================================================================================
PHASE 4 STRUCTURAL ANALYSIS DEMO
Analyzing Super Mario Bros Disassembly
================================================================================

üìä OVERALL STATISTICS
--------------------------------------------------------------------------------
Total Assembly Lines: 16352
Total Functions: 294
Total Basic Blocks: 2445
Total CFG Edges: 5294


üîç FUNCTION ANALYSIS: ProcessAreaData
================================================================================
Entry Address: 0x0CE5
Basic Blocks: 23
CFG Edges: 37

üìù ANNOTATED ASSEMBLY CODE:
--------------------------------------------------------------------------------
  0x94D9                            LDX #$02                        ; [BB_START]
  0x94DB  ProcADLoop:               STX ObjectOffset                ; [BB_START, LOOP_DO_WHILE, COND_IF_ELSE_IF, BACK_EDGE_TARGET]
  0x94DE                            LDA #$00                        ; reset flag
  0x94E0                            STA BehindAreaParserFlag      
  0x94E3                            LDY AreaDataOffset              ; get offset of area data pointer
  0x94E6                            LDA (AreaData),Y                ; get first byte of area object
  0x94E8                            CMP #$fd                        ; if end-of-area, skip all this crap
  0x94EA                            BEQ RdyDecode                 
  0x94EC                            LDA AreaObjectLength,X          ; [BB_START, COND_IF_ELSE_IF]
  0x94EF                            BPL RdyDecode                   ; if buffer not negative, branch, otherwise
  0x94F1                            INY                             ; [BB_START, COND_IF_ELSE_IF]
  0x94F2                            LDA (AreaData),Y                ; get second byte of area object
  0x94F4                            ASL                             ; check for page select bit (d7), branch if not set
  0x94F5                            BCC Chk1Row13                 
  0x94F7                            LDA AreaObjectPageSel           ; [BB_START, COND_IF_ELSE_IF]
  0x94FA                            BNE Chk1Row13                 
  0x94FC                            INC AreaObjectPageSel           ; [BB_START]
  0x94FF                            INC AreaObjectPageLoc           ; and increment page location
  0x9502  Chk1Row13:                DEY                             ; [BB_START, COND_IF_ELSE_IF]
  0x9503                            LDA (AreaData),Y                ; reread first byte of level object
  0x9505                            AND #$0f                        ; mask out high nybble
  0x9507                            CMP #$0d                        ; row 13?
  0x9509                            BNE Chk1Row14                 
  0x950B                            INY                             ; [BB_START, COND_IF_ELSE_IF]
  0x950C                            LDA (AreaData),Y              
  0x950E                            DEY                             ; decrement to get ready to read first byte
  0x950F                            AND #%01000000                  ; check for d6 set (if not, object is page control)
  0x9511                            BNE CheckRear                 
  0x9513                            LDA AreaObjectPageSel           ; [BB_START, COND_IF_ELSE_IF]
  0x9516                            BNE CheckRear                 
  0x9518                            INY                             ; [BB_START]
  0x9519                            LDA (AreaData),Y              
  0x951B                            AND #%00011111                  ; mask out all but 5 LSB and store in page control
  0x951D                            STA AreaObjectPageLoc         
  0x9520                            INC AreaObjectPageSel           ; increment page select
  0x9523                            JMP NextAObj                  
  0x9526  Chk1Row14:                CMP #$0e                        ; [BB_START, COND_IF_ELSE_IF]
  0x9528                            BNE CheckRear                 
  0x952A                            LDA BackloadingFlag             ; [BB_START, COND_IF_ELSE_IF]
  0x952D                            BNE RdyDecode                   ; to render the object (otherwise bg might not look right)
  0x952F  CheckRear:                LDA AreaObjectPageLoc           ; [BB_START, COND_IF_ELSE_IF]
  0x9532                            CMP CurrentPageLoc              ; behind current page of renderer
  0x9535                            BCC SetBehind                   ; if so branch
  0x9537  RdyDecode:                JSR DecodeAreaData              ; [BB_START]
  0x953A                            JMP ChkLength                   ; [BB_START]
  0x953D  SetBehind:                INC BehindAreaParserFlag        ; [BB_START]
  0x9540  NextAObj:                 JSR IncAreaObjOffset            ; [BB_START]
  0x9543  ChkLength:                LDX ObjectOffset                ; [BB_START, COND_IF_ELSE_IF]
  0x9546                            LDA AreaObjectLength,X          ; check object length for anything stored here
  0x9549                            BMI ProcLoopb                   ; if not, branch to handle loopback
  0x954B                            DEC AreaObjectLength,X          ; [BB_START]
  0x954E  ProcLoopb:                DEX                             ; [BB_START]
  0x954F                            BPL ProcADLoop                  ; and loopback unless exceeded buffer
  0x9551                            LDA BehindAreaParserFlag        ; [BB_START]
  0x9554                            BNE ProcessAreaData             ; branch if true to load more level data, otherwise
  0x9556                            LDA BackloadingFlag             ; [BB_START]
  0x9559                            BNE ProcessAreaData             ; branch if true to load more level data, otherwise leave
  0x955B  EndAParse:                RTS                             ; [BB_START]
--------------------------------------------------------------------------------

üìê Dominator Tree:
  Back Edges: 1
    0xD18 -> 0xCE6
üîÑ Loops Detected: 1
  Loop at 0xCE6:
    Type: DO_WHILE
    Body size: 19 blocks
    Exits: 1
    Nesting depth: 0

üîÄ Conditionals Detected: 11
  Conditional at 0xCE6:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xD10
    Nesting depth: 1
  Conditional at 0xCED:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 9 blocks
    Merge point: 0xD10
    Nesting depth: 2
  Conditional at 0xCEF:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xCF7
    Nesting depth: 3
  ... and 8 more conditionals

üèóÔ∏è  Region Structure:
  Total regions: 25
  Root region depth: 4

  Region tree (first 20 lines):
    Function(entry=3301)
      Sequence(entry=3301)
        Block(3301)
        Loop(header=3302, type=DO_WHILE)
          Sequence(entry=3302)
            Block(3302)
            Block(3309)
            Block(3311)
            Block(3315)
            Block(3317)
            Block(3319)
            Block(3324)
            Block(3329)
            Block(3331)
            Block(3337)
            Block(3339)
            Block(3341)
            Block(3344)
            Block(3345)
            Block(3346)
    ... (26 more lines)

‚ú® Structured Code:
  Fully structured: YES ‚úì
  Control flow breakdown:
    If statements: 0
    Loops: 1
    Breaks: 0
    Continues: 0
    Returns: 0
    Block statements: 42

--------------------------------------------------------------------------------

üîç FUNCTION ANALYSIS: DecodeAreaData
================================================================================
Entry Address: 0x0D28
Basic Blocks: 39
CFG Edges: 60

üìù ANNOTATED ASSEMBLY CODE:
--------------------------------------------------------------------------------
  0x955B  EndAParse:                RTS                             ; [BB_START]
  0x9568                            LDA AreaObjectLength,X          ; [BB_START, COND_IF_ELSE_IF]
  0x956B                            BMI Chk1stB                   
  0x956D                            LDY AreaObjOffsetBuffer,X       ; [BB_START]
  0x9570  Chk1stB:                  LDX #$10                        ; [BB_START, COND_IF_ELSE_IF]
  0x9572                            LDA (AreaData),Y                ; get first byte of level object again
  0x9574                            CMP #$fd                      
  0x9576                            BEQ EndAParse                   ; if end of level, leave this routine
  0x9578                            AND #$0f                        ; [BB_START, COND_IF_ELSE_IF]
  0x957A                            CMP #$0f                        ; row 15?
  0x957C                            BEQ ChkRow14                    ; if so, keep the offset of 16
  0x957E                            LDX #$08                        ; [BB_START, COND_IF_ELSE_IF]
  0x9580                            CMP #$0c                        ; row 12?
  0x9582                            BEQ ChkRow14                    ; if so, keep the offset value of 8
  0x9584                            LDX #$00                        ; [BB_START]
  0x9586  ChkRow14:                 STX $07                         ; [BB_START, COND_IF_ELSE_IF]
  0x9588                            LDX ObjectOffset                ; get object offset again
  0x958B                            CMP #$0e                        ; row 14?
  0x958D                            BNE ChkRow13                  
  0x958F                            LDA #$00                        ; [BB_START, COND_IF_ELSE_IF]
  0x9591                            STA $07                       
  0x9593                            LDA #$2e                        ; and load A with another value
  0x9595                            BNE NormObj                     ; unconditional branch
  0x9597  ChkRow13:                 CMP #$0d                        ; [BB_START, COND_IF_ELSE_IF]
  0x9599                            BNE ChkSRows                  
  0x959B                            LDA #$22                        ; [BB_START, COND_IF_ELSE_IF]
  0x959D                            STA $07                       
  0x959F                            INY                             ; get next byte
  0x95A0                            LDA (AreaData),Y              
  0x95A2                            AND #%01000000                  ; mask out all but d6 (page control obj bit)
  0x95A4                            BEQ LeavePar                    ; if d6 clear, branch to leave (we handled this earlier)
  0x95A6                            LDA (AreaData),Y                ; [BB_START, COND_IF_ELSE]
  0x95A8                            AND #%01111111                  ; mask out d7
  0x95AA                            CMP #$4b                        ; check for loop command in low nybble
  0x95AC                            BNE Mask2MSB                    ; (plus d6 set for object other than page control)
  0x95AE                            INC LoopCommand                 ; [BB_START]
  0x95B1  Mask2MSB:                 AND #%00111111                  ; [BB_START]
  0x95B3                            JMP NormObj                     ; and jump
  0x95B6  ChkSRows:                 CMP #$0c                        ; [BB_START, COND_IF_ELSE_IF]
  0x95B8                            BCS SpecObj                   
  0x95BA                            INY                             ; [BB_START, COND_IF_ELSE_IF]
  0x95BB                            LDA (AreaData),Y              
  0x95BD                            AND #%01110000                  ; mask out all but d6-d4
  0x95BF                            BNE LrgObj                      ; if any bits set, branch to handle large object
  0x95C1                            LDA #$16                        ; [BB_START]
  0x95C3                            STA $07                         ; otherwise set offset of 24 for small object
  0x95C5                            LDA (AreaData),Y                ; reload second byte of level object
  0x95C7                            AND #%00001111                  ; mask out higher nybble and jump
  0x95C9                            JMP NormObj                   
  0x95CC  LrgObj:                   STA $00                         ; [BB_START, COND_IF_ELSE_IF]
  0x95CE                            CMP #$70                        ; check for vertical pipe object
  0x95D0                            BNE NotWPipe                  
  0x95D2                            LDA (AreaData),Y                ; [BB_START, COND_IF_ELSE]
  0x95D4                            AND #%00001000                  ; mask out all but d3 (usage control bit)
  0x95D6                            BEQ NotWPipe                    ; if d3 clear, branch to get original value
  0x95D8                            LDA #$00                        ; [BB_START]
  0x95DA                            STA $00                       
  0x95DC  NotWPipe:                 LDA $00                         ; [BB_START]
  0x95DE                            JMP MoveAOId                  
  0x95E1  SpecObj:                  INY                             ; [BB_START]
  0x95E2                            LDA (AreaData),Y              
  0x95E4                            AND #%01110000                  ; get next byte and mask out all but d6-d4
  0x95E6  MoveAOId:                 LSR                             ; [BB_START]
  0x95E7                            LSR                           
  0x95E8                            LSR                           
  0x95E9                            LSR                           
  0x95EA  NormObj:                  STA $00                         ; [BB_START, COND_IF_ELSE_IF]
  0x95EC                            LDA AreaObjectLength,X          ; is there something stored here already?
  0x95EF                            BPL RunAObj                     ; if so, branch to do its particular sub
  0x95F1                            LDA AreaObjectPageLoc           ; [BB_START, COND_IF_ELSE_IF]
  0x95F4                            CMP CurrentPageLoc              ; same page as the renderer, and if so, branch
  0x95F7                            BEQ InitRear                  
  0x95F9                            LDY AreaDataOffset              ; [BB_START, COND_IF_ELSE_IF]
  0x95FC                            LDA (AreaData),Y                ; and reload first byte
  0x95FE                            AND #%00001111                
  0x9600                            CMP #$0e                        ; row 14?
  0x9602                            BNE LeavePar                  
  0x9604                            LDA BackloadingFlag             ; [BB_START, COND_IF_ELSE]
  0x9607                            BNE StrAObj                     ; if set, branch to render object, else leave
  0x9609  LeavePar:                 RTS                             ; [BB_START]
  0x960A  InitRear:                 LDA BackloadingFlag             ; [BB_START, COND_IF_ELSE]
  0x960D                            BEQ BackColC                    ; branch to column-wise check
  0x960F                            LDA #$00                        ; [BB_START]
  0x9611                            STA BackloadingFlag             ; behind-renderer flags and leave
  0x9614                            STA BehindAreaParserFlag      
  0x9617                            STA ObjectOffset              
  0x961A  LoopCmdE:                 RTS                             ; [BB_START]
  0x961B  BackColC:                 LDY AreaDataOffset              ; [BB_START, COND_IF_ELSE_IF]
  0x961E                            LDA (AreaData),Y              
  0x9620                            AND #%11110000                  ; mask out low nybble and move high to low
  0x9622                            LSR                           
  0x9623                            LSR                           
  0x9624                            LSR                           
  0x9625                            LSR                           
  0x9626                            CMP CurrentColumnPos            ; is this where we're at?
  0x9629                            BNE LeavePar                    ; if not, branch to leave
  0x962B  StrAObj:                  LDA AreaDataOffset              ; [BB_START]
  0x962E                            STA AreaObjOffsetBuffer,X     
  0x9631                            JSR IncAreaObjOffset            ; do sub to increment to next object data
  0x9634  RunAObj:                  LDA $00                         ; [BB_START]
  0x9636                            CLC                             ; then use the jump engine with current contents of A
  0x9637                            ADC $07                       
  0x9639                            JSR JumpEngine                
  0x963C                            LDY AreaObjOffsetBuffer,X       ; [BB_START, COND_IF_ELSE]
  0x963F                            INY                             ; load second byte
  0x9640                            LDA (AreaData),Y              
  0x9642                            PHA                             ; save in stack for now
  0x9643                            AND #%01000000                
  0x9645                            BNE Alter2                      ; branch if d6 is set
  0x9647                            PLA                             ; [BB_START]
  0x9648                            PHA                             ; pull and push offset to copy to A
  0x9649                            AND #%00001111                  ; mask out high nybble and store as
  0x964B                            STA TerrainControl              ; new terrain height type bits
  0x964E                            PLA                           
  0x964F                            AND #%00110000                  ; pull and mask out all but d5 and d4
  0x9651                            LSR                             ; move bits to lower nybble and store
  0x9652                            LSR                             ; as new background scenery bits
  0x9653                            LSR                           
  0x9654                            LSR                           
  0x9655                            STA BackgroundScenery           ; then leave
  0x9658                            RTS                           
  0x9659  Alter2:                   PLA                             ; [BB_START, COND_IF_ELSE]
  0x965A                            AND #%00000111                  ; mask out all but 3 LSB
  0x965C                            CMP #$04                        ; if four or greater, set color control bits
  0x965E                            BCC SetFore                     ; and nullify foreground scenery bits
  0x9660                            STA BackgroundColorCtrl         ; [BB_START]
  0x9663                            LDA #$00                      
  0x9665  SetFore:                  STA ForegroundScenery           ; [BB_START]
  0x9668                            RTS                           
--------------------------------------------------------------------------------

üìê Dominator Tree:
  Back Edges: 0
üîÄ Conditionals Detected: 21
  Conditional at 0xD28:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xD2B
    Nesting depth: 0
  Conditional at 0xD2B:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 35 blocks
    Merge point: none
    Nesting depth: 1
  Conditional at 0xD2F:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xD36
    Nesting depth: 2
  ... and 18 more conditionals

üèóÔ∏è  Region Structure:
  Total regions: 41
  Root region depth: 4

  Region tree (first 20 lines):
    Function(entry=3368)
      Sequence(entry=3368)
        Block(3358)
        If(header=3368, type=IF_ELSE_IF)
        Then:
          Block(3371)
        Else:
          Sequence(entry=3370)
            Block(3370)
            Block(3371)
        Block(3368)
        Block(3370)
        Block(3371)
        Block(3375)
        Block(3378)
        Block(3381)
        Block(3382)
        Block(3386)
        Block(3390)
        Block(3392)
    ... (28 more lines)

‚ú® Structured Code:
  Fully structured: YES ‚úì
  Control flow breakdown:
    If statements: 1
    Loops: 0
    Breaks: 0
    Continues: 0
    Returns: 0
    Block statements: 42

--------------------------------------------------------------------------------

üéØ PHASE 4 SUMMARY STATISTICS
================================================================================
Total Loops Detected: 81
  - While loops: 0
  - Do-while loops: 55
  - Infinite loops: 0
  - Multi-exit loops: 26

Total Conditionals Detected: 1607
  - Simple IF: 17
  - IF-ELSE: 366
  - IF-ELSE-IF: 1224

Total Regions Formed: 4174
  - Block regions: 3610
  - Loop regions: 77
  - Conditional regions: 193
  - Sequence regions: 0

Goto Elimination:
  - Fully structured functions: 294 / 294
  - Functions with remaining gotos: 0

Structured Control Flow Statistics:
  - If statements: 221
  - Loop statements: 81
  - Break statements: 0
  - Continue statements: 0
  - Return statements: 0
  - Block statements: 5034
  - Remaining gotos: 0

================================================================================

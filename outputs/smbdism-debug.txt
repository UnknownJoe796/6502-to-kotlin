Function Dump_Sq2_Regs
  Inputs: [X, Y]
  Outputs: []
    Line 15150: Dump_Sq2_Regs: 

Function AlterAreaAttributes
  Inputs: [X]
  Outputs: []
                  Line 3535: AlterAreaAttributes: 
                    Branch exit: Line 3554: Alter2: PLA 
                    Line 3542: PLA 
                    Line 3554: Alter2: PLA 
                      Branch exit: Line 3560: SetFore: STA ForegroundScenery  ; otherwise set new foreground scenery bits
                      Line 3558: STA BackgroundColorCtrl
                      Line 3560: SetFore: STA ForegroundScenery  ; otherwise set new foreground scenery bits

Function InitFireworks
  Inputs: [X]
  Outputs: []
        Line 8633: InitFireworks: 
          Branch exit: Line 8671: ExitFWk: RTS 
          Line 8636: LDA #$20                        ; otherwise reset timer
            Line 8640: StarFChk: DEY 
              Branch exit: Line 8640: StarFChk: DEY 
              Line 8644: LDA Enemy_X_Position,Y
          Line 8671: ExitFWk: RTS 

Function AutoControlPlayer
  Inputs: [A]
  Outputs: []
  Line 5554: AutoControlPlayer: 

Function PrimaryGameSetup
  Inputs: []
  Outputs: []
    Line 2716: PrimaryGameSetup: 
      Line 2724: SecondaryGameSetup:  (as a call, not in function)

Function GetPipeHeight
  Inputs: [X]
  Outputs: []
    Line 3885: GetPipeHeight: 

Function GetPlayerAnimSpeed
  Inputs: []
  Outputs: []
      Line 6194: GetPlayerAnimSpeed: 
        Branch exit: Line 6210: SetRunSpd: STA RunningSpeed     ; store zero or running speed here
        Line 6199: INY                             ; otherwise increment Y
          Branch exit: Line 6203: ChkSkid: LDA SavedJoypadBits    ; get controller bits
          Line 6202: INY                             ; otherwise increment Y again
          Line 6203: ChkSkid: LDA SavedJoypadBits    ; get controller bits
            Branch exit: Line 6220: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset
            Line 6206: AND #$03                        ; mask out all others except left and right
              Branch exit: Line 6212: ProcSkid: LDA Player_XSpeedAbsolute; check player's walking/running speed
              Line 6209: LDA #$00                        ; otherwise set zero value here
              Line 6212: ProcSkid: LDA Player_XSpeedAbsolute; check player's walking/running speed
                Branch exit: Line 6220: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset
                Line 6215: LDA PlayerFacingDir
        Line 6210: SetRunSpd: STA RunningSpeed     ; store zero or running speed here
          Branch exit: Line 6220: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset
        Line 6220: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset

Function WriteTopScore
  Inputs: []
  Outputs: []
    Line 1627: WriteTopScore: 

Function SetStun
  Inputs: [X]
  Outputs: []
          Line 12465: SetStun: LDA Enemy_State,X      ; load enemy state
            Branch exit: Line 12477: SetWYSpd: LDA #$ff              ; change the vertical speed
            Line 12474: LDA #$fd                        ; set default vertical speed
              Branch exit: Line 12478: SetNotW: STA Enemy_Y_Speed,X    ; set vertical speed now
            Line 12477: SetWYSpd: LDA #$ff              ; change the vertical speed
            Line 12478: SetNotW: STA Enemy_Y_Speed,X    ; set vertical speed now
              Branch exit: Line 12483: ChkBBill: LDA Enemy_ID,X
              Line 12482: INY                             ; increment Y if not
              Line 12483: ChkBBill: LDA Enemy_ID,X
                Branch exit: Line 12489: NoCDirF: DEY                    ; decrement and use as offset
                Line 12486: CMP #BulletBill_FrenzyVar       ; check for bullet bill (frenzy variant)
                  Branch exit: Line 12489: NoCDirF: DEY                    ; decrement and use as offset
                  Line 12488: STY Enemy_MovingDir,X           ; store as moving direction
                Line 12489: NoCDirF: DEY                    ; decrement and use as offset

Function RelativeBlockPosition
  Inputs: [X]
  Outputs: []
    Line 14790: RelativeBlockPosition: 

Function ProcLPlatCollisions
  Inputs: [Y, X]
  Outputs: []
    Line 11781: ProcLPlatCollisions: 
      Branch exit: Line 11792: ChkForTopCollision: 
      Line 11787: LDA Player_Y_Speed              ; check to see if player's vertical speed is moving down
        Branch exit: Line 11792: ChkForTopCollision: 
        Line 11789: LDA #$01                        ; otherwise, set vertical
      Line 11792: ChkForTopCollision: 
        Branch exit: Line 11815: PlatformSideCollisions: 
        Line 11798: LDA Player_Y_Speed
          Branch exit: Line 11815: PlatformSideCollisions: 
          Line 11800: LDA $00                         ; get saved bounding box counter from earlier
            Branch exit: Line 11808: SetCollisionFlag: 
            Line 11804: CPY #$2c                        ; as contents of collision flag
              Branch exit: Line 11808: SetCollisionFlag: 
              Line 11806: TXA                             ; otherwise use enemy object buffer offset
            Line 11808: SetCollisionFlag: 

Function BrickWithCoins
  Inputs: []
  Outputs: []
    Line 4182: BrickWithCoins: 

Function PlayerHammerCollision
  Inputs: [X]
  Outputs: []
    Line 11202: PlayerHammerCollision: 
      Branch exit: Line 11232: ExPHC: RTS 
      Line 11206: LDA TimerControl                ; if either master timer control
        Branch exit: Line 11232: ExPHC: RTS 
        Line 11209: TXA 
          Branch exit: Line 11230: ClHCol: LDA #$00                ; clear collision flag
          Line 11218: LDA Misc_Collision_Flag,X       ; otherwise read collision flag
            Branch exit: Line 11232: ExPHC: RTS 
            Line 11220: LDA #$01
              Branch exit: Line 11232: ExPHC: RTS 
              Line 11229: JMP InjurePlayer                ; otherwise jump to hurt player, do not return
                Branch exit: Line 11400: InjurePlayer: 
          Line 11230: ClHCol: LDA #$00                ; clear collision flag
      Line 11232: ExPHC: RTS 

Function ProcessPlayerAction
  Inputs: []
  Outputs: []
    Line 14584: ProcessPlayerAction: 
      Branch exit: Line 14633: ActionClimbing: 
      Line 14588: CMP #$02
        Branch exit: Line 14623: ActionFalling: 
        Line 14590: CMP #$01
          Branch exit: Line 14600: ProcOnGroundActs: 
          Line 14592: LDA SwimmingFlag
            Branch exit: Line 14640: ActionSwimming: 
            Line 14594: LDY #$06                        ; load offset for crouching
              Branch exit: Line 14616: NonAnimatedActs: 
              Line 14597: LDY #$00                        ; otherwise load offset for jumping
                Branch exit: Line 14616: NonAnimatedActs: 

Function InitScreen
  Inputs: []
  Outputs: []
        Line 1382: InitScreen: 
          Branch exit: Line 1417: NextSubtask: JMP IncSubtask     ; move onto next task
          Line 1387: LDX #$03                        ; into buffer pointer
            Branch exit: Line 1416: SetVRAMAddr_A: STX VRAM_Buffer_AddrCtrl; store offset into buffer control

Function LargePlatformBoundBox
  Inputs: [X, A]
  Outputs: []
    Line 12824: LargePlatformBoundBox: 
      Branch exit: Line 12840: MoveBoundBoxOffscreen: 
      Line 12830: 

Function InitializeGame
  Inputs: [A]
  Outputs: []
        Line 2648: InitializeGame: 
          Line 2652: ClrSndLoop: STA SoundMemory,Y   ; clear out memory used
            Branch exit: Line 2652: ClrSndLoop: STA SoundMemory,Y   ; clear out memory used
            Line 2655: LDA #$18                        ; set demo timer
              Line 2659: InitializeArea:  (as a call, not in function)

Function BlockBufferChk_Enemy
  Inputs: [A, X]
  Outputs: [ZeroFlag]
  Line 12997: BlockBufferChk_Enemy: 
    Branch exit: Line 13021: BBChk_E: JSR BlockBufferCollision; do collision detection subroutine for sprite object

Function ProcEnemyCollisions
  Inputs: [Y, X, $01]
  Outputs: []
    Line 11622: ProcEnemyCollisions: 
      Branch exit: Line 11654: ExitProcessEColl: 
      Line 11627: LDA Enemy_State,X
        Branch exit: Line 11657: ProcSecondEnemyColl: 
        Line 11630: LDA Enemy_ID,X                  ; check second enemy identifier for hammer bro
          Branch exit: Line 11654: ExitProcessEColl: 
          Line 11633: LDA Enemy_State,Y               ; check first enemy state for d7 set
            Branch exit: Line 11641: ShellCollisions: 
            Line 11636: LDA #$06
            Line 11641: ShellCollisions: 

Function VerticalPipe
  Inputs: [$00, Y, X, $07, $06, CarryFlag]
  Outputs: []
      Line 3842: VerticalPipe: 
        Branch exit: Line 3850: WarpPipe: TYA                   ; save value in stack
        Line 3846: INY 
        Line 3850: WarpPipe: TYA                   ; save value in stack
          Branch exit: Line 3874: DrawPipe: PLA                   ; get value saved earlier and use as Y
          Line 3855: LDY AreaObjectLength,X          ; if on second column of pipe, branch
            Branch exit: Line 3874: DrawPipe: PLA                   ; get value saved earlier and use as Y
            Line 3857: JSR FindEmptyEnemySlot          ; check for an empty moving data buffer space
              Branch exit: Line 3874: DrawPipe: PLA                   ; get value saved earlier and use as Y
              Line 3859: JSR GetAreaObjXPosition         ; get horizontal pixel coordinate
          Line 3874: DrawPipe: PLA                   ; get value saved earlier and use as Y
            Branch exit: Line 4247: RenderUnderPart: 

Function LoadControlRegs
  Inputs: []
  Outputs: []
    Line 15925: LoadControlRegs: 
      Branch exit: Line 15931: NotECstlM: LDA AreaMusicBuffer
      Line 15929: LDA #$04                        ; this value is only used for win castle music
        Branch exit: Line 15937: AllMus: LDX #$82                ; load contents of other sound regs for square 2
      Line 15931: NotECstlM: LDA AreaMusicBuffer
        Branch exit: Line 15936: WaterMus: LDA #$28              ; this value is used for water music and all other event music
        Line 15934: LDA #$08                        ; this is the default value for all other music
          Branch exit: Line 15937: AllMus: LDX #$82                ; load contents of other sound regs for square 2
        Line 15936: WaterMus: LDA #$28              ; this value is used for water music and all other event music
      Line 15937: AllMus: LDX #$82                ; load contents of other sound regs for square 2

Function FirebarSpin
  Inputs: [A, X]
  Outputs: [A]
    Line 10638: FirebarSpin: 
      Branch exit: Line 10651: SpinCounterClockwise: 
      Line 10642: LDY #$18                        ; possibly residual ldy

Function FindPlayerAction
  Inputs: [A]
  Outputs: []
  Line 14473: FindPlayerAction: 
    Branch exit: Line 14485: PlayerGfxProcessing: 

Function BlockBufferColli_Head
  Inputs: []
  Outputs: [ZeroFlag]
            Line 13044: BlockBufferColli_Head: 
              Line 13048: BlockBufferColli_Side:  (as a call, not in function)

Function ImposeGravityBlock
  Inputs: []
  Outputs: []
        Line 7659: ImposeGravityBlock: 

Function ScrollScreen
  Inputs: [Y]
  Outputs: []
                Line 5401: ScrollScreen: 
                  Branch exit: Line 5427: ChkPOffscr: LDX #$00            ; set X for player offset

Function WriteBlockMetatile
  Inputs: [A]
  Outputs: []
      Line 2035: WriteBlockMetatile: 
        Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
        Line 2039: LDY #$00                        ; load offset for brick metatile w/ line
          Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
          Line 2042: CMP #$51
            Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
            Line 2044: INY                             ; increment offset for brick metatile w/o line
              Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
              Line 2047: CMP #$52
                Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
                Line 2049: INY                             ; if any other metatile, increment offset for empty block
        Line 2050: UseBOffset: TYA                 ; put Y in A
          Line 2054: MoveVOffset: DEY                ; decrement vram buffer offset (as a call, not in function)

Function ReadPortBits
  Inputs: [A, X]
  Outputs: []
      Line 2428: ReadPortBits: LDY #$08
        Line 2429: PortLoop: PHA                   ; push previous bit onto stack
          Branch exit: Line 2429: PortLoop: PHA                   ; push previous bit onto stack
          Line 2439: STA SavedJoypadBits,X           ; save controller status here always
            Branch exit: Line 2448: Save8Bits: PLA 
            Line 2444: PLA 
            Line 2448: Save8Bits: PLA 

Function SecondaryGameSetup
  Inputs: []
  Outputs: []
      Line 2724: SecondaryGameSetup: 
        Line 2728: ClearVRLoop: STA VRAM_Buffer1-1,Y; clear buffer at $0300-$03ff
          Branch exit: Line 2728: ClearVRLoop: STA VRAM_Buffer1-1,Y; clear buffer at $0300-$03ff
          Line 2731: STA GameTimerExpiredFlag        ; clear game timer exp flag
            Line 2749: ShufAmtLoop: LDA DefaultSprOffsets,X
              Branch exit: Line 2749: ShufAmtLoop: LDA DefaultSprOffsets,X
              Line 2753: LDY #$03                        ; set up sprite #0
                Line 2754: ISpr0Loop: LDA Sprite0Data,Y
                  Branch exit: Line 2754: ISpr0Loop: LDA Sprite0Data,Y
                  Line 2758: JSR DoNothing2                  ; these jsrs doesn't do anything useful

Function InitNormalEnemy
  Inputs: [X]
  Outputs: []
      Line 8165: InitNormalEnemy: 
        Branch exit: Line 8170: GetESpd: LDA NormalXSpdData,Y   ; get appropriate horizontal speed
        Line 8169: DEY                             ; if not set, decrement offset
        Line 8170: GetESpd: LDA NormalXSpdData,Y   ; get appropriate horizontal speed

Function UpdateNumber
  Inputs: []
  Outputs: []
  Line 7112: UpdateNumber: 
    Branch exit: Line 7119: NoZSup: LDX ObjectOffset        ; get enemy object buffer offset
    Line 7117: LDA #$24
    Line 7119: NoZSup: LDX ObjectOffset        ; get enemy object buffer offset

Function GetPlayerOffscreenBits
  Inputs: [$00]
  Outputs: []
    Line 14820: GetPlayerOffscreenBits: 
      Branch exit: Line 14868: GetOffScreenBitsSet: 

Function InitBulletBill
  Inputs: [X]
  Outputs: []
    Line 8233: InitBulletBill: 

Function GameCoreRoutine
  Inputs: []
  Outputs: []
                                                                                                                                                                                Line 5300: GameCoreRoutine: 
                                                                                                                                                                                  Branch exit: Line 5310: GameEngine: 
                                                                                                                                                                                  Line 5308: RTS 

Function Hole_Empty
  Inputs: [CarryFlag]
  Outputs: []
      Line 4214: Hole_Empty: 
        Branch exit: Line 4240: NoWhirlP: LDX AreaType          ; get appropriate metatile, then
        Line 4217: LDA AreaType                    ; check for water type level
          Branch exit: Line 4240: NoWhirlP: LDX AreaType          ; get appropriate metatile, then
          Line 4219: LDX Whirlpool_Offset            ; get offset for data used by cannons and whirlpools
            Branch exit: Line 4239: StrWOffset: STX Whirlpool_Offset; save new offset here
            Line 4238: LDX #$00                        ; otherwise initialize it
            Line 4239: StrWOffset: STX Whirlpool_Offset; save new offset here
        Line 4240: NoWhirlP: LDX AreaType          ; get appropriate metatile, then

Function VictoryModeSubroutines
  Inputs: []
  Outputs: []
    Line 1121: VictoryModeSubroutines: 
      Line 1124: 
        Line 1133: SetupVictoryMode:  (as a call, not in function)

Function ExitPipe
  Inputs: []
  Outputs: []
          Line 3809: ExitPipe: 
            Line 3814: RenderSidewaysPipe:  (as a call, not in function)

Function SetFlameTimer
  Inputs: []
  Outputs: [A]
      Line 10314: SetFlameTimer: 

Function EnemyMovementSubs
  Inputs: [X]
  Outputs: []
    Line 9081: EnemyMovementSubs: 
      Line 9084: 
        Line 9109: NoMoveCode:  (as a call, not in function)

Function XMovingPlatform
  Inputs: [X]
  Outputs: []
    Line 10926: XMovingPlatform: 
      Branch exit: Line 10947: ExXMP: RTS                      ; and we are done here
      Line 10932: 
        Line 10933: PositionPlayerOnHPlat:  (as a call, not in function)
      Line 10947: ExXMP: RTS                      ; and we are done here (as a call, not in function)

Function SixSpriteStacker
  Inputs: [A, Y, $02]
  Outputs: []
    Line 13161: SixSpriteStacker: 
      Line 13163: StkLp: STA Sprite_Data,Y        ; store X or Y coordinate into OAM data
        Branch exit: Line 13163: StkLp: STA Sprite_Data,Y        ; store X or Y coordinate into OAM data
        Line 13172: LDY $02                         ; get saved OAM data offset and leave

Function InitLakitu
  Inputs: []
  Outputs: []
    Line 8253: InitLakitu: 
      Branch exit: Line 8263: KillLakitu: 
      Line 8256: 
        Line 8257: SetupLakitu:  (as a call, not in function)

Function UpdateTopScore
  Inputs: []
  Outputs: []
    Line 2613: UpdateTopScore: 
      Line 2618: TopScoreCheck:  (as a call, not in function)

Function RenderAttributeTables
  Inputs: []
  Outputs: []
    Line 1894: RenderAttributeTables: 
      Branch exit: Line 1904: SetATHigh: AND #%00000100       ; mask out all other bits
      Line 1903: EOR #%00000100                  ; otherwise invert d2
      Line 1904: SetATHigh: AND #%00000100       ; mask out all other bits
        Line 1914: AttribLoop: LDA $00
          Branch exit: Line 1914: AttribLoop: LDA $00
          Line 1934: STA VRAM_Buffer2,Y              ; put null terminator at the end

Function LargeLiftDown
  Inputs: [X]
  Outputs: []
    Line 8947: LargeLiftDown: 

Function MoveFallingPlatform
  Inputs: []
  Outputs: []
      Line 7604: MoveFallingPlatform: 

Function SetFreq_Tri
  Inputs: [A]
  Outputs: []
          Line 15162: SetFreq_Tri: 
            Branch exit: Line 15140: Dump_Freq_Regs: 
            Line 15165: 
              Line 15168: SwimStompEnvelopeData: 
                Line 15172: PlayFlagpoleSlide:  (as a call, not in function)

Function GameTimerFireworks
  Inputs: [X]
  Outputs: []
                Line 10465: GameTimerFireworks: 
                  Branch exit: Line 10477: SetFWC: STA FireworksCounter    ; set fireworks counter here
                  Line 10470: LDY #$03                        ; otherwise load new value for state
                    Branch exit: Line 10477: SetFWC: STA FireworksCounter    ; set fireworks counter here
                    Line 10473: LDY #$00                        ; otherwise load one more potential value for state
                      Branch exit: Line 10477: SetFWC: STA FireworksCounter    ; set fireworks counter here
                      Line 10476: LDA #$ff                        ; otherwise set value for no fireworks
                  Line 10477: SetFWC: STA FireworksCounter    ; set fireworks counter here

Function ResetPalStar
  Inputs: []
  Outputs: []
    Line 5798: ResetPalStar: 

Function SetupGameOver
  Inputs: []
  Outputs: []
        Line 2955: SetupGameOver: 

Function MovePlatformUp
  Inputs: [X]
  Outputs: []
      Line 7676: MovePlatformUp: 
        Branch exit: Line 7685: SetDplSpd: STA $00              ; save downward movement amount here
        Line 7684: LDA #$09                        ; residual code
        Line 7685: SetDplSpd: STA $00              ; save downward movement amount here

Function TerminateGame
  Inputs: [CarryFlag]
  Outputs: []
      Line 2975: TerminateGame: 
        Branch exit: Line 2989: ContinueGame: 
        Line 2980: LDA WorldNumber                 ; otherwise put world number of current

Function RunGameOver
  Inputs: []
  Outputs: []
    Line 2967: RunGameOver: 
      Branch exit: Line 2975: TerminateGame: 
      Line 2973: LDA ScreenTimer                 ; if not pressed, wait for
        Branch exit: Line 3001: GameIsOn: RTS 
      Line 2975: TerminateGame:  (as a call, not in function)

Function BlockObjMT_Updater
  Inputs: []
  Outputs: []
    Line 7501: BlockObjMT_Updater: 
      Line 7503: UpdateLoop: STX ObjectOffset    ; set offset here
        Branch exit: Line 7520: NextBUpd: DEX                   ; decrement block object offset
        Line 7506: LDA Block_RepFlag,X             ; if flag for block object already clear,
          Branch exit: Line 7520: NextBUpd: DEX                   ; decrement block object offset
          Line 7508: LDA Block_BBuf_Low,X            ; get low byte of block buffer
        Line 7520: NextBUpd: DEX                   ; decrement block object offset
          Branch exit: Line 7503: UpdateLoop: STX ObjectOffset    ; set offset here
          Line 7522: RTS                             ; then leave

Function ScrollLockObject_Warp
  Inputs: []
  Outputs: []
    Line 3565: ScrollLockObject_Warp: 
      Branch exit: Line 3574: WarpNum: TXA 
      Line 3569: INX                             ; if world number > 1, increment for next warp zone (5)
        Branch exit: Line 3574: WarpNum: TXA 
        Line 3573: INX                             ; (8-7-6) and move on
      Line 3574: WarpNum: TXA 
        Line 3580: ScrollLockObject:  (as a call, not in function)

Function null
  Inputs: []
  Outputs: []
  Line 0:                                 ; SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
    Line 673: Start: 
      Line 680: VBlank1: LDA PPU_STATUS         ; wait two frames
        Branch exit: Line 680: VBlank1: LDA PPU_STATUS         ; wait two frames
        Line 682: VBlank2: LDA PPU_STATUS
          Branch exit: Line 682: VBlank2: LDA PPU_STATUS
          Line 684: LDY #ColdBootOffset             ; load default cold boot pointer
            Line 686: WBootCheck: LDA TopScoreDisplay,X; check each score digit in the top score
              Branch exit: Line 695: ColdBoot: JSR InitializeMemory  ; clear memory using pointer in Y
              Line 689: DEX 
                Branch exit: Line 686: WBootCheck: LDA TopScoreDisplay,X; check each score digit in the top score
                Line 691: LDA WarmBootValidation          ; second checkpoint, check to see if
                  Branch exit: Line 695: ColdBoot: JSR InitializeMemory  ; clear memory using pointer in Y
                  Line 694: LDY #WarmBootOffset             ; if passed both, load warm boot pointer
              Line 695: ColdBoot: JSR InitializeMemory  ; clear memory using pointer in Y
                Line 711: EndlessLoop: JMP EndlessLoop    ; endless loop, need I say more?
                  Branch exit: Line 711: EndlessLoop: JMP EndlessLoop    ; endless loop, need I say more?

Function PosPlatform
  Inputs: [X, Y]
  Outputs: []
        Line 8987: PosPlatform: 

Function StopSquare2Sfx
  Inputs: []
  Outputs: []
    Line 15422: StopSquare2Sfx: 

Function ChainObj
  Inputs: [$00]
  Outputs: []
  Line 4038: ChainObj: 
    Branch exit: Line 4048: ColObj: LDY #$00                ; column length of 1

Function HandleChangeSize
  Inputs: []
  Outputs: []
      Line 14692: HandleChangeSize: 
        Branch exit: Line 14703: GorSLog: LDA PlayerSize         ; get player's size
        Line 14697: INY                             ; increment frame control
          Branch exit: Line 14702: CSzNext: STY PlayerAnimCtrl     ; store proper frame control
          Line 14700: LDY #$00                        ; otherwise initialize both grow/shrink flag
          Line 14702: CSzNext: STY PlayerAnimCtrl     ; store proper frame control
        Line 14703: GorSLog: LDA PlayerSize         ; get player's size
          Branch exit: Line 14715: ShrinkPlayer: 
          Line 14705: LDA ChangeSizeOffsetAdder,Y     ; get offset adder based on frame control as offset

Function DecodeAreaData
  Inputs: [X]
  Outputs: []
    Line 3367: DecodeAreaData: 
      Branch exit: Line 3371: Chk1stB: LDX #$10               ; load offset of 16 for special row 15
      Line 3370: LDY AreaObjOffsetBuffer,X       ; if not, get offset from buffer
      Line 3371: Chk1stB: LDX #$10               ; load offset of 16 for special row 15
        Branch exit: Line 3358: EndAParse: RTS 
        Line 3375: AND #$0f                        ; otherwise, mask out low nybble
          Branch exit: Line 3382: ChkRow14: STX $07               ; store whatever value we just loaded here
          Line 3378: LDX #$08                        ; otherwise load offset of 8 for special row 12
            Branch exit: Line 3382: ChkRow14: STX $07               ; store whatever value we just loaded here
            Line 3381: LDX #$00                        ; otherwise nullify value by default
          Line 3382: ChkRow14: STX $07               ; store whatever value we just loaded here
            Branch exit: Line 3390: ChkRow13: CMP #$0d              ; row 13?
            Line 3386: LDA #$00                        ; if so, load offset with $00
              Branch exit: Line 3433: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
            Line 3390: ChkRow13: CMP #$0d              ; row 13?
              Branch exit: Line 3405: ChkSRows: CMP #$0c              ; row 12-15?
              Line 3392: LDA #$22                        ; if so, load offset with 34
                Branch exit: Line 3446: LeavePar: RTS 
                Line 3398: LDA (AreaData),Y                ; otherwise, get byte again
                  Branch exit: Line 3403: Mask2MSB: AND #%00111111        ; mask out d7 and d6
                  Line 3402: INC LoopCommand                 ; if loop command, set loop command flag
                  Line 3403: Mask2MSB: AND #%00111111        ; mask out d7 and d6
                    Branch exit: Line 3433: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
              Line 3405: ChkSRows: CMP #$0c              ; row 12-15?
                Branch exit: Line 3426: SpecObj: INY                    ; branch here for rows 12-15
                Line 3407: INY                             ; if not, get second byte of level object
                  Branch exit: Line 3416: LrgObj: STA $00                 ; store value here (branch for large objects)
                  Line 3411: LDA #$16
                    Branch exit: Line 3433: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
                  Line 3416: LrgObj: STA $00                 ; store value here (branch for large objects)
                    Branch exit: Line 3424: NotWPipe: LDA $00               ; get value and jump ahead
                    Line 3419: LDA (AreaData),Y                ; if not, reload second byte
                      Branch exit: Line 3424: NotWPipe: LDA $00               ; get value and jump ahead
                      Line 3422: LDA #$00                        ; otherwise, nullify value for warp pipe
                    Line 3424: NotWPipe: LDA $00               ; get value and jump ahead
                      Branch exit: Line 3429: MoveAOId: LSR                   ; move d6-d4 to lower nybble
                Line 3426: SpecObj: INY                    ; branch here for rows 12-15
                Line 3429: MoveAOId: LSR                   ; move d6-d4 to lower nybble
            Line 3433: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
              Branch exit: Line 3466: RunAObj: LDA $00                ; get stored value and add offset to it
              Line 3436: LDA AreaObjectPageLoc           ; otherwise check to see if the object we've loaded is on the
                Branch exit: Line 3447: InitRear: LDA BackloadingFlag   ; check backloading flag to see if it's been initialized
                Line 3439: LDY AreaDataOffset              ; if not, get old offset of level pointer
                  Branch exit: Line 3446: LeavePar: RTS 
                  Line 3444: LDA BackloadingFlag             ; if so, check backloading flag
                    Branch exit: Line 3463: StrAObj: LDA AreaDataOffset     ; if so, load area obj offset and store in buffer
                Line 3447: InitRear: LDA BackloadingFlag   ; check backloading flag to see if it's been initialized
                  Branch exit: Line 3454: BackColC: LDY AreaDataOffset    ; get first byte again
                  Line 3449: LDA #$00                        ; if not, initialize both backloading and
                    Line 3453: LoopCmdE: RTS  (as a call, not in function)
                  Line 3454: BackColC: LDY AreaDataOffset    ; get first byte again
                    Branch exit: Line 3446: LeavePar: RTS 
                Line 3463: StrAObj: LDA AreaDataOffset     ; if so, load area obj offset and store in buffer
              Line 3466: RunAObj: LDA $00                ; get stored value and add offset to it
                Line 3470: 
                  Line 3535: AlterAreaAttributes:  (as a call, not in function)
            Line 3446: LeavePar: RTS 

Function GetFireballBoundBox
  Inputs: [X]
  Outputs: []
      Line 12779: GetFireballBoundBox: 
        Branch exit: Line 12793: FBallB: JSR BoundingBoxCore     ; get bounding box coordinates
        Line 12786: 
          Line 12787: GetMiscBoundBox:  (as a call, not in function)
        Line 12793: FBallB: JSR BoundingBoxCore     ; get bounding box coordinates (as a call, not in function)

Function PlaySqu1Sfx
  Inputs: []
  Outputs: []
    Line 15134: PlaySqu1Sfx: 
      Line 15137: SetFreq_Squ1:  (as a call, not in function)

Function NoFrenzyCode
  Inputs: []
  Outputs: []
        Line 8846: NoFrenzyCode: 

Function ImposeFriction
  Inputs: [A]
  Outputs: [A]
    Line 6226: ImposeFriction: 
      Branch exit: Line 6234: JoypFrict: LSR                  ; put right controller bit into carry
      Line 6230: LDA Player_X_Speed
        Branch exit: Line 6264: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave
        Line 6232: BPL RghtFrict                   ; if player moving to the right, branch to slow
          Branch exit: Line 6248: RghtFrict: LDA Player_X_MoveForce; load value set here
          Line 6233: BMI LeftFrict                   ; otherwise logic dictates player moving left, branch to slow
            Branch exit: Line 6236: LeftFrict: LDA Player_X_MoveForce; load value set here
      Line 6234: JoypFrict: LSR                  ; put right controller bit into carry
        Branch exit: Line 6248: RghtFrict: LDA Player_X_MoveForce; load value set here
      Line 6236: LeftFrict: LDA Player_X_MoveForce; load value set here
        Branch exit: Line 6259: XSpdSign: CMP #$00              ; if player not moving or moving to the right,
        Line 6245: LDA MaximumRightSpeed           ; otherwise set preset value as horizontal speed
          Branch exit: Line 6264: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave
      Line 6248: RghtFrict: LDA Player_X_MoveForce; load value set here
        Branch exit: Line 6259: XSpdSign: CMP #$00              ; if player not moving or moving to the right,
        Line 6257: LDA MaximumLeftSpeed            ; otherwise set preset value as horizontal speed
      Line 6259: XSpdSign: CMP #$00              ; if player not moving or moving to the right,
        Branch exit: Line 6264: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave
        Line 6261: EOR #$ff
      Line 6264: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave

Function FireballBGCollision
  Inputs: [X]
  Outputs: []
    Line 12725: FireballBGCollision: 
      Branch exit: Line 12746: ClearBounceFlag: 
      Line 12729: JSR BlockBufferChk_FBall        ; do fireball to background collision detection on bottom of it
        Branch exit: Line 12746: ClearBounceFlag: 
        Line 12731: JSR ChkForNonSolids             ; check for non-solid metatiles
          Branch exit: Line 12746: ClearBounceFlag: 
          Line 12733: LDA Fireball_Y_Speed,X          ; if fireball's vertical speed set to move upwards,
            Branch exit: Line 12751: InitFireballExplode: 
            Line 12735: LDA FireballBouncingFlag,X      ; if bouncing flag already set,
              Branch exit: Line 12751: InitFireballExplode: 
              Line 12737: LDA #$fd

Function CyclePlayerPalette
  Inputs: [A]
  Outputs: []
        Line 5786: CyclePlayerPalette: 

Function VariableObjOfsRelPos
  Inputs: [X, A]
  Outputs: [X]
  Line 14799: VariableObjOfsRelPos: 

Function ProcSwimmingB
  Inputs: [X]
  Outputs: []
    Line 9519: ProcSwimmingB: 
      Branch exit: Line 9555: ChkForFloatdown: 
      Line 9523: LDA FrameCounter
        Branch exit: Line 9541: SlowSwim: 
        Line 9529: PLA                             ; pull 3 LSB of frame counter from the stack
          Branch exit: Line 9539: BSwimE: RTS 
          Line 9531: LDA Enemy_Y_MoveForce,X
            Branch exit: Line 9539: BSwimE: RTS 
            Line 9538: INC BlooperMoveCounter,X        ; otherwise increment movement counter
          Line 9539: BSwimE: RTS 

Function DoNothing1
  Inputs: []
  Outputs: []
    Line 3026: DoNothing1: 
      Line 3029: DoNothing2:  (as a call, not in function)

Function LoopCmdE
  Inputs: []
  Outputs: []
                    Line 3453: LoopCmdE: RTS 

Function StaircaseObject
  Inputs: [CarryFlag]
  Outputs: []
        Line 4131: StaircaseObject: 
          Branch exit: Line 4136: NextStair: DEC StaircaseControl ; move onto next step (or first if starting)
          Line 4134: LDA #$09                        ; start past the end for the bottom
          Line 4136: NextStair: DEC StaircaseControl ; move onto next step (or first if starting)
            Branch exit: Line 4247: RenderUnderPart: 

Function ProcHammerObj
  Inputs: [X]
  Outputs: []
    Line 6902: ProcHammerObj: 
      Branch exit: Line 6952: RunHSubs: JSR GetMiscOffscreenBits; get offscreen information
      Line 6905: LDA Misc_State,X                ; otherwise get hammer's state
        Branch exit: Line 6926: SetHSpd: LDA #$fe
        Line 6910: BCS SetHPos                     ; if greater than 2, branch elsewhere
          Branch exit: Line 6936: SetHPos: DEC Misc_State,X       ; decrement hammer's state
          Line 6911: TXA 
            Branch exit: Line 6951: RunAllH: JSR PlayerHammerCollision; handle collisions
        Line 6926: SetHSpd: LDA #$fe
        Line 6936: SetHPos: DEC Misc_State,X       ; decrement hammer's state
          Branch exit: Line 6952: RunHSubs: JSR GetMiscOffscreenBits; get offscreen information
        Line 6951: RunAllH: JSR PlayerHammerCollision; handle collisions
      Line 6952: RunHSubs: JSR GetMiscOffscreenBits; get offscreen information

Function ProcHammerBro
  Inputs: [X]
  Outputs: []
          Line 9212: ProcHammerBro: 
            Branch exit: Line 9217: ChkJH: LDA HammerBroJumpTimer,X ; check jump timer
            Line 9216: JMP MoveDefeatedEnemy           ; otherwise jump to something else
              Branch exit: Line 9355: MoveDefeatedEnemy: 
            Line 9217: ChkJH: LDA HammerBroJumpTimer,X ; check jump timer
              Branch exit: Line 9240: HammerBroJumpCode: 
              Line 9219: DEC HammerBroJumpTimer,X        ; otherwise decrement jump timer
                Branch exit: Line 9275: MoveHammerBroXDir: 
                Line 9223: LDA HammerThrowingTimer,X       ; check hammer throwing timer
                  Branch exit: Line 9234: DecHT: DEC HammerThrowingTimer,X; decrement timer
                  Line 9225: LDY SecondaryHardMode           ; otherwise get secondary hard mode flag
                    Branch exit: Line 9234: DecHT: DEC HammerThrowingTimer,X; decrement timer
                    Line 9230: LDA Enemy_State,X
                      Branch exit: Line 9275: MoveHammerBroXDir: 
                  Line 9234: DecHT: DEC HammerThrowingTimer,X; decrement timer
                    Branch exit: Line 9275: MoveHammerBroXDir: 

Function DelayToAreaEnd
  Inputs: [X]
  Outputs: []
    Line 10563: DelayToAreaEnd: 
      Branch exit: Line 10570: StarFlagExit2: 
      Line 10567: LDA EventMusicBuffer            ; if event music buffer empty,
        Branch exit: Line 10559: IncrementSFTask2: 
        Line 10569: 
      Line 10570: StarFlagExit2: 

Function MovePiranhaPlant
  Inputs: [X]
  Outputs: []
    Line 10576: MovePiranhaPlant: 
      Branch exit: Line 10630: PutinPipe: 
      Line 10579: LDA EnemyFrameTimer,X           ; check enemy's timer here
        Branch exit: Line 10630: PutinPipe: 
        Line 10581: LDA PiranhaPlant_MoveFlag,X     ; check movement flag
          Branch exit: Line 10606: SetupToMovePPlant: 
          Line 10583: LDA PiranhaPlant_Y_Speed,X      ; if currently rising, branch
            Branch exit: Line 10598: ReversePlantSpeed: 
            Line 10585: JSR PlayerEnemyDiff             ; get horizontal difference between player and
              Branch exit: Line 10593: ChkPlayerNearPipe: 
              Line 10587: LDA $00                         ; otherwise get saved horizontal difference
              Line 10593: ChkPlayerNearPipe: 
                Branch exit: Line 10630: PutinPipe: 
                Line 10597: 
            Line 10598: ReversePlantSpeed: 
          Line 10606: SetupToMovePPlant: 
            Branch exit: Line 10612: RiseFallPiranhaPlant: 
            Line 10610: LDA PiranhaPlantUpYPos,X        ; otherwise get other vertical coordinate (highest point)
            Line 10612: RiseFallPiranhaPlant: 
              Branch exit: Line 10630: PutinPipe: 
              Line 10617: LDA TimerControl                ; get master timer control
                Branch exit: Line 10630: PutinPipe: 
                Line 10619: LDA Enemy_Y_Position,X          ; get current vertical coordinate
                  Branch exit: Line 10630: PutinPipe: 
                  Line 10625: LDA #$00
      Line 10630: PutinPipe: 

Function GetAreaType
  Inputs: [A]
  Outputs: [A]
        Line 4358: GetAreaType: AND #%01100000     ; mask out all but d6 and d5

Function OffscreenBoundsCheck
  Inputs: [X]
  Outputs: []
  Line 11005: OffscreenBoundsCheck: 
    Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
    Line 11009: LDA ScreenLeft_X_Pos            ; get horizontal coordinate for left side of screen
      Branch exit: Line 11015: LimitB: ADC #$38                ; add 56 pixels to coordinate if hammer bro or piranha plant
      Line 11013: CPY #PiranhaPlant               ; check for piranha plant object
        Branch exit: Line 11016: ExtendLB: SBC #$48              ; subtract 72 pixels regardless of enemy object
      Line 11015: LimitB: ADC #$38                ; add 56 pixels to coordinate if hammer bro or piranha plant
      Line 11016: ExtendLB: SBC #$48              ; subtract 72 pixels regardless of enemy object
        Branch exit: Line 11048: TooFar: JSR EraseEnemyObject    ; erase object if necessary
        Line 11032: LDA Enemy_X_Position,X          ; compare horizontal coordinate of the enemy object
          Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
          Line 11037: LDA Enemy_State,X               ; if at this point, enemy is offscreen to the right, so check
            Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
            Line 11040: CPY #PiranhaPlant               ; if piranha plant, do not erase
              Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
              Line 11042: CPY #FlagpoleFlagObject         ; if flagpole flag, do not erase
                Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
                Line 11044: CPY #StarFlagObject             ; if star flag, do not erase
                  Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
                  Line 11046: CPY #JumpspringObject           ; if jumpspring, do not erase
                    Branch exit: Line 11049: ExScrnBd: RTS                   ; leave
        Line 11048: TooFar: JSR EraseEnemyObject    ; erase object if necessary
    Line 11049: ExScrnBd: RTS                   ; leave

Function EnemiesAndLoopsCore
  Inputs: [X]
  Outputs: [X]
    Line 7762: EnemiesAndLoopsCore: 
      Branch exit: Line 7775: ChkBowserF: PLA                 ; get data from stack
      Line 7767: PLA                             ; get from stack
        Branch exit: Line 7770: ChkAreaTsk: LDA AreaParserTaskNum; check number of tasks to perform
        Line 7769: JMP RunEnemyObjectsCore         ; otherwise, jump to run enemy subroutines
          Branch exit: Line 9004: RunEnemyObjectsCore: 
        Line 7770: ChkAreaTsk: LDA AreaParserTaskNum; check number of tasks to perform
          Branch exit: Line 7781: ExitELCore: RTS 
          Line 7774: JMP ProcLoopCommand             ; otherwise, jump to process loop command/load enemies
            Branch exit: Line 7825: ProcLoopCommand: 
      Line 7775: ChkBowserF: PLA                 ; get data from stack
        Branch exit: Line 7781: ExitELCore: RTS 
        Line 7780: STA Enemy_Flag,X                ; if second enemy flag not set, also clear first one
      Line 7781: ExitELCore: RTS 

Function MoveVOffset
  Inputs: [Y]
  Outputs: []
          Line 2054: MoveVOffset: DEY                ; decrement vram buffer offset
            Branch exit: Line 1476: SetVRAMOffset: STA VRAM_Buffer1_Offset; store as new vram buffer offset

Function DumpTwoSpr
  Inputs: [A, Y]
  Outputs: []
  Line 13322: DumpTwoSpr: 

Function WriteBottomStatusLine
  Inputs: []
  Outputs: []
    Line 1498: WriteBottomStatusLine: 
      Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function PlayerDeath
  Inputs: []
  Outputs: []
    Line 5765: PlayerDeath: 
      Branch exit: Line 5804: ExitDeath: 
      Line 5769: JMP PlayerCtrlRoutine           ; otherwise run player control routine
        Branch exit: Line 5557: PlayerCtrlRoutine: 

Function DrawFirebar
  Inputs: [Y]
  Outputs: []
    Line 14235: DrawFirebar: 
      Branch exit: Line 14249: FireA: STA Sprite_Attributes,Y  ; store attribute byte and leave
      Line 14248: ORA #%11000000                  ; otherwise flip both ways every eight frames
      Line 14249: FireA: STA Sprite_Attributes,Y  ; store attribute byte and leave

Function FlagBalls_Residual
  Inputs: []
  Outputs: []
    Line 3957: FlagBalls_Residual: 
      Branch exit: Line 4247: RenderUnderPart: 

Function LargePlatformSubroutines
  Inputs: [X]
  Outputs: []
    Line 9156: LargePlatformSubroutines: 
      Line 9161: 

Function BulletBillCheepCheep
  Inputs: [X]
  Outputs: []
          Line 8684: BulletBillCheepCheep: 
            Branch exit: Line 8739: ExF17: RTS                      ; if found, leave
            Line 8687: LDA AreaType                    ; are we in a water-type level?
              Branch exit: Line 8729: DoBulletBills: 
              Line 8689: CPX #$03                        ; are we past third enemy slot?
                Branch exit: Line 8739: ExF17: RTS                      ; if found, leave
                Line 8691: LDY #$00                        ; load default offset
                  Branch exit: Line 8696: ChkW2: LDA WorldNumber          ; check world number
                  Line 8695: INY                             ; otherwise increment
                  Line 8696: ChkW2: LDA WorldNumber          ; check world number
                    Branch exit: Line 8700: Get17ID: TYA 
                    Line 8699: INY                             ; otherwise increment
                    Line 8700: Get17ID: TYA 

Function BumpBlock
  Inputs: [X, $05, CarryFlag, Y]
  Outputs: []
    Line 7306: BumpBlock: 
      Branch exit: Line 7355: ExitBlockChk: 
      Line 7319: TYA                             ; move block number to A
        Branch exit: Line 7323: BlockCode: JSR JumpEngine       ; run appropriate subroutine depending on block number
        Line 7322: SBC #$05                        ; otherwise subtract 5 for second set to get proper number
        Line 7323: BlockCode: JSR JumpEngine       ; run appropriate subroutine depending on block number
          Line 7324: 
            Line 7337: MushFlowerBlock:  (as a call, not in function)

Function PlayerLakituDiff
  Inputs: [$00, X]
  Outputs: []
    Line 10001: PlayerLakituDiff: 
      Branch exit: Line 10011: ChkLakDif: LDA $00              ; get low byte of horizontal difference
      Line 10005: INY                             ; increment Y for left of player
      Line 10011: ChkLakDif: LDA $00              ; get low byte of horizontal difference
        Branch exit: Line 10029: ChkPSpeed: LDA $00
        Line 10014: LDA #$3c                        ; otherwise set maximum distance
          Branch exit: Line 10029: ChkPSpeed: LDA $00
          Line 10019: TYA                             ; compare contents of Y, now in A
            Branch exit: Line 10029: ChkPSpeed: LDA $00
            Line 10022: LDA LakituMoveDirection,X       ; if moving to the left beyond maximum distance,
              Branch exit: Line 10027: SetLMovD: TYA                   ; set horizontal direction depending on horizontal
              Line 10024: DEC LakituMoveSpeed,X           ; decrement horizontal speed
                Branch exit: Line 10061: ExMoveLak: RTS                  ; leave!!!
              Line 10027: SetLMovD: TYA                   ; set horizontal direction depending on horizontal
        Line 10029: ChkPSpeed: LDA $00
          Branch exit: Line 10055: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
          Line 10037: LDA ScrollAmount
            Branch exit: Line 10055: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
            Line 10039: INY                             ; otherwise increment offset
              Branch exit: Line 10047: ChkSpinyO: LDA Enemy_ID,X       ; check for spiny object
              Line 10043: LDA ScrollAmount
                Branch exit: Line 10047: ChkSpinyO: LDA Enemy_ID,X       ; check for spiny object
                Line 10046: INY                             ; otherwise increment once more
              Line 10047: ChkSpinyO: LDA Enemy_ID,X       ; check for spiny object
                Branch exit: Line 10052: ChkEmySpd: LDA Enemy_Y_Speed,X  ; check vertical speed
                Line 10050: LDA Player_X_Speed              ; if player not moving, skip this part
                  Branch exit: Line 10055: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
                Line 10052: ChkEmySpd: LDA Enemy_Y_Speed,X  ; check vertical speed
                  Branch exit: Line 10055: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
                  Line 10054: LDY #$00                        ; otherwise reinit offset
          Line 10055: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
            Line 10057: SPixelLak: SEC                  ; subtract one for each pixel of horizontal difference
              Branch exit: Line 10057: SPixelLak: SEC                  ; subtract one for each pixel of horizontal difference
        Line 10061: ExMoveLak: RTS                  ; leave!!!

Function ClearBuffersDrawIcon
  Inputs: []
  Outputs: []
    Line 1613: ClearBuffersDrawIcon: 
      Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode
      Line 1616: LDX #$00                        ; otherwise, clear buffer space
        Line 1617: TScrClear: STA VRAM_Buffer1-1,X
          Branch exit: Line 1617: TScrClear: STA VRAM_Buffer1-1,X
          Line 1621: JSR DrawMushroomIcon            ; draw player select icon

Function PlayerEnemyCollision
  Inputs: [X]
  Outputs: []
  Line 11292: PlayerEnemyCollision: 
    Branch exit: Line 11279: NoPUp: RTS 
    Line 11296: JSR CheckPlayerVertical         ; if player object is completely offscreen or
      Branch exit: Line 11313: NoPECol: RTS 
      Line 11298: LDA EnemyOffscrBitsMasked,X     ; if current enemy is offscreen by any amount,
        Branch exit: Line 11313: NoPECol: RTS 
        Line 11300: LDA GameEngineSubroutine
          Branch exit: Line 11313: NoPECol: RTS 
          Line 11303: LDA Enemy_State,X
            Branch exit: Line 11313: NoPECol: RTS 
            Line 11306: JSR GetEnemyBoundBoxOfs         ; get bounding box offset for current enemy object
              Branch exit: Line 11315: CheckForPUpCollision: 
              Line 11310: LDA Enemy_CollisionBits,X
      Line 11313: NoPECol: RTS 

Function InitVStf
  Inputs: [X]
  Outputs: [A]
    Line 8226: InitVStf: LDA #$00              ; initialize vertical speed

Function FlagpoleObject
  Inputs: []
  Outputs: []
    Line 3965: FlagpoleObject: 

Function SpawnHammerObj
  Inputs: []
  Outputs: [CarryFlag]
        Line 6872: SpawnHammerObj: 
          Branch exit: Line 6878: SetMOfs: TAY                    ; use either d3 or d2-d0 for offset here
          Line 6876: LDA PseudoRandomBitReg+1
          Line 6878: SetMOfs: TAY                    ; use either d3 or d2-d0 for offset here
            Branch exit: Line 6893: NoHammer: LDX ObjectOffset      ; get original enemy object offset
            Line 6881: LDX HammerEnemyOfsData,Y        ; get offset of enemy slot to check using Y as offset
              Branch exit: Line 6893: NoHammer: LDX ObjectOffset      ; get original enemy object offset
              Line 6884: LDX ObjectOffset                ; get original enemy object offset
            Line 6893: NoHammer: LDX ObjectOffset      ; get original enemy object offset

Function GetLrgObjAttrib
  Inputs: [X]
  Outputs: [Y, $07, A]
    Line 4287: GetLrgObjAttrib: 

Function SideExitPipeEntry
  Inputs: []
  Outputs: []
    Line 5704: SideExitPipeEntry: 

Function Square2SfxHandler
  Inputs: []
  Outputs: []
    Line 15429: Square2SfxHandler: 
      Branch exit: Line 15498: ContinueExtraLife: 
      Line 15433: LDY Square2SoundQueue           ; check for sfx in queue
        Branch exit: Line 15452: CheckSfx2Buffer: 
        Line 15435: STY Square2SoundBuffer          ; if found, put in buffer and check for the following
          Branch exit: Line 15478: PlayBowserFall: 
          Line 15437: LSR Square2SoundQueue
            Branch exit: Line 15360: PlayCoinGrab: 
            Line 15439: LSR Square2SoundQueue
              Branch exit: Line 15511: PlayGrowPowerUp: 
              Line 15441: LSR Square2SoundQueue
                Branch exit: Line 15515: PlayGrowVine: 
                Line 15443: LSR Square2SoundQueue
                  Branch exit: Line 15383: PlayBlast: 
                  Line 15445: LSR Square2SoundQueue
                    Branch exit: Line 15365: PlayTimerTick: 
                    Line 15447: LSR Square2SoundQueue
                      Branch exit: Line 15398: PlayPowerUpGrab: 
                      Line 15449: LSR Square2SoundQueue
                        Branch exit: Line 15494: PlayExtraLife: 
                        Line 15451: 
        Line 15452: CheckSfx2Buffer: 
          Branch exit: Line 15470: ExS2H: RTS 
          Line 15455: BMI ContinueBowserFall          ; bowser fall
            Branch exit: Line 15485: ContinueBowserFall: 
            Line 15456: LSR 
              Branch exit: Line 15472: Cont_CGrab_TTick: 
              Line 15458: LSR 
                Branch exit: Line 15525: ContinueGrowItems: 
                Line 15460: LSR 
                  Branch exit: Line 15525: ContinueGrowItems: 
                  Line 15462: LSR 
                    Branch exit: Line 15390: ContinueBlast: 
                    Line 15464: LSR 
                      Branch exit: Line 15472: Cont_CGrab_TTick: 
                      Line 15466: LSR 
                        Branch exit: Line 15402: ContinuePowerUpGrab: 
                        Line 15468: LSR 
                          Branch exit: Line 15498: ContinueExtraLife: 
          Line 15470: ExS2H: RTS 

Function PositionPlayerOnHPlat
  Inputs: [$00]
  Outputs: []
        Line 10933: PositionPlayerOnHPlat: 
          Branch exit: Line 10943: PPHSubt: SBC #$00               ; subtract borrow from page location
          Line 10941: ADC #$00                        ; otherwise add carry to page location
            Branch exit: Line 10944: SetPVar: STA Player_PageLoc     ; save result to player's page location
          Line 10943: PPHSubt: SBC #$00               ; subtract borrow from page location
          Line 10944: SetPVar: STA Player_PageLoc     ; save result to player's page location

Function GetEnemyBoundBoxOfs
  Inputs: []
  Outputs: [A]
    Line 11879: GetEnemyBoundBoxOfs: 
      Line 11882: GetEnemyBoundBoxOfsArg:  (as a call, not in function)

Function InitEnemyFrenzy
  Inputs: [X]
  Outputs: []
    Line 8829: InitEnemyFrenzy: 
      Line 8835: 
        Line 8846: NoFrenzyCode:  (as a call, not in function)

Function ProcFirebar
  Inputs: [X]
  Outputs: []
            Line 9700: ProcFirebar: 
              Branch exit: Line 9756: SkipFBar: RTS 
              Line 9705: LDA TimerControl                ; if master timer control set, branch
                Branch exit: Line 9711: SusFbar: LDA FirebarSpinState_High,X; get high byte of spinstate
                Line 9707: LDA FirebarSpinSpeed,X          ; load spinning speed of firebar
                Line 9711: SusFbar: LDA FirebarSpinState_High,X; get high byte of spinstate
                  Branch exit: Line 9722: SetupGFB: STA $ef               ; save high byte of spinning thing, modified or otherwise
                  Line 9715: CMP #$08                        ; check high byte of spinstate
                    Branch exit: Line 9719: SkpFSte: CLC 
                    Line 9717: CMP #$18
                      Branch exit: Line 9722: SetupGFB: STA $ef               ; save high byte of spinning thing, modified or otherwise
                    Line 9719: SkpFSte: CLC 
                  Line 9722: SetupGFB: STA $ef               ; save high byte of spinning thing, modified or otherwise
                    Branch exit: Line 9740: SetMFbar: STY $ed               ; store maximum value for length of firebars
                    Line 9739: LDY #$0b                        ; otherwise load value for long firebars
                    Line 9740: SetMFbar: STY $ed               ; store maximum value for length of firebars
                      Line 9743: DrawFbar: LDA $ef               ; load high byte of spinstate
                        Branch exit: Line 9752: NextFbar: INC $00               ; move onto the next firebar part
                        Line 9749: LDY DuplicateObj_Offset         ; if we arrive at fifth firebar part,
                        Line 9752: NextFbar: INC $00               ; move onto the next firebar part
                          Branch exit: Line 9743: DrawFbar: LDA $ef               ; load high byte of spinstate
              Line 9756: SkipFBar: RTS 

Function InitHammerBro
  Inputs: [X]
  Outputs: []
      Line 8187: InitHammerBro: 
        Branch exit: Line 8223: SetBBox: STA Enemy_BoundBoxCtrl,X; set bounding box control here

Function EnemyFacePlayer
  Inputs: [X]
  Outputs: []
    Line 11523: EnemyFacePlayer: 
      Branch exit: Line 11528: SFcRt: STY Enemy_MovingDir,X    ; set moving direction here
      Line 11527: INY                             ; otherwise, increment to set to move to the left
      Line 11528: SFcRt: STY Enemy_MovingDir,X    ; set moving direction here

Function EraseEnemyObject
  Inputs: [X]
  Outputs: []
  Line 9172: EraseEnemyObject: 

Function YMovingPlatform
  Inputs: [X]
  Outputs: []
    Line 10895: YMovingPlatform: 
      Branch exit: Line 10909: ChkYCenterPos: 
      Line 10899: STA Enemy_YMF_Dummy,X           ; initialize dummy variable
        Branch exit: Line 10909: ChkYCenterPos: 
        Line 10903: LDA FrameCounter
          Branch exit: Line 10907: SkipIY: JMP ChkYPCollision      ; skip ahead to last part
          Line 10906: INC Enemy_Y_Position,X          ; increase vertical position every eighth frame
          Line 10907: SkipIY: JMP ChkYPCollision      ; skip ahead to last part
            Branch exit: Line 10917: ChkYPCollision: 

Function ImposeGravitySprObj
  Inputs: [A]
  Outputs: []
  Line 7665: ImposeGravitySprObj: 
    Branch exit: Line 7703: ImposeGravity: 

Function GetScreenPosition
  Inputs: []
  Outputs: [A]
        Line 5461: GetScreenPosition: 

Function ChkJumpspringMetatiles
  Inputs: [A]
  Outputs: [CarryFlag]
    Line 12260: ChkJumpspringMetatiles: 
      Branch exit: Line 12266: JSFnd: SEC                      ; set carry if found
      Line 12263: CMP #$68                        ; check for bottom jumpspring metatile
        Branch exit: Line 12267: NoJSFnd: RTS                    ; leave
      Line 12266: JSFnd: SEC                      ; set carry if found
      Line 12267: NoJSFnd: RTS                    ; leave

Function KillEnemies
  Inputs: [A]
  Outputs: []
    Line 3589: KillEnemies: 
      Line 3593: KillELoop: LDY Enemy_ID,X
        Branch exit: Line 3597: NoKillE: DEX                    ; do this until all slots are checked
        Line 3596: STA Enemy_Flag,X                ; if found, deactivate enemy object flag
        Line 3597: NoKillE: DEX                    ; do this until all slots are checked
          Branch exit: Line 3593: KillELoop: LDY Enemy_ID,X
          Line 3599: RTS 

Function BlockObjectsCore
  Inputs: [X]
  Outputs: [X]
    Line 7442: BlockObjectsCore: 
      Branch exit: Line 7494: UpdSte: STA Block_State,X       ; store contents of A in block object state
      Line 7445: AND #$0f                        ; mask out high nybble
        Branch exit: Line 7480: BouncingBlockHandler: 
        Line 7454: JSR ImposeGravityBlock          ; do sub to impose gravity on one block object object
          Branch exit: Line 7494: UpdSte: STA Block_State,X       ; store contents of A in block object state
          Line 7469: PHA                             ; otherwise save state back into stack
            Branch exit: Line 7474: ChkTop: LDA Block_Y_Position,X  ; get top block object's vertical coordinate
            Line 7473: STA Block_Y_Position+2,X        ; otherwise set offscreen coordinate
            Line 7474: ChkTop: LDA Block_Y_Position,X  ; get top block object's vertical coordinate
              Branch exit: Line 7494: UpdSte: STA Block_State,X       ; store contents of A in block object state
              Line 7478: BCS KillBlock                   ; otherwise do unconditional branch to kill it
                Branch exit: Line 7493: KillBlock: LDA #$00             ; if branched here, nullify object state
                Line 7479: 
        Line 7480: BouncingBlockHandler: 
          Branch exit: Line 7494: UpdSte: STA Block_State,X       ; store contents of A in block object state
          Line 7491: LDA #$01
        Line 7493: KillBlock: LDA #$00             ; if branched here, nullify object state
      Line 7494: UpdSte: STA Block_State,X       ; store contents of A in block object state

Function DonePlayerTask
  Inputs: []
  Outputs: []
  Line 5771: DonePlayerTask: 

Function TreeLedge
  Inputs: [X, Y, $07]
  Outputs: []
        Line 3627: TreeLedge: 
          Branch exit: Line 3644: EndTreeL: LDA #$18              ; render end of tree ledge
          Line 3631: BPL MidTreeL
            Branch exit: Line 3639: MidTreeL: LDX $07
            Line 3632: TYA 
              Branch exit: Line 3639: MidTreeL: LDX $07
              Line 3637: LDA #$16                        ; render start of tree ledge
                Branch exit: Line 3673: NoUnder: LDX $07                ; load row of ledge
            Line 3639: MidTreeL: LDX $07
              Branch exit: Line 3670: AllUnder: INX 
          Line 3644: EndTreeL: LDA #$18              ; render end of tree ledge
            Branch exit: Line 3673: NoUnder: LDX $07                ; load row of ledge

Function MovePodoboo
  Inputs: [X]
  Outputs: []
    Line 9186: MovePodoboo: 
      Branch exit: Line 9198: PdbM: JMP MoveJ_EnemyVertically ; branch to impose gravity on podoboo
      Line 9189: JSR InitPodoboo                 ; otherwise set up podoboo again
      Line 9198: PdbM: JMP MoveJ_EnemyVertically ; branch to impose gravity on podoboo
        Branch exit: Line 7641: MoveJ_EnemyVertically: 

Function RelativeMiscPosition
  Inputs: []
  Outputs: []
    Line 14779: RelativeMiscPosition: 
      Branch exit: Line 14775: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function GetMTileAttrib
  Inputs: [A]
  Outputs: [A]
    Line 12381: GetMTileAttrib: 

Function TransposePlayers
  Inputs: []
  Outputs: [CarryFlag]
    Line 3003: TransposePlayers: 
      Branch exit: Line 3022: ExTrans: RTS 
      Line 3007: LDA OffScr_NumberofLives        ; does offscreen player have any lives left?
        Branch exit: Line 3022: ExTrans: RTS 
        Line 3009: LDA CurrentPlayer               ; invert bit to update
          Line 3013: TransLoop: LDA OnscreenPlayerInfo,X; transpose the information
            Branch exit: Line 3013: TransLoop: LDA OnscreenPlayerInfo,X; transpose the information
            Line 3021: CLC                             ; clear carry flag to get game going
      Line 3022: ExTrans: RTS 

Function EndFrenzy
  Inputs: [X]
  Outputs: []
    Line 8851: EndFrenzy: 
      Line 8853: LakituChk: LDA Enemy_ID,Y       ; check enemy identifiers
        Branch exit: Line 8858: NextFSlot: DEY                  ; move onto the next slot
        Line 8856: LDA #$01                        ; if found, set state
        Line 8858: NextFSlot: DEY                  ; move onto the next slot
          Branch exit: Line 8853: LakituChk: LDA Enemy_ID,Y       ; check enemy identifiers
          Line 8860: LDA #$00

Function InitBalPlatform
  Inputs: [X]
  Outputs: []
    Line 8878: InitBalPlatform: 
      Branch exit: Line 8885: AlignP: LDY #$ff                ; set default value here for now
      Line 8883: LDY #$02                        ; otherwise set value here
      Line 8885: AlignP: LDY #$ff                ; set default value here for now
        Branch exit: Line 8891: SetBPA: STY BalPlatformAlignment; store whatever value's in Y here
        Line 8889: TXA                             ; if old contents already $ff, put
        Line 8891: SetBPA: STY BalPlatformAlignment; store whatever value's in Y here
          Line 8899: InitDropPlatform:  (as a call, not in function)

Function RunStarFlagObj
  Inputs: []
  Outputs: []
          Line 10451: RunStarFlagObj: 
            Branch exit: Line 10483: StarFlagExit: 
            Line 10457: JSR JumpEngine                  ; otherwise jump to appropriate sub
              Line 10458: 
                Line 10465: GameTimerFireworks:  (as a call, not in function)

Function MoveDropPlatform
  Inputs: []
  Outputs: []
    Line 7630: MoveDropPlatform: 
      Branch exit: Line 7636: SetMdMax: LDA #$02              ; set maximum speed in A
      Line 7633: 

Function SetupIntermediate
  Inputs: []
  Outputs: []
    Line 1392: SetupIntermediate: 
      Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function SetupFloateyNumber
  Inputs: [A, X]
  Outputs: []
    Line 11532: SetupFloateyNumber: 

Function SmallBBox
  Inputs: [X]
  Outputs: [A]
  Line 8208: SmallBBox: LDA #$09             ; set specific bounding box size control
    Branch exit: Line 8223: SetBBox: STA Enemy_BoundBoxCtrl,X; set bounding box control here
    Line 8210: 
      Line 8213: InitRedPTroopa:  (as a call, not in function)

Function DisplayTimeUp
  Inputs: []
  Outputs: []
    Line 1527: DisplayTimeUp: 
      Branch exit: Line 1534: NoTimeUp: INC ScreenRoutineTask ; increment control task 2 tasks forward
      Line 1530: LDA #$00
        Branch exit: Line 1553: OutputInter: JSR WriteGameText
      Line 1534: NoTimeUp: INC ScreenRoutineTask ; increment control task 2 tasks forward
        Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function AlternateLengthHandler
  Inputs: [A, CarryFlag]
  Outputs: [A, X]
    Line 15908: AlternateLengthHandler: 
      Line 15916: ProcessLengthData:  (as a call, not in function)

Function SetupVictoryMode
  Inputs: []
  Outputs: []
        Line 1133: SetupVictoryMode: 
          Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode

Function AreaParserTasks
  Inputs: []
  Outputs: []
    Line 3047: AreaParserTasks: 
      Line 3049: 
        Line 3061: IncrementColumnPos:  (as a call, not in function)

Function MoveLiftPlatforms
  Inputs: [X]
  Outputs: []
    Line 10981: MoveLiftPlatforms: 
      Branch exit: Line 10997: ExLiftP: RTS                    ; then leave
      Line 10984: LDA Enemy_YMF_Dummy,X

Function PositionPlayerOnVPlat
  Inputs: [X]
  Outputs: []
        Line 11845: PositionPlayerOnVPlat: 
          Branch exit: Line 11862: ExPlPos: RTS 
          Line 11850: LDY Enemy_Y_HighPos,X
            Branch exit: Line 11862: ExPlPos: RTS 
            Line 11853: SEC                             ; subtract 32 pixels from vertical coordinate
          Line 11862: ExPlPos: RTS 

Function GetPlayerColors
  Inputs: []
  Outputs: []
              Line 1441: GetPlayerColors: 
                Branch exit: Line 1447: ChkFiery: LDA PlayerStatus      ; check player status
                Line 1446: LDY #$04                        ; load offset for luigi
                Line 1447: ChkFiery: LDA PlayerStatus      ; check player status
                  Branch exit: Line 1451: StartClrGet: LDA #$03           ; do four colors
                  Line 1450: LDY #$08
                  Line 1451: StartClrGet: LDA #$03           ; do four colors
                    Line 1453: ClrGetLoop: LDA PlayerColors,Y  ; fetch player colors and store them
                      Branch exit: Line 1453: ClrGetLoop: LDA PlayerColors,Y  ; fetch player colors and store them
                      Line 1459: LDX VRAM_Buffer1_Offset         ; load original offset from before
                        Branch exit: Line 1463: SetBGColor: LDA BackgroundColors,Y; to background color instead
                        Line 1462: LDY AreaType                    ; otherwise use area type bits from area offset as offset
                        Line 1463: SetBGColor: LDA BackgroundColors,Y; to background color instead

Function MoveEnemyHorizontally
  Inputs: [X]
  Outputs: []
  Line 7529: MoveEnemyHorizontally: 

Function DrawBlock
  Inputs: [X]
  Outputs: []
      Line 14096: DrawBlock: 
        Line 14107: DBlkLoop: LDA DefaultBlockObjTiles,X; get left tile number
          Branch exit: Line 14107: DBlkLoop: LDA DefaultBlockObjTiles,X; get left tile number
          Line 14113: LDX ObjectOffset                ; get block object offset
            Branch exit: Line 14121: ChkRep: LDA Block_Metatile,X    ; check replacement metatile
            Line 14118: LDA #$86
            Line 14121: ChkRep: LDA Block_Metatile,X    ; check replacement metatile
              Branch exit: Line 14141: BlkOffscr: LDA Block_OffscreenBits; get offscreen bits for block object
              Line 14124: LDA #$87                        ; set A for used block tile
                Branch exit: Line 14133: SetBFlip: LDX ObjectOffset      ; put block object offset back in X
                Line 14132: LSR                             ; otherwise set to $01
                Line 14133: SetBFlip: LDX ObjectOffset      ; put block object offset back in X
              Line 14141: BlkOffscr: LDA Block_OffscreenBits; get offscreen bits for block object
                Branch exit: Line 14148: PullOfsB: PLA                   ; pull offscreen bits from stack
                Line 14145: LDA #$f8                        ; move offscreen two OAMs
                Line 14148: PullOfsB: PLA                   ; pull offscreen bits from stack
                  Line 14149: ChkLeftCo: AND #%00001000       ; check to see if d3 in offscreen bits are set (as a call, not in function)

Function PlayerMovementSubs
  Inputs: []
  Outputs: []
    Line 5873: PlayerMovementSubs: 
      Branch exit: Line 5881: SetCrouch: STA CrouchingFlag    ; store value in crouch flag
      Line 5877: LDA Player_State                ; check state of player
        Branch exit: Line 5882: ProcMove: JSR PlayerPhysicsSub  ; run sub related to jumping and swimming
        Line 5879: LDA Up_Down_Buttons             ; load controller bits for up and down
      Line 5881: SetCrouch: STA CrouchingFlag    ; store value in crouch flag
      Line 5882: ProcMove: JSR PlayerPhysicsSub  ; run sub related to jumping and swimming
        Branch exit: Line 5897: NoMoveSub: RTS 
        Line 5885: LDA Player_State
          Branch exit: Line 5890: MoveSubs: JSR JumpEngine
          Line 5888: LDY #$18
          Line 5890: MoveSubs: JSR JumpEngine
            Line 5891: 
        Line 5897: NoMoveSub: RTS 

Function DemoEngine
  Inputs: []
  Outputs: [CarryFlag]
        Line 1093: DemoEngine: 
          Branch exit: Line 1103: DoAction: LDA DemoActionData-1,X; get and perform action (current or next)
          Line 1097: INX 
            Branch exit: Line 1107: DemoOver: RTS 
          Line 1103: DoAction: LDA DemoActionData-1,X; get and perform action (current or next)
          Line 1107: DemoOver: RTS 

Function BlockBufferCollision
  Inputs: [A, Y, X]
  Outputs: [$02, A]
                Line 13052: BlockBufferCollision: 
                  Branch exit: Line 13085: RetXC: LDA SprObject_X_Position,X; otherwise load horizontal coordinate
                  Line 13083: LDA SprObject_Y_Position,X      ; if A = 0, load vertical coordinate
                    Branch exit: Line 13086: RetYC: AND #%00001111           ; and mask out high nybble
                  Line 13085: RetXC: LDA SprObject_X_Position,X; otherwise load horizontal coordinate
                  Line 13086: RetYC: AND #%00001111           ; and mask out high nybble

Function AreaStyleObject
  Inputs: []
  Outputs: []
    Line 3620: AreaStyleObject: 
      Line 3623: .db TreeLedge                   ; also used for cloud type levels
        Line 3627: TreeLedge:  (as a call, not in function)

Function RemoveCoin_Axe
  Inputs: []
  Outputs: []
  Line 2015: RemoveCoin_Axe: 
    Branch exit: Line 2021: WriteBlankMT: JSR PutBlockMetatile; do a sub to write blank metatile to vram buffer
    Line 2020: LDA #$04                        ; otherwise load offset for blank metatile used in water
    Line 2021: WriteBlankMT: JSR PutBlockMetatile; do a sub to write blank metatile to vram buffer

Function VerticalPipeEntry
  Inputs: []
  Outputs: []
    Line 5682: VerticalPipeEntry: 
      Branch exit: Line 5707: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area
      Line 5689: INY 
        Branch exit: Line 5707: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area
        Line 5693: INY 
          Branch exit: Line 5707: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area

Function MoveSpritesOffscreen
  Inputs: []
  Outputs: []
          Line 943: MoveSpritesOffscreen: 
            Line 946: SprInitLoop: STA Sprite_Y_Position,Y; write 248 into OAM data's Y coordinate
              Branch exit: Line 946: SprInitLoop: STA Sprite_Y_Position,Y; write 248 into OAM data's Y coordinate
              Line 952: RTS 

Function GetFirebarPosition
  Inputs: [A, $00]
  Outputs: []
    Line 9870: GetFirebarPosition: 
      Branch exit: Line 9878: GetHAdder: STA $01              ; store result, modified or not, here
      Line 9875: EOR #%00001111                  ; otherwise get two's compliment to oscillate
      Line 9878: GetHAdder: STA $01              ; store result, modified or not, here
        Branch exit: Line 9896: GetVAdder: STA $02              ; store result here
        Line 9893: EOR #%00001111                  ; otherwise get two's compliment
        Line 9896: GetVAdder: STA $02              ; store result here

Function ErACM
  Inputs: [$02]
  Outputs: []
    Line 12133: ErACM: LDY $02                  ; load vertical high nybble offset for block buffer
      Branch exit: Line 2015: RemoveCoin_Axe: 

Function ForceInjury
  Inputs: [A]
  Outputs: []
      Line 11404: ForceInjury: 
        Branch exit: Line 11426: KillPlayer: 
        Line 11407: STA PlayerStatus                ; otherwise set player's status to small

Function BulletBillHandler
  Inputs: [X, $00]
  Outputs: []
      Line 6823: BulletBillHandler: 
        Branch exit: Line 6855: RunBBSubs: JSR GetEnemyOffscreenBits; get offscreen information
        Line 6826: LDA Enemy_State,X
          Branch exit: Line 6850: ChkDSte: LDA Enemy_State,X      ; check enemy state for d5 set
          Line 6828: LDA Enemy_OffscreenBits         ; otherwise load offscreen bits
            Branch exit: Line 6860: KillBB: JSR EraseEnemyObject    ; kill bullet bill and leave
            Line 6832: LDY #$01                        ; set to move right by default
              Branch exit: Line 6836: SetupBB: STY Enemy_MovingDir,X  ; set bullet bill's moving direction
              Line 6835: INY                             ; otherwise increment to move left
              Line 6836: SetupBB: STY Enemy_MovingDir,X  ; set bullet bill's moving direction
                Branch exit: Line 6860: KillBB: JSR EraseEnemyObject    ; kill bullet bill and leave
                Line 6844: LDA #$01
            Line 6860: KillBB: JSR EraseEnemyObject    ; kill bullet bill and leave
          Line 6850: ChkDSte: LDA Enemy_State,X      ; check enemy state for d5 set
            Branch exit: Line 6854: BBFly: JSR MoveEnemyHorizontally; do sub to move bullet bill horizontally
            Line 6853: JSR MoveD_EnemyVertically       ; otherwise do sub to move bullet bill vertically
            Line 6854: BBFly: JSR MoveEnemyHorizontally; do sub to move bullet bill horizontally
        Line 6855: RunBBSubs: JSR GetEnemyOffscreenBits; get offscreen information
          Branch exit: Line 13613: EnemyGfxHandler: 

Function DuplicateEnemyObj
  Inputs: [X]
  Outputs: []
    Line 8525: DuplicateEnemyObj: 
      Line 8527: FSLoop: INY                     ; increment one slot
        Branch exit: Line 8527: FSLoop: INY                     ; increment one slot
        Line 8530: STY DuplicateObj_Offset         ; otherwise set offset here

Function MoveAllSpritesOffscreen
  Inputs: []
  Outputs: []
        Line 939: MoveAllSpritesOffscreen: 
          Line 943: MoveSpritesOffscreen:  (as a call, not in function)

Function PlayerPhysicsSub
  Inputs: []
  Outputs: []
                      Line 6041: PlayerPhysicsSub: 
                        Branch exit: Line 6063: CheckForJumping: 
                        Line 6045: LDY #$00
                          Branch exit: Line 6053: ProcClimb: LDX Climb_Y_MForceData,Y; load value here
                          Line 6049: INY 
                            Branch exit: Line 6053: ProcClimb: LDX Climb_Y_MForceData,Y; load value here
                            Line 6052: INY 
                          Line 6053: ProcClimb: LDX Climb_Y_MForceData,Y; load value here
                            Branch exit: Line 6060: SetCAnim: STA PlayerAnimTimerSet; store animation timer setting and leave
                            Line 6059: LSR                             ; otherwise divide timer setting by 2
                            Line 6060: SetCAnim: STA PlayerAnimTimerSet; store animation timer setting and leave

Function JumpspringHandler
  Inputs: [X]
  Outputs: []
      Line 6627: JumpspringHandler: 
        Branch exit: Line 6662: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
        Line 6631: LDA JumpspringAnimCtrl          ; check jumpspring frame control
          Branch exit: Line 6662: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
          Line 6633: TAY 
            Branch exit: Line 6641: DownJSpr: DEC Player_Y_Position ; move player's vertical position up two pixels
            Line 6638: INC Player_Y_Position
              Branch exit: Line 6643: PosJSpr: LDA Jumpspring_FixedYPos,X; get permanent vertical position
            Line 6641: DownJSpr: DEC Player_Y_Position ; move player's vertical position up two pixels
            Line 6643: PosJSpr: LDA Jumpspring_FixedYPos,X; get permanent vertical position
              Branch exit: Line 6656: BounceJS: CPY #$03              ; check frame control offset again
              Line 6649: LDA A_B_Buttons
                Branch exit: Line 6656: BounceJS: CPY #$03              ; check frame control offset again
                Line 6652: AND PreviousA_B_Buttons         ; check for A button pressed in previous frame
                  Branch exit: Line 6656: BounceJS: CPY #$03              ; check frame control offset again
                  Line 6654: LDA #$f4
              Line 6656: BounceJS: CPY #$03              ; check frame control offset again
                Branch exit: Line 6662: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
                Line 6658: LDA JumpspringForce
        Line 6662: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
          Branch exit: Line 6672: ExJSpring: RTS                  ; leave
          Line 6667: LDA JumpspringTimer
            Branch exit: Line 6672: ExJSpring: RTS                  ; leave
            Line 6669: LDA #$04
          Line 6672: ExJSpring: RTS                  ; leave

Function ImposeGravity
  Inputs: [A, X, $00, $02, $01]
  Outputs: []
  Line 7703: ImposeGravity: 
    Branch exit: Line 7713: AlterYP: STY $07                ; store Y here
    Line 7712: DEY                             ; otherwise decrement Y
    Line 7713: AlterYP: STY $07                ; store Y here
      Branch exit: Line 7735: ChkUpM: PLA                     ; get value from stack
      Line 7728: LDA SprObject_Y_MoveForce,X
        Branch exit: Line 7735: ChkUpM: PLA                     ; get value from stack
        Line 7731: LDA $02
      Line 7735: ChkUpM: PLA                     ; get value from stack
        Branch exit: Line 7758: ExVMove: RTS                    ; leave!
        Line 7737: LDA $02
          Branch exit: Line 7758: ExVMove: RTS                    ; leave!
          Line 7751: LDA SprObject_Y_MoveForce,X
            Branch exit: Line 7758: ExVMove: RTS                    ; leave!
            Line 7754: LDA $07
        Line 7758: ExVMove: RTS                    ; leave!

Function RelativeFireballPosition
  Inputs: []
  Outputs: []
    Line 14771: RelativeFireballPosition: 

Function GetProperObjOffset
  Inputs: [X, Y]
  Outputs: []
      Line 14846: GetProperObjOffset: 

Function ScreenRoutines
  Inputs: []
  Outputs: []
    Line 1360: ScreenRoutines: 
      Line 1363: 
        Line 1382: InitScreen:  (as a call, not in function)

Function DestroyBlockMetatile
  Inputs: []
  Outputs: []
    Line 2032: DestroyBlockMetatile: 
      Line 2035: WriteBlockMetatile:  (as a call, not in function)

Function FlagpoleSlide
  Inputs: []
  Outputs: []
    Line 5809: FlagpoleSlide: 
      Branch exit: Line 5822: NoFPObj: INC GameEngineSubroutine; increment to next routine (this may
      Line 5813: LDA FlagpoleSoundQueue          ; load flagpole sound
        Branch exit: Line 5821: SlidePlayer: JMP AutoControlPlayer; jump to player control routine
        Line 5820: LDA #$04                        ; otherwise force player to climb down (to slide)
        Line 5821: SlidePlayer: JMP AutoControlPlayer; jump to player control routine
          Branch exit: Line 5554: AutoControlPlayer: 
      Line 5822: NoFPObj: INC GameEngineSubroutine; increment to next routine (this may

Function InitHoriPlatform
  Inputs: [X]
  Outputs: []
    Line 8906: InitHoriPlatform: 
      Branch exit: Line 8929: CommonPlatCode: 

Function ClimbingSub
  Inputs: []
  Outputs: []
        Line 5965: ClimbingSub: 
          Branch exit: Line 5974: MoveOnVine: STY $00             ; store adder here
          Line 5973: DEY                             ; otherwise set adder to $ff
          Line 5974: MoveOnVine: STY $00             ; store adder here
            Branch exit: Line 6007: InitCSTimer: STA ClimbSideTimer ; initialize timer here
            Line 5983: LDY ClimbSideTimer              ; otherwise check timer
              Branch exit: Line 6006: ExitCSub: RTS                   ; then leave
              Line 5985: LDY #$18
                Branch exit: Line 5993: ClimbFD: DEY                    ; check to see if facing right
                Line 5991: INX 
                Line 5993: ClimbFD: DEY                    ; check to see if facing right
                  Branch exit: Line 5996: CSetFDir: LDA Player_X_Position
                  Line 5995: INX                             ; otherwise increment by 1 byte
                  Line 5996: CSetFDir: LDA Player_X_Position
              Line 6006: ExitCSub: RTS                   ; then leave
            Line 6007: InitCSTimer: STA ClimbSideTimer ; initialize timer here

Function GiveOneCoin
  Inputs: []
  Outputs: []
  Line 7083: GiveOneCoin: 
    Branch exit: Line 7099: CoinPoints: 
    Line 7093: LDA #$00
    Line 7099: CoinPoints: 
      Line 7103: AddToScore:  (as a call, not in function)

Function ProcFireball_Bubble
  Inputs: []
  Outputs: []
    Line 6272: ProcFireball_Bubble: 
      Branch exit: Line 6310: ProcAirBubbles: 
      Line 6276: LDA A_B_Buttons
        Branch exit: Line 6304: ProcFireballs: 
        Line 6279: AND PreviousA_B_Buttons
          Branch exit: Line 6304: ProcFireballs: 
          Line 6281: LDA FireballCounter             ; load fireball counter
            Branch exit: Line 6304: ProcFireballs: 
            Line 6286: LDY Player_Y_HighPos            ; if player too high or too low, branch
              Branch exit: Line 6304: ProcFireballs: 
              Line 6289: LDA CrouchingFlag               ; if player crouching, branch
                Branch exit: Line 6304: ProcFireballs: 
                Line 6291: LDA Player_State                ; if player's state = climbing, branch
                  Branch exit: Line 6304: ProcFireballs: 
                  Line 6294: LDA #Sfx_Fireball               ; play fireball sound effect
        Line 6304: ProcFireballs: 
      Line 6310: ProcAirBubbles: 
        Branch exit: Line 6321: BublExit: RTS                   ; then leave
        Line 6313: LDX #$02                        ; otherwise load counter and use as offset
          Line 6314: BublLoop: STX ObjectOffset      ; store offset
            Branch exit: Line 6314: BublLoop: STX ObjectOffset      ; store offset
        Line 6321: BublExit: RTS                   ; then leave

Function CheckForCoinMTiles
  Inputs: [A]
  Outputs: [CarryFlag]
    Line 12370: CheckForCoinMTiles: 
      Branch exit: Line 12377: CoinSd: LDA #Sfx_CoinGrab
      Line 12373: CMP #$c3                        ; check for underwater coin
        Branch exit: Line 12377: CoinSd: LDA #Sfx_CoinGrab
        Line 12375: CLC                             ; otherwise clear carry and leave
      Line 12377: CoinSd: LDA #Sfx_CoinGrab

Function RaiseFlagSetoffFWorks
  Inputs: [X]
  Outputs: []
    Line 10517: RaiseFlagSetoffFWorks: 
      Branch exit: Line 10523: SetoffF: LDA FireworksCounter   ; check fireworks counter
      Line 10521: DEC Enemy_Y_Position,X          ; otherwise, raise star flag by one pixel
        Branch exit: Line 10529: DrawStarFlag: 
      Line 10523: SetoffF: LDA FireworksCounter   ; check fireworks counter
        Branch exit: Line 10554: DrawFlagSetTimer: 
        Line 10525: BMI DrawFlagSetTimer            ; if no fireworks set to go off, skip this part
          Branch exit: Line 10554: DrawFlagSetTimer: 
          Line 10526: LDA #Fireworks
      Line 10529: DrawStarFlag:  (as a call, not in function)

Function InitBowserFlame
  Inputs: [X]
  Outputs: []
        Line 8553: InitBowserFlame: 
          Branch exit: Line 8543: FlmEx: RTS                      ; and then leave
          Line 8556: STA Enemy_Y_MoveForce,X         ; reset something here
            Branch exit: Line 8589: SpawnFromMouth: 
            Line 8564: JSR SetFlameTimer               ; get timer data based on flame counter
              Branch exit: Line 8571: SetFrT: STA FrenzyEnemyTimer    ; set timer accordingly
              Line 8569: SEC 
              Line 8571: SetFrT: STA FrenzyEnemyTimer    ; set timer accordingly
                Line 8578: PutAtRightExtent:  (as a call, not in function)

Function GetAreaObjectID
  Inputs: [$00]
  Outputs: [Y]
    Line 4202: GetAreaObjectID: 

Function NoiseSfxHandler
  Inputs: []
  Outputs: []
    Line 15574: NoiseSfxHandler: 
      Branch exit: Line 15583: CheckNoiseBuffer: 
      Line 15577: STY NoiseSoundBuffer            ; if found, put in buffer
        Branch exit: Line 15547: PlayBrickShatter: 
        Line 15580: LSR NoiseSoundQueue
          Branch exit: Line 15592: PlayBowserFlame: 
          Line 15582: 
      Line 15583: CheckNoiseBuffer: 
        Branch exit: Line 15590: ExNH: RTS 
        Line 15586: LSR 
          Branch exit: Line 15551: ContinueBrickShatter: 
          Line 15588: LSR 
            Branch exit: Line 15596: ContinueBowserFlame: 
        Line 15590: ExNH: RTS 

Function WritePPUReg1
  Inputs: [A]
  Outputs: []
    Line 2507: WritePPUReg1: 

Function FindEmptyMiscSlot
  Inputs: []
  Outputs: [CarryFlag]
    Line 6999: FindEmptyMiscSlot: 
      Line 7001: FMiscLoop: LDA Misc_State,Y     ; get misc object state
        Branch exit: Line 7007: UseMiscS: STY JumpCoinMiscOffset; store offset of misc object buffer here (residual)
        Line 7003: DEY                             ; decrement offset
          Branch exit: Line 7001: FMiscLoop: LDA Misc_State,Y     ; get misc object state
          Line 7006: LDY #$08                        ; if no empty slots found, use last slot
        Line 7007: UseMiscS: STY JumpCoinMiscOffset; store offset of misc object buffer here (residual)

Function RightPlatform
  Inputs: [A, X]
  Outputs: []
    Line 10961: RightPlatform: 
      Branch exit: Line 10969: ExRPl: RTS                      ; then leave
      Line 10966: LDA #$10
      Line 10969: ExRPl: RTS                      ; then leave

Function RenderSidewaysPipe
  Inputs: [Y, X]
  Outputs: [CarryFlag]
            Line 3814: RenderSidewaysPipe: 
              Branch exit: Line 3829: DrawSidePart: LDY $06           ; render side pipe part at the bottom
              Line 3825: LDX #$00
              Line 3829: DrawSidePart: LDY $06           ; render side pipe part at the bottom

Function InitPodoboo
  Inputs: [X]
  Outputs: []
    Line 8143: InitPodoboo: 
      Branch exit: Line 8208: SmallBBox: LDA #$09             ; set specific bounding box size control

Function SpriteShuffler
  Inputs: []
  Outputs: []
    Line 886: SpriteShuffler: 
      Line 891: ShuffleLoop: LDA SprDataOffset,X; check for offset value against
        Branch exit: Line 901: NextSprOffset: DEX              ; move backwards to next one
        Line 894: LDY SprShuffleAmtOffset         ; get current offset to preset value we want to add
          Branch exit: Line 900: StrSprOffset: STA SprDataOffset,X; store new offset here or old one if branched to here
          Line 898: CLC 
          Line 900: StrSprOffset: STA SprDataOffset,X; store new offset here or old one if branched to here
        Line 901: NextSprOffset: DEX              ; move backwards to next one
          Branch exit: Line 891: ShuffleLoop: LDA SprDataOffset,X; check for offset value against
          Line 903: LDX SprShuffleAmtOffset         ; load offset
            Branch exit: Line 908: SetAmtOffset: STX SprShuffleAmtOffset
            Line 907: LDX #$00                        ; otherwise, init to 0
            Line 908: SetAmtOffset: STX SprShuffleAmtOffset
              Line 911: SetMiscOffset: LDA SprDataOffset+5,Y; load one of three OAM data offsets
                Branch exit: Line 911: SetMiscOffset: LDA SprDataOffset+5,Y; load one of three OAM data offsets
                Line 924: RTS 

Function MovePlayerYAxis
  Inputs: [A]
  Outputs: []
    Line 5696: MovePlayerYAxis: 

Function DropPlatform
  Inputs: [X]
  Outputs: []
    Line 10951: DropPlatform: 
      Branch exit: Line 10956: ExDPl: RTS                      ; leave
      Line 10954: JSR MoveDropPlatform            ; otherwise do a sub to move platform down very quickly
      Line 10956: ExDPl: RTS                      ; leave

Function CastleObject
  Inputs: [Y, X]
  Outputs: []
      Line 3711: CastleObject: 
        Line 3722: CRendLoop: LDA CastleMetatiles,Y; load current byte using offset
          Branch exit: Line 3733: ChkCFloor: CPX #$0b             ; have we reached the row just before floor?
          Line 3727: INY                             ; if not, increment column-wise
          Line 3733: ChkCFloor: CPX #$0b             ; have we reached the row just before floor?
            Branch exit: Line 3722: CRendLoop: LDA CastleMetatiles,Y; load current byte using offset
            Line 3735: PLA 
              Branch exit: Line 3765: ExitCastle: RTS 
              Line 3739: LDA AreaObjectLength,X          ; check length
                Branch exit: Line 3763: PlayerStop: LDY #$52            ; put brick at floor to stop player at end of level
                Line 3742: LDY $07                         ; check starting row for tall castle ($00)
                  Branch exit: Line 3746: NotTall: CMP #$02               ; if not tall castle, check to see if we're at the third column
                  Line 3744: CMP #$03                        ; if found, then check to see if we're at the second column
                    Branch exit: Line 3763: PlayerStop: LDY #$52            ; put brick at floor to stop player at end of level
                  Line 3746: NotTall: CMP #$02               ; if not tall castle, check to see if we're at the third column
                    Branch exit: Line 3765: ExitCastle: RTS 
                    Line 3748: JSR GetAreaObjXPosition         ; otherwise, obtain and save horizontal pixel coordinate
                Line 3763: PlayerStop: LDY #$52            ; put brick at floor to stop player at end of level
              Line 3765: ExitCastle: RTS 

Function WriteTopStatusLine
  Inputs: []
  Outputs: []
    Line 1491: WriteTopStatusLine: 
      Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function QuestionBlockRow_High
  Inputs: []
  Outputs: []
    Line 3918: QuestionBlockRow_High: 
      Line 3922: QuestionBlockRow_Low:  (as a call, not in function)

Function QuestionBlock
  Inputs: [Y, $07]
  Outputs: []
    Line 4178: QuestionBlock: 
      Branch exit: Line 4197: DrawQBlk: LDA BrickQBlockMetatiles,Y; get appropriate metatile for brick (question block

Function GetAreaObjYPosition
  Inputs: [$07]
  Outputs: [A]
    Line 4310: GetAreaObjYPosition: 

Function PlayerChangeSize
  Inputs: []
  Outputs: []
    Line 5731: PlayerChangeSize: 
      Branch exit: Line 5736: EndChgSize: CMP #$c4            ; check again for another specific moment
      Line 5735: JMP InitChangeSize              ; otherwise run code to get growing/shrinking going
        Branch exit: Line 5752: InitChangeSize: 
      Line 5736: EndChgSize: CMP #$c4            ; check again for another specific moment
        Branch exit: Line 5739: ExitChgSize: RTS                ; and then leave
        Line 5738: JSR DonePlayerTask              ; otherwise do sub to init timer control and set routine
        Line 5739: ExitChgSize: RTS                ; and then leave

Function GetBubbleOffscreenBits
  Inputs: [$00]
  Outputs: [X]
    Line 14831: GetBubbleOffscreenBits: 
      Branch exit: Line 14868: GetOffScreenBitsSet: 

Function DrawOneSpriteRow
  Inputs: [A, $03, $00, Y, $04, $02, $05, X]
  Outputs: [X]
      Line 14067: DrawOneSpriteRow: 
        Branch exit: Line 14999: DrawSpriteObject: 

Function DrawBubble
  Inputs: [X]
  Outputs: []
    Line 14371: DrawBubble: 
      Branch exit: Line 14387: ExDBub: RTS                     ; leave
      Line 14375: LDA Bubble_OffscreenBits        ; check air bubble's offscreen bits
        Branch exit: Line 14387: ExDBub: RTS                     ; leave
        Line 14378: LDY Bubble_SprDataOffset,X      ; get air bubble's OAM data offset
      Line 14387: ExDBub: RTS                     ; leave

Function GetMiscBoundBox
  Inputs: [X]
  Outputs: []
          Line 12787: GetMiscBoundBox: 

Function IntroPipe
  Inputs: [CarryFlag]
  Outputs: []
    Line 3784: IntroPipe: 
      Branch exit: Line 3797: NoBlankP: RTS 
      Line 3790: LDX #$06                        ; blank everything above the vertical pipe part
        Line 3791: VPipeSectLoop: LDA #$00         ; all the way to the top of the screen
          Branch exit: Line 3791: VPipeSectLoop: LDA #$00         ; all the way to the top of the screen
          Line 3795: LDA VerticalPipeData,Y          ; draw the end of the vertical pipe part
      Line 3797: NoBlankP: RTS 

Function MoveFlyingCheepCheep
  Inputs: [X]
  Outputs: []
        Line 9921: MoveFlyingCheepCheep: 
          Branch exit: Line 9928: FlyCC: JSR MoveEnemyHorizontally; move cheep-cheep horizontally based on speed and force
          Line 9925: LDA #$00
            Branch exit: Line 7641: MoveJ_EnemyVertically: 
          Line 9928: FlyCC: JSR MoveEnemyHorizontally; move cheep-cheep horizontally based on speed and force
            Branch exit: Line 9945: AddCCF: CMP #$08                ; if result or two's compliment greater than eight,
            Line 9942: EOR #$ff
            Line 9945: AddCCF: CMP #$08                ; if result or two's compliment greater than eight,
              Branch exit: Line 9956: BPGet: LDA FlyCCBPriority,Y     ; load bg priority data and store (this is very likely
              Line 9947: LDA Enemy_Y_MoveForce,X
              Line 9956: BPGet: LDA FlyCCBPriority,Y     ; load bg priority data and store (this is very likely

Function DigitsMathRoutine
  Inputs: [Y]
  Outputs: []
    Line 2582: DigitsMathRoutine: 
      Branch exit: Line 2597: EraseDMods: LDA #$00            ; store zero here
      Line 2586: LDX #$05
        Line 2587: AddModLoop: LDA DigitModifier,X ; load digit amount to increment
          Branch exit: Line 2603: BorrowOne: DEC DigitModifier-1,X; decrement the previous digit, then put $09 in
          Line 2591: CMP #10
            Branch exit: Line 2606: CarryOne: SEC                   ; subtract ten from our digit to make it a
          Line 2593: StoreNewD: STA DisplayDigits,Y  ; store as new score or game timer digit
            Branch exit: Line 2587: AddModLoop: LDA DigitModifier,X ; load digit amount to increment
          Line 2603: BorrowOne: DEC DigitModifier-1,X; decrement the previous digit, then put $09 in
            Branch exit: Line 2593: StoreNewD: STA DisplayDigits,Y  ; store as new score or game timer digit
          Line 2606: CarryOne: SEC                   ; subtract ten from our digit to make it a
            Branch exit: Line 2593: StoreNewD: STA DisplayDigits,Y  ; store as new score or game timer digit
      Line 2597: EraseDMods: LDA #$00            ; store zero here
        Line 2599: EraseMLoop: STA DigitModifier-1,X; initialize the digit amounts to increment
          Branch exit: Line 2599: EraseMLoop: STA DigitModifier-1,X; initialize the digit amounts to increment
          Line 2602: RTS 

Function PlayerFireFlower
  Inputs: []
  Outputs: []
    Line 5778: PlayerFireFlower: 
      Branch exit: Line 5795: ResetPalFireFlower: 
      Line 5782: LDA FrameCounter                ; get frame counter
        Line 5786: CyclePlayerPalette:  (as a call, not in function)

Function BalancePlatRope
  Inputs: [X]
  Outputs: []
    Line 3997: BalancePlatRope: 

Function DrawPowerUp
  Inputs: []
  Outputs: []
        Line 13483: DrawPowerUp: 
          Line 13504: PUpDrawLoop: 
            Branch exit: Line 13504: PUpDrawLoop: 
            Line 13511: LDY Enemy_SprDataOffset+5       ; get sprite data offset again
              Branch exit: Line 13536: PUpOfs: JMP SprObjectOffscrChk  ; jump to check to see if power-up is offscreen at all, then leave
              Line 13514: CMP #$03
                Branch exit: Line 13536: PUpOfs: JMP SprObjectOffscrChk  ; jump to check to see if power-up is offscreen at all, then leave
                Line 13516: STA $00                         ; store power-up type here now
                  Branch exit: Line 13529: FlipPUpRightSide: 
                  Line 13526: STA Sprite_Attributes+8,Y       ; otherwise set new palette bits  for bottom left
                  Line 13529: FlipPUpRightSide: 
              Line 13536: PUpOfs: JMP SprObjectOffscrChk  ; jump to check to see if power-up is offscreen at all, then leave
                Branch exit: Line 14018: SprObjectOffscrChk: 

Function BrickShatter
  Inputs: [X]
  Outputs: []
    Line 7378: BrickShatter: 

Function ProcBowserFlame
  Inputs: [X]
  Outputs: []
    Line 10323: ProcBowserFlame: 
      Branch exit: Line 10348: SetGfxF: JSR RelativeEnemyPosition; get new relative coordinates
      Line 10326: LDA #$40                        ; load default movement force
        Branch exit: Line 10330: SFlmX: STA $00                  ; store value here
        Line 10329: LDA #$60                        ; otherwise load alternate movement force to go faster
        Line 10330: SFlmX: STA $00                  ; store value here
          Branch exit: Line 10348: SetGfxF: JSR RelativeEnemyPosition; get new relative coordinates
          Line 10345: CLC 
      Line 10348: SetGfxF: JSR RelativeEnemyPosition; get new relative coordinates
        Branch exit: Line 10321: ExFl: RTS 
        Line 10351: LDA #$51                        ; otherwise, continue
          Branch exit: Line 10358: FlmeAt: STY $01                 ; set bowser's flame sprite attributes here
          Line 10357: LDY #$82                        ; otherwise write value with vertical flip bit set
          Line 10358: FlmeAt: STY $01                 ; set bowser's flame sprite attributes here
            Line 10362: DrawFlameLoop: 
              Branch exit: Line 10362: DrawFlameLoop: 
              Line 10382: LDX ObjectOffset                ; reload original enemy offset
                Branch exit: Line 10391: M3FOfs: PLA                     ; get bits from stack
                Line 10389: LDA #$f8                        ; otherwise move sprite offscreen, this part likely
                Line 10391: M3FOfs: PLA                     ; get bits from stack
                  Branch exit: Line 10397: M2FOfs: PLA                     ; get bits from stack again
                  Line 10395: LDA #$f8                        ; otherwise move third sprite offscreen
                  Line 10397: M2FOfs: PLA                     ; get bits from stack again
                    Branch exit: Line 10403: M1FOfs: PLA                     ; get bits from stack one last time
                    Line 10401: LDA #$f8                        ; otherwise move second sprite offscreen
                    Line 10403: M1FOfs: PLA                     ; get bits from stack one last time
                      Branch exit: Line 10408: ExFlmeD: RTS                    ; leave
                      Line 10406: LDA #$f8
                      Line 10408: ExFlmeD: RTS                    ; leave

Function ScrollHandler
  Inputs: []
  Outputs: []
    Line 5377: ScrollHandler: 
      Branch exit: Line 5425: InitScrlAmt: LDA #$00
      Line 5384: LDA Player_Pos_ForScroll
        Branch exit: Line 5425: InitScrlAmt: LDA #$00
        Line 5387: LDA SideCollisionTimer          ; if timer related to player's side collision
          Branch exit: Line 5425: InitScrlAmt: LDA #$00
          Line 5389: LDY Player_X_Scroll             ; get value and decrement by one
            Branch exit: Line 5425: InitScrlAmt: LDA #$00
            Line 5392: INY 
              Branch exit: Line 5396: ChkNearMid: LDA Player_Pos_ForScroll
              Line 5395: DEY                             ; otherwise decrement by one
              Line 5396: ChkNearMid: LDA Player_Pos_ForScroll
                Branch exit: Line 5401: ScrollScreen: 
                Line 5399: LDY Player_X_Scroll             ; otherwise get original value undecremented
                Line 5401: ScrollScreen:  (as a call, not in function)
      Line 5425: InitScrlAmt: LDA #$00
      Line 5427: ChkPOffscr: LDX #$00            ; set X for player offset
        Branch exit: Line 5437: KeepOnscr: LDA ScreenEdge_X_Pos,Y; get left or right side coordinate based on offset
        Line 5433: INY                             ; otherwise use different offset (right side)
          Branch exit: Line 5449: InitPlatScrl: LDA #$00          ; nullify platform force imposed on scroll
        Line 5437: KeepOnscr: LDA ScreenEdge_X_Pos,Y; get left or right side coordinate based on offset
          Branch exit: Line 5449: InitPlatScrl: LDA #$00          ; nullify platform force imposed on scroll
          Line 5447: LDA #$00
        Line 5449: InitPlatScrl: LDA #$00          ; nullify platform force imposed on scroll

Function EnemiesCollision
  Inputs: [X, Y]
  Outputs: []
        Line 11551: EnemiesCollision: 
          Branch exit: Line 11540: ExSFN: RTS 
          Line 11555: LDA AreaType
            Branch exit: Line 11540: ExSFN: RTS 
            Line 11557: LDA Enemy_ID,X
              Branch exit: Line 11618: ExitECRoutine: 
              Line 11560: CMP #Lakitu                     ; if lakitu, branch to leave
                Branch exit: Line 11618: ExitECRoutine: 
                Line 11562: CMP #PiranhaPlant               ; if piranha plant, branch to leave
                  Branch exit: Line 11618: ExitECRoutine: 
                  Line 11564: LDA EnemyOffscrBitsMasked,X     ; if masked offscreen bits nonzero, branch to leave
                    Branch exit: Line 11618: ExitECRoutine: 
                    Line 11566: JSR GetEnemyBoundBoxOfs         ; otherwise, do sub, get appropriate bounding box offset for
                      Branch exit: Line 11618: ExitECRoutine: 

Function DisplayIntermediate
  Inputs: []
  Outputs: []
    Line 1539: DisplayIntermediate: 
      Branch exit: Line 1563: NoInter: LDA #$08               ; set for specific task and leave
      Line 1542: CMP #GameOverModeValue          ; are we in game over mode?
        Branch exit: Line 1558: GameOverInter: LDA #$12         ; set screen timer
        Line 1544: LDA AltEntranceControl          ; otherwise check for mode of alternate entry
          Branch exit: Line 1563: NoInter: LDA #$08               ; set for specific task and leave
          Line 1546: LDY AreaType                    ; check if we are on castle level
            Branch exit: Line 1551: PlayerInter: JSR DrawPlayer_Intermediate; put player in appropriate place for
            Line 1549: LDA DisableIntermediate         ; if this flag is set, skip intermediate lives display
              Branch exit: Line 1563: NoInter: LDA #$08               ; set for specific task and leave
            Line 1551: PlayerInter: JSR DrawPlayer_Intermediate; put player in appropriate place for
        Line 1558: GameOverInter: LDA #$12         ; set screen timer
          Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode
      Line 1563: NoInter: LDA #$08               ; set for specific task and leave

Function Hidden1UpBlock
  Inputs: []
  Outputs: []
    Line 4171: Hidden1UpBlock: 
      Branch exit: Line 4207: ExitDecBlock: RTS 
      Line 4174: LDA #$00                        ; if set, init for the next one
        Branch exit: Line 4186: BrickWithItem: 

Function CoinBlock
  Inputs: [X, Y, CarryFlag]
  Outputs: []
    Line 6962: CoinBlock: 
      Branch exit: Line 6988: JCoinC: LDA #$fb

Function Bridge_Middle
  Inputs: []
  Outputs: []
      Line 3938: Bridge_Middle: 
        Line 3942: Bridge_Low:  (as a call, not in function)

Function PutAtRightExtent
  Inputs: [A, X]
  Outputs: [A]
                Line 8578: PutAtRightExtent: 
                  Branch exit: Line 8614: FinishFlame: 

Function RenderAreaGraphics
  Inputs: []
  Outputs: []
    Line 1799: RenderAreaGraphics: 
      Line 1814: DrawMTLoop: STX $01             ; store init value of 0 or incremented offset for buffer
        Branch exit: Line 1852: RightCheck: LDA $01             ; get LSB of current row we're rendering
        Line 1845: LDA $01                         ; get current row we're rendering
          Branch exit: Line 1860: LLeft: LSR $03                  ; shift attribute bits 2 to the right
          Line 1848: ROL $03                         ; rotate attribute bits 3 to the left
            Branch exit: Line 1863: SetAttrib: LDA AttributeBuffer,Y; get previously saved bits from before
          Line 1860: LLeft: LSR $03                  ; shift attribute bits 2 to the right
        Line 1852: RightCheck: LDA $01             ; get LSB of current row we're rendering
          Branch exit: Line 1862: NextMTRow: INC $04              ; move onto next attribute row
          Line 1855: LSR $03                         ; shift attribute bits 4 to the right
            Branch exit: Line 1863: SetAttrib: LDA AttributeBuffer,Y; get previously saved bits from before
        Line 1862: NextMTRow: INC $04              ; move onto next attribute row
        Line 1863: SetAttrib: LDA AttributeBuffer,Y; get previously saved bits from before
          Branch exit: Line 1814: DrawMTLoop: STX $01             ; store init value of 0 or incremented offset for buffer
          Line 1872: LDY $00                         ; get current vram buffer offset, increment by 3
            Branch exit: Line 1888: ExitDrawM: JMP SetVRAMCtrl      ; jump to set buffer to $0341 and leave
            Line 1883: LDA #$80                        ; if wraparound occurs, make sure low byte stays
            Line 1888: ExitDrawM: JMP SetVRAMCtrl      ; jump to set buffer to $0341 and leave
              Branch exit: Line 1936: SetVRAMCtrl: LDA #$06

Function PlayerCtrlRoutine
  Inputs: []
  Outputs: []
  Line 5557: PlayerCtrlRoutine: 
    Branch exit: Line 5589: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
    Line 5561: LDA AreaType                    ; are we in a water type area?
      Branch exit: Line 5571: SaveJoyp: LDA SavedJoypadBits   ; otherwise store A and B buttons in $0a
      Line 5563: LDY Player_Y_HighPos
        Branch exit: Line 5569: DisJoyp: LDA #$00               ; disable controller bits
        Line 5566: LDA Player_Y_Position
          Branch exit: Line 5571: SaveJoyp: LDA SavedJoypadBits   ; otherwise store A and B buttons in $0a
        Line 5569: DisJoyp: LDA #$00               ; disable controller bits
      Line 5571: SaveJoyp: LDA SavedJoypadBits   ; otherwise store A and B buttons in $0a
        Branch exit: Line 5589: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
        Line 5582: LDA Player_State                ; check player's state
          Branch exit: Line 5589: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
          Line 5584: LDY Left_Right_Buttons          ; check left and right
            Branch exit: Line 5589: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
            Line 5586: LDA #$00
    Line 5589: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
      Branch exit: Line 5597: ChkMoveDir: STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control
      Line 5593: LDY #$00                        ; check for if crouching
        Branch exit: Line 5597: ChkMoveDir: STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control
        Line 5596: LDY #$02                        ; if big and crouching, load y with 2
      Line 5597: ChkMoveDir: STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control
        Branch exit: Line 5604: PlayerSubs: JSR ScrollHandler   ; move the screen if necessary
        Line 5601: BPL SetMoveDir                  ; if moving to the right, use default moving direction
          Branch exit: Line 5603: SetMoveDir: STA Player_MovingDir; set moving direction
          Line 5602: ASL                             ; otherwise change to move to the left
          Line 5603: SetMoveDir: STA Player_MovingDir; set moving direction
        Line 5604: PlayerSubs: JSR ScrollHandler   ; move the screen if necessary
          Branch exit: Line 5623: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
          Line 5613: LDA GameEngineSubroutine
            Branch exit: Line 5623: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
            Line 5616: CMP #$07                        ; if running player entrance routine, branch ahead
              Branch exit: Line 5623: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
              Line 5618: CMP #$04                        ; if running routines $00-$03, branch ahead
                Branch exit: Line 5623: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
                Line 5620: LDA Player_SprAttrib
          Line 5623: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
            Branch exit: Line 5654: ExitCtrl: RTS                   ; leave
            Line 5626: LDX #$01
              Branch exit: Line 5635: HoleDie: INX                    ; set flag in X for player death
              Line 5633: LDY CloudTypeOverride           ; check for cloud type override
                Branch exit: Line 5646: ChkHoleX: CMP $07               ; compare vertical high byte with value set here
              Line 5635: HoleDie: INX                    ; set flag in X for player death
                Branch exit: Line 5646: ChkHoleX: CMP $07               ; compare vertical high byte with value set here
                Line 5639: LDY DeathMusicLoaded            ; check value here
                  Branch exit: Line 5644: HoleBottom: LDY #$06
                  Line 5641: INY 
                  Line 5644: HoleBottom: LDY #$06
              Line 5646: ChkHoleX: CMP $07               ; compare vertical high byte with value set here
                Branch exit: Line 5654: ExitCtrl: RTS                   ; leave
                Line 5648: DEX                             ; otherwise decrement flag in X
                  Branch exit: Line 5656: CloudExit: 
                  Line 5650: LDY EventMusicBuffer            ; check to see if music is still playing
                    Branch exit: Line 5654: ExitCtrl: RTS                   ; leave
                    Line 5652: LDA #$06                        ; otherwise set to run lose life routine
            Line 5654: ExitCtrl: RTS                   ; leave

Function RowOfBricks
  Inputs: [$07]
  Outputs: []
        Line 4060: RowOfBricks: 
          Branch exit: Line 4065: DrawBricks: LDA BrickMetatiles,Y; get appropriate metatile
          Line 4064: LDY #$04                        ; if cloud type, override area type
          Line 4065: DrawBricks: LDA BrickMetatiles,Y; get appropriate metatile
            Branch exit: Line 4071: GetRow: PHA                     ; store metatile here

Function RowOfSolidBlocks
  Inputs: [$07]
  Outputs: []
    Line 4068: RowOfSolidBlocks: 

Function EndlessRope
  Inputs: []
  Outputs: []
    Line 3992: EndlessRope: 
      Branch exit: Line 4008: DrawRope: LDA #$40              ; render the actual rope

Function MoveEnemySlowVert
  Inputs: []
  Outputs: []
  Line 7634: MoveEnemySlowVert: 

Function QuestionBlockRow_Low
  Inputs: []
  Outputs: []
      Line 3922: QuestionBlockRow_Low: 

Function Dump_Squ1_Regs
  Inputs: [Y, X]
  Outputs: []
    Line 15129: Dump_Squ1_Regs: 

Function GoContinue
  Inputs: [A]
  Outputs: []
  Line 1055: GoContinue: STA WorldNumber     ; start both players at the first area

Function RunRetainerObj
  Inputs: []
  Outputs: []
    Line 9059: RunRetainerObj: 
      Branch exit: Line 13613: EnemyGfxHandler: 

Function GetEnemyBoundBox
  Inputs: [X]
  Outputs: []
    Line 12796: GetEnemyBoundBox: 
      Branch exit: Line 12807: GetMaskedOffScrBits: 

Function LoadAreaPointer
  Inputs: [A]
  Outputs: []
      Line 4355: LoadAreaPointer: 
        Line 4358: GetAreaType: AND #%01100000     ; mask out all but d6 and d5 (as a call, not in function)

Function DrawHammer
  Inputs: [X]
  Outputs: []
                  Line 13198: DrawHammer: 
                    Branch exit: Line 13206: ForceHPose: LDX #$00            ; reset offset here
                    Line 13202: LDA Misc_State,X                ; otherwise get hammer's state
                      Branch exit: Line 13208: GetHPose: LDA FrameCounter      ; get frame counter
                    Line 13206: ForceHPose: LDX #$00            ; reset offset here
                      Branch exit: Line 13213: RenderH: LDA Misc_Rel_YPos      ; get relative vertical coordinate
                    Line 13208: GetHPose: LDA FrameCounter      ; get frame counter
                    Line 13213: RenderH: LDA Misc_Rel_YPos      ; get relative vertical coordinate
                      Branch exit: Line 13242: NoHOffscr: RTS                  ; leave
                      Line 13238: LDA #$00
                      Line 13242: NoHOffscr: RTS                  ; leave

Function RunNormalEnemies
  Inputs: [X]
  Outputs: []
    Line 9066: RunNormalEnemies: 
      Branch exit: Line 9079: SkipMove: JMP OffscreenBoundsCheck
      Line 9078: JSR EnemyMovementSubs
      Line 9079: SkipMove: JMP OffscreenBoundsCheck
        Branch exit: Line 11005: OffscreenBoundsCheck: 

Function InitRedPTroopa
  Inputs: [X, CarryFlag]
  Outputs: []
      Line 8213: InitRedPTroopa: 
        Branch exit: Line 8219: GetCent: TYA                    ; send central position adder to A
        Line 8218: LDY #$e0                        ; if => $80, load position adder for 32 pixels up
        Line 8219: GetCent: TYA                    ; send central position adder to A

Function GetEnemyOffscreenBits
  Inputs: [X]
  Outputs: []
    Line 14853: GetEnemyOffscreenBits: 
      Branch exit: Line 14862: SetOffscrBitsOffset: 

Function WriteNTAddr
  Inputs: [A]
  Outputs: []
      Line 2395: WriteNTAddr: STA PPU_ADDRESS
        Line 2401: InitNTLoop: STA PPU_DATA        ; count out exactly 768 tiles
          Branch exit: Line 2401: InitNTLoop: STA PPU_DATA        ; count out exactly 768 tiles
          Line 2404: DEX 
            Branch exit: Line 2401: InitNTLoop: STA PPU_DATA        ; count out exactly 768 tiles
            Line 2406: LDY #64                         ; now to clear the attribute table (with zero this time)
              Line 2410: InitATLoop: STA PPU_DATA
                Branch exit: Line 2410: InitATLoop: STA PPU_DATA
                Line 2413: STA HorizontalScroll            ; reset scroll variables
                  Branch exit: Line 2501: InitScroll: STA PPU_SCROLL_REG  ; store contents of A into scroll registers

Function NoMoveCode
  Inputs: []
  Outputs: []
        Line 9109: NoMoveCode: 

Function DrawFirebar_Collision
  Inputs: [$03, $06, $01, $02]
  Outputs: []
    Line 9758: DrawFirebar_Collision: 
      Branch exit: Line 9767: AddHA: CLC                      ; add horizontal coordinate relative to screen to
      Line 9765: EOR #$ff
      Line 9767: AddHA: CLC                      ; add horizontal coordinate relative to screen to
        Branch exit: Line 9777: SubtR1: SEC                     ; subtract original X from the
        Line 9773: LDA Enemy_Rel_XPos
          Branch exit: Line 9779: ChkFOfs: CMP #$59               ; if difference of coordinates within a certain range,
        Line 9777: SubtR1: SEC                     ; subtract original X from the
        Line 9779: ChkFOfs: CMP #$59               ; if difference of coordinates within a certain range,
          Branch exit: Line 9783: VAHandl: LDA Enemy_Rel_YPos     ; if vertical relative coordinate offscreen,
          Line 9781: LDA #$f8                        ; otherwise, load offscreen Y coordinate
            Branch exit: Line 9793: SetVFbr: STA Sprite_Y_Position,Y; store as Y coordinate here
          Line 9783: VAHandl: LDA Enemy_Rel_YPos     ; if vertical relative coordinate offscreen,
            Branch exit: Line 9793: SetVFbr: STA Sprite_Y_Position,Y; store as Y coordinate here
            Line 9786: LDA $02                         ; load vertical adder we got from position loader
              Branch exit: Line 9791: AddVA: CLC                      ; add vertical coordinate relative to screen to
              Line 9789: EOR #$ff
              Line 9791: AddVA: CLC                      ; add vertical coordinate relative to screen to
          Line 9793: SetVFbr: STA Sprite_Y_Position,Y; store as Y coordinate here
            Line 9796: FirebarCollision:  (as a call, not in function)

Function PlayerHeadCollision
  Inputs: [A, $02, $06, CarryFlag]
  Outputs: []
      Line 7218: PlayerHeadCollision: 
        Branch exit: Line 7225: DBlockSte: STA Block_State,X    ; store into block object buffer
        Line 7224: LDA #$12                        ; otherwise load breakable block object state
        Line 7225: DBlockSte: STA Block_State,X    ; store into block object buffer
          Branch exit: Line 7239: ChkBrick: BCC PutMTileB         ; if no match was found in previous sub, skip ahead
          Line 7238: TYA                             ; otherwise init A (note: big = 0)
          Line 7239: ChkBrick: BCC PutMTileB         ; if no match was found in previous sub, skip ahead
            Branch exit: Line 7257: PutMTileB: STA Block_Metatile,X ; store whatever metatile be appropriate here
            Line 7240: LDY #$11                        ; otherwise load unbreakable state into block object buffer
              Branch exit: Line 7248: StartBTmr: LDA BrickCoinTimerFlag; check brick coin timer flag
              Line 7246: CPY #$5d                        ; is it brick with coins (without line)?
                Branch exit: Line 7257: PutMTileB: STA Block_Metatile,X ; store whatever metatile be appropriate here
              Line 7248: StartBTmr: LDA BrickCoinTimerFlag; check brick coin timer flag
                Branch exit: Line 7253: ContBTmr: LDA BrickCoinTimer    ; check brick coin timer
                Line 7250: LDA #$0b
                Line 7253: ContBTmr: LDA BrickCoinTimer    ; check brick coin timer
                  Branch exit: Line 7256: PutOldMT: TYA                   ; put metatile into A
                  Line 7255: LDY #$c4                        ; otherwise use empty block metatile
                  Line 7256: PutOldMT: TYA                   ; put metatile into A
            Line 7257: PutMTileB: STA Block_Metatile,X ; store whatever metatile be appropriate here
              Branch exit: Line 7271: SmallBP: INY                    ; increment for small or big and crouching
              Line 7269: LDA PlayerSize                  ; is player big?
                Branch exit: Line 7272: BigBP: LDA Player_Y_Position    ; get player's vertical coordinate
              Line 7271: SmallBP: INY                    ; increment for small or big and crouching
              Line 7272: BigBP: LDA Player_Y_Position    ; get player's vertical coordinate
                Branch exit: Line 7282: Unbreak: JSR BumpBlock          ; execute code for unbreakable brick or question block
                Line 7280: JSR BrickShatter                ; execute code for breakable brick
                  Branch exit: Line 7283: InvOBit: LDA SprDataOffset_Ctrl ; invert control bit used by block objects
                Line 7282: Unbreak: JSR BumpBlock          ; execute code for unbreakable brick or question block
                Line 7283: InvOBit: LDA SprDataOffset_Ctrl ; invert control bit used by block objects

Function CheckpointEnemyID
  Inputs: [X]
  Outputs: []
  Line 8054: CheckpointEnemyID: 
    Branch exit: Line 8066: InitEnemyRoutines: 
    Line 8058: TAY                             ; save identifier in Y register for now
    Line 8066: InitEnemyRoutines: 
      Line 8068: 
        Line 8132: NoInitCode:  (as a call, not in function)

Function ChkInvisibleMTiles
  Inputs: [A]
  Outputs: [ZeroFlag]
    Line 12237: ChkInvisibleMTiles: 
      Branch exit: Line 12241: ExCInvT: RTS                    ; leave with zero flag set if either found
      Line 12240: CMP #$60                        ; check for hidden 1-up block
      Line 12241: ExCInvT: RTS                    ; leave with zero flag set if either found

Function DrawEnemyObjRow
  Inputs: [X]
  Outputs: []
    Line 14062: DrawEnemyObjRow: 
      Line 14067: DrawOneSpriteRow:  (as a call, not in function)

Function ProcessAreaData
  Inputs: []
  Outputs: []
      Line 3300: ProcessAreaData: 
        Line 3302: ProcADLoop: STX ObjectOffset
          Branch exit: Line 3344: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
          Line 3309: LDA AreaObjectLength,X          ; check area object buffer flag
            Branch exit: Line 3344: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
            Line 3311: INY 
              Branch exit: Line 3319: Chk1Row13: DEY 
              Line 3315: LDA AreaObjectPageSel           ; check page select
                Branch exit: Line 3319: Chk1Row13: DEY 
                Line 3317: INC AreaObjectPageSel           ; if not already set, set it now
              Line 3319: Chk1Row13: DEY 
                Branch exit: Line 3337: Chk1Row14: CMP #$0e             ; row 14?
                Line 3324: INY                             ; if so, reread second byte of level object
                  Branch exit: Line 3341: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                  Line 3329: LDA AreaObjectPageSel           ; if page select is set, do not reread
                    Branch exit: Line 3341: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                    Line 3331: INY                             ; if d6 not set, reread second byte
                      Branch exit: Line 3347: NextAObj: JSR IncAreaObjOffset  ; increment buffer offset and move on
                Line 3337: Chk1Row14: CMP #$0e             ; row 14?
                  Branch exit: Line 3341: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                  Line 3339: LDA BackloadingFlag             ; check flag for saved page number and branch if set
                    Branch exit: Line 3344: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
                Line 3341: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                  Branch exit: Line 3346: SetBehind: INC BehindAreaParserFlag; turn on flag if object is behind renderer
                  Line 3346: SetBehind: INC BehindAreaParserFlag; turn on flag if object is behind renderer
                Line 3347: NextAObj: JSR IncAreaObjOffset  ; increment buffer offset and move on
          Line 3344: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
            Branch exit: Line 3348: ChkLength: LDX ObjectOffset     ; get buffer offset
          Line 3348: ChkLength: LDX ObjectOffset     ; get buffer offset
            Branch exit: Line 3352: ProcLoopb: DEX                  ; decrement buffer offset
            Line 3351: DEC AreaObjectLength,X          ; otherwise decrement length or get rid of it
            Line 3352: ProcLoopb: DEX                  ; decrement buffer offset
              Branch exit: Line 3302: ProcADLoop: STX ObjectOffset
              Line 3354: LDA BehindAreaParserFlag        ; check for flag set if objects were behind renderer
                Branch exit: Line 3300: ProcessAreaData: 
                Line 3356: LDA BackloadingFlag             ; check for flag set if starting right of page $00
                  Branch exit: Line 3300: ProcessAreaData: 

Function PlayerEndLevel
  Inputs: []
  Outputs: []
      Line 5830: PlayerEndLevel: 
        Branch exit: Line 5842: ChkStop: LDA Player_CollisionBits; get player collision bits
        Line 5836: LDA ScrollLock                  ; if scroll lock not set, branch ahead to next part
          Branch exit: Line 5842: ChkStop: LDA Player_CollisionBits; get player collision bits
          Line 5838: LDA #EndOfLevelMusic
        Line 5842: ChkStop: LDA Player_CollisionBits; get player collision bits
          Branch exit: Line 5850: RdyNextA: LDA StarFlagTaskControl
          Line 5845: LDA StarFlagTaskControl         ; if star flag task control already set,
            Branch exit: Line 5848: InCastle: LDA #%00100000        ; set player's background priority bit to
            Line 5847: INC StarFlagTaskControl         ; otherwise set task control now (this gets ball rolling!)
            Line 5848: InCastle: LDA #%00100000        ; set player's background priority bit to
          Line 5850: RdyNextA: LDA StarFlagTaskControl
            Branch exit: Line 5869: ExitNA: RTS 
            Line 5853: INC LevelNumber                 ; increment level number used for game logic
              Branch exit: Line 5862: NextArea: INC AreaNumber        ; increment area number used for address loader
              Line 5857: LDY WorldNumber                 ; get world number as offset
                Branch exit: Line 5862: NextArea: INC AreaNumber        ; increment area number used for address loader
                Line 5861: INC Hidden1UpFlag               ; otherwise set hidden 1-up box control flag

Function AreaFrenzy
  Inputs: [$00]
  Outputs: []
      Line 3606: AreaFrenzy: LDX $00             ; use area object identifier bit as offset
        Line 3609: FreCompLoop: DEY                ; check regular slots of enemy object buffer
          Branch exit: Line 3614: ExitAFrenzy: STA EnemyFrenzyQueue; store enemy into frenzy queue
          Line 3611: CMP Enemy_ID,Y                  ; check for enemy object in buffer versus frenzy object
            Branch exit: Line 3609: FreCompLoop: DEY                ; check regular slots of enemy object buffer
            Line 3613: LDA #$00                        ; if enemy object already present, nullify queue and leave
          Line 3614: ExitAFrenzy: STA EnemyFrenzyQueue; store enemy into frenzy queue

Function ChkForLandJumpSpring
  Inputs: [CarryFlag]
  Outputs: []
    Line 12247: ChkForLandJumpSpring: 
      Branch exit: Line 12258: ExCJSp: RTS                     ; and leave
      Line 12250: LDA #$70
      Line 12258: ExCJSp: RTS                     ; and leave

Function GameOverMode
  Inputs: []
  Outputs: []
    Line 2945: GameOverMode: 
      Line 2948: 
        Line 2955: SetupGameOver:  (as a call, not in function)

Function EnemyLanding
  Inputs: [X]
  Outputs: []
    Line 12645: EnemyLanding: 

Function ProcMoveRedPTroopa
  Inputs: [X]
  Outputs: []
    Line 9376: ProcMoveRedPTroopa: 
      Branch exit: Line 9390: MoveRedPTUpOrDown: 
      Line 9380: STA Enemy_YMF_Dummy,X           ; initialize something here
        Branch exit: Line 9390: MoveRedPTUpOrDown: 
        Line 9384: LDA FrameCounter                ; get frame counter
          Branch exit: Line 9388: NoIncPT: RTS                    ; leave
          Line 9387: INC Enemy_Y_Position,X          ; otherwise increment red paratroopa's vertical position
          Line 9388: NoIncPT: RTS                    ; leave

Function ProcessBowserHalf
  Inputs: [X]
  Outputs: []
    Line 10297: ProcessBowserHalf: 
      Branch exit: Line 10295: ExBGfxH: RTS                    ; leave!
      Line 10302: LDA #$0a
        Branch exit: Line 11292: PlayerEnemyCollision: 

Function SetupLakitu
  Inputs: [X]
  Outputs: []
        Line 8257: SetupLakitu: 
          Branch exit: Line 8872: TallBBox2: LDA #$03             ; set specific value for bounding box control

Function InitGoomba
  Inputs: []
  Outputs: []
    Line 8137: InitGoomba: 
      Branch exit: Line 8208: SmallBBox: LDA #$09             ; set specific bounding box size control

Function RunFirebarObj
  Inputs: []
  Outputs: []
    Line 9124: RunFirebarObj: 
      Branch exit: Line 11005: OffscreenBoundsCheck: 

Function RunLargePlatform
  Inputs: []
  Outputs: []
    Line 9142: RunLargePlatform: 
      Branch exit: Line 9150: SkipPT: JSR RelativeEnemyPosition
      Line 9149: JSR LargePlatformSubroutines
      Line 9150: SkipPT: JSR RelativeEnemyPosition
        Branch exit: Line 11005: OffscreenBoundsCheck: 

Function ChkForPlayerC_LargeP
  Inputs: [CarryFlag, X]
  Outputs: []
          Line 11722: ChkForPlayerC_LargeP: 
            Branch exit: Line 11736: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
            Line 11725: TXA 
              Branch exit: Line 11736: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
              Line 11735: JSR ProcLPlatCollisions         ; otherwise collision, perform sub

Function Bridge_High
  Inputs: []
  Outputs: []
    Line 3934: Bridge_High: 
      Line 3938: Bridge_Middle:  (as a call, not in function)

Function GetAlternatePalette1
  Inputs: []
  Outputs: []
    Line 1481: GetAlternatePalette1: 
      Branch exit: Line 1487: NoAltPal: JMP IncSubtask        ; now onto the next task
      Line 1485: LDA #$0b                        ; if found, load appropriate palette

Function DrawLargePlatform
  Inputs: [X]
  Outputs: []
    Line 13331: DrawLargePlatform: 
      Branch exit: Line 13348: ShrinkPlatform: 
      Line 13345: LDY SecondaryHardMode           ; check for secondary hard mode flag set
        Branch exit: Line 13351: SetLast2Platform: 
        Line 13347: 
      Line 13348: ShrinkPlatform: 
      Line 13351: SetLast2Platform: 
        Branch exit: Line 13360: SetPlatformTilenum: 
        Line 13358: LDA #$75                        ; otherwise load other tile for platform (puff)
        Line 13360: SetPlatformTilenum: 
          Branch exit: Line 13376: SChk2: PLA                      ; get bits from stack
          Line 13374: LDA #$f8                        ; if d7 was set, move first sprite offscreen
          Line 13376: SChk2: PLA                      ; get bits from stack
            Branch exit: Line 13382: SChk3: PLA                      ; get bits from stack
            Line 13380: LDA #$f8                        ; if d6 was set, move second sprite offscreen
            Line 13382: SChk3: PLA                      ; get bits from stack
              Branch exit: Line 13388: SChk4: PLA                      ; get bits from stack
              Line 13386: LDA #$f8                        ; if d5 was set, move third sprite offscreen
              Line 13388: SChk4: PLA                      ; get bits from stack
                Branch exit: Line 13394: SChk5: PLA                      ; get bits from stack
                Line 13392: LDA #$f8                        ; if d4 was set, move fourth sprite offscreen
                Line 13394: SChk5: PLA                      ; get bits from stack
                  Branch exit: Line 13400: SChk6: PLA                      ; get bits from stack
                  Line 13398: LDA #$f8                        ; if d3 was set, move fifth sprite offscreen
                  Line 13400: SChk6: PLA                      ; get bits from stack
                    Branch exit: Line 13405: SLChk: LDA Enemy_OffscreenBits  ; check d7 of offscreen bits
                    Line 13403: LDA #$f8
                    Line 13405: SLChk: LDA Enemy_OffscreenBits  ; check d7 of offscreen bits
                      Branch exit: Line 13409: ExDLPl: RTS 
                      Line 13408: JSR MoveSixSpritesOffscreen     ; otherwise branch to move all sprites offscreen
                      Line 13409: ExDLPl: RTS 

Function CheckPlayerVertical
  Inputs: []
  Outputs: [CarryFlag]
    Line 11866: CheckPlayerVertical: 
      Branch exit: Line 11875: ExCPV: RTS 
      Line 11870: LDY Player_Y_HighPos            ; if player high vertical byte is not
        Branch exit: Line 11875: ExCPV: RTS 
        Line 11873: LDA Player_Y_Position           ; if on the screen, check to see how far down
      Line 11875: ExCPV: RTS 

Function InitializeArea
  Inputs: []
  Outputs: []
              Line 2659: InitializeArea: 
                Line 2664: ClrTimersLoop: STA Timers,X     ; clear out memory between
                  Branch exit: Line 2664: ClrTimersLoop: STA Timers,X     ; clear out memory between
                  Line 2667: LDA HalfwayPage
                    Branch exit: Line 2671: StartPage: STA ScreenLeft_PageLoc; set as value here
                    Line 2670: LDA EntrancePage                ; otherwise use saved entry page number here
                    Line 2671: StartPage: STA ScreenLeft_PageLoc; set as value here
                      Branch exit: Line 2679: SetInitNTHigh: STY CurrentNTAddr_High; store name table address
                      Line 2678: LDY #$24
                      Line 2679: SetInitNTHigh: STY CurrentNTAddr_High; store name table address
                        Branch exit: Line 2702: SetSecHard: INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond
                        Line 2695: LDA WorldNumber                 ; otherwise check world number
                          Branch exit: Line 2703: CheckHalfway: LDA HalfwayPage
                          Line 2698: BNE SetSecHard                  ; if not equal to, then world > 5, thus activate
                            Branch exit: Line 2702: SetSecHard: INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond
                            Line 2699: LDA LevelNumber                 ; otherwise, world 5, so check level number
                              Branch exit: Line 2703: CheckHalfway: LDA HalfwayPage
                        Line 2702: SetSecHard: INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond
                        Line 2703: CheckHalfway: LDA HalfwayPage
                          Branch exit: Line 2707: DoneInitArea: LDA #Silence      ; silence music
                          Line 2705: LDA #$02                        ; if halfway page set, overwrite start position from header
                          Line 2707: DoneInitArea: LDA #Silence      ; silence music

Function DividePDiff
  Inputs: [A, $07, $06, Y]
  Outputs: []
    Line 14977: DividePDiff: 
      Branch exit: Line 14990: ExDivPD: RTS                    ; leave
      Line 14982: LSR                             ; divide by eight
        Branch exit: Line 14989: SetOscrO: TAX                   ; use as offset
        Line 14988: ADC $05                         ; if not, add value to difference / 8
        Line 14989: SetOscrO: TAX                   ; use as offset
      Line 14990: ExDivPD: RTS                    ; leave

Function PulleyRopeObject
  Inputs: [CarryFlag, X]
  Outputs: []
      Line 3683: PulleyRopeObject: 
        Branch exit: Line 3691: RenderPul: LDA PulleyRopeMetatiles,Y
        Line 3687: INY 
          Branch exit: Line 3691: RenderPul: LDA PulleyRopeMetatiles,Y
          Line 3690: INY                             ; otherwise render right pulley
        Line 3691: RenderPul: LDA PulleyRopeMetatiles,Y

Function BulletBillCannon
  Inputs: [$07, Y]
  Outputs: []
    Line 4094: BulletBillCannon: 
      Branch exit: Line 4109: SetupCannon: LDX Cannon_Offset  ; get offset for data used by cannons and whirlpools
      Line 4102: LDA #$65                        ; if not, render middle part
        Branch exit: Line 4109: SetupCannon: LDX Cannon_Offset  ; get offset for data used by cannons and whirlpools
        Line 4107: LDA #$66                        ; if not, render bottom until length expires
      Line 4109: SetupCannon: LDX Cannon_Offset  ; get offset for data used by cannons and whirlpools
        Branch exit: Line 4120: StrCOffset: STX Cannon_Offset   ; save new offset and leave
        Line 4119: LDX #$00                        ; otherwise initialize it
        Line 4120: StrCOffset: STX Cannon_Offset   ; save new offset and leave

Function InitHorizFlySwimEnemy
  Inputs: [X]
  Outputs: []
    Line 8199: InitHorizFlySwimEnemy: 
      Branch exit: Line 8171: SetESpd: STA Enemy_X_Speed,X    ; store as speed for enemy object

Function JCoinGfxHandler
  Inputs: [X]
  Outputs: []
      Line 13437: JCoinGfxHandler: 
        Branch exit: Line 13413: DrawFloateyNumber_Coin: 
        Line 13442: LDA Misc_Y_Position,X           ; store vertical coordinate as

Function ReadJoypads
  Inputs: []
  Outputs: []
    Line 2420: ReadJoypads: 
      Line 2428: ReadPortBits: LDY #$08 (as a call, not in function)

Function MushroomLedge
  Inputs: [Y, CarryFlag, X, $07]
  Outputs: []
    Line 3647: MushroomLedge: 
      Branch exit: Line 3656: EndMushL: LDA #$1b              ; if at the end, render end of mushroom
      Line 3651: LDA AreaObjectLength,X          ; divide length by 2 and store elsewhere
        Branch exit: Line 3673: NoUnder: LDX $07                ; load row of ledge
      Line 3656: EndMushL: LDA #$1b              ; if at the end, render end of mushroom
        Branch exit: Line 3673: NoUnder: LDX $07                ; load row of ledge
        Line 3659: LDA MushroomLedgeHalfLen,X      ; get divided length and store where length
          Branch exit: Line 3693: MushLExit: RTS                  ; and leave
          Line 3666: INX 

Function BalancePlatform
  Inputs: [X, $01]
  Outputs: []
    Line 10666: BalancePlatform: 
      Branch exit: Line 10671: DoBPl: LDA Enemy_State,X        ; get object's state (set to $ff or other platform offset)
      Line 10670: JMP EraseEnemyObject            ; if far below screen, kill the object
        Branch exit: Line 9172: EraseEnemyObject: 
      Line 10671: DoBPl: LDA Enemy_State,X        ; get object's state (set to $ff or other platform offset)
        Branch exit: Line 10675: CheckBalPlatform: 
        Line 10673: RTS 

Function RunGameTimer
  Inputs: []
  Outputs: []
        Line 6435: RunGameTimer: 
          Branch exit: Line 6471: ExGTimer: RTS                   ; leave
          Line 6438: LDA GameEngineSubroutine
            Branch exit: Line 6471: ExGTimer: RTS                   ; leave
            Line 6441: CMP #$0b                        ; if running death routine,
              Branch exit: Line 6471: ExGTimer: RTS                   ; leave
              Line 6443: LDA Player_Y_HighPos
                Branch exit: Line 6471: ExGTimer: RTS                   ; leave
                Line 6446: LDA GameTimerCtrlTimer          ; if game timer control not yet expired,
                  Branch exit: Line 6471: ExGTimer: RTS                   ; leave
                  Line 6448: LDA GameTimerDisplay
                    Branch exit: Line 6468: TimeUpOn: STA PlayerStatus      ; init player status (note A will always be zero here)
                    Line 6452: LDY GameTimerDisplay            ; otherwise check first digit
                      Branch exit: Line 6460: ResGTCtrl: LDA #$18             ; reset game timer control
                      Line 6455: LDA GameTimerDisplay+1          ; otherwise check second and third digits
                        Branch exit: Line 6460: ResGTCtrl: LDA #$18             ; reset game timer control
                        Line 6458: LDA #TimeRunningOutMusic
                      Line 6460: ResGTCtrl: LDA #$18             ; reset game timer control
                        Branch exit: Line 2529: PrintStatusBarNumbers: 
                    Line 6468: TimeUpOn: STA PlayerStatus      ; init player status (note A will always be zero here)

Function EnemyGfxHandler
  Inputs: [X]
  Outputs: []
  Line 13613: EnemyGfxHandler: 
    Branch exit: Line 13635: CheckForRetainerObj: 
    Line 13629: LDY PiranhaPlant_Y_Speed,X
      Branch exit: Line 13635: CheckForRetainerObj: 
      Line 13631: LDY EnemyFrameTimer,X
        Branch exit: Line 13635: CheckForRetainerObj: 
        Line 13633: RTS                             ; if all conditions fail, leave

Function ChkLeftCo
  Inputs: [A]
  Outputs: []
                  Line 14149: ChkLeftCo: AND #%00001000       ; check to see if d3 in offscreen bits are set
                    Branch exit: Line 14156: ExDBlk: RTS 
                    Line 14151: 
                      Line 14152: MoveColOffscreen:  (as a call, not in function)
                    Line 14156: ExDBlk: RTS  (as a call, not in function)

Function LargePlatformCollision
  Inputs: [X]
  Outputs: []
    Line 11708: LargePlatformCollision: 
      Branch exit: Line 11736: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
      Line 11713: LDA Enemy_State,X               ; if d7 set in object state,
        Branch exit: Line 11736: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
        Line 11715: LDA Enemy_ID,X
          Branch exit: Line 11722: ChkForPlayerC_LargeP: 
          Line 11718: LDA Enemy_State,X
          Line 11722: ChkForPlayerC_LargeP:  (as a call, not in function)
      Line 11736: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave

Function SetEntr
  Inputs: []
  Outputs: []
        Line 5676: SetEntr: LDA #$02               ; set starting position to override
          Branch exit: Line 5710: ChgAreaMode: INC DisableScreenFlag; set flag to disable screen output

Function PlatLiftUp
  Inputs: [X]
  Outputs: []
    Line 8955: PlatLiftUp: 
      Branch exit: Line 8972: CommonSmallLift: 

Function AreaParserTaskControl
  Inputs: []
  Outputs: []
    Line 1569: AreaParserTaskControl: 
      Line 1571: TaskLoop: JSR AreaParserTaskHandler; render column set of current area
        Branch exit: Line 1571: TaskLoop: JSR AreaParserTaskHandler; render column set of current area
        Line 1574: DEC ColumnSets                  ; do we need to render more column sets?
          Branch exit: Line 1577: OutputCol: LDA #$06             ; set vram buffer to output rendered column set
          Line 1576: INC ScreenRoutineTask           ; if not, move on to the next task
          Line 1577: OutputCol: LDA #$06             ; set vram buffer to output rendered column set

Function GameMenuRoutine
  Inputs: []
  Outputs: []
          Line 970: GameMenuRoutine: 
            Branch exit: Line 978: StartGame: JMP ChkContinue      ; if either start or A + start, execute here
            Line 976: CMP #A_Button+Start_Button      ; check to see if A + start was pressed
              Branch exit: Line 979: ChkSelect: CMP #Select_Button   ; check to see if the select button was pressed
              Line 979: ChkSelect: CMP #Select_Button   ; check to see if the select button was pressed
                Branch exit: Line 992: SelectBLogic: LDA DemoTimer     ; if select or B pressed, check demo timer one last time
                Line 981: LDX DemoTimer                   ; otherwise check demo timer
                  Branch exit: Line 987: ChkWorldSel: LDX WorldSelectEnableFlag; check to see if world selection has been enabled
                  Line 983: STA SelectTimer                 ; set controller bits here if running demo
                    Branch exit: Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
                    Line 986: JMP RunDemo                     ; otherwise, run game engine for demo
                      Branch exit: Line 1023: RunDemo: JSR GameCoreRoutine    ; run game engine
                  Line 987: ChkWorldSel: LDX WorldSelectEnableFlag; check to see if world selection has been enabled
                    Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                    Line 989: CMP #B_Button                   ; if so, check to see if the B button was pressed
                      Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                      Line 991: INY                             ; if so, increment Y and execute same code as select
                Line 992: SelectBLogic: LDA DemoTimer     ; if select or B pressed, check demo timer one last time
                  Branch exit: Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
                  Line 994: LDA #$18                        ; otherwise reset demo timer
                    Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                    Line 998: LDA #$10                        ; otherwise reset select button timer
                      Branch exit: Line 1007: IncWorldSel: LDX WorldSelectNumber; increment world select number
                      Line 1002: LDA NumberOfPlayers             ; if no, must have been the select button, therefore
                        Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                      Line 1007: IncWorldSel: LDX WorldSelectNumber; increment world select number
                        Line 1013: UpdateShroom: LDA WSelectBufferTemplate,X; write template for world select in vram buffer
                          Branch exit: Line 1013: UpdateShroom: LDA WSelectBufferTemplate,X; write template for world select in vram buffer
                          Line 1018: LDY WorldNumber                 ; get world number from variable and increment for
                Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                Line 1023: RunDemo: JSR GameCoreRoutine    ; run game engine
                  Branch exit: Line 1054: ExitMenu: RTS 
            Line 978: StartGame: JMP ChkContinue      ; if either start or A + start, execute here
              Branch exit: Line 1033: ChkContinue: LDY DemoTimer      ; if timer for demo has expired, reset modes
              Line 1033: ChkContinue: LDY DemoTimer      ; if timer for demo has expired, reset modes
                Branch exit: Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
                Line 1035: ASL                             ; check to see if A button was also pushed
                  Branch exit: Line 1039: StartWorld1: JSR LoadAreaPointer
                  Line 1037: LDA ContinueWorld               ; load previously saved world number for secret
                  Line 1039: StartWorld1: JSR LoadAreaPointer
                    Line 1051: InitScores: STA ScoreAndCoinDisplay,X; clear player scores and coin displays
                      Branch exit: Line 1051: InitScores: STA ScoreAndCoinDisplay,X; clear player scores and coin displays
            Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
            Line 1054: ExitMenu: RTS 

Function GetAreaDataAddrs
  Inputs: []
  Outputs: []
    Line 4376: GetAreaDataAddrs: 
      Branch exit: Line 4408: StoreFore: STA ForegroundScenery; if less, save value here as foreground scenery
      Line 4406: STA BackgroundColorCtrl         ; if 4 or greater, save value here as bg color control
      Line 4408: StoreFore: STA ForegroundScenery; if less, save value here as foreground scenery
        Branch exit: Line 4446: StoreStyle: STA AreaStyle
        Line 4444: STA CloudTypeOverride           ; otherwise store value in other place
        Line 4446: StoreStyle: STA AreaStyle

Function MoveObjectHorizontally
  Inputs: [X]
  Outputs: []
        Line 7540: MoveObjectHorizontally: 
          Branch exit: Line 7555: SaveXSpd: STA $00               ; save result here
          Line 7554: ORA #%11110000                  ; otherwise alter high nybble
          Line 7555: SaveXSpd: STA $00               ; save result here
            Branch exit: Line 7560: UseAdder: STY $02               ; save Y here
            Line 7559: DEY                             ; otherwise decrement Y
            Line 7560: UseAdder: STY $02               ; save Y here

Function MoveESprColOffscreen
  Inputs: [A, X]
  Outputs: []
    Line 14078: MoveESprColOffscreen: 

Function EmptyBlock
  Inputs: [$07]
  Outputs: []
    Line 4044: EmptyBlock: 

Function ExecGameLoopback
  Inputs: [Y]
  Outputs: []
          Line 7795: ExecGameLoopback: 

Function DumpSixSpr
  Inputs: [A, Y]
  Outputs: []
              Line 13312: DumpSixSpr: 
                Line 13316: DumpFourSpr:  (as a call, not in function)

Function UpdateScreen
  Inputs: [$00, $01]
  Outputs: []
                Line 2497: UpdateScreen: LDX PPU_STATUS    ; reset flip-flop
                  Branch exit: Line 2456: WriteBufferToScreen: 

Function FlagpoleGfxHandler
  Inputs: [X]
  Outputs: []
      Line 13258: FlagpoleGfxHandler: 
        Branch exit: Line 13300: ChkFlagOffscreen: 
        Line 13288: TYA 
        Line 13300: ChkFlagOffscreen: 
          Branch exit: Line 13326: ExitDumpSpr: 
          Line 13306: 
            Line 13309: MoveSixSpritesOffscreen:  (as a call, not in function)

Function InitBowser
  Inputs: [X]
  Outputs: []
    Line 8503: InitBowser: 

Function MiscObjectsCore
  Inputs: []
  Outputs: []
    Line 7012: MiscObjectsCore: 

Function MoveBloober
  Inputs: [X]
  Outputs: []
      Line 9467: MoveBloober: 
        Branch exit: Line 9516: MoveDefeatedBloober: 
        Line 9471: LDY SecondaryHardMode           ; use secondary hard mode flag as offset
          Branch exit: Line 9486: BlooberSwim: 
          Line 9475: TXA 
            Branch exit: Line 9480: FBLeft: LDY #$02                ; set left moving direction by default
            Line 9478: LDY Player_MovingDir            ; otherwise, load player's moving direction and
              Branch exit: Line 9484: SBMDir: STY Enemy_MovingDir,X   ; set moving direction of bloober, then continue on here
            Line 9480: FBLeft: LDY #$02                ; set left moving direction by default
              Branch exit: Line 9484: SBMDir: STY Enemy_MovingDir,X   ; set moving direction of bloober, then continue on here
              Line 9483: DEY                             ; otherwise decrement to set right moving direction
            Line 9484: SBMDir: STY Enemy_MovingDir,X   ; set moving direction of bloober, then continue on here
          Line 9486: BlooberSwim: 
            Branch exit: Line 9494: SwimX: LDY Enemy_MovingDir,X    ; check moving direction
            Line 9493: STA Enemy_Y_Position,X          ; otherwise, set new vertical position, make bloober swim
            Line 9494: SwimX: LDY Enemy_MovingDir,X    ; check moving direction
              Branch exit: Line 9506: LeftSwim: 
              Line 9497: LDA Enemy_X_Position,X

Function ShellOrBlockDefeat
  Inputs: [X]
  Outputs: []
  Line 11171: ShellOrBlockDefeat: 
    Branch exit: Line 11178: StnE: JSR ChkToStunEnemies      ; do yet another sub
    Line 11175: LDA Enemy_Y_Position,X
    Line 11178: StnE: JSR ChkToStunEnemies      ; do yet another sub
      Branch exit: Line 11189: GoombaPoints: 
      Line 11187: LDA #$06                        ; award 1000 points for hammer bro
      Line 11189: GoombaPoints: 
        Branch exit: Line 11194: EnemySmackScore: 
        Line 11192: LDA #$01                        ; award 100 points for goomba

Function ProcessLengthData
  Inputs: [A]
  Outputs: [A]
      Line 15916: ProcessLengthData: 

Function RelativeBubblePosition
  Inputs: []
  Outputs: [X]
    Line 14765: RelativeBubblePosition: 
      Branch exit: Line 14775: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function MushFlowerBlock
  Inputs: []
  Outputs: []
            Line 7337: MushFlowerBlock: 
              Line 7341: StarBlock:  (as a call, not in function)

Function BridgeCollapse
  Inputs: []
  Outputs: []
      Line 10072: BridgeCollapse: 
        Branch exit: Line 10085: SetM2: LDA #Silence             ; silence music
        Line 10077: STX ObjectOffset                ; store as enemy offset here
          Branch exit: Line 10094: RemoveBridge: 
          Line 10080: AND #%01000000                  ; if bowser's state has d6 clear, skip to silence music
            Branch exit: Line 10085: SetM2: LDA #Silence             ; silence music
            Line 10082: LDA Enemy_Y_Position,X          ; check bowser's vertical coordinate
              Branch exit: Line 10090: MoveD_Bowser: 
        Line 10085: SetM2: LDA #Silence             ; silence music
          Branch exit: Line 10141: KillAllEnemies: 

Function TopScoreCheck
  Inputs: [X]
  Outputs: []
      Line 2618: TopScoreCheck: 
        Line 2621: GetScoreDiff: LDA PlayerScoreDisplay,X; subtract each player digit from each high score digit
          Branch exit: Line 2621: GetScoreDiff: LDA PlayerScoreDisplay,X; subtract each player digit from each high score digit
          Line 2626: BCC NoTopSc                     ; check to see if borrow is still set, if so, no new high score
            Branch exit: Line 2635: NoTopSc: RTS 
            Line 2627: INX                             ; increment X and Y once to the start of the score
              Line 2629: CopyScore: LDA PlayerScoreDisplay,X; store player's score digits into high score memory area
                Branch exit: Line 2629: CopyScore: LDA PlayerScoreDisplay,X; store player's score digits into high score memory area
            Line 2635: NoTopSc: RTS 

Function BoundingBoxCore
  Inputs: [X, Y]
  Outputs: []
    Line 12852: BoundingBoxCore: 

Function SetPRout
  Inputs: [A, Y]
  Outputs: []
    Line 11415: SetPRout: STA GameEngineSubroutine; load new value to run subroutine on next frame

Function CheckForSolidMTiles
  Inputs: [A, X]
  Outputs: [CarryFlag]
      Line 12357: CheckForSolidMTiles: 

Function PrintVictoryMessages
  Inputs: []
  Outputs: []
    Line 1175: PrintVictoryMessages: 
      Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
      Line 1178: LDA PrimaryMsgCounter           ; otherwise load primary message counter
        Branch exit: Line 1191: ThankPlayer: TAY                ; put primary message counter into Y
        Line 1180: CMP #$09                        ; if at 9 or above, branch elsewhere (this comparison
          Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
          Line 1182: LDY WorldNumber                 ; check world number
            Branch exit: Line 1189: MRetainerMsg: CMP #$02          ; check primary message counter
            Line 1185: CMP #$03                        ; check primary message counter again
              Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
              Line 1187: SBC #$01                        ; otherwise subtract one
                Branch exit: Line 1191: ThankPlayer: TAY                ; put primary message counter into Y
            Line 1189: MRetainerMsg: CMP #$02          ; check primary message counter
              Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
        Line 1191: ThankPlayer: TAY                ; put primary message counter into Y
          Branch exit: Line 1197: SecondPartMsg: INY              ; increment Y to do world 8's message
          Line 1193: LDA CurrentPlayer               ; otherwise get player currently on the screen
            Branch exit: Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
            Line 1195: INY                             ; otherwise increment Y once for luigi and
              Branch exit: Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
          Line 1197: SecondPartMsg: INY              ; increment Y to do world 8's message
            Branch exit: Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
            Line 1201: DEY                             ; otherwise decrement Y for world 1-7's message
              Branch exit: Line 1222: SetEndTimer: BCC ExitMsgs       ; if not reached value yet, branch to leave
              Line 1204: CPY #$03                        ; if counter at 3 (world 1-7 only)
                Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
          Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
            Branch exit: Line 1210: PrintMsg: TYA                   ; put primary message counter in A
            Line 1208: LDA #VictoryMusic               ; reach this code if counter = 0, and will always branch)
            Line 1210: PrintMsg: TYA                   ; put primary message counter in A
      Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
      Line 1222: SetEndTimer: BCC ExitMsgs       ; if not reached value yet, branch to leave
        Branch exit: Line 1226: ExitMsgs: RTS                   ; leave
        Line 1223: LDA #$06

Function XMoveCntr_Platform
  Inputs: [A, X]
  Outputs: []
      Line 9422: XMoveCntr_Platform: 
        Branch exit: Line 9434: NoIncXM: RTS 
        Line 9427: LDY XMoveSecondaryCounter,X     ; get secondary counter
          Branch exit: Line 9437: DecSeXM: TYA                    ; put secondary counter in A
          Line 9431: CPY $01                         ; compare secondary counter to preset maximum value
            Branch exit: Line 9435: IncPXM: INC XMovePrimaryCounter,X; increment primary counter and leave
            Line 9433: INC XMoveSecondaryCounter,X     ; increment secondary counter and leave
          Line 9435: IncPXM: INC XMovePrimaryCounter,X; increment primary counter and leave
          Line 9437: DecSeXM: TYA                    ; put secondary counter in A
            Branch exit: Line 9435: IncPXM: INC XMovePrimaryCounter,X; increment primary counter and leave
            Line 9439: DEC XMoveSecondaryCounter,X     ; otherwise decrement secondary counter and leave
        Line 9434: NoIncXM: RTS 

Function DrawVine
  Inputs: [Y]
  Outputs: [Y]
      Line 13103: DrawVine: 
        Line 13130: VineTL: LDA #$e1                ; set tile number for sprite
          Branch exit: Line 13130: VineTL: LDA #$e1                ; set tile number for sprite
          Line 13138: LDY $02                         ; get original offset
            Branch exit: Line 13143: SkpVTop: LDX #$00               ; start with the first sprite again
            Line 13141: LDA #$e0
            Line 13143: SkpVTop: LDX #$00               ; start with the first sprite again
              Line 13144: ChkFTop: LDA VineStart_Y_Position; get original starting vertical coordinate
                Branch exit: Line 13151: NextVSp: INY                    ; move offset to next OAM data
                Line 13149: LDA #$f8
                Line 13151: NextVSp: INY                    ; move offset to next OAM data
                  Branch exit: Line 13144: ChkFTop: LDA VineStart_Y_Position; get original starting vertical coordinate
                  Line 13158: LDY $00                         ; return offset set earlier

Function SetupPlatformRope
  Inputs: [A, Y]
  Outputs: [$01, $00]
    Line 10805: SetupPlatformRope: 
      Branch exit: Line 10814: GetLRp: PHA                     ; save modified horizontal coordinate to stack
      Line 10812: CLC 
      Line 10814: GetLRp: PHA                     ; save modified horizontal coordinate to stack
        Branch exit: Line 10831: GetHRp: TXA                     ; move vertical coordinate to A
        Line 10827: TXA 
        Line 10831: GetHRp: TXA                     ; move vertical coordinate to A
          Branch exit: Line 10857: ExPRp: RTS                      ; leave!
          Line 10854: LDA $00
          Line 10857: ExPRp: RTS                      ; leave!

Function SmallPlatformCollision
  Inputs: [X, CarryFlag, Y]
  Outputs: []
    Line 11742: SmallPlatformCollision: 
      Branch exit: Line 11773: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave
      Line 11745: STA PlatformCollisionFlag,X     ; otherwise initialize collision flag
        Branch exit: Line 11773: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave
        Line 11748: LDA #$02
          Line 11751: ChkSmallPlatLoop: 
            Branch exit: Line 11773: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave
            Line 11756: LDA BoundingBox_UL_YPos,Y       ; check top of platform's bounding box for being
              Branch exit: Line 11762: MoveBoundBox: 
              Line 11759: JSR PlayerCollisionCore         ; otherwise, perform player-to-platform collision detection
                Branch exit: Line 11778: ProcSPlatCollisions: 
                Line 11761: 
              Line 11762: MoveBoundBox: 
                Branch exit: Line 11751: ChkSmallPlatLoop: 
      Line 11773: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave

Function MoveSmallPlatform
  Inputs: [X]
  Outputs: []
    Line 10977: MoveSmallPlatform: 
      Branch exit: Line 10993: ChkSmallPlatCollision: 

Function AddToScore
  Inputs: []
  Outputs: []
      Line 7103: AddToScore: 
        Line 7108: GetSBNybbles:  (as a call, not in function)

Function ResetSpritesAndScreenTimer
  Inputs: []
  Outputs: []
    Line 1778: ResetSpritesAndScreenTimer: 
      Branch exit: Line 1787: NoReset: RTS 
      Line 1781: JSR MoveAllSpritesOffscreen     ; otherwise reset sprites now
        Line 1783: ResetScreenTimer:  (as a call, not in function)
      Line 1787: NoReset: RTS  (as a call, not in function)

Function MoveESprRowOffscreen
  Inputs: [A, X]
  Outputs: []
    Line 14071: MoveESprRowOffscreen: 
      Branch exit: Line 13322: DumpTwoSpr: 

Function LoadEnvelopeData
  Inputs: [Y]
  Outputs: [A]
    Line 15941: LoadEnvelopeData: 
      Branch exit: Line 15948: LoadUsualEnvData: 
      Line 15945: LDA EndOfCastleMusicEnvData,Y   ; load data from offset for win castle music

Function FindAreaPointer
  Inputs: []
  Outputs: [A]
    Line 4366: FindAreaPointer: 

Function ColumnOfSolidBlocks
  Inputs: [$07]
  Outputs: []
    Line 4083: ColumnOfSolidBlocks: 

Function ProcessCannons
  Inputs: []
  Outputs: []
      Line 6762: ProcessCannons: 
        Branch exit: Line 6816: ExCannon: RTS                   ; then leave
        Line 6765: LDX #$02

Function DoNothing2
  Inputs: []
  Outputs: []
      Line 3029: DoNothing2: 

Function Entrance_GameTimerSetup
  Inputs: []
  Outputs: []
              Line 2832: Entrance_GameTimerSetup: 
                Branch exit: Line 2848: ChkStPos: STY SwimmingFlag
                Line 2847: INY 
                Line 2848: ChkStPos: STY SwimmingFlag
                  Branch exit: Line 2855: SetStPos: LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position
                  Line 2852: CPY #$01
                    Branch exit: Line 2855: SetStPos: LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position
                    Line 2854: LDX AltYPosOffset-2,Y           ; if not 0 or 1, override $0710 with new offset in X
                  Line 2855: SetStPos: LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position
                    Branch exit: Line 2874: ChkOverR: LDY JoypadOverride    ; if controller bits not set, branch to skip this part
                    Line 2864: LDA FetchNewGameTimerFlag       ; do we need to set the game timer? if not, use
                      Branch exit: Line 2874: ChkOverR: LDY JoypadOverride    ; if controller bits not set, branch to skip this part
                      Line 2866: LDA GameTimerData,Y             ; if game timer is set and game timer flag is also set,
                    Line 2874: ChkOverR: LDY JoypadOverride    ; if controller bits not set, branch to skip this part
                      Branch exit: Line 2885: ChkSwimE: LDY AreaType          ; if level not water-type,
                      Line 2876: LDA #$03                        ; set player state to climbing
                      Line 2885: ChkSwimE: LDY AreaType          ; if level not water-type,
                        Branch exit: Line 2888: SetPESub: LDA #$07              ; set to run player entrance subroutine
                        Line 2887: JSR SetupBubble                 ; otherwise, execute sub to set up air bubbles
                        Line 2888: SetPESub: LDA #$07              ; set to run player entrance subroutine

Function ResetScreenTimer
  Inputs: []
  Outputs: []
        Line 1783: ResetScreenTimer: 

Function PlayerEntrance
  Inputs: []
  Outputs: []
        Line 5493: PlayerEntrance: 
          Branch exit: Line 5515: EntrMode2: LDA JoypadOverride   ; if controller override bits set here,
          Line 5497: LDA #$00
            Branch exit: Line 5554: AutoControlPlayer: 
            Line 5501: LDA PlayerEntranceCtrl          ; check player entry bits from header
              Branch exit: Line 5506: ChkBehPipe: LDA Player_SprAttrib; check for sprite attributes
              Line 5504: CMP #$07                        ; otherwise branch to normal entry
                Branch exit: Line 5541: PlayerRdy: LDA #$08             ; set routine to be executed by game engine next frame
              Line 5506: ChkBehPipe: LDA Player_SprAttrib; check for sprite attributes
                Branch exit: Line 5510: IntroEntr: JSR EnterSidePipe    ; execute sub to move player to the right
                Line 5508: LDA #$01
                  Branch exit: Line 5554: AutoControlPlayer: 
                Line 5510: IntroEntr: JSR EnterSidePipe    ; execute sub to move player to the right
                  Branch exit: Line 5549: ExitEntr: RTS                   ; leave!
                  Line 5513: INC DisableIntermediate         ; set flag to skip world and lives display
                    Branch exit: Line 5862: NextArea: INC AreaNumber        ; increment area number used for address loader
          Line 5515: EntrMode2: LDA JoypadOverride   ; if controller override bits set here,
            Branch exit: Line 5523: VineEntr: LDA VineHeight
            Line 5517: LDA #$ff                        ; otherwise, set value here then execute sub
              Branch exit: Line 5541: PlayerRdy: LDA #$08             ; set routine to be executed by game engine next frame
              Line 5522: RTS                             ; to the last part, otherwise leave
            Line 5523: VineEntr: LDA VineHeight
              Branch exit: Line 5549: ExitEntr: RTS                   ; leave!
              Line 5526: LDA Player_Y_Position           ; get player's vertical coordinate
                Branch exit: Line 5536: OffVine: STY DisableCollisionDet; set collision detection disable flag
                Line 5531: LDA #$03
                Line 5536: OffVine: STY DisableCollisionDet; set collision detection disable flag
                  Branch exit: Line 5549: ExitEntr: RTS                   ; leave!
          Line 5541: PlayerRdy: LDA #$08             ; set routine to be executed by game engine next frame
          Line 5549: ExitEntr: RTS                   ; leave!

Function PlayerCollisionCore
  Inputs: []
  Outputs: []
    Line 12930: PlayerCollisionCore: 
      Line 12933: SprObjectCollisionCore:  (as a call, not in function)

Function GetBlockBufferAddr
  Inputs: [A]
  Outputs: []
      Line 4327: GetBlockBufferAddr: 

Function GetAreaMusic
  Inputs: []
  Outputs: []
      Line 2792: GetAreaMusic: 
        Branch exit: Line 2810: ExitGetM: RTS 
        Line 2795: LDA AltEntranceControl          ; check for specific alternate mode of entry
          Branch exit: Line 2804: ChkAreaType: LDY AreaType       ; load area type as offset for music bit
          Line 2798: LDY #$05                        ; select music for pipe intro scene by default
            Branch exit: Line 2808: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
            Line 2802: CMP #$07                        ; start position either value $06 or $07
              Branch exit: Line 2808: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
          Line 2804: ChkAreaType: LDY AreaType       ; load area type as offset for music bit
            Branch exit: Line 2808: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
            Line 2807: LDY #$04                        ; select music for cloud type level if found
          Line 2808: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
        Line 2810: ExitGetM: RTS 

Function SmallPlatformBoundBox
  Inputs: [X]
  Outputs: []
    Line 12802: SmallPlatformBoundBox: 

Function InitLongFirebar
  Inputs: []
  Outputs: []
        Line 8374: InitLongFirebar: 
          Line 8377: InitShortFirebar:  (as a call, not in function)

Function InitBloober
  Inputs: [X]
  Outputs: []
    Line 8205: InitBloober: 

Function SetupBubble
  Inputs: [X, $07]
  Outputs: []
          Line 6393: SetupBubble: 
            Branch exit: Line 6399: PosBubl: TYA                    ; use value loaded as adder
            Line 6398: LDY #$08                        ; otherwise load alternate value here
            Line 6399: PosBubl: TYA                    ; use value loaded as adder

Function RunBowserFlame
  Inputs: []
  Outputs: []
    Line 9114: RunBowserFlame: 
      Branch exit: Line 11005: OffscreenBoundsCheck: 

Function InitScroll
  Inputs: [A]
  Outputs: []
  Line 2501: InitScroll: STA PPU_SCROLL_REG  ; store contents of A into scroll registers

Function InitRedKoopa
  Inputs: [X]
  Outputs: []
    Line 8176: InitRedKoopa: 

Function InitializeNameTables
  Inputs: []
  Outputs: []
    Line 2386: InitializeNameTables: 
      Line 2395: WriteNTAddr: STA PPU_ADDRESS (as a call, not in function)

Function CheckTopOfBlock
  Inputs: [$02]
  Outputs: [CarryFlag]
    Line 7394: CheckTopOfBlock: 
      Branch exit: Line 7411: TopEx: RTS                      ; leave!
      Line 7398: TYA                             ; otherwise set to A
        Branch exit: Line 7411: TopEx: RTS                      ; leave!
        Line 7406: LDA #$00
      Line 7411: TopEx: RTS                      ; leave!

Function NoInitCode
  Inputs: []
  Outputs: []
        Line 8132: NoInitCode: 

Function InitJumpGPTroopa
  Inputs: [X]
  Outputs: []
    Line 8867: InitJumpGPTroopa: 

Function PlayerBGCollision
  Inputs: [$04, $06]
  Outputs: []
      Line 11901: PlayerBGCollision: 
        Branch exit: Line 11926: ExPBGCol: RTS                   ; otherwise leave
        Line 11904: LDA GameEngineSubroutine
          Branch exit: Line 11926: ExPBGCol: RTS                   ; otherwise leave
          Line 11907: CMP #$04
            Branch exit: Line 11926: ExPBGCol: RTS                   ; otherwise leave
            Line 11909: LDA #$01                        ; load default player state for swimming
              Branch exit: Line 11917: SetPSte: STA Player_State       ; set whatever player state is appropriate
              Line 11912: LDA Player_State                ; if player in normal state,
                Branch exit: Line 11916: SetFallS: LDA #$02              ; load default player state for falling
                Line 11914: CMP #$03
                  Branch exit: Line 11918: ChkOnScr: LDA Player_Y_HighPos
                Line 11916: SetFallS: LDA #$02              ; load default player state for falling
              Line 11917: SetPSte: STA Player_State       ; set whatever player state is appropriate
              Line 11918: ChkOnScr: LDA Player_Y_HighPos
                Branch exit: Line 11926: ExPBGCol: RTS                   ; otherwise leave
                Line 11921: LDA #$ff
                  Branch exit: Line 11928: ChkCollSize: 
        Line 11926: ExPBGCol: RTS                   ; otherwise leave

Function MoveSwimmingCheepCheep
  Inputs: [X]
  Outputs: []
      Line 9594: MoveSwimmingCheepCheep: 
        Branch exit: Line 9599: CCSwim: STA $03                 ; save enemy state in $03
        Line 9598: JMP MoveEnemySlowVert           ; otherwise jump to move defeated cheep-cheep downwards
          Branch exit: Line 7634: MoveEnemySlowVert: 
        Line 9599: CCSwim: STA $03                 ; save enemy state in $03
          Branch exit: Line 9660: ExSwCC: RTS                     ; leave
          Line 9620: LDA CheepCheepMoveMFlag,X       ; check movement flag
            Branch exit: Line 9634: CCSwimUpwards: 
            Line 9623: LDA Enemy_YMF_Dummy,X
              Branch exit: Line 9645: ChkSwimYPos: 

Function BlockBufferChk_FBall
  Inputs: [X]
  Outputs: [ZeroFlag]
    Line 13014: BlockBufferChk_FBall: 

Function ChkForPlayerAttrib
  Inputs: []
  Outputs: []
    Line 14727: ChkForPlayerAttrib: 
      Branch exit: Line 14741: KilledAtt: LDA Sprite_Attributes+16,Y
      Line 14732: LDA PlayerGfxOffset             ; get graphics table offset
        Branch exit: Line 14748: C_S_IGAtt: LDA Sprite_Attributes+24,Y
        Line 14735: CMP #$b8                        ; or intermediate growing offset,
          Branch exit: Line 14748: C_S_IGAtt: LDA Sprite_Attributes+24,Y
          Line 14737: CMP #$c0                        ; fourth row OAM attributes only
            Branch exit: Line 14748: C_S_IGAtt: LDA Sprite_Attributes+24,Y
            Line 14739: CMP #$c8
              Branch exit: Line 14755: ExPlyrAt: RTS                   ; leave
      Line 14741: KilledAtt: LDA Sprite_Attributes+16,Y
      Line 14748: C_S_IGAtt: LDA Sprite_Attributes+24,Y
      Line 14755: ExPlyrAt: RTS                   ; leave

Function OnGroundStateSub
  Inputs: []
  Outputs: []
    Line 5902: OnGroundStateSub: 
      Branch exit: Line 5907: GndMove: JSR ImposeFriction     ; do a sub to impose friction on player's walk/run
      Line 5906: STA PlayerFacingDir             ; otherwise set new facing direction
      Line 5907: GndMove: JSR ImposeFriction     ; do a sub to impose friction on player's walk/run

Function ImpedePlayerMove
  Inputs: [$00]
  Outputs: []
  Line 12317: ImpedePlayerMove: 
    Branch exit: Line 12328: RImpd: LDX #$02                 ; return $02 to X
    Line 12323: INX                             ; return value to X
      Branch exit: Line 12346: ExIPM: TXA                      ; invert contents of X
      Line 12326: LDA #$ff                        ; otherwise load A with value to be used later
        Branch exit: Line 12332: NXSpd: LDY #$10
    Line 12328: RImpd: LDX #$02                 ; return $02 to X
      Branch exit: Line 12346: ExIPM: TXA                      ; invert contents of X
      Line 12331: LDA #$01                        ; otherwise load A with value to be used here
    Line 12332: NXSpd: LDY #$10
      Branch exit: Line 12339: PlatF: STY $00                  ; store Y as high bits of horizontal adder
      Line 12338: DEY                             ; otherwise decrement Y now
      Line 12339: PlatF: STY $00                  ; store Y as high bits of horizontal adder
    Line 12346: ExIPM: TXA                      ; invert contents of X

Function InitDropPlatform
  Inputs: [X]
  Outputs: []
          Line 8899: InitDropPlatform: 
            Branch exit: Line 8929: CommonPlatCode: 

Function ColorRotation
  Inputs: []
  Outputs: []
          Line 1957: ColorRotation: 
            Branch exit: Line 1998: ExitColorRot: RTS               ; leave
            Line 1961: LDX VRAM_Buffer1_Offset         ; check vram buffer offset
              Branch exit: Line 1998: ExitColorRot: RTS               ; leave
              Line 1964: TAY                             ; otherwise use frame counter's 3 LSB as offset here
                Line 1965: GetBlankPal: LDA BlankPalette,Y ; get blank palette for palette 3
                  Branch exit: Line 1965: GetBlankPal: LDA BlankPalette,Y ; get blank palette for palette 3
                  Line 1971: LDX VRAM_Buffer1_Offset         ; get current vram buffer offset
                    Line 1978: GetAreaPal: LDA Palette3Data,Y  ; fetch palette to be written based on area type
                      Branch exit: Line 1978: GetAreaPal: LDA Palette3Data,Y  ; fetch palette to be written based on area type
                      Line 1984: LDX VRAM_Buffer1_Offset         ; get current vram buffer offset
                        Branch exit: Line 1998: ExitColorRot: RTS               ; leave
                        Line 1996: LDA #$00
            Line 1998: ExitColorRot: RTS               ; leave

Function InitRetainerObj
  Inputs: [X]
  Outputs: []
    Line 8155: InitRetainerObj: 

Function ChkToStunEnemies
  Inputs: [A, X]
  Outputs: []
        Line 12454: ChkToStunEnemies: 
          Branch exit: Line 12465: SetStun: LDA Enemy_State,X      ; load enemy state
          Line 12457: CMP #$11                        ; if the enemy object identifier is equal to the values
            Branch exit: Line 12465: SetStun: LDA Enemy_State,X      ; load enemy state
            Line 12459: CMP #$0a                        ; modified if not any of those values, note that piranha plant will
              Branch exit: Line 12463: Demote: AND #%00000001          ; erase all but LSB, essentially turning enemy object
              Line 12461: CMP #PiranhaPlant               ; coordinate from previous addition, also these comparisons
                Branch exit: Line 12465: SetStun: LDA Enemy_State,X      ; load enemy state
              Line 12463: Demote: AND #%00000001          ; erase all but LSB, essentially turning enemy object
          Line 12465: SetStun: LDA Enemy_State,X      ; load enemy state (as a call, not in function)

Function ScrollLockObject
  Inputs: []
  Outputs: []
        Line 3580: ScrollLockObject: 

Function ChkLrgObjFixedLength
  Inputs: [X, Y]
  Outputs: [CarryFlag]
      Line 4277: ChkLrgObjFixedLength: 
        Branch exit: Line 4284: LenSet: RTS 
        Line 4281: TYA                             ; save length into length counter
        Line 4284: LenSet: RTS 

Function EnemyTurnAround
  Inputs: [X]
  Outputs: []
    Line 11681: EnemyTurnAround: 
      Branch exit: Line 11703: ExTA: RTS                       ; leave!!!
      Line 11685: CMP #Lakitu
        Branch exit: Line 11703: ExTA: RTS                       ; leave!!!
        Line 11687: CMP #HammerBro
          Branch exit: Line 11703: ExTA: RTS                       ; leave!!!
          Line 11689: CMP #Spiny
            Branch exit: Line 11695: RXSpd: LDA Enemy_X_Speed,X      ; load horizontal speed
            Line 11691: CMP #GreenParatroopaJump
              Branch exit: Line 11695: RXSpd: LDA Enemy_X_Speed,X      ; load horizontal speed
              Line 11693: CMP #$07
                Branch exit: Line 11703: ExTA: RTS                       ; leave!!!

Function SetupJumpCoin
  Inputs: [X, Y, $06, $02]
  Outputs: []
    Line 6974: SetupJumpCoin: 

Function GetXOffscreenBits
  Inputs: [X]
  Outputs: [A, X]
        Line 14908: GetXOffscreenBits: 
          Line 14911: XOfsLoop: LDA ScreenEdge_X_Pos,Y; get pixel coordinate of edge
            Branch exit: Line 14927: XLdBData: LDA XOffscreenBitsData,X; get bits here
            Line 14920: LDX DefaultXOnscreenOfs+1,Y     ; if not, load alternate offset value here
              Branch exit: Line 14927: XLdBData: LDA XOffscreenBitsData,X; get bits here
              Line 14923: LDA #$38                        ; if no branching, load value here and store
            Line 14927: XLdBData: LDA XOffscreenBitsData,X; get bits here
              Branch exit: Line 14933: ExXOfsBS: RTS 
              Line 14931: DEY                             ; otherwise, do left side of screen now
                Branch exit: Line 14911: XOfsLoop: LDA ScreenEdge_X_Pos,Y; get pixel coordinate of edge
              Line 14933: ExXOfsBS: RTS 

Function DrawExplosion_Fireworks
  Inputs: [A, Y]
  Outputs: []
      Line 14266: DrawExplosion_Fireworks: 

Function Hole_Water
  Inputs: []
  Outputs: []
    Line 3907: Hole_Water: 
      Branch exit: Line 4247: RenderUnderPart: 

Function PlayerEnemyDiff
  Inputs: [X]
  Outputs: [NegativeFlag]
    Line 12634: PlayerEnemyDiff: 

Function VineBlock
  Inputs: []
  Outputs: []
    Line 7350: VineBlock: 

Function GetGfxOffsetAdder
  Inputs: [Y]
  Outputs: []
    Line 14679: GetGfxOffsetAdder: 
      Branch exit: Line 14686: SzOfs: RTS                      ; go back
      Line 14682: TYA                             ; for big player
      Line 14686: SzOfs: RTS                      ; go back

Function PositionPlayerOnS_Plat
  Inputs: [A, X]
  Outputs: []
      Line 11838: PositionPlayerOnS_Plat: 
        Line 11845: PositionPlayerOnVPlat:  (as a call, not in function)

Function ReplaceBlockMetatile
  Inputs: [X]
  Outputs: []
    Line 2026: ReplaceBlockMetatile: 

Function PauseRoutine
  Inputs: []
  Outputs: []
    Line 850: PauseRoutine: 
      Branch exit: Line 859: ChkPauseTimer: LDA GamePauseTimer; check if pause timer is still counting down
      Line 854: CMP #GameModeValue              ; are we in game mode?
        Branch exit: Line 881: ExitPause: RTS 
        Line 856: LDA OperMode_Task               ; if we are in game mode, are we running game engine?
          Branch exit: Line 881: ExitPause: RTS 
      Line 859: ChkPauseTimer: LDA GamePauseTimer; check if pause timer is still counting down
        Branch exit: Line 863: ChkStart: LDA SavedJoypad1Bits  ; check to see if start is pressed
        Line 861: DEC GamePauseTimer              ; if so, decrement and leave
        Line 863: ChkStart: LDA SavedJoypad1Bits  ; check to see if start is pressed
          Branch exit: Line 878: ClrPauseTimer: LDA GamePauseStatus; clear timer flag if timer is at zero and start button
          Line 866: LDA GamePauseStatus             ; check to see if timer flag is set
            Branch exit: Line 881: ExitPause: RTS 
            Line 869: LDA #$2b                        ; set pause timer
              Branch exit: Line 880: SetPause: STA GamePauseStatus
          Line 878: ClrPauseTimer: LDA GamePauseStatus; clear timer flag if timer is at zero and start button
          Line 880: SetPause: STA GamePauseStatus
      Line 881: ExitPause: RTS 

Function RelativePlayerPosition
  Inputs: []
  Outputs: []
    Line 14760: RelativePlayerPosition: 
      Branch exit: Line 14775: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function JumpSwimSub
  Inputs: []
  Outputs: []
    Line 5921: JumpSwimSub: 
      Branch exit: Line 5933: DumpFall: LDA VerticalForceDown ; otherwise dump falling into main fractional
      Line 5924: LDA A_B_Buttons
        Branch exit: Line 5935: ProcSwim: LDA SwimmingFlag      ; if swimming flag not set,
        Line 5928: LDA JumpOrigin_Y_Position       ; get vertical position player jumped from
          Branch exit: Line 5935: ProcSwim: LDA SwimmingFlag      ; if swimming flag not set,
      Line 5933: DumpFall: LDA VerticalForceDown ; otherwise dump falling into main fractional
      Line 5935: ProcSwim: LDA SwimmingFlag      ; if swimming flag not set,
        Branch exit: Line 5946: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)
        Line 5937: JSR GetPlayerAnimSpeed          ; do a sub to get animation frame timing
          Branch exit: Line 5943: LRWater: LDA Left_Right_Buttons ; check left/right controller bits (check for swimming)
          Line 5941: LDA #$18
          Line 5943: LRWater: LDA Left_Right_Buttons ; check left/right controller bits (check for swimming)
            Branch exit: Line 5946: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)
            Line 5945: STA PlayerFacingDir             ; otherwise set facing direction accordingly

Function EnemyToBGCollisionDet
  Inputs: [X, CarryFlag, $02, $04]
  Outputs: []
        Line 12400: EnemyToBGCollisionDet: 
          Branch exit: Line 12389: ExEBG: RTS                      ; leave
          Line 12404: JSR SubtEnemyYPos               ; otherwise, do a subroutine here
            Branch exit: Line 12389: ExEBG: RTS                      ; leave
            Line 12406: LDY Enemy_ID,X
              Branch exit: Line 12413: DoIDCheckBGColl: 
              Line 12409: LDA Enemy_Y_Position,X
                Branch exit: Line 12389: ExEBG: RTS                      ; leave
                Line 12412: 
              Line 12413: DoIDCheckBGColl: 
                Branch exit: Line 12417: HBChk: CPY #HammerBro           ; check for hammer bro
                Line 12416: JMP EnemyJump                   ; otherwise jump elsewhere
                  Branch exit: Line 12660: EnemyJump: 
                Line 12417: HBChk: CPY #HammerBro           ; check for hammer bro
                  Branch exit: Line 12420: CInvu: CPY #Spiny               ; if enemy object is spiny, branch
                  Line 12419: JMP HammerBroBGColl             ; otherwise jump elsewhere
                    Branch exit: Line 12679: HammerBroBGColl: 
                  Line 12420: CInvu: CPY #Spiny               ; if enemy object is spiny, branch
                    Branch exit: Line 12426: YesIn: JSR ChkUnderEnemy        ; if enemy object < $07, or = $12 or $2e, do this sub
                    Line 12422: CPY #PowerUpObject              ; if special power-up object, branch
                      Branch exit: Line 12426: YesIn: JSR ChkUnderEnemy        ; if enemy object < $07, or = $12 or $2e, do this sub
                      Line 12424: CPY #$07                        ; if enemy object =>$07, branch to leave
                        Branch exit: Line 12492: ExEBGChk: RTS 
                    Line 12426: YesIn: JSR ChkUnderEnemy        ; if enemy object < $07, or = $12 or $2e, do this sub
                      Branch exit: Line 12435: HandleEToBGCollision: 
                      Line 12428: 

Function MoveJumpingEnemy
  Inputs: []
  Outputs: []
    Line 9370: MoveJumpingEnemy: 
      Branch exit: Line 7529: MoveEnemyHorizontally: 

Function BlockBufferColli_Side
  Inputs: []
  Outputs: [ZeroFlag]
              Line 13048: BlockBufferColli_Side: 
                Line 13052: BlockBufferCollision:  (as a call, not in function)

Function PlatLiftDown
  Inputs: [X]
  Outputs: []
    Line 8964: PlatLiftDown: 

Function InitFlyingCheepCheep
  Inputs: [X]
  Outputs: []
          Line 8418: InitFlyingCheepCheep: 
            Branch exit: Line 8364: ChpChpEx: RTS 
            Line 8421: JSR SmallBBox                   ; jump to set bounding box size $09 and init other values
              Branch exit: Line 8431: MaxCC: STY $00                  ; store whatever pseudorandom bits are in Y
              Line 8430: INY                             ; otherwise, increment Y to allow as many as four onscreen
              Line 8431: MaxCC: STY $00                  ; store whatever pseudorandom bits are in Y
                Branch exit: Line 8364: ChpChpEx: RTS 
                Line 8434: LDA PseudoRandomBitReg,X
                  Branch exit: Line 8447: GSeed: PHA                      ; save to stack
                  Line 8443: LDA #$04
                    Branch exit: Line 8447: GSeed: PHA                      ; save to stack
                    Line 8446: ASL                             ; otherwise, multiply A by 2
                  Line 8447: GSeed: PHA                      ; save to stack
                    Branch exit: Line 8457: RSeed: PLA                      ; get value from stack we saved earlier
                    Line 8454: LDA PseudoRandomBitReg+2,X
                    Line 8457: RSeed: PLA                      ; get value from stack we saved earlier
                      Branch exit: Line 8477: D2XPos1: TYA                    ; get first LSFR or third LSFR lower nybble again
                      Line 8467: LDY $00                         ; get first LSFR or third LSFR lower nybble
                        Branch exit: Line 8477: D2XPos1: TYA                    ; get first LSFR or third LSFR lower nybble again
                        Line 8471: LDA Enemy_X_Speed,X
                      Line 8477: D2XPos1: TYA                    ; get first LSFR or third LSFR lower nybble again
                        Branch exit: Line 8487: D2XPos2: LDA Player_X_Position  ; get player's horizontal position
                        Line 8480: LDA Player_X_Position           ; get player's horizontal position
                          Branch exit: Line 8493: FinCCSt: STA Enemy_PageLoc,X    ; save as enemy's page location
                        Line 8487: D2XPos2: LDA Player_X_Position  ; get player's horizontal position
                        Line 8493: FinCCSt: STA Enemy_PageLoc,X    ; save as enemy's page location

Function ChkUnderEnemy
  Inputs: []
  Outputs: [ZeroFlag]
    Line 12706: ChkUnderEnemy: 
      Branch exit: Line 12997: BlockBufferChk_Enemy: 

Function WriteGameText
  Inputs: [A]
  Outputs: []
                          Line 1693: WriteGameText: 
                            Branch exit: Line 1705: LdGameText: LDX GameTextOffsets,Y; get offset to message we want to print
                            Line 1699: CPY #$08                        ; if set to do time-up or game over,
                              Branch exit: Line 1702: Chk2Players: LDA NumberOfPlayers; check for number of players
                              Line 1701: LDY #$08                        ; otherwise warp zone, therefore set offset
                              Line 1702: Chk2Players: LDA NumberOfPlayers; check for number of players
                                Branch exit: Line 1705: LdGameText: LDX GameTextOffsets,Y; get offset to message we want to print
                                Line 1704: INY                             ; otherwise increment offset by one to not print name
                            Line 1705: LdGameText: LDX GameTextOffsets,Y; get offset to message we want to print
                              Line 1707: GameTextLoop: LDA GameText,X    ; load message data
                                Branch exit: Line 1714: EndGameText: LDA #$00           ; put null terminator at end
                                Line 1710: STA VRAM_Buffer1,Y              ; otherwise write data to buffer
                                  Branch exit: Line 1707: GameTextLoop: LDA GameText,X    ; load message data
                                Line 1714: EndGameText: LDA #$00           ; put null terminator at end
                                  Branch exit: Line 1758: PrintWarpZoneNumbers: 
                                  Line 1720: DEX                             ; are we printing the world/lives display?
                                    Branch exit: Line 1739: CheckPlayerName: 
                                    Line 1722: LDA NumberofLives               ; otherwise, check number of lives
                                      Branch exit: Line 1730: PutLives: STA VRAM_Buffer1+8
                                      Line 1727: SBC #10                         ; if so, subtract 10 and put a crown tile
                                      Line 1730: PutLives: STA VRAM_Buffer1+8

Function HandlePipeEntry
  Inputs: [$00, $01]
  Outputs: []
    Line 12269: HandlePipeEntry: 
      Branch exit: Line 12315: ExPipeE: RTS                    ; leave!!!
      Line 12273: LDA $00
        Branch exit: Line 12315: ExPipeE: RTS                    ; leave!!!
        Line 12276: LDA $01
          Branch exit: Line 12315: ExPipeE: RTS                    ; leave!!!
          Line 12279: LDA #$30
            Branch exit: Line 12315: ExPipeE: RTS                    ; leave!!!
            Line 12289: AND #%00000011                  ; mask out all but 2 LSB
              Branch exit: Line 12300: GetWNum: LDY WarpZoneNumbers,X  ; get warp zone numbers
              Line 12296: INX                             ; otherwise increment for middle pipe
                Branch exit: Line 12300: GetWNum: LDY WarpZoneNumbers,X  ; get warp zone numbers
                Line 12299: INX                             ; otherwise increment for last pipe
              Line 12300: GetWNum: LDY WarpZoneNumbers,X  ; get warp zone numbers
      Line 12315: ExPipeE: RTS                    ; leave!!!

Function DrawPlayerLoop
  Inputs: [X, $07]
  Outputs: []
      Line 14575: DrawPlayerLoop: 
        Branch exit: Line 14575: DrawPlayerLoop: 
        Line 14582: RTS 

Function FireballEnemyCollision
  Inputs: [X]
  Outputs: []
    Line 11059: FireballEnemyCollision: 
      Branch exit: Line 11115: ExitFBallEnemy: 
      Line 11062: ASL 
        Branch exit: Line 11115: ExitFBallEnemy: 
        Line 11064: LDA FrameCounter
          Branch exit: Line 11115: ExitFBallEnemy: 
          Line 11067: TXA 
            Line 11075: FireballEnemyCDLoop: 
              Branch exit: Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
              Line 11082: LDA Enemy_Flag,X                ; check to see if buffer flag is set
                Branch exit: Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
                Line 11084: LDA Enemy_ID,X                  ; check enemy identifier
                  Branch exit: Line 11089: GoombaDie: CMP #Goomba          ; check for goomba identifier
                  Line 11087: CMP #$2b
                    Branch exit: Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
                  Line 11089: GoombaDie: CMP #Goomba          ; check for goomba identifier
                    Branch exit: Line 11094: NotGoomba: LDA EnemyOffscrBitsMasked,X; if any masked offscreen bits set,
                    Line 11091: LDA Enemy_State,X               ; otherwise check for defeated state
                      Branch exit: Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
                    Line 11094: NotGoomba: LDA EnemyOffscrBitsMasked,X; if any masked offscreen bits set,
                      Branch exit: Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
                      Line 11096: TXA 
                        Branch exit: Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
                        Line 11105: LDA #%10000000
              Line 11109: NoFToECol: PLA                  ; pull fireball offset from stack
                Branch exit: Line 11075: FireballEnemyCDLoop: 
                Line 11114: 
      Line 11115: ExitFBallEnemy: 

Function GetSBNybbles
  Inputs: []
  Outputs: []
        Line 7108: GetSBNybbles: 

Function GetObjRelativePosition
  Inputs: [X, Y]
  Outputs: []
    Line 14808: GetObjRelativePosition: 

Function Vine_AutoClimb
  Inputs: []
  Outputs: []
    Line 5665: Vine_AutoClimb: 
      Branch exit: Line 5671: AutoClimb: LDA #%00001000       ; set controller bits override to up
      Line 5668: LDA Player_Y_Position
        Branch exit: Line 5676: SetEntr: LDA #$02               ; set starting position to override
        Line 5676: SetEntr: LDA #$02               ; set starting position to override (as a call, not in function)
      Line 5671: AutoClimb: LDA #%00001000       ; set controller bits override to up
        Branch exit: Line 5554: AutoControlPlayer: 

Function RelativeEnemyPosition
  Inputs: []
  Outputs: []
    Line 14785: RelativeEnemyPosition: 
      Branch exit: Line 14799: VariableObjOfsRelPos: 

Function MoveColOffscreen
  Inputs: [Y]
  Outputs: [A]
                      Line 14152: MoveColOffscreen: 

Function MoveLakitu
  Inputs: [X]
  Outputs: []
      Line 9967: MoveLakitu: 
        Branch exit: Line 9972: ChkLS: LDA Enemy_State,X        ; if lakitu's enemy state not set at all,
        Line 9971: JMP MoveD_EnemyVertically       ; otherwise jump to move defeated lakitu downwards
          Branch exit: Line 7598: MoveD_EnemyVertically: 
        Line 9972: ChkLS: LDA Enemy_State,X        ; if lakitu's enemy state not set at all,
          Branch exit: Line 9979: Fr12S: LDA #Spiny
          Line 9974: LDA #$00
            Branch exit: Line 9987: SetLSpd: STA LakituMoveSpeed,X  ; set movement speed returned from sub
          Line 9979: Fr12S: LDA #Spiny
            Line 9982: LdLDa: LDA LakituDiffAdj,Y      ; load values
              Branch exit: Line 9982: LdLDa: LDA LakituDiffAdj,Y      ; load values
              Line 9986: JSR PlayerLakituDiff            ; execute sub to set speed and create spinys
          Line 9987: SetLSpd: STA LakituMoveSpeed,X  ; set movement speed returned from sub
            Branch exit: Line 9998: SetLMov: STY Enemy_MovingDir,X  ; store moving direction
            Line 9992: LDA LakituMoveSpeed,X
            Line 9998: SetLMov: STY Enemy_MovingDir,X  ; store moving direction
              Branch exit: Line 7529: MoveEnemyHorizontally: 

Function Bridge_Low
  Inputs: []
  Outputs: []
        Line 3942: Bridge_Low: 
          Branch exit: Line 4247: RenderUnderPart: 

Function CheckForClimbMTiles
  Inputs: [A, X]
  Outputs: [CarryFlag]
      Line 12365: CheckForClimbMTiles: 

Function PlayerVictoryWalk
  Inputs: []
  Outputs: []
    Line 1143: PlayerVictoryWalk: 
      Branch exit: Line 1152: PerformWalk: INC VictoryWalkControl; otherwise increment value and Y
      Line 1149: LDA Player_X_Position           ; otherwise get player's horizontal position
        Branch exit: Line 1154: DontWalk: TYA                   ; put contents of Y in A and
      Line 1152: PerformWalk: INC VictoryWalkControl; otherwise increment value and Y
      Line 1154: DontWalk: TYA                   ; put contents of Y in A and
        Branch exit: Line 1169: ExitVWalk: LDA VictoryWalkControl; load value set here
        Line 1159: LDA ScrollFractional
        Line 1169: ExitVWalk: LDA VictoryWalkControl; load value set here
          Branch exit: Line 1225: IncModeTask_A: INC OperMode_Task; move onto next task in mode
          Line 1171: RTS                             ; otherwise leave

Function RenderPlayerSub
  Inputs: [A]
  Outputs: []
    Line 14561: RenderPlayerSub: 
      Line 14575: DrawPlayerLoop:  (as a call, not in function)

Function MovePlayerHorizontally
  Inputs: []
  Outputs: [A]
    Line 7535: MovePlayerHorizontally: 
      Branch exit: Line 7578: ExXMove: RTS                    ; and leave
      Line 7538: TAX                             ; otherwise set zero for offset to use player's stuff
        Line 7540: MoveObjectHorizontally:  (as a call, not in function)

Function ChkLrgObjLength
  Inputs: []
  Outputs: []
    Line 4274: ChkLrgObjLength: 
      Line 4277: ChkLrgObjFixedLength:  (as a call, not in function)

Function PwrUpJmp
  Inputs: []
  Outputs: []
    Line 7137: PwrUpJmp: LDA #$01              ; this is a residual jump point in enemy object jump table
      Branch exit: Line 7150: PutBehind: LDA #%00100000
      Line 7145: LDA PlayerStatus                ; otherwise check player's current status
        Branch exit: Line 7149: StrType: STA PowerUpType        ; store type here
        Line 7148: LSR                             ; otherwise shift right to force fire flower type
        Line 7149: StrType: STA PowerUpType        ; store type here
      Line 7150: PutBehind: LDA #%00100000

Function GetCurrentAnimOffset
  Inputs: [Y]
  Outputs: [A]
  Line 14650: GetCurrentAnimOffset: 
    Branch exit: Line 14708: GetOffsetFromAnimCtrl: 

Function DumpThreeSpr
  Inputs: [A, Y]
  Outputs: []
                  Line 13319: DumpThreeSpr: 

Function InitEnemyObject
  Inputs: [X]
  Outputs: []
  Line 8011: InitEnemyObject: 

Function SpawnBrickChunks
  Inputs: [X]
  Outputs: []
    Line 7415: SpawnBrickChunks: 

Function HandleEnemyFBallCol
  Inputs: [$01]
  Outputs: []
      Line 11122: HandleEnemyFBallCol: 
        Branch exit: Line 11134: ChkBuzzyBeetle: 
        Line 11127: AND #%00001111                  ; otherwise mask out high nybble and
          Branch exit: Line 11141: HurtBowser: 
          Line 11132: LDX $01                         ; otherwise retrieve current enemy offset
        Line 11134: ChkBuzzyBeetle: 
          Branch exit: Line 11198: ExHCF: RTS                      ; and now let's leave
          Line 11138: CMP #Bowser                     ; check for bowser one more time (necessary if d7 of flag was clear)
            Branch exit: Line 11163: ChkOtherEnemies: 
            Line 11140: 
        Line 11141: HurtBowser: 
          Branch exit: Line 11198: ExHCF: RTS                      ; and now let's leave
          Line 11144: JSR InitVStf                    ; otherwise do sub to init vertical speed and movement force
            Branch exit: Line 11156: SetDBSte: STA Enemy_State,X     ; set defeated enemy state
            Line 11155: ORA #$03                        ; otherwise add 3 to enemy state
            Line 11156: SetDBSte: STA Enemy_State,X     ; set defeated enemy state
              Branch exit: Line 11194: EnemySmackScore: 
              Line 11162: 
        Line 11163: ChkOtherEnemies: 
          Branch exit: Line 11198: ExHCF: RTS                      ; and now let's leave
          Line 11166: CMP #Podoboo
            Branch exit: Line 11198: ExHCF: RTS                      ; and now let's leave
            Line 11168: CMP #$15
              Branch exit: Line 11198: ExHCF: RTS                      ; and now let's leave
              Line 11170: 

Function SetXMoveAmt
  Inputs: [Y, X]
  Outputs: []
  Line 7644: SetXMoveAmt: STY $00            ; set movement amount here

Function GetAreaPalette
  Inputs: []
  Outputs: []
      Line 1413: GetAreaPalette: 

Function GetBlockOffscreenBits
  Inputs: [X]
  Outputs: []
    Line 14858: GetBlockOffscreenBits: 

Function InitCheepCheep
  Inputs: [X]
  Outputs: []
    Line 8242: InitCheepCheep: 

Function GetFireballOffscreenBits
  Inputs: [$00]
  Outputs: []
    Line 14825: GetFireballOffscreenBits: 
      Branch exit: Line 14868: GetOffScreenBitsSet: 

Function LargeLiftUp
  Inputs: [X]
  Outputs: []
    Line 8943: LargeLiftUp: 
      Branch exit: Line 8950: LargeLiftBBox: 

Function IncrementColumnPos
  Inputs: []
  Outputs: []
        Line 3061: IncrementColumnPos: 
          Branch exit: Line 3068: NoColWrap: INC BlockBufferColumnPos; increment column offset where we're at
          Line 3066: STA CurrentColumnPos            ; if no bits left set, wrap back to zero (0-f)
          Line 3068: NoColWrap: INC BlockBufferColumnPos; increment column offset where we're at

Function MoveLargeLiftPlat
  Inputs: [X]
  Outputs: []
    Line 10973: MoveLargeLiftPlat: 
      Branch exit: Line 10917: ChkYPCollision: 

Function MoveSixSpritesOffscreen
  Inputs: []
  Outputs: []
            Line 13309: MoveSixSpritesOffscreen: 
              Line 13312: DumpSixSpr:  (as a call, not in function)

Function AwardGameTimerPoints
  Inputs: []
  Outputs: []
    Line 10486: AwardGameTimerPoints: 
      Branch exit: Line 10480: IncrementSFTask1: 
      Line 10491: LDA FrameCounter
        Branch exit: Line 10496: NoTTick: LDY #$23               ; set offset here to subtract from game timer's last digit
        Line 10494: LDA #Sfx_TimerTick
        Line 10496: NoTTick: LDY #$23               ; set offset here to subtract from game timer's last digit

Function GetMiscOffscreenBits
  Inputs: [$00]
  Outputs: []
    Line 14837: GetMiscOffscreenBits: 
      Branch exit: Line 14868: GetOffScreenBitsSet: 

Function ColumnOfBricks
  Inputs: [$07]
  Outputs: []
    Line 4078: ColumnOfBricks: 
      Branch exit: Line 4086: GetRow2: PHA                    ; save metatile to stack for now

Function GetAreaObjXPosition
  Inputs: []
  Outputs: [A]
    Line 4300: GetAreaObjXPosition: 

Function DrawStarFlag
  Inputs: [X]
  Outputs: []
      Line 10529: DrawStarFlag: 
        Line 10533: DSFLoop: LDA Enemy_Rel_YPos     ; get relative vertical coordinate
          Branch exit: Line 10533: DSFLoop: LDA Enemy_Rel_YPos     ; get relative vertical coordinate
          Line 10551: LDX ObjectOffset                ; get enemy object offset and leave

Function ChkForNonSolids
  Inputs: [A]
  Outputs: [ZeroFlag]
    Line 12711: ChkForNonSolids: 
      Branch exit: Line 12721: NSFnd: RTS 
      Line 12714: CMP #$c2                        ; regular coin?
        Branch exit: Line 12721: NSFnd: RTS 
        Line 12716: CMP #$c3                        ; underwater coin?
          Branch exit: Line 12721: NSFnd: RTS 
          Line 12718: CMP #$5f                        ; hidden coin block?
            Branch exit: Line 12721: NSFnd: RTS 
            Line 12720: CMP #$60                        ; hidden 1-up block?
      Line 12721: NSFnd: RTS 

Function DrawTitleScreen
  Inputs: []
  Outputs: []
    Line 1586: DrawTitleScreen: 
      Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode
      Line 1589: LDA                             ; load address $1ec0 into
        Line 1598: OutputTScr: LDA PPU_DATA        ; get title screen from chr-rom
          Branch exit: Line 1603: ChkHiByte: LDA $01              ; check high byte?
          Line 1602: INC $01                         ; otherwise increment high byte of indirect
          Line 1603: ChkHiByte: LDA $01              ; check high byte?
            Branch exit: Line 1598: OutputTScr: LDA PPU_DATA        ; get title screen from chr-rom
            Line 1606: CPY #$3a                        ; check if offset points past end of data
              Branch exit: Line 1598: OutputTScr: LDA PPU_DATA        ; get title screen from chr-rom
              Line 1608: LDA #$05                        ; set buffer transfer control to $0300,
                Branch exit: Line 1486: SetVRAMAddr_B: STA VRAM_Buffer_AddrCtrl

Function InitBlock_XY_Pos
  Inputs: [X]
  Outputs: []
    Line 7290: InitBlock_XY_Pos: 

Function InitializeMemory
  Inputs: [Y]
  Outputs: [A]
    Line 2769: InitializeMemory: 
      Line 2773: InitPageLoop: STX $07
        Line 2774: InitByteLoop: CPX #$01          ; check to see if we're on the stack ($0100-$01ff)
          Branch exit: Line 2778: InitByte: STA ($06),Y           ; otherwise, initialize byte with current low byte in Y
          Line 2776: CPY #$60                        ; otherwise, check to see if we're at $0160-$01ff
            Branch exit: Line 2779: SkipByte: DEY 
          Line 2778: InitByte: STA ($06),Y           ; otherwise, initialize byte with current low byte in Y
          Line 2779: SkipByte: DEY 
            Branch exit: Line 2774: InitByteLoop: CPX #$01          ; check to see if we're on the stack ($0100-$01ff)
            Line 2782: DEX                             ; go onto the next page
              Branch exit: Line 2773: InitPageLoop: STX $07
              Line 2784: RTS 

Function EnterSidePipe
  Inputs: []
  Outputs: []
    Line 5716: EnterSidePipe: 
      Branch exit: Line 5725: RightPipe: TYA                  ; use contents of Y to
      Line 5723: STA Player_X_Speed              ; if lower nybble = 0, set as horizontal speed
      Line 5725: RightPipe: TYA                  ; use contents of Y to

Function TitleScreenMode
  Inputs: []
  Outputs: []
    Line 956: TitleScreenMode: 
      Line 959: 
        Line 967: WSelectBufferTemplate: 
          Line 970: GameMenuRoutine:  (as a call, not in function)

Function NoRunCode
  Inputs: []
  Outputs: []
        Line 9054: NoRunCode: 

Function KillEnemyAboveBlock
  Inputs: [X]
  Outputs: []
        Line 12685: KillEnemyAboveBlock: 

Function PlayerEndWorld
  Inputs: []
  Outputs: []
    Line 1230: PlayerEndWorld: 
      Branch exit: Line 1245: EndExitOne: RTS                 ; and leave
      Line 1233: LDY WorldNumber                 ; check world number
        Branch exit: Line 1246: EndChkBButton: LDA SavedJoypad1Bits
        Line 1236: LDA #$00
        Line 1246: EndChkBButton: LDA SavedJoypad1Bits
          Branch exit: Line 1255: EndExitTwo: RTS                 ; leave
          Line 1250: LDA #$01                        ; otherwise set world selection flag
          Line 1255: EndExitTwo: RTS                 ; leave

Function PlayerGfxHandler
  Inputs: []
  Outputs: []
  Line 14434: PlayerGfxHandler: 
    Branch exit: Line 14440: CntPl: LDA GameEngineSubroutine ; if executing specific game engine routine,
    Line 14437: LDA FrameCounter
      Branch exit: Line 14471: ExPGH: RTS                      ; then leave
    Line 14440: CntPl: LDA GameEngineSubroutine ; if executing specific game engine routine,
      Branch exit: Line 14481: PlayerKilled: 
      Line 14443: LDA PlayerChangeSizeFlag        ; if grow/shrink flag set
        Branch exit: Line 14477: DoChangeSize: 
        Line 14445: LDY SwimmingFlag                ; if swimming flag set, branch to
          Branch exit: Line 14473: FindPlayerAction: 
          Line 14447: LDA Player_State
            Branch exit: Line 14473: FindPlayerAction: 
            Line 14450: JSR FindPlayerAction            ; otherwise jump and return
              Branch exit: Line 14471: ExPGH: RTS                      ; then leave
              Line 14454: TAX                             ; initialize X to zero
                Branch exit: Line 14463: SwimKT: LDA PlayerSize          ; check player's size
                Line 14459: INY 
                Line 14463: SwimKT: LDA PlayerSize          ; check player's size
                  Branch exit: Line 14469: BigKTS: LDA SwimKickTileNum,X   ; overwrite tile number in sprite 7/8
                  Line 14465: LDA Sprite_Tilenumber+24,Y      ; check tile number of seventh/eighth sprite
                    Branch exit: Line 14471: ExPGH: RTS                      ; then leave
                    Line 14468: INX                             ; otherwise increment X for second tile
                  Line 14469: BigKTS: LDA SwimKickTileNum,X   ; overwrite tile number in sprite 7/8
    Line 14471: ExPGH: RTS                      ; then leave

Function IncAreaObjOffset
  Inputs: []
  Outputs: []
    Line 3360: IncAreaObjOffset: 

Function WaterPipe
  Inputs: [X, $07]
  Outputs: []
    Line 3769: WaterPipe: 

Function RunBowser
  Inputs: [X]
  Outputs: []
      Line 10133: RunBowser: 
        Branch exit: Line 10150: BowserControl: 
        Line 10137: LDA Enemy_Y_Position,X          ; otherwise check vertical position
          Branch exit: Line 10090: MoveD_Bowser: 
          Line 10140: 

Function MoveJ_EnemyVertically
  Inputs: []
  Outputs: []
  Line 7641: MoveJ_EnemyVertically: 

Function InitPiranhaPlant
  Inputs: [X]
  Outputs: []
    Line 8813: InitPiranhaPlant: 
      Branch exit: Line 8873: SetBBox2: STA Enemy_BoundBoxCtrl,X; set bounding box control then leave

Function InjurePlayer
  Inputs: []
  Outputs: []
  Line 11400: InjurePlayer: 
    Branch exit: Line 11422: ExInjColRoutines: 
    Line 11403: 
      Line 11404: ForceInjury:  (as a call, not in function)

Function DumpFourSpr
  Inputs: [A, Y]
  Outputs: []
                Line 13316: DumpFourSpr: 
                  Line 13319: DumpThreeSpr:  (as a call, not in function)

Function GameRoutines
  Inputs: []
  Outputs: []
    Line 5473: GameRoutines: 
      Line 5476: 
        Line 5493: PlayerEntrance:  (as a call, not in function)

Function ExtraLifeMushBlock
  Inputs: [X]
  Outputs: []
                Line 7345: ExtraLifeMushBlock: 
                  Branch exit: Line 7124: SetupPowerUp: 

Function GetEnemyBoundBoxOfsArg
  Inputs: [A]
  Outputs: [CarryFlag]
      Line 11882: GetEnemyBoundBoxOfsArg: 

Function SoundEngine
  Inputs: []
  Outputs: []
    Line 15044: SoundEngine: 
      Branch exit: Line 15049: SndOn: LDA #$ff
      Line 15047: STA SND_MASTERCTRL_REG          ; if so, disable sound and leave
      Line 15049: SndOn: LDA #$ff
        Branch exit: Line 15058: InPause: LDA PauseSoundBuffer   ; check pause sfx buffer
        Line 15055: LDA PauseSoundQueue             ; if not, check pause sfx queue
          Branch exit: Line 15099: RunSoundSubroutines: 
        Line 15058: InPause: LDA PauseSoundBuffer   ; check pause sfx buffer
          Branch exit: Line 15075: ContPau: LDA Squ1_SfxLenCounter ; check pause length left
          Line 15060: LDA PauseSoundQueue             ; check pause queue
            Branch exit: Line 15108: SkipSoundSubroutines: 
            Line 15062: STA PauseSoundBuffer            ; if queue full, store in buffer and activate
          Line 15073: PTone1F: LDA #$44               ; play first tone
            Branch exit: Line 15083: PTRegC: LDX #$84
          Line 15075: ContPau: LDA Squ1_SfxLenCounter ; check pause length left
            Branch exit: Line 15082: PTone2F: LDA #$64               ; store reg contents and play the pause sfx
            Line 15078: CMP #$1e                        ; time to play first again?
              Branch exit: Line 15073: PTone1F: LDA #$44               ; play first tone
              Line 15080: CMP #$18                        ; time to play second again?
                Branch exit: Line 15086: DecPauC: DEC Squ1_SfxLenCounter ; decrement pause sfx counter
            Line 15082: PTone2F: LDA #$64               ; store reg contents and play the pause sfx
          Line 15083: PTRegC: LDX #$84
          Line 15086: DecPauC: DEC Squ1_SfxLenCounter ; decrement pause sfx counter
            Branch exit: Line 15108: SkipSoundSubroutines: 
            Line 15088: LDA #$00                        ; disable sound if in pause mode and
              Branch exit: Line 15095: SkipPIn: LDA #$00               ; clear pause sfx buffer
              Line 15093: LDA #$00                        ; clear pause mode to allow game sounds again
              Line 15095: SkipPIn: LDA #$00               ; clear pause sfx buffer
                Branch exit: Line 15108: SkipSoundSubroutines: 
                Line 15098: 
        Line 15099: RunSoundSubroutines: 
        Line 15108: SkipSoundSubroutines: 
          Branch exit: Line 15121: NoIncDAC: TYA 
          Line 15118: INC DAC_Counter                 ; increment and check counter
            Branch exit: Line 15124: StrWave: STY SND_DELTA_REG+1    ; store into DMC load register (??)
          Line 15121: NoIncDAC: TYA 
            Branch exit: Line 15124: StrWave: STY SND_DELTA_REG+1    ; store into DMC load register (??)
            Line 15123: DEC DAC_Counter                 ; decrement counter
          Line 15124: StrWave: STY SND_DELTA_REG+1    ; store into DMC load register (??)

Function SprObjectCollisionCore
  Inputs: [Y, X]
  Outputs: [CarryFlag]
      Line 12933: SprObjectCollisionCore: 

Function Setup_Vine
  Inputs: [X, Y]
  Outputs: []
    Line 6676: Setup_Vine: 
      Branch exit: Line 6690: NextVO: TXA                     ; store object offset to next available vine slot
      Line 6689: STA VineStart_Y_Position        ; otherwise store vertical coordinate here
      Line 6690: NextVO: TXA                     ; store object offset to next available vine slot

Function Jumpspring
  Inputs: [A, X, $07]
  Outputs: []
    Line 4146: Jumpspring: 

Function UpdScrollVar
  Inputs: []
  Outputs: []
          Line 5359: UpdScrollVar: LDA VRAM_Buffer_AddrCtrl
            Branch exit: Line 5373: ExitEng: RTS                    ; and after all that, we're finally done!
            Line 5362: LDA AreaParserTaskNum           ; otherwise check number of tasks
              Branch exit: Line 5372: RunParser: JSR AreaParserTaskHandler; update the name table with more level graphics
              Line 5364: LDA ScrollThirtyTwo             ; get horizontal scroll in 0-31 or $00-$20 range
                Branch exit: Line 5373: ExitEng: RTS                    ; and after all that, we're finally done!
                Line 5367: LDA ScrollThirtyTwo
              Line 5372: RunParser: JSR AreaParserTaskHandler; update the name table with more level graphics
            Line 5373: ExitEng: RTS                    ; and after all that, we're finally done!

Function WarpZoneObject
  Inputs: []
  Outputs: []
    Line 6475: WarpZoneObject: 
      Branch exit: Line 6471: ExGTimer: RTS                   ; leave
      Line 6478: LDA Player_Y_Position           ; check to see if player's vertical coordinate has
        Branch exit: Line 6471: ExGTimer: RTS                   ; leave
        Line 6481: STA ScrollLock                  ; otherwise nullify scroll lock flag
          Branch exit: Line 9172: EraseEnemyObject: 

Function RunOffscrBitsSubs
  Inputs: [A, X]
  Outputs: [A, $00]
    Line 14885: RunOffscrBitsSubs: 
      Branch exit: Line 14948: GetYOffscreenBits: 

Function DrawSmallPlatform
  Inputs: [X]
  Outputs: []
    Line 14308: DrawSmallPlatform: 
      Branch exit: Line 14335: TopSP: JSR DumpThreeSpr         ; dump vertical coordinate into Y coordinates
      Line 14334: LDA #$f8                        ; otherwise move first three sprites offscreen
      Line 14335: TopSP: JSR DumpThreeSpr         ; dump vertical coordinate into Y coordinates
        Branch exit: Line 14343: BotSP: STA Sprite_Y_Position+12,Y; dump vertical coordinate + 128 pixels
        Line 14342: LDA #$f8                        ; otherwise move last three sprites offscreen
        Line 14343: BotSP: STA Sprite_Y_Position+12,Y; dump vertical coordinate + 128 pixels
          Branch exit: Line 14353: SOfs: PLA                       ; move out and back into stack
          Line 14350: LDA #$f8                        ; if d3 was set, move first and
          Line 14353: SOfs: PLA                       ; move out and back into stack
            Branch exit: Line 14360: SOfs2: PLA                      ; get from stack
            Line 14357: LDA #$f8                        ; if d2 was set, move second and
            Line 14360: SOfs2: PLA                      ; get from stack
              Branch exit: Line 14366: ExSPl: LDX ObjectOffset         ; get enemy object offset and leave
              Line 14363: LDA #$f8                        ; if d1 was set, move third and
              Line 14366: ExSPl: LDX ObjectOffset         ; get enemy object offset and leave

Function FlagpoleRoutine
  Inputs: []
  Outputs: []
        Line 6578: FlagpoleRoutine: 
          Branch exit: Line 6620: ExitFlagP: RTS 
          Line 6584: LDA GameEngineSubroutine
            Branch exit: Line 6609: SkipScore: JMP FPGfx            ; jump to skip ahead and draw flag and floatey number
            Line 6587: LDA Player_State
              Branch exit: Line 6609: SkipScore: JMP FPGfx            ; jump to skip ahead and draw flag and floatey number
              Line 6590: LDA Enemy_Y_Position,X          ; check flagpole flag's vertical coordinate
                Branch exit: Line 6610: GiveFPScr: LDY FlagpoleScore    ; get score offset from earlier (when player touched flagpole)
                Line 6593: LDA Player_Y_Position           ; check player's vertical coordinate
                  Branch exit: Line 6610: GiveFPScr: LDY FlagpoleScore    ; get score offset from earlier (when player touched flagpole)
                  Line 6596: LDA Enemy_YMF_Dummy,X
                Line 6610: GiveFPScr: LDY FlagpoleScore    ; get score offset from earlier (when player touched flagpole)
            Line 6609: SkipScore: JMP FPGfx            ; jump to skip ahead and draw flag and floatey number
              Branch exit: Line 6617: FPGfx: JSR GetEnemyOffscreenBits; get offscreen information
            Line 6617: FPGfx: JSR GetEnemyOffscreenBits; get offscreen information
          Line 6620: ExitFlagP: RTS 

Function DrawBrickChunks
  Inputs: [X]
  Outputs: []
    Line 14161: DrawBrickChunks: 
      Branch exit: Line 14171: DChunks: LDY Block_SprDataOffset,X; get OAM data offset
      Line 14168: LDA #$03                        ; otherwise set different palette bits
      Line 14171: DChunks: LDY Block_SprDataOffset,X; get OAM data offset
        Branch exit: Line 14216: ChnkOfs: LDA $00                ; if relative position on left side of screen,
        Line 14214: LDA #$f8
        Line 14216: ChnkOfs: LDA $00                ; if relative position on left side of screen,
          Branch exit: Line 14224: ExBCDr: RTS                     ; leave
          Line 14218: LDA Sprite_X_Position,Y         ; otherwise compare left-side X coordinate
            Branch exit: Line 14224: ExBCDr: RTS                     ; leave
            Line 14221: LDA #$f8                        ; otherwise move right half of sprites offscreen
          Line 14224: ExBCDr: RTS                     ; leave

Function JumpEngine
  Inputs: [A]
  Outputs: []
                                              Line 2369: JumpEngine: 

Function PutBlockMetatile
  Inputs: [X, Y, A, $06, $02]
  Outputs: []
    Line 2060: PutBlockMetatile: 
      Branch exit: Line 2071: SaveHAdder: STY $03             ; save high byte here
      Line 2070: LDY #$24                        ; otherwise load high byte for name table 1
      Line 2071: SaveHAdder: STY $03             ; save high byte here
        Line 2092: RemBridge: LDA BlockGfxData,X   ; write top left and top right (as a call, not in function)

Function Square1SfxHandler
  Inputs: []
  Outputs: []
                      Line 15230: Square1SfxHandler: 
                        Branch exit: Line 15250: CheckSfx1Buffer: 
                        Line 15233: STY Square1SoundBuffer          ; if found, put in buffer
                          Branch exit: Line 15180: PlaySmallJump: 
                          Line 15235: LSR Square1SoundQueue
                            Branch exit: Line 15184: PlayBigJump: 
                            Line 15237: LSR Square1SoundQueue
                              Branch exit: Line 15213: PlayBump: 
                              Line 15239: LSR Square1SoundQueue
                                Branch exit: Line 15270: PlaySwimStomp: 
                                Line 15241: LSR Square1SoundQueue
                                  Branch exit: Line 15290: PlaySmackEnemy: 
                                  Line 15243: LSR Square1SoundQueue
                                    Branch exit: Line 15323: PlayPipeDownInj: 
                                    Line 15245: LSR Square1SoundQueue
                                      Branch exit: Line 15208: PlayFireballThrow: 
                                      Line 15247: LSR Square1SoundQueue
                                        Branch exit: Line 15172: PlayFlagpoleSlide: 
                                        Line 15249: 
                        Line 15250: CheckSfx1Buffer: 
                          Branch exit: Line 15268: ExS1H: RTS 
                          Line 15253: BMI ContinueSndJump             ; small mario jump
                            Branch exit: Line 15194: ContinueSndJump: 
                            Line 15254: LSR 
                              Branch exit: Line 15194: ContinueSndJump: 
                              Line 15256: LSR 
                                Branch exit: Line 15221: ContinueBumpThrow: 
                                Line 15258: LSR 
                                  Branch exit: Line 15278: ContinueSwimStomp: 
                                  Line 15260: LSR 
                                    Branch exit: Line 15299: ContinueSmackEnemy: 
                                    Line 15262: LSR 
                                      Branch exit: Line 15327: ContinuePipeDownInj: 
                                      Line 15264: LSR 
                                        Branch exit: Line 15221: ContinueBumpThrow: 
                                        Line 15266: LSR 
                                          Branch exit: Line 15310: DecrementSfx1Length: 
                          Line 15268: ExS1H: RTS 

Function FindEmptyEnemySlot
  Inputs: []
  Outputs: [CarryFlag, A]
    Line 3895: FindEmptyEnemySlot: 
      Line 3897: EmptyChkLoop: CLC               ; clear carry flag by default
        Branch exit: Line 3903: ExitEmptyChk: RTS               ; if all values nonzero, carry flag is set
        Line 3900: INX 
          Branch exit: Line 3897: EmptyChkLoop: CLC               ; clear carry flag by default
        Line 3903: ExitEmptyChk: RTS               ; if all values nonzero, carry flag is set

Function RunFireworks
  Inputs: [X]
  Outputs: []
    Line 10412: RunFireworks: 
      Branch exit: Line 10421: SetupExpl: JSR RelativeEnemyPosition; get relative coordinates of explosion
      Line 10415: LDA #$08
        Branch exit: Line 10431: FireworksSoundScore: 
      Line 10421: SetupExpl: JSR RelativeEnemyPosition; get relative coordinates of explosion

Function RunSmallPlatform
  Inputs: []
  Outputs: []
    Line 9130: RunSmallPlatform: 
      Branch exit: Line 11005: OffscreenBoundsCheck: 

Function SetFreq_Squ2
  Inputs: [A]
  Outputs: [ZeroFlag]
      Line 15158: SetFreq_Squ2: 
        Branch exit: Line 15140: Dump_Freq_Regs: 
        Line 15161: 
          Line 15162: SetFreq_Tri:  (as a call, not in function)

Function FallingSub
  Inputs: []
  Outputs: []
    Line 5914: FallingSub: 
      Branch exit: Line 5946: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)

Function SetFreq_Squ1
  Inputs: [A]
  Outputs: [ZeroFlag]
      Line 15137: SetFreq_Squ1: 

Function MoveWithXMCntrs
  Inputs: [X]
  Outputs: []
    Line 9442: MoveWithXMCntrs: 
      Branch exit: Line 9455: XMRight: STY Enemy_MovingDir,X  ; store as moving direction
      Line 9449: LDA XMoveSecondaryCounter,X
      Line 9455: XMRight: STY Enemy_MovingDir,X  ; store as moving direction

Function RowOfCoins
  Inputs: [$07]
  Outputs: []
      Line 4016: RowOfCoins: 
        Branch exit: Line 4071: GetRow: PHA                     ; store metatile here

Function SubtEnemyYPos
  Inputs: [X]
  Outputs: [CarryFlag]
    Line 12653: SubtEnemyYPos: 

Function StarFlagExit
  Inputs: []
  Outputs: []
  Line 10483: StarFlagExit: 

Function EndOfEnemyInitCode
  Inputs: []
  Outputs: []
    Line 8999: EndOfEnemyInitCode: 

Function ChkForBump_HammerBroJ
  Inputs: [X]
  Outputs: []
  Line 12612: ChkForBump_HammerBroJ: 
    Branch exit: Line 12620: NoBump: LDA Enemy_ID,X          ; check for hammer bro
    Line 12615: LDA Enemy_State,X               ; if enemy state d7 not set, branch
      Branch exit: Line 12620: NoBump: LDA Enemy_ID,X          ; check for hammer bro
      Line 12618: LDA #Sfx_Bump                   ; otherwise, play bump sound
    Line 12620: NoBump: LDA Enemy_ID,X          ; check for hammer bro
      Branch exit: Line 12628: InvEnemyDir: 
      Line 12623: LDA #$00
        Branch exit: Line 9259: SetHJ: STY Enemy_Y_Speed,X      ; set vertical speed for jumping

Function DrawMushroomIcon
  Inputs: []
  Outputs: []
      Line 1067: DrawMushroomIcon: 
        Line 1069: IconDataRead: LDA MushroomIconData,Y; note that the default position is set for a
          Branch exit: Line 1069: IconDataRead: LDA MushroomIconData,Y; note that the default position is set for a
          Line 1073: LDA NumberOfPlayers             ; check number of players
            Branch exit: Line 1079: ExitIcon: RTS 
            Line 1075: LDA #$24                        ; otherwise, load blank tile in 1-player position
            Line 1079: ExitIcon: RTS 

Function StopPlatforms
  Inputs: [A, Y]
  Outputs: []
  Line 10872: StopPlatforms: 

Function ProcessWhirlpools
  Inputs: []
  Outputs: []
    Line 6493: ProcessWhirlpools: 
      Branch exit: Line 6522: ExitWh: RTS                     ; leave
      Line 6496: STA Whirlpool_Flag              ; otherwise initialize whirlpool flag
        Branch exit: Line 6522: ExitWh: RTS                     ; leave
        Line 6499: LDY #$04                        ; otherwise start with last whirlpool data
          Line 6500: WhLoop: LDA Whirlpool_LeftExtent,Y; get left extent of whirlpool
            Branch exit: Line 6520: NextWh: DEY                     ; move onto next whirlpool data
            Line 6506: ADC #$00                        ; add carry
              Branch exit: Line 6520: NextWh: DEY                     ; move onto next whirlpool data
              Line 6514: LDA $02                         ; otherwise get right extent
                Branch exit: Line 6524: WhirlpoolActivate: 
            Line 6520: NextWh: DEY                     ; move onto next whirlpool data
              Branch exit: Line 6500: WhLoop: LDA Whirlpool_LeftExtent,Y; get left extent of whirlpool
      Line 6522: ExitWh: RTS                     ; leave

Function FireballObjCore
  Inputs: [X]
  Outputs: []
      Line 6326: FireballObjCore: 
        Branch exit: Line 6379: FireballExplosion: 
        Line 6331: LDY Fireball_State,X            ; if fireball inactive, branch to leave
          Branch exit: Line 6377: NoFBall: RTS                    ; leave
          Line 6333: DEY                             ; if fireball state set to 1, skip this part and just run it
            Branch exit: Line 6354: RunFB: TXA                      ; add 7 to offset to use
            Line 6335: LDA Player_X_Position           ; get player's horizontal position
            Line 6354: RunFB: TXA                      ; add 7 to offset to use
              Branch exit: Line 6375: EraseFB: LDA #$00               ; erase fireball state
              Line 6373: JSR FireballEnemyCollision      ; do fireball to enemy collision detection and deal with collisions
                Branch exit: Line 14228: DrawFireball: 
              Line 6375: EraseFB: LDA #$00               ; erase fireball state
          Line 6377: NoFBall: RTS                    ; leave

Function EnemyJump
  Inputs: [CarryFlag, X]
  Outputs: []
  Line 12660: EnemyJump: 
    Branch exit: Line 12675: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
    Line 12663: LDA Enemy_Y_Speed,X
      Branch exit: Line 12675: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
      Line 12668: JSR ChkUnderEnemy               ; otherwise, check to see if green paratroopa is
        Branch exit: Line 12675: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
        Line 12670: JSR ChkForNonSolids             ; check for non-solid blocks
          Branch exit: Line 12675: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
          Line 12672: JSR EnemyLanding                ; change vertical coordinate and speed
    Line 12675: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
      Branch exit: Line 12591: DoEnemySideCheck: 

Function VineObjectHandler
  Inputs: [X, $02]
  Outputs: []
      Line 6704: VineObjectHandler: 
        Branch exit: Line 6754: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
        Line 6707: LDY VineFlagOffset
          Branch exit: Line 6720: RunVSubs: LDA VineHeight        ; if vine still very small,
          Line 6712: LDA FrameCounter                ; get frame counter
            Branch exit: Line 6720: RunVSubs: LDA VineHeight        ; if vine still very small,
            Line 6716: LDA Enemy_Y_Position+5
          Line 6720: RunVSubs: LDA VineHeight        ; if vine still very small,
            Branch exit: Line 6754: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
            Line 6723: JSR RelativeEnemyPosition       ; get relative coordinates of vine,
              Line 6726: VDrawLoop: JSR DrawVine         ; draw vine
                Branch exit: Line 6726: VDrawLoop: JSR DrawVine         ; draw vine
                Line 6730: LDA Enemy_OffscreenBits
                  Branch exit: Line 6740: WrCMTile: LDA VineHeight        ; check vine height
                  Line 6733: DEY                             ; otherwise decrement Y to get proper offset again
                    Line 6734: KillVine: LDX VineObjOffset,Y   ; get enemy object offset for this vine object
                      Branch exit: Line 6734: KillVine: LDX VineObjOffset,Y   ; get enemy object offset for this vine object
                      Line 6738: STA VineFlagOffset              ; initialize vine flag/offset
                  Line 6740: WrCMTile: LDA VineHeight        ; check vine height
                    Branch exit: Line 6754: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
                    Line 6743: LDX #$06                        ; set offset in X to last enemy slot
                      Branch exit: Line 6754: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
                      Line 6750: LDA ($06),Y                     ; otherwise check contents of block buffer at
                        Branch exit: Line 6754: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
                        Line 6752: LDA #$26
        Line 6754: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave

Function StarBlock
  Inputs: []
  Outputs: []
              Line 7341: StarBlock: 
                Line 7345: ExtraLifeMushBlock:  (as a call, not in function)

Function AreaParserTaskHandler
  Inputs: []
  Outputs: []
    Line 3034: AreaParserTaskHandler: 
      Branch exit: Line 3039: DoAPTasks: DEY 
      Line 3037: LDY #$08
      Line 3039: DoAPTasks: DEY 
        Branch exit: Line 3045: SkipATRender: RTS 
        Line 3044: JSR RenderAttributeTables
        Line 3045: SkipATRender: RTS 

Function VictoryMode
  Inputs: []
  Outputs: []
    Line 1111: VictoryMode: 
      Branch exit: Line 1118: AutoPlayer: JSR RelativePlayerPosition; get player's relative coordinates
      Line 1115: LDX #$00
      Line 1118: AutoPlayer: JSR RelativePlayerPosition; get player's relative coordinates
        Branch exit: Line 14434: PlayerGfxHandler: 

Function RemBridge
  Inputs: [X, Y, $04, $05, $00]
  Outputs: []
        Line 2092: RemBridge: LDA BlockGfxData,X   ; write top left and top right

Function MoveBulletBill
  Inputs: [X]
  Outputs: []
    Line 9577: MoveBulletBill: 
      Branch exit: Line 9582: NotDefB: LDA #$e8               ; set bullet bill's horizontal speed
      Line 9581: JMP MoveJ_EnemyVertically       ; otherwise jump to move defeated bullet bill downwards
        Branch exit: Line 7641: MoveJ_EnemyVertically: 
      Line 9582: NotDefB: LDA #$e8               ; set bullet bill's horizontal speed
        Branch exit: Line 7529: MoveEnemyHorizontally: 

Function InitVertPlatform
  Inputs: [X]
  Outputs: []
    Line 8913: InitVertPlatform: 
      Branch exit: Line 8921: SetYO: STA YPlatformTopYPos,X   ; save as top vertical position
      Line 8917: EOR #$ff
      Line 8921: SetYO: STA YPlatformTopYPos,X   ; save as top vertical position

Function OutputNumbers
  Inputs: [A]
  Outputs: []
    Line 2538: OutputNumbers: 
      Branch exit: Line 2578: ExitOutputN: RTS 
      Line 2544: PHA                             ; save incremented value to stack for now and
        Branch exit: Line 2552: SetupNums: STA VRAM_Buffer1,X
        Line 2551: LDA #$22                        ; if so, put further down on the screen
        Line 2552: SetupNums: STA VRAM_Buffer1,X
          Line 2566: DigitPLoop: LDA DisplayDigits,Y ; write digits to the buffer
            Branch exit: Line 2566: DigitPLoop: LDA DisplayDigits,Y ; write digits to the buffer
            Line 2572: LDA #$00                        ; put null terminator at end
      Line 2578: ExitOutputN: RTS 

Function AreaParserCore
  Inputs: []
  Outputs: []
                  Line 3153: AreaParserCore: 
                    Branch exit: Line 3158: RenderSceneryTerrain: 
                    Line 3156: JSR ProcessAreaData             ; otherwise skip ahead and load level data
                    Line 3158: RenderSceneryTerrain: 
                      Line 3161: ClrMTBuf: STA MetatileBuffer,X  ; clear out metatile buffer
                        Branch exit: Line 3161: ClrMTBuf: STA MetatileBuffer,X  ; clear out metatile buffer
                        Line 3164: LDY BackgroundScenery           ; do we need to render the background scenery?
                          Branch exit: Line 3205: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                          Line 3166: LDA CurrentPageLoc              ; otherwise check for every third page
                            Line 3167: ThirdP: CMP #$03
                              Branch exit: Line 3172: RendBack: ASL                   ; move results to higher nybble
                              Line 3169: SEC 
                                Branch exit: Line 3167: ThirdP: CMP #$03
                              Line 3172: RendBack: ASL                   ; move results to higher nybble
                                Branch exit: Line 3205: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                                Line 3181: PHA 
                                  Line 3197: SceLoop1: LDA BackSceneryMetatiles,X; load metatile data from offset of (lsb - 1) * 3
                                    Branch exit: Line 3205: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                                    Line 3203: DEC $00                         ; decrement until counter expires, barring exception
                                      Branch exit: Line 3197: SceLoop1: LDA BackSceneryMetatiles,X; load metatile data from offset of (lsb - 1) * 3
                          Line 3205: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                            Branch exit: Line 3216: RendTerr: LDY AreaType          ; check world type for water level
                            Line 3207: LDY FSceneDataOffsets-1,X       ; load offset from location offset by header value, then
                              Line 3209: SceLoop2: LDA ForeSceneryData,Y ; load data until counter expires
                                Branch exit: Line 3212: NoFore: INY 
                                Line 3211: STA MetatileBuffer,X
                                Line 3212: NoFore: INY 
                                  Branch exit: Line 3209: SceLoop2: LDA ForeSceneryData,Y ; load data until counter expires
                            Line 3216: RendTerr: LDY AreaType          ; check world type for water level
                              Branch exit: Line 3223: TerMTile: LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type
                              Line 3218: LDA WorldNumber                 ; check world number, if not world number eight
                                Branch exit: Line 3223: TerMTile: LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type
                                Line 3221: LDA #$62                        ; if set as water level and world number eight,
                                  Branch exit: Line 3227: StoreMT: STA $07                ; store value here
                              Line 3223: TerMTile: LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type
                                Branch exit: Line 3227: StoreMT: STA $07                ; store value here
                                Line 3226: LDA #$88                        ; use cloud block terrain
                              Line 3227: StoreMT: STA $07                ; store value here
                                Line 3232: TerrLoop: LDA TerrainRenderBits,Y; get one of the terrain rendering bit data
                                  Branch exit: Line 3243: NoCloud2: LDY #$00              ; start at beginning of bitmasks
                                  Line 3238: CPX #$00                        ; otherwise, check if we're doing the ceiling byte
                                    Branch exit: Line 3243: NoCloud2: LDY #$00              ; start at beginning of bitmasks
                                    Line 3240: LDA $00                         ; if not, mask out all but d3
                                  Line 3243: NoCloud2: LDY #$00              ; start at beginning of bitmasks
                                    Line 3244: TerrBChk: LDA Bitmasks,Y        ; load bitmask, then perform AND on contents of first byte
                                      Branch exit: Line 3249: NextTBit: INX                   ; continue until end of buffer
                                      Line 3247: LDA $07
                                      Line 3249: NextTBit: INX                   ; continue until end of buffer
                                        Branch exit: Line 3264: RendBBuf: JSR ProcessAreaData   ; do the area data loading routine now
                                        Line 3252: LDA AreaType                    ; check world type for underground area
                                          Branch exit: Line 3259: EndUChk: INY                    ; increment bitmasks offset in Y
                                          Line 3255: CPX #$0b
                                            Branch exit: Line 3259: EndUChk: INY                    ; increment bitmasks offset in Y
                                            Line 3257: LDA #$54                        ; old terrain type with ground level terrain type
                                          Line 3259: EndUChk: INY                    ; increment bitmasks offset in Y
                                            Branch exit: Line 3244: TerrBChk: LDA Bitmasks,Y        ; load bitmask, then perform AND on contents of first byte
                                            Line 3262: LDY $01
                                              Branch exit: Line 3232: TerrLoop: LDA TerrainRenderBits,Y; get one of the terrain rendering bit data
                                        Line 3264: RendBBuf: JSR ProcessAreaData   ; do the area data loading routine now
                                          Line 3269: ChkMTLow: STY $00
                                            Branch exit: Line 3280: StrBlock: LDY $00               ; get offset for block buffer
                                            Line 3279: LDA #$00                        ; if less, init value before storing
                                            Line 3280: StrBlock: LDY $00               ; get offset for block buffer
                                              Branch exit: Line 3269: ChkMTLow: STY $00
                                              Line 3289: RTS 

Function BlockBufferColli_Feet
  Inputs: [Y]
  Outputs: []
          Line 13041: BlockBufferColli_Feet: 
            Line 13044: BlockBufferColli_Head:  (as a call, not in function)

Function StopSquare1Sfx
  Inputs: []
  Outputs: []
      Line 15314: StopSquare1Sfx: 

Function PlayerLoseLife
  Inputs: []
  Outputs: []
      Line 2905: PlayerLoseLife: 
        Branch exit: Line 2918: StillInGame: LDA WorldNumber    ; multiply world number by 2 and use
        Line 2913: LDA #$00
        Line 2918: StillInGame: LDA WorldNumber    ; multiply world number by 2 and use
          Branch exit: Line 2925: GetHalfway: LDY HalfwayPageNybbles,X; get halfway page number with offset
          Line 2924: INX 
          Line 2925: GetHalfway: LDY HalfwayPageNybbles,X; get halfway page number with offset
            Branch exit: Line 2934: MaskHPNyb: AND #%00001111       ; mask out all but lower nybble
            Line 2930: LSR                             ; move higher nybble to lower if area
            Line 2934: MaskHPNyb: AND #%00001111       ; mask out all but lower nybble
              Branch exit: Line 2939: SetHalfway: STA HalfwayPage     ; store as halfway page for player
              Line 2937: BCC SetHalfway                  ; otherwise player must start at the
                Branch exit: Line 2939: SetHalfway: STA HalfwayPage     ; store as halfway page for player
                Line 2938: LDA #$00                        ; beginning of the level
              Line 2939: SetHalfway: STA HalfwayPage     ; store as halfway page for player
                Branch exit: Line 2989: ContinueGame: 

Function MovePlatformDown
  Inputs: []
  Outputs: []
    Line 7672: MovePlatformDown: 
      Line 7676: MovePlatformUp:  (as a call, not in function)

Function FirebarCollision
  Inputs: [Y, $07, $00]
  Outputs: []
            Line 9796: FirebarCollision: 
              Branch exit: Line 9863: NoColFB: PLA                    ; get OAM data offset
              Line 9803: STA $05                         ; otherwise initialize counter
                Branch exit: Line 9863: NoColFB: PLA                    ; get OAM data offset
                Line 9807: LDY Player_Y_Position           ; get player's vertical position
                  Branch exit: Line 9812: AdjSm: INC $05                  ; if small or big but crouching, execute this part
                  Line 9810: LDA CrouchingFlag
                    Branch exit: Line 9818: BigJp: TYA                      ; get vertical coordinate, altered or otherwise, from Y
                  Line 9812: AdjSm: INC $05                  ; if small or big but crouching, execute this part
                  Line 9818: BigJp: TYA                      ; get vertical coordinate, altered or otherwise, from Y
                    Line 9819: FBCLoop: SEC                    ; subtract vertical position of firebar
                      Branch exit: Line 9825: ChkVFBD: CMP #$08               ; if difference => 8 pixels, skip ahead of this part
                      Line 9822: EOR #$ff                        ; skip two's compliment part
                      Line 9825: ChkVFBD: CMP #$08               ; if difference => 8 pixels, skip ahead of this part
                        Branch exit: Line 9842: Chk2Ofs: LDA $05                ; if value of $02 was set earlier for whatever reason,
                        Line 9827: LDA $06                         ; if firebar on far right on the screen, skip this,
                          Branch exit: Line 9842: Chk2Ofs: LDA $05                ; if value of $02 was set earlier for whatever reason,
                          Line 9830: LDA Sprite_X_Position+4         ; get OAM X coordinate for sprite #1
                            Branch exit: Line 9840: ChkFBCl: CMP #$08               ; if difference < 8 pixels, collision, thus branch
                            Line 9837: EOR #$ff                        ; skip two's compliment part
                            Line 9840: ChkFBCl: CMP #$08               ; if difference < 8 pixels, collision, thus branch
                              Branch exit: Line 9851: ChgSDir: LDX #$01               ; set movement direction by default
                              Line 9851: ChgSDir: LDX #$01               ; set movement direction by default
                                Branch exit: Line 9856: SetSDir: STX Enemy_MovingDir    ; store movement direction here
                                Line 9855: INX                             ; otherwise increment it
                                Line 9856: SetSDir: STX Enemy_MovingDir    ; store movement direction here
                        Line 9842: Chk2Ofs: LDA $05                ; if value of $02 was set earlier for whatever reason,
                          Branch exit: Line 9863: NoColFB: PLA                    ; get OAM data offset
                          Line 9845: LDY $05                         ; otherwise get temp here and use as offset
                            Branch exit: Line 9819: FBCLoop: SEC                    ; subtract vertical position of firebar
              Line 9863: NoColFB: PLA                    ; get OAM data offset

Function FloateyNumbersRoutine
  Inputs: [X]
  Outputs: [X]
        Line 1282: FloateyNumbersRoutine: 
          Branch exit: Line 1245: EndExitOne: RTS                 ; and leave
          Line 1285: CMP #$0b                        ; if less than $0b, branch
            Branch exit: Line 1289: ChkNumTimer: TAY                ; use as Y
            Line 1287: LDA #$0b                        ; otherwise set to $0b, thus keeping
            Line 1289: ChkNumTimer: TAY                ; use as Y
              Branch exit: Line 1294: DecNumTimer: DEC FloateyNum_Timer,X; decrement value here
              Line 1292: STA FloateyNum_Control,X        ; initialize floatey number control and leave
              Line 1294: DecNumTimer: DEC FloateyNum_Timer,X; decrement value here
                Branch exit: Line 1312: ChkTallEnemy: LDY Enemy_SprDataOffset,X; get OAM data offset for enemy object
                Line 1297: CPY #$0b                        ; check offset for $0b
                  Branch exit: Line 1302: LoadNumTiles: LDA ScoreUpdateData,Y; load point value here
                  Line 1299: INC NumberofLives               ; give player one extra life (1-up)
                  Line 1302: LoadNumTiles: LDA ScoreUpdateData,Y; load point value here
                Line 1312: ChkTallEnemy: LDY Enemy_SprDataOffset,X; get OAM data offset for enemy object
                  Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                  Line 1316: CMP #PiranhaPlant
                    Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                    Line 1318: CMP #HammerBro
                      Branch exit: Line 1329: GetAltOffset: LDX SprDataOffset_Ctrl; load some kind of control bit
                      Line 1320: CMP #GreyCheepCheep
                        Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                        Line 1322: CMP #RedCheepCheep
                          Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                          Line 1324: CMP #TallEnemy
                            Branch exit: Line 1329: GetAltOffset: LDX SprDataOffset_Ctrl; load some kind of control bit
                            Line 1326: LDA Enemy_State,X
                              Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                      Line 1329: GetAltOffset: LDX SprDataOffset_Ctrl; load some kind of control bit
                  Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                    Branch exit: Line 1337: SetupNumSpr: LDA FloateyNum_Y_Pos,X; get vertical coordinate
                    Line 1335: SBC #$01
                    Line 1337: SetupNumSpr: LDA FloateyNum_Y_Pos,X; get vertical coordinate

Function MoveFlyGreenPTroopa
  Inputs: [X]
  Outputs: []
    Line 9401: MoveFlyGreenPTroopa: 
      Branch exit: Line 9417: NoMGPT: RTS                     ; leave!
      Line 9408: LDA FrameCounter
        Branch exit: Line 9412: YSway: STY $00                  ; store adder here
        Line 9411: LDY #$ff                        ; otherwise set Y to move green paratroopa up
        Line 9412: YSway: STY $00                  ; store adder here
      Line 9417: NoMGPT: RTS                     ; leave!

Function MusicHandler
  Inputs: []
  Outputs: []
    Line 15609: MusicHandler: 
      Branch exit: Line 15619: LoadEventMusic: 
      Line 15612: LDA AreaMusicQueue              ; check area music queue
        Branch exit: Line 15636: LoadAreaMusic: 
        Line 15614: LDA EventMusicBuffer            ; check both buffers
          Branch exit: Line 15606: ContinueMusic: 
          Line 15617: RTS                             ; no music, then leave

Function PlaySqu2Sfx
  Inputs: []
  Outputs: []
    Line 15155: PlaySqu2Sfx: 
      Line 15158: SetFreq_Squ2:  (as a call, not in function)

Function PlayerInjuryBlink
  Inputs: []
  Outputs: []
    Line 5743: PlayerInjuryBlink: 
      Branch exit: Line 5750: ExitBlink: BNE ExitBoth         ; do unconditional branch to leave
      Line 5747: CMP #$c8                        ; check again for another specific point
        Branch exit: Line 5771: DonePlayerTask: 
        Line 5749: JMP PlayerCtrlRoutine           ; otherwise run player control routine
          Branch exit: Line 5557: PlayerCtrlRoutine: 
      Line 5750: ExitBlink: BNE ExitBoth         ; do unconditional branch to leave
        Branch exit: Line 5760: ExitBoth: RTS                   ; leave
        Line 5751: 

Function BubbleCheck
  Inputs: [X]
  Outputs: []
    Line 6383: BubbleCheck: 
      Branch exit: Line 6414: MoveBubl: LDY $07               ; get pseudorandom bit again, use as offset
      Line 6390: LDA AirBubbleTimer              ; if air bubble timer not expired,
        Branch exit: Line 6425: ExitBubl: RTS                   ; leave
        Line 6392: 
          Line 6393: SetupBubble:  (as a call, not in function)
      Line 6414: MoveBubl: LDY $07               ; get pseudorandom bit again, use as offset
        Branch exit: Line 6424: Y_Bubl: STA Bubble_Y_Position,X ; store as new vertical coordinate for air bubble
        Line 6423: LDA #$f8                        ; otherwise set offscreen coordinate
        Line 6424: Y_Bubl: STA Bubble_Y_Position,X ; store as new vertical coordinate for air bubble
      Line 6425: ExitBubl: RTS                   ; leave

Function OperModeExecutionTree
  Inputs: []
  Outputs: []
    Line 928: OperModeExecutionTree: 
      Line 931: 
        Line 939: MoveAllSpritesOffscreen:  (as a call, not in function)

Function MoveNormalEnemy
  Inputs: [X]
  Outputs: []
        Line 9292: MoveNormalEnemy: 
          Branch exit: Line 9310: FallE: JSR MoveD_EnemyVertically; do a sub here to move enemy downwards
          Line 9297: LDA Enemy_State,X
            Branch exit: Line 9324: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
            Line 9300: LDA Enemy_State,X
              Branch exit: Line 9355: MoveDefeatedEnemy: 
              Line 9303: LDA Enemy_State,X
                Branch exit: Line 9324: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
                Line 9306: CMP #$05
                  Branch exit: Line 9310: FallE: JSR MoveD_EnemyVertically; do a sub here to move enemy downwards
                  Line 9308: CMP #$03
                    Branch exit: Line 9337: ReviveStunned: 
          Line 9310: FallE: JSR MoveD_EnemyVertically; do a sub here to move enemy downwards
            Branch exit: Line 9321: MEHor: JMP MoveEnemyHorizontally; jump here to move enemy horizontally for <> $2e and d6 set
            Line 9315: AND #%01000000                  ; check for d6 set
              Branch exit: Line 9324: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
              Line 9317: LDA Enemy_ID,X
                Branch exit: Line 9324: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
                Line 9320: BNE SlowM                       ; if any other object where d6 set, jump to set Y
                  Branch exit: Line 9323: SlowM: LDY #$01                 ; if branched here, increment Y to slow horizontal movement
            Line 9321: MEHor: JMP MoveEnemyHorizontally; jump here to move enemy horizontally for <> $2e and d6 set
              Branch exit: Line 7529: MoveEnemyHorizontally: 

Function GetBackgroundColor
  Inputs: []
  Outputs: []
          Line 1434: GetBackgroundColor: 
            Branch exit: Line 1439: NoBGColor: INC ScreenRoutineTask; increment to next subtask and plod on through
            Line 1437: LDA BGColorCtrl_Addr-4,Y        ; put appropriate palette into vram
            Line 1439: NoBGColor: INC ScreenRoutineTask; increment to next subtask and plod on through
              Line 1441: GetPlayerColors:  (as a call, not in function)

Function PrintStatusBarNumbers
  Inputs: [A]
  Outputs: []
  Line 2529: PrintStatusBarNumbers: 
    Line 2538: OutputNumbers:  (as a call, not in function)

Function InitShortFirebar
  Inputs: [X]
  Outputs: []
          Line 8377: InitShortFirebar: 
            Branch exit: Line 8872: TallBBox2: LDA #$03             ; set specific value for bounding box control

Function LakituAndSpinyHandler
  Inputs: [X]
  Outputs: []
      Line 8274: LakituAndSpinyHandler: 
        Branch exit: Line 8305: ExLSHand: RTS 
        Line 8277: CPX #$05                        ; if we are on the special use slot, leave
          Branch exit: Line 8305: ExLSHand: RTS 
          Line 8279: LDA #$80                        ; set timer
            Line 8282: ChkLak: LDA Enemy_ID,Y          ; check all enemy slots to see
              Branch exit: Line 8309: CreateSpiny: 
              Line 8285: DEY                             ; otherwise check another slot
                Branch exit: Line 8282: ChkLak: LDA Enemy_ID,Y          ; check all enemy slots to see
                Line 8287: INC LakituReappearTimer         ; increment reappearance timer
                  Branch exit: Line 8305: ExLSHand: RTS 
                  Line 8291: LDX #$04                        ; start with the last enemy slot again
                    Line 8292: ChkNoEn: LDA Enemy_Flag,X       ; check enemy buffer flag for non-active enemy slot
                      Branch exit: Line 8297: CreateL: LDA #$00               ; initialize enemy state
                      Line 8294: DEX                             ; otherwise check next slot
                        Branch exit: Line 8292: ChkNoEn: LDA Enemy_Flag,X       ; check enemy buffer flag for non-active enemy slot
                        Line 8296: BMI RetEOfs                     ; if no empty slots were found, branch to leave
                          Branch exit: Line 8304: RetEOfs: LDX ObjectOffset       ; get enemy object buffer offset again and leave
                      Line 8297: CreateL: LDA #$00               ; initialize enemy state
                      Line 8304: RetEOfs: LDX ObjectOffset       ; get enemy object buffer offset again and leave

Function XMoveCntr_GreenPTroopa
  Inputs: []
  Outputs: []
    Line 9419: XMoveCntr_GreenPTroopa: 
      Line 9422: XMoveCntr_Platform:  (as a call, not in function)

Function CastleBridgeObj
  Inputs: []
  Outputs: []
        Line 4029: CastleBridgeObj: 
          Branch exit: Line 4038: ChainObj: 

Function GameMode
  Inputs: []
  Outputs: []
                                                                                                                                                                            Line 5289: GameMode: 
                                                                                                                                                                              Line 5292: 
                                                                                                                                                                                Line 5300: GameCoreRoutine:  (as a call, not in function)

Function BrickWithItem
  Inputs: [Y]
  Outputs: []
  Line 4186: BrickWithItem: 
    Branch exit: Line 4194: BWithL: CLC                     ; add object ID to adder
    Line 4193: LDA #$05                        ; otherwise use adder for bricks without lines
    Line 4194: BWithL: CLC                     ; add object ID to adder

Function PowerUpObjHandler
  Inputs: []
  Outputs: []
    Line 7158: PowerUpObjHandler: 
      Branch exit: Line 7206: ExitPUp: RTS                    ; and we're done
      Line 7163: ASL                             ; shift to check if d7 was set in object state
        Branch exit: Line 7180: GrowThePowerUp: 
        Line 7165: LDA TimerControl                ; if master timer control set,
          Branch exit: Line 7200: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen
          Line 7167: LDA PowerUpType                 ; check power-up type
            Branch exit: Line 7176: ShroomM: JSR MoveNormalEnemy    ; do sub to make mushrooms move
            Line 7169: CMP #$03
              Branch exit: Line 7176: ShroomM: JSR MoveNormalEnemy    ; do sub to make mushrooms move
              Line 7171: CMP #$02
                Branch exit: Line 7200: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen
                Line 7173: JSR MoveJumpingEnemy            ; otherwise impose gravity on star power-up and make it jump
                  Branch exit: Line 7200: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen
            Line 7176: ShroomM: JSR MoveNormalEnemy    ; do sub to make mushrooms move
              Branch exit: Line 7200: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen

Function AxeObj
  Inputs: []
  Outputs: []
    Line 4034: AxeObj: 

Function RenderUnderPart
  Inputs: [Y, X, A]
  Outputs: []
  Line 4247: RenderUnderPart: 
    Branch exit: Line 4263: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
    Line 4251: CPY #$17
      Branch exit: Line 4264: WaitOneRow: INX 
      Line 4253: CPY #$1a
        Branch exit: Line 4264: WaitOneRow: INX 
        Line 4255: CPY #$c0
          Branch exit: Line 4263: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
          Line 4257: CPY #$c0
            Branch exit: Line 4264: WaitOneRow: INX 
            Line 4259: CPY #$54
              Branch exit: Line 4263: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
              Line 4261: CMP #$50
                Branch exit: Line 4264: WaitOneRow: INX 
    Line 4263: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
    Line 4264: WaitOneRow: INX 
      Branch exit: Line 4270: ExitUPartR: RTS 
      Line 4267: LDY AreaObjectHeight            ; decrement, and stop rendering if there is no more length
        Branch exit: Line 4247: RenderUnderPart: 
      Line 4270: ExitUPartR: RTS 

Function BlockBumpedChk
  Inputs: [A]
  Outputs: [CarryFlag]
      Line 7367: BlockBumpedChk: 
        Line 7369: BumpChkLoop: CMP BrickQBlockMetatiles,Y; check to see if current metatile matches
          Branch exit: Line 7374: MatchBump: RTS                  ; note carry is set if found match
          Line 7371: DEY                             ; otherwise move onto next metatile
            Branch exit: Line 7369: BumpChkLoop: CMP BrickQBlockMetatiles,Y; check to see if current metatile matches
            Line 7373: CLC                             ; if none match, return with carry clear
          Line 7374: MatchBump: RTS                  ; note carry is set if found match

Function ChgAreaMode
  Inputs: []
  Outputs: [A]
  Line 5710: ChgAreaMode: INC DisableScreenFlag; set flag to disable screen output

Function MoveD_EnemyVertically
  Inputs: [X]
  Outputs: []
  Line 7598: MoveD_EnemyVertically: 
    Branch exit: Line 7606: ContVMove: JMP SetHiMax         ; jump to skip the rest of this
    Line 7603: 
      Line 7604: MoveFallingPlatform:  (as a call, not in function)
    Line 7606: ContVMove: JMP SetHiMax         ; jump to skip the rest of this
      Branch exit: Line 7643: SetHiMax: LDA #$03              ; set maximum speed in A

Function DrawPlayer_Intermediate
  Inputs: []
  Outputs: []
      Line 14538: DrawPlayer_Intermediate: 
        Line 14540: PIntLoop: LDA IntermediatePlayerData,X; load data to display player as he always
          Branch exit: Line 14540: PIntLoop: LDA IntermediatePlayerData,X; load data to display player as he always
          Line 14544: LDX #$b8                        ; load offset for small standing

Function KillAllEnemies
  Inputs: [A]
  Outputs: []
  Line 10141: KillAllEnemies: 
    Line 10143: KillLoop: JSR EraseEnemyObject  ; branch to kill enemy objects
      Branch exit: Line 10143: KillLoop: JSR EraseEnemyObject  ; branch to kill enemy objects
      Line 10146: STA EnemyFrenzyBuffer           ; empty frenzy buffer


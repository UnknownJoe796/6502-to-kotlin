Function ChkForBump_HammerBroJ
  Inputs: [X]
  Outputs: []
  Line 12617: ChkForBump_HammerBroJ: 
    Branch exit: Line 12625: NoBump: LDA Enemy_ID,X          ; check for hammer bro
    Line 12620: LDA Enemy_State,X               ; if enemy state d7 not set, branch
      Branch exit: Line 12625: NoBump: LDA Enemy_ID,X          ; check for hammer bro
      Line 12623: LDA #Sfx_Bump                   ; otherwise, play bump sound
    Line 12625: NoBump: LDA Enemy_ID,X          ; check for hammer bro
      Branch exit: Line 12633: InvEnemyDir: 
      Line 12628: LDA #$00
        Branch exit: Line 9264: SetHJ: STY Enemy_Y_Speed,X      ; set vertical speed for jumping

Function PlayerDeath
  Inputs: []
  Outputs: []
    Line 5770: PlayerDeath: 
      Branch exit: Line 5809: ExitDeath: 
      Line 5774: JMP PlayerCtrlRoutine           ; otherwise run player control routine
        Branch exit: Line 5562: PlayerCtrlRoutine: 

Function UpdateTopScore
  Inputs: []
  Outputs: []
    Line 2613: UpdateTopScore: 
      Line 2618: TopScoreCheck:  (as a call, not in function)

Function ChkForNonSolids
  Inputs: [A]
  Outputs: [ZeroFlag]
    Line 12716: ChkForNonSolids: 
      Branch exit: Line 12726: NSFnd: RTS 
      Line 12719: CMP #$c2                        ; regular coin?
        Branch exit: Line 12726: NSFnd: RTS 
        Line 12721: CMP #$c3                        ; underwater coin?
          Branch exit: Line 12726: NSFnd: RTS 
          Line 12723: CMP #$5f                        ; hidden coin block?
            Branch exit: Line 12726: NSFnd: RTS 
            Line 12725: CMP #$60                        ; hidden 1-up block?
      Line 12726: NSFnd: RTS 

Function ChkLrgObjLength
  Inputs: [X]
  Outputs: [Y]
    Line 4279: ChkLrgObjLength: 
      Line 4282: ChkLrgObjFixedLength:  (as a call, not in function)

Function BulletBillCannon
  Inputs: [$07, Y, X]
  Outputs: []
    Line 4099: BulletBillCannon: 
      Branch exit: Line 4114: SetupCannon: LDX Cannon_Offset  ; get offset for data used by cannons and whirlpools
      Line 4107: LDA #$65                        ; if not, render middle part
        Branch exit: Line 4114: SetupCannon: LDX Cannon_Offset  ; get offset for data used by cannons and whirlpools
        Line 4112: LDA #$66                        ; if not, render bottom until length expires
      Line 4114: SetupCannon: LDX Cannon_Offset  ; get offset for data used by cannons and whirlpools
        Branch exit: Line 4125: StrCOffset: STX Cannon_Offset   ; save new offset and leave
        Line 4124: LDX #$00                        ; otherwise initialize it
        Line 4125: StrCOffset: STX Cannon_Offset   ; save new offset and leave

Function LargeLiftUp
  Inputs: [X]
  Outputs: []
    Line 8948: LargeLiftUp: 
      Branch exit: Line 8955: LargeLiftBBox: 

Function TitleScreenMode
  Inputs: []
  Outputs: []
    Line 956: TitleScreenMode: 
      Line 959: 
        Line 967: WSelectBufferTemplate: 
          Line 970: GameMenuRoutine:  (as a call, not in function)

Function SecondaryGameSetup
  Inputs: []
  Outputs: []
      Line 2729: SecondaryGameSetup: 
        Line 2733: ClearVRLoop: STA VRAM_Buffer1-1,Y; clear buffer at $0300-$03ff
          Branch exit: Line 2733: ClearVRLoop: STA VRAM_Buffer1-1,Y; clear buffer at $0300-$03ff
          Line 2736: STA GameTimerExpiredFlag        ; clear game timer exp flag
            Line 2754: ShufAmtLoop: LDA DefaultSprOffsets,X
              Branch exit: Line 2754: ShufAmtLoop: LDA DefaultSprOffsets,X
              Line 2758: LDY #$03                        ; set up sprite #0
                Line 2759: ISpr0Loop: LDA Sprite0Data,Y
                  Branch exit: Line 2759: ISpr0Loop: LDA Sprite0Data,Y
                  Line 2763: JSR DoNothing2                  ; these jsrs doesn't do anything useful

Function GetObjRelativePosition
  Inputs: [X, Y]
  Outputs: []
    Line 14813: GetObjRelativePosition: 

Function ScreenRoutines
  Inputs: []
  Outputs: []
    Line 1360: ScreenRoutines: 
      Line 1363: 
        Line 1382: InitScreen:  (as a call, not in function)

Function FlagBalls_Residual
  Inputs: [X]
  Outputs: []
    Line 3962: FlagBalls_Residual: 
      Branch exit: Line 4252: RenderUnderPart: 

Function DrawHammer
  Inputs: [X]
  Outputs: []
                  Line 13203: DrawHammer: 
                    Branch exit: Line 13211: ForceHPose: LDX #$00            ; reset offset here
                    Line 13207: LDA Misc_State,X                ; otherwise get hammer's state
                      Branch exit: Line 13213: GetHPose: LDA FrameCounter      ; get frame counter
                    Line 13211: ForceHPose: LDX #$00            ; reset offset here
                      Branch exit: Line 13218: RenderH: LDA Misc_Rel_YPos      ; get relative vertical coordinate
                    Line 13213: GetHPose: LDA FrameCounter      ; get frame counter
                    Line 13218: RenderH: LDA Misc_Rel_YPos      ; get relative vertical coordinate
                      Branch exit: Line 13247: NoHOffscr: RTS                  ; leave
                      Line 13243: LDA #$00
                      Line 13247: NoHOffscr: RTS                  ; leave

Function GetBlockBufferAddr
  Inputs: [A]
  Outputs: []
      Line 4332: GetBlockBufferAddr: 

Function PositionPlayerOnHPlat
  Inputs: [$00]
  Outputs: []
        Line 10938: PositionPlayerOnHPlat: 
          Branch exit: Line 10948: PPHSubt: SBC #$00               ; subtract borrow from page location
          Line 10946: ADC #$00                        ; otherwise add carry to page location
            Branch exit: Line 10949: SetPVar: STA Player_PageLoc     ; save result to player's page location
          Line 10948: PPHSubt: SBC #$00               ; subtract borrow from page location
          Line 10949: SetPVar: STA Player_PageLoc     ; save result to player's page location (as a call, not in function)

Function SetupFloateyNumber
  Inputs: [A, X]
  Outputs: []
    Line 11537: SetupFloateyNumber: 

Function GetXPhy
  Inputs: [Y, $00]
  Outputs: []
    Line 6174: GetXPhy: LDA MaxLeftXSpdData,Y  ; get maximum speed to the left
      Branch exit: Line 6180: GetXPhy2: LDA MaxRightXSpdData,Y; get maximum speed to the right
      Line 6179: LDY #$03                        ; otherwise set Y to 3
      Line 6180: GetXPhy2: LDA MaxRightXSpdData,Y; get maximum speed to the right
        Branch exit: Line 6192: ExitPhy: RTS                    ; and then leave
        Line 6190: ASL FrictionAdderLow            ; otherwise shift d7 of friction adder low into carry
        Line 6192: ExitPhy: RTS                    ; and then leave

Function DrawExplosion_Fireball
  Inputs: [X]
  Outputs: []
  Line 14262: DrawExplosion_Fireball: 
    Branch exit: Line 14306: KillFireBall: 
    Line 14270: 
      Line 14271: DrawExplosion_Fireworks:  (as a call, not in function)

Function GetOffScreenBitsSet
  Inputs: [Y, $00, X]
  Outputs: []
  Line 14873: GetOffScreenBitsSet: 

Function InitFireworks
  Inputs: [X]
  Outputs: []
        Line 8638: InitFireworks: 
          Branch exit: Line 8676: ExitFWk: RTS 
          Line 8641: LDA #$20                        ; otherwise reset timer
            Line 8645: StarFChk: DEY 
              Branch exit: Line 8645: StarFChk: DEY 
              Line 8649: LDA Enemy_X_Position,Y
          Line 8676: ExitFWk: RTS 

Function ChkJumpspringMetatiles
  Inputs: [A]
  Outputs: [CarryFlag]
    Line 12265: ChkJumpspringMetatiles: 
      Branch exit: Line 12271: JSFnd: SEC                      ; set carry if found
      Line 12268: CMP #$68                        ; check for bottom jumpspring metatile
        Branch exit: Line 12272: NoJSFnd: RTS                    ; leave
      Line 12271: JSFnd: SEC                      ; set carry if found
      Line 12272: NoJSFnd: RTS                    ; leave

Function EmptySfx2Buffer
  Inputs: []
  Outputs: []
  Line 15423: EmptySfx2Buffer: 
    Line 15427: StopSquare2Sfx:  (as a call, not in function)

Function SetupVictoryMode
  Inputs: []
  Outputs: []
        Line 1133: SetupVictoryMode: 
          Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode

Function Inc2B
  Inputs: []
  Outputs: []
  Line 8052: Inc2B: INC EnemyDataOffset      ; otherwise increment two bytes

Function MoveRedPTroopaUp
  Inputs: []
  Outputs: []
  Line 7619: MoveRedPTroopaUp: 

Function PlayerVictoryWalk
  Inputs: []
  Outputs: []
    Line 1143: PlayerVictoryWalk: 
      Branch exit: Line 1152: PerformWalk: INC VictoryWalkControl; otherwise increment value and Y
      Line 1149: LDA Player_X_Position           ; otherwise get player's horizontal position
        Branch exit: Line 1154: DontWalk: TYA                   ; put contents of Y in A and
      Line 1152: PerformWalk: INC VictoryWalkControl; otherwise increment value and Y
      Line 1154: DontWalk: TYA                   ; put contents of Y in A and
        Branch exit: Line 1169: ExitVWalk: LDA VictoryWalkControl; load value set here
        Line 1159: LDA ScrollFractional
        Line 1169: ExitVWalk: LDA VictoryWalkControl; load value set here
          Branch exit: Line 1225: IncModeTask_A: INC OperMode_Task; move onto next task in mode
          Line 1171: RTS                             ; otherwise leave

Function InitFlyingCheepCheep
  Inputs: [X]
  Outputs: []
          Line 8423: InitFlyingCheepCheep: 
            Branch exit: Line 8369: ChpChpEx: RTS 
            Line 8426: JSR SmallBBox                   ; jump to set bounding box size $09 and init other values
              Branch exit: Line 8436: MaxCC: STY $00                  ; store whatever pseudorandom bits are in Y
              Line 8435: INY                             ; otherwise, increment Y to allow as many as four onscreen
              Line 8436: MaxCC: STY $00                  ; store whatever pseudorandom bits are in Y
                Branch exit: Line 8369: ChpChpEx: RTS 
                Line 8439: LDA PseudoRandomBitReg,X
                  Branch exit: Line 8452: GSeed: PHA                      ; save to stack
                  Line 8448: LDA #$04
                    Branch exit: Line 8452: GSeed: PHA                      ; save to stack
                    Line 8451: ASL                             ; otherwise, multiply A by 2
                  Line 8452: GSeed: PHA                      ; save to stack
                    Branch exit: Line 8462: RSeed: PLA                      ; get value from stack we saved earlier
                    Line 8459: LDA PseudoRandomBitReg+2,X
                    Line 8462: RSeed: PLA                      ; get value from stack we saved earlier
                      Branch exit: Line 8482: D2XPos1: TYA                    ; get first LSFR or third LSFR lower nybble again
                      Line 8472: LDY $00                         ; get first LSFR or third LSFR lower nybble
                        Branch exit: Line 8482: D2XPos1: TYA                    ; get first LSFR or third LSFR lower nybble again
                        Line 8476: LDA Enemy_X_Speed,X
                      Line 8482: D2XPos1: TYA                    ; get first LSFR or third LSFR lower nybble again
                        Branch exit: Line 8492: D2XPos2: LDA Player_X_Position  ; get player's horizontal position
                        Line 8485: LDA Player_X_Position           ; get player's horizontal position
                          Branch exit: Line 8498: FinCCSt: STA Enemy_PageLoc,X    ; save as enemy's page location
                        Line 8492: D2XPos2: LDA Player_X_Position  ; get player's horizontal position
                        Line 8498: FinCCSt: STA Enemy_PageLoc,X    ; save as enemy's page location (as a call, not in function)

Function DemoEngine
  Inputs: []
  Outputs: [CarryFlag]
        Line 1093: DemoEngine: 
          Branch exit: Line 1103: DoAction: LDA DemoActionData-1,X; get and perform action (current or next)
          Line 1097: INX 
            Branch exit: Line 1107: DemoOver: RTS 
          Line 1103: DoAction: LDA DemoActionData-1,X; get and perform action (current or next)
          Line 1107: DemoOver: RTS 

Function GameMenuRoutine
  Inputs: []
  Outputs: []
          Line 970: GameMenuRoutine: 
            Branch exit: Line 978: StartGame: JMP ChkContinue      ; if either start or A + start, execute here
            Line 976: CMP #A_Button+Start_Button      ; check to see if A + start was pressed
              Branch exit: Line 979: ChkSelect: CMP #Select_Button   ; check to see if the select button was pressed
              Line 979: ChkSelect: CMP #Select_Button   ; check to see if the select button was pressed
                Branch exit: Line 992: SelectBLogic: LDA DemoTimer     ; if select or B pressed, check demo timer one last time
                Line 981: LDX DemoTimer                   ; otherwise check demo timer
                  Branch exit: Line 987: ChkWorldSel: LDX WorldSelectEnableFlag; check to see if world selection has been enabled
                  Line 983: STA SelectTimer                 ; set controller bits here if running demo
                    Branch exit: Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
                    Line 986: JMP RunDemo                     ; otherwise, run game engine for demo
                      Branch exit: Line 1023: RunDemo: JSR GameCoreRoutine    ; run game engine
                  Line 987: ChkWorldSel: LDX WorldSelectEnableFlag; check to see if world selection has been enabled
                    Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                    Line 989: CMP #B_Button                   ; if so, check to see if the B button was pressed
                      Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                      Line 991: INY                             ; if so, increment Y and execute same code as select
                Line 992: SelectBLogic: LDA DemoTimer     ; if select or B pressed, check demo timer one last time
                  Branch exit: Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
                  Line 994: LDA #$18                        ; otherwise reset demo timer
                    Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                    Line 998: LDA #$10                        ; otherwise reset select button timer
                      Branch exit: Line 1007: IncWorldSel: LDX WorldSelectNumber; increment world select number
                      Line 1002: LDA NumberOfPlayers             ; if no, must have been the select button, therefore
                        Branch exit: Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1
                      Line 1007: IncWorldSel: LDX WorldSelectNumber; increment world select number
                        Line 1013: UpdateShroom: LDA WSelectBufferTemplate,X; write template for world select in vram buffer
                          Branch exit: Line 1013: UpdateShroom: LDA WSelectBufferTemplate,X; write template for world select in vram buffer
                          Line 1018: LDY WorldNumber                 ; get world number from variable and increment for
                Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1 (as a call, not in function)
                Line 1023: RunDemo: JSR GameCoreRoutine    ; run game engine (as a call, not in function)
            Line 978: StartGame: JMP ChkContinue      ; if either start or A + start, execute here
              Branch exit: Line 1033: ChkContinue: LDY DemoTimer      ; if timer for demo has expired, reset modes
              Line 1033: ChkContinue: LDY DemoTimer      ; if timer for demo has expired, reset modes (as a call, not in function)
            Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable (as a call, not in function)
            Line 1054: ExitMenu: RTS  (as a call, not in function)

Function NoiseSfxHandler
  Inputs: []
  Outputs: []
    Line 15579: NoiseSfxHandler: 
      Branch exit: Line 15588: CheckNoiseBuffer: 
      Line 15582: STY NoiseSoundBuffer            ; if found, put in buffer
        Branch exit: Line 15552: PlayBrickShatter: 
        Line 15585: LSR NoiseSoundQueue
          Branch exit: Line 15597: PlayBowserFlame: 
          Line 15587: 
      Line 15588: CheckNoiseBuffer: 
        Branch exit: Line 15595: ExNH: RTS 
        Line 15591: LSR 
          Branch exit: Line 15556: ContinueBrickShatter: 
          Line 15593: LSR 
            Branch exit: Line 15601: ContinueBowserFlame: 
        Line 15595: ExNH: RTS 

Function MiscLoopBack
  Inputs: [X]
  Outputs: []
  Line 7072: MiscLoopBack: 
    Branch exit: Line 7019: MiscLoop: STX ObjectOffset      ; store misc object offset here
    Line 7075: RTS                             ; then leave

Function LoadEventMusic
  Inputs: [A]
  Outputs: []
  Line 15624: LoadEventMusic: 
    Branch exit: Line 15630: NoStopSfx: LDX AreaMusicBuffer
    Line 15628: JSR StopSquare1Sfx              ; stop sfx in square 1 and 2
    Line 15630: NoStopSfx: LDX AreaMusicBuffer
      Branch exit: Line 15665: FindEventMusicHeader: 
      Line 15637: LDX #$08                        ; load offset to be added to length byte of header
        Branch exit: Line 15665: FindEventMusicHeader: 
        Line 15640: 

Function ContinueGame
  Inputs: [A]
  Outputs: []
  Line 2994: ContinueGame: 

Function Hole_Water
  Inputs: [X]
  Outputs: []
    Line 3912: Hole_Water: 
      Branch exit: Line 4252: RenderUnderPart: 

Function X_Physics
  Inputs: []
  Outputs: []
  Line 6143: X_Physics: LDY #$00
    Branch exit: Line 6151: ProcPRun: INY                   ; if mario on the ground, increment Y
    Line 6147: LDA Player_XSpeedAbsolute       ; check something that seems to be related
      Branch exit: Line 6174: GetXPhy: LDA MaxLeftXSpdData,Y  ; get maximum speed to the left
      Line 6150: BCC ChkRFast                    ; if not branch elsewhere
        Branch exit: Line 6163: ChkRFast: INY                   ; if running timer not set or level type is water,
    Line 6151: ProcPRun: INY                   ; if mario on the ground, increment Y
      Branch exit: Line 6163: ChkRFast: INY                   ; if running timer not set or level type is water,
      Line 6154: DEY                             ; decrement Y by default for non-water type area
        Branch exit: Line 6163: ChkRFast: INY                   ; if running timer not set or level type is water,
        Line 6158: LDA A_B_Buttons                 ; check for b button pressed
          Branch exit: Line 6172: SetRTmr: LDA #$0a               ; if b button pressed, set running timer
          Line 6161: LDA RunningTimer                ; check for running timer set
            Branch exit: Line 6174: GetXPhy: LDA MaxLeftXSpdData,Y  ; get maximum speed to the left
          Line 6172: SetRTmr: LDA #$0a               ; if b button pressed, set running timer
    Line 6163: ChkRFast: INY                   ; if running timer not set or level type is water,
      Branch exit: Line 6170: FastXSp: INC $00                ; if running speed set or speed => $21 increment $00
      Line 6167: LDA Player_XSpeedAbsolute
        Branch exit: Line 6174: GetXPhy: LDA MaxLeftXSpdData,Y  ; get maximum speed to the left
      Line 6170: FastXSp: INC $00                ; if running speed set or speed => $21 increment $00
        Branch exit: Line 6174: GetXPhy: LDA MaxLeftXSpdData,Y  ; get maximum speed to the left
    Line 6174: GetXPhy: LDA MaxLeftXSpdData,Y  ; get maximum speed to the left (as a call, not in function)

Function RenderUnderPart
  Inputs: [Y, X, A]
  Outputs: []
  Line 4252: RenderUnderPart: 
    Branch exit: Line 4268: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
    Line 4256: CPY #$17
      Branch exit: Line 4269: WaitOneRow: INX 
      Line 4258: CPY #$1a
        Branch exit: Line 4269: WaitOneRow: INX 
        Line 4260: CPY #$c0
          Branch exit: Line 4268: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
          Line 4262: CPY #$c0
            Branch exit: Line 4269: WaitOneRow: INX 
            Line 4264: CPY #$54
              Branch exit: Line 4268: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
              Line 4266: CMP #$50
                Branch exit: Line 4269: WaitOneRow: INX 
    Line 4268: DrawThisRow: STA MetatileBuffer,X; render contents of A from routine that called this
    Line 4269: WaitOneRow: INX 
      Branch exit: Line 4275: ExitUPartR: RTS 
      Line 4272: LDY AreaObjectHeight            ; decrement, and stop rendering if there is no more length
        Branch exit: Line 4252: RenderUnderPart: 
      Line 4275: ExitUPartR: RTS 

Function CommonSmallLift
  Inputs: [X]
  Outputs: []
  Line 8977: CommonSmallLift: 

Function ExecGameLoopback
  Inputs: [Y]
  Outputs: []
          Line 7800: ExecGameLoopback: 

Function MoveESprColOffscreen
  Inputs: [A, X]
  Outputs: []
    Line 14083: MoveESprColOffscreen: 

Function FourFrameExtent
  Inputs: []
  Outputs: []
  Line 14659: FourFrameExtent: 
    Branch exit: Line 14666: AnimationControl: 

Function JumpSwimSub
  Inputs: []
  Outputs: []
    Line 5926: JumpSwimSub: 
      Branch exit: Line 5938: DumpFall: LDA VerticalForceDown ; otherwise dump falling into main fractional
      Line 5929: LDA A_B_Buttons
        Branch exit: Line 5940: ProcSwim: LDA SwimmingFlag      ; if swimming flag not set,
        Line 5933: LDA JumpOrigin_Y_Position       ; get vertical position player jumped from
          Branch exit: Line 5940: ProcSwim: LDA SwimmingFlag      ; if swimming flag not set,
      Line 5938: DumpFall: LDA VerticalForceDown ; otherwise dump falling into main fractional
      Line 5940: ProcSwim: LDA SwimmingFlag      ; if swimming flag not set,
        Branch exit: Line 5951: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)
        Line 5942: JSR GetPlayerAnimSpeed          ; do a sub to get animation frame timing
          Branch exit: Line 5948: LRWater: LDA Left_Right_Buttons ; check left/right controller bits (check for swimming)
          Line 5946: LDA #$18
          Line 5948: LRWater: LDA Left_Right_Buttons ; check left/right controller bits (check for swimming)
            Branch exit: Line 5951: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)
            Line 5950: STA PlayerFacingDir             ; otherwise set facing direction accordingly

Function BrickWithCoins
  Inputs: []
  Outputs: []
    Line 4187: BrickWithCoins: 

Function AutoControlPlayer
  Inputs: [A]
  Outputs: []
  Line 5559: AutoControlPlayer: 

Function SaveAB
  Inputs: []
  Outputs: []
        Line 5360: SaveAB: LDA A_B_Buttons         ; save current A and B button
          Line 5364: UpdScrollVar: LDA VRAM_Buffer_AddrCtrl (as a call, not in function)

Function ProcessWhirlpools
  Inputs: []
  Outputs: []
    Line 6498: ProcessWhirlpools: 
      Branch exit: Line 6527: ExitWh: RTS                     ; leave
      Line 6501: STA Whirlpool_Flag              ; otherwise initialize whirlpool flag
        Branch exit: Line 6527: ExitWh: RTS                     ; leave
        Line 6504: LDY #$04                        ; otherwise start with last whirlpool data
          Line 6505: WhLoop: LDA Whirlpool_LeftExtent,Y; get left extent of whirlpool
            Branch exit: Line 6525: NextWh: DEY                     ; move onto next whirlpool data
            Line 6511: ADC #$00                        ; add carry
              Branch exit: Line 6525: NextWh: DEY                     ; move onto next whirlpool data
              Line 6519: LDA $02                         ; otherwise get right extent
                Branch exit: Line 6529: WhirlpoolActivate: 
            Line 6525: NextWh: DEY                     ; move onto next whirlpool data
              Branch exit: Line 6505: WhLoop: LDA Whirlpool_LeftExtent,Y; get left extent of whirlpool
      Line 6527: ExitWh: RTS                     ; leave

Function CommonPlatCode
  Inputs: [X]
  Outputs: []
  Line 8934: CommonPlatCode: 

Function NoRunCode
  Inputs: []
  Outputs: []
        Line 9059: NoRunCode: 

Function ProcSwimmingB
  Inputs: [X]
  Outputs: []
    Line 9524: ProcSwimmingB: 
      Branch exit: Line 9560: ChkForFloatdown: 
      Line 9528: LDA FrameCounter
        Branch exit: Line 9546: SlowSwim: 
        Line 9534: PLA                             ; pull 3 LSB of frame counter from the stack
          Branch exit: Line 9544: BSwimE: RTS 
          Line 9536: LDA Enemy_Y_MoveForce,X
            Branch exit: Line 9544: BSwimE: RTS 
            Line 9543: INC BlooperMoveCounter,X        ; otherwise increment movement counter
          Line 9544: BSwimE: RTS 

Function ScrollHandler
  Inputs: []
  Outputs: []
    Line 5382: ScrollHandler: 
      Branch exit: Line 5430: InitScrlAmt: LDA #$00
      Line 5389: LDA Player_Pos_ForScroll
        Branch exit: Line 5430: InitScrlAmt: LDA #$00
        Line 5392: LDA SideCollisionTimer          ; if timer related to player's side collision
          Branch exit: Line 5430: InitScrlAmt: LDA #$00
          Line 5394: LDY Player_X_Scroll             ; get value and decrement by one
            Branch exit: Line 5430: InitScrlAmt: LDA #$00
            Line 5397: INY 
              Branch exit: Line 5401: ChkNearMid: LDA Player_Pos_ForScroll
              Line 5400: DEY                             ; otherwise decrement by one
              Line 5401: ChkNearMid: LDA Player_Pos_ForScroll
                Branch exit: Line 5406: ScrollScreen: 
                Line 5404: LDY Player_X_Scroll             ; otherwise get original value undecremented
                Line 5406: ScrollScreen:  (as a call, not in function)
      Line 5430: InitScrlAmt: LDA #$00
      Line 5432: ChkPOffscr: LDX #$00            ; set X for player offset (as a call, not in function)

Function LargeLiftDown
  Inputs: [X]
  Outputs: []
    Line 8952: LargeLiftDown: 

Function SetupGameOver
  Inputs: []
  Outputs: []
        Line 2960: SetupGameOver: 

Function ChainObj
  Inputs: [$00]
  Outputs: []
  Line 4043: ChainObj: 
    Branch exit: Line 4053: ColObj: LDY #$00                ; column length of 1

Function MovePlayerHorizontally
  Inputs: []
  Outputs: [A]
    Line 7540: MovePlayerHorizontally: 
      Branch exit: Line 7583: ExXMove: RTS                    ; and leave
      Line 7543: TAX                             ; otherwise set zero for offset to use player's stuff
        Line 7545: MoveObjectHorizontally:  (as a call, not in function)

Function HammerChk
  Inputs: [X]
  Outputs: []
      Line 10219: HammerChk: LDA EnemyFrameTimer,X; if timer set here not expired yet, skip ahead to
        Branch exit: Line 10238: MakeBJump: CMP #$01             ; if timer not yet about to expire,
        Line 10221: JSR MoveEnemySlowVert           ; otherwise start by moving bowser downwards
          Branch exit: Line 10229: SetHmrTmr: LDA Enemy_Y_Position,X; get current vertical position
          Line 10225: LDA FrameCounter
            Branch exit: Line 10229: SetHmrTmr: LDA Enemy_Y_Position,X; get current vertical position
            Line 10228: JSR SpawnHammerObj              ; execute sub on every fourth frame to spawn misc object (hammer)
          Line 10229: SetHmrTmr: LDA Enemy_Y_Position,X; get current vertical position
            Branch exit: Line 10244: ChkFireB: LDA WorldNumber       ; check world number here
            Line 10232: LDA PseudoRandomBitReg,X
        Line 10238: MakeBJump: CMP #$01             ; if timer not yet about to expire,
          Branch exit: Line 10244: ChkFireB: LDA WorldNumber       ; check world number here
          Line 10240: DEC Enemy_Y_Position,X          ; otherwise decrement vertical coordinate

Function DrawRope
  Inputs: []
  Outputs: []
  Line 4013: DrawRope: LDA #$40              ; render the actual rope
    Branch exit: Line 4252: RenderUnderPart: 

Function SetStun
  Inputs: [X]
  Outputs: []
          Line 12470: SetStun: LDA Enemy_State,X      ; load enemy state
            Branch exit: Line 12482: SetWYSpd: LDA #$ff              ; change the vertical speed
            Line 12479: LDA #$fd                        ; set default vertical speed
              Branch exit: Line 12483: SetNotW: STA Enemy_Y_Speed,X    ; set vertical speed now
            Line 12482: SetWYSpd: LDA #$ff              ; change the vertical speed
            Line 12483: SetNotW: STA Enemy_Y_Speed,X    ; set vertical speed now
              Branch exit: Line 12488: ChkBBill: LDA Enemy_ID,X
              Line 12487: INY                             ; increment Y if not
              Line 12488: ChkBBill: LDA Enemy_ID,X
                Branch exit: Line 12494: NoCDirF: DEY                    ; decrement and use as offset
                Line 12491: CMP #BulletBill_FrenzyVar       ; check for bullet bill (frenzy variant)
                  Branch exit: Line 12494: NoCDirF: DEY                    ; decrement and use as offset
                  Line 12493: STY Enemy_MovingDir,X           ; store as moving direction
                Line 12494: NoCDirF: DEY                    ; decrement and use as offset

Function InitPlatformFall
  Inputs: [Y]
  Outputs: []
  Line 10864: InitPlatformFall: 

Function PlatformFall
  Inputs: [Y]
  Outputs: []
  Line 10883: PlatformFall: 
    Branch exit: Line 10895: ExPF: LDX ObjectOffset          ; get enemy object buffer offset and leave
    Line 10893: TAX                             ; transfer collision flag offset as offset to X
    Line 10895: ExPF: LDX ObjectOffset          ; get enemy object buffer offset and leave

Function GetPlayerColors
  Inputs: []
  Outputs: []
              Line 1441: GetPlayerColors: 
                Branch exit: Line 1447: ChkFiery: LDA PlayerStatus      ; check player status
                Line 1446: LDY #$04                        ; load offset for luigi
                Line 1447: ChkFiery: LDA PlayerStatus      ; check player status
                  Branch exit: Line 1451: StartClrGet: LDA #$03           ; do four colors
                  Line 1450: LDY #$08
                  Line 1451: StartClrGet: LDA #$03           ; do four colors
                    Line 1453: ClrGetLoop: LDA PlayerColors,Y  ; fetch player colors and store them
                      Branch exit: Line 1453: ClrGetLoop: LDA PlayerColors,Y  ; fetch player colors and store them
                      Line 1459: LDX VRAM_Buffer1_Offset         ; load original offset from before
                        Branch exit: Line 1463: SetBGColor: LDA BackgroundColors,Y; to background color instead
                        Line 1462: LDY AreaType                    ; otherwise use area type bits from area offset as offset
                        Line 1463: SetBGColor: LDA BackgroundColors,Y; to background color instead

Function DelayToAreaEnd
  Inputs: [X]
  Outputs: []
    Line 10568: DelayToAreaEnd: 
      Branch exit: Line 10575: StarFlagExit2: 
      Line 10572: LDA EventMusicBuffer            ; if event music buffer empty,
        Branch exit: Line 10564: IncrementSFTask2: 
        Line 10574: 
      Line 10575: StarFlagExit2: 

Function GetScreenPosition
  Inputs: []
  Outputs: [A]
        Line 5466: GetScreenPosition: 

Function ExJCGfx
  Inputs: []
  Outputs: []
  Line 13468: ExJCGfx: RTS                    ; leave

Function RelativeMiscPosition
  Inputs: [X]
  Outputs: []
    Line 14784: RelativeMiscPosition: 
      Branch exit: Line 14780: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function Hidden1UpBlock
  Inputs: []
  Outputs: []
    Line 4176: Hidden1UpBlock: 
      Branch exit: Line 4212: ExitDecBlock: RTS 
      Line 4179: LDA #$00                        ; if set, init for the next one
        Branch exit: Line 4191: BrickWithItem: 

Function ChkFOfs
  Inputs: [A, Y, $02, $05]
  Outputs: []
        Line 9784: ChkFOfs: CMP #$59               ; if difference of coordinates within a certain range,
          Branch exit: Line 9788: VAHandl: LDA Enemy_Rel_YPos     ; if vertical relative coordinate offscreen,
          Line 9786: LDA #$f8                        ; otherwise, load offscreen Y coordinate
            Branch exit: Line 9798: SetVFbr: STA Sprite_Y_Position,Y; store as Y coordinate here
          Line 9788: VAHandl: LDA Enemy_Rel_YPos     ; if vertical relative coordinate offscreen,
            Branch exit: Line 9798: SetVFbr: STA Sprite_Y_Position,Y; store as Y coordinate here
            Line 9791: LDA $02                         ; load vertical adder we got from position loader
              Branch exit: Line 9796: AddVA: CLC                      ; add vertical coordinate relative to screen to
              Line 9794: EOR #$ff
              Line 9796: AddVA: CLC                      ; add vertical coordinate relative to screen to
          Line 9798: SetVFbr: STA Sprite_Y_Position,Y; store as Y coordinate here
            Line 9801: FirebarCollision:  (as a call, not in function)

Function AreaStyleObject
  Inputs: []
  Outputs: []
    Line 3625: AreaStyleObject: 
      Line 3628: .db TreeLedge,                  ; also used for cloud type levels
        Line 3632: TreeLedge:  (as a call, not in function)

Function DrawRow
  Inputs: [$07]
  Outputs: []
  Line 4078: DrawRow: LDX $07
    Branch exit: Line 4252: RenderUnderPart: 

Function UpdateNumber
  Inputs: [A]
  Outputs: []
  Line 7117: UpdateNumber: 
    Branch exit: Line 7124: NoZSup: LDX ObjectOffset        ; get enemy object buffer offset
    Line 7122: LDA #$24
    Line 7124: NoZSup: LDX ObjectOffset        ; get enemy object buffer offset

Function PulleyRopeObject
  Inputs: [CarryFlag, X]
  Outputs: []
      Line 3688: PulleyRopeObject: 
        Branch exit: Line 3696: RenderPul: LDA PulleyRopeMetatiles,Y
        Line 3692: INY 
          Branch exit: Line 3696: RenderPul: LDA PulleyRopeMetatiles,Y
          Line 3695: INY                             ; otherwise render right pulley
        Line 3696: RenderPul: LDA PulleyRopeMetatiles,Y

Function MusicHandler
  Inputs: []
  Outputs: []
    Line 15614: MusicHandler: 
      Branch exit: Line 15624: LoadEventMusic: 
      Line 15617: LDA AreaMusicQueue              ; check area music queue
        Branch exit: Line 15641: LoadAreaMusic: 
        Line 15619: LDA EventMusicBuffer            ; check both buffers
          Branch exit: Line 15611: ContinueMusic: 
          Line 15622: RTS                             ; no music, then leave

Function TallBBox
  Inputs: []
  Outputs: []
  Line 8227: TallBBox: LDA #$03              ; set specific bounding box size control

Function InitializeNameTables
  Inputs: []
  Outputs: []
    Line 2386: InitializeNameTables: 
      Line 2395: WriteNTAddr: STA PPU_ADDRESS (as a call, not in function)

Function RunFireworks
  Inputs: [X]
  Outputs: []
    Line 10417: RunFireworks: 
      Branch exit: Line 10426: SetupExpl: JSR RelativeEnemyPosition; get relative coordinates of explosion
      Line 10420: LDA #$08
        Branch exit: Line 10436: FireworksSoundScore: 
      Line 10426: SetupExpl: JSR RelativeEnemyPosition; get relative coordinates of explosion

Function PrimaryGameSetup
  Inputs: []
  Outputs: []
    Line 2721: PrimaryGameSetup: 
      Line 2729: SecondaryGameSetup:  (as a call, not in function)

Function Inc3B
  Inputs: []
  Outputs: []
  Line 8051: Inc3B: INC EnemyDataOffset      ; if row = $0e, increment three bytes

Function MoveFallingPlatform
  Inputs: []
  Outputs: []
      Line 7609: MoveFallingPlatform: 

Function RenderPlayerSub
  Inputs: [A]
  Outputs: []
    Line 14566: RenderPlayerSub: 
      Line 14580: DrawPlayerLoop:  (as a call, not in function)

Function GetEnemyOffscreenBits
  Inputs: []
  Outputs: []
    Line 14858: GetEnemyOffscreenBits: 
      Branch exit: Line 14867: SetOffscrBitsOffset: 

Function RaiseFlagSetoffFWorks
  Inputs: [X]
  Outputs: []
    Line 10522: RaiseFlagSetoffFWorks: 
      Branch exit: Line 10528: SetoffF: LDA FireworksCounter   ; check fireworks counter
      Line 10526: DEC Enemy_Y_Position,X          ; otherwise, raise star flag by one pixel
        Branch exit: Line 10534: DrawStarFlag: 
      Line 10528: SetoffF: LDA FireworksCounter   ; check fireworks counter
        Branch exit: Line 10559: DrawFlagSetTimer: 
        Line 10530: BMI DrawFlagSetTimer            ; if no fireworks set to go off, skip this part
          Branch exit: Line 10559: DrawFlagSetTimer: 
          Line 10531: LDA #Fireworks
      Line 10534: DrawStarFlag:  (as a call, not in function)

Function ChkLrgObjFixedLength
  Inputs: [X, Y]
  Outputs: [CarryFlag]
      Line 4282: ChkLrgObjFixedLength: 
        Branch exit: Line 4289: LenSet: RTS 
        Line 4286: TYA                             ; save length into length counter
        Line 4289: LenSet: RTS 

Function RelativeBubblePosition
  Inputs: [X]
  Outputs: [X]
    Line 14770: RelativeBubblePosition: 
      Branch exit: Line 14780: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function EnemyJump
  Inputs: [CarryFlag, X]
  Outputs: []
  Line 12665: EnemyJump: 
    Branch exit: Line 12680: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
    Line 12668: LDA Enemy_Y_Speed,X
      Branch exit: Line 12680: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
      Line 12673: JSR ChkUnderEnemy               ; otherwise, check to see if green paratroopa is
        Branch exit: Line 12680: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
        Line 12675: JSR ChkForNonSolids             ; check for non-solid blocks
          Branch exit: Line 12680: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
          Line 12677: JSR EnemyLanding                ; change vertical coordinate and speed
    Line 12680: DoSide: JMP DoEnemySideCheck    ; check for horizontal blockage, then leave
      Branch exit: Line 12596: DoEnemySideCheck: 

Function RunFirebarObj
  Inputs: [X, $00, $03, $01]
  Outputs: []
    Line 9129: RunFirebarObj: 
      Branch exit: Line 11010: OffscreenBoundsCheck: 

Function EnemyMovementSubs
  Inputs: [X]
  Outputs: []
    Line 9086: EnemyMovementSubs: 
      Line 9089: 
        Line 9114: NoMoveCode:  (as a call, not in function)

Function ProcessBowserHalf
  Inputs: [X]
  Outputs: []
    Line 10302: ProcessBowserHalf: 
      Branch exit: Line 10300: ExBGfxH: RTS                    ; leave!
      Line 10307: LDA #$0a
        Branch exit: Line 11297: PlayerEnemyCollision: 

Function PlayerEndWorld
  Inputs: []
  Outputs: []
    Line 1230: PlayerEndWorld: 
      Branch exit: Line 1245: EndExitOne: RTS                 ; and leave
      Line 1233: LDY WorldNumber                 ; check world number
        Branch exit: Line 1246: EndChkBButton: LDA SavedJoypad1Bits
        Line 1236: LDA #$00
        Line 1246: EndChkBButton: LDA SavedJoypad1Bits
          Branch exit: Line 1255: EndExitTwo: RTS                 ; leave
          Line 1250: LDA #$01                        ; otherwise set world selection flag
          Line 1255: EndExitTwo: RTS                 ; leave

Function DrawSmallPlatform
  Inputs: [X]
  Outputs: []
    Line 14313: DrawSmallPlatform: 
      Branch exit: Line 14340: TopSP: JSR DumpThreeSpr         ; dump vertical coordinate into Y coordinates
      Line 14339: LDA #$f8                        ; otherwise move first three sprites offscreen
      Line 14340: TopSP: JSR DumpThreeSpr         ; dump vertical coordinate into Y coordinates
        Branch exit: Line 14348: BotSP: STA Sprite_Y_Position+12,Y; dump vertical coordinate + 128 pixels
        Line 14347: LDA #$f8                        ; otherwise move last three sprites offscreen
        Line 14348: BotSP: STA Sprite_Y_Position+12,Y; dump vertical coordinate + 128 pixels
          Branch exit: Line 14358: SOfs: PLA                       ; move out and back into stack
          Line 14355: LDA #$f8                        ; if d3 was set, move first and
          Line 14358: SOfs: PLA                       ; move out and back into stack
            Branch exit: Line 14365: SOfs2: PLA                      ; get from stack
            Line 14362: LDA #$f8                        ; if d2 was set, move second and
            Line 14365: SOfs2: PLA                      ; get from stack
              Branch exit: Line 14371: ExSPl: LDX ObjectOffset         ; get enemy object offset and leave
              Line 14368: LDA #$f8                        ; if d1 was set, move third and
              Line 14371: ExSPl: LDX ObjectOffset         ; get enemy object offset and leave

Function SetFreq_Squ2
  Inputs: [A]
  Outputs: [ZeroFlag]
      Line 15163: SetFreq_Squ2: 
        Branch exit: Line 15145: Dump_Freq_Regs: 
        Line 15166: 
          Line 15167: SetFreq_Tri:  (as a call, not in function)

Function RelativeBlockPosition
  Inputs: [X]
  Outputs: []
    Line 14795: RelativeBlockPosition: 

Function HandleGroupEnemies
  Inputs: [A]
  Outputs: []
  Line 8759: HandleGroupEnemies: 
    Branch exit: Line 8772: SnglID: STY $01                 ; save enemy id here
    Line 8766: PHA                             ; save another copy to stack
      Branch exit: Line 8771: PullID: PLA                     ; get second copy from stack
      Line 8770: LDY #BuzzyBeetle                ; for buzzy beetle
      Line 8771: PullID: PLA                     ; get second copy from stack
    Line 8772: SnglID: STY $01                 ; save enemy id here
      Branch exit: Line 8777: SetYGp: STY $00                 ; save y coordinate here
      Line 8776: LDY #$70                        ; otherwise branch and use default
      Line 8777: SetYGp: STY $00                 ; save y coordinate here
        Branch exit: Line 8787: CntGrp: STY NumberofGroupEnemies; save number of enemies here
        Line 8786: INY                             ; otherwise increment to three enemies
        Line 8787: CntGrp: STY NumberofGroupEnemies; save number of enemies here
          Line 8788: GrLoop: LDX #$ff                ; start at beginning of enemy buffers
            Line 8789: GSltLp: INX                     ; increment and branch if past
              Branch exit: Line 8814: NextED: JMP Inc2B               ; jump to increment data offset and leave
              Line 8792: LDA Enemy_Flag,X                ; check to see if enemy is already
                Branch exit: Line 8789: GSltLp: INX                     ; increment and branch if past
                Line 8794: LDA $01
                  Branch exit: Line 8788: GrLoop: LDX #$ff                ; start at beginning of enemy buffers
              Line 8814: NextED: JMP Inc2B               ; jump to increment data offset and leave
                Branch exit: Line 8052: Inc2B: INC EnemyDataOffset      ; otherwise increment two bytes

Function DrawFirebar_Collision
  Inputs: [$03, $06, $01]
  Outputs: []
    Line 9763: DrawFirebar_Collision: 
      Branch exit: Line 9772: AddHA: CLC                      ; add horizontal coordinate relative to screen to
      Line 9770: EOR #$ff
      Line 9772: AddHA: CLC                      ; add horizontal coordinate relative to screen to
        Branch exit: Line 9782: SubtR1: SEC                     ; subtract original X from the
        Line 9778: LDA Enemy_Rel_XPos
          Branch exit: Line 9784: ChkFOfs: CMP #$59               ; if difference of coordinates within a certain range,
        Line 9782: SubtR1: SEC                     ; subtract original X from the
        Line 9784: ChkFOfs: CMP #$59               ; if difference of coordinates within a certain range, (as a call, not in function)

Function NextArea
  Inputs: [A]
  Outputs: []
  Line 5867: NextArea: INC AreaNumber        ; increment area number used for address loader

Function QuestionBlockRow_High
  Inputs: [X]
  Outputs: []
    Line 3923: QuestionBlockRow_High: 
      Line 3927: QuestionBlockRow_Low:  (as a call, not in function)

Function CyclePlayerPalette
  Inputs: [A]
  Outputs: []
        Line 5791: CyclePlayerPalette: 

Function BlockBufferColli_Head
  Inputs: []
  Outputs: [ZeroFlag]
            Line 13049: BlockBufferColli_Head: 
              Line 13053: BlockBufferColli_Side:  (as a call, not in function)

Function InvOBit
  Inputs: []
  Outputs: []
                Line 7288: InvOBit: LDA SprDataOffset_Ctrl ; invert control bit used by block objects

Function AreaParserCore
  Inputs: []
  Outputs: []
                  Line 3158: AreaParserCore: 
                    Branch exit: Line 3163: RenderSceneryTerrain: 
                    Line 3161: JSR ProcessAreaData             ; otherwise skip ahead and load level data
                    Line 3163: RenderSceneryTerrain: 
                      Line 3166: ClrMTBuf: STA MetatileBuffer,X  ; clear out metatile buffer
                        Branch exit: Line 3166: ClrMTBuf: STA MetatileBuffer,X  ; clear out metatile buffer
                        Line 3169: LDY BackgroundScenery           ; do we need to render the background scenery?
                          Branch exit: Line 3210: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                          Line 3171: LDA CurrentPageLoc              ; otherwise check for every third page
                            Line 3172: ThirdP: CMP #$03
                              Branch exit: Line 3177: RendBack: ASL                   ; move results to higher nybble
                              Line 3174: SEC 
                                Branch exit: Line 3172: ThirdP: CMP #$03
                              Line 3177: RendBack: ASL                   ; move results to higher nybble
                                Branch exit: Line 3210: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                                Line 3186: PHA 
                                  Line 3202: SceLoop1: LDA BackSceneryMetatiles,X; load metatile data from offset of (lsb - 1) * 3
                                    Branch exit: Line 3210: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                                    Line 3208: DEC $00                         ; decrement until counter expires, barring exception
                                      Branch exit: Line 3202: SceLoop1: LDA BackSceneryMetatiles,X; load metatile data from offset of (lsb - 1) * 3
                          Line 3210: RendFore: LDX ForegroundScenery ; check for foreground data needed or not
                            Branch exit: Line 3221: RendTerr: LDY AreaType          ; check world type for water level
                            Line 3212: LDY FSceneDataOffsets-1,X       ; load offset from location offset by header value, then
                              Line 3214: SceLoop2: LDA ForeSceneryData,Y ; load data until counter expires
                                Branch exit: Line 3217: NoFore: INY 
                                Line 3216: STA MetatileBuffer,X
                                Line 3217: NoFore: INY 
                                  Branch exit: Line 3214: SceLoop2: LDA ForeSceneryData,Y ; load data until counter expires
                            Line 3221: RendTerr: LDY AreaType          ; check world type for water level
                              Branch exit: Line 3228: TerMTile: LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type
                              Line 3223: LDA WorldNumber                 ; check world number, if not world number eight
                                Branch exit: Line 3228: TerMTile: LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type
                                Line 3226: LDA #$62                        ; if set as water level and world number eight,
                                  Branch exit: Line 3232: StoreMT: STA $07                ; store value here
                              Line 3228: TerMTile: LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type
                                Branch exit: Line 3232: StoreMT: STA $07                ; store value here
                                Line 3231: LDA #$88                        ; use cloud block terrain
                              Line 3232: StoreMT: STA $07                ; store value here (as a call, not in function)

Function DrawBlock
  Inputs: [X]
  Outputs: []
      Line 14101: DrawBlock: 
        Line 14112: DBlkLoop: LDA DefaultBlockObjTiles,X; get left tile number
          Branch exit: Line 14112: DBlkLoop: LDA DefaultBlockObjTiles,X; get left tile number
          Line 14118: LDX ObjectOffset                ; get block object offset
            Branch exit: Line 14126: ChkRep: LDA Block_Metatile,X    ; check replacement metatile
            Line 14123: LDA #$86
            Line 14126: ChkRep: LDA Block_Metatile,X    ; check replacement metatile
              Branch exit: Line 14146: BlkOffscr: LDA Block_OffscreenBits; get offscreen bits for block object
              Line 14129: LDA #$87                        ; set A for used block tile
                Branch exit: Line 14138: SetBFlip: LDX ObjectOffset      ; put block object offset back in X
                Line 14137: LSR                             ; otherwise set to $01
                Line 14138: SetBFlip: LDX ObjectOffset      ; put block object offset back in X
              Line 14146: BlkOffscr: LDA Block_OffscreenBits; get offscreen bits for block object
                Branch exit: Line 14153: PullOfsB: PLA                   ; pull offscreen bits from stack
                Line 14150: LDA #$f8                        ; move offscreen two OAMs
                Line 14153: PullOfsB: PLA                   ; pull offscreen bits from stack
                  Line 14154: ChkLeftCo: AND #%00001000       ; check to see if d3 in offscreen bits are set (as a call, not in function)

Function WriteTopScore
  Inputs: []
  Outputs: []
    Line 1627: WriteTopScore: 

Function PlayerInjuryBlink
  Inputs: []
  Outputs: []
    Line 5748: PlayerInjuryBlink: 
      Branch exit: Line 5755: ExitBlink: BNE ExitBoth         ; do unconditional branch to leave
      Line 5752: CMP #$c8                        ; check again for another specific point
        Branch exit: Line 5776: DonePlayerTask: 
        Line 5754: JMP PlayerCtrlRoutine           ; otherwise run player control routine
          Branch exit: Line 5562: PlayerCtrlRoutine: 
      Line 5755: ExitBlink: BNE ExitBoth         ; do unconditional branch to leave
        Branch exit: Line 5765: ExitBoth: RTS                   ; leave
        Line 5756: 

Function BlockBufferColli_Feet
  Inputs: [Y]
  Outputs: []
          Line 13046: BlockBufferColli_Feet: 
            Line 13049: BlockBufferColli_Head:  (as a call, not in function)

Function BowserGfxHandler
  Inputs: [X]
  Outputs: []
  Line 10268: BowserGfxHandler: 
    Branch exit: Line 10275: CopyFToR: TYA                   ; move bowser's rear object position value to A
    Line 10274: LDY #$f0                        ; otherwise load alternate positioning value here
    Line 10275: CopyFToR: TYA                   ; move bowser's rear object position value to A

Function RunSmallPlatform
  Inputs: [X, CarryFlag, Y]
  Outputs: []
    Line 9135: RunSmallPlatform: 
      Branch exit: Line 11010: OffscreenBoundsCheck: 

Function StoreMT
  Inputs: [A]
  Outputs: []
                              Line 3232: StoreMT: STA $07                ; store value here
                                Line 3237: TerrLoop: LDA TerrainRenderBits,Y; get one of the terrain rendering bit data
                                  Branch exit: Line 3248: NoCloud2: LDY #$00              ; start at beginning of bitmasks
                                  Line 3243: CPX #$00                        ; otherwise, check if we're doing the ceiling byte
                                    Branch exit: Line 3248: NoCloud2: LDY #$00              ; start at beginning of bitmasks
                                    Line 3245: LDA $00                         ; if not, mask out all but d3
                                  Line 3248: NoCloud2: LDY #$00              ; start at beginning of bitmasks
                                    Line 3249: TerrBChk: LDA Bitmasks,Y        ; load bitmask, then perform AND on contents of first byte
                                      Branch exit: Line 3254: NextTBit: INX                   ; continue until end of buffer
                                      Line 3252: LDA $07
                                      Line 3254: NextTBit: INX                   ; continue until end of buffer
                                        Branch exit: Line 3269: RendBBuf: JSR ProcessAreaData   ; do the area data loading routine now
                                        Line 3257: LDA AreaType                    ; check world type for underground area
                                          Branch exit: Line 3264: EndUChk: INY                    ; increment bitmasks offset in Y
                                          Line 3260: CPX #$0b
                                            Branch exit: Line 3264: EndUChk: INY                    ; increment bitmasks offset in Y
                                            Line 3262: LDA #$54                        ; old terrain type with ground level terrain type
                                          Line 3264: EndUChk: INY                    ; increment bitmasks offset in Y
                                            Branch exit: Line 3249: TerrBChk: LDA Bitmasks,Y        ; load bitmask, then perform AND on contents of first byte
                                            Line 3267: LDY $01
                                              Branch exit: Line 3237: TerrLoop: LDA TerrainRenderBits,Y; get one of the terrain rendering bit data
                                        Line 3269: RendBBuf: JSR ProcessAreaData   ; do the area data loading routine now
                                          Line 3274: ChkMTLow: STY $00
                                            Branch exit: Line 3285: StrBlock: LDY $00               ; get offset for block buffer
                                            Line 3284: LDA #$00                        ; if less, init value before storing
                                            Line 3285: StrBlock: LDY $00               ; get offset for block buffer
                                              Branch exit: Line 3274: ChkMTLow: STY $00
                                              Line 3294: RTS 

Function WriteTopStatusLine
  Inputs: []
  Outputs: []
    Line 1491: WriteTopStatusLine: 
      Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function KillEnemies
  Inputs: [A]
  Outputs: []
    Line 3594: KillEnemies: 
      Line 3598: KillELoop: LDY Enemy_ID,X
        Branch exit: Line 3602: NoKillE: DEX                    ; do this until all slots are checked
        Line 3601: STA Enemy_Flag,X                ; if found, deactivate enemy object flag
        Line 3602: NoKillE: DEX                    ; do this until all slots are checked
          Branch exit: Line 3598: KillELoop: LDY Enemy_ID,X
          Line 3604: RTS 

Function PutAtRightExtent
  Inputs: [A, X]
  Outputs: [A]
                Line 8583: PutAtRightExtent: 
                  Branch exit: Line 8619: FinishFlame: 

Function CheckThreeBytes
  Inputs: []
  Outputs: []
  Line 8045: CheckThreeBytes: 
    Branch exit: Line 8052: Inc2B: INC EnemyDataOffset      ; otherwise increment two bytes

Function DoFootCheck
  Inputs: [$04, X]
  Outputs: []
  Line 11979: DoFootCheck: 
    Branch exit: Line 12031: DoPlayerSideCheck: 
    Line 11984: JSR BlockBufferColli_Feet       ; do player-to-bg collision detection on bottom left of player
      Branch exit: Line 11998: AwardTouchedCoin: 
      Line 11987: PHA                             ; save bottom left metatile to stack
        Branch exit: Line 12001: ChkFootMTile: 
        Line 11993: LDA $00                         ; otherwise check for anything in bottom right metatile
          Branch exit: Line 12031: DoPlayerSideCheck: 
          Line 11995: JSR CheckForCoinMTiles          ; check to see if player touched coin with their right foot
            Branch exit: Line 12001: ChkFootMTile: 
            Line 11997: 

Function RenderAttributeTables
  Inputs: []
  Outputs: []
    Line 1894: RenderAttributeTables: 
      Branch exit: Line 1904: SetATHigh: AND #%00000100       ; mask out all other bits
      Line 1903: EOR #%00000100                  ; otherwise invert d2
      Line 1904: SetATHigh: AND #%00000100       ; mask out all other bits
        Line 1914: AttribLoop: LDA $00
          Branch exit: Line 1914: AttribLoop: LDA $00
          Line 1934: STA VRAM_Buffer2,Y              ; put null terminator at the end

Function AxeObj
  Inputs: []
  Outputs: []
    Line 4039: AxeObj: 

Function WarpZoneObject
  Inputs: []
  Outputs: []
    Line 6480: WarpZoneObject: 
      Branch exit: Line 6476: ExGTimer: RTS                   ; leave
      Line 6483: LDA Player_Y_Position           ; check to see if player's vertical coordinate has
        Branch exit: Line 6476: ExGTimer: RTS                   ; leave
        Line 6486: STA ScrollLock                  ; otherwise nullify scroll lock flag
          Branch exit: Line 9177: EraseEnemyObject: 

Function SmallPlatformCollision
  Inputs: [X, CarryFlag, Y]
  Outputs: []
    Line 11747: SmallPlatformCollision: 
      Branch exit: Line 11778: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave
      Line 11750: STA PlatformCollisionFlag,X     ; otherwise initialize collision flag
        Branch exit: Line 11778: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave
        Line 11753: LDA #$02
          Line 11756: ChkSmallPlatLoop: 
            Branch exit: Line 11778: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave
            Line 11761: LDA BoundingBox_UL_YPos,Y       ; check top of platform's bounding box for being
              Branch exit: Line 11767: MoveBoundBox: 
              Line 11764: JSR PlayerCollisionCore         ; otherwise, perform player-to-platform collision detection
                Branch exit: Line 11783: ProcSPlatCollisions: 
                Line 11766: 
              Line 11767: MoveBoundBox: 
                Branch exit: Line 11756: ChkSmallPlatLoop: 
      Line 11778: ExSPC: LDX ObjectOffset         ; get enemy object buffer offset, then leave

Function ImposeFriction
  Inputs: [A]
  Outputs: [A]
    Line 6231: ImposeFriction: 
      Branch exit: Line 6239: JoypFrict: LSR                  ; put right controller bit into carry
      Line 6235: LDA Player_X_Speed
        Branch exit: Line 6269: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave
        Line 6237: BPL RghtFrict                   ; if player moving to the right, branch to slow
          Branch exit: Line 6253: RghtFrict: LDA Player_X_MoveForce; load value set here
          Line 6238: BMI LeftFrict                   ; otherwise logic dictates player moving left, branch to slow
            Branch exit: Line 6241: LeftFrict: LDA Player_X_MoveForce; load value set here
      Line 6239: JoypFrict: LSR                  ; put right controller bit into carry
        Branch exit: Line 6253: RghtFrict: LDA Player_X_MoveForce; load value set here
      Line 6241: LeftFrict: LDA Player_X_MoveForce; load value set here
        Branch exit: Line 6264: XSpdSign: CMP #$00              ; if player not moving or moving to the right,
        Line 6250: LDA MaximumRightSpeed           ; otherwise set preset value as horizontal speed
          Branch exit: Line 6269: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave
      Line 6253: RghtFrict: LDA Player_X_MoveForce; load value set here
        Branch exit: Line 6264: XSpdSign: CMP #$00              ; if player not moving or moving to the right,
        Line 6262: LDA MaximumLeftSpeed            ; otherwise set preset value as horizontal speed
      Line 6264: XSpdSign: CMP #$00              ; if player not moving or moving to the right,
        Branch exit: Line 6269: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave
        Line 6266: EOR #$ff
      Line 6269: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave (as a call, not in function)

Function NoFrenzyCode
  Inputs: []
  Outputs: []
        Line 8851: NoFrenzyCode: 

Function MoveEnemyHorizontally
  Inputs: [X]
  Outputs: [A]
  Line 7534: MoveEnemyHorizontally: 

Function SPBBox
  Inputs: [X]
  Outputs: []
  Line 8936: SPBBox: LDA #$05                ; set default bounding box size control
    Branch exit: Line 8943: CasPBB: STA Enemy_BoundBoxCtrl,X; set bounding box size control here and leave
    Line 8940: LDY SecondaryHardMode           ; otherwise check for secondary hard mode flag
      Branch exit: Line 8943: CasPBB: STA Enemy_BoundBoxCtrl,X; set bounding box size control here and leave
      Line 8942: LDA #$06                        ; use alternate value if not castle or secondary not set
    Line 8943: CasPBB: STA Enemy_BoundBoxCtrl,X; set bounding box size control here and leave

Function GetAreaObjectID
  Inputs: [$00]
  Outputs: [Y]
    Line 4207: GetAreaObjectID: 

Function PlatLiftDown
  Inputs: [X]
  Outputs: []
    Line 8969: PlatLiftDown: 

Function SetVRAMAddr_B
  Inputs: [A]
  Outputs: []
  Line 1486: SetVRAMAddr_B: STA VRAM_Buffer_AddrCtrl

Function UpdScrollVar
  Inputs: []
  Outputs: []
          Line 5364: UpdScrollVar: LDA VRAM_Buffer_AddrCtrl
            Branch exit: Line 5378: ExitEng: RTS                    ; and after all that, we're finally done!
            Line 5367: LDA AreaParserTaskNum           ; otherwise check number of tasks
              Branch exit: Line 5377: RunParser: JSR AreaParserTaskHandler; update the name table with more level graphics
              Line 5369: LDA ScrollThirtyTwo             ; get horizontal scroll in 0-31 or $00-$20 range
                Branch exit: Line 5378: ExitEng: RTS                    ; and after all that, we're finally done!
                Line 5372: LDA ScrollThirtyTwo
              Line 5377: RunParser: JSR AreaParserTaskHandler; update the name table with more level graphics
            Line 5378: ExitEng: RTS                    ; and after all that, we're finally done!

Function MoveSmallPlatform
  Inputs: [X]
  Outputs: []
    Line 10982: MoveSmallPlatform: 
      Branch exit: Line 10998: ChkSmallPlatCollision: 

Function RunDemo
  Inputs: [$01]
  Outputs: []
                Line 1023: RunDemo: JSR GameCoreRoutine    ; run game engine
                  Branch exit: Line 1054: ExitMenu: RTS 

Function ProcEnemyCollisions
  Inputs: [Y, X, $01]
  Outputs: []
    Line 11627: ProcEnemyCollisions: 
      Branch exit: Line 11659: ExitProcessEColl: 
      Line 11632: LDA Enemy_State,X
        Branch exit: Line 11662: ProcSecondEnemyColl: 
        Line 11635: LDA Enemy_ID,X                  ; check second enemy identifier for hammer bro
          Branch exit: Line 11659: ExitProcessEColl: 
          Line 11638: LDA Enemy_State,Y               ; check first enemy state for d7 set
            Branch exit: Line 11646: ShellCollisions: 
            Line 11641: LDA #$06
            Line 11646: ShellCollisions: 

Function EnemyGfxHandler
  Inputs: [X]
  Outputs: []
  Line 13618: EnemyGfxHandler: 
    Branch exit: Line 13640: CheckForRetainerObj: 
    Line 13634: LDY PiranhaPlant_Y_Speed,X
      Branch exit: Line 13640: CheckForRetainerObj: 
      Line 13636: LDY EnemyFrameTimer,X
        Branch exit: Line 13640: CheckForRetainerObj: 
        Line 13638: RTS                             ; if all conditions fail, leave

Function InitializeGame
  Inputs: [A]
  Outputs: []
        Line 2650: InitializeGame: 
          Line 2654: ClrSndLoop: STA SoundMemory,Y   ; clear out memory used
            Branch exit: Line 2654: ClrSndLoop: STA SoundMemory,Y   ; clear out memory used
            Line 2657: LDA #$18                        ; set demo timer
              Line 2664: InitializeArea:  (as a call, not in function)

Function DecodeAreaData
  Inputs: [X]
  Outputs: []
    Line 3372: DecodeAreaData: 
      Branch exit: Line 3376: Chk1stB: LDX #$10               ; load offset of 16 for special row 15
      Line 3375: LDY AreaObjOffsetBuffer,X       ; if not, get offset from buffer
      Line 3376: Chk1stB: LDX #$10               ; load offset of 16 for special row 15
        Branch exit: Line 3363: EndAParse: RTS 
        Line 3380: AND #$0f                        ; otherwise, mask out low nybble
          Branch exit: Line 3387: ChkRow14: STX $07               ; store whatever value we just loaded here
          Line 3383: LDX #$08                        ; otherwise load offset of 8 for special row 12
            Branch exit: Line 3387: ChkRow14: STX $07               ; store whatever value we just loaded here
            Line 3386: LDX #$00                        ; otherwise nullify value by default
          Line 3387: ChkRow14: STX $07               ; store whatever value we just loaded here
            Branch exit: Line 3395: ChkRow13: CMP #$0d              ; row 13?
            Line 3391: LDA #$00                        ; if so, load offset with $00
              Branch exit: Line 3438: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
            Line 3395: ChkRow13: CMP #$0d              ; row 13?
              Branch exit: Line 3410: ChkSRows: CMP #$0c              ; row 12-15?
              Line 3397: LDA #$22                        ; if so, load offset with 34
                Branch exit: Line 3451: LeavePar: RTS 
                Line 3403: LDA (AreaData),Y                ; otherwise, get byte again
                  Branch exit: Line 3408: Mask2MSB: AND #%00111111        ; mask out d7 and d6
                  Line 3407: INC LoopCommand                 ; if loop command, set loop command flag
                  Line 3408: Mask2MSB: AND #%00111111        ; mask out d7 and d6
                    Branch exit: Line 3438: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
              Line 3410: ChkSRows: CMP #$0c              ; row 12-15?
                Branch exit: Line 3431: SpecObj: INY                    ; branch here for rows 12-15
                Line 3412: INY                             ; if not, get second byte of level object
                  Branch exit: Line 3421: LrgObj: STA $00                 ; store value here (branch for large objects)
                  Line 3416: LDA #$16
                    Branch exit: Line 3438: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
                  Line 3421: LrgObj: STA $00                 ; store value here (branch for large objects)
                    Branch exit: Line 3429: NotWPipe: LDA $00               ; get value and jump ahead
                    Line 3424: LDA (AreaData),Y                ; if not, reload second byte
                      Branch exit: Line 3429: NotWPipe: LDA $00               ; get value and jump ahead
                      Line 3427: LDA #$00                        ; otherwise, nullify value for warp pipe
                    Line 3429: NotWPipe: LDA $00               ; get value and jump ahead
                      Branch exit: Line 3434: MoveAOId: LSR                   ; move d6-d4 to lower nybble
                Line 3431: SpecObj: INY                    ; branch here for rows 12-15
                Line 3434: MoveAOId: LSR                   ; move d6-d4 to lower nybble (as a call, not in function)
            Line 3438: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14) (as a call, not in function)
            Line 3451: LeavePar: RTS  (as a call, not in function)

Function FirebarCollision
  Inputs: [Y]
  Outputs: []
            Line 9801: FirebarCollision: 
              Branch exit: Line 9868: NoColFB: PLA                    ; get OAM data offset
              Line 9808: STA $05                         ; otherwise initialize counter
                Branch exit: Line 9868: NoColFB: PLA                    ; get OAM data offset
                Line 9812: LDY Player_Y_Position           ; get player's vertical position
                  Branch exit: Line 9817: AdjSm: INC $05                  ; if small or big but crouching, execute this part
                  Line 9815: LDA CrouchingFlag
                    Branch exit: Line 9823: BigJp: TYA                      ; get vertical coordinate, altered or otherwise, from Y
                  Line 9817: AdjSm: INC $05                  ; if small or big but crouching, execute this part
                  Line 9823: BigJp: TYA                      ; get vertical coordinate, altered or otherwise, from Y
                    Line 9824: FBCLoop: SEC                    ; subtract vertical position of firebar (as a call, not in function)
              Line 9868: NoColFB: PLA                    ; get OAM data offset (as a call, not in function)

Function GetAreaObjXPosition
  Inputs: []
  Outputs: [A]
    Line 4305: GetAreaObjXPosition: 

Function MovePlatformDown
  Inputs: [X]
  Outputs: []
    Line 7677: MovePlatformDown: 
      Line 7681: MovePlatformUp:  (as a call, not in function)

Function EnemyLanding
  Inputs: [X]
  Outputs: []
    Line 12650: EnemyLanding: 

Function InitializeArea
  Inputs: []
  Outputs: []
              Line 2664: InitializeArea: 
                Line 2669: ClrTimersLoop: STA Timers,X     ; clear out memory between
                  Branch exit: Line 2669: ClrTimersLoop: STA Timers,X     ; clear out memory between
                  Line 2672: LDA HalfwayPage
                    Branch exit: Line 2676: StartPage: STA ScreenLeft_PageLoc; set as value here
                    Line 2675: LDA EntrancePage                ; otherwise use saved entry page number here
                    Line 2676: StartPage: STA ScreenLeft_PageLoc; set as value here
                      Branch exit: Line 2684: SetInitNTHigh: STY CurrentNTAddr_High; store name table address
                      Line 2683: LDY #$24
                      Line 2684: SetInitNTHigh: STY CurrentNTAddr_High; store name table address
                        Branch exit: Line 2707: SetSecHard: INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond
                        Line 2700: LDA WorldNumber                 ; otherwise check world number
                          Branch exit: Line 2708: CheckHalfway: LDA HalfwayPage
                          Line 2703: BNE SetSecHard                  ; if not equal to, then world > 5, thus activate
                            Branch exit: Line 2707: SetSecHard: INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond
                            Line 2704: LDA LevelNumber                 ; otherwise, world 5, so check level number
                              Branch exit: Line 2708: CheckHalfway: LDA HalfwayPage
                        Line 2707: SetSecHard: INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond
                        Line 2708: CheckHalfway: LDA HalfwayPage
                          Branch exit: Line 2712: DoneInitArea: LDA #Silence      ; silence music
                          Line 2710: LDA #$02                        ; if halfway page set, overwrite start position from header
                          Line 2712: DoneInitArea: LDA #Silence      ; silence music

Function StopPlatforms
  Inputs: [A, Y, X]
  Outputs: []
  Line 10877: StopPlatforms: 

Function GetCurrentAnimOffset
  Inputs: []
  Outputs: [A]
  Line 14655: GetCurrentAnimOffset: 
    Branch exit: Line 14713: GetOffsetFromAnimCtrl: 

Function RenderAreaGraphics
  Inputs: []
  Outputs: []
    Line 1799: RenderAreaGraphics: 
      Line 1814: DrawMTLoop: STX $01             ; store init value of 0 or incremented offset for buffer (as a call, not in function)

Function InitBowserFlame
  Inputs: [X]
  Outputs: []
        Line 8558: InitBowserFlame: 
          Branch exit: Line 8548: FlmEx: RTS                      ; and then leave
          Line 8561: STA Enemy_Y_MoveForce,X         ; reset something here
            Branch exit: Line 8594: SpawnFromMouth: 
            Line 8569: JSR SetFlameTimer               ; get timer data based on flame counter
              Branch exit: Line 8576: SetFrT: STA FrenzyEnemyTimer    ; set timer accordingly
              Line 8574: SEC 
              Line 8576: SetFrT: STA FrenzyEnemyTimer    ; set timer accordingly
                Line 8583: PutAtRightExtent:  (as a call, not in function)

Function StaircaseObject
  Inputs: [CarryFlag, X]
  Outputs: []
        Line 4136: StaircaseObject: 
          Branch exit: Line 4141: NextStair: DEC StaircaseControl ; move onto next step (or first if starting)
          Line 4139: LDA #$09                        ; start past the end for the bottom
          Line 4141: NextStair: DEC StaircaseControl ; move onto next step (or first if starting)
            Branch exit: Line 4252: RenderUnderPart: 

Function BrickWithItem
  Inputs: [Y, $00]
  Outputs: []
  Line 4191: BrickWithItem: 
    Branch exit: Line 4199: BWithL: CLC                     ; add object ID to adder
    Line 4198: LDA #$05                        ; otherwise use adder for bricks without lines
    Line 4199: BWithL: CLC                     ; add object ID to adder

Function DisplayIntermediate
  Inputs: [$07]
  Outputs: []
    Line 1539: DisplayIntermediate: 
      Branch exit: Line 1563: NoInter: LDA #$08               ; set for specific task and leave
      Line 1542: CMP #GameOverModeValue          ; are we in game over mode?
        Branch exit: Line 1558: GameOverInter: LDA #$12         ; set screen timer
        Line 1544: LDA AltEntranceControl          ; otherwise check for mode of alternate entry
          Branch exit: Line 1563: NoInter: LDA #$08               ; set for specific task and leave
          Line 1546: LDY AreaType                    ; check if we are on castle level
            Branch exit: Line 1551: PlayerInter: JSR DrawPlayer_Intermediate; put player in appropriate place for
            Line 1549: LDA DisableIntermediate         ; if this flag is set, skip intermediate lives display
              Branch exit: Line 1563: NoInter: LDA #$08               ; set for specific task and leave
            Line 1551: PlayerInter: JSR DrawPlayer_Intermediate; put player in appropriate place for
        Line 1558: GameOverInter: LDA #$12         ; set screen timer
          Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode
      Line 1563: NoInter: LDA #$08               ; set for specific task and leave

Function WritePPUReg1
  Inputs: [A]
  Outputs: []
    Line 2507: WritePPUReg1: 

Function IncrementColumnPos
  Inputs: []
  Outputs: []
        Line 3066: IncrementColumnPos: 
          Branch exit: Line 3073: NoColWrap: INC BlockBufferColumnPos; increment column offset where we're at
          Line 3071: STA CurrentColumnPos            ; if no bits left set, wrap back to zero (0-f)
          Line 3073: NoColWrap: INC BlockBufferColumnPos; increment column offset where we're at

Function HandlePipeEntry
  Inputs: [$00, $01]
  Outputs: []
    Line 12274: HandlePipeEntry: 
      Branch exit: Line 12320: ExPipeE: RTS                    ; leave!!!
      Line 12278: LDA $00
        Branch exit: Line 12320: ExPipeE: RTS                    ; leave!!!
        Line 12281: LDA $01
          Branch exit: Line 12320: ExPipeE: RTS                    ; leave!!!
          Line 12284: LDA #$30
            Branch exit: Line 12320: ExPipeE: RTS                    ; leave!!!
            Line 12294: AND #%00000011                  ; mask out all but 2 LSB
              Branch exit: Line 12305: GetWNum: LDY WarpZoneNumbers,X  ; get warp zone numbers
              Line 12301: INX                             ; otherwise increment for middle pipe
                Branch exit: Line 12305: GetWNum: LDY WarpZoneNumbers,X  ; get warp zone numbers
                Line 12304: INX                             ; otherwise increment for last pipe
              Line 12305: GetWNum: LDY WarpZoneNumbers,X  ; get warp zone numbers
      Line 12320: ExPipeE: RTS                    ; leave!!!

Function HandleAxeMetatile
  Inputs: []
  Outputs: []
  Line 12131: HandleAxeMetatile: 
    Line 12138: ErACM: LDY $02                  ; load vertical high nybble offset for block buffer (as a call, not in function)

Function MovePlayerVertically
  Inputs: []
  Outputs: []
  Line 7590: MovePlayerVertically: 
    Branch exit: Line 7596: NoJSChk: LDA VerticalForce      ; dump vertical force
    Line 7594: LDA JumpspringAnimCtrl          ; otherwise check to see if jumpspring is animating
      Branch exit: Line 7583: ExXMove: RTS                    ; and leave
    Line 7596: NoJSChk: LDA VerticalForce      ; dump vertical force
      Branch exit: Line 7670: ImposeGravitySprObj: 

Function EnemyTurnAround
  Inputs: [X]
  Outputs: []
    Line 11686: EnemyTurnAround: 
      Branch exit: Line 11708: ExTA: RTS                       ; leave!!!
      Line 11690: CMP #Lakitu
        Branch exit: Line 11708: ExTA: RTS                       ; leave!!!
        Line 11692: CMP #HammerBro
          Branch exit: Line 11708: ExTA: RTS                       ; leave!!!
          Line 11694: CMP #Spiny
            Branch exit: Line 11700: RXSpd: LDA Enemy_X_Speed,X      ; load horizontal speed
            Line 11696: CMP #GreenParatroopaJump
              Branch exit: Line 11700: RXSpd: LDA Enemy_X_Speed,X      ; load horizontal speed
              Line 11698: CMP #$07
                Branch exit: Line 11708: ExTA: RTS                       ; leave!!!

Function ChkForRedKoopa
  Inputs: [X]
  Outputs: []
  Line 12576: ChkForRedKoopa: 
    Branch exit: Line 12582: Chk2MSBSt: LDA Enemy_State,X    ; save enemy state into Y
    Line 12580: LDA Enemy_State,X
      Branch exit: Line 12617: ChkForBump_HammerBroJ: 
    Line 12582: Chk2MSBSt: LDA Enemy_State,X    ; save enemy state into Y
      Branch exit: Line 12589: GetSteFromD: LDA EnemyBGCStateData,Y; load new enemy state with old as offset
      Line 12586: LDA Enemy_State,X
        Branch exit: Line 12590: SetD6Ste: STA Enemy_State,X     ; set as new state
      Line 12589: GetSteFromD: LDA EnemyBGCStateData,Y; load new enemy state with old as offset
      Line 12590: SetD6Ste: STA Enemy_State,X     ; set as new state (as a call, not in function)

Function Vine_AutoClimb
  Inputs: []
  Outputs: []
    Line 5670: Vine_AutoClimb: 
      Branch exit: Line 5676: AutoClimb: LDA #%00001000       ; set controller bits override to up
      Line 5673: LDA Player_Y_Position
        Branch exit: Line 5681: SetEntr: LDA #$02               ; set starting position to override
        Line 5681: SetEntr: LDA #$02               ; set starting position to override (as a call, not in function)
      Line 5676: AutoClimb: LDA #%00001000       ; set controller bits override to up
        Branch exit: Line 5559: AutoControlPlayer: 

Function GetMaskedOffScrBits
  Inputs: [X, Y, $00]
  Outputs: []
  Line 12812: GetMaskedOffScrBits: 
    Branch exit: Line 12823: CMBits: TYA                     ; otherwise use contents of Y
    Line 12820: ORA $01
      Branch exit: Line 12823: CMBits: TYA                     ; otherwise use contents of Y
      Line 12822: LDY $00                         ; if to the right of left edge, use value in $00 for A
    Line 12823: CMBits: TYA                     ; otherwise use contents of Y
      Branch exit: Line 12845: MoveBoundBoxOffscreen: 
      Line 12827: JMP SetupEOffsetFBBox           ; otherwise, do something else
        Branch exit: Line 12836: SetupEOffsetFBBox: 

Function InitPodoboo
  Inputs: [X]
  Outputs: []
    Line 8148: InitPodoboo: 
      Branch exit: Line 8213: SmallBBox: LDA #$09             ; set specific bounding box size control

Function InitJumpGPTroopa
  Inputs: [X]
  Outputs: []
    Line 8872: InitJumpGPTroopa: 

Function SetVRAMOffset
  Inputs: [A]
  Outputs: []
  Line 1476: SetVRAMOffset: STA VRAM_Buffer1_Offset; store as new vram buffer offset

Function EndOfEnemyInitCode
  Inputs: []
  Outputs: []
    Line 9004: EndOfEnemyInitCode: 

Function XMoveCntr_GreenPTroopa
  Inputs: []
  Outputs: []
    Line 9424: XMoveCntr_GreenPTroopa: 
      Line 9427: XMoveCntr_Platform:  (as a call, not in function)

Function RunLargePlatform
  Inputs: [X, A, Y]
  Outputs: []
    Line 9147: RunLargePlatform: 
      Branch exit: Line 9155: SkipPT: JSR RelativeEnemyPosition
      Line 9154: JSR LargePlatformSubroutines
      Line 9155: SkipPT: JSR RelativeEnemyPosition
        Branch exit: Line 11010: OffscreenBoundsCheck: 

Function GetMTileAttrib
  Inputs: [A]
  Outputs: [A]
    Line 12386: GetMTileAttrib: 

Function LoadControlRegs
  Inputs: []
  Outputs: []
    Line 15930: LoadControlRegs: 
      Branch exit: Line 15936: NotECstlM: LDA AreaMusicBuffer
      Line 15934: LDA #$04                        ; this value is only used for win castle music
        Branch exit: Line 15942: AllMus: LDX #$82                ; load contents of other sound regs for square 2
      Line 15936: NotECstlM: LDA AreaMusicBuffer
        Branch exit: Line 15941: WaterMus: LDA #$28              ; this value is used for water music and all other event music
        Line 15939: LDA #$08                        ; this is the default value for all other music
          Branch exit: Line 15942: AllMus: LDX #$82                ; load contents of other sound regs for square 2
        Line 15941: WaterMus: LDA #$28              ; this value is used for water music and all other event music
      Line 15942: AllMus: LDX #$82                ; load contents of other sound regs for square 2

Function InitDropPlatform
  Inputs: [X]
  Outputs: []
          Line 8904: InitDropPlatform: 
            Branch exit: Line 8934: CommonPlatCode: 

Function DrawOneSpriteRow
  Inputs: [A]
  Outputs: [X]
      Line 14072: DrawOneSpriteRow: 
        Branch exit: Line 15004: DrawSpriteObject: 

Function DumpThreeSpr
  Inputs: [A, Y]
  Outputs: []
                  Line 13324: DumpThreeSpr: 

Function SBnce
  Inputs: []
  Outputs: []
  Line 11515: SBnce: LDA #$fc                 ; set player's vertical speed for bounce

Function AlterAreaAttributes
  Inputs: [X]
  Outputs: []
                  Line 3540: AlterAreaAttributes: 
                    Branch exit: Line 3559: Alter2: PLA 
                    Line 3547: PLA 
                    Line 3559: Alter2: PLA 
                      Branch exit: Line 3565: SetFore: STA ForegroundScenery  ; otherwise set new foreground scenery bits
                      Line 3563: STA BackgroundColorCtrl
                      Line 3565: SetFore: STA ForegroundScenery  ; otherwise set new foreground scenery bits

Function ThreeFrameExtent
  Inputs: []
  Outputs: []
  Line 14663: ThreeFrameExtent: 

Function GetMiscBoundBox
  Inputs: [X]
  Outputs: []
          Line 12792: GetMiscBoundBox: 

Function BalancePlatform
  Inputs: [X]
  Outputs: []
    Line 10671: BalancePlatform: 
      Branch exit: Line 10676: DoBPl: LDA Enemy_State,X        ; get object's state (set to $ff or other platform offset)
      Line 10675: JMP EraseEnemyObject            ; if far below screen, kill the object
        Branch exit: Line 9177: EraseEnemyObject: 
      Line 10676: DoBPl: LDA Enemy_State,X        ; get object's state (set to $ff or other platform offset)
        Branch exit: Line 10680: CheckBalPlatform: 
        Line 10678: RTS 

Function PlayerLakituDiff
  Inputs: [$00, X]
  Outputs: []
    Line 10006: PlayerLakituDiff: 
      Branch exit: Line 10016: ChkLakDif: LDA $00              ; get low byte of horizontal difference
      Line 10010: INY                             ; increment Y for left of player
      Line 10016: ChkLakDif: LDA $00              ; get low byte of horizontal difference
        Branch exit: Line 10034: ChkPSpeed: LDA $00
        Line 10019: LDA #$3c                        ; otherwise set maximum distance
          Branch exit: Line 10034: ChkPSpeed: LDA $00
          Line 10024: TYA                             ; compare contents of Y, now in A
            Branch exit: Line 10034: ChkPSpeed: LDA $00
            Line 10027: LDA LakituMoveDirection,X       ; if moving to the left beyond maximum distance,
              Branch exit: Line 10032: SetLMovD: TYA                   ; set horizontal direction depending on horizontal
              Line 10029: DEC LakituMoveSpeed,X           ; decrement horizontal speed
                Branch exit: Line 10066: ExMoveLak: RTS                  ; leave!!!
              Line 10032: SetLMovD: TYA                   ; set horizontal direction depending on horizontal
        Line 10034: ChkPSpeed: LDA $00
          Branch exit: Line 10060: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
          Line 10042: LDA ScrollAmount
            Branch exit: Line 10060: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
            Line 10044: INY                             ; otherwise increment offset
              Branch exit: Line 10052: ChkSpinyO: LDA Enemy_ID,X       ; check for spiny object
              Line 10048: LDA ScrollAmount
                Branch exit: Line 10052: ChkSpinyO: LDA Enemy_ID,X       ; check for spiny object
                Line 10051: INY                             ; otherwise increment once more
              Line 10052: ChkSpinyO: LDA Enemy_ID,X       ; check for spiny object
                Branch exit: Line 10057: ChkEmySpd: LDA Enemy_Y_Speed,X  ; check vertical speed
                Line 10055: LDA Player_X_Speed              ; if player not moving, skip this part
                  Branch exit: Line 10060: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
                Line 10057: ChkEmySpd: LDA Enemy_Y_Speed,X  ; check vertical speed
                  Branch exit: Line 10060: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
                  Line 10059: LDY #$00                        ; otherwise reinit offset
          Line 10060: SubDifAdj: LDA $0001,Y          ; get one of three saved values from earlier
            Line 10062: SPixelLak: SEC                  ; subtract one for each pixel of horizontal difference
              Branch exit: Line 10062: SPixelLak: SEC                  ; subtract one for each pixel of horizontal difference
        Line 10066: ExMoveLak: RTS                  ; leave!!!

Function CheckRightScreenBBox
  Inputs: [X, Y]
  Outputs: []
  Line 12895: CheckRightScreenBBox: 
    Branch exit: Line 12918: CheckLeftScreenBBox: 
    Line 12908: LDA BoundingBox_DR_XPos,Y       ; check right-side edge of bounding box for offscreen
      Branch exit: Line 12915: NoOfs: LDX ObjectOffset         ; get object offset and leave
      Line 12910: LDA #$ff                        ; load offscreen value here to use on one or both horizontal sides
        Branch exit: Line 12914: SORte: STA BoundingBox_DR_XPos,Y; store offscreen value for right side
        Line 12913: STA BoundingBox_UL_XPos,Y       ; store offscreen value for left side
        Line 12914: SORte: STA BoundingBox_DR_XPos,Y; store offscreen value for right side
      Line 12915: NoOfs: LDX ObjectOffset         ; get object offset and leave

Function KillAllEnemies
  Inputs: [A]
  Outputs: []
  Line 10146: KillAllEnemies: 
    Line 10148: KillLoop: JSR EraseEnemyObject  ; branch to kill enemy objects
      Branch exit: Line 10148: KillLoop: JSR EraseEnemyObject  ; branch to kill enemy objects
      Line 10151: STA EnemyFrenzyBuffer           ; empty frenzy buffer

Function CheckFrenzyBuffer
  Inputs: [X]
  Outputs: []
  Line 8007: CheckFrenzyBuffer: 
    Branch exit: Line 8014: StrFre: STA Enemy_ID,X          ; store contents of frenzy buffer into enemy identifier value
    Line 8010: LDA VineFlagOffset              ; otherwise check vine flag offset
      Branch exit: Line 8020: ExEPar: RTS                     ; then leave
      Line 8013: LDA #VineObject                 ; otherwise put vine in enemy identifier
    Line 8014: StrFre: STA Enemy_ID,X          ; store contents of frenzy buffer into enemy identifier value

Function EnterSidePipe
  Inputs: []
  Outputs: []
    Line 5721: EnterSidePipe: 
      Branch exit: Line 5730: RightPipe: TYA                  ; use contents of Y to
      Line 5728: STA Player_X_Speed              ; if lower nybble = 0, set as horizontal speed
      Line 5730: RightPipe: TYA                  ; use contents of Y to

Function Bridge_Middle
  Inputs: [X]
  Outputs: []
      Line 3943: Bridge_Middle:  (as a call, not in function)

Function MoveNormalEnemy
  Inputs: [X]
  Outputs: []
        Line 9297: MoveNormalEnemy: 
          Branch exit: Line 9315: FallE: JSR MoveD_EnemyVertically; do a sub here to move enemy downwards
          Line 9302: LDA Enemy_State,X
            Branch exit: Line 9329: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
            Line 9305: LDA Enemy_State,X
              Branch exit: Line 9360: MoveDefeatedEnemy: 
              Line 9308: LDA Enemy_State,X
                Branch exit: Line 9329: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
                Line 9311: CMP #$05
                  Branch exit: Line 9315: FallE: JSR MoveD_EnemyVertically; do a sub here to move enemy downwards
                  Line 9313: CMP #$03
                    Branch exit: Line 9342: ReviveStunned: 
          Line 9315: FallE: JSR MoveD_EnemyVertically; do a sub here to move enemy downwards
            Branch exit: Line 9326: MEHor: JMP MoveEnemyHorizontally; jump here to move enemy horizontally for <> $2e and d6 set
            Line 9320: AND #%01000000                  ; check for d6 set
              Branch exit: Line 9329: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
              Line 9322: LDA Enemy_ID,X
                Branch exit: Line 9329: SteadM: LDA Enemy_X_Speed,X     ; get current horizontal speed
                Line 9325: BNE SlowM                       ; if any other object where d6 set, jump to set Y
                  Branch exit: Line 9328: SlowM: LDY #$01                 ; if branched here, increment Y to slow horizontal movement
            Line 9326: MEHor: JMP MoveEnemyHorizontally; jump here to move enemy horizontally for <> $2e and d6 set
              Branch exit: Line 7534: MoveEnemyHorizontally: 

Function ProcLoopCommand
  Inputs: [X]
  Outputs: []
  Line 7830: ProcLoopCommand: 
    Branch exit: Line 7875: ChkEnemyFrenzy: 
    Line 7833: LDA CurrentColumnPos            ; check to see if we're still on the first page
      Branch exit: Line 7875: ChkEnemyFrenzy: 
      Line 7835: LDY #$0b                        ; start at the end of each set of loop data
        Line 7836: FindLoop: DEY 
          Branch exit: Line 7875: ChkEnemyFrenzy: 
          Line 7838: LDA WorldNumber                 ; check to see if one of the world numbers
            Branch exit: Line 7836: FindLoop: DEY 
            Line 7841: LDA CurrentPageLoc              ; check to see if one of the page numbers
              Branch exit: Line 7836: FindLoop: DEY 
              Line 7844: LDA Player_Y_Position           ; check to see if the player is at the correct position
                Branch exit: Line 7862: WrongChk: LDA WorldNumber       ; are we in world 7? (check performed on
                Line 7847: LDA Player_State                ; check to see if the player is
                  Branch exit: Line 7862: WrongChk: LDA WorldNumber       ; are we in world 7? (check performed on
                  Line 7850: LDA WorldNumber                 ; are we in world 7? (check performed on correct
                    Branch exit: Line 7867: InitMLp: LDA #$00               ; initialize counters used for multi-part loop commands
                    Line 7853: INC MultiLoopCorrectCntr        ; increment counter for correct progression
                Line 7854: IncMLoop: INC MultiLoopPassCntr ; increment master multi-part counter
                  Branch exit: Line 7870: InitLCmd: LDA #$00              ; initialize loop command flag
                  Line 7858: LDA MultiLoopCorrectCntr        ; if so, have we done them all correctly?
                    Branch exit: Line 7867: InitMLp: LDA #$00               ; initialize counters used for multi-part loop commands
                    Line 7861: BNE DoLpBack                    ; unconditional branch if previous branch fails
                      Branch exit: Line 7865: DoLpBack: JSR ExecGameLoopback  ; if player is not in right place, loop back
                Line 7862: WrongChk: LDA WorldNumber       ; are we in world 7? (check performed on
                  Branch exit: Line 7854: IncMLoop: INC MultiLoopPassCntr ; increment master multi-part counter
                Line 7865: DoLpBack: JSR ExecGameLoopback  ; if player is not in right place, loop back
                Line 7867: InitMLp: LDA #$00               ; initialize counters used for multi-part loop commands
                Line 7870: InitLCmd: LDA #$00              ; initialize loop command flag
    Line 7875: ChkEnemyFrenzy: 
      Branch exit: Line 7890: ProcessEnemyData: 
      Line 7878: STA Enemy_ID,X                  ; store as enemy object identifier here
        Branch exit: Line 8016: InitEnemyObject: 

Function LoadEnvelopeData
  Inputs: [Y]
  Outputs: [A]
    Line 15946: LoadEnvelopeData: 
      Branch exit: Line 15953: LoadUsualEnvData: 
      Line 15950: LDA EndOfCastleMusicEnvData,Y   ; load data from offset for win castle music

Function RunBowserFlame
  Inputs: [X]
  Outputs: []
    Line 9119: RunBowserFlame: 
      Branch exit: Line 11010: OffscreenBoundsCheck: 

Function RunGameOver
  Inputs: []
  Outputs: []
    Line 2972: RunGameOver: 
      Branch exit: Line 2980: TerminateGame: 
      Line 2978: LDA ScreenTimer                 ; if not pressed, wait for
        Branch exit: Line 3006: GameIsOn: RTS 
      Line 2980: TerminateGame:  (as a call, not in function)

Function MoveDefeatedEnemy
  Inputs: [X]
  Outputs: []
  Line 9360: MoveDefeatedEnemy: 
    Branch exit: Line 7534: MoveEnemyHorizontally: 

Function GetBackgroundColor
  Inputs: []
  Outputs: []
          Line 1434: GetBackgroundColor: 
            Branch exit: Line 1439: NoBGColor: INC ScreenRoutineTask; increment to next subtask and plod on through
            Line 1437: LDA BGColorCtrl_Addr-4,Y        ; put appropriate palette into vram
            Line 1439: NoBGColor: INC ScreenRoutineTask; increment to next subtask and plod on through
              Line 1441: GetPlayerColors:  (as a call, not in function)

Function RunOffscrBitsSubs
  Inputs: [A, X]
  Outputs: [A, $00]
    Line 14890: RunOffscrBitsSubs: 
      Branch exit: Line 14953: GetYOffscreenBits: 

Function ColObj
  Inputs: []
  Outputs: []
  Line 4053: ColObj: LDY #$00                ; column length of 1
    Branch exit: Line 4252: RenderUnderPart: 

Function ProcMoveRedPTroopa
  Inputs: [X]
  Outputs: []
    Line 9381: ProcMoveRedPTroopa: 
      Branch exit: Line 9395: MoveRedPTUpOrDown: 
      Line 9385: STA Enemy_YMF_Dummy,X           ; initialize something here
        Branch exit: Line 9395: MoveRedPTUpOrDown: 
        Line 9389: LDA FrameCounter                ; get frame counter
          Branch exit: Line 9393: NoIncPT: RTS                    ; leave
          Line 9392: INC Enemy_Y_Position,X          ; otherwise increment red paratroopa's vertical position
          Line 9393: NoIncPT: RTS                    ; leave

Function MushroomLedge
  Inputs: [Y, CarryFlag, X, $07]
  Outputs: []
    Line 3652: MushroomLedge: 
      Branch exit: Line 3661: EndMushL: LDA #$1b              ; if at the end, render end of mushroom
      Line 3656: LDA AreaObjectLength,X          ; divide length by 2 and store elsewhere
        Branch exit: Line 3678: NoUnder: LDX $07                ; load row of ledge
      Line 3661: EndMushL: LDA #$1b              ; if at the end, render end of mushroom
        Branch exit: Line 3678: NoUnder: LDX $07                ; load row of ledge
        Line 3664: LDA MushroomLedgeHalfLen,X      ; get divided length and store where length
          Branch exit: Line 3698: MushLExit: RTS                  ; and leave
          Line 3671: INX 

Function InitGoomba
  Inputs: []
  Outputs: []
    Line 8142: InitGoomba: 
      Branch exit: Line 8213: SmallBBox: LDA #$09             ; set specific bounding box size control

Function FinishFlame
  Inputs: [X]
  Outputs: []
  Line 8619: FinishFlame: 

Function DigitsMathRoutine
  Inputs: [Y]
  Outputs: []
    Line 2582: DigitsMathRoutine: 
      Branch exit: Line 2597: EraseDMods: LDA #$00            ; store zero here
      Line 2586: LDX #$05
        Line 2587: AddModLoop: LDA DigitModifier,X ; load digit amount to increment (as a call, not in function)
      Line 2597: EraseDMods: LDA #$00            ; store zero here (as a call, not in function)

Function ChkUnderEnemy
  Inputs: []
  Outputs: [ZeroFlag]
    Line 12711: ChkUnderEnemy: 
      Branch exit: Line 13002: BlockBufferChk_Enemy: 

Function SoundEngine
  Inputs: []
  Outputs: []
    Line 15049: SoundEngine: 
      Branch exit: Line 15054: SndOn: LDA #$ff
      Line 15052: STA SND_MASTERCTRL_REG          ; if so, disable sound and leave
      Line 15054: SndOn: LDA #$ff
        Branch exit: Line 15063: InPause: LDA PauseSoundBuffer   ; check pause sfx buffer
        Line 15060: LDA PauseSoundQueue             ; if not, check pause sfx queue
          Branch exit: Line 15104: RunSoundSubroutines: 
        Line 15063: InPause: LDA PauseSoundBuffer   ; check pause sfx buffer
          Branch exit: Line 15080: ContPau: LDA Squ1_SfxLenCounter ; check pause length left
          Line 15065: LDA PauseSoundQueue             ; check pause queue
            Branch exit: Line 15113: SkipSoundSubroutines: 
            Line 15067: STA PauseSoundBuffer            ; if queue full, store in buffer and activate
          Line 15078: PTone1F: LDA #$44               ; play first tone
            Branch exit: Line 15088: PTRegC: LDX #$84
          Line 15080: ContPau: LDA Squ1_SfxLenCounter ; check pause length left
            Branch exit: Line 15087: PTone2F: LDA #$64               ; store reg contents and play the pause sfx
            Line 15083: CMP #$1e                        ; time to play first again?
              Branch exit: Line 15078: PTone1F: LDA #$44               ; play first tone
              Line 15085: CMP #$18                        ; time to play second again?
                Branch exit: Line 15091: DecPauC: DEC Squ1_SfxLenCounter ; decrement pause sfx counter
            Line 15087: PTone2F: LDA #$64               ; store reg contents and play the pause sfx
          Line 15088: PTRegC: LDX #$84
          Line 15091: DecPauC: DEC Squ1_SfxLenCounter ; decrement pause sfx counter
            Branch exit: Line 15113: SkipSoundSubroutines: 
            Line 15093: LDA #$00                        ; disable sound if in pause mode and
              Branch exit: Line 15100: SkipPIn: LDA #$00               ; clear pause sfx buffer
              Line 15098: LDA #$00                        ; clear pause mode to allow game sounds again
              Line 15100: SkipPIn: LDA #$00               ; clear pause sfx buffer
                Branch exit: Line 15113: SkipSoundSubroutines: 
                Line 15103: 
        Line 15104: RunSoundSubroutines: 
        Line 15113: SkipSoundSubroutines: 
          Branch exit: Line 15126: NoIncDAC: TYA 
          Line 15123: INC DAC_Counter                 ; increment and check counter
            Branch exit: Line 15129: StrWave: STY SND_DELTA_REG+1    ; store into DMC load register (??)
          Line 15126: NoIncDAC: TYA 
            Branch exit: Line 15129: StrWave: STY SND_DELTA_REG+1    ; store into DMC load register (??)
            Line 15128: DEC DAC_Counter                 ; decrement counter
          Line 15129: StrWave: STY SND_DELTA_REG+1    ; store into DMC load register (??)

Function MovePlatformUp
  Inputs: [X]
  Outputs: []
      Line 7681: MovePlatformUp: 
        Branch exit: Line 7690: SetDplSpd: STA $00              ; save downward movement amount here
        Line 7689: LDA #$09                        ; residual code
        Line 7690: SetDplSpd: STA $00              ; save downward movement amount here

Function InitRetainerObj
  Inputs: [X]
  Outputs: []
    Line 8160: InitRetainerObj: 

Function DumpSixSpr
  Inputs: [A, Y]
  Outputs: []
              Line 13317: DumpSixSpr: 
                Line 13321: DumpFourSpr:  (as a call, not in function)

Function SetFreq_Squ1
  Inputs: [A]
  Outputs: [ZeroFlag]
      Line 15142: SetFreq_Squ1: 

Function InitBulletBill
  Inputs: [X]
  Outputs: []
    Line 8238: InitBulletBill: 

Function InitBloober
  Inputs: [X]
  Outputs: []
    Line 8210: InitBloober: 

Function FlagpoleGfxHandler
  Inputs: [X]
  Outputs: []
      Line 13263: FlagpoleGfxHandler: 
        Branch exit: Line 13305: ChkFlagOffscreen: 
        Line 13293: TYA 
        Line 13305: ChkFlagOffscreen: 
          Branch exit: Line 13331: ExitDumpSpr: 
          Line 13311: 
            Line 13314: MoveSixSpritesOffscreen:  (as a call, not in function)

Function DrawFirebar
  Inputs: [Y]
  Outputs: []
    Line 14240: DrawFirebar: 
      Branch exit: Line 14254: FireA: STA Sprite_Attributes,Y  ; store attribute byte and leave
      Line 14253: ORA #%11000000                  ; otherwise flip both ways every eight frames
      Line 14254: FireA: STA Sprite_Attributes,Y  ; store attribute byte and leave

Function WriteGameText
  Inputs: [A]
  Outputs: []
                          Line 1693: WriteGameText: 
                            Branch exit: Line 1705: LdGameText: LDX GameTextOffsets,Y; get offset to message we want to print
                            Line 1699: CPY #$08                        ; if set to do time-up or game over,
                              Branch exit: Line 1702: Chk2Players: LDA NumberOfPlayers; check for number of players
                              Line 1701: LDY #$08                        ; otherwise warp zone, therefore set offset
                              Line 1702: Chk2Players: LDA NumberOfPlayers; check for number of players
                                Branch exit: Line 1705: LdGameText: LDX GameTextOffsets,Y; get offset to message we want to print
                                Line 1704: INY                             ; otherwise increment offset by one to not print name
                            Line 1705: LdGameText: LDX GameTextOffsets,Y; get offset to message we want to print
                              Line 1707: GameTextLoop: LDA GameText,X    ; load message data
                                Branch exit: Line 1714: EndGameText: LDA #$00           ; put null terminator at end
                                Line 1710: STA VRAM_Buffer1,Y              ; otherwise write data to buffer
                                  Branch exit: Line 1707: GameTextLoop: LDA GameText,X    ; load message data
                                Line 1714: EndGameText: LDA #$00           ; put null terminator at end
                                  Branch exit: Line 1758: PrintWarpZoneNumbers: 
                                  Line 1720: DEX                             ; are we printing the world/lives display?
                                    Branch exit: Line 1739: CheckPlayerName: 
                                    Line 1722: LDA NumberofLives               ; otherwise, check number of lives
                                      Branch exit: Line 1730: PutLives: STA VRAM_Buffer1+8
                                      Line 1727: SBC #10                         ; if so, subtract 10 and put a crown tile
                                      Line 1730: PutLives: STA VRAM_Buffer1+8

Function PlayerEnemyDiff
  Inputs: [X]
  Outputs: [NegativeFlag]
    Line 12639: PlayerEnemyDiff: 

Function SetHiMax
  Inputs: []
  Outputs: []
  Line 7648: SetHiMax: LDA #$03              ; set maximum speed in A

Function DestroyBlockMetatile
  Inputs: []
  Outputs: []
    Line 2032: DestroyBlockMetatile: 
      Line 2035: WriteBlockMetatile:  (as a call, not in function)

Function IncSubtask
  Inputs: []
  Outputs: []
  Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function GetGfxOffsetAdder
  Inputs: [Y]
  Outputs: []
    Line 14684: GetGfxOffsetAdder: 
      Branch exit: Line 14691: SzOfs: RTS                      ; go back
      Line 14687: TYA                             ; for big player
      Line 14691: SzOfs: RTS                      ; go back

Function BulletBillCheepCheep
  Inputs: [X]
  Outputs: []
          Line 8689: BulletBillCheepCheep: 
            Branch exit: Line 8744: ExF17: RTS                      ; if found, leave
            Line 8692: LDA AreaType                    ; are we in a water-type level?
              Branch exit: Line 8734: DoBulletBills: 
              Line 8694: CPX #$03                        ; are we past third enemy slot?
                Branch exit: Line 8744: ExF17: RTS                      ; if found, leave
                Line 8696: LDY #$00                        ; load default offset
                  Branch exit: Line 8701: ChkW2: LDA WorldNumber          ; check world number
                  Line 8700: INY                             ; otherwise increment
                  Line 8701: ChkW2: LDA WorldNumber          ; check world number
                    Branch exit: Line 8705: Get17ID: TYA 
                    Line 8704: INY                             ; otherwise increment
                    Line 8705: Get17ID: TYA 

Function ScrollLockObject_Warp
  Inputs: []
  Outputs: []
    Line 3570: ScrollLockObject_Warp: 
      Branch exit: Line 3579: WarpNum: TXA 
      Line 3574: INX                             ; if world number > 1, increment for next warp zone (5)
        Branch exit: Line 3579: WarpNum: TXA 
        Line 3578: INX                             ; (8-7-6) and move on
      Line 3579: WarpNum: TXA 
        Line 3585: ScrollLockObject:  (as a call, not in function)

Function EndAreaPoints
  Inputs: []
  Outputs: []
  Line 10508: EndAreaPoints: 
    Branch exit: Line 10513: ELPGive: JSR DigitsMathRoutine  ; award 50 points per game timer interval
    Line 10512: LDY #$11                        ; otherwise load offset for luigi's score
    Line 10513: ELPGive: JSR DigitsMathRoutine  ; award 50 points per game timer interval
      Branch exit: Line 7117: UpdateNumber: 

Function ResetPalStar
  Inputs: []
  Outputs: []
    Line 5803: ResetPalStar: 

Function IncModeTask_B
  Inputs: []
  Outputs: []
  Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode

Function MoveObjectHorizontally
  Inputs: [X]
  Outputs: []
        Line 7545: MoveObjectHorizontally: 
          Branch exit: Line 7560: SaveXSpd: STA $00               ; save result here
          Line 7559: ORA #%11110000                  ; otherwise alter high nybble
          Line 7560: SaveXSpd: STA $00               ; save result here
            Branch exit: Line 7565: UseAdder: STY $02               ; save Y here
            Line 7564: DEY                             ; otherwise decrement Y
            Line 7565: UseAdder: STY $02               ; save Y here

Function BridgeCollapse
  Inputs: [$00]
  Outputs: []
      Line 10077: BridgeCollapse: 
        Branch exit: Line 10090: SetM2: LDA #Silence             ; silence music
        Line 10082: STX ObjectOffset                ; store as enemy offset here
          Branch exit: Line 10099: RemoveBridge: 
          Line 10085: AND #%01000000                  ; if bowser's state has d6 clear, skip to silence music
            Branch exit: Line 10090: SetM2: LDA #Silence             ; silence music
            Line 10087: LDA Enemy_Y_Position,X          ; check bowser's vertical coordinate
              Branch exit: Line 10095: MoveD_Bowser: 
        Line 10090: SetM2: LDA #Silence             ; silence music
          Branch exit: Line 10146: KillAllEnemies: 

Function AllUnder
  Inputs: [X]
  Outputs: []
  Line 3675: AllUnder: INX 
    Branch exit: Line 4252: RenderUnderPart: 

Function MoveRedPTroopa
  Inputs: [X, Y]
  Outputs: []
  Line 7622: MoveRedPTroopa: 
    Branch exit: Line 7698: RedPTroopaGrav: 

Function ReadyNextEnemy
  Inputs: [$01]
  Outputs: []
  Line 11616: ReadyNextEnemy: 
    Branch exit: Line 11574: ECLoop: STX $01                 ; save enemy object buffer offset for second enemy here
    Line 11622: 

Function GetProperObjOffset
  Inputs: [X, Y]
  Outputs: []
      Line 14851: GetProperObjOffset: 

Function CastleObject
  Inputs: [Y, X]
  Outputs: []
      Line 3716: CastleObject: 
        Line 3727: CRendLoop: LDA CastleMetatiles,Y; load current byte using offset
          Branch exit: Line 3738: ChkCFloor: CPX #$0b             ; have we reached the row just before floor?
          Line 3732: INY                             ; if not, increment column-wise
          Line 3738: ChkCFloor: CPX #$0b             ; have we reached the row just before floor?
            Branch exit: Line 3727: CRendLoop: LDA CastleMetatiles,Y; load current byte using offset
            Line 3740: PLA 
              Branch exit: Line 3770: ExitCastle: RTS 
              Line 3744: LDA AreaObjectLength,X          ; check length
                Branch exit: Line 3768: PlayerStop: LDY #$52            ; put brick at floor to stop player at end of level
                Line 3747: LDY $07                         ; check starting row for tall castle ($00)
                  Branch exit: Line 3751: NotTall: CMP #$02               ; if not tall castle, check to see if we're at the third column
                  Line 3749: CMP #$03                        ; if found, then check to see if we're at the second column
                    Branch exit: Line 3768: PlayerStop: LDY #$52            ; put brick at floor to stop player at end of level
                  Line 3751: NotTall: CMP #$02               ; if not tall castle, check to see if we're at the third column
                    Branch exit: Line 3770: ExitCastle: RTS 
                    Line 3753: JSR GetAreaObjXPosition         ; otherwise, obtain and save horizontal pixel coordinate
                Line 3768: PlayerStop: LDY #$52            ; put brick at floor to stop player at end of level
              Line 3770: ExitCastle: RTS 

Function RowOfCoins
  Inputs: []
  Outputs: []
      Line 4021: RowOfCoins: 
        Branch exit: Line 4076: GetRow: PHA                     ; store metatile here

Function QuestionBlockRow_Low
  Inputs: [X]
  Outputs: []
      Line 3927: QuestionBlockRow_Low: 

Function InitShortFirebar
  Inputs: [X]
  Outputs: []
          Line 8382: InitShortFirebar: 
            Branch exit: Line 8877: TallBBox2: LDA #$03             ; set specific value for bounding box control

Function MovePiranhaPlant
  Inputs: [X]
  Outputs: []
    Line 10581: MovePiranhaPlant: 
      Branch exit: Line 10635: PutinPipe: 
      Line 10584: LDA EnemyFrameTimer,X           ; check enemy's timer here
        Branch exit: Line 10635: PutinPipe: 
        Line 10586: LDA PiranhaPlant_MoveFlag,X     ; check movement flag
          Branch exit: Line 10611: SetupToMovePPlant: 
          Line 10588: LDA PiranhaPlant_Y_Speed,X      ; if currently rising, branch
            Branch exit: Line 10603: ReversePlantSpeed: 
            Line 10590: JSR PlayerEnemyDiff             ; get horizontal difference between player and
              Branch exit: Line 10598: ChkPlayerNearPipe: 
              Line 10592: LDA $00                         ; otherwise get saved horizontal difference
              Line 10598: ChkPlayerNearPipe: 
                Branch exit: Line 10635: PutinPipe: 
                Line 10602: 
            Line 10603: ReversePlantSpeed: 
          Line 10611: SetupToMovePPlant: 
            Branch exit: Line 10617: RiseFallPiranhaPlant: 
            Line 10615: LDA PiranhaPlantUpYPos,X        ; otherwise get other vertical coordinate (highest point)
            Line 10617: RiseFallPiranhaPlant: 
              Branch exit: Line 10635: PutinPipe: 
              Line 10622: LDA TimerControl                ; get master timer control
                Branch exit: Line 10635: PutinPipe: 
                Line 10624: LDA Enemy_Y_Position,X          ; get current vertical coordinate
                  Branch exit: Line 10635: PutinPipe: 
                  Line 10630: LDA #$00
      Line 10635: PutinPipe: 

Function EnemiesCollision
  Inputs: [X, Y]
  Outputs: []
        Line 11556: EnemiesCollision: 
          Branch exit: Line 11545: ExSFN: RTS 
          Line 11560: LDA AreaType
            Branch exit: Line 11545: ExSFN: RTS 
            Line 11562: LDA Enemy_ID,X
              Branch exit: Line 11623: ExitECRoutine: 
              Line 11565: CMP #Lakitu                     ; if lakitu, branch to leave
                Branch exit: Line 11623: ExitECRoutine: 
                Line 11567: CMP #PiranhaPlant               ; if piranha plant, branch to leave
                  Branch exit: Line 11623: ExitECRoutine: 
                  Line 11569: LDA EnemyOffscrBitsMasked,X     ; if masked offscreen bits nonzero, branch to leave
                    Branch exit: Line 11623: ExitECRoutine: 
                    Line 11571: JSR GetEnemyBoundBoxOfs         ; otherwise, do sub, get appropriate bounding box offset for
                      Branch exit: Line 11623: ExitECRoutine: 

Function SetFreq_Tri
  Inputs: [A]
  Outputs: []
          Line 15167: SetFreq_Tri: 
            Branch exit: Line 15145: Dump_Freq_Regs: 
            Line 15170: 
              Line 15173: SwimStompEnvelopeData: 
                Line 15177: PlayFlagpoleSlide:  (as a call, not in function)

Function OutputInter
  Inputs: [A]
  Outputs: []
  Line 1553: OutputInter: JSR WriteGameText

Function MoveJ_EnemyVertically
  Inputs: []
  Outputs: []
  Line 7646: MoveJ_EnemyVertically: 

Function CheckForCoinMTiles
  Inputs: [A]
  Outputs: [CarryFlag]
    Line 12375: CheckForCoinMTiles: 
      Branch exit: Line 12382: CoinSd: LDA #Sfx_CoinGrab
      Line 12378: CMP #$c3                        ; check for underwater coin
        Branch exit: Line 12382: CoinSd: LDA #Sfx_CoinGrab
        Line 12380: CLC                             ; otherwise clear carry and leave
      Line 12382: CoinSd: LDA #Sfx_CoinGrab

Function ShellOrBlockDefeat
  Inputs: [X]
  Outputs: []
  Line 11176: ShellOrBlockDefeat: 
    Branch exit: Line 11183: StnE: JSR ChkToStunEnemies      ; do yet another sub
    Line 11180: LDA Enemy_Y_Position,X
    Line 11183: StnE: JSR ChkToStunEnemies      ; do yet another sub
      Branch exit: Line 11194: GoombaPoints: 
      Line 11192: LDA #$06                        ; award 1000 points for hammer bro
      Line 11194: GoombaPoints: 
        Branch exit: Line 11199: EnemySmackScore: 
        Line 11197: LDA #$01                        ; award 100 points for goomba

Function SetupBubble
  Inputs: [X, $07]
  Outputs: []
          Line 6398: SetupBubble: 
            Branch exit: Line 6404: PosBubl: TYA                    ; use value loaded as adder
            Line 6403: LDY #$08                        ; otherwise load alternate value here
            Line 6404: PosBubl: TYA                    ; use value loaded as adder

Function Entrance_GameTimerSetup
  Inputs: [$07]
  Outputs: []
              Line 2837: Entrance_GameTimerSetup: 
                Branch exit: Line 2853: ChkStPos: STY SwimmingFlag
                Line 2852: INY 
                Line 2853: ChkStPos: STY SwimmingFlag
                  Branch exit: Line 2860: SetStPos: LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position
                  Line 2857: CPY #$01
                    Branch exit: Line 2860: SetStPos: LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position
                    Line 2859: LDX AltYPosOffset-2,Y           ; if not 0 or 1, override $0710 with new offset in X
                  Line 2860: SetStPos: LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position
                    Branch exit: Line 2879: ChkOverR: LDY JoypadOverride    ; if controller bits not set, branch to skip this part
                    Line 2869: LDA FetchNewGameTimerFlag       ; do we need to set the game timer? if not, use
                      Branch exit: Line 2879: ChkOverR: LDY JoypadOverride    ; if controller bits not set, branch to skip this part
                      Line 2871: LDA GameTimerData,Y             ; if game timer is set and game timer flag is also set,
                    Line 2879: ChkOverR: LDY JoypadOverride    ; if controller bits not set, branch to skip this part
                      Branch exit: Line 2890: ChkSwimE: LDY AreaType          ; if level not water-type,
                      Line 2881: LDA #$03                        ; set player state to climbing
                      Line 2890: ChkSwimE: LDY AreaType          ; if level not water-type,
                        Branch exit: Line 2893: SetPESub: LDA #$07              ; set to run player entrance subroutine
                        Line 2892: JSR SetupBubble                 ; otherwise, execute sub to set up air bubbles
                        Line 2893: SetPESub: LDA #$07              ; set to run player entrance subroutine

Function RunRetainerObj
  Inputs: []
  Outputs: []
    Line 9064: RunRetainerObj: 
      Branch exit: Line 13618: EnemyGfxHandler: 

Function ChkSwimYPos
  Inputs: [A, X]
  Outputs: []
  Line 9650: ChkSwimYPos: 
    Branch exit: Line 9661: YPDiff: CMP #$0f                ; if difference between original vs. current vertical
    Line 9657: LDY #$10                        ; otherwise load movement speed to downwards
    Line 9661: YPDiff: CMP #$0f                ; if difference between original vs. current vertical
      Branch exit: Line 9665: ExSwCC: RTS                     ; leave
      Line 9663: TYA 

Function DoEnemySideCheck
  Inputs: [X]
  Outputs: []
  Line 12596: DoEnemySideCheck: 
    Branch exit: Line 12615: ExESdeC: RTS 
    Line 12600: LDY #$16                        ; start by finding block to the left of enemy ($00,$14)
      Line 12603: SdeCLoop: LDA $eb               ; check value
        Branch exit: Line 12611: NextSdeC: DEC $eb               ; move to the next direction
        Line 12606: LDA #$01                        ; set flag in A for save horizontal coordinate
          Branch exit: Line 12611: NextSdeC: DEC $eb               ; move to the next direction
          Line 12609: JSR ChkForNonSolids             ; check for non-solid blocks
            Branch exit: Line 12617: ChkForBump_HammerBroJ: 
        Line 12611: NextSdeC: DEC $eb               ; move to the next direction
          Branch exit: Line 12603: SdeCLoop: LDA $eb               ; check value
    Line 12615: ExESdeC: RTS 

Function PlayerEndLevel
  Inputs: []
  Outputs: []
      Line 5835: PlayerEndLevel: 
        Branch exit: Line 5847: ChkStop: LDA Player_CollisionBits; get player collision bits
        Line 5841: LDA ScrollLock                  ; if scroll lock not set, branch ahead to next part
          Branch exit: Line 5847: ChkStop: LDA Player_CollisionBits; get player collision bits
          Line 5843: LDA #EndOfLevelMusic
        Line 5847: ChkStop: LDA Player_CollisionBits; get player collision bits
          Branch exit: Line 5855: RdyNextA: LDA StarFlagTaskControl
          Line 5850: LDA StarFlagTaskControl         ; if star flag task control already set,
            Branch exit: Line 5853: InCastle: LDA #%00100000        ; set player's background priority bit to
            Line 5852: INC StarFlagTaskControl         ; otherwise set task control now (this gets ball rolling!)
            Line 5853: InCastle: LDA #%00100000        ; set player's background priority bit to
          Line 5855: RdyNextA: LDA StarFlagTaskControl
            Branch exit: Line 5874: ExitNA: RTS 
            Line 5858: INC LevelNumber                 ; increment level number used for game logic
              Branch exit: Line 5867: NextArea: INC AreaNumber        ; increment area number used for address loader
              Line 5862: LDY WorldNumber                 ; get world number as offset
                Branch exit: Line 5867: NextArea: INC AreaNumber        ; increment area number used for address loader
                Line 5866: INC Hidden1UpFlag               ; otherwise set hidden 1-up box control flag

Function InitCheepCheep
  Inputs: [X]
  Outputs: []
    Line 8247: InitCheepCheep: 

Function FirebarSpin
  Inputs: [A, X]
  Outputs: [A]
    Line 10643: FirebarSpin: 
      Branch exit: Line 10656: SpinCounterClockwise: 
      Line 10647: LDY #$18                        ; possibly residual ldy

Function InjurePlayer
  Inputs: []
  Outputs: []
  Line 11405: InjurePlayer: 
    Branch exit: Line 11427: ExInjColRoutines: 
    Line 11408: 
      Line 11409: ForceInjury:  (as a call, not in function)

Function InitScroll
  Inputs: [A]
  Outputs: []
  Line 2501: InitScroll: STA PPU_SCROLL_REG  ; store contents of A into scroll registers

Function ChgAreaMode
  Inputs: []
  Outputs: [A]
  Line 5715: ChgAreaMode: INC DisableScreenFlag; set flag to disable screen output

Function HandleEnemyFBallCol
  Inputs: [$01]
  Outputs: []
      Line 11127: HandleEnemyFBallCol: 
        Branch exit: Line 11139: ChkBuzzyBeetle: 
        Line 11132: AND #%00001111                  ; otherwise mask out high nybble and
          Branch exit: Line 11146: HurtBowser: 
          Line 11137: LDX $01                         ; otherwise retrieve current enemy offset
        Line 11139: ChkBuzzyBeetle: 
          Branch exit: Line 11203: ExHCF: RTS                      ; and now let's leave
          Line 11143: CMP #Bowser                     ; check for bowser one more time (necessary if d7 of flag was clear)
            Branch exit: Line 11168: ChkOtherEnemies: 
            Line 11145: 
        Line 11146: HurtBowser: 
          Branch exit: Line 11203: ExHCF: RTS                      ; and now let's leave
          Line 11149: JSR InitVStf                    ; otherwise do sub to init vertical speed and movement force
            Branch exit: Line 11161: SetDBSte: STA Enemy_State,X     ; set defeated enemy state
            Line 11160: ORA #$03                        ; otherwise add 3 to enemy state
            Line 11161: SetDBSte: STA Enemy_State,X     ; set defeated enemy state
              Branch exit: Line 11199: EnemySmackScore: 
              Line 11167: 
        Line 11168: ChkOtherEnemies: 
          Branch exit: Line 11203: ExHCF: RTS                      ; and now let's leave
          Line 11171: CMP #Podoboo
            Branch exit: Line 11203: ExHCF: RTS                      ; and now let's leave
            Line 11173: CMP #$15
              Branch exit: Line 11203: ExHCF: RTS                      ; and now let's leave
              Line 11175: 

Function GetFireballBoundBox
  Inputs: [X]
  Outputs: []
      Line 12784: GetFireballBoundBox: 
        Branch exit: Line 12798: FBallB: JSR BoundingBoxCore     ; get bounding box coordinates
        Line 12791: 
          Line 12792: GetMiscBoundBox:  (as a call, not in function)
        Line 12798: FBallB: JSR BoundingBoxCore     ; get bounding box coordinates
          Branch exit: Line 12895: CheckRightScreenBBox: 

Function ProcBowserFlame
  Inputs: [X]
  Outputs: []
    Line 10328: ProcBowserFlame: 
      Branch exit: Line 10353: SetGfxF: JSR RelativeEnemyPosition; get new relative coordinates
      Line 10331: LDA #$40                        ; load default movement force
        Branch exit: Line 10335: SFlmX: STA $00                  ; store value here
        Line 10334: LDA #$60                        ; otherwise load alternate movement force to go faster
        Line 10335: SFlmX: STA $00                  ; store value here
          Branch exit: Line 10353: SetGfxF: JSR RelativeEnemyPosition; get new relative coordinates
          Line 10350: CLC 
      Line 10353: SetGfxF: JSR RelativeEnemyPosition; get new relative coordinates
        Branch exit: Line 10326: ExFl: RTS 
        Line 10356: LDA #$51                        ; otherwise, continue
          Branch exit: Line 10363: FlmeAt: STY $01                 ; set bowser's flame sprite attributes here
          Line 10362: LDY #$82                        ; otherwise write value with vertical flip bit set
          Line 10363: FlmeAt: STY $01                 ; set bowser's flame sprite attributes here
            Line 10367: DrawFlameLoop: 
              Branch exit: Line 10367: DrawFlameLoop: 
              Line 10387: LDX ObjectOffset                ; reload original enemy offset
                Branch exit: Line 10396: M3FOfs: PLA                     ; get bits from stack
                Line 10394: LDA #$f8                        ; otherwise move sprite offscreen, this part likely
                Line 10396: M3FOfs: PLA                     ; get bits from stack
                  Branch exit: Line 10402: M2FOfs: PLA                     ; get bits from stack again
                  Line 10400: LDA #$f8                        ; otherwise move third sprite offscreen
                  Line 10402: M2FOfs: PLA                     ; get bits from stack again
                    Branch exit: Line 10408: M1FOfs: PLA                     ; get bits from stack one last time
                    Line 10406: LDA #$f8                        ; otherwise move second sprite offscreen
                    Line 10408: M1FOfs: PLA                     ; get bits from stack one last time
                      Branch exit: Line 10413: ExFlmeD: RTS                    ; leave
                      Line 10411: LDA #$f8
                      Line 10413: ExFlmeD: RTS                    ; leave

Function OtherRope
  Inputs: [Y, $01, X, $00]
  Outputs: []
            Line 10779: OtherRope: 
              Branch exit: Line 10798: EraseR2: LDA #$24               ; put blank tiles in vram buffer
              Line 10793: LDA #$a2
                Branch exit: Line 10801: EndRp: LDA #$00                 ; put null terminator at the end
              Line 10798: EraseR2: LDA #$24               ; put blank tiles in vram buffer
              Line 10801: EndRp: LDA #$00                 ; put null terminator at the end (as a call, not in function)

Function HandleSquare2Music
  Inputs: []
  Outputs: []
  Line 15699: HandleSquare2Music: 
    Branch exit: Line 15753: MiscSqu2MusicTasks: 
    Line 15702: LDY MusicOffset_Square2         ; increment square 2 music offset and fetch data
      Branch exit: Line 15709: EndOfMusicData: 
      Line 15706: BPL Squ2NoteHandler             ; if non-negative, data is a note
        Branch exit: Line 15742: Squ2NoteHandler: 
        Line 15707: BNE Squ2LengthHandler           ; otherwise it is length data
          Branch exit: Line 15735: Squ2LengthHandler: 
          Line 15708: 
      Line 15709: EndOfMusicData: 
        Branch exit: Line 15715: NotTRO: AND #VictoryMusic       ; check for victory music (the only secondary that loops)
        Line 15713: LDA AreaMusicBuffer_Alt         ; load previously saved contents of primary buffer
          Branch exit: Line 15729: MusicLoopBack: 
        Line 15715: NotTRO: AND #VictoryMusic       ; check for victory music (the only secondary that loops)
          Branch exit: Line 15732: VictoryMLoopBack: 
          Line 15717: LDA AreaMusicBuffer             ; check primary buffer for any music except pipe intro
            Branch exit: Line 15729: MusicLoopBack: 
            Line 15720: LDA #$00                        ; clear primary and secondary buffers and initialize

Function Setup_Vine
  Inputs: [X, Y]
  Outputs: []
    Line 6681: Setup_Vine: 
      Branch exit: Line 6695: NextVO: TXA                     ; store object offset to next available vine slot
      Line 6694: STA VineStart_Y_Position        ; otherwise store vertical coordinate here
      Line 6695: NextVO: TXA                     ; store object offset to next available vine slot

Function BlockBumpedChk
  Inputs: [A]
  Outputs: [CarryFlag]
      Line 7372: BlockBumpedChk: 
        Line 7374: BumpChkLoop: CMP BrickQBlockMetatiles,Y; check to see if current metatile matches
          Branch exit: Line 7379: MatchBump: RTS                  ; note carry is set if found match
          Line 7376: DEY                             ; otherwise move onto next metatile
            Branch exit: Line 7374: BumpChkLoop: CMP BrickQBlockMetatiles,Y; check to see if current metatile matches
            Line 7378: CLC                             ; if none match, return with carry clear
          Line 7379: MatchBump: RTS                  ; note carry is set if found match

Function MoveDropPlatform
  Inputs: []
  Outputs: []
    Line 7635: MoveDropPlatform: 
      Branch exit: Line 7641: SetMdMax: LDA #$02              ; set maximum speed in A
      Line 7638: 

Function BlockBufferCollision
  Inputs: [A, Y, X]
  Outputs: [$02, A]
                Line 13057: BlockBufferCollision: 
                  Branch exit: Line 13090: RetXC: LDA SprObject_X_Position,X; otherwise load horizontal coordinate
                  Line 13088: LDA SprObject_Y_Position,X      ; if A = 0, load vertical coordinate
                    Branch exit: Line 13091: RetYC: AND #%00001111           ; and mask out high nybble
                  Line 13090: RetXC: LDA SprObject_X_Position,X; otherwise load horizontal coordinate
                  Line 13091: RetYC: AND #%00001111           ; and mask out high nybble (as a call, not in function)

Function ChkForLandJumpSpring
  Inputs: [CarryFlag, A]
  Outputs: []
    Line 12252: ChkForLandJumpSpring: 
      Branch exit: Line 12263: ExCJSp: RTS                     ; and leave
      Line 12255: LDA #$70
      Line 12263: ExCJSp: RTS                     ; and leave

Function StopPlayerMove
  Inputs: [$00]
  Outputs: []
  Line 12119: StopPlayerMove: 

Function MoveSixSpritesOffscreen
  Inputs: []
  Outputs: []
            Line 13314: MoveSixSpritesOffscreen: 
              Line 13317: DumpSixSpr:  (as a call, not in function)

Function VariableObjOfsRelPos
  Inputs: [X, A, Y]
  Outputs: [X]
  Line 14804: VariableObjOfsRelPos: 

Function SetAbsSpd
  Inputs: [A]
  Outputs: []
      Line 6269: SetAbsSpd: STA Player_XSpeedAbsolute; store walking/running speed here and leave

Function NoUnder
  Inputs: [$07]
  Outputs: []
  Line 3678: NoUnder: LDX $07                ; load row of ledge
    Branch exit: Line 4252: RenderUnderPart: 

Function IncAreaObjOffset
  Inputs: []
  Outputs: []
    Line 3365: IncAreaObjOffset: 

Function GetEnemyBoundBoxOfs
  Inputs: []
  Outputs: [A]
    Line 11884: GetEnemyBoundBoxOfs: 
      Line 11887: GetEnemyBoundBoxOfsArg:  (as a call, not in function)

Function EnemyToBGCollisionDet
  Inputs: [X, CarryFlag, $02, $04]
  Outputs: []
        Line 12405: EnemyToBGCollisionDet: 
          Branch exit: Line 12394: ExEBG: RTS                      ; leave
          Line 12409: JSR SubtEnemyYPos               ; otherwise, do a subroutine here
            Branch exit: Line 12394: ExEBG: RTS                      ; leave
            Line 12411: LDY Enemy_ID,X
              Branch exit: Line 12418: DoIDCheckBGColl: 
              Line 12414: LDA Enemy_Y_Position,X
                Branch exit: Line 12394: ExEBG: RTS                      ; leave
                Line 12417: 
              Line 12418: DoIDCheckBGColl: 
                Branch exit: Line 12422: HBChk: CPY #HammerBro           ; check for hammer bro
                Line 12421: JMP EnemyJump                   ; otherwise jump elsewhere
                  Branch exit: Line 12665: EnemyJump: 
                Line 12422: HBChk: CPY #HammerBro           ; check for hammer bro
                  Branch exit: Line 12425: CInvu: CPY #Spiny               ; if enemy object is spiny, branch
                  Line 12424: JMP HammerBroBGColl             ; otherwise jump elsewhere
                    Branch exit: Line 12684: HammerBroBGColl: 
                  Line 12425: CInvu: CPY #Spiny               ; if enemy object is spiny, branch
                    Branch exit: Line 12431: YesIn: JSR ChkUnderEnemy        ; if enemy object < $07, or = $12 or $2e, do this sub
                    Line 12427: CPY #PowerUpObject              ; if special power-up object, branch
                      Branch exit: Line 12431: YesIn: JSR ChkUnderEnemy        ; if enemy object < $07, or = $12 or $2e, do this sub
                      Line 12429: CPY #$07                        ; if enemy object =>$07, branch to leave
                        Branch exit: Line 12497: ExEBGChk: RTS 
                    Line 12431: YesIn: JSR ChkUnderEnemy        ; if enemy object < $07, or = $12 or $2e, do this sub
                      Branch exit: Line 12440: HandleEToBGCollision: 
                      Line 12433: 

Function ExitPipe
  Inputs: [X]
  Outputs: []
          Line 3814: ExitPipe: 
            Line 3819: RenderSidewaysPipe:  (as a call, not in function)

Function GetPlayerOffscreenBits
  Inputs: []
  Outputs: []
    Line 14825: GetPlayerOffscreenBits: 
      Branch exit: Line 14873: GetOffScreenBitsSet: 

Function PositionPlayerOnVPlat
  Inputs: [X]
  Outputs: []
        Line 11850: PositionPlayerOnVPlat:  (as a call, not in function)

Function NormObj
  Inputs: [A, X, $07]
  Outputs: []
            Line 3438: NormObj: STA $00                ; store value here (branch for small objects and rows 13 and 14)
              Branch exit: Line 3471: RunAObj: LDA $00                ; get stored value and add offset to it
              Line 3441: LDA AreaObjectPageLoc           ; otherwise check to see if the object we've loaded is on the
                Branch exit: Line 3452: InitRear: LDA BackloadingFlag   ; check backloading flag to see if it's been initialized
                Line 3444: LDY AreaDataOffset              ; if not, get old offset of level pointer
                  Branch exit: Line 3451: LeavePar: RTS 
                  Line 3449: LDA BackloadingFlag             ; if so, check backloading flag
                    Branch exit: Line 3468: StrAObj: LDA AreaDataOffset     ; if so, load area obj offset and store in buffer
                Line 3452: InitRear: LDA BackloadingFlag   ; check backloading flag to see if it's been initialized
                  Branch exit: Line 3459: BackColC: LDY AreaDataOffset    ; get first byte again
                  Line 3454: LDA #$00                        ; if not, initialize both backloading and
                    Line 3458: LoopCmdE: RTS  (as a call, not in function)
                  Line 3459: BackColC: LDY AreaDataOffset    ; get first byte again
                    Branch exit: Line 3451: LeavePar: RTS 
                Line 3468: StrAObj: LDA AreaDataOffset     ; if so, load area obj offset and store in buffer
              Line 3471: RunAObj: LDA $00                ; get stored value and add offset to it
                Line 3475: 
                  Line 3540: AlterAreaAttributes:  (as a call, not in function)

Function MovePlayerYAxis
  Inputs: [A]
  Outputs: []
    Line 5701: MovePlayerYAxis: 

Function MoveD_EnemyVertically
  Inputs: [X]
  Outputs: []
  Line 7603: MoveD_EnemyVertically: 
    Branch exit: Line 7611: ContVMove: JMP SetHiMax         ; jump to skip the rest of this
    Line 7608: 
      Line 7609: MoveFallingPlatform:  (as a call, not in function)
    Line 7611: ContVMove: JMP SetHiMax         ; jump to skip the rest of this
      Branch exit: Line 7648: SetHiMax: LDA #$03              ; set maximum speed in A

Function Jumpspring
  Inputs: [A, X, $07]
  Outputs: []
    Line 4151: Jumpspring: 

Function ProcHammerObj
  Inputs: [X]
  Outputs: []
    Line 6907: ProcHammerObj: 
      Branch exit: Line 6957: RunHSubs: JSR GetMiscOffscreenBits; get offscreen information
      Line 6910: LDA Misc_State,X                ; otherwise get hammer's state
        Branch exit: Line 6931: SetHSpd: LDA #$fe
        Line 6915: BCS SetHPos                     ; if greater than 2, branch elsewhere
          Branch exit: Line 6941: SetHPos: DEC Misc_State,X       ; decrement hammer's state
          Line 6916: TXA 
            Branch exit: Line 6956: RunAllH: JSR PlayerHammerCollision; handle collisions
        Line 6931: SetHSpd: LDA #$fe
        Line 6941: SetHPos: DEC Misc_State,X       ; decrement hammer's state
          Branch exit: Line 6957: RunHSubs: JSR GetMiscOffscreenBits; get offscreen information
        Line 6956: RunAllH: JSR PlayerHammerCollision; handle collisions (as a call, not in function)
      Line 6957: RunHSubs: JSR GetMiscOffscreenBits; get offscreen information (as a call, not in function)

Function LInj
  Inputs: [X]
  Outputs: []
  Line 11524: LInj: JSR EnemyTurnAround       ; turn the enemy around, if necessary
    Branch exit: Line 11405: InjurePlayer: 

Function GetFirebarPosition
  Inputs: [A, $00]
  Outputs: []
    Line 9875: GetFirebarPosition: 
      Branch exit: Line 9883: GetHAdder: STA $01              ; store result, modified or not, here
      Line 9880: EOR #%00001111                  ; otherwise get two's compliment to oscillate
      Line 9883: GetHAdder: STA $01              ; store result, modified or not, here
        Branch exit: Line 9901: GetVAdder: STA $02              ; store result here
        Line 9898: EOR #%00001111                  ; otherwise get two's compliment
        Line 9901: GetVAdder: STA $02              ; store result here

Function BlockObjectsCore
  Inputs: [X]
  Outputs: [X]
    Line 7447: BlockObjectsCore: 
      Branch exit: Line 7499: UpdSte: STA Block_State,X       ; store contents of A in block object state
      Line 7450: AND #$0f                        ; mask out high nybble
        Branch exit: Line 7485: BouncingBlockHandler: 
        Line 7459: JSR ImposeGravityBlock          ; do sub to impose gravity on one block object object
          Branch exit: Line 7499: UpdSte: STA Block_State,X       ; store contents of A in block object state
          Line 7474: PHA                             ; otherwise save state back into stack
            Branch exit: Line 7479: ChkTop: LDA Block_Y_Position,X  ; get top block object's vertical coordinate
            Line 7478: STA Block_Y_Position+2,X        ; otherwise set offscreen coordinate
            Line 7479: ChkTop: LDA Block_Y_Position,X  ; get top block object's vertical coordinate
              Branch exit: Line 7499: UpdSte: STA Block_State,X       ; store contents of A in block object state
              Line 7483: BCS KillBlock                   ; otherwise do unconditional branch to kill it
                Branch exit: Line 7498: KillBlock: LDA #$00             ; if branched here, nullify object state
                Line 7484: 
        Line 7485: BouncingBlockHandler: 
          Branch exit: Line 7499: UpdSte: STA Block_State,X       ; store contents of A in block object state
          Line 7496: LDA #$01
        Line 7498: KillBlock: LDA #$00             ; if branched here, nullify object state
      Line 7499: UpdSte: STA Block_State,X       ; store contents of A in block object state

Function Bridge_High
  Inputs: [X]
  Outputs: []
    Line 3939: Bridge_High: 
      Line 3943: Bridge_Middle: 
        Line 3947: Bridge_Low:  (as a call, not in function)

Function EndlessRope
  Inputs: []
  Outputs: []
    Line 3997: EndlessRope: 
      Branch exit: Line 4013: DrawRope: LDA #$40              ; render the actual rope

Function PutPlayerOnVine
  Inputs: [$06]
  Outputs: []
  Line 12210: PutPlayerOnVine: 
    Branch exit: Line 12223: SetVXPl: LDY PlayerFacingDir    ; get current facing direction, use as offset
    Line 12221: LDA #$02
    Line 12223: SetVXPl: LDY PlayerFacingDir    ; get current facing direction, use as offset
      Branch exit: Line 12238: ExPVne: RTS                     ; finally, we're done!
      Line 12234: LDA ScreenRight_PageLoc         ; load page location of right side of screen
      Line 12238: ExPVne: RTS                     ; finally, we're done!

Function GetSBNybbles
  Inputs: []
  Outputs: []
        Line 7113: GetSBNybbles: 

Function SetupIntermediate
  Inputs: []
  Outputs: []
    Line 1392: SetupIntermediate: 
      Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function DropPlatform
  Inputs: [X]
  Outputs: []
    Line 10956: DropPlatform: 
      Branch exit: Line 10961: ExDPl: RTS                      ; leave
      Line 10959: JSR MoveDropPlatform            ; otherwise do a sub to move platform down very quickly
      Line 10961: ExDPl: RTS                      ; leave

Function ChkForPlayerAttrib
  Inputs: []
  Outputs: []
    Line 14732: ChkForPlayerAttrib: 
      Branch exit: Line 14746: KilledAtt: LDA Sprite_Attributes+16,Y
      Line 14737: LDA PlayerGfxOffset             ; get graphics table offset
        Branch exit: Line 14753: C_S_IGAtt: LDA Sprite_Attributes+24,Y
        Line 14740: CMP #$b8                        ; or intermediate growing offset,
          Branch exit: Line 14753: C_S_IGAtt: LDA Sprite_Attributes+24,Y
          Line 14742: CMP #$c0                        ; fourth row OAM attributes only
            Branch exit: Line 14753: C_S_IGAtt: LDA Sprite_Attributes+24,Y
            Line 14744: CMP #$c8
              Branch exit: Line 14760: ExPlyrAt: RTS                   ; leave
      Line 14746: KilledAtt: LDA Sprite_Attributes+16,Y
      Line 14753: C_S_IGAtt: LDA Sprite_Attributes+24,Y
      Line 14760: ExPlyrAt: RTS                   ; leave

Function SetupEOffsetFBBox
  Inputs: [X]
  Outputs: []
  Line 12836: SetupEOffsetFBBox: 
    Branch exit: Line 12895: CheckRightScreenBBox: 

Function SetEntr
  Inputs: []
  Outputs: []
        Line 5681: SetEntr: LDA #$02               ; set starting position to override
          Branch exit: Line 5715: ChgAreaMode: INC DisableScreenFlag; set flag to disable screen output

Function LoadAreaPointer
  Inputs: [A]
  Outputs: [A]
      Line 4360: LoadAreaPointer: 
        Line 4363: GetAreaType: AND #%01100000     ; mask out all but d6 and d5 (as a call, not in function)

Function DecrementSfx1Length
  Inputs: []
  Outputs: []
  Line 15315: DecrementSfx1Length: 
    Branch exit: Line 15326: ExSfx1: RTS 
    Line 15318: 
      Line 15319: StopSquare1Sfx:  (as a call, not in function)
    Line 15326: ExSfx1: RTS  (as a call, not in function)

Function MoveWithXMCntrs
  Inputs: [X]
  Outputs: []
    Line 9447: MoveWithXMCntrs: 
      Branch exit: Line 9460: XMRight: STY Enemy_MovingDir,X  ; store as moving direction
      Line 9454: LDA XMoveSecondaryCounter,X
      Line 9460: XMRight: STY Enemy_MovingDir,X  ; store as moving direction

Function DrawBubble
  Inputs: [X]
  Outputs: []
    Line 14376: DrawBubble: 
      Branch exit: Line 14392: ExDBub: RTS                     ; leave
      Line 14380: LDA Bubble_OffscreenBits        ; check air bubble's offscreen bits
        Branch exit: Line 14392: ExDBub: RTS                     ; leave
        Line 14383: LDY Bubble_SprDataOffset,X      ; get air bubble's OAM data offset
      Line 14392: ExDBub: RTS                     ; leave

Function AnimationControl
  Inputs: [A]
  Outputs: []
  Line 14666: AnimationControl: 
    Branch exit: Line 14681: ExAnimC: PLA                    ; get offset to graphics table from stack and leave
    Line 14672: LDA PlayerAnimTimerSet          ; get animation frame timer amount
      Branch exit: Line 14680: SetAnimC: STA PlayerAnimCtrl    ; store as new animation frame control
      Line 14679: LDA #$00                        ; otherwise initialize frame control
      Line 14680: SetAnimC: STA PlayerAnimCtrl    ; store as new animation frame control
    Line 14681: ExAnimC: PLA                    ; get offset to graphics table from stack and leave

Function ClimbingSub
  Inputs: []
  Outputs: []
        Line 5970: ClimbingSub: 
          Branch exit: Line 5979: MoveOnVine: STY $00             ; store adder here
          Line 5978: DEY                             ; otherwise set adder to $ff
          Line 5979: MoveOnVine: STY $00             ; store adder here
            Branch exit: Line 6012: InitCSTimer: STA ClimbSideTimer ; initialize timer here
            Line 5988: LDY ClimbSideTimer              ; otherwise check timer
              Branch exit: Line 6011: ExitCSub: RTS                   ; then leave
              Line 5990: LDY #$18
                Branch exit: Line 5998: ClimbFD: DEY                    ; check to see if facing right
                Line 5996: INX 
                Line 5998: ClimbFD: DEY                    ; check to see if facing right
                  Branch exit: Line 6001: CSetFDir: LDA Player_X_Position
                  Line 6000: INX                             ; otherwise increment by 1 byte
                  Line 6001: CSetFDir: LDA Player_X_Position
              Line 6011: ExitCSub: RTS                   ; then leave
            Line 6012: InitCSTimer: STA ClimbSideTimer ; initialize timer here

Function FloateyNumbersRoutine
  Inputs: [X]
  Outputs: [X]
        Line 1282: FloateyNumbersRoutine: 
          Branch exit: Line 1245: EndExitOne: RTS                 ; and leave
          Line 1285: CMP #$0b                        ; if less than $0b, branch
            Branch exit: Line 1289: ChkNumTimer: TAY                ; use as Y
            Line 1287: LDA #$0b                        ; otherwise set to $0b, thus keeping
            Line 1289: ChkNumTimer: TAY                ; use as Y
              Branch exit: Line 1294: DecNumTimer: DEC FloateyNum_Timer,X; decrement value here
              Line 1292: STA FloateyNum_Control,X        ; initialize floatey number control and leave
              Line 1294: DecNumTimer: DEC FloateyNum_Timer,X; decrement value here
                Branch exit: Line 1312: ChkTallEnemy: LDY Enemy_SprDataOffset,X; get OAM data offset for enemy object
                Line 1297: CPY #$0b                        ; check offset for $0b
                  Branch exit: Line 1302: LoadNumTiles: LDA ScoreUpdateData,Y; load point value here
                  Line 1299: INC NumberofLives               ; give player one extra life (1-up)
                  Line 1302: LoadNumTiles: LDA ScoreUpdateData,Y; load point value here
                Line 1312: ChkTallEnemy: LDY Enemy_SprDataOffset,X; get OAM data offset for enemy object
                  Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                  Line 1316: CMP #PiranhaPlant
                    Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                    Line 1318: CMP #HammerBro
                      Branch exit: Line 1329: GetAltOffset: LDX SprDataOffset_Ctrl; load some kind of control bit
                      Line 1320: CMP #GreyCheepCheep
                        Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                        Line 1322: CMP #RedCheepCheep
                          Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                          Line 1324: CMP #TallEnemy
                            Branch exit: Line 1329: GetAltOffset: LDX SprDataOffset_Ctrl; load some kind of control bit
                            Line 1326: LDA Enemy_State,X
                              Branch exit: Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                      Line 1329: GetAltOffset: LDX SprDataOffset_Ctrl; load some kind of control bit
                  Line 1332: FloateyPart: LDA FloateyNum_Y_Pos,X; get vertical coordinate for
                    Branch exit: Line 1337: SetupNumSpr: LDA FloateyNum_Y_Pos,X; get vertical coordinate
                    Line 1335: SBC #$01
                    Line 1337: SetupNumSpr: LDA FloateyNum_Y_Pos,X; get vertical coordinate

Function CoinBlock
  Inputs: [X, Y, CarryFlag]
  Outputs: []
    Line 6967: CoinBlock: 
      Branch exit: Line 6993: JCoinC: LDA #$fb

Function GameTimerFireworks
  Inputs: [X]
  Outputs: []
                Line 10470: GameTimerFireworks: 
                  Branch exit: Line 10482: SetFWC: STA FireworksCounter    ; set fireworks counter here
                  Line 10475: LDY #$03                        ; otherwise load new value for state
                    Branch exit: Line 10482: SetFWC: STA FireworksCounter    ; set fireworks counter here
                    Line 10478: LDY #$00                        ; otherwise load one more potential value for state
                      Branch exit: Line 10482: SetFWC: STA FireworksCounter    ; set fireworks counter here
                      Line 10481: LDA #$ff                        ; otherwise set value for no fireworks
                  Line 10482: SetFWC: STA FireworksCounter    ; set fireworks counter here

Function LargePlatformCollision
  Inputs: [X, Y]
  Outputs: []
    Line 11713: LargePlatformCollision: 
      Branch exit: Line 11741: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
      Line 11718: LDA Enemy_State,X               ; if d7 set in object state,
        Branch exit: Line 11741: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
        Line 11720: LDA Enemy_ID,X
          Branch exit: Line 11727: ChkForPlayerC_LargeP: 
          Line 11723: LDA Enemy_State,X
          Line 11727: ChkForPlayerC_LargeP:  (as a call, not in function)
      Line 11741: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave (as a call, not in function)

Function ChkInvisibleMTiles
  Inputs: [A]
  Outputs: [ZeroFlag]
    Line 12242: ChkInvisibleMTiles: 
      Branch exit: Line 12246: ExCInvT: RTS                    ; leave with zero flag set if either found
      Line 12245: CMP #$60                        ; check for hidden 1-up block
      Line 12246: ExCInvT: RTS                    ; leave with zero flag set if either found

Function FindAreaPointer
  Inputs: []
  Outputs: [A]
    Line 4371: FindAreaPointer: 

Function NullJoypad
  Inputs: []
  Outputs: []
                Line 1021: NullJoypad: LDA #$00            ; clear joypad bits for player 1

Function SpawnHammerObj
  Inputs: []
  Outputs: [CarryFlag]
        Line 6877: SpawnHammerObj: 
          Branch exit: Line 6883: SetMOfs: TAY                    ; use either d3 or d2-d0 for offset here
          Line 6881: LDA PseudoRandomBitReg+1
          Line 6883: SetMOfs: TAY                    ; use either d3 or d2-d0 for offset here
            Branch exit: Line 6898: NoHammer: LDX ObjectOffset      ; get original enemy object offset
            Line 6886: LDX HammerEnemyOfsData,Y        ; get offset of enemy slot to check using Y as offset
              Branch exit: Line 6898: NoHammer: LDX ObjectOffset      ; get original enemy object offset
              Line 6889: LDX ObjectOffset                ; get original enemy object offset
            Line 6898: NoHammer: LDX ObjectOffset      ; get original enemy object offset

Function XMovingPlatform
  Inputs: [X]
  Outputs: []
    Line 10931: XMovingPlatform: 
      Branch exit: Line 10952: ExXMP: RTS                      ; and we are done here
      Line 10937: 
        Line 10938: PositionPlayerOnHPlat:  (as a call, not in function)
      Line 10952: ExXMP: RTS                      ; and we are done here (as a call, not in function)

Function PlaySqu2Sfx
  Inputs: [X, Y]
  Outputs: []
    Line 15160: PlaySqu2Sfx: 
      Line 15163: SetFreq_Squ2:  (as a call, not in function)

Function CheckTopOfBlock
  Inputs: [$02, $06]
  Outputs: [$05, CarryFlag]
    Line 7399: CheckTopOfBlock: 
      Branch exit: Line 7416: TopEx: RTS                      ; leave!
      Line 7403: TYA                             ; otherwise set to A
        Branch exit: Line 7416: TopEx: RTS                      ; leave!
        Line 7411: LDA #$00
      Line 7416: TopEx: RTS                      ; leave!

Function SetAttrib
  Inputs: [Y, $03, $00, $01, $04, $05]
  Outputs: []
        Line 1863: SetAttrib: LDA AttributeBuffer,Y; get previously saved bits from before
          Branch exit: Line 1814: DrawMTLoop: STX $01             ; store init value of 0 or incremented offset for buffer
          Line 1872: LDY $00                         ; get current vram buffer offset, increment by 3
            Branch exit: Line 1888: ExitDrawM: JMP SetVRAMCtrl      ; jump to set buffer to $0341 and leave
            Line 1883: LDA #$80                        ; if wraparound occurs, make sure low byte stays
            Line 1888: ExitDrawM: JMP SetVRAMCtrl      ; jump to set buffer to $0341 and leave
              Branch exit: Line 1936: SetVRAMCtrl: LDA #$06

Function RowOfBricks
  Inputs: []
  Outputs: []
        Line 4065: RowOfBricks: 
          Branch exit: Line 4070: DrawBricks: LDA BrickMetatiles,Y; get appropriate metatile
          Line 4069: LDY #$04                        ; if cloud type, override area type
          Line 4070: DrawBricks: LDA BrickMetatiles,Y; get appropriate metatile
            Branch exit: Line 4076: GetRow: PHA                     ; store metatile here

Function StarBlock
  Inputs: []
  Outputs: []
              Line 7346: StarBlock:  (as a call, not in function)

Function ScrollScreen
  Inputs: [Y]
  Outputs: []
                Line 5406: ScrollScreen: 
                  Branch exit: Line 5432: ChkPOffscr: LDX #$00            ; set X for player offset

Function PosJSpr
  Inputs: [X, Y]
  Outputs: []
            Line 6648: PosJSpr: LDA Jumpspring_FixedYPos,X; get permanent vertical position
              Branch exit: Line 6661: BounceJS: CPY #$03              ; check frame control offset again
              Line 6654: LDA A_B_Buttons
                Branch exit: Line 6661: BounceJS: CPY #$03              ; check frame control offset again
                Line 6657: AND PreviousA_B_Buttons         ; check for A button pressed in previous frame
                  Branch exit: Line 6661: BounceJS: CPY #$03              ; check frame control offset again
                  Line 6659: LDA #$f4
              Line 6661: BounceJS: CPY #$03              ; check frame control offset again
                Branch exit: Line 6667: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
                Line 6663: LDA JumpspringForce

Function MoveFlyGreenPTroopa
  Inputs: [X]
  Outputs: []
    Line 9406: MoveFlyGreenPTroopa: 
      Branch exit: Line 9422: NoMGPT: RTS                     ; leave!
      Line 9413: LDA FrameCounter
        Branch exit: Line 9417: YSway: STY $00                  ; store adder here
        Line 9416: LDY #$ff                        ; otherwise set Y to move green paratroopa up
        Line 9417: YSway: STY $00                  ; store adder here
      Line 9422: NoMGPT: RTS                     ; leave!

Function GetRow2
  Inputs: [A, $07, X]
  Outputs: []
  Line 4091: GetRow2: PHA                    ; save metatile to stack for now
    Branch exit: Line 4252: RenderUnderPart: 

Function MoveVOffset
  Inputs: [Y]
  Outputs: []
          Line 2054: MoveVOffset: DEY                ; decrement vram buffer offset
            Branch exit: Line 1476: SetVRAMOffset: STA VRAM_Buffer1_Offset; store as new vram buffer offset

Function InitRedKoopa
  Inputs: [X]
  Outputs: []
    Line 8181: InitRedKoopa: 

Function RelativeFireballPosition
  Inputs: [X]
  Outputs: []
    Line 14776: RelativeFireballPosition: 

Function ImposeGravitySprObj
  Inputs: [A]
  Outputs: []
  Line 7670: ImposeGravitySprObj: 
    Branch exit: Line 7708: ImposeGravity: 

Function KillEnemyAboveBlock
  Inputs: [X]
  Outputs: []
        Line 12690: KillEnemyAboveBlock: 

Function ImpedePlayerMove
  Inputs: [$00]
  Outputs: []
  Line 12322: ImpedePlayerMove: 
    Branch exit: Line 12333: RImpd: LDX #$02                 ; return $02 to X
    Line 12328: INX                             ; return value to X
      Branch exit: Line 12351: ExIPM: TXA                      ; invert contents of X
      Line 12331: LDA #$ff                        ; otherwise load A with value to be used later
        Branch exit: Line 12337: NXSpd: LDY #$10
    Line 12333: RImpd: LDX #$02                 ; return $02 to X
      Branch exit: Line 12351: ExIPM: TXA                      ; invert contents of X
      Line 12336: LDA #$01                        ; otherwise load A with value to be used here
    Line 12337: NXSpd: LDY #$10 (as a call, not in function)
    Line 12351: ExIPM: TXA                      ; invert contents of X (as a call, not in function)

Function NXSpd
  Inputs: [A, X]
  Outputs: []
    Line 12337: NXSpd: LDY #$10
      Branch exit: Line 12344: PlatF: STY $00                  ; store Y as high bits of horizontal adder
      Line 12343: DEY                             ; otherwise decrement Y now
      Line 12344: PlatF: STY $00                  ; store Y as high bits of horizontal adder

Function PlayerGfxProcessing
  Inputs: [A]
  Outputs: []
  Line 14490: PlayerGfxProcessing: 
    Branch exit: Line 14514: PlayerOffscreenChk: 
    Line 14497: LDY #$00                        ; set value to initialize by default
      Branch exit: Line 14514: PlayerOffscreenChk: 
      Line 14502: STA FireballThrowingTimer       ; otherwise store animation timer into fireball throw timer
        Branch exit: Line 14511: SUpdR: TYA                      ; save in A for use
        Line 14510: DEY                             ; otherwise set to update only three sprite rows
        Line 14511: SUpdR: TYA                      ; save in A for use
    Line 14514: PlayerOffscreenChk: 
      Line 14526: PROfsLoop: LDA #$f8             ; load offscreen Y coordinate just in case
        Branch exit: Line 14530: NPROffscr: TYA 
        Line 14529: JSR DumpTwoSpr                  ; otherwise dump offscreen Y coordinate into sprite data
        Line 14530: NPROffscr: TYA 
          Branch exit: Line 14526: PROfsLoop: LDA #$f8             ; load offscreen Y coordinate just in case
          Line 14536: RTS                             ; then we are done!

Function InitBlock_XY_Pos
  Inputs: [X]
  Outputs: []
    Line 7295: InitBlock_XY_Pos: 

Function InitHoriPlatform
  Inputs: [X]
  Outputs: []
    Line 8911: InitHoriPlatform: 
      Branch exit: Line 8934: CommonPlatCode: 

Function DrawPowerUp
  Inputs: []
  Outputs: []
        Line 13488: DrawPowerUp: 
          Line 13509: PUpDrawLoop: 
            Branch exit: Line 13509: PUpDrawLoop: 
            Line 13516: LDY Enemy_SprDataOffset+5       ; get sprite data offset again
              Branch exit: Line 13541: PUpOfs: JMP SprObjectOffscrChk  ; jump to check to see if power-up is offscreen at all, then leave
              Line 13519: CMP #$03
                Branch exit: Line 13541: PUpOfs: JMP SprObjectOffscrChk  ; jump to check to see if power-up is offscreen at all, then leave
                Line 13521: STA $00                         ; store power-up type here now
                  Branch exit: Line 13534: FlipPUpRightSide: 
                  Line 13531: STA Sprite_Attributes+8,Y       ; otherwise set new palette bits  for bottom left
                  Line 13534: FlipPUpRightSide: 
              Line 13541: PUpOfs: JMP SprObjectOffscrChk  ; jump to check to see if power-up is offscreen at all, then leave
                Branch exit: Line 14023: SprObjectOffscrChk: 

Function ReadPortBits
  Inputs: [A, X]
  Outputs: []
      Line 2428: ReadPortBits: LDY #$08
        Line 2429: PortLoop: PHA                   ; push previous bit onto stack
          Branch exit: Line 2429: PortLoop: PHA                   ; push previous bit onto stack
          Line 2439: STA SavedJoypadBits,X           ; save controller status here always
            Branch exit: Line 2448: Save8Bits: PLA 
            Line 2444: PLA 
            Line 2448: Save8Bits: PLA 

Function DrawEnemyObjRow
  Inputs: [X]
  Outputs: []
    Line 14067: DrawEnemyObjRow: 
      Line 14072: DrawOneSpriteRow:  (as a call, not in function)

Function RunBowser
  Inputs: [X]
  Outputs: []
      Line 10138: RunBowser: 
        Branch exit: Line 10155: BowserControl: 
        Line 10142: LDA Enemy_Y_Position,X          ; otherwise check vertical position
          Branch exit: Line 10095: MoveD_Bowser: 
          Line 10145: 

Function AreaParserTaskControl
  Inputs: []
  Outputs: []
    Line 1569: AreaParserTaskControl: 
      Line 1571: TaskLoop: JSR AreaParserTaskHandler; render column set of current area
        Branch exit: Line 1571: TaskLoop: JSR AreaParserTaskHandler; render column set of current area
        Line 1574: DEC ColumnSets                  ; do we need to render more column sets?
          Branch exit: Line 1577: OutputCol: LDA #$06             ; set vram buffer to output rendered column set
          Line 1576: INC ScreenRoutineTask           ; if not, move on to the next task
          Line 1577: OutputCol: LDA #$06             ; set vram buffer to output rendered column set

Function OutputNumbers
  Inputs: [A]
  Outputs: []
    Line 2538: OutputNumbers: 
      Branch exit: Line 2578: ExitOutputN: RTS 
      Line 2544: PHA                             ; save incremented value to stack for now and
        Branch exit: Line 2552: SetupNums: STA VRAM_Buffer1,X
        Line 2551: LDA #$22                        ; if so, put further down on the screen
        Line 2552: SetupNums: STA VRAM_Buffer1,X
          Line 2566: DigitPLoop: LDA DisplayDigits,Y ; write digits to the buffer
            Branch exit: Line 2566: DigitPLoop: LDA DisplayDigits,Y ; write digits to the buffer
            Line 2572: LDA #$00                        ; put null terminator at end
      Line 2578: ExitOutputN: RTS 

Function GetPlayerAnimSpeed
  Inputs: []
  Outputs: []
      Line 6199: GetPlayerAnimSpeed: 
        Branch exit: Line 6215: SetRunSpd: STA RunningSpeed     ; store zero or running speed here
        Line 6204: INY                             ; otherwise increment Y
          Branch exit: Line 6208: ChkSkid: LDA SavedJoypadBits    ; get controller bits
          Line 6207: INY                             ; otherwise increment Y again
          Line 6208: ChkSkid: LDA SavedJoypadBits    ; get controller bits
            Branch exit: Line 6225: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset
            Line 6211: AND #$03                        ; mask out all others except left and right
              Branch exit: Line 6217: ProcSkid: LDA Player_XSpeedAbsolute; check player's walking/running speed
              Line 6214: LDA #$00                        ; otherwise set zero value here
              Line 6217: ProcSkid: LDA Player_XSpeedAbsolute; check player's walking/running speed
                Branch exit: Line 6225: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset
                Line 6220: LDA PlayerFacingDir
        Line 6215: SetRunSpd: STA RunningSpeed     ; store zero or running speed here
          Branch exit: Line 6225: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset
        Line 6225: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset (as a call, not in function)

Function Square1SfxHandler
  Inputs: []
  Outputs: []
                      Line 15235: Square1SfxHandler: 
                        Branch exit: Line 15255: CheckSfx1Buffer: 
                        Line 15238: STY Square1SoundBuffer          ; if found, put in buffer
                          Branch exit: Line 15185: PlaySmallJump: 
                          Line 15240: LSR Square1SoundQueue
                            Branch exit: Line 15189: PlayBigJump: 
                            Line 15242: LSR Square1SoundQueue
                              Branch exit: Line 15218: PlayBump: 
                              Line 15244: LSR Square1SoundQueue
                                Branch exit: Line 15275: PlaySwimStomp: 
                                Line 15246: LSR Square1SoundQueue
                                  Branch exit: Line 15295: PlaySmackEnemy: 
                                  Line 15248: LSR Square1SoundQueue
                                    Branch exit: Line 15328: PlayPipeDownInj: 
                                    Line 15250: LSR Square1SoundQueue
                                      Branch exit: Line 15213: PlayFireballThrow: 
                                      Line 15252: LSR Square1SoundQueue
                                        Branch exit: Line 15177: PlayFlagpoleSlide: 
                                        Line 15254: 
                        Line 15255: CheckSfx1Buffer: 
                          Branch exit: Line 15273: ExS1H: RTS 
                          Line 15258: BMI ContinueSndJump             ; small mario jump
                            Branch exit: Line 15199: ContinueSndJump: 
                            Line 15259: LSR 
                              Branch exit: Line 15199: ContinueSndJump: 
                              Line 15261: LSR 
                                Branch exit: Line 15226: ContinueBumpThrow: 
                                Line 15263: LSR 
                                  Branch exit: Line 15283: ContinueSwimStomp: 
                                  Line 15265: LSR 
                                    Branch exit: Line 15304: ContinueSmackEnemy: 
                                    Line 15267: LSR 
                                      Branch exit: Line 15332: ContinuePipeDownInj: 
                                      Line 15269: LSR 
                                        Branch exit: Line 15226: ContinueBumpThrow: 
                                        Line 15271: LSR 
                                          Branch exit: Line 15315: DecrementSfx1Length: 
                          Line 15273: ExS1H: RTS 

Function XMoveCntr_Platform
  Inputs: [A, X]
  Outputs: []
      Line 9427: XMoveCntr_Platform: 
        Branch exit: Line 9439: NoIncXM: RTS 
        Line 9432: LDY XMoveSecondaryCounter,X     ; get secondary counter
          Branch exit: Line 9442: DecSeXM: TYA                    ; put secondary counter in A
          Line 9436: CPY $01                         ; compare secondary counter to preset maximum value
            Branch exit: Line 9440: IncPXM: INC XMovePrimaryCounter,X; increment primary counter and leave
            Line 9438: INC XMoveSecondaryCounter,X     ; increment secondary counter and leave
          Line 9440: IncPXM: INC XMovePrimaryCounter,X; increment primary counter and leave
          Line 9442: DecSeXM: TYA                    ; put secondary counter in A
            Branch exit: Line 9440: IncPXM: INC XMovePrimaryCounter,X; increment primary counter and leave
            Line 9444: DEC XMoveSecondaryCounter,X     ; otherwise decrement secondary counter and leave
        Line 9439: NoIncXM: RTS 

Function PlayerCtrlRoutine
  Inputs: [$04, $02, $06]
  Outputs: []
  Line 5562: PlayerCtrlRoutine: 
    Branch exit: Line 5594: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
    Line 5566: LDA AreaType                    ; are we in a water type area?
      Branch exit: Line 5576: SaveJoyp: LDA SavedJoypadBits   ; otherwise store A and B buttons in $0a
      Line 5568: LDY Player_Y_HighPos
        Branch exit: Line 5574: DisJoyp: LDA #$00               ; disable controller bits
        Line 5571: LDA Player_Y_Position
          Branch exit: Line 5576: SaveJoyp: LDA SavedJoypadBits   ; otherwise store A and B buttons in $0a
        Line 5574: DisJoyp: LDA #$00               ; disable controller bits
      Line 5576: SaveJoyp: LDA SavedJoypadBits   ; otherwise store A and B buttons in $0a
        Branch exit: Line 5594: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
        Line 5587: LDA Player_State                ; check player's state
          Branch exit: Line 5594: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
          Line 5589: LDY Left_Right_Buttons          ; check left and right
            Branch exit: Line 5594: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
            Line 5591: LDA #$00
    Line 5594: SizeChk: JSR PlayerMovementSubs ; run movement subroutines
      Branch exit: Line 5602: ChkMoveDir: STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control
      Line 5598: LDY #$00                        ; check for if crouching
        Branch exit: Line 5602: ChkMoveDir: STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control
        Line 5601: LDY #$02                        ; if big and crouching, load y with 2
      Line 5602: ChkMoveDir: STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control
        Branch exit: Line 5609: PlayerSubs: JSR ScrollHandler   ; move the screen if necessary
        Line 5606: BPL SetMoveDir                  ; if moving to the right, use default moving direction
          Branch exit: Line 5608: SetMoveDir: STA Player_MovingDir; set moving direction
          Line 5607: ASL                             ; otherwise change to move to the left
          Line 5608: SetMoveDir: STA Player_MovingDir; set moving direction
        Line 5609: PlayerSubs: JSR ScrollHandler   ; move the screen if necessary
          Branch exit: Line 5628: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
          Line 5618: LDA GameEngineSubroutine
            Branch exit: Line 5628: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
            Line 5621: CMP #$07                        ; if running player entrance routine, branch ahead
              Branch exit: Line 5628: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
              Line 5623: CMP #$04                        ; if running routines $00-$03, branch ahead
                Branch exit: Line 5628: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
                Line 5625: LDA Player_SprAttrib
          Line 5628: PlayerHole: LDA Player_Y_HighPos; check player's vertical high byte
            Branch exit: Line 5659: ExitCtrl: RTS                   ; leave
            Line 5631: LDX #$01
              Branch exit: Line 5640: HoleDie: INX                    ; set flag in X for player death
              Line 5638: LDY CloudTypeOverride           ; check for cloud type override
                Branch exit: Line 5651: ChkHoleX: CMP $07               ; compare vertical high byte with value set here
              Line 5640: HoleDie: INX                    ; set flag in X for player death
                Branch exit: Line 5651: ChkHoleX: CMP $07               ; compare vertical high byte with value set here
                Line 5644: LDY DeathMusicLoaded            ; check value here
                  Branch exit: Line 5649: HoleBottom: LDY #$06
                  Line 5646: INY 
                  Line 5649: HoleBottom: LDY #$06
              Line 5651: ChkHoleX: CMP $07               ; compare vertical high byte with value set here
                Branch exit: Line 5659: ExitCtrl: RTS                   ; leave
                Line 5653: DEX                             ; otherwise decrement flag in X
                  Branch exit: Line 5661: CloudExit: 
                  Line 5655: LDY EventMusicBuffer            ; check to see if music is still playing
                    Branch exit: Line 5659: ExitCtrl: RTS                   ; leave
                    Line 5657: LDA #$06                        ; otherwise set to run lose life routine
            Line 5659: ExitCtrl: RTS                   ; leave

Function DrawSpriteObject
  Inputs: [$03, $00, Y, $01, $04, $02, $05, X]
  Outputs: []
  Line 15004: DrawSpriteObject: 
    Branch exit: Line 15015: NoHFlip: STA Sprite_Tilenumber,Y; store first tile into first sprite
    Line 15010: STA Sprite_Tilenumber+4,Y       ; store first tile into second sprite
      Branch exit: Line 15019: SetHFAt: ORA $04                ; add other OAM attributes if necessary
    Line 15015: NoHFlip: STA Sprite_Tilenumber,Y; store first tile into first sprite
    Line 15019: SetHFAt: ORA $04                ; add other OAM attributes if necessary

Function PauseRoutine
  Inputs: []
  Outputs: []
    Line 850: PauseRoutine: 
      Branch exit: Line 859: ChkPauseTimer: LDA GamePauseTimer; check if pause timer is still counting down
      Line 854: CMP #GameModeValue              ; are we in game mode?
        Branch exit: Line 881: ExitPause: RTS 
        Line 856: LDA OperMode_Task               ; if we are in game mode, are we running game engine?
          Branch exit: Line 881: ExitPause: RTS 
      Line 859: ChkPauseTimer: LDA GamePauseTimer; check if pause timer is still counting down
        Branch exit: Line 863: ChkStart: LDA SavedJoypad1Bits  ; check to see if start is pressed
        Line 861: DEC GamePauseTimer              ; if so, decrement and leave
        Line 863: ChkStart: LDA SavedJoypad1Bits  ; check to see if start is pressed
          Branch exit: Line 878: ClrPauseTimer: LDA GamePauseStatus; clear timer flag if timer is at zero and start button
          Line 866: LDA GamePauseStatus             ; check to see if timer flag is set
            Branch exit: Line 881: ExitPause: RTS 
            Line 869: LDA #$2b                        ; set pause timer
              Branch exit: Line 880: SetPause: STA GamePauseStatus
          Line 878: ClrPauseTimer: LDA GamePauseStatus; clear timer flag if timer is at zero and start button
          Line 880: SetPause: STA GamePauseStatus
      Line 881: ExitPause: RTS 

Function DuplicateEnemyObj
  Inputs: [X]
  Outputs: []
    Line 8530: DuplicateEnemyObj: 
      Line 8532: FSLoop: INY                     ; increment one slot
        Branch exit: Line 8532: FSLoop: INY                     ; increment one slot
        Line 8535: STY DuplicateObj_Offset         ; otherwise set offset here

Function CheckDefeatedState
  Inputs: []
  Outputs: []
  Line 13872: CheckDefeatedState: 
    Branch exit: Line 13884: DrawEnemyObject: 
    Line 13876: LDA $ef
      Branch exit: Line 13884: DrawEnemyObject: 
      Line 13879: LDY #$01

Function EmptyBlock
  Inputs: [$07, X]
  Outputs: []
    Line 4049: EmptyBlock: 

Function CheckpointEnemyID
  Inputs: [X]
  Outputs: []
  Line 8059: CheckpointEnemyID: 
    Branch exit: Line 8071: InitEnemyRoutines: 
    Line 8063: TAY                             ; save identifier in Y register for now
    Line 8071: InitEnemyRoutines: 
      Line 8073: 
        Line 8137: NoInitCode:  (as a call, not in function)

Function GetAlternatePalette1
  Inputs: []
  Outputs: []
    Line 1481: GetAlternatePalette1: 
      Branch exit: Line 1487: NoAltPal: JMP IncSubtask        ; now onto the next task
      Line 1485: LDA #$0b                        ; if found, load appropriate palette

Function DrawPlayer_Intermediate
  Inputs: [$07]
  Outputs: []
      Line 14543: DrawPlayer_Intermediate: 
        Line 14545: PIntLoop: LDA IntermediatePlayerData,X; load data to display player as he always
          Branch exit: Line 14545: PIntLoop: LDA IntermediatePlayerData,X; load data to display player as he always
          Line 14549: LDX #$b8                        ; load offset for small standing

Function JCoinGfxHandler
  Inputs: [X]
  Outputs: []
      Line 13442: JCoinGfxHandler: 
        Branch exit: Line 13418: DrawFloateyNumber_Coin: 
        Line 13447: LDA Misc_Y_Position,X           ; store vertical coordinate as

Function RedPTroopaGrav
  Inputs: [A, X, $00, $02, $01]
  Outputs: []
  Line 7698: RedPTroopaGrav: 

Function VerticalPipe
  Inputs: [$00, Y, X, $07, $06, CarryFlag]
  Outputs: []
      Line 3847: VerticalPipe: 
        Branch exit: Line 3855: WarpPipe: TYA                   ; save value in stack
        Line 3851: INY 
        Line 3855: WarpPipe: TYA                   ; save value in stack
          Branch exit: Line 3879: DrawPipe: PLA                   ; get value saved earlier and use as Y
          Line 3860: LDY AreaObjectLength,X          ; if on second column of pipe, branch
            Branch exit: Line 3879: DrawPipe: PLA                   ; get value saved earlier and use as Y
            Line 3862: JSR FindEmptyEnemySlot          ; check for an empty moving data buffer space
              Branch exit: Line 3879: DrawPipe: PLA                   ; get value saved earlier and use as Y
              Line 3864: JSR GetAreaObjXPosition         ; get horizontal pixel coordinate
          Line 3879: DrawPipe: PLA                   ; get value saved earlier and use as Y
            Branch exit: Line 4252: RenderUnderPart: 

Function TallBBox2
  Inputs: []
  Outputs: []
  Line 8877: TallBBox2: LDA #$03             ; set specific value for bounding box control

Function LargePlatformSubroutines
  Inputs: [X]
  Outputs: []
    Line 9161: LargePlatformSubroutines: 
      Line 9166: 

Function GetEnemyBoundBoxOfsArg
  Inputs: [A]
  Outputs: [CarryFlag]
      Line 11887: GetEnemyBoundBoxOfsArg: 

Function RightPlatform
  Inputs: [A, X]
  Outputs: []
    Line 10966: RightPlatform: 
      Branch exit: Line 10974: ExRPl: RTS                      ; then leave
      Line 10971: LDA #$10
      Line 10974: ExRPl: RTS                      ; then leave

Function MiscObjectsCore
  Inputs: []
  Outputs: []
    Line 7017: MiscObjectsCore: 

Function InitBowser
  Inputs: [X]
  Outputs: []
    Line 8508: InitBowser: 

Function StarFlagExit
  Inputs: []
  Outputs: []
  Line 10488: StarFlagExit: 

Function BlockObjMT_Updater
  Inputs: []
  Outputs: []
    Line 7506: BlockObjMT_Updater: 
      Line 7508: UpdateLoop: STX ObjectOffset    ; set offset here
        Branch exit: Line 7525: NextBUpd: DEX                   ; decrement block object offset
        Line 7511: LDA Block_RepFlag,X             ; if flag for block object already clear,
          Branch exit: Line 7525: NextBUpd: DEX                   ; decrement block object offset
          Line 7513: LDA Block_BBuf_Low,X            ; get low byte of block buffer
        Line 7525: NextBUpd: DEX                   ; decrement block object offset
          Branch exit: Line 7508: UpdateLoop: STX ObjectOffset    ; set offset here
          Line 7527: RTS                             ; then leave

Function SetXMoveAmt
  Inputs: [Y, X, A]
  Outputs: []
  Line 7649: SetXMoveAmt: STY $00            ; set movement amount here

Function RelativePlayerPosition
  Inputs: []
  Outputs: []
    Line 14765: RelativePlayerPosition: 
      Branch exit: Line 14780: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function InitChangeSize
  Inputs: []
  Outputs: []
  Line 5757: InitChangeSize: 
    Branch exit: Line 5765: ExitBoth: RTS                   ; leave
    Line 5760: STY PlayerAnimCtrl              ; otherwise initialize player's animation frame control

Function InitScreen
  Inputs: []
  Outputs: []
        Line 1382: InitScreen: 
          Branch exit: Line 1417: NextSubtask: JMP IncSubtask     ; move onto next task
          Line 1387: LDX #$03                        ; into buffer pointer
            Branch exit: Line 1416: SetVRAMAddr_A: STX VRAM_Buffer_AddrCtrl; store offset into buffer control

Function ReadJoypads
  Inputs: []
  Outputs: []
    Line 2420: ReadJoypads: 
      Line 2428: ReadPortBits: LDY #$08 (as a call, not in function)

Function MoveRedPTroopaDown
  Inputs: []
  Outputs: []
  Line 7615: MoveRedPTroopaDown: 
    Branch exit: Line 7622: MoveRedPTroopa: 

Function VineObjectHandler
  Inputs: [X, $02]
  Outputs: []
      Line 6709: VineObjectHandler: 
        Branch exit: Line 6759: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
        Line 6712: LDY VineFlagOffset
          Branch exit: Line 6725: RunVSubs: LDA VineHeight        ; if vine still very small,
          Line 6717: LDA FrameCounter                ; get frame counter
            Branch exit: Line 6725: RunVSubs: LDA VineHeight        ; if vine still very small,
            Line 6721: LDA Enemy_Y_Position+5
          Line 6725: RunVSubs: LDA VineHeight        ; if vine still very small,
            Branch exit: Line 6759: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
            Line 6728: JSR RelativeEnemyPosition       ; get relative coordinates of vine,
              Line 6731: VDrawLoop: JSR DrawVine         ; draw vine
                Branch exit: Line 6731: VDrawLoop: JSR DrawVine         ; draw vine
                Line 6735: LDA Enemy_OffscreenBits
                  Branch exit: Line 6745: WrCMTile: LDA VineHeight        ; check vine height
                  Line 6738: DEY                             ; otherwise decrement Y to get proper offset again
                    Line 6739: KillVine: LDX VineObjOffset,Y   ; get enemy object offset for this vine object
                      Branch exit: Line 6739: KillVine: LDX VineObjOffset,Y   ; get enemy object offset for this vine object
                      Line 6743: STA VineFlagOffset              ; initialize vine flag/offset
                  Line 6745: WrCMTile: LDA VineHeight        ; check vine height
                    Branch exit: Line 6759: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
                    Line 6748: LDX #$06                        ; set offset in X to last enemy slot
                      Branch exit: Line 6759: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
                      Line 6755: LDA ($06),Y                     ; otherwise check contents of block buffer at
                        Branch exit: Line 6759: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave
                        Line 6757: LDA #$26
        Line 6759: ExitVH: LDX ObjectOffset        ; get enemy object offset and leave

Function ResetScreenTimer
  Inputs: []
  Outputs: []
        Line 1783: ResetScreenTimer: 

Function InitLakitu
  Inputs: []
  Outputs: []
    Line 8258: InitLakitu: 
      Branch exit: Line 8268: KillLakitu: 
      Line 8261: 
        Line 8262: SetupLakitu:  (as a call, not in function)

Function PositionPlayerOnS_Plat
  Inputs: [A, X]
  Outputs: []
      Line 11843: PositionPlayerOnS_Plat: 
        Line 11850: PositionPlayerOnVPlat: 
          Branch exit: Line 11867: ExPlPos: RTS 
          Line 11855: LDY Enemy_Y_HighPos,X
            Branch exit: Line 11867: ExPlPos: RTS 
            Line 11858: SEC                             ; subtract 32 pixels from vertical coordinate
          Line 11867: ExPlPos: RTS 

Function DoOtherPlatform
  Inputs: [X, $01, $00]
  Outputs: []
    Line 10737: DoOtherPlatform: 
      Branch exit: Line 10750: DrawEraseRope: 
      Line 10747: TAX                             ; put offset which collision occurred here
      Line 10750: DrawEraseRope: 
        Branch exit: Line 10807: ExitRp: LDX ObjectOffset        ; get enemy object buffer offset and leave
        Line 10755: LDX VRAM_Buffer1_Offset         ; get vram buffer offset
          Branch exit: Line 10807: ExitRp: LDX ObjectOffset        ; get enemy object buffer offset and leave
          Line 10758: LDA Enemy_Y_Speed,Y
            Branch exit: Line 10775: EraseR1: LDA #$24               ; put blank tiles in vram buffer
            Line 10770: LDA #$a2
              Branch exit: Line 10779: OtherRope: 
            Line 10775: EraseR1: LDA #$24               ; put blank tiles in vram buffer
            Line 10779: OtherRope:  (as a call, not in function)
        Line 10807: ExitRp: LDX ObjectOffset        ; get enemy object buffer offset and leave (as a call, not in function)

Function EnemiesAndLoopsCore
  Inputs: [X]
  Outputs: [X]
    Line 7767: EnemiesAndLoopsCore: 
      Branch exit: Line 7780: ChkBowserF: PLA                 ; get data from stack
      Line 7772: PLA                             ; get from stack
        Branch exit: Line 7775: ChkAreaTsk: LDA AreaParserTaskNum; check number of tasks to perform
        Line 7774: JMP RunEnemyObjectsCore         ; otherwise, jump to run enemy subroutines
          Branch exit: Line 9009: RunEnemyObjectsCore: 
        Line 7775: ChkAreaTsk: LDA AreaParserTaskNum; check number of tasks to perform
          Branch exit: Line 7786: ExitELCore: RTS 
          Line 7779: JMP ProcLoopCommand             ; otherwise, jump to process loop command/load enemies
            Branch exit: Line 7830: ProcLoopCommand: 
      Line 7780: ChkBowserF: PLA                 ; get data from stack
        Branch exit: Line 7786: ExitELCore: RTS 
        Line 7785: STA Enemy_Flag,X                ; if second enemy flag not set, also clear first one
      Line 7786: ExitELCore: RTS 

Function ProcLPlatCollisions
  Inputs: [Y, X]
  Outputs: []
    Line 11786: ProcLPlatCollisions: 
      Branch exit: Line 11797: ChkForTopCollision: 
      Line 11792: LDA Player_Y_Speed              ; check to see if player's vertical speed is moving down
        Branch exit: Line 11797: ChkForTopCollision: 
        Line 11794: LDA #$01                        ; otherwise, set vertical
      Line 11797: ChkForTopCollision: 
        Branch exit: Line 11820: PlatformSideCollisions: 
        Line 11803: LDA Player_Y_Speed
          Branch exit: Line 11820: PlatformSideCollisions: 
          Line 11805: LDA $00                         ; get saved bounding box counter from earlier
            Branch exit: Line 11813: SetCollisionFlag: 
            Line 11809: CPY #$2c                        ; as contents of collision flag
              Branch exit: Line 11813: SetCollisionFlag: 
              Line 11811: TXA                             ; otherwise use enemy object buffer offset
            Line 11813: SetCollisionFlag: 

Function RenderSidewaysPipe
  Inputs: [Y, X]
  Outputs: [CarryFlag]
            Line 3819: RenderSidewaysPipe: 
              Branch exit: Line 3834: DrawSidePart: LDY $06           ; render side pipe part at the bottom
              Line 3830: LDX #$00
              Line 3834: DrawSidePart: LDY $06           ; render side pipe part at the bottom

Function EraseEnemyObject
  Inputs: [X]
  Outputs: []
  Line 9177: EraseEnemyObject: 

Function HandleClimbing
  Inputs: [$04, A]
  Outputs: []
  Line 12157: HandleClimbing: 
    Branch exit: Line 12163: ExHC: RTS                       ; leave if too far left or too far right
    Line 12161: CPY #$0a                        ; than 16 pixels
      Branch exit: Line 12165: ChkForFlagpole: 
    Line 12163: ExHC: RTS                       ; leave if too far left or too far right

Function SetD6Ste
  Inputs: [A, X]
  Outputs: []
      Line 12590: SetD6Ste: STA Enemy_State,X     ; set as new state

Function MoveESprRowOffscreen
  Inputs: [A, X]
  Outputs: []
    Line 14076: MoveESprRowOffscreen: 
      Branch exit: Line 13327: DumpTwoSpr: 

Function GetAreaMusic
  Inputs: []
  Outputs: []
      Line 2797: GetAreaMusic: 
        Branch exit: Line 2815: ExitGetM: RTS 
        Line 2800: LDA AltEntranceControl          ; check for specific alternate mode of entry
          Branch exit: Line 2809: ChkAreaType: LDY AreaType       ; load area type as offset for music bit
          Line 2803: LDY #$05                        ; select music for pipe intro scene by default
            Branch exit: Line 2813: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
            Line 2807: CMP #$07                        ; start position either value $06 or $07
              Branch exit: Line 2813: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
          Line 2809: ChkAreaType: LDY AreaType       ; load area type as offset for music bit
            Branch exit: Line 2813: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
            Line 2812: LDY #$04                        ; select music for cloud type level if found
          Line 2813: StoreMusic: LDA MusicSelectData,Y; otherwise select appropriate music for level type
        Line 2815: ExitGetM: RTS 

Function DisplayTimeUp
  Inputs: []
  Outputs: []
    Line 1527: DisplayTimeUp: 
      Branch exit: Line 1534: NoTimeUp: INC ScreenRoutineTask ; increment control task 2 tasks forward
      Line 1530: LDA #$00
        Branch exit: Line 1553: OutputInter: JSR WriteGameText
      Line 1534: NoTimeUp: INC ScreenRoutineTask ; increment control task 2 tasks forward
        Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function TreeLedge
  Inputs: [X, Y, $07]
  Outputs: []
        Line 3632: TreeLedge: 
          Branch exit: Line 3649: EndTreeL: LDA #$18              ; render end of tree ledge
          Line 3636: BPL MidTreeL
            Branch exit: Line 3644: MidTreeL: LDX $07
            Line 3637: TYA 
              Branch exit: Line 3644: MidTreeL: LDX $07
              Line 3642: LDA #$16                        ; render start of tree ledge
                Branch exit: Line 3678: NoUnder: LDX $07                ; load row of ledge
            Line 3644: MidTreeL: LDX $07
              Branch exit: Line 3675: AllUnder: INX 
          Line 3649: EndTreeL: LDA #$18              ; render end of tree ledge
            Branch exit: Line 3678: NoUnder: LDX $07                ; load row of ledge

Function Dump_Squ1_Regs
  Inputs: [Y, X]
  Outputs: []
    Line 15134: Dump_Squ1_Regs: 

Function SetPVar
  Inputs: [A, Y, X]
  Outputs: []
          Line 10949: SetPVar: STA Player_PageLoc     ; save result to player's page location

Function PlayerPhysicsSub
  Inputs: []
  Outputs: []
                      Line 6046: PlayerPhysicsSub: 
                        Branch exit: Line 6068: CheckForJumping: 
                        Line 6050: LDY #$00
                          Branch exit: Line 6058: ProcClimb: LDX Climb_Y_MForceData,Y; load value here
                          Line 6054: INY 
                            Branch exit: Line 6058: ProcClimb: LDX Climb_Y_MForceData,Y; load value here
                            Line 6057: INY 
                          Line 6058: ProcClimb: LDX Climb_Y_MForceData,Y; load value here
                            Branch exit: Line 6065: SetCAnim: STA PlayerAnimTimerSet; store animation timer setting and leave
                            Line 6064: LSR                             ; otherwise divide timer setting by 2
                            Line 6065: SetCAnim: STA PlayerAnimTimerSet; store animation timer setting and leave

Function StoreNewD
  Inputs: [A, Y, X]
  Outputs: []
          Line 2593: StoreNewD: STA DisplayDigits,Y  ; store as new score or game timer digit
            Branch exit: Line 2587: AddModLoop: LDA DigitModifier,X ; load digit amount to increment

Function DumpFourSpr
  Inputs: [A, Y]
  Outputs: []
                Line 13321: DumpFourSpr: 
                  Line 13324: DumpThreeSpr:  (as a call, not in function)

Function VerticalPipeEntry
  Inputs: []
  Outputs: []
    Line 5687: VerticalPipeEntry: 
      Branch exit: Line 5712: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area
      Line 5694: INY 
        Branch exit: Line 5712: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area
        Line 5698: INY 
          Branch exit: Line 5712: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area

Function HandleChangeSize
  Inputs: []
  Outputs: []
      Line 14697: HandleChangeSize: 
        Branch exit: Line 14708: GorSLog: LDA PlayerSize         ; get player's size
        Line 14702: INY                             ; increment frame control
          Branch exit: Line 14707: CSzNext: STY PlayerAnimCtrl     ; store proper frame control
          Line 14705: LDY #$00                        ; otherwise initialize both grow/shrink flag
          Line 14707: CSzNext: STY PlayerAnimCtrl     ; store proper frame control
        Line 14708: GorSLog: LDA PlayerSize         ; get player's size
          Branch exit: Line 14720: ShrinkPlayer: 
          Line 14710: LDA ChangeSizeOffsetAdder,Y     ; get offset adder based on frame control as offset

Function GetAreaType
  Inputs: [A]
  Outputs: [A]
        Line 4363: GetAreaType: AND #%01100000     ; mask out all but d6 and d5

Function DrawQBlk
  Inputs: [Y, X]
  Outputs: []
  Line 4202: DrawQBlk: LDA BrickQBlockMetatiles,Y; get appropriate metatile for brick (question block
    Branch exit: Line 4078: DrawRow: LDX $07

Function HandleCoinMetatile
  Inputs: [$02]
  Outputs: []
  Line 12126: HandleCoinMetatile: 
    Branch exit: Line 7088: GiveOneCoin: 

Function ErACM
  Inputs: [$02]
  Outputs: []
    Line 12138: ErACM: LDY $02                  ; load vertical high nybble offset for block buffer
      Branch exit: Line 2015: RemoveCoin_Axe: 

Function PlaySqu1Sfx
  Inputs: [Y, X]
  Outputs: []
    Line 15139: PlaySqu1Sfx: 
      Line 15142: SetFreq_Squ1:  (as a call, not in function)

Function DrawMushroomIcon
  Inputs: []
  Outputs: []
      Line 1067: DrawMushroomIcon: 
        Line 1069: IconDataRead: LDA MushroomIconData,Y; note that the default position is set for a
          Branch exit: Line 1069: IconDataRead: LDA MushroomIconData,Y; note that the default position is set for a
          Line 1073: LDA NumberOfPlayers             ; check number of players
            Branch exit: Line 1079: ExitIcon: RTS 
            Line 1075: LDA #$24                        ; otherwise, load blank tile in 1-player position
            Line 1079: ExitIcon: RTS 

Function ChkToStunEnemies
  Inputs: [A, X]
  Outputs: []
        Line 12459: ChkToStunEnemies: 
          Branch exit: Line 12470: SetStun: LDA Enemy_State,X      ; load enemy state
          Line 12462: CMP #$11                        ; if the enemy object identifier is equal to the values
            Branch exit: Line 12470: SetStun: LDA Enemy_State,X      ; load enemy state
            Line 12464: CMP #$0a                        ; modified if not any of those values, note that piranha plant will
              Branch exit: Line 12468: Demote: AND #%00000001          ; erase all but LSB, essentially turning enemy object
              Line 12466: CMP #PiranhaPlant               ; coordinate from previous addition, also these comparisons
                Branch exit: Line 12470: SetStun: LDA Enemy_State,X      ; load enemy state
              Line 12468: Demote: AND #%00000001          ; erase all but LSB, essentially turning enemy object
          Line 12470: SetStun: LDA Enemy_State,X      ; load enemy state (as a call, not in function)

Function ChgAreaPipe
  Inputs: [Y]
  Outputs: []
  Line 5712: ChgAreaPipe: DEC ChangeAreaTimer; decrement timer for change of area
    Branch exit: Line 5719: ExitCAPipe: RTS                 ; leave
    Line 5714: STY AltEntranceControl          ; when timer expires set mode of alternate entry

Function FlagpoleRoutine
  Inputs: []
  Outputs: []
        Line 6583: FlagpoleRoutine: 
          Branch exit: Line 6625: ExitFlagP: RTS 
          Line 6589: LDA GameEngineSubroutine
            Branch exit: Line 6614: SkipScore: JMP FPGfx            ; jump to skip ahead and draw flag and floatey number
            Line 6592: LDA Player_State
              Branch exit: Line 6614: SkipScore: JMP FPGfx            ; jump to skip ahead and draw flag and floatey number
              Line 6595: LDA Enemy_Y_Position,X          ; check flagpole flag's vertical coordinate
                Branch exit: Line 6615: GiveFPScr: LDY FlagpoleScore    ; get score offset from earlier (when player touched flagpole)
                Line 6598: LDA Player_Y_Position           ; check player's vertical coordinate
                  Branch exit: Line 6615: GiveFPScr: LDY FlagpoleScore    ; get score offset from earlier (when player touched flagpole)
                  Line 6601: LDA Enemy_YMF_Dummy,X
                Line 6615: GiveFPScr: LDY FlagpoleScore    ; get score offset from earlier (when player touched flagpole)
            Line 6614: SkipScore: JMP FPGfx            ; jump to skip ahead and draw flag and floatey number
              Branch exit: Line 6622: FPGfx: JSR GetEnemyOffscreenBits; get offscreen information
            Line 6622: FPGfx: JSR GetEnemyOffscreenBits; get offscreen information (as a call, not in function)
          Line 6625: ExitFlagP: RTS  (as a call, not in function)

Function PlayerMovementSubs
  Inputs: []
  Outputs: []
    Line 5878: PlayerMovementSubs: 
      Branch exit: Line 5886: SetCrouch: STA CrouchingFlag    ; store value in crouch flag
      Line 5882: LDA Player_State                ; check state of player
        Branch exit: Line 5887: ProcMove: JSR PlayerPhysicsSub  ; run sub related to jumping and swimming
        Line 5884: LDA Up_Down_Buttons             ; load controller bits for up and down
      Line 5886: SetCrouch: STA CrouchingFlag    ; store value in crouch flag
      Line 5887: ProcMove: JSR PlayerPhysicsSub  ; run sub related to jumping and swimming
        Branch exit: Line 5902: NoMoveSub: RTS 
        Line 5890: LDA Player_State
          Branch exit: Line 5895: MoveSubs: JSR JumpEngine
          Line 5893: LDY #$18
          Line 5895: MoveSubs: JSR JumpEngine
            Line 5896: 
        Line 5902: NoMoveSub: RTS 

Function GetBlockOffscreenBits
  Inputs: []
  Outputs: []
    Line 14863: GetBlockOffscreenBits: 

Function MoveHammerBroXDir
  Inputs: [X]
  Outputs: []
  Line 9280: MoveHammerBroXDir: 
    Branch exit: Line 9286: Shimmy: STY Enemy_X_Speed,X     ; store horizontal speed
    Line 9285: LDY #$04                        ; if d6 set in counter, move him a little to the right
    Line 9286: Shimmy: STY Enemy_X_Speed,X     ; store horizontal speed
      Branch exit: Line 9295: SetShim: STY Enemy_MovingDir,X  ; set moving direction
      Line 9290: INY                             ; set to face left
        Branch exit: Line 9295: SetShim: STY Enemy_MovingDir,X  ; set moving direction
        Line 9293: LDA #$f8
      Line 9295: SetShim: STY Enemy_MovingDir,X  ; set moving direction
        Line 9297: MoveNormalEnemy:  (as a call, not in function)

Function null
  Inputs: []
  Outputs: []
  Line 0:                                 ; SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
    Line 673: Start: 
      Line 680: VBlank1: LDA PPU_STATUS         ; wait two frames
        Branch exit: Line 680: VBlank1: LDA PPU_STATUS         ; wait two frames
        Line 682: VBlank2: LDA PPU_STATUS
          Branch exit: Line 682: VBlank2: LDA PPU_STATUS
          Line 684: LDY #ColdBootOffset             ; load default cold boot pointer
            Line 686: WBootCheck: LDA TopScoreDisplay,X; check each score digit in the top score
              Branch exit: Line 695: ColdBoot: JSR InitializeMemory  ; clear memory using pointer in Y
              Line 689: DEX 
                Branch exit: Line 686: WBootCheck: LDA TopScoreDisplay,X; check each score digit in the top score
                Line 691: LDA WarmBootValidation          ; second checkpoint, check to see if
                  Branch exit: Line 695: ColdBoot: JSR InitializeMemory  ; clear memory using pointer in Y
                  Line 694: LDY #WarmBootOffset             ; if passed both, load warm boot pointer
              Line 695: ColdBoot: JSR InitializeMemory  ; clear memory using pointer in Y
                Line 711: EndlessLoop: JMP EndlessLoop    ; endless loop, need I say more? (as a call, not in function)

Function Next3Slt
  Inputs: [X]
  Outputs: []
  Line 6819: Next3Slt: DEX                   ; move onto next slot
    Branch exit: Line 6771: ThreeSChk: STX ObjectOffset     ; start at third enemy slot

Function OnGroundStateSub
  Inputs: []
  Outputs: []
    Line 5907: OnGroundStateSub: 
      Branch exit: Line 5912: GndMove: JSR ImposeFriction     ; do a sub to impose friction on player's walk/run
      Line 5911: STA PlayerFacingDir             ; otherwise set new facing direction
      Line 5912: GndMove: JSR ImposeFriction     ; do a sub to impose friction on player's walk/run

Function MoveBloober
  Inputs: [X]
  Outputs: []
      Line 9472: MoveBloober: 
        Branch exit: Line 9521: MoveDefeatedBloober: 
        Line 9476: LDY SecondaryHardMode           ; use secondary hard mode flag as offset
          Branch exit: Line 9491: BlooberSwim: 
          Line 9480: TXA 
            Branch exit: Line 9485: FBLeft: LDY #$02                ; set left moving direction by default
            Line 9483: LDY Player_MovingDir            ; otherwise, load player's moving direction and
              Branch exit: Line 9489: SBMDir: STY Enemy_MovingDir,X   ; set moving direction of bloober, then continue on here
            Line 9485: FBLeft: LDY #$02                ; set left moving direction by default
              Branch exit: Line 9489: SBMDir: STY Enemy_MovingDir,X   ; set moving direction of bloober, then continue on here
              Line 9488: DEY                             ; otherwise decrement to set right moving direction
            Line 9489: SBMDir: STY Enemy_MovingDir,X   ; set moving direction of bloober, then continue on here
          Line 9491: BlooberSwim: 
            Branch exit: Line 9499: SwimX: LDY Enemy_MovingDir,X    ; check moving direction
            Line 9498: STA Enemy_Y_Position,X          ; otherwise, set new vertical position, make bloober swim
            Line 9499: SwimX: LDY Enemy_MovingDir,X    ; check moving direction
              Branch exit: Line 9511: LeftSwim: 
              Line 9502: LDA Enemy_X_Position,X

Function SubtEnemyYPos
  Inputs: [X]
  Outputs: [CarryFlag]
    Line 12658: SubtEnemyYPos: 

Function GetMiscOffscreenBits
  Inputs: [X]
  Outputs: []
    Line 14842: GetMiscOffscreenBits: 
      Branch exit: Line 14873: GetOffScreenBitsSet: 

Function SetupLakitu
  Inputs: []
  Outputs: []
        Line 8262: SetupLakitu: 
          Branch exit: Line 8877: TallBBox2: LDA #$03             ; set specific value for bounding box control

Function GetAreaObjYPosition
  Inputs: [$07]
  Outputs: [A]
    Line 4315: GetAreaObjYPosition: 

Function ImposeGravityBlock
  Inputs: []
  Outputs: []
        Line 7664: ImposeGravityBlock: 

Function PlayerEnemyCollision
  Inputs: [X]
  Outputs: []
  Line 11297: PlayerEnemyCollision: 
    Branch exit: Line 11284: NoPUp: RTS 
    Line 11301: JSR CheckPlayerVertical         ; if player object is completely offscreen or
      Branch exit: Line 11318: NoPECol: RTS 
      Line 11303: LDA EnemyOffscrBitsMasked,X     ; if current enemy is offscreen by any amount,
        Branch exit: Line 11318: NoPECol: RTS 
        Line 11305: LDA GameEngineSubroutine
          Branch exit: Line 11318: NoPECol: RTS 
          Line 11308: LDA Enemy_State,X
            Branch exit: Line 11318: NoPECol: RTS 
            Line 11311: JSR GetEnemyBoundBoxOfs         ; get bounding box offset for current enemy object
              Branch exit: Line 11320: CheckForPUpCollision: 
              Line 11315: LDA Enemy_CollisionBits,X
      Line 11318: NoPECol: RTS 

Function DrawFireball
  Inputs: [X]
  Outputs: []
  Line 14233: DrawFireball: 
    Line 14240: DrawFirebar:  (as a call, not in function)

Function PrintStatusBarNumbers
  Inputs: [A]
  Outputs: []
  Line 2529: PrintStatusBarNumbers: 
    Line 2538: OutputNumbers:  (as a call, not in function)

Function BulletBillHandler
  Inputs: [X, $00]
  Outputs: []
      Line 6828: BulletBillHandler: 
        Branch exit: Line 6860: RunBBSubs: JSR GetEnemyOffscreenBits; get offscreen information
        Line 6831: LDA Enemy_State,X
          Branch exit: Line 6855: ChkDSte: LDA Enemy_State,X      ; check enemy state for d5 set
          Line 6833: LDA Enemy_OffscreenBits         ; otherwise load offscreen bits
            Branch exit: Line 6865: KillBB: JSR EraseEnemyObject    ; kill bullet bill and leave
            Line 6837: LDY #$01                        ; set to move right by default
              Branch exit: Line 6841: SetupBB: STY Enemy_MovingDir,X  ; set bullet bill's moving direction
              Line 6840: INY                             ; otherwise increment to move left
              Line 6841: SetupBB: STY Enemy_MovingDir,X  ; set bullet bill's moving direction
                Branch exit: Line 6865: KillBB: JSR EraseEnemyObject    ; kill bullet bill and leave
                Line 6849: LDA #$01
            Line 6865: KillBB: JSR EraseEnemyObject    ; kill bullet bill and leave
          Line 6855: ChkDSte: LDA Enemy_State,X      ; check enemy state for d5 set
            Branch exit: Line 6859: BBFly: JSR MoveEnemyHorizontally; do sub to move bullet bill horizontally
            Line 6858: JSR MoveD_EnemyVertically       ; otherwise do sub to move bullet bill vertically
            Line 6859: BBFly: JSR MoveEnemyHorizontally; do sub to move bullet bill horizontally
        Line 6860: RunBBSubs: JSR GetEnemyOffscreenBits; get offscreen information
          Branch exit: Line 13618: EnemyGfxHandler: 

Function ChkForPlayerC_LargeP
  Inputs: [CarryFlag, X, Y]
  Outputs: []
          Line 11727: ChkForPlayerC_LargeP: 
            Branch exit: Line 11741: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
            Line 11730: TXA 
              Branch exit: Line 11741: ExLPC: LDX ObjectOffset         ; get enemy object buffer offset and leave
              Line 11740: JSR ProcLPlatCollisions         ; otherwise collision, perform sub

Function SetOffscrBitsOffset
  Inputs: [X, A]
  Outputs: []
  Line 14867: SetOffscrBitsOffset: 

Function RemBridge
  Inputs: [X, Y, $04, $05, $00]
  Outputs: []
        Line 2092: RemBridge: LDA BlockGfxData,X   ; write top left and top right

Function BoundingBoxCore
  Inputs: [X, Y]
  Outputs: []
    Line 12857: BoundingBoxCore: 

Function EndlessLoop
  Inputs: []
  Outputs: []
                Line 711: EndlessLoop: JMP EndlessLoop    ; endless loop, need I say more?
                  Branch exit: Line 711: EndlessLoop: JMP EndlessLoop    ; endless loop, need I say more?

Function BlockBufferColli_Side
  Inputs: []
  Outputs: [ZeroFlag]
              Line 13053: BlockBufferColli_Side: 
                Line 13057: BlockBufferCollision:  (as a call, not in function)

Function RunEnemyObjectsCore
  Inputs: []
  Outputs: []
  Line 9009: RunEnemyObjectsCore: 
    Branch exit: Line 9017: JmpEO: JSR JumpEngine
    Line 9015: TYA                             ; otherwise subtract $14 from the value and use
    Line 9017: JmpEO: JSR JumpEngine
      Line 9018: 
        Line 9059: NoRunCode:  (as a call, not in function)

Function ChkRBit
  Inputs: [A, X]
  Outputs: []
      Line 8717: ChkRBit: TAY                    ; use as offset
        Branch exit: Line 8725: AddFBit: ORA BitMFilter         ; add bit to already set bits in filter
        Line 8721: INY                             ; increment offset
          Branch exit: Line 8717: ChkRBit: TAY                    ; use as offset
        Line 8725: AddFBit: ORA BitMFilter         ; add bit to already set bits in filter
          Branch exit: Line 8059: CheckpointEnemyID: 

Function SpriteShuffler
  Inputs: []
  Outputs: []
    Line 886: SpriteShuffler: 
      Line 891: ShuffleLoop: LDA SprDataOffset,X; check for offset value against
        Branch exit: Line 901: NextSprOffset: DEX              ; move backwards to next one
        Line 894: LDY SprShuffleAmtOffset         ; get current offset to preset value we want to add
          Branch exit: Line 900: StrSprOffset: STA SprDataOffset,X; store new offset here or old one if branched to here
          Line 898: CLC 
          Line 900: StrSprOffset: STA SprDataOffset,X; store new offset here or old one if branched to here
        Line 901: NextSprOffset: DEX              ; move backwards to next one
          Branch exit: Line 891: ShuffleLoop: LDA SprDataOffset,X; check for offset value against
          Line 903: LDX SprShuffleAmtOffset         ; load offset
            Branch exit: Line 908: SetAmtOffset: STX SprShuffleAmtOffset
            Line 907: LDX #$00                        ; otherwise, init to 0
            Line 908: SetAmtOffset: STX SprShuffleAmtOffset
              Line 911: SetMiscOffset: LDA SprDataOffset+5,Y; load one of three OAM data offsets
                Branch exit: Line 911: SetMiscOffset: LDA SprDataOffset+5,Y; load one of three OAM data offsets
                Line 924: RTS 

Function SetVRAMAddr_A
  Inputs: [X]
  Outputs: []
  Line 1416: SetVRAMAddr_A: STX VRAM_Buffer_AddrCtrl; store offset into buffer control

Function RunPUSubs
  Inputs: [X]
  Outputs: []
  Line 7205: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen

Function GetEnemyBoundBox
  Inputs: []
  Outputs: []
    Line 12801: GetEnemyBoundBox: 
      Branch exit: Line 12812: GetMaskedOffScrBits: 

Function GameOverMode
  Inputs: []
  Outputs: []
    Line 2950: GameOverMode: 
      Line 2953: 
        Line 2960: SetupGameOver:  (as a call, not in function)

Function IntroPipe
  Inputs: [CarryFlag, X]
  Outputs: []
    Line 3789: IntroPipe: 
      Branch exit: Line 3802: NoBlankP: RTS 
      Line 3795: LDX #$06                        ; blank everything above the vertical pipe part
        Line 3796: VPipeSectLoop: LDA #$00         ; all the way to the top of the screen
          Branch exit: Line 3796: VPipeSectLoop: LDA #$00         ; all the way to the top of the screen
          Line 3800: LDA VerticalPipeData,Y          ; draw the end of the vertical pipe part
      Line 3802: NoBlankP: RTS 

Function WriteBottomStatusLine
  Inputs: []
  Outputs: []
    Line 1498: WriteBottomStatusLine: 
      Branch exit: Line 1622: IncSubtask: INC ScreenRoutineTask; move onto next task

Function ColumnOfSolidBlocks
  Inputs: []
  Outputs: []
    Line 4088: ColumnOfSolidBlocks: 

Function FBCLoop
  Inputs: [A, $07, $06, $05, $00]
  Outputs: []
                    Line 9824: FBCLoop: SEC                    ; subtract vertical position of firebar
                      Branch exit: Line 9830: ChkVFBD: CMP #$08               ; if difference => 8 pixels, skip ahead of this part
                      Line 9827: EOR #$ff                        ; skip two's compliment part
                      Line 9830: ChkVFBD: CMP #$08               ; if difference => 8 pixels, skip ahead of this part
                        Branch exit: Line 9847: Chk2Ofs: LDA $05                ; if value of $02 was set earlier for whatever reason,
                        Line 9832: LDA $06                         ; if firebar on far right on the screen, skip this,
                          Branch exit: Line 9847: Chk2Ofs: LDA $05                ; if value of $02 was set earlier for whatever reason,
                          Line 9835: LDA Sprite_X_Position+4         ; get OAM X coordinate for sprite #1
                            Branch exit: Line 9845: ChkFBCl: CMP #$08               ; if difference < 8 pixels, collision, thus branch
                            Line 9842: EOR #$ff                        ; skip two's compliment part
                            Line 9845: ChkFBCl: CMP #$08               ; if difference < 8 pixels, collision, thus branch
                              Branch exit: Line 9856: ChgSDir: LDX #$01               ; set movement direction by default
                              Line 9856: ChgSDir: LDX #$01               ; set movement direction by default
                                Branch exit: Line 9861: SetSDir: STX Enemy_MovingDir    ; store movement direction here
                                Line 9860: INX                             ; otherwise increment it
                                Line 9861: SetSDir: STX Enemy_MovingDir    ; store movement direction here
                        Line 9847: Chk2Ofs: LDA $05                ; if value of $02 was set earlier for whatever reason,
                          Branch exit: Line 9868: NoColFB: PLA                    ; get OAM data offset
                          Line 9850: LDY $05                         ; otherwise get temp here and use as offset
                            Branch exit: Line 9824: FBCLoop: SEC                    ; subtract vertical position of firebar

Function DumpTwoSpr
  Inputs: [A, Y]
  Outputs: []
  Line 13327: DumpTwoSpr: 

Function UpdateScreen
  Inputs: [$00, $01]
  Outputs: []
                Line 2497: UpdateScreen: LDX PPU_STATUS    ; reset flip-flop
                  Branch exit: Line 2456: WriteBufferToScreen: 

Function InitBalPlatform
  Inputs: [X]
  Outputs: []
    Line 8883: InitBalPlatform: 
      Branch exit: Line 8890: AlignP: LDY #$ff                ; set default value here for now
      Line 8888: LDY #$02                        ; otherwise set value here
      Line 8890: AlignP: LDY #$ff                ; set default value here for now
        Branch exit: Line 8896: SetBPA: STY BalPlatformAlignment; store whatever value's in Y here
        Line 8894: TXA                             ; if old contents already $ff, put
        Line 8896: SetBPA: STY BalPlatformAlignment; store whatever value's in Y here
          Line 8904: InitDropPlatform:  (as a call, not in function)

Function PlayerLoseLife
  Inputs: []
  Outputs: []
      Line 2910: PlayerLoseLife: 
        Branch exit: Line 2923: StillInGame: LDA WorldNumber    ; multiply world number by 2 and use
        Line 2918: LDA #$00
        Line 2923: StillInGame: LDA WorldNumber    ; multiply world number by 2 and use
          Branch exit: Line 2930: GetHalfway: LDY HalfwayPageNybbles,X; get halfway page number with offset
          Line 2929: INX 
          Line 2930: GetHalfway: LDY HalfwayPageNybbles,X; get halfway page number with offset
            Branch exit: Line 2939: MaskHPNyb: AND #%00001111       ; mask out all but lower nybble
            Line 2935: LSR                             ; move higher nybble to lower if area
            Line 2939: MaskHPNyb: AND #%00001111       ; mask out all but lower nybble
              Branch exit: Line 2944: SetHalfway: STA HalfwayPage     ; store as halfway page for player
              Line 2942: BCC SetHalfway                  ; otherwise player must start at the
                Branch exit: Line 2944: SetHalfway: STA HalfwayPage     ; store as halfway page for player
                Line 2943: LDA #$00                        ; beginning of the level
              Line 2944: SetHalfway: STA HalfwayPage     ; store as halfway page for player
                Branch exit: Line 2994: ContinueGame: 

Function BubbleCheck
  Inputs: [X]
  Outputs: []
    Line 6388: BubbleCheck: 
      Branch exit: Line 6419: MoveBubl: LDY $07               ; get pseudorandom bit again, use as offset
      Line 6395: LDA AirBubbleTimer              ; if air bubble timer not expired,
        Branch exit: Line 6430: ExitBubl: RTS                   ; leave
        Line 6397: 
          Line 6398: SetupBubble:  (as a call, not in function)
      Line 6419: MoveBubl: LDY $07               ; get pseudorandom bit again, use as offset
        Branch exit: Line 6429: Y_Bubl: STA Bubble_Y_Position,X ; store as new vertical coordinate for air bubble
        Line 6428: LDA #$f8                        ; otherwise set offscreen coordinate
        Line 6429: Y_Bubl: STA Bubble_Y_Position,X ; store as new vertical coordinate for air bubble
      Line 6430: ExitBubl: RTS                   ; leave

Function GetAreaPalette
  Inputs: []
  Outputs: []
      Line 1413: GetAreaPalette: 

Function TopScoreCheck
  Inputs: [X]
  Outputs: []
      Line 2618: TopScoreCheck: 
        Line 2621: GetScoreDiff: LDA PlayerScoreDisplay,X; subtract each player digit from each high score digit
          Branch exit: Line 2621: GetScoreDiff: LDA PlayerScoreDisplay,X; subtract each player digit from each high score digit
          Line 2626: BCC NoTopSc                     ; check to see if borrow is still set, if so, no new high score
            Branch exit: Line 2635: NoTopSc: RTS 
            Line 2627: INX                             ; increment X and Y once to the start of the score
              Line 2629: CopyScore: LDA PlayerScoreDisplay,X; store player's score digits into high score memory area
                Branch exit: Line 2629: CopyScore: LDA PlayerScoreDisplay,X; store player's score digits into high score memory area
            Line 2635: NoTopSc: RTS 

Function PlayerBGCollision
  Inputs: [$04, $02, $06]
  Outputs: []
      Line 11906: PlayerBGCollision: 
        Branch exit: Line 11931: ExPBGCol: RTS                   ; otherwise leave
        Line 11909: LDA GameEngineSubroutine
          Branch exit: Line 11931: ExPBGCol: RTS                   ; otherwise leave
          Line 11912: CMP #$04
            Branch exit: Line 11931: ExPBGCol: RTS                   ; otherwise leave
            Line 11914: LDA #$01                        ; load default player state for swimming
              Branch exit: Line 11922: SetPSte: STA Player_State       ; set whatever player state is appropriate
              Line 11917: LDA Player_State                ; if player in normal state,
                Branch exit: Line 11921: SetFallS: LDA #$02              ; load default player state for falling
                Line 11919: CMP #$03
                  Branch exit: Line 11923: ChkOnScr: LDA Player_Y_HighPos
                Line 11921: SetFallS: LDA #$02              ; load default player state for falling
              Line 11922: SetPSte: STA Player_State       ; set whatever player state is appropriate
              Line 11923: ChkOnScr: LDA Player_Y_HighPos
                Branch exit: Line 11931: ExPBGCol: RTS                   ; otherwise leave
                Line 11926: LDA #$ff
                  Branch exit: Line 11933: ChkCollSize: 
        Line 11931: ExPBGCol: RTS                   ; otherwise leave

Function FireballEnemyCollision
  Inputs: [X]
  Outputs: []
    Line 11064: FireballEnemyCollision: 
      Branch exit: Line 11120: ExitFBallEnemy: 
      Line 11067: ASL 
        Branch exit: Line 11120: ExitFBallEnemy: 
        Line 11069: LDA FrameCounter
          Branch exit: Line 11120: ExitFBallEnemy: 
          Line 11072: TXA 
            Line 11080: FireballEnemyCDLoop: 
              Branch exit: Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
              Line 11087: LDA Enemy_Flag,X                ; check to see if buffer flag is set
                Branch exit: Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
                Line 11089: LDA Enemy_ID,X                  ; check enemy identifier
                  Branch exit: Line 11094: GoombaDie: CMP #Goomba          ; check for goomba identifier
                  Line 11092: CMP #$2b
                    Branch exit: Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
                  Line 11094: GoombaDie: CMP #Goomba          ; check for goomba identifier
                    Branch exit: Line 11099: NotGoomba: LDA EnemyOffscrBitsMasked,X; if any masked offscreen bits set,
                    Line 11096: LDA Enemy_State,X               ; otherwise check for defeated state
                      Branch exit: Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
                    Line 11099: NotGoomba: LDA EnemyOffscrBitsMasked,X; if any masked offscreen bits set,
                      Branch exit: Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
                      Line 11101: TXA 
                        Branch exit: Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
                        Line 11110: LDA #%10000000
              Line 11114: NoFToECol: PLA                  ; pull fireball offset from stack
                Branch exit: Line 11080: FireballEnemyCDLoop: 
                Line 11119: 
      Line 11120: ExitFBallEnemy: 

Function CheckForHammerBro
  Inputs: [X, $02]
  Outputs: []
  Line 13808: CheckForHammerBro: 
    Branch exit: Line 13820: CheckForBloober: 
    Line 13813: LDA $ed
      Branch exit: Line 13835: CheckToAnimateEnemy: 
      Line 13815: AND #%00001000
        Branch exit: Line 13872: CheckDefeatedState: 
        Line 13817: LDX #$b4                        ; otherwise load offset for different frame
          Branch exit: Line 13835: CheckToAnimateEnemy: 
          Line 13819: 
    Line 13820: CheckForBloober: 
      Branch exit: Line 13835: CheckToAnimateEnemy: 
      Line 13823: LDA EnemyIntervalTimer,Y
        Branch exit: Line 13872: CheckDefeatedState: 
        Line 13826: CPX #$3c                        ; check for bloober offset loaded
          Branch exit: Line 13835: CheckToAnimateEnemy: 
          Line 13828: CMP #$01
            Branch exit: Line 13872: CheckDefeatedState: 
            Line 13830: INC $02                         ; increment saved vertical coordinate three pixels
              Branch exit: Line 13862: CheckAnimationStop: 

Function AwardGameTimerPoints
  Inputs: []
  Outputs: []
    Line 10491: AwardGameTimerPoints: 
      Branch exit: Line 10485: IncrementSFTask1: 
      Line 10496: LDA FrameCounter
        Branch exit: Line 10501: NoTTick: LDY #$23               ; set offset here to subtract from game timer's last digit
        Line 10499: LDA #Sfx_TimerTick
        Line 10501: NoTTick: LDY #$23               ; set offset here to subtract from game timer's last digit

Function FinCCSt
  Inputs: [A, X]
  Outputs: []
                        Line 8498: FinCCSt: STA Enemy_PageLoc,X    ; save as enemy's page location

Function ReplaceBlockMetatile
  Inputs: [X, A, $06, $02]
  Outputs: []
    Line 2026: ReplaceBlockMetatile: 

Function GiveOneCoin
  Inputs: []
  Outputs: []
  Line 7088: GiveOneCoin: 
    Branch exit: Line 7104: CoinPoints: 
    Line 7098: LDA #$00
    Line 7104: CoinPoints: 
      Line 7108: AddToScore:  (as a call, not in function)

Function EndRp
  Inputs: [X]
  Outputs: []
              Line 10801: EndRp: LDA #$00                 ; put null terminator at the end

Function AreaParserTaskHandler
  Inputs: []
  Outputs: []
    Line 3039: AreaParserTaskHandler: 
      Branch exit: Line 3044: DoAPTasks: DEY 
      Line 3042: LDY #$08
      Line 3044: DoAPTasks: DEY 
        Branch exit: Line 3050: SkipATRender: RTS 
        Line 3049: JSR RenderAttributeTables
        Line 3050: SkipATRender: RTS 

Function ChkContinue
  Inputs: [A]
  Outputs: []
              Line 1033: ChkContinue: LDY DemoTimer      ; if timer for demo has expired, reset modes
                Branch exit: Line 1027: ResetTitle: LDA #$00            ; reset game modes, disable
                Line 1035: ASL                             ; check to see if A button was also pushed
                  Branch exit: Line 1039: StartWorld1: JSR LoadAreaPointer
                  Line 1037: LDA ContinueWorld               ; load previously saved world number for secret
                  Line 1039: StartWorld1: JSR LoadAreaPointer
                    Line 1051: InitScores: STA ScoreAndCoinDisplay,X; clear player scores and coin displays
                      Branch exit: Line 1051: InitScores: STA ScoreAndCoinDisplay,X; clear player scores and coin displays

Function RelWOfs
  Inputs: [X, Y]
  Outputs: []
  Line 14780: RelWOfs: JSR GetObjRelativePosition; get the coordinates

Function MoveLakitu
  Inputs: [X, $00]
  Outputs: []
      Line 9972: MoveLakitu: 
        Branch exit: Line 9977: ChkLS: LDA Enemy_State,X        ; if lakitu's enemy state not set at all,
        Line 9976: JMP MoveD_EnemyVertically       ; otherwise jump to move defeated lakitu downwards
          Branch exit: Line 7603: MoveD_EnemyVertically: 
        Line 9977: ChkLS: LDA Enemy_State,X        ; if lakitu's enemy state not set at all,
          Branch exit: Line 9984: Fr12S: LDA #Spiny
          Line 9979: LDA #$00
            Branch exit: Line 9992: SetLSpd: STA LakituMoveSpeed,X  ; set movement speed returned from sub
          Line 9984: Fr12S: LDA #Spiny
            Line 9987: LdLDa: LDA LakituDiffAdj,Y      ; load values
              Branch exit: Line 9987: LdLDa: LDA LakituDiffAdj,Y      ; load values
              Line 9991: JSR PlayerLakituDiff            ; execute sub to set speed and create spinys
          Line 9992: SetLSpd: STA LakituMoveSpeed,X  ; set movement speed returned from sub
            Branch exit: Line 10003: SetLMov: STY Enemy_MovingDir,X  ; store moving direction
            Line 9997: LDA LakituMoveSpeed,X
            Line 10003: SetLMov: STY Enemy_MovingDir,X  ; store moving direction
              Branch exit: Line 7534: MoveEnemyHorizontally: 

Function AlternateLengthHandler
  Inputs: [A, CarryFlag]
  Outputs: [A, X]
    Line 15913: AlternateLengthHandler: 
      Line 15921: ProcessLengthData:  (as a call, not in function)

Function ExtraLifeMushBlock
  Inputs: []
  Outputs: []
                Line 7350: ExtraLifeMushBlock:  (as a call, not in function)

Function StopSquare1Sfx
  Inputs: []
  Outputs: []
      Line 15319: StopSquare1Sfx: 

Function GetRow
  Inputs: [A, X]
  Outputs: []
  Line 4076: GetRow: PHA                     ; store metatile here

Function RetYC
  Inputs: [A, $03]
  Outputs: []
                  Line 13091: RetYC: AND #%00001111           ; and mask out high nybble

Function WriteBlockMetatile
  Inputs: [A, X, $06, $02]
  Outputs: []
      Line 2035: WriteBlockMetatile: 
        Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
        Line 2039: LDY #$00                        ; load offset for brick metatile w/ line
          Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
          Line 2042: CMP #$51
            Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
            Line 2044: INY                             ; increment offset for brick metatile w/o line
              Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
              Line 2047: CMP #$52
                Branch exit: Line 2050: UseBOffset: TYA                 ; put Y in A
                Line 2049: INY                             ; if any other metatile, increment offset for empty block
        Line 2050: UseBOffset: TYA                 ; put Y in A
          Line 2054: MoveVOffset: DEY                ; decrement vram buffer offset (as a call, not in function)

Function DonePlayerTask
  Inputs: []
  Outputs: []
  Line 5776: DonePlayerTask: 

Function ChkLeftCo
  Inputs: [A]
  Outputs: []
                  Line 14154: ChkLeftCo: AND #%00001000       ; check to see if d3 in offscreen bits are set
                    Branch exit: Line 14161: ExDBlk: RTS 
                    Line 14156: 
                      Line 14157: MoveColOffscreen:  (as a call, not in function)
                    Line 14161: ExDBlk: RTS  (as a call, not in function)

Function InitVertPlatform
  Inputs: [X]
  Outputs: []
    Line 8918: InitVertPlatform: 
      Branch exit: Line 8926: SetYO: STA YPlatformTopYPos,X   ; save as top vertical position
      Line 8922: EOR #$ff
      Line 8926: SetYO: STA YPlatformTopYPos,X   ; save as top vertical position

Function ChkEnemyFaceRight
  Inputs: [X]
  Outputs: []
  Line 11519: ChkEnemyFaceRight: 
    Branch exit: Line 11524: LInj: JSR EnemyTurnAround       ; turn the enemy around, if necessary
    Line 11523: JMP InjurePlayer                ; otherwise go back to hurt player
      Branch exit: Line 11405: InjurePlayer: 

Function ChkLength
  Inputs: []
  Outputs: []
          Line 3353: ChkLength: LDX ObjectOffset     ; get buffer offset
            Branch exit: Line 3357: ProcLoopb: DEX                  ; decrement buffer offset
            Line 3356: DEC AreaObjectLength,X          ; otherwise decrement length or get rid of it
            Line 3357: ProcLoopb: DEX                  ; decrement buffer offset
              Branch exit: Line 3307: ProcADLoop: STX ObjectOffset
              Line 3359: LDA BehindAreaParserFlag        ; check for flag set if objects were behind renderer
                Branch exit: Line 3305: ProcessAreaData: 
                Line 3361: LDA BackloadingFlag             ; check for flag set if starting right of page $00
                  Branch exit: Line 3305: ProcessAreaData: 

Function FindPlayerAction
  Inputs: []
  Outputs: []
  Line 14478: FindPlayerAction: 
    Branch exit: Line 14490: PlayerGfxProcessing: 

Function PrintVictoryMessages
  Inputs: []
  Outputs: []
    Line 1175: PrintVictoryMessages: 
      Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
      Line 1178: LDA PrimaryMsgCounter           ; otherwise load primary message counter
        Branch exit: Line 1191: ThankPlayer: TAY                ; put primary message counter into Y
        Line 1180: CMP #$09                        ; if at 9 or above, branch elsewhere (this comparison
          Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
          Line 1182: LDY WorldNumber                 ; check world number
            Branch exit: Line 1189: MRetainerMsg: CMP #$02          ; check primary message counter
            Line 1185: CMP #$03                        ; check primary message counter again
              Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
              Line 1187: SBC #$01                        ; otherwise subtract one
                Branch exit: Line 1191: ThankPlayer: TAY                ; put primary message counter into Y
            Line 1189: MRetainerMsg: CMP #$02          ; check primary message counter
              Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
        Line 1191: ThankPlayer: TAY                ; put primary message counter into Y (as a call, not in function)
      Line 1214: IncMsgCounter: LDA SecondaryMsgCounter (as a call, not in function)
      Line 1222: SetEndTimer: BCC ExitMsgs       ; if not reached value yet, branch to leave (as a call, not in function)

Function SetupPowerUp
  Inputs: [X]
  Outputs: []
  Line 7129: SetupPowerUp: 
    Line 7142: PwrUpJmp: LDA #$01              ; this is a residual jump point in enemy object jump table (as a call, not in function)

Function InitPiranhaPlant
  Inputs: [X]
  Outputs: []
    Line 8818: InitPiranhaPlant: 
      Branch exit: Line 8878: SetBBox2: STA Enemy_BoundBoxCtrl,X; set bounding box control then leave

Function RunNormalEnemies
  Inputs: [X, CarryFlag, $02, $04, Y]
  Outputs: []
    Line 9071: RunNormalEnemies: 
      Branch exit: Line 9084: SkipMove: JMP OffscreenBoundsCheck
      Line 9083: JSR EnemyMovementSubs
      Line 9084: SkipMove: JMP OffscreenBoundsCheck
        Branch exit: Line 11010: OffscreenBoundsCheck: 

Function OffscreenBoundsCheck
  Inputs: [X]
  Outputs: []
  Line 11010: OffscreenBoundsCheck: 
    Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
    Line 11014: LDA ScreenLeft_X_Pos            ; get horizontal coordinate for left side of screen
      Branch exit: Line 11020: LimitB: ADC #$38                ; add 56 pixels to coordinate if hammer bro or piranha plant
      Line 11018: CPY #PiranhaPlant               ; check for piranha plant object
        Branch exit: Line 11021: ExtendLB: SBC #$48              ; subtract 72 pixels regardless of enemy object
      Line 11020: LimitB: ADC #$38                ; add 56 pixels to coordinate if hammer bro or piranha plant
      Line 11021: ExtendLB: SBC #$48              ; subtract 72 pixels regardless of enemy object
        Branch exit: Line 11053: TooFar: JSR EraseEnemyObject    ; erase object if necessary
        Line 11037: LDA Enemy_X_Position,X          ; compare horizontal coordinate of the enemy object
          Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
          Line 11042: LDA Enemy_State,X               ; if at this point, enemy is offscreen to the right, so check
            Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
            Line 11045: CPY #PiranhaPlant               ; if piranha plant, do not erase
              Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
              Line 11047: CPY #FlagpoleFlagObject         ; if flagpole flag, do not erase
                Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
                Line 11049: CPY #StarFlagObject             ; if star flag, do not erase
                  Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
                  Line 11051: CPY #JumpspringObject           ; if jumpspring, do not erase
                    Branch exit: Line 11054: ExScrnBd: RTS                   ; leave
        Line 11053: TooFar: JSR EraseEnemyObject    ; erase object if necessary
    Line 11054: ExScrnBd: RTS                   ; leave

Function GetXOffscreenBits
  Inputs: [X]
  Outputs: [A, X]
        Line 14913: GetXOffscreenBits: 
          Line 14916: XOfsLoop: LDA ScreenEdge_X_Pos,Y; get pixel coordinate of edge
            Branch exit: Line 14932: XLdBData: LDA XOffscreenBitsData,X; get bits here
            Line 14925: LDX DefaultXOnscreenOfs+1,Y     ; if not, load alternate offset value here
              Branch exit: Line 14932: XLdBData: LDA XOffscreenBitsData,X; get bits here
              Line 14928: LDA #$38                        ; if no branching, load value here and store
            Line 14932: XLdBData: LDA XOffscreenBitsData,X; get bits here
              Branch exit: Line 14938: ExXOfsBS: RTS 
              Line 14936: DEY                             ; otherwise, do left side of screen now
                Branch exit: Line 14916: XOfsLoop: LDA ScreenEdge_X_Pos,Y; get pixel coordinate of edge
              Line 14938: ExXOfsBS: RTS 

Function DrawTitleScreen
  Inputs: []
  Outputs: []
    Line 1586: DrawTitleScreen: 
      Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode
      Line 1589: LDA #>TitleScreenDataOffset     ; load address $1ec0 into
        Line 1598: OutputTScr: LDA PPU_DATA        ; get title screen from chr-rom
          Branch exit: Line 1603: ChkHiByte: LDA $01              ; check high byte?
          Line 1602: INC $01                         ; otherwise increment high byte of indirect
          Line 1603: ChkHiByte: LDA $01              ; check high byte?
            Branch exit: Line 1598: OutputTScr: LDA PPU_DATA        ; get title screen from chr-rom
            Line 1606: CPY #$3a                        ; check if offset points past end of data
              Branch exit: Line 1598: OutputTScr: LDA PPU_DATA        ; get title screen from chr-rom
              Line 1608: LDA #$05                        ; set buffer transfer control to $0300,
                Branch exit: Line 1486: SetVRAMAddr_B: STA VRAM_Buffer_AddrCtrl

Function LoopCmdE
  Inputs: []
  Outputs: []
                    Line 3458: LoopCmdE: RTS 

Function SkipToFB
  Inputs: []
  Outputs: []
    Line 10237: SkipToFB: JMP ChkFireB          ; jump to execute flames code
      Branch exit: Line 10244: ChkFireB: LDA WorldNumber       ; check world number here

Function RunStarFlagObj
  Inputs: []
  Outputs: []
          Line 10456: RunStarFlagObj: 
            Branch exit: Line 10488: StarFlagExit: 
            Line 10462: JSR JumpEngine                  ; otherwise jump to appropriate sub
              Line 10463: 
                Line 10470: GameTimerFireworks:  (as a call, not in function)

Function ScrollLockObject
  Inputs: []
  Outputs: []
        Line 3585: ScrollLockObject: 

Function LakituAndSpinyHandler
  Inputs: [X, $00]
  Outputs: []
      Line 8279: LakituAndSpinyHandler: 
        Branch exit: Line 8310: ExLSHand: RTS 
        Line 8282: CPX #$05                        ; if we are on the special use slot, leave
          Branch exit: Line 8310: ExLSHand: RTS 
          Line 8284: LDA #$80                        ; set timer
            Line 8287: ChkLak: LDA Enemy_ID,Y          ; check all enemy slots to see
              Branch exit: Line 8314: CreateSpiny: 
              Line 8290: DEY                             ; otherwise check another slot
                Branch exit: Line 8287: ChkLak: LDA Enemy_ID,Y          ; check all enemy slots to see
                Line 8292: INC LakituReappearTimer         ; increment reappearance timer
                  Branch exit: Line 8310: ExLSHand: RTS 
                  Line 8296: LDX #$04                        ; start with the last enemy slot again
                    Line 8297: ChkNoEn: LDA Enemy_Flag,X       ; check enemy buffer flag for non-active enemy slot
                      Branch exit: Line 8302: CreateL: LDA #$00               ; initialize enemy state
                      Line 8299: DEX                             ; otherwise check next slot
                        Branch exit: Line 8297: ChkNoEn: LDA Enemy_Flag,X       ; check enemy buffer flag for non-active enemy slot
                        Line 8301: BMI RetEOfs                     ; if no empty slots were found, branch to leave
                          Branch exit: Line 8309: RetEOfs: LDX ObjectOffset       ; get enemy object buffer offset again and leave
                      Line 8302: CreateL: LDA #$00               ; initialize enemy state
                      Line 8309: RetEOfs: LDX ObjectOffset       ; get enemy object buffer offset again and leave

Function InitLongFirebar
  Inputs: [X]
  Outputs: []
        Line 8379: InitLongFirebar: 
          Line 8382: InitShortFirebar:  (as a call, not in function)

Function MoveSpritesOffscreen
  Inputs: []
  Outputs: []
          Line 943: MoveSpritesOffscreen:  (as a call, not in function)

Function ResJmpM
  Inputs: []
  Outputs: []
  Line 13025: ResJmpM: LDA #$00               ; set A to return vertical coordinate

Function ProcFirebar
  Inputs: [X, $00, $03, $01]
  Outputs: []
            Line 9705: ProcFirebar: 
              Branch exit: Line 9761: SkipFBar: RTS 
              Line 9710: LDA TimerControl                ; if master timer control set, branch
                Branch exit: Line 9716: SusFbar: LDA FirebarSpinState_High,X; get high byte of spinstate
                Line 9712: LDA FirebarSpinSpeed,X          ; load spinning speed of firebar
                Line 9716: SusFbar: LDA FirebarSpinState_High,X; get high byte of spinstate
                  Branch exit: Line 9727: SetupGFB: STA $ef               ; save high byte of spinning thing, modified or otherwise
                  Line 9720: CMP #$08                        ; check high byte of spinstate
                    Branch exit: Line 9724: SkpFSte: CLC 
                    Line 9722: CMP #$18
                      Branch exit: Line 9727: SetupGFB: STA $ef               ; save high byte of spinning thing, modified or otherwise
                    Line 9724: SkpFSte: CLC 
                  Line 9727: SetupGFB: STA $ef               ; save high byte of spinning thing, modified or otherwise
                    Branch exit: Line 9745: SetMFbar: STY $ed               ; store maximum value for length of firebars
                    Line 9744: LDY #$0b                        ; otherwise load value for long firebars
                    Line 9745: SetMFbar: STY $ed               ; store maximum value for length of firebars
                      Line 9748: DrawFbar: LDA $ef               ; load high byte of spinstate
                        Branch exit: Line 9757: NextFbar: INC $00               ; move onto the next firebar part
                        Line 9754: LDY DuplicateObj_Offset         ; if we arrive at fifth firebar part,
                        Line 9757: NextFbar: INC $00               ; move onto the next firebar part
                          Branch exit: Line 9748: DrawFbar: LDA $ef               ; load high byte of spinstate
              Line 9761: SkipFBar: RTS 

Function ProcessPlayerAction
  Inputs: []
  Outputs: []
    Line 14589: ProcessPlayerAction: 
      Branch exit: Line 14638: ActionClimbing: 
      Line 14593: CMP #$02
        Branch exit: Line 14628: ActionFalling: 
        Line 14595: CMP #$01
          Branch exit: Line 14605: ProcOnGroundActs: 
          Line 14597: LDA SwimmingFlag
            Branch exit: Line 14645: ActionSwimming: 
            Line 14599: LDY #$06                        ; load offset for crouching
              Branch exit: Line 14621: NonAnimatedActs: 
              Line 14602: LDY #$00                        ; otherwise load offset for jumping
                Branch exit: Line 14621: NonAnimatedActs: 

Function PowerUpObjHandler
  Inputs: [$02, $04]
  Outputs: []
    Line 7163: PowerUpObjHandler: 
      Branch exit: Line 7211: ExitPUp: RTS                    ; and we're done
      Line 7168: ASL                             ; shift to check if d7 was set in object state
        Branch exit: Line 7185: GrowThePowerUp: 
        Line 7170: LDA TimerControl                ; if master timer control set,
          Branch exit: Line 7205: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen
          Line 7172: LDA PowerUpType                 ; check power-up type
            Branch exit: Line 7181: ShroomM: JSR MoveNormalEnemy    ; do sub to make mushrooms move
            Line 7174: CMP #$03
              Branch exit: Line 7181: ShroomM: JSR MoveNormalEnemy    ; do sub to make mushrooms move
              Line 7176: CMP #$02
                Branch exit: Line 7205: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen
                Line 7178: JSR MoveJumpingEnemy            ; otherwise impose gravity on star power-up and make it jump
                  Branch exit: Line 7205: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen
            Line 7181: ShroomM: JSR MoveNormalEnemy    ; do sub to make mushrooms move
              Branch exit: Line 7205: RunPUSubs: JSR RelativeEnemyPosition; get coordinates relative to screen

Function Dump_Sq2_Regs
  Inputs: [X, Y]
  Outputs: []
    Line 15155: Dump_Sq2_Regs: 

Function DrawEnemyObject
  Inputs: [X]
  Outputs: []
  Line 13884: DrawEnemyObject: 
    Branch exit: Line 13898: CheckForVerticalFlip: 
    Line 13894: 

Function PlayerHeadCollision
  Inputs: [A, $02, $06, CarryFlag]
  Outputs: []
      Line 7223: PlayerHeadCollision: 
        Branch exit: Line 7230: DBlockSte: STA Block_State,X    ; store into block object buffer
        Line 7229: LDA #$12                        ; otherwise load breakable block object state
        Line 7230: DBlockSte: STA Block_State,X    ; store into block object buffer
          Branch exit: Line 7244: ChkBrick: BCC PutMTileB         ; if no match was found in previous sub, skip ahead
          Line 7243: TYA                             ; otherwise init A (note: big = 0)
          Line 7244: ChkBrick: BCC PutMTileB         ; if no match was found in previous sub, skip ahead
            Branch exit: Line 7262: PutMTileB: STA Block_Metatile,X ; store whatever metatile be appropriate here
            Line 7245: LDY #$11                        ; otherwise load unbreakable state into block object buffer
              Branch exit: Line 7253: StartBTmr: LDA BrickCoinTimerFlag; check brick coin timer flag
              Line 7251: CPY #$5d                        ; is it brick with coins (without line)?
                Branch exit: Line 7262: PutMTileB: STA Block_Metatile,X ; store whatever metatile be appropriate here
              Line 7253: StartBTmr: LDA BrickCoinTimerFlag; check brick coin timer flag
                Branch exit: Line 7258: ContBTmr: LDA BrickCoinTimer    ; check brick coin timer
                Line 7255: LDA #$0b
                Line 7258: ContBTmr: LDA BrickCoinTimer    ; check brick coin timer
                  Branch exit: Line 7261: PutOldMT: TYA                   ; put metatile into A
                  Line 7260: LDY #$c4                        ; otherwise use empty block metatile
                  Line 7261: PutOldMT: TYA                   ; put metatile into A
            Line 7262: PutMTileB: STA Block_Metatile,X ; store whatever metatile be appropriate here
              Branch exit: Line 7276: SmallBP: INY                    ; increment for small or big and crouching
              Line 7274: LDA PlayerSize                  ; is player big?
                Branch exit: Line 7277: BigBP: LDA Player_Y_Position    ; get player's vertical coordinate
              Line 7276: SmallBP: INY                    ; increment for small or big and crouching
              Line 7277: BigBP: LDA Player_Y_Position    ; get player's vertical coordinate
                Branch exit: Line 7287: Unbreak: JSR BumpBlock          ; execute code for unbreakable brick or question block
                Line 7285: JSR BrickShatter                ; execute code for breakable brick
                  Branch exit: Line 7288: InvOBit: LDA SprDataOffset_Ctrl ; invert control bit used by block objects
                Line 7287: Unbreak: JSR BumpBlock          ; execute code for unbreakable brick or question block
                Line 7288: InvOBit: LDA SprDataOffset_Ctrl ; invert control bit used by block objects (as a call, not in function)

Function MoveColOffscreen
  Inputs: [Y]
  Outputs: [A]
                      Line 14157: MoveColOffscreen: 

Function StopSquare2Sfx
  Inputs: []
  Outputs: []
    Line 15427: StopSquare2Sfx: 

Function DrawBrickChunks
  Inputs: [X]
  Outputs: []
    Line 14166: DrawBrickChunks: 
      Branch exit: Line 14176: DChunks: LDY Block_SprDataOffset,X; get OAM data offset
      Line 14173: LDA #$03                        ; otherwise set different palette bits
      Line 14176: DChunks: LDY Block_SprDataOffset,X; get OAM data offset
        Branch exit: Line 14221: ChnkOfs: LDA $00                ; if relative position on left side of screen,
        Line 14219: LDA #$f8
        Line 14221: ChnkOfs: LDA $00                ; if relative position on left side of screen,
          Branch exit: Line 14229: ExBCDr: RTS                     ; leave
          Line 14223: LDA Sprite_X_Position,Y         ; otherwise compare left-side X coordinate
            Branch exit: Line 14229: ExBCDr: RTS                     ; leave
            Line 14226: LDA #$f8                        ; otherwise move right half of sprites offscreen
          Line 14229: ExBCDr: RTS                     ; leave

Function AreaFrenzy
  Inputs: [$00]
  Outputs: []
      Line 3611: AreaFrenzy: LDX $00             ; use area object identifier bit as offset
        Line 3614: FreCompLoop: DEY                ; check regular slots of enemy object buffer
          Branch exit: Line 3619: ExitAFrenzy: STA EnemyFrenzyQueue; store enemy into frenzy queue
          Line 3616: CMP Enemy_ID,Y                  ; check for enemy object in buffer versus frenzy object
            Branch exit: Line 3614: FreCompLoop: DEY                ; check regular slots of enemy object buffer
            Line 3618: LDA #$00                        ; if enemy object already present, nullify queue and leave
          Line 3619: ExitAFrenzy: STA EnemyFrenzyQueue; store enemy into frenzy queue

Function NoMoveCode
  Inputs: []
  Outputs: []
        Line 9114: NoMoveCode: 

Function SetupJumpCoin
  Inputs: [X, Y, $06, $02]
  Outputs: []
    Line 6979: SetupJumpCoin: 

Function RunGameTimer
  Inputs: []
  Outputs: []
        Line 6440: RunGameTimer: 
          Branch exit: Line 6476: ExGTimer: RTS                   ; leave
          Line 6443: LDA GameEngineSubroutine
            Branch exit: Line 6476: ExGTimer: RTS                   ; leave
            Line 6446: CMP #$0b                        ; if running death routine,
              Branch exit: Line 6476: ExGTimer: RTS                   ; leave
              Line 6448: LDA Player_Y_HighPos
                Branch exit: Line 6476: ExGTimer: RTS                   ; leave
                Line 6451: LDA GameTimerCtrlTimer          ; if game timer control not yet expired,
                  Branch exit: Line 6476: ExGTimer: RTS                   ; leave
                  Line 6453: LDA GameTimerDisplay
                    Branch exit: Line 6473: TimeUpOn: STA PlayerStatus      ; init player status (note A will always be zero here)
                    Line 6457: LDY GameTimerDisplay            ; otherwise check first digit
                      Branch exit: Line 6465: ResGTCtrl: LDA #$18             ; reset game timer control
                      Line 6460: LDA GameTimerDisplay+1          ; otherwise check second and third digits
                        Branch exit: Line 6465: ResGTCtrl: LDA #$18             ; reset game timer control
                        Line 6463: LDA #TimeRunningOutMusic
                      Line 6465: ResGTCtrl: LDA #$18             ; reset game timer control
                        Branch exit: Line 2529: PrintStatusBarNumbers: 
                    Line 6473: TimeUpOn: STA PlayerStatus      ; init player status (note A will always be zero here)

Function BlockBufferChk_Enemy
  Inputs: [A, X]
  Outputs: [ZeroFlag]
  Line 13002: BlockBufferChk_Enemy: 
    Branch exit: Line 13026: BBChk_E: JSR BlockBufferCollision; do collision detection subroutine for sprite object

Function GetLrgObjAttrib
  Inputs: [X]
  Outputs: [Y, $07, A]
    Line 4292: GetLrgObjAttrib: 

Function BumpBlock
  Inputs: [X, $05, CarryFlag, Y, $02, $06]
  Outputs: []
    Line 7311: BumpBlock: 
      Branch exit: Line 7360: ExitBlockChk: 
      Line 7324: TYA                             ; move block number to A
        Branch exit: Line 7328: BlockCode: JSR JumpEngine       ; run appropriate subroutine depending on block number
        Line 7327: SBC #$05                        ; otherwise subtract 5 for second set to get proper number
        Line 7328: BlockCode: JSR JumpEngine       ; run appropriate subroutine depending on block number
          Line 7329: 
            Line 7342: MushFlowerBlock:  (as a call, not in function)

Function SetAnimSpd
  Inputs: [Y]
  Outputs: []
        Line 6225: SetAnimSpd: LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset

Function ProcFireball_Bubble
  Inputs: [$01]
  Outputs: []
    Line 6277: ProcFireball_Bubble: 
      Branch exit: Line 6315: ProcAirBubbles: 
      Line 6281: LDA A_B_Buttons
        Branch exit: Line 6309: ProcFireballs: 
        Line 6284: AND PreviousA_B_Buttons
          Branch exit: Line 6309: ProcFireballs: 
          Line 6286: LDA FireballCounter             ; load fireball counter
            Branch exit: Line 6309: ProcFireballs: 
            Line 6291: LDY Player_Y_HighPos            ; if player too high or too low, branch
              Branch exit: Line 6309: ProcFireballs: 
              Line 6294: LDA CrouchingFlag               ; if player crouching, branch
                Branch exit: Line 6309: ProcFireballs: 
                Line 6296: LDA Player_State                ; if player's state = climbing, branch
                  Branch exit: Line 6309: ProcFireballs: 
                  Line 6299: LDA #Sfx_Fireball               ; play fireball sound effect
        Line 6309: ProcFireballs: 
      Line 6315: ProcAirBubbles: 
        Branch exit: Line 6326: BublExit: RTS                   ; then leave
        Line 6318: LDX #$02                        ; otherwise load counter and use as offset
          Line 6319: BublLoop: STX ObjectOffset      ; store offset
            Branch exit: Line 6319: BublLoop: STX ObjectOffset      ; store offset
        Line 6326: BublExit: RTS                   ; then leave

Function SetFlameTimer
  Inputs: []
  Outputs: [A]
      Line 10319: SetFlameTimer: 

Function ClearBuffersDrawIcon
  Inputs: []
  Outputs: []
    Line 1613: ClearBuffersDrawIcon: 
      Branch exit: Line 1630: IncModeTask_B: INC OperMode_Task; move onto next mode
      Line 1616: LDX #$00                        ; otherwise, clear buffer space
        Line 1617: TScrClear: STA VRAM_Buffer1-1,X
          Branch exit: Line 1617: TScrClear: STA VRAM_Buffer1-1,X
          Line 1621: JSR DrawMushroomIcon            ; draw player select icon

Function ProcessCannons
  Inputs: []
  Outputs: []
      Line 6767: ProcessCannons: 
        Branch exit: Line 6821: ExCannon: RTS                   ; then leave
        Line 6770: LDX #$02

Function GameCoreRoutine
  Inputs: [$01]
  Outputs: []
                                                                                                                                                                                Line 5305: GameCoreRoutine: 
                                                                                                                                                                                  Branch exit: Line 5315: GameEngine: 
                                                                                                                                                                                  Line 5313: RTS 

Function JumpspringHandler
  Inputs: [X]
  Outputs: []
      Line 6632: JumpspringHandler: 
        Branch exit: Line 6667: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
        Line 6636: LDA JumpspringAnimCtrl          ; check jumpspring frame control
          Branch exit: Line 6667: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
          Line 6638: TAY 
            Branch exit: Line 6646: DownJSpr: DEC Player_Y_Position ; move player's vertical position up two pixels
            Line 6643: INC Player_Y_Position
              Branch exit: Line 6648: PosJSpr: LDA Jumpspring_FixedYPos,X; get permanent vertical position
            Line 6646: DownJSpr: DEC Player_Y_Position ; move player's vertical position up two pixels
            Line 6648: PosJSpr: LDA Jumpspring_FixedYPos,X; get permanent vertical position (as a call, not in function)
        Line 6667: DrawJSpr: JSR RelativeEnemyPosition; get jumpspring's relative coordinates
          Branch exit: Line 6677: ExJSpring: RTS                  ; leave
          Line 6672: LDA JumpspringTimer
            Branch exit: Line 6677: ExJSpring: RTS                  ; leave
            Line 6674: LDA #$04
          Line 6677: ExJSpring: RTS                  ; leave

Function DecrementSfx2Length
  Inputs: []
  Outputs: []
  Line 15419: DecrementSfx2Length: 
    Branch exit: Line 15432: ExSfx2: RTS 
    Line 15422: 

Function SmallBBox
  Inputs: []
  Outputs: [A]
  Line 8213: SmallBBox: LDA #$09             ; set specific bounding box size control
    Branch exit: Line 8228: SetBBox: STA Enemy_BoundBoxCtrl,X; set bounding box control here
    Line 8215: 
      Line 8218: InitRedPTroopa:  (as a call, not in function)

Function GameMode
  Inputs: []
  Outputs: []
                                                                                                                                                                            Line 5294: GameMode: 
                                                                                                                                                                              Line 5297: 
                                                                                                                                                                                Line 5305: GameCoreRoutine:  (as a call, not in function)

Function MoveLargeLiftPlat
  Inputs: [X]
  Outputs: []
    Line 10978: MoveLargeLiftPlat: 
      Branch exit: Line 10922: ChkYPCollision: 

Function CheckForSolidMTiles
  Inputs: [A, X]
  Outputs: [CarryFlag]
      Line 12362: CheckForSolidMTiles: 

Function ChkSmallPlatCollision
  Inputs: [X]
  Outputs: []
  Line 10998: ChkSmallPlatCollision: 
    Branch exit: Line 11002: ExLiftP: RTS                    ; then leave
    Line 11001: JSR PositionPlayerOnS_Plat      ; use to position player correctly

Function SpawnBrickChunks
  Inputs: [X]
  Outputs: []
    Line 7420: SpawnBrickChunks: 

Function YMovingPlatform
  Inputs: [X]
  Outputs: []
    Line 10900: YMovingPlatform: 
      Branch exit: Line 10914: ChkYCenterPos: 
      Line 10904: STA Enemy_YMF_Dummy,X           ; initialize dummy variable
        Branch exit: Line 10914: ChkYCenterPos: 
        Line 10908: LDA FrameCounter
          Branch exit: Line 10912: SkipIY: JMP ChkYPCollision      ; skip ahead to last part
          Line 10911: INC Enemy_Y_Position,X          ; increase vertical position every eighth frame
          Line 10912: SkipIY: JMP ChkYPCollision      ; skip ahead to last part
            Branch exit: Line 10922: ChkYPCollision: 

Function VineBlock
  Inputs: []
  Outputs: []
    Line 7355: VineBlock: 

Function InitHorizFlySwimEnemy
  Inputs: []
  Outputs: []
    Line 8204: InitHorizFlySwimEnemy: 
      Branch exit: Line 8176: SetESpd: STA Enemy_X_Speed,X    ; store as speed for enemy object

Function AddToScore
  Inputs: []
  Outputs: []
      Line 7108: AddToScore: 
        Line 7113: GetSBNybbles:  (as a call, not in function)

Function PwrUpJmp
  Inputs: []
  Outputs: []
    Line 7142: PwrUpJmp: LDA #$01              ; this is a residual jump point in enemy object jump table
      Branch exit: Line 7155: PutBehind: LDA #%00100000
      Line 7150: LDA PlayerStatus                ; otherwise check player's current status
        Branch exit: Line 7154: StrType: STA PowerUpType        ; store type here
        Line 7153: LSR                             ; otherwise shift right to force fire flower type
        Line 7154: StrType: STA PowerUpType        ; store type here
      Line 7155: PutBehind: LDA #%00100000

Function ProcessAreaData
  Inputs: []
  Outputs: []
      Line 3305: ProcessAreaData: 
        Line 3307: ProcADLoop: STX ObjectOffset
          Branch exit: Line 3349: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
          Line 3314: LDA AreaObjectLength,X          ; check area object buffer flag
            Branch exit: Line 3349: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
            Line 3316: INY 
              Branch exit: Line 3324: Chk1Row13: DEY 
              Line 3320: LDA AreaObjectPageSel           ; check page select
                Branch exit: Line 3324: Chk1Row13: DEY 
                Line 3322: INC AreaObjectPageSel           ; if not already set, set it now
              Line 3324: Chk1Row13: DEY 
                Branch exit: Line 3342: Chk1Row14: CMP #$0e             ; row 14?
                Line 3329: INY                             ; if so, reread second byte of level object
                  Branch exit: Line 3346: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                  Line 3334: LDA AreaObjectPageSel           ; if page select is set, do not reread
                    Branch exit: Line 3346: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                    Line 3336: INY                             ; if d6 not set, reread second byte
                      Branch exit: Line 3352: NextAObj: JSR IncAreaObjOffset  ; increment buffer offset and move on
                Line 3342: Chk1Row14: CMP #$0e             ; row 14?
                  Branch exit: Line 3346: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                  Line 3344: LDA BackloadingFlag             ; check flag for saved page number and branch if set
                    Branch exit: Line 3349: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
                Line 3346: CheckRear: LDA AreaObjectPageLoc; check to see if current page of level object is
                  Branch exit: Line 3351: SetBehind: INC BehindAreaParserFlag; turn on flag if object is behind renderer
                  Line 3351: SetBehind: INC BehindAreaParserFlag; turn on flag if object is behind renderer
                Line 3352: NextAObj: JSR IncAreaObjOffset  ; increment buffer offset and move on (as a call, not in function)
          Line 3349: RdyDecode: JSR DecodeAreaData   ; do sub and do not turn on flag
            Branch exit: Line 3353: ChkLength: LDX ObjectOffset     ; get buffer offset
          Line 3353: ChkLength: LDX ObjectOffset     ; get buffer offset (as a call, not in function)

Function VictoryMode
  Inputs: []
  Outputs: []
    Line 1111: VictoryMode: 
      Branch exit: Line 1118: AutoPlayer: JSR RelativePlayerPosition; get player's relative coordinates
      Line 1115: LDX #$00
      Line 1118: AutoPlayer: JSR RelativePlayerPosition; get player's relative coordinates
        Branch exit: Line 14439: PlayerGfxHandler: 

Function DoNothing2
  Inputs: []
  Outputs: []
      Line 3034: DoNothing2: 

Function RowOfSolidBlocks
  Inputs: []
  Outputs: []
    Line 4073: RowOfSolidBlocks: 

Function FlagpoleObject
  Inputs: []
  Outputs: []
    Line 3970: FlagpoleObject: 

Function QuestionBlock
  Inputs: [$00]
  Outputs: []
    Line 4183: QuestionBlock: 
      Branch exit: Line 4202: DrawQBlk: LDA BrickQBlockMetatiles,Y; get appropriate metatile for brick (question block

Function TransposePlayers
  Inputs: []
  Outputs: [CarryFlag]
    Line 3008: TransposePlayers: 
      Branch exit: Line 3027: ExTrans: RTS 
      Line 3012: LDA OffScr_NumberofLives        ; does offscreen player have any lives left?
        Branch exit: Line 3027: ExTrans: RTS 
        Line 3014: LDA CurrentPlayer               ; invert bit to update
          Line 3018: TransLoop: LDA OnscreenPlayerInfo,X; transpose the information
            Branch exit: Line 3018: TransLoop: LDA OnscreenPlayerInfo,X; transpose the information
            Line 3026: CLC                             ; clear carry flag to get game going
      Line 3027: ExTrans: RTS 

Function GameRoutines
  Inputs: []
  Outputs: []
    Line 5478: GameRoutines: 
      Line 5481: 
        Line 5498: PlayerEntrance:  (as a call, not in function)

Function HandlePowerUpCollision
  Inputs: [X]
  Outputs: []
  Line 11241: HandlePowerUpCollision: 
    Branch exit: Line 11258: Shroom_Flower_PUp: 
    Line 11250: CMP #$03
      Branch exit: Line 11271: SetFor1Up: 
      Line 11252: LDA #$23                        ; otherwise set star mario invincibility

Function Chk_BB
  Inputs: [X, $00]
  Outputs: []
  Line 6811: Chk_BB: LDA Enemy_ID,X          ; check enemy identifier for bullet bill (cannon variant)
    Branch exit: Line 6819: Next3Slt: DEX                   ; move onto next slot
    Line 6814: JSR OffscreenBoundsCheck        ; otherwise, check to see if it went offscreen
      Branch exit: Line 6819: Next3Slt: DEX                   ; move onto next slot
      Line 6817: JSR GetEnemyOffscreenBits       ; otherwise, get offscreen information

Function NonAnimatedActs
  Inputs: [Y]
  Outputs: []
  Line 14621: NonAnimatedActs: 

Function DrawLargePlatform
  Inputs: [X]
  Outputs: []
    Line 13336: DrawLargePlatform: 
      Branch exit: Line 13353: ShrinkPlatform: 
      Line 13350: LDY SecondaryHardMode           ; check for secondary hard mode flag set
        Branch exit: Line 13356: SetLast2Platform: 
        Line 13352: 
      Line 13353: ShrinkPlatform: 
      Line 13356: SetLast2Platform: 
        Branch exit: Line 13365: SetPlatformTilenum: 
        Line 13363: LDA #$75                        ; otherwise load other tile for platform (puff)
        Line 13365: SetPlatformTilenum: 
          Branch exit: Line 13381: SChk2: PLA                      ; get bits from stack
          Line 13379: LDA #$f8                        ; if d7 was set, move first sprite offscreen
          Line 13381: SChk2: PLA                      ; get bits from stack
            Branch exit: Line 13387: SChk3: PLA                      ; get bits from stack
            Line 13385: LDA #$f8                        ; if d6 was set, move second sprite offscreen
            Line 13387: SChk3: PLA                      ; get bits from stack
              Branch exit: Line 13393: SChk4: PLA                      ; get bits from stack
              Line 13391: LDA #$f8                        ; if d5 was set, move third sprite offscreen
              Line 13393: SChk4: PLA                      ; get bits from stack
                Branch exit: Line 13399: SChk5: PLA                      ; get bits from stack
                Line 13397: LDA #$f8                        ; if d4 was set, move fourth sprite offscreen
                Line 13399: SChk5: PLA                      ; get bits from stack
                  Branch exit: Line 13405: SChk6: PLA                      ; get bits from stack
                  Line 13403: LDA #$f8                        ; if d3 was set, move fifth sprite offscreen
                  Line 13405: SChk6: PLA                      ; get bits from stack
                    Branch exit: Line 13410: SLChk: LDA Enemy_OffscreenBits  ; check d7 of offscreen bits
                    Line 13408: LDA #$f8
                    Line 13410: SLChk: LDA Enemy_OffscreenBits  ; check d7 of offscreen bits
                      Branch exit: Line 13414: ExDLPl: RTS 
                      Line 13413: JSR MoveSixSpritesOffscreen     ; otherwise branch to move all sprites offscreen
                      Line 13414: ExDLPl: RTS 

Function EnemyFacePlayer
  Inputs: [X]
  Outputs: []
    Line 11528: EnemyFacePlayer: 
      Branch exit: Line 11533: SFcRt: STY Enemy_MovingDir,X    ; set moving direction here
      Line 11532: INY                             ; otherwise, increment to set to move to the left
      Line 11533: SFcRt: STY Enemy_MovingDir,X    ; set moving direction here

Function ChkPOffscr
  Inputs: [A]
  Outputs: []
      Line 5432: ChkPOffscr: LDX #$00            ; set X for player offset
        Branch exit: Line 5442: KeepOnscr: LDA ScreenEdge_X_Pos,Y; get left or right side coordinate based on offset
        Line 5438: INY                             ; otherwise use different offset (right side)
          Branch exit: Line 5454: InitPlatScrl: LDA #$00          ; nullify platform force imposed on scroll
        Line 5442: KeepOnscr: LDA ScreenEdge_X_Pos,Y; get left or right side coordinate based on offset
          Branch exit: Line 5454: InitPlatScrl: LDA #$00          ; nullify platform force imposed on scroll
          Line 5452: LDA #$00
        Line 5454: InitPlatScrl: LDA #$00          ; nullify platform force imposed on scroll

Function SetPWh
  Inputs: [A]
  Outputs: []
      Line 6565: SetPWh: STA Player_PageLoc      ; set player's new page location

Function SetVRAMCtrl
  Inputs: []
  Outputs: []
  Line 1936: SetVRAMCtrl: LDA #$06

Function SetESpd
  Inputs: [A, X]
  Outputs: []
  Line 8176: SetESpd: STA Enemy_X_Speed,X    ; store as speed for enemy object
    Branch exit: Line 8227: TallBBox: LDA #$03              ; set specific bounding box size control

Function BBChk_E
  Inputs: [A, Y, X]
  Outputs: []
  Line 13026: BBChk_E: JSR BlockBufferCollision; do collision detection subroutine for sprite object

Function DividePDiff
  Inputs: [A, $07, $06, Y]
  Outputs: []
    Line 14982: DividePDiff: 
      Branch exit: Line 14995: ExDivPD: RTS                    ; leave
      Line 14987: LSR                             ; divide by eight
        Branch exit: Line 14994: SetOscrO: TAX                   ; use as offset
        Line 14993: ADC $05                         ; if not, add value to difference / 8
        Line 14994: SetOscrO: TAX                   ; use as offset
      Line 14995: ExDivPD: RTS                    ; leave

Function ColumnOfBricks
  Inputs: []
  Outputs: []
    Line 4083: ColumnOfBricks: 
      Branch exit: Line 4091: GetRow2: PHA                    ; save metatile to stack for now

Function MoveJumpingEnemy
  Inputs: []
  Outputs: []
    Line 9375: MoveJumpingEnemy: 
      Branch exit: Line 7534: MoveEnemyHorizontally: 

Function FindEmptyEnemySlot
  Inputs: []
  Outputs: [CarryFlag, A]
    Line 3900: FindEmptyEnemySlot: 
      Line 3902: EmptyChkLoop: CLC               ; clear carry flag by default
        Branch exit: Line 3908: ExitEmptyChk: RTS               ; if all values nonzero, carry flag is set
        Line 3905: INX 
          Branch exit: Line 3902: EmptyChkLoop: CLC               ; clear carry flag by default
        Line 3908: ExitEmptyChk: RTS               ; if all values nonzero, carry flag is set

Function CheckAnimationStop
  Inputs: [X]
  Outputs: []
  Line 13862: CheckAnimationStop: 
    Branch exit: Line 13872: CheckDefeatedState: 
    Line 13867: TXA 

Function GetFireballOffscreenBits
  Inputs: [X]
  Outputs: []
    Line 14830: GetFireballOffscreenBits: 
      Branch exit: Line 14873: GetOffScreenBitsSet: 

Function GetBubbleOffscreenBits
  Inputs: [X]
  Outputs: [X]
    Line 14836: GetBubbleOffscreenBits: 
      Branch exit: Line 14873: GetOffScreenBitsSet: 

Function MoveSwimmingCheepCheep
  Inputs: [X]
  Outputs: []
      Line 9599: MoveSwimmingCheepCheep: 
        Branch exit: Line 9604: CCSwim: STA $03                 ; save enemy state in $03
        Line 9603: JMP MoveEnemySlowVert           ; otherwise jump to move defeated cheep-cheep downwards
          Branch exit: Line 7639: MoveEnemySlowVert: 
        Line 9604: CCSwim: STA $03                 ; save enemy state in $03
          Branch exit: Line 9665: ExSwCC: RTS                     ; leave
          Line 9625: LDA CheepCheepMoveMFlag,X       ; check movement flag
            Branch exit: Line 9639: CCSwimUpwards: 
            Line 9628: LDA Enemy_YMF_Dummy,X
              Branch exit: Line 9650: ChkSwimYPos: 

Function SetBBox2
  Inputs: [A, X]
  Outputs: []
  Line 8878: SetBBox2: STA Enemy_BoundBoxCtrl,X; set bounding box control then leave

Function ProcessLengthData
  Inputs: [A]
  Outputs: [A]
      Line 15921: ProcessLengthData: 

Function HandleAreaMusicLoopB
  Inputs: [A]
  Outputs: []
  Line 15648: HandleAreaMusicLoopB: 
    Branch exit: Line 15661: FindAreaMusicHeader: 
    Line 15654: INC GroundMusicHeaderOfs        ; increment but only if playing ground level music
      Branch exit: Line 15670: LoadHeader: 
      Line 15658: LDY #$11
        Branch exit: Line 15646: GMLoopB: STY GroundMusicHeaderOfs
        Line 15660: 
    Line 15661: FindAreaMusicHeader: 

Function FallingSub
  Inputs: []
  Outputs: []
    Line 5919: FallingSub: 
      Branch exit: Line 5951: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)

Function LRAir
  Inputs: []
  Outputs: []
  Line 5951: LRAir: LDA Left_Right_Buttons   ; check left/right controller bits (check for jumping/falling)
    Branch exit: Line 5954: JSMove: JSR MovePlayerHorizontally; do a sub to move player horizontally
    Line 5953: JSR ImposeFriction              ; otherwise process horizontal movement
    Line 5954: JSMove: JSR MovePlayerHorizontally; do a sub to move player horizontally
      Branch exit: Line 5961: ExitMov1: JMP MovePlayerVertically; jump to move player vertically, then leave
      Line 5959: LDA #$28
      Line 5961: ExitMov1: JMP MovePlayerVertically; jump to move player vertically, then leave
        Branch exit: Line 7590: MovePlayerVertically: 

Function FindEmptyMiscSlot
  Inputs: []
  Outputs: [CarryFlag]
    Line 7004: FindEmptyMiscSlot: 
      Line 7006: FMiscLoop: LDA Misc_State,Y     ; get misc object state
        Branch exit: Line 7012: UseMiscS: STY JumpCoinMiscOffset; store offset of misc object buffer here (residual)
        Line 7008: DEY                             ; decrement offset
          Branch exit: Line 7006: FMiscLoop: LDA Misc_State,Y     ; get misc object state
          Line 7011: LDY #$08                        ; if no empty slots found, use last slot
        Line 7012: UseMiscS: STY JumpCoinMiscOffset; store offset of misc object buffer here (residual)

Function SmallPlatformBoundBox
  Inputs: []
  Outputs: []
    Line 12807: SmallPlatformBoundBox: 

Function SixSpriteStacker
  Inputs: [A, Y, $02]
  Outputs: []
    Line 13166: SixSpriteStacker: 
      Line 13168: StkLp: STA Sprite_Data,Y        ; store X or Y coordinate into OAM data
        Branch exit: Line 13168: StkLp: STA Sprite_Data,Y        ; store X or Y coordinate into OAM data
        Line 13177: LDY $02                         ; get saved OAM data offset and leave

Function GoContinue
  Inputs: [A]
  Outputs: []
  Line 1055: GoContinue: STA WorldNumber     ; start both players at the first area

Function PlayerChangeSize
  Inputs: []
  Outputs: []
    Line 5736: PlayerChangeSize: 
      Branch exit: Line 5741: EndChgSize: CMP #$c4            ; check again for another specific moment
      Line 5740: JMP InitChangeSize              ; otherwise run code to get growing/shrinking going
        Branch exit: Line 5757: InitChangeSize: 
      Line 5741: EndChgSize: CMP #$c4            ; check again for another specific moment
        Branch exit: Line 5744: ExitChgSize: RTS                ; and then leave
        Line 5743: JSR DonePlayerTask              ; otherwise do sub to init timer control and set routine
        Line 5744: ExitChgSize: RTS                ; and then leave

Function BalancePlatRope
  Inputs: [X]
  Outputs: []
    Line 4002: BalancePlatRope: 

Function PlayerGfxHandler
  Inputs: []
  Outputs: []
  Line 14439: PlayerGfxHandler: 
    Branch exit: Line 14445: CntPl: LDA GameEngineSubroutine ; if executing specific game engine routine,
    Line 14442: LDA FrameCounter
      Branch exit: Line 14476: ExPGH: RTS                      ; then leave
    Line 14445: CntPl: LDA GameEngineSubroutine ; if executing specific game engine routine,
      Branch exit: Line 14486: PlayerKilled: 
      Line 14448: LDA PlayerChangeSizeFlag        ; if grow/shrink flag set
        Branch exit: Line 14482: DoChangeSize: 
        Line 14450: LDY SwimmingFlag                ; if swimming flag set, branch to
          Branch exit: Line 14478: FindPlayerAction: 
          Line 14452: LDA Player_State
            Branch exit: Line 14478: FindPlayerAction: 
            Line 14455: JSR FindPlayerAction            ; otherwise jump and return
              Branch exit: Line 14476: ExPGH: RTS                      ; then leave
              Line 14459: TAX                             ; initialize X to zero
                Branch exit: Line 14468: SwimKT: LDA PlayerSize          ; check player's size
                Line 14464: INY 
                Line 14468: SwimKT: LDA PlayerSize          ; check player's size
                  Branch exit: Line 14474: BigKTS: LDA SwimKickTileNum,X   ; overwrite tile number in sprite 7/8
                  Line 14470: LDA Sprite_Tilenumber+24,Y      ; check tile number of seventh/eighth sprite
                    Branch exit: Line 14476: ExPGH: RTS                      ; then leave
                    Line 14473: INX                             ; otherwise increment X for second tile
                  Line 14474: BigKTS: LDA SwimKickTileNum,X   ; overwrite tile number in sprite 7/8
    Line 14476: ExPGH: RTS                      ; then leave

Function SetupPlatformRope
  Inputs: [A, Y]
  Outputs: [$01, $00]
    Line 10810: SetupPlatformRope: 
      Branch exit: Line 10819: GetLRp: PHA                     ; save modified horizontal coordinate to stack
      Line 10817: CLC 
      Line 10819: GetLRp: PHA                     ; save modified horizontal coordinate to stack
        Branch exit: Line 10836: GetHRp: TXA                     ; move vertical coordinate to A
        Line 10832: TXA 
        Line 10836: GetHRp: TXA                     ; move vertical coordinate to A
          Branch exit: Line 10862: ExPRp: RTS                      ; leave!
          Line 10859: LDA $00
          Line 10862: ExPRp: RTS                      ; leave!

Function DoNothing1
  Inputs: []
  Outputs: []
    Line 3031: DoNothing1: 
      Line 3034: DoNothing2:  (as a call, not in function)

Function InitVStf
  Inputs: [X]
  Outputs: [A]
    Line 8231: InitVStf: LDA #$00              ; initialize vertical speed

Function TerminateGame
  Inputs: [CarryFlag]
  Outputs: []
      Line 2980: TerminateGame: 
        Branch exit: Line 2994: ContinueGame: 
        Line 2985: LDA WorldNumber                 ; otherwise put world number of current

Function DrawPlayerLoop
  Inputs: [X, $07]
  Outputs: []
      Line 14580: DrawPlayerLoop: 
        Branch exit: Line 14580: DrawPlayerLoop: 
        Line 14587: RTS 

Function LargePlatformBoundBox
  Inputs: [X, A]
  Outputs: []
    Line 12829: LargePlatformBoundBox: 
      Branch exit: Line 12845: MoveBoundBoxOffscreen: 
      Line 12835: 

Function EndFrenzy
  Inputs: [X]
  Outputs: []
    Line 8856: EndFrenzy: 
      Line 8858: LakituChk: LDA Enemy_ID,Y       ; check enemy identifiers
        Branch exit: Line 8863: NextFSlot: DEY                  ; move onto the next slot
        Line 8861: LDA #$01                        ; if found, set state
        Line 8863: NextFSlot: DEY                  ; move onto the next slot
          Branch exit: Line 8858: LakituChk: LDA Enemy_ID,Y       ; check enemy identifiers
          Line 8865: LDA #$00

Function Hole_Empty
  Inputs: [CarryFlag, X]
  Outputs: []
      Line 4219: Hole_Empty: 
        Branch exit: Line 4245: NoWhirlP: LDX AreaType          ; get appropriate metatile, then
        Line 4222: LDA AreaType                    ; check for water type level
          Branch exit: Line 4245: NoWhirlP: LDX AreaType          ; get appropriate metatile, then
          Line 4224: LDX Whirlpool_Offset            ; get offset for data used by cannons and whirlpools
            Branch exit: Line 4244: StrWOffset: STX Whirlpool_Offset; save new offset here
            Line 4243: LDX #$00                        ; otherwise initialize it
            Line 4244: StrWOffset: STX Whirlpool_Offset; save new offset here
        Line 4245: NoWhirlP: LDX AreaType          ; get appropriate metatile, then

Function SprObjectCollisionCore
  Inputs: [Y, X]
  Outputs: [CarryFlag]
      Line 12938: SprObjectCollisionCore: 

Function CheckPlayerVertical
  Inputs: []
  Outputs: [CarryFlag]
    Line 11871: CheckPlayerVertical: 
      Branch exit: Line 11880: ExCPV: RTS 
      Line 11875: LDY Player_Y_HighPos            ; if player high vertical byte is not
        Branch exit: Line 11880: ExCPV: RTS 
        Line 11878: LDA Player_Y_Position           ; if on the screen, check to see how far down
      Line 11880: ExCPV: RTS 

Function Bridge_Low
  Inputs: [X]
  Outputs: []
        Line 3947: Bridge_Low: 
          Branch exit: Line 4252: RenderUnderPart: 

Function InitEnemyFrenzy
  Inputs: [X]
  Outputs: []
    Line 8834: InitEnemyFrenzy: 
      Line 8840: 
        Line 8851: NoFrenzyCode:  (as a call, not in function)

Function RXSpd
  Inputs: [X]
  Outputs: []
  Line 11700: RXSpd: LDA Enemy_X_Speed,X      ; load horizontal speed

Function NoInitCode
  Inputs: []
  Outputs: []
        Line 8137: NoInitCode: 

Function PutBlockMetatile
  Inputs: [X, Y, A, $06, $02]
  Outputs: []
    Line 2060: PutBlockMetatile: 
      Branch exit: Line 2071: SaveHAdder: STY $03             ; save high byte here
      Line 2070: LDY #$24                        ; otherwise load high byte for name table 1
      Line 2071: SaveHAdder: STY $03             ; save high byte here
        Line 2092: RemBridge: LDA BlockGfxData,X   ; write top left and top right (as a call, not in function)

Function SideExitPipeEntry
  Inputs: []
  Outputs: []
    Line 5709: SideExitPipeEntry: 

Function ImposeGravity
  Inputs: [A, X, $00, $02, $01]
  Outputs: []
  Line 7708: ImposeGravity: 
    Branch exit: Line 7718: AlterYP: STY $07                ; store Y here
    Line 7717: DEY                             ; otherwise decrement Y
    Line 7718: AlterYP: STY $07                ; store Y here
      Branch exit: Line 7740: ChkUpM: PLA                     ; get value from stack
      Line 7733: LDA SprObject_Y_MoveForce,X
        Branch exit: Line 7740: ChkUpM: PLA                     ; get value from stack
        Line 7736: LDA $02
      Line 7740: ChkUpM: PLA                     ; get value from stack
        Branch exit: Line 7763: ExVMove: RTS                    ; leave!
        Line 7742: LDA $02
          Branch exit: Line 7763: ExVMove: RTS                    ; leave!
          Line 7756: LDA SprObject_Y_MoveForce,X
            Branch exit: Line 7763: ExVMove: RTS                    ; leave!
            Line 7759: LDA $07
        Line 7763: ExVMove: RTS                    ; leave!

Function DrawVine
  Inputs: [Y]
  Outputs: [Y]
      Line 13108: DrawVine: 
        Line 13135: VineTL: LDA #$e1                ; set tile number for sprite
          Branch exit: Line 13135: VineTL: LDA #$e1                ; set tile number for sprite
          Line 13143: LDY $02                         ; get original offset
            Branch exit: Line 13148: SkpVTop: LDX #$00               ; start with the first sprite again
            Line 13146: LDA #$e0
            Line 13148: SkpVTop: LDX #$00               ; start with the first sprite again
              Line 13149: ChkFTop: LDA VineStart_Y_Position; get original starting vertical coordinate
                Branch exit: Line 13156: NextVSp: INY                    ; move offset to next OAM data
                Line 13154: LDA #$f8
                Line 13156: NextVSp: INY                    ; move offset to next OAM data
                  Branch exit: Line 13149: ChkFTop: LDA VineStart_Y_Position; get original starting vertical coordinate
                  Line 13163: LDY $00                         ; return offset set earlier

Function SprObjectOffscrChk
  Inputs: []
  Outputs: []
  Line 14023: SprObjectOffscrChk: 
    Branch exit: Line 14033: LcChk: PLA                      ; get from stack
    Line 14031: LDA #$04                        ; set for right column sprites
    Line 14033: LcChk: PLA                      ; get from stack
      Branch exit: Line 14039: Row3C: PLA                      ; get from stack again
      Line 14037: LDA #$00                        ; set for left column sprites,
      Line 14039: Row3C: PLA                      ; get from stack again
        Branch exit: Line 14046: Row23C: PLA                     ; get from stack
        Line 14044: LDA #$10                        ; set for third row of sprites
        Line 14046: Row23C: PLA                     ; get from stack
          Branch exit: Line 14052: AllRowC: PLA                    ; get from stack once more
          Line 14050: LDA #$08                        ; set for second and third rows
          Line 14052: AllRowC: PLA                    ; get from stack once more
            Branch exit: Line 14064: ExEGHandler: 
            Line 14055: JSR MoveESprRowOffscreen        ; move all sprites offscreen (A should be 0 by now)
              Branch exit: Line 14064: ExEGHandler: 
              Line 14059: LDA Enemy_Y_HighPos,X           ; check high byte of vertical position
                Branch exit: Line 14064: ExEGHandler: 
                Line 14062: JSR EraseEnemyObject            ; what it says
            Line 14064: ExEGHandler: 

Function FlagpoleSlide
  Inputs: []
  Outputs: []
    Line 5814: FlagpoleSlide: 
      Branch exit: Line 5827: NoFPObj: INC GameEngineSubroutine; increment to next routine (this may
      Line 5818: LDA FlagpoleSoundQueue          ; load flagpole sound
        Branch exit: Line 5826: SlidePlayer: JMP AutoControlPlayer; jump to player control routine
        Line 5825: LDA #$04                        ; otherwise force player to climb down (to slide)
        Line 5826: SlidePlayer: JMP AutoControlPlayer; jump to player control routine
          Branch exit: Line 5559: AutoControlPlayer: 
      Line 5827: NoFPObj: INC GameEngineSubroutine; increment to next routine (this may

Function HammerBroBGColl
  Inputs: [ZeroFlag, A, X]
  Outputs: []
  Line 12684: HammerBroBGColl: 
    Branch exit: Line 12705: NoUnderHammerBro: 
    Line 12687: CMP #$23                        ; check for blank metatile $23 and branch if not found
      Branch exit: Line 12696: UnderHammerBro: 
      Line 12689: 
        Line 12690: KillEnemyAboveBlock:  (as a call, not in function)

Function MoveLiftPlatforms
  Inputs: [X]
  Outputs: []
    Line 10986: MoveLiftPlatforms: 
      Branch exit: Line 11002: ExLiftP: RTS                    ; then leave
      Line 10989: LDA Enemy_YMF_Dummy,X

Function InitializeMemory
  Inputs: [Y]
  Outputs: [A]
    Line 2774: InitializeMemory: 
      Line 2778: InitPageLoop: STX $07
        Line 2779: InitByteLoop: CPX #$01          ; check to see if we're on the stack ($0100-$01ff)
          Branch exit: Line 2783: InitByte: STA ($06),Y           ; otherwise, initialize byte with current low byte in Y
          Line 2781: CPY #$60                        ; otherwise, check to see if we're at $0160-$01ff
            Branch exit: Line 2784: SkipByte: DEY 
          Line 2783: InitByte: STA ($06),Y           ; otherwise, initialize byte with current low byte in Y
          Line 2784: SkipByte: DEY 
            Branch exit: Line 2779: InitByteLoop: CPX #$01          ; check to see if we're on the stack ($0100-$01ff)
            Line 2787: DEX                             ; go onto the next page
              Branch exit: Line 2778: InitPageLoop: STX $07
              Line 2789: RTS 

Function WriteNTAddr
  Inputs: [A]
  Outputs: []
      Line 2395: WriteNTAddr: STA PPU_ADDRESS
        Line 2401: InitNTLoop: STA PPU_DATA        ; count out exactly 768 tiles
          Branch exit: Line 2401: InitNTLoop: STA PPU_DATA        ; count out exactly 768 tiles
          Line 2404: DEX 
            Branch exit: Line 2401: InitNTLoop: STA PPU_DATA        ; count out exactly 768 tiles
            Line 2406: LDY #64                         ; now to clear the attribute table (with zero this time)
              Line 2410: InitATLoop: STA PPU_DATA
                Branch exit: Line 2410: InitATLoop: STA PPU_DATA
                Line 2413: STA HorizontalScroll            ; reset scroll variables
                  Branch exit: Line 2501: InitScroll: STA PPU_SCROLL_REG  ; store contents of A into scroll registers

Function InitNormalEnemy
  Inputs: []
  Outputs: []
      Line 8170: InitNormalEnemy: 
        Branch exit: Line 8175: GetESpd: LDA NormalXSpdData,Y   ; get appropriate horizontal speed
        Line 8174: DEY                             ; if not set, decrement offset
        Line 8175: GetESpd: LDA NormalXSpdData,Y   ; get appropriate horizontal speed

Function JumpEngine
  Inputs: [A]
  Outputs: []
                                              Line 2369: JumpEngine: 

Function PlayerEntrance
  Inputs: []
  Outputs: []
        Line 5498: PlayerEntrance: 
          Branch exit: Line 5520: EntrMode2: LDA JoypadOverride   ; if controller override bits set here,
          Line 5502: LDA #$00
            Branch exit: Line 5559: AutoControlPlayer: 
            Line 5506: LDA PlayerEntranceCtrl          ; check player entry bits from header
              Branch exit: Line 5511: ChkBehPipe: LDA Player_SprAttrib; check for sprite attributes
              Line 5509: CMP #$07                        ; otherwise branch to normal entry
                Branch exit: Line 5546: PlayerRdy: LDA #$08             ; set routine to be executed by game engine next frame
              Line 5511: ChkBehPipe: LDA Player_SprAttrib; check for sprite attributes
                Branch exit: Line 5515: IntroEntr: JSR EnterSidePipe    ; execute sub to move player to the right
                Line 5513: LDA #$01
                  Branch exit: Line 5559: AutoControlPlayer: 
                Line 5515: IntroEntr: JSR EnterSidePipe    ; execute sub to move player to the right
                  Branch exit: Line 5554: ExitEntr: RTS                   ; leave!
                  Line 5518: INC DisableIntermediate         ; set flag to skip world and lives display
                    Branch exit: Line 5867: NextArea: INC AreaNumber        ; increment area number used for address loader
          Line 5520: EntrMode2: LDA JoypadOverride   ; if controller override bits set here,
            Branch exit: Line 5528: VineEntr: LDA VineHeight
            Line 5522: LDA #$ff                        ; otherwise, set value here then execute sub
              Branch exit: Line 5546: PlayerRdy: LDA #$08             ; set routine to be executed by game engine next frame
              Line 5527: RTS                             ; to the last part, otherwise leave
            Line 5528: VineEntr: LDA VineHeight
              Branch exit: Line 5554: ExitEntr: RTS                   ; leave!
              Line 5531: LDA Player_Y_Position           ; get player's vertical coordinate
                Branch exit: Line 5541: OffVine: STY DisableCollisionDet; set collision detection disable flag
                Line 5536: LDA #$03
                Line 5541: OffVine: STY DisableCollisionDet; set collision detection disable flag
                  Branch exit: Line 5554: ExitEntr: RTS                   ; leave!
          Line 5546: PlayerRdy: LDA #$08             ; set routine to be executed by game engine next frame
          Line 5554: ExitEntr: RTS                   ; leave!

Function BrickShatter
  Inputs: [X, $02, $06]
  Outputs: []
    Line 7383: BrickShatter: 

Function RunAllH
  Inputs: [X]
  Outputs: []
        Line 6956: RunAllH: JSR PlayerHammerCollision; handle collisions

Function PlayerFireFlower
  Inputs: []
  Outputs: []
    Line 5783: PlayerFireFlower: 
      Branch exit: Line 5800: ResetPalFireFlower: 
      Line 5787: LDA FrameCounter                ; get frame counter
        Line 5791: CyclePlayerPalette:  (as a call, not in function)

Function JCoinC
  Inputs: [Y, X]
  Outputs: []
  Line 6993: JCoinC: LDA #$fb

Function ContinueCGrabTTick
  Inputs: []
  Outputs: []
  Line 15380: ContinueCGrabTTick: 
    Branch exit: Line 15386: N2Tone: BNE DecrementSfx2Length
    Line 15384: LDA #$54                        ; if so, load the tone directly into the reg
    Line 15386: N2Tone: BNE DecrementSfx2Length
      Branch exit: Line 15419: DecrementSfx2Length: 
      Line 15387: 

Function FPGfx
  Inputs: [X]
  Outputs: []
            Line 6622: FPGfx: JSR GetEnemyOffscreenBits; get offscreen information

Function GetPipeHeight
  Inputs: [X]
  Outputs: []
    Line 3890: GetPipeHeight: 

Function UpToFiery
  Inputs: [A]
  Outputs: []
  Line 11281: UpToFiery: 

Function PlayerHammerCollision
  Inputs: [X]
  Outputs: []
    Line 11207: PlayerHammerCollision: 
      Branch exit: Line 11237: ExPHC: RTS 
      Line 11211: LDA TimerControl                ; if either master timer control
        Branch exit: Line 11237: ExPHC: RTS 
        Line 11214: TXA 
          Branch exit: Line 11235: ClHCol: LDA #$00                ; clear collision flag
          Line 11223: LDA Misc_Collision_Flag,X       ; otherwise read collision flag
            Branch exit: Line 11237: ExPHC: RTS 
            Line 11225: LDA #$01
              Branch exit: Line 11237: ExPHC: RTS 
              Line 11234: JMP InjurePlayer                ; otherwise jump to hurt player, do not return
                Branch exit: Line 11405: InjurePlayer: 
          Line 11235: ClHCol: LDA #$00                ; clear collision flag
      Line 11237: ExPHC: RTS 

Function PlatLiftUp
  Inputs: [X]
  Outputs: []
    Line 8960: PlatLiftUp: 
      Branch exit: Line 8977: CommonSmallLift: 

Function FlipBowserOver
  Inputs: [X]
  Outputs: []
  Line 13729: FlipBowserOver: 

Function WaterPipe
  Inputs: [X, $07]
  Outputs: []
    Line 3774: WaterPipe: 

Function ResetSpritesAndScreenTimer
  Inputs: []
  Outputs: []
    Line 1778: ResetSpritesAndScreenTimer: 
      Branch exit: Line 1787: NoReset: RTS 
      Line 1781: JSR MoveAllSpritesOffscreen     ; otherwise reset sprites now
        Line 1783: ResetScreenTimer:  (as a call, not in function)
      Line 1787: NoReset: RTS 

Function NextAObj
  Inputs: []
  Outputs: []
                Line 3352: NextAObj: JSR IncAreaObjOffset  ; increment buffer offset and move on

Function GetOffsetFromAnimCtrl
  Inputs: [A, Y]
  Outputs: []
  Line 14713: GetOffsetFromAnimCtrl: 

Function LargeLiftBBox
  Inputs: []
  Outputs: []
  Line 8955: LargeLiftBBox: 
    Branch exit: Line 8936: SPBBox: LDA #$05                ; set default bounding box size control

Function AreaParserTasks
  Inputs: [A]
  Outputs: []
    Line 3052: AreaParserTasks: 
      Line 3054: 
        Line 3066: IncrementColumnPos:  (as a call, not in function)

Function GetYOffscreenBits
  Inputs: [X]
  Outputs: []
  Line 14953: GetYOffscreenBits: 
    Line 14956: YOfsLoop: LDA HighPosUnitData,Y ; load coordinate for edge of vertical unit
      Branch exit: Line 14972: YLdBData: LDA YOffscreenBitsData,X; get offscreen data bits using offset
      Line 14965: LDX DefaultYOnscreenOfs+1,Y     ; if not, load alternate offset value here
        Branch exit: Line 14972: YLdBData: LDA YOffscreenBitsData,X; get offscreen data bits using offset
        Line 14968: LDA #$20                        ; if no branching, load value here and store
      Line 14972: YLdBData: LDA YOffscreenBitsData,X; get offscreen data bits using offset
        Branch exit: Line 14978: ExYOfsBS: RTS 
        Line 14976: DEY                             ; otherwise, do bottom of the screen now
          Branch exit: Line 14956: YOfsLoop: LDA HighPosUnitData,Y ; load coordinate for edge of vertical unit
        Line 14978: ExYOfsBS: RTS 

Function MoveFlyingCheepCheep
  Inputs: [X]
  Outputs: []
        Line 9926: MoveFlyingCheepCheep: 
          Branch exit: Line 9933: FlyCC: JSR MoveEnemyHorizontally; move cheep-cheep horizontally based on speed and force
          Line 9930: LDA #$00
            Branch exit: Line 7646: MoveJ_EnemyVertically: 
          Line 9933: FlyCC: JSR MoveEnemyHorizontally; move cheep-cheep horizontally based on speed and force
            Branch exit: Line 9950: AddCCF: CMP #$08                ; if result or two's compliment greater than eight,
            Line 9947: EOR #$ff
            Line 9950: AddCCF: CMP #$08                ; if result or two's compliment greater than eight,
              Branch exit: Line 9961: BPGet: LDA FlyCCBPriority,Y     ; load bg priority data and store (this is very likely
              Line 9952: LDA Enemy_Y_MoveForce,X
              Line 9961: BPGet: LDA FlyCCBPriority,Y     ; load bg priority data and store (this is very likely

Function InitEnemyObject
  Inputs: [X]
  Outputs: []
  Line 8016: InitEnemyObject: 

Function CheckForClimbMTiles
  Inputs: [A, X]
  Outputs: [CarryFlag]
      Line 12370: CheckForClimbMTiles: 

Function GetAreaDataAddrs
  Inputs: []
  Outputs: []
    Line 4381: GetAreaDataAddrs: 
      Branch exit: Line 4413: StoreFore: STA ForegroundScenery; if less, save value here as foreground scenery
      Line 4411: STA BackgroundColorCtrl         ; if 4 or greater, save value here as bg color control
      Line 4413: StoreFore: STA ForegroundScenery; if less, save value here as foreground scenery
        Branch exit: Line 4451: StoreStyle: STA AreaStyle
        Line 4449: STA CloudTypeOverride           ; otherwise store value in other place
        Line 4451: StoreStyle: STA AreaStyle

Function MoveEnemySlowVert
  Inputs: []
  Outputs: []
  Line 7639: MoveEnemySlowVert: 

Function MoveAOId
  Inputs: [A]
  Outputs: []
                Line 3434: MoveAOId: LSR                   ; move d6-d4 to lower nybble

Function BlockBufferChk_FBall
  Inputs: [X]
  Outputs: [ZeroFlag]
    Line 13019: BlockBufferChk_FBall: 

Function ChkYPCollision
  Inputs: [X]
  Outputs: []
  Line 10922: ChkYPCollision: 
    Branch exit: Line 10926: ExYPl: RTS                      ; leave
    Line 10925: JSR PositionPlayerOnVPlat       ; otherwise position player appropriately
    Line 10926: ExYPl: RTS                      ; leave

Function RemoveCoin_Axe
  Inputs: [$06, $02]
  Outputs: []
  Line 2015: RemoveCoin_Axe: 
    Branch exit: Line 2021: WriteBlankMT: JSR PutBlockMetatile; do a sub to write blank metatile to vram buffer
    Line 2020: LDA #$04                        ; otherwise load offset for blank metatile used in water
    Line 2021: WriteBlankMT: JSR PutBlockMetatile; do a sub to write blank metatile to vram buffer

Function FireballObjCore
  Inputs: [X, $01]
  Outputs: []
      Line 6331: FireballObjCore: 
        Branch exit: Line 6384: FireballExplosion: 
        Line 6336: LDY Fireball_State,X            ; if fireball inactive, branch to leave
          Branch exit: Line 6382: NoFBall: RTS                    ; leave
          Line 6338: DEY                             ; if fireball state set to 1, skip this part and just run it
            Branch exit: Line 6359: RunFB: TXA                      ; add 7 to offset to use
            Line 6340: LDA Player_X_Position           ; get player's horizontal position
            Line 6359: RunFB: TXA                      ; add 7 to offset to use
              Branch exit: Line 6380: EraseFB: LDA #$00               ; erase fireball state
              Line 6378: JSR FireballEnemyCollision      ; do fireball to enemy collision detection and deal with collisions
                Branch exit: Line 14233: DrawFireball: 
              Line 6380: EraseFB: LDA #$00               ; erase fireball state
          Line 6382: NoFBall: RTS                    ; leave

Function InitRedPTroopa
  Inputs: [X, CarryFlag]
  Outputs: []
      Line 8218: InitRedPTroopa: 
        Branch exit: Line 8224: GetCent: TYA                    ; send central position adder to A
        Line 8223: LDY #$e0                        ; if => $80, load position adder for 32 pixels up
        Line 8224: GetCent: TYA                    ; send central position adder to A

Function SetBBox
  Inputs: [A, X]
  Outputs: []
  Line 8228: SetBBox: STA Enemy_BoundBoxCtrl,X; set bounding box control here
    Line 8231: InitVStf: LDA #$00              ; initialize vertical speed (as a call, not in function)

Function Square2SfxHandler
  Inputs: []
  Outputs: []
    Line 15434: Square2SfxHandler: 
      Branch exit: Line 15503: ContinueExtraLife: 
      Line 15438: LDY Square2SoundQueue           ; check for sfx in queue
        Branch exit: Line 15457: CheckSfx2Buffer: 
        Line 15440: STY Square2SoundBuffer          ; if found, put in buffer and check for the following
          Branch exit: Line 15483: PlayBowserFall: 
          Line 15442: LSR Square2SoundQueue
            Branch exit: Line 15365: PlayCoinGrab: 
            Line 15444: LSR Square2SoundQueue
              Branch exit: Line 15516: PlayGrowPowerUp: 
              Line 15446: LSR Square2SoundQueue
                Branch exit: Line 15520: PlayGrowVine: 
                Line 15448: LSR Square2SoundQueue
                  Branch exit: Line 15388: PlayBlast: 
                  Line 15450: LSR Square2SoundQueue
                    Branch exit: Line 15370: PlayTimerTick: 
                    Line 15452: LSR Square2SoundQueue
                      Branch exit: Line 15403: PlayPowerUpGrab: 
                      Line 15454: LSR Square2SoundQueue
                        Branch exit: Line 15499: PlayExtraLife: 
                        Line 15456: 
        Line 15457: CheckSfx2Buffer: 
          Branch exit: Line 15475: ExS2H: RTS 
          Line 15460: BMI ContinueBowserFall          ; bowser fall
            Branch exit: Line 15490: ContinueBowserFall: 
            Line 15461: LSR 
              Branch exit: Line 15477: Cont_CGrab_TTick: 
              Line 15463: LSR 
                Branch exit: Line 15530: ContinueGrowItems: 
                Line 15465: LSR 
                  Branch exit: Line 15530: ContinueGrowItems: 
                  Line 15467: LSR 
                    Branch exit: Line 15395: ContinueBlast: 
                    Line 15469: LSR 
                      Branch exit: Line 15477: Cont_CGrab_TTick: 
                      Line 15471: LSR 
                        Branch exit: Line 15407: ContinuePowerUpGrab: 
                        Line 15473: LSR 
                          Branch exit: Line 15503: ContinueExtraLife: 
          Line 15475: ExS2H: RTS 

Function MovePodoboo
  Inputs: [X]
  Outputs: []
    Line 9191: MovePodoboo: 
      Branch exit: Line 9203: PdbM: JMP MoveJ_EnemyVertically ; branch to impose gravity on podoboo
      Line 9194: JSR InitPodoboo                 ; otherwise set up podoboo again
      Line 9203: PdbM: JMP MoveJ_EnemyVertically ; branch to impose gravity on podoboo
        Branch exit: Line 7646: MoveJ_EnemyVertically: 

Function PosPlatform
  Inputs: [X, Y]
  Outputs: []
        Line 8992: PosPlatform: 

Function ThankPlayer
  Inputs: [A]
  Outputs: []
        Line 1191: ThankPlayer: TAY                ; put primary message counter into Y
          Branch exit: Line 1197: SecondPartMsg: INY              ; increment Y to do world 8's message
          Line 1193: LDA CurrentPlayer               ; otherwise get player currently on the screen
            Branch exit: Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
            Line 1195: INY                             ; otherwise increment Y once for luigi and
              Branch exit: Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
          Line 1197: SecondPartMsg: INY              ; increment Y to do world 8's message
            Branch exit: Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
            Line 1201: DEY                             ; otherwise decrement Y for world 1-7's message
              Branch exit: Line 1222: SetEndTimer: BCC ExitMsgs       ; if not reached value yet, branch to leave
              Line 1204: CPY #$03                        ; if counter at 3 (world 1-7 only)
                Branch exit: Line 1214: IncMsgCounter: LDA SecondaryMsgCounter
          Line 1206: EvalForMusic: CPY #$03          ; if counter not yet at 3 (world 8 only), branch
            Branch exit: Line 1210: PrintMsg: TYA                   ; put primary message counter in A
            Line 1208: LDA #VictoryMusic               ; reach this code if counter = 0, and will always branch)
            Line 1210: PrintMsg: TYA                   ; put primary message counter in A

Function ChkFireB
  Inputs: []
  Outputs: []
    Line 10244: ChkFireB: LDA WorldNumber       ; check world number here
      Branch exit: Line 10249: SpawnFBr: LDA BowserFireBreathTimer; check timer here
      Line 10247: CMP #World6                     ; world 6-7?
        Branch exit: Line 10268: BowserGfxHandler: 
      Line 10249: SpawnFBr: LDA BowserFireBreathTimer; check timer here
        Branch exit: Line 10268: BowserGfxHandler: 
        Line 10251: LDA #$20
          Branch exit: Line 10244: ChkFireB: LDA WorldNumber       ; check world number here
          Line 10257: JSR SetFlameTimer               ; get timing for bowser's flame
            Branch exit: Line 10262: SetFBTmr: STA BowserFireBreathTimer; set value as timer here
            Line 10260: SEC 
            Line 10262: SetFBTmr: STA BowserFireBreathTimer; set value as timer here

Function OperModeExecutionTree
  Inputs: []
  Outputs: []
    Line 928: OperModeExecutionTree: 
      Line 931: 
        Line 939: MoveAllSpritesOffscreen:  (as a call, not in function)

Function RelativeEnemyPosition
  Inputs: []
  Outputs: []
    Line 14790: RelativeEnemyPosition: 
      Branch exit: Line 14804: VariableObjOfsRelPos: 

Function DrawExplosion_Fireworks
  Inputs: [A, Y]
  Outputs: []
      Line 14271: DrawExplosion_Fireworks: 

Function PlayerCollisionCore
  Inputs: []
  Outputs: []
    Line 12935: PlayerCollisionCore: 
      Line 12938: SprObjectCollisionCore:  (as a call, not in function)

Function InitHammerBro
  Inputs: [X]
  Outputs: []
      Line 8192: InitHammerBro: 
        Branch exit: Line 8228: SetBBox: STA Enemy_BoundBoxCtrl,X; set bounding box control here

Function CastleBridgeObj
  Inputs: [X]
  Outputs: []
        Line 4034: CastleBridgeObj: 
          Branch exit: Line 4043: ChainObj: 

Function ColorRotation
  Inputs: []
  Outputs: []
          Line 1957: ColorRotation: 
            Branch exit: Line 1998: ExitColorRot: RTS               ; leave
            Line 1961: LDX VRAM_Buffer1_Offset         ; check vram buffer offset
              Branch exit: Line 1998: ExitColorRot: RTS               ; leave
              Line 1964: TAY                             ; otherwise use frame counter's 3 LSB as offset here
                Line 1965: GetBlankPal: LDA BlankPalette,Y ; get blank palette for palette 3
                  Branch exit: Line 1965: GetBlankPal: LDA BlankPalette,Y ; get blank palette for palette 3
                  Line 1971: LDX VRAM_Buffer1_Offset         ; get current vram buffer offset
                    Line 1978: GetAreaPal: LDA Palette3Data,Y  ; fetch palette to be written based on area type
                      Branch exit: Line 1978: GetAreaPal: LDA Palette3Data,Y  ; fetch palette to be written based on area type
                      Line 1984: LDX VRAM_Buffer1_Offset         ; get current vram buffer offset
                        Branch exit: Line 1998: ExitColorRot: RTS               ; leave
                        Line 1996: LDA #$00
            Line 1998: ExitColorRot: RTS               ; leave

Function MoveBulletBill
  Inputs: [X]
  Outputs: []
    Line 9582: MoveBulletBill: 
      Branch exit: Line 9587: NotDefB: LDA #$e8               ; set bullet bill's horizontal speed
      Line 9586: JMP MoveJ_EnemyVertically       ; otherwise jump to move defeated bullet bill downwards
        Branch exit: Line 7646: MoveJ_EnemyVertically: 
      Line 9587: NotDefB: LDA #$e8               ; set bullet bill's horizontal speed
        Branch exit: Line 7534: MoveEnemyHorizontally: 

Function MoveAllSpritesOffscreen
  Inputs: []
  Outputs: []
        Line 939: MoveAllSpritesOffscreen: 
          Line 943: MoveSpritesOffscreen: 
            Line 946: SprInitLoop: STA Sprite_Y_Position,Y; write 248 into OAM data's Y coordinate
              Branch exit: Line 946: SprInitLoop: STA Sprite_Y_Position,Y; write 248 into OAM data's Y coordinate
              Line 952: RTS 

Function FireballBGCollision
  Inputs: [X]
  Outputs: []
    Line 12730: FireballBGCollision: 
      Branch exit: Line 12751: ClearBounceFlag: 
      Line 12734: JSR BlockBufferChk_FBall        ; do fireball to background collision detection on bottom of it
        Branch exit: Line 12751: ClearBounceFlag: 
        Line 12736: JSR ChkForNonSolids             ; check for non-solid metatiles
          Branch exit: Line 12751: ClearBounceFlag: 
          Line 12738: LDA Fireball_Y_Speed,X          ; if fireball's vertical speed set to move upwards,
            Branch exit: Line 12756: InitFireballExplode: 
            Line 12740: LDA FireballBouncingFlag,X      ; if bouncing flag already set,
              Branch exit: Line 12756: InitFireballExplode: 
              Line 12742: LDA #$fd

Function SetHJ
  Inputs: [Y, X, $00]
  Outputs: []
  Line 9264: SetHJ: STY Enemy_Y_Speed,X      ; set vertical speed for jumping
    Branch exit: Line 9274: HJump: LDA HammerBroJumpLData,Y ; get jump length timer data using offset from before
    Line 9273: TAY                             ; if secondary hard mode flag clear, set offset to 0
    Line 9274: HJump: LDA HammerBroJumpLData,Y ; get jump length timer data using offset from before

Function VictoryModeSubroutines
  Inputs: []
  Outputs: []
    Line 1121: VictoryModeSubroutines: 
      Line 1124: 
        Line 1133: SetupVictoryMode:  (as a call, not in function)

Function ForceInjury
  Inputs: [A]
  Outputs: []
      Line 11409: ForceInjury: 
        Branch exit: Line 11431: KillPlayer: 
        Line 11412: STA PlayerStatus                ; otherwise set player's status to small

Function DrawStarFlag
  Inputs: [X]
  Outputs: []
      Line 10534: DrawStarFlag: 
        Line 10538: DSFLoop: LDA Enemy_Rel_YPos     ; get relative vertical coordinate
          Branch exit: Line 10538: DSFLoop: LDA Enemy_Rel_YPos     ; get relative vertical coordinate
          Line 10556: LDX ObjectOffset                ; get enemy object offset and leave

Function MushFlowerBlock
  Inputs: []
  Outputs: []
            Line 7342: MushFlowerBlock: 
              Line 7346: StarBlock: 
                Line 7350: ExtraLifeMushBlock: 
                  Branch exit: Line 7129: SetupPowerUp: 

Function ProcHammerBro
  Inputs: [X]
  Outputs: []
          Line 9217: ProcHammerBro: 
            Branch exit: Line 9222: ChkJH: LDA HammerBroJumpTimer,X ; check jump timer
            Line 9221: JMP MoveDefeatedEnemy           ; otherwise jump to something else
              Branch exit: Line 9360: MoveDefeatedEnemy: 
            Line 9222: ChkJH: LDA HammerBroJumpTimer,X ; check jump timer
              Branch exit: Line 9245: HammerBroJumpCode: 
              Line 9224: DEC HammerBroJumpTimer,X        ; otherwise decrement jump timer
                Branch exit: Line 9280: MoveHammerBroXDir: 
                Line 9228: LDA HammerThrowingTimer,X       ; check hammer throwing timer
                  Branch exit: Line 9239: DecHT: DEC HammerThrowingTimer,X; decrement timer
                  Line 9230: LDY SecondaryHardMode           ; otherwise get secondary hard mode flag
                    Branch exit: Line 9239: DecHT: DEC HammerThrowingTimer,X; decrement timer
                    Line 9235: LDA Enemy_State,X
                      Branch exit: Line 9280: MoveHammerBroXDir: 
                  Line 9239: DecHT: DEC HammerThrowingTimer,X; decrement timer
                    Branch exit: Line 9280: MoveHammerBroXDir: 

Function SetPRout
  Inputs: [A, Y]
  Outputs: []
    Line 11420: SetPRout: STA GameEngineSubroutine; load new value to run subroutine on next frame


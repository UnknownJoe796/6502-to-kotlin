================================================================================
PHASE 4 STRUCTURAL ANALYSIS DEMO
Analyzing Super Mario Bros Disassembly
================================================================================

üìä OVERALL STATISTICS
--------------------------------------------------------------------------------
Total Assembly Lines: 16352
Total Functions: 296
Total Basic Blocks: 3475
Total CFG Edges: 5239


üîç FUNCTION ANALYSIS: ProcessAreaData
================================================================================
Entry Address: 0x0CE5
Basic Blocks: 23
CFG Edges: 37

üìù ANNOTATED ASSEMBLY CODE:
--------------------------------------------------------------------------------
  0x9500                            LDX #$02                        ; [BB_START]
  0x9502  ProcADLoop:               STX ObjectOffset                ; [BB_START, LOOP_DO_WHILE, COND_IF_ELSE_IF, BACK_EDGE_TARGET]
  0x9505                            LDA #$00                        ; reset flag
  0x9507                            STA BehindAreaParserFlag      
  0x950A                            LDY AreaDataOffset              ; get offset of area data pointer
  0x950D                            LDA (AreaData),Y                ; get first byte of area object
  0x950F                            CMP #$fd                        ; if end-of-area, skip all this crap
  0x9511                            BEQ RdyDecode                 
  0x9513                            LDA AreaObjectLength,X          ; [BB_START, COND_IF_ELSE_IF]
  0x9516                            BPL RdyDecode                   ; if buffer not negative, branch, otherwise
  0x9518                            INY                             ; [BB_START, COND_IF_ELSE_IF]
  0x9519                            LDA (AreaData),Y                ; get second byte of area object
  0x951B                            ASL                             ; check for page select bit (d7), branch if not set
  0x951C                            BCC Chk1Row13                 
  0x951E                            LDA AreaObjectPageSel           ; [BB_START, COND_IF_ELSE_IF]
  0x9521                            BNE Chk1Row13                 
  0x9523                            INC AreaObjectPageSel           ; [BB_START]
  0x9526                            INC AreaObjectPageLoc           ; and increment page location
  0x9529  Chk1Row13:                DEY                             ; [BB_START, COND_IF_ELSE_IF]
  0x952A                            LDA (AreaData),Y                ; reread first byte of level object
  0x952C                            AND #$0f                        ; mask out high nybble
  0x952E                            CMP #$0d                        ; row 13?
  0x9530                            BNE Chk1Row14                 
  0x9532                            INY                             ; [BB_START, COND_IF_ELSE_IF]
  0x9533                            LDA (AreaData),Y              
  0x9535                            DEY                             ; decrement to get ready to read first byte
  0x9536                            AND #%01000000                  ; check for d6 set (if not, object is page control)
  0x9538                            BNE CheckRear                 
  0x953A                            LDA AreaObjectPageSel           ; [BB_START, COND_IF_ELSE_IF]
  0x953D                            BNE CheckRear                 
  0x953F                            INY                             ; [BB_START]
  0x9540                            LDA (AreaData),Y              
  0x9542                            AND #%00011111                  ; mask out all but 5 LSB and store in page control
  0x9544                            STA AreaObjectPageLoc         
  0x9547                            INC AreaObjectPageSel           ; increment page select
  0x954A                            JMP NextAObj                  
  0x954D  Chk1Row14:                CMP #$0e                        ; [BB_START, COND_IF_ELSE_IF]
  0x954F                            BNE CheckRear                 
  0x9551                            LDA BackloadingFlag             ; [BB_START, COND_IF_ELSE_IF]
  0x9554                            BNE RdyDecode                   ; to render the object (otherwise bg might not look right)
  0x9556  CheckRear:                LDA AreaObjectPageLoc           ; [BB_START, COND_IF_ELSE_IF]
  0x9559                            CMP CurrentPageLoc              ; behind current page of renderer
  0x955C                            BCC SetBehind                   ; if so branch
  0x955E  RdyDecode:                JSR DecodeAreaData              ; [BB_START]
  0x9561                            JMP ChkLength                   ; [BB_START]
  0x9564  SetBehind:                INC BehindAreaParserFlag        ; [BB_START]
  0x9567  NextAObj:                 JSR IncAreaObjOffset            ; [BB_START]
  0x956A  ChkLength:                LDX ObjectOffset                ; [BB_START, COND_IF_ELSE_IF]
  0x956D                            LDA AreaObjectLength,X          ; check object length for anything stored here
  0x9570                            BMI ProcLoopb                   ; if not, branch to handle loopback
  0x9572                            DEC AreaObjectLength,X          ; [BB_START]
  0x9575  ProcLoopb:                DEX                             ; [BB_START]
  0x9576                            BPL ProcADLoop                  ; and loopback unless exceeded buffer
  0x9578                            LDA BehindAreaParserFlag        ; [BB_START]
  0x957B                            BNE ProcessAreaData             ; branch if true to load more level data, otherwise
  0x957D                            LDA BackloadingFlag             ; [BB_START]
  0x9580                            BNE ProcessAreaData             ; branch if true to load more level data, otherwise leave
  0x9582  EndAParse:                RTS                             ; [BB_START]
--------------------------------------------------------------------------------

üìê Dominator Tree:
  Back Edges: 1
    0xD18 -> 0xCE6
üîÑ Loops Detected: 1
  Loop at 0xCE6:
    Type: DO_WHILE
    Body size: 19 blocks
    Exits: 1
    Nesting depth: 0

üîÄ Conditionals Detected: 11
  Conditional at 0xCE6:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xD10
    Nesting depth: 1
  Conditional at 0xCED:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 9 blocks
    Merge point: 0xD10
    Nesting depth: 2
  Conditional at 0xCEF:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xCF7
    Nesting depth: 3
  ... and 8 more conditionals

üèóÔ∏è  Region Structure:
  Total regions: 25
  Root region depth: 4

  Region tree (first 20 lines):
    Function(entry=3301)
      Sequence(entry=3301)
        Block(3301)
        Loop(header=3302, type=DO_WHILE)
          Sequence(entry=3302)
            Block(3302)
            Block(3309)
            Block(3311)
            Block(3315)
            Block(3317)
            Block(3319)
            Block(3324)
            Block(3329)
            Block(3331)
            Block(3337)
            Block(3339)
            Block(3341)
            Block(3344)
            Block(3345)
            Block(3346)
    ... (26 more lines)

‚ú® Structured Code:
  Fully structured: YES ‚úì
  Control flow breakdown:
    If statements: 0
    Loops: 1
    Breaks: 0
    Continues: 0
    Returns: 0
    Block statements: 42

--------------------------------------------------------------------------------

üîç FUNCTION ANALYSIS: DecodeAreaData
================================================================================
Entry Address: 0x0D28
Basic Blocks: 34
CFG Edges: 52

üìù ANNOTATED ASSEMBLY CODE:
--------------------------------------------------------------------------------
  0x9582  EndAParse:                RTS                             ; [BB_START]
  0x958F                            LDA AreaObjectLength,X          ; [BB_START, COND_IF_ELSE_IF]
  0x9592                            BMI Chk1stB                   
  0x9594                            LDY AreaObjOffsetBuffer,X       ; [BB_START]
  0x9597  Chk1stB:                  LDX #$10                        ; [BB_START, COND_IF_ELSE_IF]
  0x9599                            LDA (AreaData),Y                ; get first byte of level object again
  0x959B                            CMP #$fd                      
  0x959D                            BEQ EndAParse                   ; if end of level, leave this routine
  0x959F                            AND #$0f                        ; [BB_START, COND_IF_ELSE_IF]
  0x95A1                            CMP #$0f                        ; row 15?
  0x95A3                            BEQ ChkRow14                    ; if so, keep the offset of 16
  0x95A5                            LDX #$08                        ; [BB_START, COND_IF_ELSE_IF]
  0x95A7                            CMP #$0c                        ; row 12?
  0x95A9                            BEQ ChkRow14                    ; if so, keep the offset value of 8
  0x95AB                            LDX #$00                        ; [BB_START]
  0x95AD  ChkRow14:                 STX $07                         ; [BB_START, COND_IF_ELSE_IF]
  0x95AF                            LDX ObjectOffset                ; get object offset again
  0x95B2                            CMP #$0e                        ; row 14?
  0x95B4                            BNE ChkRow13                  
  0x95B6                            LDA #$00                        ; [BB_START, COND_IF_ELSE_IF]
  0x95B8                            STA $07                       
  0x95BA                            LDA #$2e                        ; and load A with another value
  0x95BC                            BNE NormObj                     ; unconditional branch
  0x95BE  ChkRow13:                 CMP #$0d                        ; [BB_START, COND_IF_ELSE_IF]
  0x95C0                            BNE ChkSRows                  
  0x95C2                            LDA #$22                        ; [BB_START, COND_IF_ELSE_IF]
  0x95C4                            STA $07                       
  0x95C6                            INY                             ; get next byte
  0x95C7                            LDA (AreaData),Y              
  0x95C9                            AND #%01000000                  ; mask out all but d6 (page control obj bit)
  0x95CB                            BEQ LeavePar                    ; if d6 clear, branch to leave (we handled this earlier)
  0x95CD                            LDA (AreaData),Y                ; [BB_START, COND_IF_ELSE]
  0x95CF                            AND #%01111111                  ; mask out d7
  0x95D1                            CMP #$4b                        ; check for loop command in low nybble
  0x95D3                            BNE Mask2MSB                    ; (plus d6 set for object other than page control)
  0x95D5                            INC LoopCommand                 ; [BB_START]
  0x95D8  Mask2MSB:                 AND #%00111111                  ; [BB_START]
  0x95DA                            JMP NormObj                     ; and jump
  0x95DD  ChkSRows:                 CMP #$0c                        ; [BB_START, COND_IF_ELSE_IF]
  0x95DF                            BCS SpecObj                   
  0x95E1                            INY                             ; [BB_START, COND_IF_ELSE_IF]
  0x95E2                            LDA (AreaData),Y              
  0x95E4                            AND #%01110000                  ; mask out all but d6-d4
  0x95E6                            BNE LrgObj                      ; if any bits set, branch to handle large object
  0x95E8                            LDA #$16                        ; [BB_START]
  0x95EA                            STA $07                         ; otherwise set offset of 24 for small object
  0x95EC                            LDA (AreaData),Y                ; reload second byte of level object
  0x95EE                            AND #%00001111                  ; mask out higher nybble and jump
  0x95F0                            JMP NormObj                   
  0x95F3  LrgObj:                   STA $00                         ; [BB_START, COND_IF_ELSE_IF]
  0x95F5                            CMP #$70                        ; check for vertical pipe object
  0x95F7                            BNE NotWPipe                  
  0x95F9                            LDA (AreaData),Y                ; [BB_START, COND_IF_ELSE]
  0x95FB                            AND #%00001000                  ; mask out all but d3 (usage control bit)
  0x95FD                            BEQ NotWPipe                    ; if d3 clear, branch to get original value
  0x95FF                            LDA #$00                        ; [BB_START]
  0x9601                            STA $00                       
  0x9603  NotWPipe:                 LDA $00                         ; [BB_START]
  0x9605                            JMP MoveAOId                  
  0x9608  SpecObj:                  INY                             ; [BB_START]
  0x9609                            LDA (AreaData),Y              
  0x960B                            AND #%01110000                  ; get next byte and mask out all but d6-d4
  0x960D  MoveAOId:                 LSR                             ; [BB_START]
  0x960E                            LSR                           
  0x960F                            LSR                           
  0x9610                            LSR                           
  0x9611  NormObj:                  STA $00                         ; [BB_START, COND_IF_ELSE_IF]
  0x9613                            LDA AreaObjectLength,X          ; is there something stored here already?
  0x9616                            BPL RunAObj                     ; if so, branch to do its particular sub
  0x9618                            LDA AreaObjectPageLoc           ; [BB_START, COND_IF_ELSE_IF]
  0x961B                            CMP CurrentPageLoc              ; same page as the renderer, and if so, branch
  0x961E                            BEQ InitRear                  
  0x9620                            LDY AreaDataOffset              ; [BB_START, COND_IF_ELSE_IF]
  0x9623                            LDA (AreaData),Y                ; and reload first byte
  0x9625                            AND #%00001111                
  0x9627                            CMP #$0e                        ; row 14?
  0x9629                            BNE LeavePar                  
  0x962B                            LDA BackloadingFlag             ; [BB_START, COND_IF_ELSE]
  0x962E                            BNE StrAObj                     ; if set, branch to render object, else leave
  0x9630  LeavePar:                 RTS                             ; [BB_START]
  0x9631  InitRear:                 LDA BackloadingFlag             ; [BB_START, COND_IF_ELSE]
  0x9634                            BEQ BackColC                    ; branch to column-wise check
  0x9636                            LDA #$00                        ; [BB_START]
  0x9638                            STA BackloadingFlag             ; behind-renderer flags and leave
  0x963B                            STA BehindAreaParserFlag      
  0x963E                            STA ObjectOffset              
  0x9641  LoopCmdE:                 RTS                             ; [BB_START]
  0x9642  BackColC:                 LDY AreaDataOffset              ; [BB_START, COND_IF_ELSE]
  0x9645                            LDA (AreaData),Y              
  0x9647                            AND #%11110000                  ; mask out low nybble and move high to low
  0x9649                            LSR                           
  0x964A                            LSR                           
  0x964B                            LSR                           
  0x964C                            LSR                           
  0x964D                            CMP CurrentColumnPos            ; is this where we're at?
  0x9650                            BNE LeavePar                    ; if not, branch to leave
  0x9652  StrAObj:                  LDA AreaDataOffset              ; [BB_START]
  0x9655                            STA AreaObjOffsetBuffer,X     
  0x9658                            JSR IncAreaObjOffset            ; do sub to increment to next object data
  0x965B  RunAObj:                  LDA $00                         ; [BB_START]
  0x965D                            CLC                             ; then use the jump engine with current contents of A
  0x965E                            ADC $07                       
  0x9660                            JSR JumpEngine                
--------------------------------------------------------------------------------

üìê Dominator Tree:
  Back Edges: 0
üîÄ Conditionals Detected: 19
  Conditional at 0xD28:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xD2B
    Nesting depth: 0
  Conditional at 0xD2B:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 30 blocks
    Merge point: none
    Nesting depth: 1
  Conditional at 0xD2F:
    Type: IF_ELSE_IF
    Then branch: 1 blocks
    Else branch: 2 blocks
    Merge point: 0xD36
    Nesting depth: 2
  ... and 16 more conditionals

üèóÔ∏è  Region Structure:
  Total regions: 36
  Root region depth: 4

  Region tree (first 20 lines):
    Function(entry=3368)
      Sequence(entry=3368)
        Block(3358)
        If(header=3368, type=IF_ELSE_IF)
        Then:
          Block(3371)
        Else:
          Sequence(entry=3370)
            Block(3370)
            Block(3371)
        Block(3368)
        Block(3370)
        Block(3371)
        Block(3375)
        Block(3378)
        Block(3381)
        Block(3382)
        Block(3386)
        Block(3390)
        Block(3392)
    ... (23 more lines)

‚ú® Structured Code:
  Fully structured: YES ‚úì
  Control flow breakdown:
    If statements: 1
    Loops: 0
    Breaks: 0
    Continues: 0
    Returns: 0
    Block statements: 37

--------------------------------------------------------------------------------

üéØ PHASE 4 SUMMARY STATISTICS
================================================================================
Total Loops Detected: 90
  - While loops: 0
  - Do-while loops: 62
  - Infinite loops: 1
  - Multi-exit loops: 27

Total Conditionals Detected: 1583
  - Simple IF: 17
  - IF-ELSE: 363
  - IF-ELSE-IF: 1203

Total Regions Formed: 4157
  - Block regions: 3580
  - Loop regions: 86
  - Conditional regions: 195
  - Sequence regions: 0

Goto Elimination:
  - Fully structured functions: 296 / 296
  - Functions with remaining gotos: 0

Structured Control Flow Statistics:
  - If statements: 225
  - Loop statements: 90
  - Break statements: 0
  - Continue statements: 0
  - Return statements: 0
  - Block statements: 5022
  - Remaining gotos: 0

================================================================================

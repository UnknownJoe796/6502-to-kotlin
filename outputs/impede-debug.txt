ImpedePlayerMove function:
  Starting block: ImpedePlayerMove
  Starting block line: 12322

Blocks in function (5):
  Block: ImpedePlayerMove
    Lines (6):
      ImpedePlayerMove:
      lda #$00                  ;initialize value here
      ldy Player_X_Speed        ;get player's horizontal speed
      ldx $00                   ;check value set earlier for
      dex                       ;left side collision
      bne RImpd                 ;if right side collision, skip this part
  Block: @12328
    Lines (3):
      inx                       ;return value to X
      cpy #$00                  ;if player moving to the left,
      bmi ExIPM                 ;branch to invert bit and leave
  Block: @12331
    Lines (2):
      lda #$ff                  ;otherwise load A with value to be used later
      jmp NXSpd                 ;and jump to affect movement
  Block: RImpd
    Lines (3):
      RImpd: ldx #$02                  ;return $02 to X
      cpy #$01                  ;if player moving to the right,
      bpl ExIPM                 ;branch to invert bit and leave
  Block: @12336
    Lines (1):
      lda #$01                  ;otherwise load A with value to be used here

Control flow (improveControlFlow):
    - If (block ImpedePlayerMove)
        Then (2 nodes):
        - Block: @12328
          Lines: 3
            inx                       ;return value to X
            cpy #$00                  ;if player moving to the left,
            bmi ExIPM                 ;branch to invert bit and leave
        - Block: @12331
          Lines: 2
            lda #$ff                  ;otherwise load A with value to be used later
            jmp NXSpd                 ;and jump to affect movement
    - Block: RImpd
      Lines: 3
        RImpd: ldx #$02                  ;return $02 to X
        cpy #$01                  ;if player moving to the right,
        bpl ExIPM                 ;branch to invert bit and leave
    - Block: @12336
      Lines: 1
        lda #$01                  ;otherwise load A with value to be used here

Generated Kotlin:
// Decompiled from ImpedePlayerMove
fun impedePlayerMove() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> ImpedePlayerMove:
    //> lda #$00                  ;initialize value here
    //> ldy Player_X_Speed        ;get player's horizontal speed
    temp0 = playerXSpeed
    //> ldx $00                   ;check value set earlier for
    temp1 = memory[0x0].toInt()
    //> dex                       ;left side collision
    temp1 = (temp1 - 1) and 0xFF
    //> bne RImpd                 ;if right side collision, skip this part
    temp2 = 0x00
    if (temp1 == 0) {
        //> inx                       ;return value to X
        temp1 = (temp1 + 1) and 0xFF
        //> cpy #$00                  ;if player moving to the left,
        //> bmi ExIPM                 ;branch to invert bit and leave
        if ((temp1 and 0x80) != 0) {
            //  goto ExIPM
            return
        }
        //> lda #$ff                  ;otherwise load A with value to be used later
        temp2 = 0xFF
        //> jmp NXSpd                 ;and jump to affect movement
    }
    //> RImpd: ldx #$02                  ;return $02 to X
    temp1 = 0x02
    //> cpy #$01                  ;if player moving to the right,
    //> bpl ExIPM                 ;branch to invert bit and leave
    if (!((temp1 and 0x80) != 0)) {
        //  goto ExIPM
        return
    } else {
        //> lda #$01                  ;otherwise load A with value to be used here
        temp2 = 0x01
    }
    // Fall-through tail call to nXSpd
    nXSpd(temp2, temp1)
}

@file:OptIn(ExperimentalUnsignedTypes::class)

package com.ivieleague.decompiler6502tokotlin.smb

import com.ivieleague.decompiler6502tokotlin.hand.*

// Decompiled Super Mario Bros. NES ROM
// Generated from smbdism.asm

// Decompiled from @0
fun func_0() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var operMode by MemoryByte(OperMode)
    var ppuCtrlReg1 by MemoryByte(PPU_CTRL_REG1)
    var ppuCtrlReg2 by MemoryByte(PPU_CTRL_REG2)
    var pseudoRandomBitReg by MemoryByte(PseudoRandomBitReg)
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    var warmBootValidation by MemoryByte(WarmBootValidation)
    val ppuStatus by MemoryByteIndexed(PPU_STATUS)
    val sndDeltaReg by MemoryByteIndexed(SND_DELTA_REG)
    val topScoreDisplay by MemoryByteIndexed(TopScoreDisplay)
    //> ;SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
    //> ;by doppelganger (doppelheathen@gmail.com)
    //> ;This file is provided for your own use as-is.  It will require the character rom data
    //> ;and an iNES file header to get it to work.
    //> ;There are so many people I have to thank for this, that taking all the credit for
    //> ;myself would be an unforgivable act of arrogance. Without their help this would
    //> ;probably not be possible.  So I thank all the peeps in the nesdev scene whose insight into
    //> ;the 6502 and the NES helped me learn how it works (you guys know who you are, there's no
    //> ;way I could have done this without your help), as well as the authors of x816 and SMB
    //> ;Utility, and the reverse-engineers who did the original Super Mario Bros. Hacking Project,
    //> ;which I compared notes with but did not copy from.  Last but certainly not least, I thank
    //> ;Nintendo for creating this game and the NES, without which this disassembly would
    //> ;only be theory.
    //> ;Assembles with x816.
    //> ;-------------------------------------------------------------------------------------
    //> ;DEFINES
    //> ;NES specific hardware defines
    //> PPU_CTRL_REG1         = $2000
    //> PPU_CTRL_REG2         = $2001
    //> PPU_STATUS            = $2002
    //> PPU_SPR_ADDR          = $2003
    //> PPU_SPR_DATA          = $2004
    //> PPU_SCROLL_REG        = $2005
    //> PPU_ADDRESS           = $2006
    //> PPU_DATA              = $2007
    //> SND_REGISTER          = $4000
    //> SND_SQUARE1_REG       = $4000
    //> SND_SQUARE2_REG       = $4004
    //> SND_TRIANGLE_REG      = $4008
    //> SND_NOISE_REG         = $400c
    //> SND_DELTA_REG         = $4010
    //> SND_MASTERCTRL_REG    = $4015
    //> SPR_DMA               = $4014
    //> JOYPAD_PORT           = $4016
    //> JOYPAD_PORT1          = $4016
    //> JOYPAD_PORT2          = $4017
    //> ; GAME SPECIFIC DEFINES
    //> ObjectOffset          = $08
    //> FrameCounter          = $09
    //> SavedJoypadBits       = $06fc
    //> SavedJoypad1Bits      = $06fc
    //> SavedJoypad2Bits      = $06fd
    //> JoypadBitMask         = $074a
    //> JoypadOverride        = $0758
    //> A_B_Buttons           = $0a
    //> PreviousA_B_Buttons   = $0d
    //> Up_Down_Buttons       = $0b
    //> Left_Right_Buttons    = $0c
    //> GameEngineSubroutine  = $0e
    //> Mirror_PPU_CTRL_REG1  = $0778
    //> Mirror_PPU_CTRL_REG2  = $0779
    //> OperMode              = $0770
    //> OperMode_Task         = $0772
    //> ScreenRoutineTask     = $073c
    //> GamePauseStatus       = $0776
    //> GamePauseTimer        = $0777
    //> DemoAction            = $0717
    //> DemoActionTimer       = $0718
    //> TimerControl          = $0747
    //> IntervalTimerControl  = $077f
    //> Timers                = $0780
    //> SelectTimer           = $0780
    //> PlayerAnimTimer       = $0781
    //> JumpSwimTimer         = $0782
    //> RunningTimer          = $0783
    //> BlockBounceTimer      = $0784
    //> SideCollisionTimer    = $0785
    //> JumpspringTimer       = $0786
    //> GameTimerCtrlTimer    = $0787
    //> ClimbSideTimer        = $0789
    //> EnemyFrameTimer       = $078a
    //> FrenzyEnemyTimer      = $078f
    //> BowserFireBreathTimer = $0790
    //> StompTimer            = $0791
    //> AirBubbleTimer        = $0792
    //> ScrollIntervalTimer   = $0795
    //> EnemyIntervalTimer    = $0796
    //> BrickCoinTimer        = $079d
    //> InjuryTimer           = $079e
    //> StarInvincibleTimer   = $079f
    //> ScreenTimer           = $07a0
    //> WorldEndTimer         = $07a1
    //> DemoTimer             = $07a2
    //> Sprite_Data           = $0200
    //> Sprite_Y_Position     = $0200
    //> Sprite_Tilenumber     = $0201
    //> Sprite_Attributes     = $0202
    //> Sprite_X_Position     = $0203
    //> ScreenEdge_PageLoc    = $071a
    //> ScreenEdge_X_Pos      = $071c
    //> ScreenLeft_PageLoc    = $071a
    //> ScreenRight_PageLoc   = $071b
    //> ScreenLeft_X_Pos      = $071c
    //> ScreenRight_X_Pos     = $071d
    //> PlayerFacingDir       = $33
    //> DestinationPageLoc    = $34
    //> VictoryWalkControl    = $35
    //> ScrollFractional      = $0768
    //> PrimaryMsgCounter     = $0719
    //> SecondaryMsgCounter   = $0749
    //> HorizontalScroll      = $073f
    //> VerticalScroll        = $0740
    //> ScrollLock            = $0723
    //> ScrollThirtyTwo       = $073d
    //> Player_X_Scroll       = $06ff
    //> Player_Pos_ForScroll  = $0755
    //> ScrollAmount          = $0775
    //> AreaData              = $e7
    //> AreaDataLow           = $e7
    //> AreaDataHigh          = $e8
    //> EnemyData             = $e9
    //> EnemyDataLow          = $e9
    //> EnemyDataHigh         = $ea
    //> AreaParserTaskNum     = $071f
    //> ColumnSets            = $071e
    //> CurrentPageLoc        = $0725
    //> CurrentColumnPos      = $0726
    //> BackloadingFlag       = $0728
    //> BehindAreaParserFlag  = $0729
    //> AreaObjectPageLoc     = $072a
    //> AreaObjectPageSel     = $072b
    //> AreaDataOffset        = $072c
    //> AreaObjOffsetBuffer   = $072d
    //> AreaObjectLength      = $0730
    //> StaircaseControl      = $0734
    //> AreaObjectHeight      = $0735
    //> MushroomLedgeHalfLen  = $0736
    //> EnemyDataOffset       = $0739
    //> EnemyObjectPageLoc    = $073a
    //> EnemyObjectPageSel    = $073b
    //> MetatileBuffer        = $06a1
    //> BlockBufferColumnPos  = $06a0
    //> CurrentNTAddr_Low     = $0721
    //> CurrentNTAddr_High    = $0720
    //> AttributeBuffer       = $03f9
    //> LoopCommand           = $0745
    //> DisplayDigits         = $07d7
    //> TopScoreDisplay       = $07d7
    //> ScoreAndCoinDisplay   = $07dd
    //> PlayerScoreDisplay    = $07dd
    //> GameTimerDisplay      = $07f8
    //> DigitModifier         = $0134
    //> VerticalFlipFlag      = $0109
    //> FloateyNum_Control    = $0110
    //> ShellChainCounter     = $0125
    //> FloateyNum_Timer      = $012c
    //> FloateyNum_X_Pos      = $0117
    //> FloateyNum_Y_Pos      = $011e
    //> FlagpoleFNum_Y_Pos    = $010d
    //> FlagpoleFNum_YMFDummy = $010e
    //> FlagpoleScore         = $010f
    //> FlagpoleCollisionYPos = $070f
    //> StompChainCounter     = $0484
    //> VRAM_Buffer1_Offset   = $0300
    //> VRAM_Buffer1          = $0301
    //> VRAM_Buffer2_Offset   = $0340
    //> VRAM_Buffer2          = $0341
    //> VRAM_Buffer_AddrCtrl  = $0773
    //> Sprite0HitDetectFlag  = $0722
    //> DisableScreenFlag     = $0774
    //> DisableIntermediate   = $0769
    //> ColorRotateOffset     = $06d4
    //> TerrainControl        = $0727
    //> AreaStyle             = $0733
    //> ForegroundScenery     = $0741
    //> BackgroundScenery     = $0742
    //> CloudTypeOverride     = $0743
    //> BackgroundColorCtrl   = $0744
    //> AreaType              = $074e
    //> AreaAddrsLOffset      = $074f
    //> AreaPointer           = $0750
    //> PlayerEntranceCtrl    = $0710
    //> GameTimerSetting      = $0715
    //> AltEntranceControl    = $0752
    //> EntrancePage          = $0751
    //> NumberOfPlayers       = $077a
    //> WarpZoneControl       = $06d6
    //> ChangeAreaTimer       = $06de
    //> MultiLoopCorrectCntr  = $06d9
    //> MultiLoopPassCntr     = $06da
    //> FetchNewGameTimerFlag = $0757
    //> GameTimerExpiredFlag  = $0759
    //> PrimaryHardMode       = $076a
    //> SecondaryHardMode     = $06cc
    //> WorldSelectNumber     = $076b
    //> WorldSelectEnableFlag = $07fc
    //> ContinueWorld         = $07fd
    //> CurrentPlayer         = $0753
    //> PlayerSize            = $0754
    //> PlayerStatus          = $0756
    //> OnscreenPlayerInfo    = $075a
    //> NumberofLives         = $075a ;used by current player
    //> HalfwayPage           = $075b
    //> LevelNumber           = $075c ;the actual dash number
    //> Hidden1UpFlag         = $075d
    //> CoinTally             = $075e
    //> WorldNumber           = $075f
    //> AreaNumber            = $0760 ;internal number used to find areas
    //> CoinTallyFor1Ups      = $0748
    //> OffscreenPlayerInfo   = $0761
    //> OffScr_NumberofLives  = $0761 ;used by offscreen player
    //> OffScr_HalfwayPage    = $0762
    //> OffScr_LevelNumber    = $0763
    //> OffScr_Hidden1UpFlag  = $0764
    //> OffScr_CoinTally      = $0765
    //> OffScr_WorldNumber    = $0766
    //> OffScr_AreaNumber     = $0767
    //> BalPlatformAlignment  = $03a0
    //> Platform_X_Scroll     = $03a1
    //> PlatformCollisionFlag = $03a2
    //> YPlatformTopYPos      = $0401
    //> YPlatformCenterYPos   = $58
    //> BrickCoinTimerFlag    = $06bc
    //> StarFlagTaskControl   = $0746
    //> PseudoRandomBitReg    = $07a7
    //> WarmBootValidation    = $07ff
    //> SprShuffleAmtOffset   = $06e0
    //> SprShuffleAmt         = $06e1
    //> SprDataOffset         = $06e4
    //> Player_SprDataOffset  = $06e4
    //> Enemy_SprDataOffset   = $06e5
    //> Block_SprDataOffset   = $06ec
    //> Alt_SprDataOffset     = $06ec
    //> Bubble_SprDataOffset  = $06ee
    //> FBall_SprDataOffset   = $06f1
    //> Misc_SprDataOffset    = $06f3
    //> SprDataOffset_Ctrl    = $03ee
    //> Player_State          = $1d
    //> Enemy_State           = $1e
    //> Fireball_State        = $24
    //> Block_State           = $26
    //> Misc_State            = $2a
    //> Player_MovingDir      = $45
    //> Enemy_MovingDir       = $46
    //> SprObject_X_Speed     = $57
    //> Player_X_Speed        = $57
    //> Enemy_X_Speed         = $58
    //> Fireball_X_Speed      = $5e
    //> Block_X_Speed         = $60
    //> Misc_X_Speed          = $64
    //> Jumpspring_FixedYPos  = $58
    //> JumpspringAnimCtrl    = $070e
    //> JumpspringForce       = $06db
    //> SprObject_PageLoc     = $6d
    //> Player_PageLoc        = $6d
    //> Enemy_PageLoc         = $6e
    //> Fireball_PageLoc      = $74
    //> Block_PageLoc         = $76
    //> Misc_PageLoc          = $7a
    //> Bubble_PageLoc        = $83
    //> SprObject_X_Position  = $86
    //> Player_X_Position     = $86
    //> Enemy_X_Position      = $87
    //> Fireball_X_Position   = $8d
    //> Block_X_Position      = $8f
    //> Misc_X_Position       = $93
    //> Bubble_X_Position     = $9c
    //> SprObject_Y_Speed     = $9f
    //> Player_Y_Speed        = $9f
    //> Enemy_Y_Speed         = $a0
    //> Fireball_Y_Speed      = $a6
    //> Block_Y_Speed         = $a8
    //> Misc_Y_Speed          = $ac
    //> SprObject_Y_HighPos   = $b5
    //> Player_Y_HighPos      = $b5
    //> Enemy_Y_HighPos       = $b6
    //> Fireball_Y_HighPos    = $bc
    //> Block_Y_HighPos       = $be
    //> Misc_Y_HighPos        = $c2
    //> Bubble_Y_HighPos      = $cb
    //> SprObject_Y_Position  = $ce
    //> Player_Y_Position     = $ce
    //> Enemy_Y_Position      = $cf
    //> Fireball_Y_Position   = $d5
    //> Block_Y_Position      = $d7
    //> Misc_Y_Position       = $db
    //> Bubble_Y_Position     = $e4
    //> SprObject_Rel_XPos    = $03ad
    //> Player_Rel_XPos       = $03ad
    //> Enemy_Rel_XPos        = $03ae
    //> Fireball_Rel_XPos     = $03af
    //> Bubble_Rel_XPos       = $03b0
    //> Block_Rel_XPos        = $03b1
    //> Misc_Rel_XPos         = $03b3
    //> SprObject_Rel_YPos    = $03b8
    //> Player_Rel_YPos       = $03b8
    //> Enemy_Rel_YPos        = $03b9
    //> Fireball_Rel_YPos     = $03ba
    //> Bubble_Rel_YPos       = $03bb
    //> Block_Rel_YPos        = $03bc
    //> Misc_Rel_YPos         = $03be
    //> SprObject_SprAttrib   = $03c4
    //> Player_SprAttrib      = $03c4
    //> Enemy_SprAttrib       = $03c5
    //> SprObject_X_MoveForce = $0400
    //> Enemy_X_MoveForce     = $0401
    //> SprObject_YMF_Dummy   = $0416
    //> Player_YMF_Dummy      = $0416
    //> Enemy_YMF_Dummy       = $0417
    //> Bubble_YMF_Dummy      = $042c
    //> SprObject_Y_MoveForce = $0433
    //> Player_Y_MoveForce    = $0433
    //> Enemy_Y_MoveForce     = $0434
    //> Block_Y_MoveForce     = $043c
    //> DisableCollisionDet   = $0716
    //> Player_CollisionBits  = $0490
    //> Enemy_CollisionBits   = $0491
    //> SprObj_BoundBoxCtrl   = $0499
    //> Player_BoundBoxCtrl   = $0499
    //> Enemy_BoundBoxCtrl    = $049a
    //> Fireball_BoundBoxCtrl = $04a0
    //> Misc_BoundBoxCtrl     = $04a2
    //> EnemyFrenzyBuffer     = $06cb
    //> EnemyFrenzyQueue      = $06cd
    //> Enemy_Flag            = $0f
    //> Enemy_ID              = $16
    //> PlayerGfxOffset       = $06d5
    //> Player_XSpeedAbsolute = $0700
    //> FrictionAdderHigh     = $0701
    //> FrictionAdderLow      = $0702
    //> RunningSpeed          = $0703
    //> SwimmingFlag          = $0704
    //> Player_X_MoveForce    = $0705
    //> DiffToHaltJump        = $0706
    //> JumpOrigin_Y_HighPos  = $0707
    //> JumpOrigin_Y_Position = $0708
    //> VerticalForce         = $0709
    //> VerticalForceDown     = $070a
    //> PlayerChangeSizeFlag  = $070b
    //> PlayerAnimTimerSet    = $070c
    //> PlayerAnimCtrl        = $070d
    //> DeathMusicLoaded      = $0712
    //> FlagpoleSoundQueue    = $0713
    //> CrouchingFlag         = $0714
    //> MaximumLeftSpeed      = $0450
    //> MaximumRightSpeed     = $0456
    //> SprObject_OffscrBits  = $03d0
    //> Player_OffscreenBits  = $03d0
    //> Enemy_OffscreenBits   = $03d1
    //> FBall_OffscreenBits   = $03d2
    //> Bubble_OffscreenBits  = $03d3
    //> Block_OffscreenBits   = $03d4
    //> Misc_OffscreenBits    = $03d6
    //> EnemyOffscrBitsMasked = $03d8
    //> Cannon_Offset         = $046a
    //> Cannon_PageLoc        = $046b
    //> Cannon_X_Position     = $0471
    //> Cannon_Y_Position     = $0477
    //> Cannon_Timer          = $047d
    //> Whirlpool_Offset      = $046a
    //> Whirlpool_PageLoc     = $046b
    //> Whirlpool_LeftExtent  = $0471
    //> Whirlpool_Length      = $0477
    //> Whirlpool_Flag        = $047d
    //> VineFlagOffset        = $0398
    //> VineHeight            = $0399
    //> VineObjOffset         = $039a
    //> VineStart_Y_Position  = $039d
    //> Block_Orig_YPos       = $03e4
    //> Block_BBuf_Low        = $03e6
    //> Block_Metatile        = $03e8
    //> Block_PageLoc2        = $03ea
    //> Block_RepFlag         = $03ec
    //> Block_ResidualCounter = $03f0
    //> Block_Orig_XPos       = $03f1
    //> BoundingBox_UL_XPos   = $04ac
    //> BoundingBox_UL_YPos   = $04ad
    //> BoundingBox_DR_XPos   = $04ae
    //> BoundingBox_DR_YPos   = $04af
    //> BoundingBox_UL_Corner = $04ac
    //> BoundingBox_LR_Corner = $04ae
    //> EnemyBoundingBoxCoord = $04b0
    //> PowerUpType           = $39
    //> FireballBouncingFlag  = $3a
    //> FireballCounter       = $06ce
    //> FireballThrowingTimer = $0711
    //> HammerEnemyOffset     = $06ae
    //> JumpCoinMiscOffset    = $06b7
    //> Block_Buffer_1        = $0500
    //> Block_Buffer_2        = $05d0
    //> HammerThrowingTimer   = $03a2
    //> HammerBroJumpTimer    = $3c
    //> Misc_Collision_Flag   = $06be
    //> RedPTroopaOrigXPos    = $0401
    //> RedPTroopaCenterYPos  = $58
    //> XMovePrimaryCounter   = $a0
    //> XMoveSecondaryCounter = $58
    //> CheepCheepMoveMFlag   = $58
    //> CheepCheepOrigYPos    = $0434
    //> BitMFilter            = $06dd
    //> LakituReappearTimer   = $06d1
    //> LakituMoveSpeed       = $58
    //> LakituMoveDirection   = $a0
    //> FirebarSpinState_Low  = $58
    //> FirebarSpinState_High = $a0
    //> FirebarSpinSpeed      = $0388
    //> FirebarSpinDirection  = $34
    //> DuplicateObj_Offset   = $06cf
    //> NumberofGroupEnemies  = $06d3
    //> BlooperMoveCounter    = $a0
    //> BlooperMoveSpeed      = $58
    //> BowserBodyControls    = $0363
    //> BowserFeetCounter     = $0364
    //> BowserMovementSpeed   = $0365
    //> BowserOrigXPos        = $0366
    //> BowserFlameTimerCtrl  = $0367
    //> BowserFront_Offset    = $0368
    //> BridgeCollapseOffset  = $0369
    //> BowserGfxFlag         = $036a
    //> BowserHitPoints       = $0483
    //> MaxRangeFromOrigin    = $06dc
    //> BowserFlamePRandomOfs = $0417
    //> PiranhaPlantUpYPos    = $0417
    //> PiranhaPlantDownYPos  = $0434
    //> PiranhaPlant_Y_Speed  = $58
    //> PiranhaPlant_MoveFlag = $a0
    //> FireworksCounter      = $06d7
    //> ExplosionGfxCounter   = $58
    //> ExplosionTimerCounter = $a0
    //> ;sound related defines
    //> Squ2_NoteLenBuffer    = $07b3
    //> Squ2_NoteLenCounter   = $07b4
    //> Squ2_EnvelopeDataCtrl = $07b5
    //> Squ1_NoteLenCounter   = $07b6
    //> Squ1_EnvelopeDataCtrl = $07b7
    //> Tri_NoteLenBuffer     = $07b8
    //> Tri_NoteLenCounter    = $07b9
    //> Noise_BeatLenCounter  = $07ba
    //> Squ1_SfxLenCounter    = $07bb
    //> Squ2_SfxLenCounter    = $07bd
    //> Sfx_SecondaryCounter  = $07be
    //> Noise_SfxLenCounter   = $07bf
    //> PauseSoundQueue       = $fa
    //> Square1SoundQueue     = $ff
    //> Square2SoundQueue     = $fe
    //> NoiseSoundQueue       = $fd
    //> AreaMusicQueue        = $fb
    //> EventMusicQueue       = $fc
    //> Square1SoundBuffer    = $f1
    //> Square2SoundBuffer    = $f2
    //> NoiseSoundBuffer      = $f3
    //> AreaMusicBuffer       = $f4
    //> EventMusicBuffer      = $07b1
    //> PauseSoundBuffer      = $07b2
    //> MusicData             = $f5
    //> MusicDataLow          = $f5
    //> MusicDataHigh         = $f6
    //> MusicOffset_Square2   = $f7
    //> MusicOffset_Square1   = $f8
    //> MusicOffset_Triangle  = $f9
    //> MusicOffset_Noise     = $07b0
    //> NoteLenLookupTblOfs   = $f0
    //> DAC_Counter           = $07c0
    //> NoiseDataLoopbackOfs  = $07c1
    //> NoteLengthTblAdder    = $07c4
    //> AreaMusicBuffer_Alt   = $07c5
    //> PauseModeFlag         = $07c6
    //> GroundMusicHeaderOfs  = $07c7
    //> AltRegContentFlag     = $07ca
    //> ;-------------------------------------------------------------------------------------
    //> ;CONSTANTS
    //> ;sound effects constants
    //> Sfx_SmallJump         = %10000000
    //> Sfx_Flagpole          = %01000000
    //> Sfx_Fireball          = %00100000
    //> Sfx_PipeDown_Injury   = %00010000
    //> Sfx_EnemySmack        = %00001000
    //> Sfx_EnemyStomp        = %00000100
    //> Sfx_Bump              = %00000010
    //> Sfx_BigJump           = %00000001
    //> Sfx_BowserFall        = %10000000
    //> Sfx_ExtraLife         = %01000000
    //> Sfx_PowerUpGrab       = %00100000
    //> Sfx_TimerTick         = %00010000
    //> Sfx_Blast             = %00001000
    //> Sfx_GrowVine          = %00000100
    //> Sfx_GrowPowerUp       = %00000010
    //> Sfx_CoinGrab          = %00000001
    //> Sfx_BowserFlame       = %00000010
    //> Sfx_BrickShatter      = %00000001
    //> ;music constants
    //> Silence               = %10000000
    //> StarPowerMusic        = %01000000
    //> PipeIntroMusic        = %00100000
    //> CloudMusic            = %00010000
    //> CastleMusic           = %00001000
    //> UndergroundMusic      = %00000100
    //> WaterMusic            = %00000010
    //> GroundMusic           = %00000001
    //> TimeRunningOutMusic   = %01000000
    //> EndOfLevelMusic       = %00100000
    //> AltGameOverMusic      = %00010000
    //> EndOfCastleMusic      = %00001000
    //> VictoryMusic          = %00000100
    //> GameOverMusic         = %00000010
    //> DeathMusic            = %00000001
    //> ;enemy object constants
    //> GreenKoopa            = $00
    //> BuzzyBeetle           = $02
    //> RedKoopa              = $03
    //> HammerBro             = $05
    //> Goomba                = $06
    //> Bloober               = $07
    //> BulletBill_FrenzyVar  = $08
    //> GreyCheepCheep        = $0a
    //> RedCheepCheep         = $0b
    //> Podoboo               = $0c
    //> PiranhaPlant          = $0d
    //> GreenParatroopaJump   = $0e
    //> RedParatroopa         = $0f
    //> GreenParatroopaFly    = $10
    //> Lakitu                = $11
    //> Spiny                 = $12
    //> FlyCheepCheepFrenzy   = $14
    //> FlyingCheepCheep      = $14
    //> BowserFlame           = $15
    //> Fireworks             = $16
    //> BBill_CCheep_Frenzy   = $17
    //> Stop_Frenzy           = $18
    //> Bowser                = $2d
    //> PowerUpObject         = $2e
    //> VineObject            = $2f
    //> FlagpoleFlagObject    = $30
    //> StarFlagObject        = $31
    //> JumpspringObject      = $32
    //> BulletBill_CannonVar  = $33
    //> RetainerObject        = $35
    //> TallEnemy             = $09
    //> ;other constants
    //> World1 = 0
    //> World2 = 1
    //> World3 = 2
    //> World4 = 3
    //> World5 = 4
    //> World6 = 5
    //> World7 = 6
    //> World8 = 7
    //> Level1 = 0
    //> Level2 = 1
    //> Level3 = 2
    //> Level4 = 3
    //> WarmBootOffset        = <$07d6
    //> ColdBootOffset        = <$07fe
    //> TitleScreenDataOffset = $1ec0
    //> SoundMemory           = $07b0
    //> SwimTileRepOffset     = PlayerGraphicsTable + $9e
    //> MusicHeaderOffsetData = MusicHeaderData - 1
    //> MHD                   = MusicHeaderData
    //> A_Button              = %10000000
    //> B_Button              = %01000000
    //> Select_Button         = %00100000
    //> Start_Button          = %00010000
    //> Up_Dir                = %00001000
    //> Down_Dir              = %00000100
    //> Left_Dir              = %00000010
    //> Right_Dir             = %00000001
    //> TitleScreenModeValue  = 0
    //> GameModeValue         = 1
    //> VictoryModeValue      = 2
    //> GameOverModeValue     = 3
    //> ;-------------------------------------------------------------------------------------
    //> ;DIRECTIVES
    //> .index 8
    //> .mem 8
    //> .org $8000
    //> ;-------------------------------------------------------------------------------------
    //> Start:
    //> sei                          ;pretty standard 6502 type init here
    //> cld
    //> lda #%00010000               ;init PPU control register 1
    A = 0x10
    //> sta PPU_CTRL_REG1
    ppuCtrlReg1 = A
    //> ldx #$ff                     ;reset stack pointer
    X = 0xFF
    //> txs
    loop0@ do {
        //> VBlank1:     lda PPU_STATUS               ;wait two frames
        A = ppuStatus[0]
        //> bpl VBlank1
        if (!((A and 0x80) != 0)) {
            //  continue loop (branch back to VBlank1)
            continue@loop0
        }
    } while ((A and 0x80) == 0)
    loop1@ do {
        //> VBlank2:     lda PPU_STATUS
        A = ppuStatus[0]
        //> bpl VBlank2
        if (!((A and 0x80) != 0)) {
            //  continue loop (branch back to VBlank2)
            continue@loop1
        }
    } while ((A and 0x80) == 0)
    //> ldy #ColdBootOffset          ;load default cold boot pointer
    Y = ColdBootOffset
    //> ldx #$05                     ;this is where we check for a warm boot
    X = 0x05
    loop2@ while (!(A >= 0x0A)) {
        //> dex
        X = (X - 1) and 0xFF
        //> bpl WBootCheck
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to WBootCheck)
            continue@loop2
        }
    }
    //> lda WarmBootValidation       ;second checkpoint, check to see if
    A = warmBootValidation
    //> cmp #$a5                     ;another location has a specific value
    //> bne ColdBoot
    if (A == 0xA5) {
        //> ldy #WarmBootOffset          ;if passed both, load warm boot pointer
        Y = WarmBootOffset
    }
    //> ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
    temp0 = initializeMemory(Y)
    //> sta SND_DELTA_REG+1          ;reset delta counter load register
    sndDeltaReg[1] = temp0
    //> sta OperMode                 ;reset primary mode of operation
    operMode = temp0
    //> lda #$a5                     ;set warm boot flag
    A = 0xA5
    //> sta WarmBootValidation
    warmBootValidation = A
    //> sta PseudoRandomBitReg       ;set seed for pseudorandom register
    pseudoRandomBitReg = A
    //> lda #%00001111
    A = 0x0F
    //> sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
    sndMasterctrlReg = A
    //> lda #%00000110
    A = 0x06
    //> sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
    ppuCtrlReg2 = A
    //> jsr MoveAllSpritesOffscreen
    moveAllSpritesOffscreen()
    //> jsr InitializeNameTables     ;initialize both name tables
    initializeNameTables()
    //> inc DisableScreenFlag        ;set flag to disable screen output
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> lda Mirror_PPU_CTRL_REG1
    A = mirrorPpuCtrlReg1
    //> ora #%10000000               ;enable NMIs
    A = A or 0x80
    //> jsr WritePPUReg1
    writePPUReg1(A)
    //  Fall-through tail call to endlessLoop
    endlessLoop()
    return
}

// Decompiled from EndlessLoop
fun endlessLoop() {
    loop0@ while (true) {
        //> EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
    }
}

// Decompiled from PauseRoutine
fun pauseRoutine() {
    var A: Int = 0
    var Y: Int = 0
    var gamePauseStatus by MemoryByte(GamePauseStatus)
    var gamePauseTimer by MemoryByte(GamePauseTimer)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var pauseSoundQueue by MemoryByte(PauseSoundQueue)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    //> PauseRoutine:
    //> lda OperMode           ;are we in victory mode?
    A = operMode
    //> cmp #VictoryModeValue  ;if so, go ahead
    //> beq ChkPauseTimer
    if (A != VictoryModeValue) {
        //> cmp #GameModeValue     ;are we in game mode?
        //> bne ExitPause          ;if not, leave
        if (A == GameModeValue) {
            //> lda OperMode_Task      ;if we are in game mode, are we running game engine?
            A = opermodeTask
            //> cmp #$03
            //> bne ExitPause          ;if not, leave
            if (!(A == 0x03)) {
                //  goto ExitPause (internal forward branch)
                //> ExitPause:     rts
                return
            }
        }
    }
    //> ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
    A = gamePauseTimer
    //> beq ChkStart
    if (A != 0) {
        //> dec GamePauseTimer     ;if so, decrement and leave
        gamePauseTimer = (gamePauseTimer - 1) and 0xFF
        //> rts
        return
    } else {
        //> ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
        A = savedJoypad1Bits
        //> and #Start_Button      ;on controller 1
        A = A and Start_Button
        //> beq ClrPauseTimer
        if (A != 0) {
            //> lda GamePauseStatus    ;check to see if timer flag is set
            A = gamePauseStatus
            //> and #%10000000         ;and if so, do not reset timer (residual,
            A = A and 0x80
            //> bne ExitPause          ;joypad reading routine makes this unnecessary)
            if (A == 0) {
                //> lda #$2b               ;set pause timer
                A = 0x2B
                //> sta GamePauseTimer
                gamePauseTimer = A
                //> lda GamePauseStatus
                A = gamePauseStatus
                //> tay
                Y = A
                //> iny                    ;set pause sfx queue for next pause mode
                Y = (Y + 1) and 0xFF
                //> sty PauseSoundQueue
                pauseSoundQueue = Y
                //> eor #%00000001         ;invert d0 and set d7
                A = A xor 0x01
                //> ora #%10000000
                A = A or 0x80
                //> bne SetPause           ;unconditional branch
                if (!(A == 0)) {
                    //  goto SetPause (internal forward branch)
                    //> SetPause:      sta GamePauseStatus
                    gamePauseStatus = A
                    return
                }
            }
        }
    }
    //> ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
    A = gamePauseStatus
    //> and #%01111111         ;is not pressed
    A = A and 0x7F
    //> SetPause:      sta GamePauseStatus
    gamePauseStatus = A
    //> ExitPause:     rts
    return
}

// Decompiled from SpriteShuffler
fun spriteShuffler() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var areaType by MemoryByte(AreaType)
    var sprShuffleAmtOffset by MemoryByte(SprShuffleAmtOffset)
    val miscSprdataoffset by MemoryByteIndexed(Misc_SprDataOffset)
    val sprDataOffset by MemoryByteIndexed(SprDataOffset)
    val sprShuffleAmt by MemoryByteIndexed(SprShuffleAmt)
    //> SpriteShuffler:
    //> ldy AreaType                ;load level type, likely residual code
    Y = areaType
    //> lda #$28                    ;load preset value which will put it at
    A = 0x28
    //> sta $00                     ;sprite #10
    memory[0x0] = A.toUByte()
    //> ldx #$0e                    ;start at the end of OAM data offsets
    X = 0x0E
    loop0@ do {
        //> ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
        A = sprDataOffset[X]
        //> cmp $00                     ;the preset value
        //> bcc NextSprOffset           ;if less, skip this part
        if (A >= memory[0x0].toInt()) {
            //> ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
            Y = sprShuffleAmtOffset
            //> clc
            //> adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
            temp0 = A + sprShuffleAmt[Y]
            A = temp0 and 0xFF
            //> bcc StrSprOffset            ;if not exceeded $ff, skip second add
            if (temp0 > 0xFF) {
                //> clc
                //> adc $00                     ;otherwise add preset value $28 to offset
                temp1 = A + memory[0x0].toInt()
                A = temp1 and 0xFF
            }
            //> StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
            sprDataOffset[X] = A
        }
        //> NextSprOffset: dex                         ;move backwards to next one
        X = (X - 1) and 0xFF
        //> bpl ShuffleLoop
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to ShuffleLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> ldx SprShuffleAmtOffset     ;load offset
    X = sprShuffleAmtOffset
    //> inx
    X = (X + 1) and 0xFF
    //> cpx #$03                    ;check if offset + 1 goes to 3
    //> bne SetAmtOffset            ;if offset + 1 not 3, store
    if (X == 0x03) {
        //> ldx #$00                    ;otherwise, init to 0
        X = 0x00
    }
    //> SetAmtOffset:  stx SprShuffleAmtOffset
    sprShuffleAmtOffset = X
    //> ldx #$08                    ;load offsets for values and storage
    X = 0x08
    //> ldy #$02
    Y = 0x02
    loop1@ do {
        //> SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
        A = sprDataOffset[5 + Y]
        //> sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
        miscSprdataoffset[-2 + X] = A
        //> clc                         ;add eight to the second and eight
        //> adc #$08                    ;more to the third one
        temp2 = A + 0x08
        A = temp2 and 0xFF
        //> sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
        miscSprdataoffset[-1 + X] = A
        //> clc                         ;this code loads into the misc sprite offsets
        //> adc #$08
        temp3 = A + 0x08
        A = temp3 and 0xFF
        //> sta Misc_SprDataOffset,x
        miscSprdataoffset[X] = A
        //> dex
        X = (X - 1) and 0xFF
        //> dex
        X = (X - 1) and 0xFF
        //> dex
        X = (X - 1) and 0xFF
        //> dey
        Y = (Y - 1) and 0xFF
        //> bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to SetMiscOffset)
            continue@loop1
        }
    } while ((Y and 0x80) == 0)
    //> rts
    return
}

// Decompiled from OperModeExecutionTree
fun operModeExecutionTree() {
    var A: Int = 0
    var operMode by MemoryByte(OperMode)
    //> OperModeExecutionTree:
    //> lda OperMode     ;this is the heart of the entire program,
    A = operMode
    //> jsr JumpEngine   ;most of what goes on starts here
    when (A) {
        0 -> {
            titleScreenMode()
        }
        1 -> {
            gameMode()
        }
        2 -> {
            victoryMode()
        }
        3 -> {
            gameOverMode()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw TitleScreenMode
    //> .dw GameMode
    //> .dw VictoryMode
    //> .dw GameOverMode
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to moveAllSpritesOffscreen
    moveAllSpritesOffscreen()
    return
}

// Decompiled from MoveAllSpritesOffscreen
fun moveAllSpritesOffscreen() {
    var A: Int = 0
    var Y: Int = 0
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> MoveAllSpritesOffscreen:
    //> ldy #$00                ;this routine moves all sprites off the screen
    Y = 0x00
    //> .db $2c                 ;BIT instruction opcode
    //> MoveSpritesOffscreen:
    //> ldy #$04                ;this routine moves all but sprite 0
    //  (skipped by BIT $2C)
    //> lda #$f8                ;off the screen
    A = 0xF8
    loop0@ do {
        //> SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
        spriteYPosition[Y] = A
        //> iny                     ;which will move it off the screen
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> bne SprInitLoop
        if (!(Y == 0)) {
            //  continue loop (branch back to SprInitLoop)
            continue@loop0
        }
    } while (Y != 0)
    //> rts
    return
}

// Decompiled from MoveSpritesOffscreen
fun moveSpritesOffscreen() {
    // Fall-through tail call to moveAllSpritesOffscreen
    moveAllSpritesOffscreen()
    return
}

// Decompiled from TitleScreenMode
fun titleScreenMode() {
    var A: Int = 0
    var opermodeTask by MemoryByte(OperMode_Task)
    //> TitleScreenMode:
    //> lda OperMode_Task
    A = opermodeTask
    //> jsr JumpEngine
    when (A) {
        0 -> {
            initializeGame(0)
        }
        1 -> {
            screenRoutines()
        }
        2 -> {
            primaryGameSetup()
        }
        3 -> {
            gameMenuRoutine()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw InitializeGame
    //> .dw ScreenRoutines
    //> .dw PrimaryGameSetup
    //> .dw GameMenuRoutine
    //> ;-------------------------------------------------------------------------------------
    //> WSelectBufferTemplate:
    //> .db $04, $20, $73, $01, $00, $00
    //  Fall-through tail call to gameMenuRoutine
    gameMenuRoutine()
    return
}

// Decompiled from GameMenuRoutine
fun gameMenuRoutine() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var demoTimer by MemoryByte(DemoTimer)
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    var savedJoypad2Bits by MemoryByte(SavedJoypad2Bits)
    var selectTimer by MemoryByte(SelectTimer)
    var worldNumber by MemoryByte(WorldNumber)
    var worldSelectEnableFlag by MemoryByte(WorldSelectEnableFlag)
    var worldSelectNumber by MemoryByte(WorldSelectNumber)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    val wSelectBufferTemplate by MemoryByteIndexed(WSelectBufferTemplate)
    //> GameMenuRoutine:
    //> ldy #$00
    Y = 0x00
    //> lda SavedJoypad1Bits        ;check to see if either player pressed
    A = savedJoypad1Bits
    //> ora SavedJoypad2Bits        ;only the start button (either joypad)
    A = A or savedJoypad2Bits
    //> cmp #Start_Button
    //> beq StartGame
    if (A != Start_Button) {
        //> cmp #A_Button+Start_Button  ;check to see if A + start was pressed
        //> bne ChkSelect               ;if not, branch to check select button
        if (!(A == (A_Button+Start_Button))) {
            //  goto ChkSelect (internal forward branch)
            //> ChkSelect:    cmp #Select_Button          ;check to see if the select button was pressed
            //> beq SelectBLogic            ;if so, branch reset demo timer
            if (A == Select_Button) {
                //  goto SelectBLogic (internal forward branch)
                //> SelectBLogic: lda DemoTimer               ;if select or B pressed, check demo timer one last time
                A = demoTimer
                //> beq ResetTitle              ;if demo timer expired, branch to reset title screen mode
                if (A == 0) {
                    //  goto ResetTitle -> resetTitle
                    resetTitle()
                    return
                }
                //> lda #$18                    ;otherwise reset demo timer
                A = 0x18
                //> sta DemoTimer
                demoTimer = A
                //> lda SelectTimer             ;check select/B button timer
                A = selectTimer
                //> bne NullJoypad              ;if not expired, branch
                if (!(A == 0)) {
                    //  goto NullJoypad -> nullJoypad
                    nullJoypad()
                    return
                }
                //> lda #$10                    ;otherwise reset select button timer
                A = 0x10
                //> sta SelectTimer
                selectTimer = A
                //> cpy #$01                    ;was the B button pressed earlier?  if so, branch
                //> beq IncWorldSel             ;note this will not be run if world selection is disabled
                if (Y == 0x01) {
                    //  goto IncWorldSel (internal forward branch)
                    //> IncWorldSel:  ldx WorldSelectNumber       ;increment world select number
                    X = worldSelectNumber
                    //> inx
                    X = (X + 1) and 0xFF
                    //> txa
                    A = X
                    //> and #%00000111              ;mask out higher bits
                    A = A and 0x07
                    //> sta WorldSelectNumber       ;store as current world select number
                    worldSelectNumber = A
                    //> jsr GoContinue
                    temp0 = goContinue(A)
                    X = temp0
                    return
                }
                //> lda NumberOfPlayers         ;if no, must have been the select button, therefore
                A = numberOfPlayers
                //> eor #%00000001              ;change number of players and draw icon accordingly
                A = A xor 0x01
                //> sta NumberOfPlayers
                numberOfPlayers = A
                //> jsr DrawMushroomIcon
                drawMushroomIcon()
                //> jmp NullJoypad
                nullJoypad()
                return
            }
            //> ldx DemoTimer               ;otherwise check demo timer
            X = demoTimer
            //> bne ChkWorldSel             ;if demo timer not expired, branch to check world selection
            if (!(X == 0)) {
                //  goto ChkWorldSel (internal forward branch)
                //> ChkWorldSel:  ldx WorldSelectEnableFlag   ;check to see if world selection has been enabled
                X = worldSelectEnableFlag
                //> beq NullJoypad
                if (X == 0) {
                    //  goto NullJoypad -> nullJoypad
                    nullJoypad()
                    return
                }
                //> cmp #B_Button               ;if so, check to see if the B button was pressed
                //> bne NullJoypad
                if (!(A == B_Button)) {
                    //  goto NullJoypad -> nullJoypad
                    nullJoypad()
                    return
                }
                //> iny                         ;if so, increment Y and execute same code as select
                Y = (Y + 1) and 0xFF
                return
            }
            //> sta SelectTimer             ;set controller bits here if running demo
            selectTimer = A
            //> jsr DemoEngine              ;run through the demo actions
            val flag0: Boolean = demoEngine()
            //> bcs ResetTitle              ;if carry flag set, demo over, thus branch
            if (flag0) {
                //  goto ResetTitle -> resetTitle
                resetTitle()
                return
            }
            //> jmp RunDemo                 ;otherwise, run game engine for demo
            runDemo()
            return
        }
    } else {
        //> StartGame:    jmp ChkContinue             ;if either start or A + start, execute here
        chkContinue(A)
        return
    }
    //> ldx DemoTimer               ;otherwise check demo timer
    X = demoTimer
    //> bne ChkWorldSel             ;if demo timer not expired, branch to check world selection
    if (X == 0) {
        //> sta SelectTimer             ;set controller bits here if running demo
        selectTimer = A
        //> jsr DemoEngine              ;run through the demo actions
        val flag1: Boolean = demoEngine()
        //> bcs ResetTitle              ;if carry flag set, demo over, thus branch
        if (flag1) {
            //  goto ResetTitle -> resetTitle
            resetTitle()
            return
        }
        //> jmp RunDemo                 ;otherwise, run game engine for demo
        runDemo()
        return
    } else {
        //> ChkWorldSel:  ldx WorldSelectEnableFlag   ;check to see if world selection has been enabled
        X = worldSelectEnableFlag
        //> beq NullJoypad
        if (X == 0) {
            //  goto NullJoypad -> nullJoypad
            nullJoypad()
            return
        }
    }
    //> cmp #B_Button               ;if so, check to see if the B button was pressed
    //> bne NullJoypad
    if (!(A == B_Button)) {
        //  goto NullJoypad -> nullJoypad
        nullJoypad()
        return
    } else {
        //> iny                         ;if so, increment Y and execute same code as select
        Y = (Y + 1) and 0xFF
    }
    //> SelectBLogic: lda DemoTimer               ;if select or B pressed, check demo timer one last time
    A = demoTimer
    //> beq ResetTitle              ;if demo timer expired, branch to reset title screen mode
    if (A == 0) {
        //  goto ResetTitle -> resetTitle
        resetTitle()
        return
    } else {
        //> lda #$18                    ;otherwise reset demo timer
        A = 0x18
        //> sta DemoTimer
        demoTimer = A
        //> lda SelectTimer             ;check select/B button timer
        A = selectTimer
        //> bne NullJoypad              ;if not expired, branch
        if (!(A == 0)) {
            //  goto NullJoypad -> nullJoypad
            nullJoypad()
            return
        }
    }
    //> lda #$10                    ;otherwise reset select button timer
    A = 0x10
    //> sta SelectTimer
    selectTimer = A
    //> cpy #$01                    ;was the B button pressed earlier?  if so, branch
    //> beq IncWorldSel             ;note this will not be run if world selection is disabled
    if (Y != 0x01) {
        //> lda NumberOfPlayers         ;if no, must have been the select button, therefore
        A = numberOfPlayers
        //> eor #%00000001              ;change number of players and draw icon accordingly
        A = A xor 0x01
        //> sta NumberOfPlayers
        numberOfPlayers = A
        //> jsr DrawMushroomIcon
        drawMushroomIcon()
        //> jmp NullJoypad
        nullJoypad()
        return
    } else {
        //> IncWorldSel:  ldx WorldSelectNumber       ;increment world select number
        X = worldSelectNumber
        //> inx
        X = (X + 1) and 0xFF
        //> txa
        A = X
        //> and #%00000111              ;mask out higher bits
        A = A and 0x07
        //> sta WorldSelectNumber       ;store as current world select number
        worldSelectNumber = A
        //> jsr GoContinue
        temp1 = goContinue(A)
        X = temp1
    }
    X = temp1
    loop0@ do {
        //> UpdateShroom: lda WSelectBufferTemplate,x ;write template for world select in vram buffer
        A = wSelectBufferTemplate[X]
        //> sta VRAM_Buffer1-1,x        ;do this until all bytes are written
        vramBuffer1[-1 + X] = A
        //> inx
        X = (X + 1) and 0xFF
        //> cpx #$06
        //> bmi UpdateShroom
        if (((X - 0x06) and 0xFF and 0x80) != 0) {
            //  continue loop (branch back to UpdateShroom)
            continue@loop0
        }
    } while (((X - 0x06) and 0xFF and 0x80) != 0)
    //> ldy WorldNumber             ;get world number from variable and increment for
    Y = worldNumber
    //> iny                         ;proper display, and put in blank byte before
    Y = (Y + 1) and 0xFF
    //> sty VRAM_Buffer1+3          ;null terminator
    vramBuffer1[3] = Y
    //  Fall-through tail call to nullJoypad
    nullJoypad()
    return
}

// Decompiled from NullJoypad
fun nullJoypad() {
    var A: Int = 0
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    //> NullJoypad:   lda #$00                    ;clear joypad bits for player 1
    A = 0x00
    //> sta SavedJoypad1Bits
    savedJoypad1Bits = A
    //  Fall-through tail call to runDemo
    runDemo()
    return
}

// Decompiled from RunDemo
fun runDemo() {
    var A: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    //> RunDemo:      jsr GameCoreRoutine         ;run game engine
    gameCoreRoutine()
    //> lda GameEngineSubroutine    ;check to see if we're running lose life routine
    A = gameEngineSubroutine
    //> cmp #$06
    //> bne ExitMenu                ;if not, do not do all the resetting below
    if (!(A == 0x06)) {
        //  goto ExitMenu -> exitMenu
        exitMenu()
        return
    }
    //  Fall-through tail call to resetTitle
    resetTitle()
    return
}

// Decompiled from ResetTitle
fun resetTitle() {
    var A: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    //> ResetTitle:   lda #$00                    ;reset game modes, disable
    A = 0x00
    //> sta OperMode                ;sprite 0 check and disable
    operMode = A
    //> sta OperMode_Task           ;screen output
    opermodeTask = A
    //> sta Sprite0HitDetectFlag
    sprite0HitDetectFlag = A
    //> inc DisableScreenFlag
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> rts
    return
}

// Decompiled from ChkContinue
fun chkContinue(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var continueWorld by MemoryByte(ContinueWorld)
    var demoTimer by MemoryByte(DemoTimer)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    var offscrHidden1upflag by MemoryByte(OffScr_Hidden1UpFlag)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    var worldSelectEnableFlag by MemoryByte(WorldSelectEnableFlag)
    val scoreAndCoinDisplay by MemoryByteIndexed(ScoreAndCoinDisplay)
    //> ChkContinue:  ldy DemoTimer               ;if timer for demo has expired, reset modes
    Y = demoTimer
    //> beq ResetTitle
    A = A
    if (Y == 0) {
        //> ResetTitle:   lda #$00                    ;reset game modes, disable
        A = 0x00
        //> sta OperMode                ;sprite 0 check and disable
        operMode = A
        //> sta OperMode_Task           ;screen output
        opermodeTask = A
        //> sta Sprite0HitDetectFlag
        sprite0HitDetectFlag = A
        //> inc DisableScreenFlag
        disableScreenFlag = (disableScreenFlag + 1) and 0xFF
        //> rts
        return
    } else {
        //> asl                         ;check to see if A button was also pushed
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> bcc StartWorld1             ;if not, don't load continue function's world number
        if ((orig0 and 0x80) != 0) {
            //> lda ContinueWorld           ;load previously saved world number for secret
            A = continueWorld
            //> jsr GoContinue              ;continue function when pressing A + start
            temp0 = goContinue(A)
            X = temp0
        }
    }
    //> StartWorld1:  jsr LoadAreaPointer
    temp1 = loadAreaPointer(A)
    //> inc Hidden1UpFlag           ;set 1-up box flag for both players
    hidden1UpFlag = (hidden1UpFlag + 1) and 0xFF
    //> inc OffScr_Hidden1UpFlag
    offscrHidden1upflag = (offscrHidden1upflag + 1) and 0xFF
    //> inc FetchNewGameTimerFlag   ;set fetch new game timer flag
    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
    //> inc OperMode                ;set next game mode
    operMode = (operMode + 1) and 0xFF
    //> lda WorldSelectEnableFlag   ;if world select flag is on, then primary
    A = worldSelectEnableFlag
    //> sta PrimaryHardMode         ;hard mode must be on as well
    primaryHardMode = A
    //> lda #$00
    A = 0x00
    //> sta OperMode_Task           ;set game mode here, and clear demo timer
    opermodeTask = A
    //> sta DemoTimer
    demoTimer = A
    //> ldx #$17
    X = 0x17
    //> lda #$00
    A = 0x00
    loop0@ do {
        //> InitScores:   sta ScoreAndCoinDisplay,x   ;clear player scores and coin displays
        scoreAndCoinDisplay[X] = A
        //> dex
        X = (X - 1) and 0xFF
        //> bpl InitScores
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to InitScores)
            continue@loop0
        }
        //  Fall-through tail call to exitMenu
        exitMenu()
        return
    } while ((X and 0x80) == 0)
    // Fall-through tail call to exitMenu
    exitMenu()
    return
}

// Decompiled from ExitMenu
fun exitMenu() {
    //> ExitMenu:     rts
    return
}

// Decompiled from GoContinue
fun goContinue(A: Int): Int {
    var X: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var offscrAreanumber by MemoryByte(OffScr_AreaNumber)
    var offscrWorldnumber by MemoryByte(OffScr_WorldNumber)
    var worldNumber by MemoryByte(WorldNumber)
    //> GoContinue:   sta WorldNumber             ;start both players at the first area
    worldNumber = A
    //> sta OffScr_WorldNumber      ;of the previously saved world number
    offscrWorldnumber = A
    //> ldx #$00                    ;note that on power-up using this function
    X = 0x00
    //> stx AreaNumber              ;will make no difference
    areaNumber = X
    //> stx OffScr_AreaNumber
    offscrAreanumber = X
    //> rts
    return X
}

// Decompiled from DrawMushroomIcon
fun drawMushroomIcon() {
    var A: Int = 0
    var Y: Int = 0
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    val mushroomIconData by MemoryByteIndexed(MushroomIconData)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> DrawMushroomIcon:
    //> ldy #$07                ;read eight bytes to be read by transfer routine
    Y = 0x07
    loop0@ do {
        //> IconDataRead: lda MushroomIconData,y  ;note that the default position is set for a
        A = mushroomIconData[Y]
        //> sta VRAM_Buffer1-1,y    ;1-player game
        vramBuffer1[-1 + Y] = A
        //> dey
        Y = (Y - 1) and 0xFF
        //> bpl IconDataRead
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to IconDataRead)
            continue@loop0
        }
    } while ((Y and 0x80) == 0)
    //> lda NumberOfPlayers     ;check number of players
    A = numberOfPlayers
    //> beq ExitIcon            ;if set to 1-player game, we're done
    if (A != 0) {
        //> lda #$24                ;otherwise, load blank tile in 1-player position
        A = 0x24
        //> sta VRAM_Buffer1+3
        vramBuffer1[3] = A
        //> lda #$ce                ;then load shroom icon tile in 2-player position
        A = 0xCE
        //> sta VRAM_Buffer1+5
        vramBuffer1[5] = A
    }
    //> ExitIcon:     rts
    return
}

// Decompiled from DemoEngine
fun demoEngine(): Boolean {
    var A: Int = 0
    var X: Int = 0
    var demoAction by MemoryByte(DemoAction)
    var demoActionTimer by MemoryByte(DemoActionTimer)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    val demoActionData by MemoryByteIndexed(DemoActionData)
    val demoTimingData by MemoryByteIndexed(DemoTimingData)
    //> DemoEngine:
    //> ldx DemoAction         ;load current demo action
    X = demoAction
    //> lda DemoActionTimer    ;load current action timer
    A = demoActionTimer
    //> bne DoAction           ;if timer still counting down, skip
    if (A == 0) {
        //> inx
        X = (X + 1) and 0xFF
        //> inc DemoAction         ;if expired, increment action, X, and
        demoAction = (demoAction + 1) and 0xFF
        //> sec                    ;set carry by default for demo over
        //> lda DemoTimingData-1,x ;get next timer
        A = demoTimingData[-1 + X]
        //> sta DemoActionTimer    ;store as current timer
        demoActionTimer = A
        //> beq DemoOver           ;if timer already at zero, skip
        if (A == 0) {
            //  goto DemoOver (internal forward branch)
            //> DemoOver: rts
            return false
        }
    }
    //> DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
    A = demoActionData[-1 + X]
    //> sta SavedJoypad1Bits
    savedJoypad1Bits = A
    //> dec DemoActionTimer    ;decrement action timer
    demoActionTimer = (demoActionTimer - 1) and 0xFF
    //> clc                    ;clear carry if demo still going
    //> DemoOver: rts
    return false
}

// Decompiled from VictoryMode
fun victoryMode() {
    var A: Int = 0
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var opermodeTask by MemoryByte(OperMode_Task)
    //> VictoryMode:
    //> jsr VictoryModeSubroutines  ;run victory mode subroutines
    victoryModeSubroutines()
    //> lda OperMode_Task           ;get current task of victory mode
    A = opermodeTask
    //> beq AutoPlayer              ;if on bridge collapse, skip enemy processing
    if (A != 0) {
        //> ldx #$00
        X = 0x00
        //> stx ObjectOffset            ;otherwise reset enemy object offset
        objectOffset = X
        //> jsr EnemiesAndLoopsCore     ;and run enemy code
        temp0 = enemiesAndLoopsCore(X)
        X = temp0
    }
    //> AutoPlayer: jsr RelativePlayerPosition  ;get player's relative coordinates
    temp1 = relativePlayerPosition()
    X = temp1
    //> jmp PlayerGfxHandler        ;draw the player, then leave
    playerGfxHandler()
    return
}

// Decompiled from VictoryModeSubroutines
fun victoryModeSubroutines() {
    var A: Int = 0
    var opermodeTask by MemoryByte(OperMode_Task)
    //> VictoryModeSubroutines:
    //> lda OperMode_Task
    A = opermodeTask
    //> jsr JumpEngine
    when (A) {
        0 -> {
            bridgeCollapse()
        }
        1 -> {
            setupVictoryMode()
        }
        2 -> {
            playerVictoryWalk()
        }
        3 -> {
            printVictoryMessages()
        }
        4 -> {
            playerEndWorld()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw BridgeCollapse
    //> .dw SetupVictoryMode
    //> .dw PlayerVictoryWalk
    //> .dw PrintVictoryMessages
    //> .dw PlayerEndWorld
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to setupVictoryMode
    setupVictoryMode()
    return
}

// Decompiled from SetupVictoryMode
fun setupVictoryMode() {
    var A: Int = 0
    var X: Int = 0
    var destinationPageLoc by MemoryByte(DestinationPageLoc)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    //> SetupVictoryMode:
    //> ldx ScreenRight_PageLoc  ;get page location of right side of screen
    X = screenrightPageloc
    //> inx                      ;increment to next page
    X = (X + 1) and 0xFF
    //> stx DestinationPageLoc   ;store here
    destinationPageLoc = X
    //> lda #EndOfCastleMusic
    A = EndOfCastleMusic
    //> sta EventMusicQueue      ;play win castle music
    eventMusicQueue = A
    //> jmp IncModeTask_B        ;jump to set next major task in victory mode
    incmodetaskB()
    return
}

// Decompiled from PlayerVictoryWalk
fun playerVictoryWalk() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var destinationPageLoc by MemoryByte(DestinationPageLoc)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var scrollFractional by MemoryByte(ScrollFractional)
    var victoryWalkControl by MemoryByte(VictoryWalkControl)
    //> PlayerVictoryWalk:
    //> ldy #$00                ;set value here to not walk player by default
    Y = 0x00
    //> sty VictoryWalkControl
    victoryWalkControl = Y
    //> lda Player_PageLoc      ;get player's page location
    A = playerPageloc
    //> cmp DestinationPageLoc  ;compare with destination page location
    //> bne PerformWalk         ;if page locations don't match, branch
    if (A == destinationPageLoc) {
        //> lda Player_X_Position   ;otherwise get player's horizontal position
        A = playerXPosition
        //> cmp #$60                ;compare with preset horizontal position
        //> bcs DontWalk            ;if still on other page, branch ahead
        if (A >= 0x60) {
            //  goto DontWalk (internal forward branch)
            //> DontWalk:    tya                     ;put contents of Y in A and
            A = Y
            //> jsr AutoControlPlayer   ;use A to move player to the right or not
            autoControlPlayer(A)
            //> lda ScreenLeft_PageLoc  ;check page location of left side of screen
            A = screenleftPageloc
            //> cmp DestinationPageLoc  ;against set value here
            //> beq ExitVWalk           ;branch if equal to change modes if necessary
            if (A == destinationPageLoc) {
                //  goto ExitVWalk (internal forward branch)
                //> ExitVWalk:   lda VictoryWalkControl  ;load value set here
                A = victoryWalkControl
                //> beq IncModeTask_A       ;if zero, branch to change modes
                if (A == 0) {
                    //  goto IncModeTask_A -> incmodetaskA
                    incmodetaskA()
                    return
                }
                //> rts                     ;otherwise leave
                return
            }
            //> lda ScrollFractional
            A = scrollFractional
            //> clc                     ;do fixed point math on fractional part of scroll
            //> adc #$80
            temp0 = A + 0x80
            A = temp0 and 0xFF
            //> sta ScrollFractional    ;save fractional movement amount
            scrollFractional = A
            //> lda #$01                ;set 1 pixel per frame
            A = 0x01
            //> adc #$00                ;add carry from previous addition
            temp1 = A + if (temp0 > 0xFF) 1 else 0
            A = temp1 and 0xFF
            //> tay                     ;use as scroll amount
            Y = A
            //> jsr ScrollScreen        ;do sub to scroll the screen
            scrollScreen(Y)
            //> jsr UpdScrollVar        ;do another sub to update screen and scroll variables
            updScrollVar()
            //> inc VictoryWalkControl  ;increment value to stay in this routine
            victoryWalkControl = (victoryWalkControl + 1) and 0xFF
            return
        }
    }
    //> PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
    victoryWalkControl = (victoryWalkControl + 1) and 0xFF
    //> iny                     ;note Y will be used to walk the player
    Y = (Y + 1) and 0xFF
    //> DontWalk:    tya                     ;put contents of Y in A and
    A = Y
    //> jsr AutoControlPlayer   ;use A to move player to the right or not
    autoControlPlayer(A)
    //> lda ScreenLeft_PageLoc  ;check page location of left side of screen
    A = screenleftPageloc
    //> cmp DestinationPageLoc  ;against set value here
    //> beq ExitVWalk           ;branch if equal to change modes if necessary
    if (A != destinationPageLoc) {
        //> lda ScrollFractional
        A = scrollFractional
        //> clc                     ;do fixed point math on fractional part of scroll
        //> adc #$80
        temp2 = A + 0x80
        A = temp2 and 0xFF
        //> sta ScrollFractional    ;save fractional movement amount
        scrollFractional = A
        //> lda #$01                ;set 1 pixel per frame
        A = 0x01
        //> adc #$00                ;add carry from previous addition
        temp3 = A + if (temp2 > 0xFF) 1 else 0
        A = temp3 and 0xFF
        //> tay                     ;use as scroll amount
        Y = A
        //> jsr ScrollScreen        ;do sub to scroll the screen
        scrollScreen(Y)
        //> jsr UpdScrollVar        ;do another sub to update screen and scroll variables
        updScrollVar()
        //> inc VictoryWalkControl  ;increment value to stay in this routine
        victoryWalkControl = (victoryWalkControl + 1) and 0xFF
    }
    //> ExitVWalk:   lda VictoryWalkControl  ;load value set here
    A = victoryWalkControl
    //> beq IncModeTask_A       ;if zero, branch to change modes
    if (A == 0) {
        //  goto IncModeTask_A -> incmodetaskA
        incmodetaskA()
        return
    } else {
        //> rts                     ;otherwise leave
        return
    }
}

// Decompiled from PrintVictoryMessages
fun printVictoryMessages() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var primaryMsgCounter by MemoryByte(PrimaryMsgCounter)
    var secondaryMsgCounter by MemoryByte(SecondaryMsgCounter)
    var worldNumber by MemoryByte(WorldNumber)
    //> PrintVictoryMessages:
    //> lda SecondaryMsgCounter   ;load secondary message counter
    A = secondaryMsgCounter
    //> bne IncMsgCounter         ;if set, branch to increment message counters
    if (!(A == 0)) {
        //  goto IncMsgCounter -> incMsgCounter
        incMsgCounter()
        return
    } else {
        //> lda PrimaryMsgCounter     ;otherwise load primary message counter
        A = primaryMsgCounter
        //> beq ThankPlayer           ;if set to zero, branch to print first message
        if (A == 0) {
            //  goto ThankPlayer -> thankPlayer
            thankPlayer(A)
            return
        }
    }
    //> cmp #$09                  ;if at 9 or above, branch elsewhere (this comparison
    //> bcs IncMsgCounter         ;is residual code, counter never reaches 9)
    if (A >= 0x09) {
        //  goto IncMsgCounter -> incMsgCounter
        incMsgCounter()
        return
    } else {
        //> ldy WorldNumber           ;check world number
        Y = worldNumber
        //> cpy #World8
        //> bne MRetainerMsg          ;if not at world 8, skip to next part
        if (Y == World8) {
            //> cmp #$03                  ;check primary message counter again
            //> bcc IncMsgCounter         ;if not at 3 yet (world 8 only), branch to increment
            if (!(A >= 0x03)) {
                //  goto IncMsgCounter -> incMsgCounter
                incMsgCounter()
                return
            }
            //> sbc #$01                  ;otherwise subtract one
            temp0 = A - 0x01 - if (A >= 0x03) 0 else 1
            A = temp0 and 0xFF
            //> jmp ThankPlayer           ;and skip to next part
            thankPlayer(A)
            return
        }
    }
    //> MRetainerMsg:  cmp #$02                  ;check primary message counter
    //> bcc IncMsgCounter         ;if not at 2 yet (world 1-7 only), branch
    if (!(A >= 0x02)) {
        //  goto IncMsgCounter -> incMsgCounter
        incMsgCounter()
        return
    }
    //  Fall-through tail call to thankPlayer
    thankPlayer(A)
    return
}

// Decompiled from ThankPlayer
fun thankPlayer(A: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    var worldNumber by MemoryByte(WorldNumber)
    //> ThankPlayer:   tay                       ;put primary message counter into Y
    Y = A
    //> bne SecondPartMsg         ;if counter nonzero, skip this part, do not print first message
    A = A
    Y = Y
    if (Y == 0) {
        //> lda CurrentPlayer         ;otherwise get player currently on the screen
        A = currentPlayer
        //> beq EvalForMusic          ;if mario, branch
        if (A != 0) {
            //> iny                       ;otherwise increment Y once for luigi and
            Y = (Y + 1) and 0xFF
            //> bne EvalForMusic          ;do an unconditional branch to the same place
            if (!(Y == 0)) {
                //  goto EvalForMusic (internal forward branch)
                //> EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
                //> bne PrintMsg              ;to print message only (note world 1-7 will only
                if (!(Y == 0x03)) {
                    //  goto PrintMsg (internal forward branch)
                    //> PrintMsg:      tya                       ;put primary message counter in A
                    A = Y
                    //> clc                       ;add $0c or 12 to counter thus giving an appropriate value,
                    //> adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
                    temp0 = A + 0x0C
                    A = temp0 and 0xFF
                    //> sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
                    vramBufferAddrctrl = A
                    //  Fall-through tail call to incMsgCounter
                    incMsgCounter()
                    return
                }
                //> lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
                A = VictoryMusic
                //> sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
                eventMusicQueue = A
                return
            }
        }
    }
    //> SecondPartMsg: iny                       ;increment Y to do world 8's message
    Y = (Y + 1) and 0xFF
    //> lda WorldNumber
    A = worldNumber
    //> cmp #World8               ;check world number
    //> beq EvalForMusic          ;if at world 8, branch to next part
    if (A != World8) {
        //> dey                       ;otherwise decrement Y for world 1-7's message
        Y = (Y - 1) and 0xFF
        //> cpy #$04                  ;if counter at 4 (world 1-7 only)
        //> bcs SetEndTimer           ;branch to set victory end timer
        if (Y >= 0x04) {
            //  goto SetEndTimer -> setEndTimer
            setEndTimer()
            return
        }
        //> cpy #$03                  ;if counter at 3 (world 1-7 only)
        //> bcs IncMsgCounter         ;branch to keep counting
        if (Y >= 0x03) {
            //  goto IncMsgCounter -> incMsgCounter
            incMsgCounter()
            return
        }
    }
    //> EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
    //> bne PrintMsg              ;to print message only (note world 1-7 will only
    if (Y == 0x03) {
        //> lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
        A = VictoryMusic
        //> sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
        eventMusicQueue = A
    }
    //> PrintMsg:      tya                       ;put primary message counter in A
    A = Y
    //> clc                       ;add $0c or 12 to counter thus giving an appropriate value,
    //> adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
    temp1 = A + 0x0C
    A = temp1 and 0xFF
    //> sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
    vramBufferAddrctrl = A
    //  Fall-through tail call to incMsgCounter
    incMsgCounter()
    return
}

// Decompiled from IncMsgCounter
fun incMsgCounter() {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var primaryMsgCounter by MemoryByte(PrimaryMsgCounter)
    var secondaryMsgCounter by MemoryByte(SecondaryMsgCounter)
    //> IncMsgCounter: lda SecondaryMsgCounter
    A = secondaryMsgCounter
    //> clc
    //> adc #$04                      ;add four to secondary message counter
    temp0 = A + 0x04
    A = temp0 and 0xFF
    //> sta SecondaryMsgCounter
    secondaryMsgCounter = A
    //> lda PrimaryMsgCounter
    A = primaryMsgCounter
    //> adc #$00                      ;add carry to primary message counter
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta PrimaryMsgCounter
    primaryMsgCounter = A
    //> cmp #$07                      ;check primary counter one more time
    //  Fall-through tail call to setEndTimer
    setEndTimer()
    return
}

// Decompiled from SetEndTimer
fun setEndTimer() {
    //> SetEndTimer:   bcc ExitMsgs                  ;if not reached value yet, branch to leave
    if (!(flagC)) {
        //  goto ExitMsgs -> exitMsgs
        exitMsgs()
        return
    }
    //  Fall-through tail call to func_1223
    func_1223()
    return
}

// Decompiled from @1223
fun func_1223() {
    var A: Int = 0
    var worldEndTimer by MemoryByte(WorldEndTimer)
    //> lda #$06
    A = 0x06
    //> sta WorldEndTimer             ;otherwise set world end timer
    worldEndTimer = A
    //  Fall-through tail call to incmodetaskA
    incmodetaskA()
    return
}

// Decompiled from IncModeTask_A
fun incmodetaskA() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
    opermodeTask = (opermodeTask + 1) and 0xFF
    //  Fall-through tail call to exitMsgs
    exitMsgs()
    return
}

// Decompiled from ExitMsgs
fun exitMsgs() {
    //> ExitMsgs:      rts                           ;leave
    return
}

// Decompiled from PlayerEndWorld
fun playerEndWorld() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var levelNumber by MemoryByte(LevelNumber)
    var numberofLives by MemoryByte(NumberofLives)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    var savedJoypad2Bits by MemoryByte(SavedJoypad2Bits)
    var worldEndTimer by MemoryByte(WorldEndTimer)
    var worldNumber by MemoryByte(WorldNumber)
    var worldSelectEnableFlag by MemoryByte(WorldSelectEnableFlag)
    //> PlayerEndWorld:
    //> lda WorldEndTimer          ;check to see if world end timer expired
    A = worldEndTimer
    //> bne EndExitOne             ;branch to leave if not
    if (!(A == 0)) {
        //  goto EndExitOne -> endExitOne
        endExitOne()
        return
    } else {
        //> ldy WorldNumber            ;check world number
        Y = worldNumber
        //> cpy #World8                ;if on world 8, player is done with game,
        //> bcs EndChkBButton          ;thus branch to read controller
        if (!(Y >= World8)) {
            //> lda #$00
            A = 0x00
            //> sta AreaNumber             ;otherwise initialize area number used as offset
            areaNumber = A
            //> sta LevelNumber            ;and level number control to start at area 1
            levelNumber = A
            //> sta OperMode_Task          ;initialize secondary mode of operation
            opermodeTask = A
            //> inc WorldNumber            ;increment world number to move onto the next world
            worldNumber = (worldNumber + 1) and 0xFF
            //> jsr LoadAreaPointer        ;get area address offset for the next area
            temp0 = loadAreaPointer(A)
            //> inc FetchNewGameTimerFlag  ;set flag to load game timer from header
            fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
            //> lda #GameModeValue
            A = GameModeValue
            //> sta OperMode               ;set mode of operation to game mode
            operMode = A
            //  Fall-through tail call to endExitOne
            endExitOne()
            return
        }
    }
    //> EndChkBButton: lda SavedJoypad1Bits
    A = savedJoypad1Bits
    //> ora SavedJoypad2Bits       ;check to see if B button was pressed on
    A = A or savedJoypad2Bits
    //> and #B_Button              ;either controller
    A = A and B_Button
    //> beq EndExitTwo             ;branch to leave if not
    if (A != 0) {
        //> lda #$01                   ;otherwise set world selection flag
        A = 0x01
        //> sta WorldSelectEnableFlag
        worldSelectEnableFlag = A
        //> lda #$ff                   ;remove onscreen player's lives
        A = 0xFF
        //> sta NumberofLives
        numberofLives = A
        //> jsr TerminateGame          ;do sub to continue other player or end game
        terminateGame()
    }
    //> EndExitTwo:    rts                        ;leave
    return
}

// Decompiled from EndExitOne
fun endExitOne() {
    //> EndExitOne:    rts                        ;and leave
    return
}

// Decompiled from FloateyNumbersRoutine
fun floateyNumbersRoutine(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var numberofLives by MemoryByte(NumberofLives)
    var objectOffset by MemoryByte(ObjectOffset)
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val altSprdataoffset by MemoryByteIndexed(Alt_SprDataOffset)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val floateyNumTileData by MemoryByteIndexed(FloateyNumTileData)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val floateynumTimer by MemoryByteIndexed(FloateyNum_Timer)
    val floateynumXPos by MemoryByteIndexed(FloateyNum_X_Pos)
    val floateynumYPos by MemoryByteIndexed(FloateyNum_Y_Pos)
    val scoreUpdateData by MemoryByteIndexed(ScoreUpdateData)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    //> FloateyNumbersRoutine:
    //> lda FloateyNum_Control,x     ;load control for floatey number
    A = floateynumControl[X]
    //> beq EndExitOne               ;if zero, branch to leave
    X = X
    if (A == 0) {
        //> EndExitOne:    rts                        ;and leave
        return X
    } else {
        //> cmp #$0b                     ;if less than $0b, branch
        //> bcc ChkNumTimer
        if (A >= 0x0B) {
            //> lda #$0b                     ;otherwise set to $0b, thus keeping
            A = 0x0B
            //> sta FloateyNum_Control,x     ;it in range
            floateynumControl[X] = A
        }
    }
    //> ChkNumTimer:  tay                          ;use as Y
    Y = A
    //> lda FloateyNum_Timer,x       ;check value here
    A = floateynumTimer[X]
    //> bne DecNumTimer              ;if nonzero, branch ahead
    Y = Y
    if (A == 0) {
        //> sta FloateyNum_Control,x     ;initialize floatey number control and leave
        floateynumControl[X] = A
        //> rts
        return X
    } else {
        //> DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
        floateynumTimer[X] = (floateynumTimer[X] - 1) and 0xFF
        //> cmp #$2b                     ;if not reached a certain point, branch
        //> bne ChkTallEnemy
        if (A == 0x2B) {
            //> cpy #$0b                     ;check offset for $0b
            //> bne LoadNumTiles             ;branch ahead if not found
            if (Y == 0x0B) {
                //> inc NumberofLives            ;give player one extra life (1-up)
                numberofLives = (numberofLives + 1) and 0xFF
                //> lda #Sfx_ExtraLife
                A = Sfx_ExtraLife
                //> sta Square2SoundQueue        ;and play the 1-up sound
                square2SoundQueue = A
            }
            //> LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
            A = scoreUpdateData[Y]
            //> lsr                          ;move high nybble to low
            val orig0: Int = A
            A = orig0 shr 1
            //> lsr
            val orig1: Int = A
            A = orig1 shr 1
            //> lsr
            val orig2: Int = A
            A = orig2 shr 1
            //> lsr
            val orig3: Int = A
            A = orig3 shr 1
            //> tax                          ;use as X offset, essentially the digit
            X = A
            //> lda ScoreUpdateData,y        ;load again and this time
            A = scoreUpdateData[Y]
            //> and #%00001111               ;mask out the high nybble
            A = A and 0x0F
            //> sta DigitModifier,x          ;store as amount to add to the digit
            digitModifier[X] = A
            //> jsr AddToScore               ;update the score accordingly
            temp0 = addToScore()
            X = temp0
        }
    }
    //> ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
    Y = enemySprdataoffset[X]
    //> lda Enemy_ID,x               ;get enemy object identifier
    A = enemyId[X]
    //> cmp #Spiny
    //> beq FloateyPart              ;branch if spiny
    if (A != Spiny) {
        //> cmp #PiranhaPlant
        //> beq FloateyPart              ;branch if piranha plant
        if (A != PiranhaPlant) {
            //> cmp #HammerBro
            //> beq GetAltOffset             ;branch elsewhere if hammer bro
            if (A != HammerBro) {
                //> cmp #GreyCheepCheep
                //> beq FloateyPart              ;branch if cheep-cheep of either color
                if (A != GreyCheepCheep) {
                    //> cmp #RedCheepCheep
                    //> beq FloateyPart
                    if (A != RedCheepCheep) {
                        //> cmp #TallEnemy
                        //> bcs GetAltOffset             ;branch elsewhere if enemy object => $09
                        if (!(A >= TallEnemy)) {
                            //> lda Enemy_State,x
                            A = enemyState[X]
                            //> cmp #$02                     ;if enemy state defeated or otherwise
                            //> bcs FloateyPart              ;$02 or greater, branch beyond this part
                            if (A >= 0x02) {
                                //  goto FloateyPart (internal forward branch)
                                //> FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
                                A = floateynumYPos[X]
                                //> cmp #$18                     ;floatey number, if coordinate in the
                                //> bcc SetupNumSpr              ;status bar, branch
                                if (!(A >= 0x18)) {
                                    //  goto SetupNumSpr (internal forward branch)
                                    //> SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
                                    A = floateynumYPos[X]
                                    //> sbc #$08                     ;subtract eight and dump into the
                                    temp1 = A - 0x08
                                    A = temp1 and 0xFF
                                    //> jsr DumpTwoSpr               ;left and right sprite's Y coordinates
                                    dumpTwoSpr(A, Y)
                                    //> lda FloateyNum_X_Pos,x       ;get horizontal coordinate
                                    A = floateynumXPos[X]
                                    //> sta Sprite_X_Position,y      ;store into X coordinate of left sprite
                                    spriteXPosition[Y] = A
                                    //> clc
                                    //> adc #$08                     ;add eight pixels and store into X
                                    temp2 = A + 0x08
                                    A = temp2 and 0xFF
                                    //> sta Sprite_X_Position+4,y    ;coordinate of right sprite
                                    spriteXPosition[4 + Y] = A
                                    //> lda #$02
                                    A = 0x02
                                    //> sta Sprite_Attributes,y      ;set palette control in attribute bytes
                                    spriteAttributes[Y] = A
                                    //> sta Sprite_Attributes+4,y    ;of left and right sprites
                                    spriteAttributes[4 + Y] = A
                                    //> lda FloateyNum_Control,x
                                    A = floateynumControl[X]
                                    //> asl                          ;multiply our floatey number control by 2
                                    val orig4: Int = A
                                    A = (orig4 shl 1) and 0xFF
                                    //> tax                          ;and use as offset for look-up table
                                    X = A
                                    //> lda FloateyNumTileData,x
                                    A = floateyNumTileData[X]
                                    //> sta Sprite_Tilenumber,y      ;display first half of number of points
                                    spriteTilenumber[Y] = A
                                    //> lda FloateyNumTileData+1,x
                                    A = floateyNumTileData[1 + X]
                                    //> sta Sprite_Tilenumber+4,y    ;display the second half
                                    spriteTilenumber[4 + Y] = A
                                    //> ldx ObjectOffset             ;get enemy object offset and leave
                                    X = objectOffset
                                    //> rts
                                    return X
                                }
                                //> sbc #$01
                                temp3 = A - 0x01 - if (A >= 0x18) 0 else 1
                                A = temp3 and 0xFF
                                //> sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
                                floateynumYPos[X] = A
                                return X
                            }
                        }
                    }
                }
            }
            //> GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
            X = sprdataoffsetCtrl
            //> ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
            Y = altSprdataoffset[X]
            //> ldx ObjectOffset             ;get enemy object offset again
            X = objectOffset
        }
    }
    //> FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
    A = floateynumYPos[X]
    //> cmp #$18                     ;floatey number, if coordinate in the
    //> bcc SetupNumSpr              ;status bar, branch
    if (A >= 0x18) {
        //> sbc #$01
        temp4 = A - 0x01 - if (A >= 0x18) 0 else 1
        A = temp4 and 0xFF
        //> sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
        floateynumYPos[X] = A
    }
    //> SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
    A = floateynumYPos[X]
    //> sbc #$08                     ;subtract eight and dump into the
    temp5 = A - 0x08
    A = temp5 and 0xFF
    //> jsr DumpTwoSpr               ;left and right sprite's Y coordinates
    dumpTwoSpr(A, Y)
    //> lda FloateyNum_X_Pos,x       ;get horizontal coordinate
    A = floateynumXPos[X]
    //> sta Sprite_X_Position,y      ;store into X coordinate of left sprite
    spriteXPosition[Y] = A
    //> clc
    //> adc #$08                     ;add eight pixels and store into X
    temp6 = A + 0x08
    A = temp6 and 0xFF
    //> sta Sprite_X_Position+4,y    ;coordinate of right sprite
    spriteXPosition[4 + Y] = A
    //> lda #$02
    A = 0x02
    //> sta Sprite_Attributes,y      ;set palette control in attribute bytes
    spriteAttributes[Y] = A
    //> sta Sprite_Attributes+4,y    ;of left and right sprites
    spriteAttributes[4 + Y] = A
    //> lda FloateyNum_Control,x
    A = floateynumControl[X]
    //> asl                          ;multiply our floatey number control by 2
    val orig5: Int = A
    A = (orig5 shl 1) and 0xFF
    //> tax                          ;and use as offset for look-up table
    X = A
    //> lda FloateyNumTileData,x
    A = floateyNumTileData[X]
    //> sta Sprite_Tilenumber,y      ;display first half of number of points
    spriteTilenumber[Y] = A
    //> lda FloateyNumTileData+1,x
    A = floateyNumTileData[1 + X]
    //> sta Sprite_Tilenumber+4,y    ;display the second half
    spriteTilenumber[4 + Y] = A
    //> ldx ObjectOffset             ;get enemy object offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from ScreenRoutines
fun screenRoutines() {
    var A: Int = 0
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> ScreenRoutines:
    //> lda ScreenRoutineTask        ;run one of the following subroutines
    A = screenRoutineTask
    //> jsr JumpEngine
    when (A) {
        0 -> {
            initScreen()
        }
        1 -> {
            setupIntermediate()
        }
        2 -> {
            writeTopStatusLine()
        }
        3 -> {
            writeBottomStatusLine()
        }
        4 -> {
            displayTimeUp()
        }
        5 -> {
            resetSpritesAndScreenTimer()
        }
        6 -> {
            displayIntermediate()
        }
        7 -> {
            resetSpritesAndScreenTimer()
        }
        8 -> {
            areaParserTaskControl()
        }
        9 -> {
            getAreaPalette()
        }
        10 -> {
            getBackgroundColor()
        }
        11 -> {
            getAlternatePalette1()
        }
        12 -> {
            drawTitleScreen()
        }
        13 -> {
            clearBuffersDrawIcon()
        }
        14 -> {
            writeTopScore()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw InitScreen
    //> .dw SetupIntermediate
    //> .dw WriteTopStatusLine
    //> .dw WriteBottomStatusLine
    //> .dw DisplayTimeUp
    //> .dw ResetSpritesAndScreenTimer
    //> .dw DisplayIntermediate
    //> .dw ResetSpritesAndScreenTimer
    //> .dw AreaParserTaskControl
    //> .dw GetAreaPalette
    //> .dw GetBackgroundColor
    //> .dw GetAlternatePalette1
    //> .dw DrawTitleScreen
    //> .dw ClearBuffersDrawIcon
    //> .dw WriteTopScore
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to initScreen
    initScreen()
    return
}

// Decompiled from InitScreen
fun initScreen() {
    var A: Int = 0
    var X: Int = 0
    var operMode by MemoryByte(OperMode)
    //> InitScreen:
    //> jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
    moveAllSpritesOffscreen()
    //> jsr InitializeNameTables    ;and erase both name and attribute tables
    initializeNameTables()
    //> lda OperMode
    A = operMode
    //> beq NextSubtask             ;if mode still 0, do not load
    if (A == 0) {
        //  goto NextSubtask -> nextSubtask
        nextSubtask()
        return
    } else {
        //> ldx #$03                    ;into buffer pointer
        X = 0x03
        //> jmp SetVRAMAddr_A
        setvramaddrA(X)
        return
    }
}

// Decompiled from SetupIntermediate
fun setupIntermediate() {
    var A: Int = 0
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var playerStatus by MemoryByte(PlayerStatus)
    //> SetupIntermediate:
    //> lda BackgroundColorCtrl  ;save current background color control
    A = backgroundColorCtrl
    //> pha                      ;and player status to stack
    push(A)
    //> lda PlayerStatus
    A = playerStatus
    //> pha
    push(A)
    //> lda #$00                 ;set background color to black
    A = 0x00
    //> sta PlayerStatus         ;and player status to not fiery
    playerStatus = A
    //> lda #$02                 ;this is the ONLY time background color control
    A = 0x02
    //> sta BackgroundColorCtrl  ;is set to less than 4
    backgroundColorCtrl = A
    //> jsr GetPlayerColors
    getPlayerColors()
    //> pla                      ;we only execute this routine for
    A = pull()
    //> sta PlayerStatus         ;the intermediate lives display
    playerStatus = A
    //> pla                      ;and once we're done, we return bg
    A = pull()
    //> sta BackgroundColorCtrl  ;color ctrl and player status from stack
    backgroundColorCtrl = A
    //> jmp IncSubtask           ;then move onto the next task
    incSubtask()
    return
}

// Decompiled from GetAreaPalette
fun getAreaPalette() {
    var X: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    val areaPalette by MemoryByteIndexed(AreaPalette)
    //> GetAreaPalette:
    //> ldy AreaType             ;select appropriate palette to load
    Y = areaType
    //> ldx AreaPalette,y        ;based on area type
    X = areaPalette[Y]
    //  Fall-through tail call to setvramaddrA
    setvramaddrA(X)
    return
}

// Decompiled from SetVRAMAddr_A
fun setvramaddrA(X: Int) {
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
    vramBufferAddrctrl = X
    //  Fall-through tail call to nextSubtask
    nextSubtask()
    return
}

// Decompiled from NextSubtask
fun nextSubtask() {
    //> NextSubtask:   jmp IncSubtask           ;move onto next task
    incSubtask()
    return
}

// Decompiled from GetBackgroundColor
fun getBackgroundColor() {
    var A: Int = 0
    var Y: Int = 0
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    val bgcolorctrlAddr by MemoryByteIndexed(BGColorCtrl_Addr)
    //> GetBackgroundColor:
    //> ldy BackgroundColorCtrl   ;check background color control
    Y = backgroundColorCtrl
    //> beq NoBGColor             ;if not set, increment task and fetch palette
    if (Y != 0) {
        //> lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
        A = bgcolorctrlAddr[-4 + Y]
        //> sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, $0301 will not be read
        vramBufferAddrctrl = A
    }
    //> NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //  Fall-through tail call to getPlayerColors
    getPlayerColors()
    return
}

// Decompiled from GetPlayerColors
fun getPlayerColors() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var currentPlayer by MemoryByte(CurrentPlayer)
    var playerStatus by MemoryByte(PlayerStatus)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val backgroundColors by MemoryByteIndexed(BackgroundColors)
    val playerColors by MemoryByteIndexed(PlayerColors)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> GetPlayerColors:
    //> ldx VRAM_Buffer1_Offset  ;get current buffer offset
    X = vramBuffer1Offset
    //> ldy #$00
    Y = 0x00
    //> lda CurrentPlayer        ;check which player is on the screen
    A = currentPlayer
    //> beq ChkFiery
    if (A != 0) {
        //> ldy #$04                 ;load offset for luigi
        Y = 0x04
    }
    //> ChkFiery:      lda PlayerStatus         ;check player status
    A = playerStatus
    //> cmp #$02
    //> bne StartClrGet          ;if fiery, load alternate offset for fiery player
    if (A == 0x02) {
        //> ldy #$08
        Y = 0x08
    }
    //> StartClrGet:   lda #$03                 ;do four colors
    A = 0x03
    //> sta $00
    memory[0x0] = A.toUByte()
    loop0@ do {
        //> ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
        A = playerColors[Y]
        //> sta VRAM_Buffer1+3,x     ;in the buffer
        vramBuffer1[3 + X] = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> inx
        X = (X + 1) and 0xFF
        //> dec $00
        memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
        //> bpl ClrGetLoop
        if (!((memory[0x0].toInt() and 0x80) != 0)) {
            //  continue loop (branch back to ClrGetLoop)
            continue@loop0
        }
    } while ((memory[0x0].toInt() and 0x80) == 0)
    //> ldx VRAM_Buffer1_Offset  ;load original offset from before
    X = vramBuffer1Offset
    //> ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
    Y = backgroundColorCtrl
    //> bne SetBGColor           ;therefore use it as offset to background color
    if (Y == 0) {
        //> ldy AreaType             ;otherwise use area type bits from area offset as offset
        Y = areaType
    }
    //> SetBGColor:    lda BackgroundColors,y   ;to background color instead
    A = backgroundColors[Y]
    //> sta VRAM_Buffer1+3,x
    vramBuffer1[3 + X] = A
    //> lda #$3f                 ;set for sprite palette address
    A = 0x3F
    //> sta VRAM_Buffer1,x       ;save to buffer
    vramBuffer1[X] = A
    //> lda #$10
    A = 0x10
    //> sta VRAM_Buffer1+1,x
    vramBuffer1[1 + X] = A
    //> lda #$04                 ;write length byte to buffer
    A = 0x04
    //> sta VRAM_Buffer1+2,x
    vramBuffer1[2 + X] = A
    //> lda #$00                 ;now the null terminator
    A = 0x00
    //> sta VRAM_Buffer1+7,x
    vramBuffer1[7 + X] = A
    //> txa                      ;move the buffer pointer ahead 7 bytes
    A = X
    //> clc                      ;in case we want to write anything else later
    //> adc #$07
    temp0 = A + 0x07
    A = temp0 and 0xFF
    //  Fall-through tail call to setVRAMOffset
    setVRAMOffset(A)
    return
}

// Decompiled from SetVRAMOffset
fun setVRAMOffset(A: Int) {
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    //> SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
    vramBuffer1Offset = A
    //> rts
    return
}

// Decompiled from GetAlternatePalette1
fun getAlternatePalette1() {
    var A: Int = 0
    var areaStyle by MemoryByte(AreaStyle)
    //> GetAlternatePalette1:
    //> lda AreaStyle            ;check for mushroom level style
    A = areaStyle
    //> cmp #$01
    //> bne NoAltPal
    if (!(A == 0x01)) {
        //  goto NoAltPal -> noAltPal
        noAltPal()
        return
    } else {
        //> lda #$0b                 ;if found, load appropriate palette
        A = 0x0B
        //  Fall-through tail call to setvramaddrB
        setvramaddrB(A)
        return
    }
}

// Decompiled from SetVRAMAddr_B
fun setvramaddrB(A: Int) {
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
    vramBufferAddrctrl = A
    //  Fall-through tail call to noAltPal
    noAltPal()
    return
}

// Decompiled from NoAltPal
fun noAltPal() {
    //> NoAltPal:      jmp IncSubtask           ;now onto the next task
    incSubtask()
    return
}

// Decompiled from WriteTopStatusLine
fun writeTopStatusLine() {
    var A: Int = 0
    //> WriteTopStatusLine:
    //> lda #$00          ;select main status bar
    A = 0x00
    //> jsr WriteGameText ;output it
    writeGameText(A)
    //> jmp IncSubtask    ;onto the next task
    incSubtask()
    return
}

// Decompiled from WriteBottomStatusLine
fun writeBottomStatusLine() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var levelNumber by MemoryByte(LevelNumber)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    var worldNumber by MemoryByte(WorldNumber)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> WriteBottomStatusLine:
    //> jsr GetSBNybbles        ;write player's score and coin tally to screen
    getSBNybbles()
    //> ldx VRAM_Buffer1_Offset
    X = vramBuffer1Offset
    //> lda #$20                ;write address for world-area number on screen
    A = 0x20
    //> sta VRAM_Buffer1,x
    vramBuffer1[X] = A
    //> lda #$73
    A = 0x73
    //> sta VRAM_Buffer1+1,x
    vramBuffer1[1 + X] = A
    //> lda #$03                ;write length for it
    A = 0x03
    //> sta VRAM_Buffer1+2,x
    vramBuffer1[2 + X] = A
    //> ldy WorldNumber         ;first the world number
    Y = worldNumber
    //> iny
    Y = (Y + 1) and 0xFF
    //> tya
    A = Y
    //> sta VRAM_Buffer1+3,x
    vramBuffer1[3 + X] = A
    //> lda #$28                ;next the dash
    A = 0x28
    //> sta VRAM_Buffer1+4,x
    vramBuffer1[4 + X] = A
    //> ldy LevelNumber         ;next the level number
    Y = levelNumber
    //> iny                     ;increment for proper number display
    Y = (Y + 1) and 0xFF
    //> tya
    A = Y
    //> sta VRAM_Buffer1+5,x
    vramBuffer1[5 + X] = A
    //> lda #$00                ;put null terminator on
    A = 0x00
    //> sta VRAM_Buffer1+6,x
    vramBuffer1[6 + X] = A
    //> txa                     ;move the buffer offset up by 6 bytes
    A = X
    //> clc
    //> adc #$06
    temp0 = A + 0x06
    A = temp0 and 0xFF
    //> sta VRAM_Buffer1_Offset
    vramBuffer1Offset = A
    //> jmp IncSubtask
    incSubtask()
    return
}

// Decompiled from DisplayTimeUp
fun displayTimeUp() {
    var A: Int = 0
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> DisplayTimeUp:
    //> lda GameTimerExpiredFlag  ;if game timer not expired, increment task
    A = gameTimerExpiredFlag
    //> beq NoTimeUp              ;control 2 tasks forward, otherwise, stay here
    if (A != 0) {
        //> lda #$00
        A = 0x00
        //> sta GameTimerExpiredFlag  ;reset timer expiration flag
        gameTimerExpiredFlag = A
        //> lda #$02                  ;output time-up screen to buffer
        A = 0x02
        //> jmp OutputInter
        outputInter(A)
        return
    } else {
        //> NoTimeUp: inc ScreenRoutineTask     ;increment control task 2 tasks forward
        screenRoutineTask = (screenRoutineTask + 1) and 0xFF
        //> jmp IncSubtask
        incSubtask()
        return
    }
}

// Decompiled from DisplayIntermediate
fun displayIntermediate() {
    var A: Int = 0
    var Y: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var disableIntermediate by MemoryByte(DisableIntermediate)
    var operMode by MemoryByte(OperMode)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var screenTimer by MemoryByte(ScreenTimer)
    //> DisplayIntermediate:
    //> lda OperMode                 ;check primary mode of operation
    A = operMode
    //> beq NoInter                  ;if in title screen mode, skip this
    if (A != 0) {
        //> cmp #GameOverModeValue       ;are we in game over mode?
        //> beq GameOverInter            ;if so, proceed to display game over screen
        if (A != GameOverModeValue) {
            //> lda AltEntranceControl       ;otherwise check for mode of alternate entry
            A = altEntranceControl
            //> bne NoInter                  ;and branch if found
            if (A == 0) {
                //> ldy AreaType                 ;check if we are on castle level
                Y = areaType
                //> cpy #$03                     ;and if so, branch (possibly residual)
                //> beq PlayerInter
                if (Y != 0x03) {
                    //> lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
                    A = disableIntermediate
                    //> bne NoInter                  ;and jump to specific task, otherwise
                    if (!(A == 0)) {
                        //  goto NoInter (internal forward branch)
                        //> NoInter:       lda #$08                     ;set for specific task and leave
                        A = 0x08
                        //> sta ScreenRoutineTask
                        screenRoutineTask = A
                        //> rts
                        return
                    }
                }
                //> PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
                drawplayerIntermediate()
                //> lda #$01                     ;lives display, then output lives display to buffer
                A = 0x01
                //  Fall-through tail call to outputInter
                outputInter(A)
                return
            }
        } else {
            //> GameOverInter: lda #$12                     ;set screen timer
            A = 0x12
            //> sta ScreenTimer
            screenTimer = A
            //> lda #$03                     ;output game over screen to buffer
            A = 0x03
            //> jsr WriteGameText
            writeGameText(A)
            //> jmp IncModeTask_B
            incmodetaskB()
            return
            //> NoInter:       lda #$08                     ;set for specific task and leave
            A = 0x08
            //> sta ScreenRoutineTask
            screenRoutineTask = A
            //> rts
            return
        }
    }
    //> NoInter:       lda #$08                     ;set for specific task and leave
    A = 0x08
    //> sta ScreenRoutineTask
    screenRoutineTask = A
    //> rts
    return
}

// Decompiled from OutputInter
fun outputInter(A: Int) {
    var A: Int = A
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    //> OutputInter:   jsr WriteGameText
    writeGameText(A)
    //> jsr ResetScreenTimer
    resetScreenTimer()
    //> lda #$00
    A = 0x00
    //> sta DisableScreenFlag        ;reenable screen output
    disableScreenFlag = A
    //> rts
    return
}

// Decompiled from AreaParserTaskControl
fun areaParserTaskControl() {
    var A: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var columnSets by MemoryByte(ColumnSets)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> AreaParserTaskControl:
    //> inc DisableScreenFlag     ;turn off screen
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    loop0@ do {
        //> TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
        areaParserTaskHandler()
        //> lda AreaParserTaskNum     ;check number of tasks
        A = areaParserTaskNum
        //> bne TaskLoop              ;if tasks still not all done, do another one
        if (!(A == 0)) {
            //  continue loop (branch back to TaskLoop)
            continue@loop0
        }
    } while (A != 0)
    //> dec ColumnSets            ;do we need to render more column sets?
    columnSets = (columnSets - 1) and 0xFF
    //> bpl OutputCol
    if ((columnSets and 0x80) != 0) {
        //> inc ScreenRoutineTask     ;if not, move on to the next task
        screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    }
    //> OutputCol: lda #$06                  ;set vram buffer to output rendered column set
    A = 0x06
    //> sta VRAM_Buffer_AddrCtrl  ;on next NMI
    vramBufferAddrctrl = A
    //> rts
    return
}

// Decompiled from DrawTitleScreen
fun drawTitleScreen() {
    var A: Int = 0
    var Y: Int = 0
    var operMode by MemoryByte(OperMode)
    var ppuAddress by MemoryByte(PPU_ADDRESS)
    var ppuData by MemoryByte(PPU_DATA)
    //> DrawTitleScreen:
    //> lda OperMode                 ;are we in title screen mode?
    A = operMode
    //> bne IncModeTask_B            ;if not, exit
    if (!(A == 0)) {
        //  goto IncModeTask_B -> incmodetaskB
        incmodetaskB()
        return
    } else {
        //> lda #>TitleScreenDataOffset  ;load address $1ec0 into
        A = TitleScreenDataOffset shr 8
        //> sta PPU_ADDRESS              ;the vram address register
        ppuAddress = A
        //> lda #<TitleScreenDataOffset
        A = TitleScreenDataOffset and 0xFF
        //> sta PPU_ADDRESS
        ppuAddress = A
        //> lda #$03                     ;put address $0300 into
        A = 0x03
        //> sta $01                      ;the indirect at $00
        memory[0x1] = A.toUByte()
        //> ldy #$00
        Y = 0x00
        //> sty $00
        memory[0x0] = Y.toUByte()
        //> lda PPU_DATA                 ;do one garbage read
        A = ppuData
    }
    loop0@ do {
        //> OutputTScr: lda PPU_DATA                 ;get title screen from chr-rom
        A = ppuData
        //> sta ($00),y                  ;store 256 bytes into buffer
        memory[readWord(0x0) + Y] = A.toUByte()
        //> iny
        Y = (Y + 1) and 0xFF
        //> bne ChkHiByte                ;if not past 256 bytes, do not increment
        if (Y == 0) {
            //> inc $01                      ;otherwise increment high byte of indirect
            memory[0x1] = ((memory[0x1].toInt() + 1) and 0xFF).toUByte()
        }
        //> ChkHiByte:  lda $01                      ;check high byte?
        A = memory[0x1].toInt()
        //> cmp #$04                     ;at $0400?
        //> bne OutputTScr               ;if not, loop back and do another
        if (!(A == 0x04)) {
            //  continue loop (branch back to OutputTScr)
            continue@loop0
        }
        //> cpy #$3a                     ;check if offset points past end of data
        //> bcc OutputTScr               ;if not, loop back and do another
        if (!(Y >= 0x3A)) {
            //  continue loop (branch back to OutputTScr)
            continue@loop0
        }
    } while (Y != 0x3A)
    //> lda #$05                     ;set buffer transfer control to $0300,
    A = 0x05
    //> jmp SetVRAMAddr_B            ;increment task and exit
    setvramaddrB(A)
    return
}

// Decompiled from ClearBuffersDrawIcon
fun clearBuffersDrawIcon() {
    var A: Int = 0
    var X: Int = 0
    var operMode by MemoryByte(OperMode)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> ClearBuffersDrawIcon:
    //> lda OperMode               ;check game mode
    A = operMode
    //> bne IncModeTask_B          ;if not title screen mode, leave
    if (!(A == 0)) {
        //  goto IncModeTask_B -> incmodetaskB
        incmodetaskB()
        return
    } else {
        //> ldx #$00                   ;otherwise, clear buffer space
        X = 0x00
    }
    loop0@ do {
        //> TScrClear:   sta VRAM_Buffer1-1,x
        vramBuffer1[-1 + X] = A
        //> sta VRAM_Buffer1-1+$100,x
        vramBuffer1[255 + X] = A
        //> dex
        X = (X - 1) and 0xFF
        //> bne TScrClear
        if (!(X == 0)) {
            //  continue loop (branch back to TScrClear)
            continue@loop0
        }
    } while (X != 0)
    //> jsr DrawMushroomIcon       ;draw player select icon
    drawMushroomIcon()
    //  Fall-through tail call to incSubtask
    incSubtask()
    return
}

// Decompiled from IncSubtask
fun incSubtask() {
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from WriteTopScore
fun writeTopScore() {
    var A: Int = 0
    //> WriteTopScore:
    //> lda #$fa           ;run display routine to display top score on title
    A = 0xFA
    //> jsr UpdateNumber
    updateNumber(A)
    //  Fall-through tail call to incmodetaskB
    incmodetaskB()
    return
}

// Decompiled from IncModeTask_B
fun incmodetaskB() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> IncModeTask_B: inc OperMode_Task  ;move onto next mode
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from WriteGameText
fun writeGameText(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var levelNumber by MemoryByte(LevelNumber)
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    var numberofLives by MemoryByte(NumberofLives)
    var operMode by MemoryByte(OperMode)
    var worldNumber by MemoryByte(WorldNumber)
    val gameText by MemoryByteIndexed(GameText)
    val gameTextOffsets by MemoryByteIndexed(GameTextOffsets)
    val luigiName by MemoryByteIndexed(LuigiName)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    val warpZoneNumbers by MemoryByteIndexed(WarpZoneNumbers)
    //> WriteGameText:
    //> pha                      ;save text number to stack
    push(A)
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> tay                      ;multiply by 2 and use as offset
    Y = A
    //> cpy #$04                 ;if set to do top status bar or world/lives display,
    //> bcc LdGameText           ;branch to use current offset as-is
    A = A
    Y = Y
    if (Y >= 0x04) {
        //> cpy #$08                 ;if set to do time-up or game over,
        //> bcc Chk2Players          ;branch to check players
        if (Y >= 0x08) {
            //> ldy #$08                 ;otherwise warp zone, therefore set offset
            Y = 0x08
        }
        //> Chk2Players:   lda NumberOfPlayers      ;check for number of players
        A = numberOfPlayers
        //> bne LdGameText           ;if there are two, use current offset to also print name
        if (A == 0) {
            //> iny                      ;otherwise increment offset by one to not print name
            Y = (Y + 1) and 0xFF
        }
    }
    //> LdGameText:    ldx GameTextOffsets,y    ;get offset to message we want to print
    X = gameTextOffsets[Y]
    //> ldy #$00
    Y = 0x00
    loop0@ while (Y != 0) {
        //> sta VRAM_Buffer1,y       ;otherwise write data to buffer
        vramBuffer1[Y] = A
        //> inx                      ;and increment increment
        X = (X + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> bne GameTextLoop         ;do this for 256 bytes if no terminator found
        if (!(Y == 0)) {
            //  continue loop (branch back to GameTextLoop)
            continue@loop0
        }
    }
    //> EndGameText:   lda #$00                 ;put null terminator at end
    A = 0x00
    //> sta VRAM_Buffer1,y
    vramBuffer1[Y] = A
    //> pla                      ;pull original text number from stack
    A = pull()
    //> tax
    X = A
    //> cmp #$04                 ;are we printing warp zone?
    //> bcs PrintWarpZoneNumbers
    if (!(A >= 0x04)) {
        //> dex                      ;are we printing the world/lives display?
        X = (X - 1) and 0xFF
        //> bne CheckPlayerName      ;if not, branch to check player's name
        if (X == 0) {
            //> lda NumberofLives        ;otherwise, check number of lives
            A = numberofLives
            //> clc                      ;and increment by one for display
            //> adc #$01
            temp0 = A + 0x01
            A = temp0 and 0xFF
            //> cmp #10                  ;more than 9 lives?
            //> bcc PutLives
            if (A >= 0x0A) {
                //> sbc #10                  ;if so, subtract 10 and put a crown tile
                temp1 = A - 0x0A - if (A >= 0x0A) 0 else 1
                A = temp1 and 0xFF
                //> ldy #$9f                 ;next to the difference...strange things happen if
                Y = 0x9F
                //> sty VRAM_Buffer1+7       ;the number of lives exceeds 19
                vramBuffer1[7] = Y
            }
            //> PutLives:      sta VRAM_Buffer1+8
            vramBuffer1[8] = A
            //> ldy WorldNumber          ;write world and level numbers (incremented for display)
            Y = worldNumber
            //> iny                      ;to the buffer in the spaces surrounding the dash
            Y = (Y + 1) and 0xFF
            //> sty VRAM_Buffer1+19
            vramBuffer1[19] = Y
            //> ldy LevelNumber
            Y = levelNumber
            //> iny
            Y = (Y + 1) and 0xFF
            //> sty VRAM_Buffer1+21      ;we're done here
            vramBuffer1[21] = Y
            //> rts
            return
        }
        //> CheckPlayerName:
        //> lda NumberOfPlayers    ;check number of players
        A = numberOfPlayers
        //> beq ExitChkName        ;if only 1 player, leave
        if (A != 0) {
            //> lda CurrentPlayer      ;load current player
            A = currentPlayer
            //> dex                    ;check to see if current message number is for time up
            X = (X - 1) and 0xFF
            //> bne ChkLuigi
            if (X == 0) {
                //> ldy OperMode           ;check for game over mode
                Y = operMode
                //> cpy #GameOverModeValue
                //> beq ChkLuigi
                if (Y != GameOverModeValue) {
                    //> eor #%00000001         ;if not, must be time up, invert d0 to do other player
                    A = A xor 0x01
                }
            }
            //> ChkLuigi:    lsr
            val orig1: Int = A
            A = orig1 shr 1
            //> bcc ExitChkName        ;if mario is current player, do not change the name
            if ((orig1 and 0x01) != 0) {
                //> ldy #$04
                Y = 0x04
                loop1@ do {
                    //> NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
                    A = luigiName[Y]
                    //> sta VRAM_Buffer1+3,y
                    vramBuffer1[3 + Y] = A
                    //> dey
                    Y = (Y - 1) and 0xFF
                    //> bpl NameLoop           ;do this until each letter is replaced
                    if (!((Y and 0x80) != 0)) {
                        //  continue loop (branch back to NameLoop)
                        continue@loop1
                    }
                } while ((Y and 0x80) == 0)
            }
        }
        //> ExitChkName: rts
        return
    } else {
        //> PrintWarpZoneNumbers:
        //> sbc #$04               ;subtract 4 and then shift to the left
        temp2 = A - 0x04 - if (A >= 0x04) 0 else 1
        A = temp2 and 0xFF
        //> asl                    ;twice to get proper warp zone number
        val orig2: Int = A
        A = (orig2 shl 1) and 0xFF
        //> asl                    ;offset
        val orig3: Int = A
        A = (orig3 shl 1) and 0xFF
        //> tax
        X = A
        //> ldy #$00
        Y = 0x00
    }
    loop2@ do {
        //> WarpNumLoop: lda WarpZoneNumbers,x  ;print warp zone numbers into the
        A = warpZoneNumbers[X]
        //> sta VRAM_Buffer1+27,y  ;placeholders from earlier
        vramBuffer1[27 + Y] = A
        //> inx
        X = (X + 1) and 0xFF
        //> iny                    ;put a number in every fourth space
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> cpy #$0c
        //> bcc WarpNumLoop
        if (!(Y >= 0x0C)) {
            //  continue loop (branch back to WarpNumLoop)
            continue@loop2
        }
    } while (!(Y >= 0x0C))
    //> lda #$2c               ;load new buffer pointer at end of message
    A = 0x2C
    //> jmp SetVRAMOffset
    setVRAMOffset(A)
    return
}

// Decompiled from ResetSpritesAndScreenTimer
fun resetSpritesAndScreenTimer() {
    var A: Int = 0
    var screenTimer by MemoryByte(ScreenTimer)
    //> ResetSpritesAndScreenTimer:
    //> lda ScreenTimer             ;check if screen timer has expired
    A = screenTimer
    //> bne NoReset                 ;if not, branch to leave
    if (!(A == 0)) {
        //  goto NoReset -> noReset
        noReset()
        return
    } else {
        //> jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
        moveAllSpritesOffscreen()
        //  Fall-through tail call to resetScreenTimer
        resetScreenTimer()
        return
    }
}

// Decompiled from ResetScreenTimer
fun resetScreenTimer() {
    var A: Int = 0
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var screenTimer by MemoryByte(ScreenTimer)
    //> ResetScreenTimer:
    //> lda #$07                    ;reset timer again
    A = 0x07
    //> sta ScreenTimer
    screenTimer = A
    //> inc ScreenRoutineTask       ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //  Fall-through tail call to noReset
    noReset()
    return
}

// Decompiled from NoReset
fun noReset() {
    //> NoReset: rts
    return
}

// Decompiled from RenderAreaGraphics
fun renderAreaGraphics() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentntaddrHigh by MemoryByte(CurrentNTAddr_High)
    var currentntaddrLow by MemoryByte(CurrentNTAddr_Low)
    var vramBuffer2Offset by MemoryByte(VRAM_Buffer2_Offset)
    val attributeBuffer by MemoryByteIndexed(AttributeBuffer)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val metatilegraphicsHigh by MemoryByteIndexed(MetatileGraphics_High)
    val metatilegraphicsLow by MemoryByteIndexed(MetatileGraphics_Low)
    val vramBuffer2 by MemoryByteIndexed(VRAM_Buffer2)
    //> RenderAreaGraphics:
    //> lda CurrentColumnPos         ;store LSB of where we're at
    A = currentColumnPos
    //> and #$01
    A = A and 0x01
    //> sta $05
    memory[0x5] = A.toUByte()
    //> ldy VRAM_Buffer2_Offset      ;store vram buffer offset
    Y = vramBuffer2Offset
    //> sty $00
    memory[0x0] = Y.toUByte()
    //> lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
    A = currentntaddrLow
    //> sta VRAM_Buffer2+1,y
    vramBuffer2[1 + Y] = A
    //> lda CurrentNTAddr_High
    A = currentntaddrHigh
    //> sta VRAM_Buffer2,y
    vramBuffer2[Y] = A
    //> lda #$9a                     ;store length byte of 26 here with d7 set
    A = 0x9A
    //> sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
    vramBuffer2[2 + Y] = A
    //> lda #$00                     ;init attribute row
    A = 0x00
    //> sta $04
    memory[0x4] = A.toUByte()
    //> tax
    X = A
    X = X
    loop0@ do {
        //> DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
        memory[0x1] = X.toUByte()
        //> lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
        A = metatileBuffer[X]
        //> and #%11000000
        A = A and 0xC0
        //> sta $03                      ;store attribute table bits here
        memory[0x3] = A.toUByte()
        //> asl                          ;note that metatile format is:
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> rol                          ;%xx000000 - attribute table bits,
        val orig1: Int = A
        A = (orig1 shl 1) and 0xFE or if ((orig0 and 0x80) != 0) 1 else 0
        //> rol                          ;%00xxxxxx - metatile number
        val orig2: Int = A
        A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x80) != 0) 1 else 0
        //> tay                          ;rotate bits to d1-d0 and use as offset here
        Y = A
        //> lda MetatileGraphics_Low,y   ;get address to graphics table from here
        A = metatilegraphicsLow[Y]
        //> sta $06
        memory[0x6] = A.toUByte()
        //> lda MetatileGraphics_High,y
        A = metatilegraphicsHigh[Y]
        //> sta $07
        memory[0x7] = A.toUByte()
        //> lda MetatileBuffer,x         ;get metatile number again
        A = metatileBuffer[X]
        //> asl                          ;multiply by 4 and use as tile offset
        val orig3: Int = A
        A = (orig3 shl 1) and 0xFF
        //> asl
        val orig4: Int = A
        A = (orig4 shl 1) and 0xFF
        //> sta $02
        memory[0x2] = A.toUByte()
        //> lda AreaParserTaskNum        ;get current task number for level processing and
        A = areaParserTaskNum
        //> and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
        A = A and 0x01
        //> eor #%00000001               ;to get the correct column position in the metatile,
        A = A xor 0x01
        //> asl                          ;then add to the tile offset so we can draw either side
        val orig5: Int = A
        A = (orig5 shl 1) and 0xFF
        //> adc $02                      ;of the metatiles
        temp0 = A + memory[0x2].toInt() + if ((orig5 and 0x80) != 0) 1 else 0
        A = temp0 and 0xFF
        //> tay
        Y = A
        //> ldx $00                      ;use vram buffer offset from before as X
        X = memory[0x0].toInt()
        //> lda ($06),y
        A = memory[readWord(0x6) + Y].toInt()
        //> sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
        vramBuffer2[3 + X] = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> lda ($06),y                  ;now get the second (bottom left or bottom right) and store
        A = memory[readWord(0x6) + Y].toInt()
        //> sta VRAM_Buffer2+4,x
        vramBuffer2[4 + X] = A
        //> ldy $04                      ;get current attribute row
        Y = memory[0x4].toInt()
        //> lda $05                      ;get LSB of current column where we're at, and
        A = memory[0x5].toInt()
        //> bne RightCheck               ;branch if set (clear = left attrib, set = right)
        if (A == 0) {
            //> lda $01                      ;get current row we're rendering
            A = memory[0x1].toInt()
            //> lsr                          ;branch if LSB set (clear = top left, set = bottom left)
            val orig6: Int = A
            A = orig6 shr 1
            //> bcs LLeft
            if ((orig6 and 0x01) == 0) {
                //> rol $03                      ;rotate attribute bits 3 to the left
                memory[0x3] = (((memory[0x3].toInt() shl 1) and 0xFE or if ((orig6 and 0x01) != 0) 1 else 0) and 0xFF).toUByte()
                //> rol $03                      ;thus in d1-d0, for upper left square
                memory[0x3] = (((memory[0x3].toInt() shl 1) and 0xFE or if ((memory[0x3].toInt() and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
                //> rol $03
                memory[0x3] = (((memory[0x3].toInt() shl 1) and 0xFE or if ((memory[0x3].toInt() and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
                //> jmp SetAttrib
                //> jmp SetAttrib (not a known function)
            }
        } else {
            //> RightCheck: lda $01                      ;get LSB of current row we're rendering
            A = memory[0x1].toInt()
            //> lsr                          ;branch if set (clear = top right, set = bottom right)
            val orig7: Int = A
            A = orig7 shr 1
            //> bcs NextMTRow
            if ((orig7 and 0x01) == 0) {
                //> lsr $03                      ;shift attribute bits 4 to the right
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03                      ;thus in d3-d2, for upper right square
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> jmp SetAttrib
                //> jmp SetAttrib (not a known function)
                //> LLeft:      lsr $03                      ;shift attribute bits 2 to the right
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03                      ;thus in d5-d4 for lower left square
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
            }
            //> NextMTRow:  inc $04                      ;move onto next attribute row
            memory[0x4] = ((memory[0x4].toInt() + 1) and 0xFF).toUByte()
        }
        //> SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
        A = attributeBuffer[Y]
        //> ora $03                      ;if any, and put new bits, if any, onto
        A = A or memory[0x3].toInt()
        //> sta AttributeBuffer,y        ;the old, and store
        attributeBuffer[Y] = A
        //> inc $00                      ;increment vram buffer offset by 2
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> inc $00
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> ldx $01                      ;get current gfx buffer row, and check for
        X = memory[0x1].toInt()
        //> inx                          ;the bottom of the screen
        X = (X + 1) and 0xFF
        //> cpx #$0d
        //> bcc DrawMTLoop               ;if not there yet, loop back
        if (!(X >= 0x0D)) {
            //  continue loop (branch back to DrawMTLoop)
            continue@loop0
        }
    } while (!(X >= 0x0D))
    //> ldy $00                      ;get current vram buffer offset, increment by 3
    Y = memory[0x0].toInt()
    //> iny                          ;(for name table address and length bytes)
    Y = (Y + 1) and 0xFF
    //> iny
    Y = (Y + 1) and 0xFF
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda #$00
    A = 0x00
    //> sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
    vramBuffer2[Y] = A
    //> sty VRAM_Buffer2_Offset      ;store new buffer offset
    vramBuffer2Offset = Y
    //> inc CurrentNTAddr_Low        ;increment name table address low
    currentntaddrLow = (currentntaddrLow + 1) and 0xFF
    //> lda CurrentNTAddr_Low        ;check current low byte
    A = currentntaddrLow
    //> and #%00011111               ;if no wraparound, just skip this part
    A = A and 0x1F
    //> bne ExitDrawM
    if (A == 0) {
        //> lda #$80                     ;if wraparound occurs, make sure low byte stays
        A = 0x80
        //> sta CurrentNTAddr_Low        ;just under the status bar
        currentntaddrLow = A
        //> lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
        A = currentntaddrHigh
        //> eor #%00000100               ;to move onto the next appropriate name table
        A = A xor 0x04
        //> sta CurrentNTAddr_High
        currentntaddrHigh = A
    }
    //> ExitDrawM:  jmp SetVRAMCtrl              ;jump to set buffer to $0341 and leave
    setVRAMCtrl()
    return
}

// Decompiled from RenderAttributeTables
fun renderAttributeTables() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var currentntaddrHigh by MemoryByte(CurrentNTAddr_High)
    var currentntaddrLow by MemoryByte(CurrentNTAddr_Low)
    var vramBuffer2Offset by MemoryByte(VRAM_Buffer2_Offset)
    val attributeBuffer by MemoryByteIndexed(AttributeBuffer)
    val vramBuffer2 by MemoryByteIndexed(VRAM_Buffer2)
    //> RenderAttributeTables:
    //> lda CurrentNTAddr_Low    ;get low byte of next name table address
    A = currentntaddrLow
    //> and #%00011111           ;to be written to, mask out all but 5 LSB,
    A = A and 0x1F
    //> sec                      ;subtract four
    //> sbc #$04
    temp0 = A - 0x04
    A = temp0 and 0xFF
    //> and #%00011111           ;mask out bits again and store
    A = A and 0x1F
    //> sta $01
    memory[0x1] = A.toUByte()
    //> lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
    A = currentntaddrHigh
    //> bcs SetATHigh
    if (!(temp0 >= 0)) {
        //> eor #%00000100           ;otherwise invert d2
        A = A xor 0x04
    }
    //> SetATHigh:   and #%00000100           ;mask out all other bits
    A = A and 0x04
    //> ora #$23                 ;add $2300 to the high byte and store
    A = A or 0x23
    //> sta $00
    memory[0x0] = A.toUByte()
    //> lda $01                  ;get low byte - 4, divide by 4, add offset for
    A = memory[0x1].toInt()
    //> lsr                      ;attribute table and store
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> adc #$c0                 ;we should now have the appropriate block of
    temp1 = A + 0xC0 + if ((orig1 and 0x01) != 0) 1 else 0
    A = temp1 and 0xFF
    //> sta $01                  ;attribute table in our temp address
    memory[0x1] = A.toUByte()
    //> ldx #$00
    X = 0x00
    //> ldy VRAM_Buffer2_Offset  ;get buffer offset
    Y = vramBuffer2Offset
    loop0@ do {
        //> AttribLoop:  lda $00
        A = memory[0x0].toInt()
        //> sta VRAM_Buffer2,y       ;store high byte of attribute table address
        vramBuffer2[Y] = A
        //> lda $01
        A = memory[0x1].toInt()
        //> clc                      ;get low byte, add 8 because we want to start
        //> adc #$08                 ;below the status bar, and store
        temp2 = A + 0x08
        A = temp2 and 0xFF
        //> sta VRAM_Buffer2+1,y
        vramBuffer2[1 + Y] = A
        //> sta $01                  ;also store in temp again
        memory[0x1] = A.toUByte()
        //> lda AttributeBuffer,x    ;fetch current attribute table byte and store
        A = attributeBuffer[X]
        //> sta VRAM_Buffer2+3,y     ;in the buffer
        vramBuffer2[3 + Y] = A
        //> lda #$01
        A = 0x01
        //> sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
        vramBuffer2[2 + Y] = A
        //> lsr
        val orig2: Int = A
        A = orig2 shr 1
        //> sta AttributeBuffer,x    ;clear current byte in attribute buffer
        attributeBuffer[X] = A
        //> iny                      ;increment buffer offset by 4 bytes
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> inx                      ;increment attribute offset and check to see
        X = (X + 1) and 0xFF
        //> cpx #$07                 ;if we're at the end yet
        //> bcc AttribLoop
        if (!(X >= 0x07)) {
            //  continue loop (branch back to AttribLoop)
            continue@loop0
        }
    } while (!(X >= 0x07))
    //> sta VRAM_Buffer2,y       ;put null terminator at the end
    vramBuffer2[Y] = A
    //> sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
    vramBuffer2Offset = Y
    //  Fall-through tail call to setVRAMCtrl
    setVRAMCtrl()
    return
}

// Decompiled from SetVRAMCtrl
fun setVRAMCtrl() {
    var A: Int = 0
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> SetVRAMCtrl: lda #$06
    A = 0x06
    //> sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
    vramBufferAddrctrl = A
    //> rts
    return
}

// Decompiled from ColorRotation
fun colorRotation() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    var colorRotateOffset by MemoryByte(ColorRotateOffset)
    var frameCounter by MemoryByte(FrameCounter)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val blankPalette by MemoryByteIndexed(BlankPalette)
    val colorRotatePalette by MemoryByteIndexed(ColorRotatePalette)
    val palette3Data by MemoryByteIndexed(Palette3Data)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> ColorRotation:
    //> lda FrameCounter         ;get frame counter
    A = frameCounter
    //> and #$07                 ;mask out all but three LSB
    A = A and 0x07
    //> bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
    if (A == 0) {
        //> ldx VRAM_Buffer1_Offset  ;check vram buffer offset
        X = vramBuffer1Offset
        //> cpx #$31
        //> bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
        if (!(X >= 0x31)) {
            //> tay                      ;otherwise use frame counter's 3 LSB as offset here
            Y = A
            Y = Y
            loop0@ do {
                //> GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
                A = blankPalette[Y]
                //> sta VRAM_Buffer1,x       ;store it in the vram buffer
                vramBuffer1[X] = A
                //> inx                      ;increment offsets
                X = (X + 1) and 0xFF
                //> iny
                Y = (Y + 1) and 0xFF
                //> cpy #$08
                //> bcc GetBlankPal          ;do this until all bytes are copied
                if (!(Y >= 0x08)) {
                    //  continue loop (branch back to GetBlankPal)
                    continue@loop0
                }
            } while (!(Y >= 0x08))
            //> ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
            X = vramBuffer1Offset
            //> lda #$03
            A = 0x03
            //> sta $00                  ;set counter here
            memory[0x0] = A.toUByte()
            //> lda AreaType             ;get area type
            A = areaType
            //> asl                      ;multiply by 4 to get proper offset
            val orig0: Int = A
            A = (orig0 shl 1) and 0xFF
            //> asl
            val orig1: Int = A
            A = (orig1 shl 1) and 0xFF
            //> tay                      ;save as offset here
            Y = A
            loop1@ do {
                //> GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
                A = palette3Data[Y]
                //> sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
                vramBuffer1[3 + X] = A
                //> iny
                Y = (Y + 1) and 0xFF
                //> inx
                X = (X + 1) and 0xFF
                //> dec $00                  ;decrement counter
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bpl GetAreaPal           ;do this until the palette is all copied
                if (!((memory[0x0].toInt() and 0x80) != 0)) {
                    //  continue loop (branch back to GetAreaPal)
                    continue@loop1
                }
            } while ((memory[0x0].toInt() and 0x80) == 0)
            //> ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
            X = vramBuffer1Offset
            //> ldy ColorRotateOffset    ;get color cycling offset
            Y = colorRotateOffset
            //> lda ColorRotatePalette,y
            A = colorRotatePalette[Y]
            //> sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
            vramBuffer1[4 + X] = A
            //> lda VRAM_Buffer1_Offset
            A = vramBuffer1Offset
            //> clc                      ;add seven bytes to vram buffer offset
            //> adc #$07
            temp0 = A + 0x07
            A = temp0 and 0xFF
            //> sta VRAM_Buffer1_Offset
            vramBuffer1Offset = A
            //> inc ColorRotateOffset    ;increment color cycling offset
            colorRotateOffset = (colorRotateOffset + 1) and 0xFF
            //> lda ColorRotateOffset
            A = colorRotateOffset
            //> cmp #$06                 ;check to see if it's still in range
            //> bcc ExitColorRot         ;if so, branch to leave
            if (A >= 0x06) {
                //> lda #$00
                A = 0x00
                //> sta ColorRotateOffset    ;otherwise, init to keep it in range
                colorRotateOffset = A
            }
        }
    }
    //> ExitColorRot: rts                      ;leave
    return
}

// Decompiled from RemoveCoin_Axe
fun removecoinAxe() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> RemoveCoin_Axe:
    //> ldy #$41                 ;set low byte so offset points to $0341
    Y = 0x41
    //> lda #$03                 ;load offset for default blank metatile
    A = 0x03
    //> ldx AreaType             ;check area type
    X = areaType
    //> bne WriteBlankMT         ;if not water type, use offset
    if (X == 0) {
        //> lda #$04                 ;otherwise load offset for blank metatile used in water
        A = 0x04
    }
    //> WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
    temp0 = putBlockMetatile(A, X, Y)
    //> lda #$06
    A = 0x06
    //> sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
    vramBufferAddrctrl = A
    //> rts
    return
}

// Decompiled from ReplaceBlockMetatile
fun replaceBlockMetatile(A: Int, X: Int): Int {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var blockResidualcounter by MemoryByte(Block_ResidualCounter)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    //> ReplaceBlockMetatile:
    //> jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
    val pair0 = writeBlockMetatile(A, X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> inc Block_ResidualCounter ;increment unused counter (residual code)
    blockResidualcounter = (blockResidualcounter + 1) and 0xFF
    //> dec Block_RepFlag,x       ;decrement flag (residual code)
    blockRepflag[temp0] = (blockRepflag[temp0] - 1) and 0xFF
    //> rts                       ;leave
    return temp0
}

// Decompiled from DestroyBlockMetatile
fun destroyBlockMetatile(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    //> DestroyBlockMetatile:
    //> lda #$00       ;force blank metatile if branched/jumped to this point
    A = 0x00
    //  Fall-through tail call to writeBlockMetatile
    return writeBlockMetatile(A, X)
}

// Decompiled from WriteBlockMetatile
fun writeBlockMetatile(A: Int, X: Int): Pair<Int, Int> {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    //> WriteBlockMetatile:
    //> ldy #$03                ;load offset for blank metatile
    Y = 0x03
    //> cmp #$00                ;check contents of A for blank metatile
    //> beq UseBOffset          ;branch if found (unconditional if branched from 8a6b)
    A = A
    X = X
    if (A != 0x00) {
        //> ldy #$00                ;load offset for brick metatile w/ line
        Y = 0x00
        //> cmp #$58
        //> beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
        if (A != 0x58) {
            //> cmp #$51
            //> beq UseBOffset          ;use offset if metatile is breakable brick w/ line
            if (A != 0x51) {
                //> iny                     ;increment offset for brick metatile w/o line
                Y = (Y + 1) and 0xFF
                //> cmp #$5d
                //> beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
                if (A != 0x5D) {
                    //> cmp #$52
                    //> beq UseBOffset          ;use offset if metatile is breakable brick w/o line
                    if (A != 0x52) {
                        //> iny                     ;if any other metatile, increment offset for empty block
                        Y = (Y + 1) and 0xFF
                    }
                }
            }
        }
    }
    //> UseBOffset:  tya                     ;put Y in A
    A = Y
    //> ldy VRAM_Buffer1_Offset ;get vram buffer offset
    Y = vramBuffer1Offset
    //> iny                     ;move onto next byte
    Y = (Y + 1) and 0xFF
    //> jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
    temp0 = putBlockMetatile(A, X, Y)
    //  Fall-through tail call to moveVOffset
    moveVOffset(temp0)
    return Pair(X, Y)
}

// Decompiled from MoveVOffset
fun moveVOffset(Y: Int): Int {
    var A: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    //> MoveVOffset: dey                     ;decrement vram buffer offset
    Y = (Y - 1) and 0xFF
    //> tya                     ;add 10 bytes to it
    A = Y
    //> clc
    //> adc #10
    temp0 = A + 0x0A
    //> jmp SetVRAMOffset       ;branch to store as new vram buffer offset
    setVRAMOffset(temp0 and 0xFF)
    return Y
}

// Decompiled from PutBlockMetatile
fun putBlockMetatile(A: Int, X: Int, Y: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    //> PutBlockMetatile:
    //> stx $00               ;store control bit from SprDataOffset_Ctrl
    memory[0x0] = X.toUByte()
    //> sty $01               ;store vram buffer offset for next byte
    memory[0x1] = Y.toUByte()
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                   ;multiply A by four and use as X
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> tax
    X = A
    //> ldy #$20              ;load high byte for name table 0
    Y = 0x20
    //> lda $06               ;get low byte of block buffer pointer
    A = memory[0x6].toInt()
    //> cmp #$d0              ;check to see if we're on odd-page block buffer
    //> bcc SaveHAdder        ;if not, use current high byte
    X = X
    if (A >= 0xD0) {
        //> ldy #$24              ;otherwise load high byte for name table 1
        Y = 0x24
    }
    //> SaveHAdder: sty $03               ;save high byte here
    memory[0x3] = Y.toUByte()
    //> and #$0f              ;mask out high nybble of block buffer pointer
    A = A and 0x0F
    //> asl                   ;multiply by 2 to get appropriate name table low byte
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> sta $04               ;and then store it here
    memory[0x4] = A.toUByte()
    //> lda #$00
    A = 0x00
    //> sta $05               ;initialize temp high byte
    memory[0x5] = A.toUByte()
    //> lda $02               ;get vertical high nybble offset used in block buffer routine
    A = memory[0x2].toInt()
    //> clc
    //> adc #$20              ;add 32 pixels for the status bar
    temp0 = A + 0x20
    A = temp0 and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> rol $05               ;shift and rotate d7 onto d0 and d6 into carry
    memory[0x5] = (((memory[0x5].toInt() shl 1) and 0xFE or if ((orig3 and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
    //> asl
    val orig4: Int = A
    A = (orig4 shl 1) and 0xFF
    //> rol $05               ;shift and rotate d6 onto d0 and d5 into carry
    memory[0x5] = (((memory[0x5].toInt() shl 1) and 0xFE or if ((orig4 and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
    //> adc $04               ;add low byte of name table and carry to vertical high nybble
    temp1 = A + memory[0x4].toInt() + if ((memory[0x5].toInt() and 0x80) != 0) 1 else 0
    A = temp1 and 0xFF
    //> sta $04               ;and store here
    memory[0x4] = A.toUByte()
    //> lda $05               ;get whatever was in d7 and d6 of vertical high nybble
    A = memory[0x5].toInt()
    //> adc #$00              ;add carry
    temp2 = A + if (temp1 > 0xFF) 1 else 0
    A = temp2 and 0xFF
    //> clc
    //> adc $03               ;then add high byte of name table
    temp3 = A + memory[0x3].toInt()
    A = temp3 and 0xFF
    //> sta $05               ;store here
    memory[0x5] = A.toUByte()
    //> ldy $01               ;get vram buffer offset to be used
    Y = memory[0x1].toInt()
    //  Fall-through tail call to remBridge
    remBridge(X, Y)
    return Y
}

// Decompiled from RemBridge
fun remBridge(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    val blockGfxData by MemoryByteIndexed(BlockGfxData)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> RemBridge:  lda BlockGfxData,x    ;write top left and top right
    A = blockGfxData[X]
    //> sta VRAM_Buffer1+2,y  ;tile numbers into first spot
    vramBuffer1[2 + Y] = A
    //> lda BlockGfxData+1,x
    A = blockGfxData[1 + X]
    //> sta VRAM_Buffer1+3,y
    vramBuffer1[3 + Y] = A
    //> lda BlockGfxData+2,x  ;write bottom left and bottom
    A = blockGfxData[2 + X]
    //> sta VRAM_Buffer1+7,y  ;right tiles numbers into
    vramBuffer1[7 + Y] = A
    //> lda BlockGfxData+3,x  ;second spot
    A = blockGfxData[3 + X]
    //> sta VRAM_Buffer1+8,y
    vramBuffer1[8 + Y] = A
    //> lda $04
    A = memory[0x4].toInt()
    //> sta VRAM_Buffer1,y    ;write low byte of name table
    vramBuffer1[Y] = A
    //> clc                   ;into first slot as read
    //> adc #$20              ;add 32 bytes to value
    temp0 = A + 0x20
    A = temp0 and 0xFF
    //> sta VRAM_Buffer1+5,y  ;write low byte of name table
    vramBuffer1[5 + Y] = A
    //> lda $05               ;plus 32 bytes into second slot
    A = memory[0x5].toInt()
    //> sta VRAM_Buffer1-1,y  ;write high byte of name
    vramBuffer1[-1 + Y] = A
    //> sta VRAM_Buffer1+4,y  ;table address to both slots
    vramBuffer1[4 + Y] = A
    //> lda #$02
    A = 0x02
    //> sta VRAM_Buffer1+1,y  ;put length of 2 in
    vramBuffer1[1 + Y] = A
    //> sta VRAM_Buffer1+6,y  ;both slots
    vramBuffer1[6 + Y] = A
    //> lda #$00
    A = 0x00
    //> sta VRAM_Buffer1+9,y  ;put null terminator at end
    vramBuffer1[9 + Y] = A
    //> ldx $00               ;get offset control bit here
    X = memory[0x0].toInt()
    //> rts                   ;and leave
    return
}

// Decompiled from JumpEngine
fun jumpEngine(A: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    //> JumpEngine:
    //> asl          ;shift bit from contents of A
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> tay
    Y = A
    //> pla          ;pull saved return address from stack
    temp0 = pull()
    //> sta $04      ;save to indirect
    memory[0x4] = temp0.toUByte()
    //> pla
    temp1 = pull()
    //> sta $05
    memory[0x5] = temp1.toUByte()
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda ($04),y  ;load pointer from indirect
    A = memory[readWord(0x4) + Y].toInt()
    //> sta $06      ;note that if an RTS is performed in next routine
    memory[0x6] = A.toUByte()
    //> iny          ;it will return to the execution before the sub
    Y = (Y + 1) and 0xFF
    //> lda ($04),y  ;that called this routine
    A = memory[readWord(0x4) + Y].toInt()
    //> sta $07
    memory[0x7] = A.toUByte()
    //> jmp ($06)    ;jump to the address we loaded
    //> jmp ($06) - indirect jump
}

// Decompiled from InitializeNameTables
fun initializeNameTables() {
    var A: Int = 0
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    val ppuStatus by MemoryByteIndexed(PPU_STATUS)
    //> InitializeNameTables:
    //> lda PPU_STATUS            ;reset flip-flop
    A = ppuStatus[0]
    //> lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
    A = mirrorPpuCtrlReg1
    //> ora #%00010000            ;set sprites for first 4k and background for second 4k
    A = A or 0x10
    //> and #%11110000            ;clear rest of lower nybble, leave higher alone
    A = A and 0xF0
    //> jsr WritePPUReg1
    writePPUReg1(A)
    //> lda #$24                  ;set vram address to start of name table 1
    A = 0x24
    //> jsr WriteNTAddr
    writeNTAddr(A)
    //> lda #$20                  ;and then set it to name table 0
    A = 0x20
    //  Fall-through tail call to writeNTAddr
    writeNTAddr(A)
    return
}

// Decompiled from WriteNTAddr
fun writeNTAddr(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var horizontalScroll by MemoryByte(HorizontalScroll)
    var ppuAddress by MemoryByte(PPU_ADDRESS)
    var ppuData by MemoryByte(PPU_DATA)
    var vramBuffer1 by MemoryByte(VRAM_Buffer1)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    var verticalScroll by MemoryByte(VerticalScroll)
    //> WriteNTAddr:  sta PPU_ADDRESS
    ppuAddress = A
    //> lda #$00
    A = 0x00
    //> sta PPU_ADDRESS
    ppuAddress = A
    //> ldx #$04                  ;clear name table with blank tile #24
    X = 0x04
    //> ldy #$c0
    Y = 0xC0
    //> lda #$24
    A = 0x24
    loop0@ do {
        loop1@ do {
            //> InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
            ppuData = A
            //> dey
            Y = (Y - 1) and 0xFF
            //> bne InitNTLoop
            if (!(Y == 0)) {
                //  continue loop (branch back to InitNTLoop)
                continue@loop1
            }
        } while (Y != 0)
        //> dex
        X = (X - 1) and 0xFF
        //> bne InitNTLoop
        if (!(X == 0)) {
            //  continue loop (branch back to InitNTLoop)
            continue@loop0
        }
    } while (X != 0)
    //> ldy #64                   ;now to clear the attribute table (with zero this time)
    Y = 0x40
    //> txa
    A = X
    //> sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
    vramBuffer1Offset = A
    //> sta VRAM_Buffer1          ;init vram buffer 1
    vramBuffer1 = A
    loop2@ do {
        //> InitATLoop:   sta PPU_DATA
        ppuData = A
        //> dey
        Y = (Y - 1) and 0xFF
        //> bne InitATLoop
        if (!(Y == 0)) {
            //  continue loop (branch back to InitATLoop)
            continue@loop2
        }
    } while (Y != 0)
    //> sta HorizontalScroll      ;reset scroll variables
    horizontalScroll = A
    //> sta VerticalScroll
    verticalScroll = A
    //> jmp InitScroll            ;initialize scroll registers to zero
    initScroll(A)
    return
}

// Decompiled from ReadJoypads
fun readJoypads(): Int {
    var A: Int = 0
    var X: Int = 0
    var temp0: Int = 0
    var joypadPort by MemoryByte(JOYPAD_PORT)
    //> ReadJoypads:
    //> lda #$01               ;reset and clear strobe of joypad ports
    A = 0x01
    //> sta JOYPAD_PORT
    joypadPort = A
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> tax                    ;start with joypad 1's port
    X = A
    //> sta JOYPAD_PORT
    joypadPort = A
    //> jsr ReadPortBits
    temp0 = readPortBits(A, X)
    //> inx                    ;increment for joypad 2's port
    X = (X + 1) and 0xFF
    //  Fall-through tail call to readPortBits
    return readPortBits(temp0, X)
}

// Decompiled from ReadPortBits
fun readPortBits(A: Int, X: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    val joypadPort by MemoryByteIndexed(JOYPAD_PORT)
    val joypadBitMask by MemoryByteIndexed(JoypadBitMask)
    val savedJoypadBits by MemoryByteIndexed(SavedJoypadBits)
    //> ReadPortBits: ldy #$08
    Y = 0x08
    X = X
    loop0@ do {
        //> PortLoop:     pha                    ;push previous bit onto stack
        push(A)
        //> lda JOYPAD_PORT,x      ;read current bit on joypad port
        A = joypadPort[X]
        //> sta $00                ;check d1 and d0 of port output
        memory[0x0] = A.toUByte()
        //> lsr                    ;this is necessary on the old
        val orig0: Int = A
        A = orig0 shr 1
        //> ora $00                ;famicom systems in japan
        A = A or memory[0x0].toInt()
        //> lsr
        val orig1: Int = A
        A = orig1 shr 1
        //> pla                    ;read bits from stack
        A = pull()
        //> rol                    ;rotate bit from carry flag
        val orig2: Int = A
        A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x01) != 0) 1 else 0
        //> dey
        Y = (Y - 1) and 0xFF
        //> bne PortLoop           ;count down bits left
        if (!(Y == 0)) {
            //  continue loop (branch back to PortLoop)
            continue@loop0
        }
    } while (Y != 0)
    //> sta SavedJoypadBits,x  ;save controller status here always
    savedJoypadBits[X] = A
    //> pha
    push(A)
    //> and #%00110000         ;check for select or start
    A = A and 0x30
    //> and JoypadBitMask,x    ;if neither saved state nor current state
    A = A and joypadBitMask[X]
    //> beq Save8Bits          ;have any of these two set, branch
    if (A != 0) {
        //> pla
        A = pull()
        //> and #%11001111         ;otherwise store without select
        A = A and 0xCF
        //> sta SavedJoypadBits,x  ;or start bits and leave
        savedJoypadBits[X] = A
        //> rts
        return A
    } else {
        //> Save8Bits:    pla
        A = pull()
        //> sta JoypadBitMask,x    ;save with all bits in another place and leave
        joypadBitMask[X] = A
        //> rts
        return A
    }
}

// Decompiled from UpdateScreen
fun updateScreen() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var ppuAddress by MemoryByte(PPU_ADDRESS)
    var ppuData by MemoryByte(PPU_DATA)
    val ppuStatus by MemoryByteIndexed(PPU_STATUS)
    loop0@ while (!true /* unknown branch STA */) {
        //> WriteBufferToScreen:
        //> sta PPU_ADDRESS           ;store high byte of vram address
        ppuAddress = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> lda ($00),y               ;load next byte (second)
        A = memory[readWord(0x0) + Y].toInt()
        //> sta PPU_ADDRESS           ;store low byte of vram address
        ppuAddress = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> lda ($00),y               ;load next byte (third)
        A = memory[readWord(0x0) + Y].toInt()
        //> asl                       ;shift to left and save in stack
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> pha
        push(A)
        //> lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
        A = mirrorPpuCtrlReg1
        //> ora #%00000100            ;set ppu to increment by 32 by default
        A = A or 0x04
        //> bcs SetupWrites           ;if d7 of third byte was clear, ppu will
        if ((orig0 and 0x80) == 0) {
            //> and #%11111011            ;only increment by 1
            A = A and 0xFB
        }
        //> SetupWrites:   jsr WritePPUReg1          ;write to register
        writePPUReg1(A)
        //> pla                       ;pull from stack and shift to left again
        A = pull()
        //> asl
        val orig1: Int = A
        A = (orig1 shl 1) and 0xFF
        //> bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
        if ((orig1 and 0x80) != 0) {
            //> ora #%00000010            ;otherwise set d1 and increment Y
            A = A or 0x02
            //> iny
            Y = (Y + 1) and 0xFF
        }
        //> GetLength:     lsr                       ;shift back to the right to get proper length
        val orig2: Int = A
        A = orig2 shr 1
        //> lsr                       ;note that d1 will now be in carry
        val orig3: Int = A
        A = orig3 shr 1
        //> tax
        X = A
        X = X
        loop1@ do {
            //> OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
            if ((orig3 and 0x01) == 0) {
                //> iny                       ;otherwise increment Y to load next byte
                Y = (Y + 1) and 0xFF
            }
            //> RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
            A = memory[readWord(0x0) + Y].toInt()
            //> sta PPU_DATA
            ppuData = A
            //> dex                       ;done writing?
            X = (X - 1) and 0xFF
            //> bne OutputToVRAM
            if (!(X == 0)) {
                //  continue loop (branch back to OutputToVRAM)
                continue@loop1
            }
        } while (X != 0)
        //> sec
        //> tya
        A = Y
        //> adc $00                   ;add end length plus one to the indirect at $00
        temp0 = A + memory[0x0].toInt() + 1
        A = temp0 and 0xFF
        //> sta $00                   ;to allow this routine to read another set of updates
        memory[0x0] = A.toUByte()
        //> lda #$00
        A = 0x00
        //> adc $01
        temp1 = A + memory[0x1].toInt() + if (temp0 > 0xFF) 1 else 0
        A = temp1 and 0xFF
        //> sta $01
        memory[0x1] = A.toUByte()
        //> lda #$3f                  ;sets vram address to $3f00
        A = 0x3F
        //> sta PPU_ADDRESS
        ppuAddress = A
        //> lda #$00
        A = 0x00
        //> sta PPU_ADDRESS
        ppuAddress = A
        //> sta PPU_ADDRESS           ;then reinitializes it for some reason
        ppuAddress = A
        //> sta PPU_ADDRESS
        ppuAddress = A
    }
    // Fall-through tail call to initScroll
    initScroll(A)
    return
}

// Decompiled from InitScroll
fun initScroll(A: Int) {
    var ppuScrollReg by MemoryByte(PPU_SCROLL_REG)
    //> InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
    ppuScrollReg = A
    //> sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
    ppuScrollReg = A
    //> rts
    return
}

// Decompiled from WritePPUReg1
fun writePPUReg1(A: Int) {
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var ppuCtrlReg1 by MemoryByte(PPU_CTRL_REG1)
    //> WritePPUReg1:
    //> sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
    ppuCtrlReg1 = A
    //> sta Mirror_PPU_CTRL_REG1  ;and its mirror
    mirrorPpuCtrlReg1 = A
    //> rts
    return
}

// Decompiled from PrintStatusBarNumbers
fun printStatusBarNumbers(A: Int) {
    var A: Int = A
    //> PrintStatusBarNumbers:
    //> sta $00            ;store player-specific offset
    memory[0x0] = A.toUByte()
    //> jsr OutputNumbers  ;use first nybble to print the coin display
    outputNumbers(A)
    //> lda $00            ;move high nybble to low
    A = memory[0x0].toInt()
    //> lsr                ;and print to score display
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> lsr
    val orig3: Int = A
    A = orig3 shr 1
    //  Fall-through tail call to outputNumbers
    outputNumbers(A)
    return
}

// Decompiled from OutputNumbers
fun outputNumbers(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val displayDigits by MemoryByteIndexed(DisplayDigits)
    val statusBarData by MemoryByteIndexed(StatusBarData)
    val statusBarOffset by MemoryByteIndexed(StatusBarOffset)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> OutputNumbers:
    //> clc                      ;add 1 to low nybble
    //> adc #$01
    temp0 = A + 0x01
    //> and #%00001111           ;mask out high nybble
    temp1 = temp0 and 0xFF and 0x0F
    //> cmp #$06
    //> bcs ExitOutputN
    A = temp1
    if (!(temp1 >= 0x06)) {
        //> pha                      ;save incremented value to stack for now and
        push(A)
        //> asl                      ;shift to left and use as offset
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> tay
        Y = A
        //> ldx VRAM_Buffer1_Offset  ;get current buffer pointer
        X = vramBuffer1Offset
        //> lda #$20                 ;put at top of screen by default
        A = 0x20
        //> cpy #$00                 ;are we writing top score on title screen?
        //> bne SetupNums
        Y = Y
        if (Y == 0x00) {
            //> lda #$22                 ;if so, put further down on the screen
            A = 0x22
        }
        //> SetupNums:   sta VRAM_Buffer1,x
        vramBuffer1[X] = A
        //> lda StatusBarData,y      ;write low vram address and length of thing
        A = statusBarData[Y]
        //> sta VRAM_Buffer1+1,x     ;we're printing to the buffer
        vramBuffer1[1 + X] = A
        //> lda StatusBarData+1,y
        A = statusBarData[1 + Y]
        //> sta VRAM_Buffer1+2,x
        vramBuffer1[2 + X] = A
        //> sta $03                  ;save length byte in counter
        memory[0x3] = A.toUByte()
        //> stx $02                  ;and buffer pointer elsewhere for now
        memory[0x2] = X.toUByte()
        //> pla                      ;pull original incremented value from stack
        A = pull()
        //> tax
        X = A
        //> lda StatusBarOffset,x    ;load offset to value we want to write
        A = statusBarOffset[X]
        //> sec
        //> sbc StatusBarData+1,y    ;subtract from length byte we read before
        temp2 = A - statusBarData[1 + Y]
        A = temp2 and 0xFF
        //> tay                      ;use value as offset to display digits
        Y = A
        //> ldx $02
        X = memory[0x2].toInt()
        loop0@ do {
            //> DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
            A = displayDigits[Y]
            //> sta VRAM_Buffer1+3,x
            vramBuffer1[3 + X] = A
            //> inx
            X = (X + 1) and 0xFF
            //> iny
            Y = (Y + 1) and 0xFF
            //> dec $03                  ;do this until all the digits are written
            memory[0x3] = ((memory[0x3].toInt() - 1) and 0xFF).toUByte()
            //> bne DigitPLoop
            if (!(memory[0x3].toInt() == 0)) {
                //  continue loop (branch back to DigitPLoop)
                continue@loop0
            }
        } while (memory[0x3].toInt() != 0)
        //> lda #$00                 ;put null terminator at end
        A = 0x00
        //> sta VRAM_Buffer1+3,x
        vramBuffer1[3 + X] = A
        //> inx                      ;increment buffer pointer by 3
        X = (X + 1) and 0xFF
        //> inx
        X = (X + 1) and 0xFF
        //> inx
        X = (X + 1) and 0xFF
        //> stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
        vramBuffer1Offset = X
    }
    //> ExitOutputN: rts
    return
}

// Decompiled from DigitsMathRoutine
fun digitsMathRoutine(Y: Int) {
    var A: Int = 0
    var X: Int = 0
    var operMode by MemoryByte(OperMode)
    //> DigitsMathRoutine:
    //> lda OperMode              ;check mode of operation
    A = operMode
    //> cmp #TitleScreenModeValue
    //> beq EraseDMods            ;if in title screen mode, branch to lock score
    if (A == TitleScreenModeValue) {
        //  goto EraseDMods -> eraseDMods
        eraseDMods()
        return
    } else {
        //> ldx #$05
        X = 0x05
        //  Fall-through tail call to addModLoop
        addModLoop(X, Y)
        return
    }
}

// Decompiled from AddModLoop
fun addModLoop(X: Int, Y: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val displayDigits by MemoryByteIndexed(DisplayDigits)
    //> AddModLoop: lda DigitModifier,x       ;load digit amount to increment
    A = digitModifier[X]
    //> clc
    //> adc DisplayDigits,y       ;add to current digit
    temp0 = A + displayDigits[Y]
    A = temp0 and 0xFF
    //> bmi BorrowOne             ;if result is a negative number, branch to subtract
    if ((temp0 and 0xFF and 0x80) != 0) {
        //  goto BorrowOne -> borrowOne
        borrowOne(X, Y)
        return
    }
    //  Fall-through tail call to func_2591
    func_2591(A, X, Y)
    return
}

// Decompiled from @2591
fun func_2591(A: Int, X: Int, Y: Int) {
    //> cmp #10
    //> bcs CarryOne              ;if digit greater than $09, branch to add
    if (A >= 0x0A) {
        //  goto CarryOne -> carryOne
        carryOne(A, X, Y)
        return
    }
    //  Fall-through tail call to storeNewD
    storeNewD(A, X, Y)
    return
}

// Decompiled from StoreNewD
fun storeNewD(A: Int, X: Int, Y: Int) {
    var X: Int = X
    var Y: Int = Y
    val displayDigits by MemoryByteIndexed(DisplayDigits)
    //> StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
    displayDigits[Y] = A
    //> dey                       ;move onto next digits in score or game timer
    Y = (Y - 1) and 0xFF
    //> dex                       ;and digit amounts to increment
    X = (X - 1) and 0xFF
    //> bpl AddModLoop            ;loop back if we're not done yet
    if (!((X and 0x80) != 0)) {
        //  goto AddModLoop -> addModLoop
        addModLoop(X, Y)
        return
    }
    //  Fall-through tail call to eraseDMods
    eraseDMods()
    return
}

// Decompiled from EraseDMods
fun eraseDMods() {
    var A: Int = 0
    var X: Int = 0
    //> EraseDMods: lda #$00                  ;store zero here
    A = 0x00
    //> ldx #$06                  ;start with the last digit
    X = 0x06
    //  Fall-through tail call to eraseMLoop
    eraseMLoop(A, X)
    return
}

// Decompiled from EraseMLoop
fun eraseMLoop(A: Int, X: Int) {
    var X: Int = X
    val digitModifier by MemoryByteIndexed(DigitModifier)
    X = X
    loop0@ do {
        //> EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
        digitModifier[-1 + X] = A
        //> dex
        X = (X - 1) and 0xFF
        //> bpl EraseMLoop            ;do this until they're all reset, then leave
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to EraseMLoop)
            continue@loop0
        }
        //  Fall-through tail call to func_2602
        func_2602()
        return
    } while ((X and 0x80) == 0)
    // Fall-through tail call to func_2602
    func_2602()
    return
}

// Decompiled from @2602
fun func_2602() {
    //> rts
    return
}

// Decompiled from BorrowOne
fun borrowOne(X: Int, Y: Int) {
    var A: Int = 0
    val digitModifier by MemoryByteIndexed(DigitModifier)
    //> BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
    digitModifier[-1 + X] = (digitModifier[-1 + X] - 1) and 0xFF
    //> lda #$09                  ;the game timer digit we're currently on to "borrow
    A = 0x09
    //> bne StoreNewD             ;the one", then do an unconditional branch back
    if (!(A == 0)) {
        //  goto StoreNewD -> storeNewD
        storeNewD(A, X, Y)
        return
    }
    //  Fall-through tail call to carryOne
    carryOne(A, X, Y)
    return
}

// Decompiled from CarryOne
fun carryOne(A: Int, X: Int, Y: Int) {
    var temp0: Int = 0
    val digitModifier by MemoryByteIndexed(DigitModifier)
    //> CarryOne:   sec                       ;subtract ten from our digit to make it a
    //> sbc #10                   ;proper BCD number, then increment the digit
    temp0 = A - 0x0A
    //> inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
    digitModifier[-1 + X] = (digitModifier[-1 + X] + 1) and 0xFF
    //> jmp StoreNewD             ;go back to just after we branched here
    storeNewD(temp0 and 0xFF, X, Y)
    return
}

// Decompiled from UpdateTopScore
fun updateTopScore() {
    var X: Int = 0
    //> UpdateTopScore:
    //> ldx #$05          ;start with mario's score
    X = 0x05
    //> jsr TopScoreCheck
    topScoreCheck(X)
    //> ldx #$0b          ;now do luigi's score
    X = 0x0B
    //  Fall-through tail call to topScoreCheck
    topScoreCheck(X)
    return
}

// Decompiled from TopScoreCheck
fun topScoreCheck(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    val playerScoreDisplay by MemoryByteIndexed(PlayerScoreDisplay)
    val topScoreDisplay by MemoryByteIndexed(TopScoreDisplay)
    //> TopScoreCheck:
    //> ldy #$05                 ;start with the lowest digit
    Y = 0x05
    //> sec
    X = X
    loop0@ do {
        //> GetScoreDiff: lda PlayerScoreDisplay,x ;subtract each player digit from each high score digit
        A = playerScoreDisplay[X]
        //> sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
        temp0 = A - topScoreDisplay[Y]
        A = temp0 and 0xFF
        //> dex                      ;any player digit, borrow will be set until a subsequent
        X = (X - 1) and 0xFF
        //> dey                      ;subtraction clears it (player digit is higher than top)
        Y = (Y - 1) and 0xFF
        //> bpl GetScoreDiff
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to GetScoreDiff)
            continue@loop0
        }
    } while ((Y and 0x80) == 0)
    //> bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
    if (temp0 >= 0) {
        //> inx                      ;increment X and Y once to the start of the score
        X = (X + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        loop1@ do {
            //> CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
            A = playerScoreDisplay[X]
            //> sta TopScoreDisplay,y
            topScoreDisplay[Y] = A
            //> inx
            X = (X + 1) and 0xFF
            //> iny
            Y = (Y + 1) and 0xFF
            //> cpy #$06                 ;do this until we have stored them all
            //> bcc CopyScore
            if (!(Y >= 0x06)) {
                //  continue loop (branch back to CopyScore)
                continue@loop1
            }
        } while (!(Y >= 0x06))
    }
    //> NoTopSc:      rts
    return
}

// Decompiled from InitializeGame
fun initializeGame(A: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var demoTimer by MemoryByte(DemoTimer)
    val soundMemory by MemoryByteIndexed(SoundMemory)
    //> InitializeGame:
    //> ldy #$6f              ;clear all memory as in initialization procedure,
    Y = 0x6F
    //> jsr InitializeMemory  ;but this time, clear only as far as $076f
    temp0 = initializeMemory(Y)
    //> ldy #$1f
    Y = 0x1F
    loop0@ do {
        //> ClrSndLoop:  sta SoundMemory,y     ;clear out memory used
        soundMemory[Y] = temp0
        //> dey                   ;by the sound engines
        Y = (Y - 1) and 0xFF
        //> bpl ClrSndLoop
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to ClrSndLoop)
            continue@loop0
        }
    } while ((Y and 0x80) == 0)
    //> lda #$18              ;set demo timer
    A = 0x18
    //> sta DemoTimer
    demoTimer = A
    //> jsr LoadAreaPointer
    temp1 = loadAreaPointer(A)
    //> ; @FRAMES_CONSUMED: 2
    //> ; This routine takes ~34,700 cycles (about 2 frames worth). When called during NMI,
    //> ; the next frame will not receive NMI (frame is consumed without input).
    //  Fall-through tail call to initializeArea
    initializeArea()
    return
}

// Decompiled from InitializeArea
fun initializeArea() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var blockBufferColumnPos by MemoryByte(BlockBufferColumnPos)
    var columnSets by MemoryByte(ColumnSets)
    var currentntaddrHigh by MemoryByte(CurrentNTAddr_High)
    var currentntaddrLow by MemoryByte(CurrentNTAddr_Low)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var entrancePage by MemoryByte(EntrancePage)
    var halfwayPage by MemoryByte(HalfwayPage)
    var levelNumber by MemoryByte(LevelNumber)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var worldNumber by MemoryByte(WorldNumber)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val timers by MemoryByteIndexed(Timers)
    //> InitializeArea:
    //> ldy #$4b                 ;clear all memory again, only as far as $074b
    Y = 0x4B
    //> jsr InitializeMemory     ;this is only necessary if branching from
    temp0 = initializeMemory(Y)
    //> ldx #$21
    X = 0x21
    //> lda #$00
    A = 0x00
    loop0@ do {
        //> ClrTimersLoop: sta Timers,x             ;clear out memory between
        timers[X] = A
        //> dex                      ;$0780 and $07a1
        X = (X - 1) and 0xFF
        //> bpl ClrTimersLoop
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to ClrTimersLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> lda HalfwayPage
    A = halfwayPage
    //> ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
    Y = altEntranceControl
    //> beq StartPage
    if (Y != 0) {
        //> lda EntrancePage         ;otherwise use saved entry page number here
        A = entrancePage
    }
    //> StartPage:     sta ScreenLeft_PageLoc   ;set as value here
    screenleftPageloc = A
    //> sta CurrentPageLoc       ;also set as current page
    currentPageLoc = A
    //> sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
    backloadingFlag = A
    //> jsr GetScreenPosition    ;get pixel coordinates for screen borders
    temp1 = getScreenPosition()
    //> ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
    Y = 0x20
    //> and #%00000001           ;otherwise use $2080, this address used later as name table
    A = temp1 and 0x01
    //> beq SetInitNTHigh        ;address for rendering of game area
    if (A != 0) {
        //> ldy #$24
        Y = 0x24
    }
    //> SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
    currentntaddrHigh = Y
    //> ldy #$80
    Y = 0x80
    //> sty CurrentNTAddr_Low
    currentntaddrLow = Y
    //> asl                      ;store LSB of page number in high nybble
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                      ;of block buffer column position
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> sta BlockBufferColumnPos
    blockBufferColumnPos = A
    //> dec AreaObjectLength     ;set area object lengths for all empty
    areaObjectLength[0] = (areaObjectLength[0] - 1) and 0xFF
    //> dec AreaObjectLength+1
    areaObjectLength[1] = (areaObjectLength[1] - 1) and 0xFF
    //> dec AreaObjectLength+2
    areaObjectLength[2] = (areaObjectLength[2] - 1) and 0xFF
    //> lda #$0b                 ;set value for renderer to update 12 column sets
    A = 0x0B
    //> sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
    columnSets = A
    //> jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
    getAreaDataAddrs()
    //> lda PrimaryHardMode      ;check to see if primary hard mode has been activated
    A = primaryHardMode
    //> bne SetSecHard           ;if so, activate the secondary no matter where we're at
    if (A == 0) {
        //> lda WorldNumber          ;otherwise check world number
        A = worldNumber
        //> cmp #World5              ;if less than 5, do not activate secondary
        //> bcc CheckHalfway
        if (A >= World5) {
            //> bne SetSecHard           ;if not equal to, then world > 5, thus activate
            if (A == World5) {
                //> lda LevelNumber          ;otherwise, world 5, so check level number
                A = levelNumber
                //> cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
                //> bcc CheckHalfway
                if (!(A >= Level3)) {
                    //  goto CheckHalfway (internal forward branch)
                    //> CheckHalfway:  lda HalfwayPage
                    A = halfwayPage
                    //> beq DoneInitArea
                    if (A == 0) {
                        //  goto DoneInitArea (internal forward branch)
                        //> DoneInitArea:  lda #Silence             ;silence music
                        A = Silence
                        //> sta AreaMusicQueue
                        areaMusicQueue = A
                        //> lda #$01                 ;disable screen output
                        A = 0x01
                        //> sta DisableScreenFlag
                        disableScreenFlag = A
                        //> inc OperMode_Task        ;increment one of the modes
                        opermodeTask = (opermodeTask + 1) and 0xFF
                        //> rts
                        return
                    }
                    //> lda #$02                 ;if halfway page set, overwrite start position from header
                    A = 0x02
                    //> sta PlayerEntranceCtrl
                    playerEntranceCtrl = A
                    return
                }
            }
        }
    }
    //> SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 5-3 and beyond
    secondaryHardMode = (secondaryHardMode + 1) and 0xFF
    //> CheckHalfway:  lda HalfwayPage
    A = halfwayPage
    //> beq DoneInitArea
    if (A != 0) {
        //> lda #$02                 ;if halfway page set, overwrite start position from header
        A = 0x02
        //> sta PlayerEntranceCtrl
        playerEntranceCtrl = A
    }
    //> DoneInitArea:  lda #Silence             ;silence music
    A = Silence
    //> sta AreaMusicQueue
    areaMusicQueue = A
    //> lda #$01                 ;disable screen output
    A = 0x01
    //> sta DisableScreenFlag
    disableScreenFlag = A
    //> inc OperMode_Task        ;increment one of the modes
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from PrimaryGameSetup
fun primaryGameSetup() {
    var A: Int = 0
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var numberofLives by MemoryByte(NumberofLives)
    var offscrNumberoflives by MemoryByte(OffScr_NumberofLives)
    var playerSize by MemoryByte(PlayerSize)
    //> PrimaryGameSetup:
    //> lda #$01
    A = 0x01
    //> sta FetchNewGameTimerFlag   ;set flag to load game timer from header
    fetchNewGameTimerFlag = A
    //> sta PlayerSize              ;set player's size to small
    playerSize = A
    //> lda #$02
    A = 0x02
    //> sta NumberofLives           ;give each player three lives
    numberofLives = A
    //> sta OffScr_NumberofLives
    offscrNumberoflives = A
    //  Fall-through tail call to secondaryGameSetup
    secondaryGameSetup()
    return
}

// Decompiled from SecondaryGameSetup
fun secondaryGameSetup() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var balPlatformAlignment by MemoryByte(BalPlatformAlignment)
    var disableIntermediate by MemoryByte(DisableIntermediate)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    val defaultSprOffsets by MemoryByteIndexed(DefaultSprOffsets)
    val sprDataOffset by MemoryByteIndexed(SprDataOffset)
    val sprShuffleAmt by MemoryByteIndexed(SprShuffleAmt)
    val sprite0Data by MemoryByteIndexed(Sprite0Data)
    val spriteData by MemoryByteIndexed(Sprite_Data)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> SecondaryGameSetup:
    //> lda #$00
    A = 0x00
    //> sta DisableScreenFlag     ;enable screen output
    disableScreenFlag = A
    //> tay
    Y = A
    Y = Y
    loop0@ do {
        //> ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
        vramBuffer1[-1 + Y] = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> bne ClearVRLoop
        if (!(Y == 0)) {
            //  continue loop (branch back to ClearVRLoop)
            continue@loop0
        }
    } while (Y != 0)
    //> sta GameTimerExpiredFlag  ;clear game timer exp flag
    gameTimerExpiredFlag = A
    //> sta DisableIntermediate   ;clear skip lives display flag
    disableIntermediate = A
    //> sta BackloadingFlag       ;clear value here
    backloadingFlag = A
    //> lda #$ff
    A = 0xFF
    //> sta BalPlatformAlignment  ;initialize balance platform assignment flag
    balPlatformAlignment = A
    //> lda ScreenLeft_PageLoc    ;get left side page location
    A = screenleftPageloc
    //> lsr Mirror_PPU_CTRL_REG1  ;shift LSB of ppu register #1 mirror out
    val orig0: Int = mirrorPpuCtrlReg1
    val carryFromLsr1: Boolean = (orig0 and 0x01) != 0
    mirrorPpuCtrlReg1 = orig0 shr 1
    //> and #$01                  ;mask out all but LSB of page location
    A = A and 0x01
    //> ror                       ;rotate LSB of page location into carry then onto mirror
    val orig2: Int = A
    A = orig2 shr 1 or if (carryFromLsr1) 0x80 else 0
    //> rol Mirror_PPU_CTRL_REG1  ;this is to set the proper PPU name table
    mirrorPpuCtrlReg1 = (mirrorPpuCtrlReg1 shl 1) and 0xFE or if ((orig2 and 0x01) != 0) 1 else 0
    //> jsr GetAreaMusic          ;load proper music into queue
    getAreaMusic()
    //> lda #$38                  ;load sprite shuffle amounts to be used later
    A = 0x38
    //> sta SprShuffleAmt+2
    sprShuffleAmt[2] = A
    //> lda #$48
    A = 0x48
    //> sta SprShuffleAmt+1
    sprShuffleAmt[1] = A
    //> lda #$58
    A = 0x58
    //> sta SprShuffleAmt
    sprShuffleAmt[0] = A
    //> ldx #$0e                  ;load default OAM offsets into $06e4-$06f2
    X = 0x0E
    loop1@ do {
        //> ShufAmtLoop: lda DefaultSprOffsets,x
        A = defaultSprOffsets[X]
        //> sta SprDataOffset,x
        sprDataOffset[X] = A
        //> dex                       ;do this until they're all set
        X = (X - 1) and 0xFF
        //> bpl ShufAmtLoop
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to ShufAmtLoop)
            continue@loop1
        }
    } while ((X and 0x80) == 0)
    //> ldy #$03                  ;set up sprite #0
    Y = 0x03
    loop2@ do {
        //> ISpr0Loop:   lda Sprite0Data,y
        A = sprite0Data[Y]
        //> sta Sprite_Data,y
        spriteData[Y] = A
        //> dey
        Y = (Y - 1) and 0xFF
        //> bpl ISpr0Loop
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to ISpr0Loop)
            continue@loop2
        }
    } while ((Y and 0x80) == 0)
    //> jsr DoNothing2            ;these jsrs doesn't do anything useful
    doNothing2()
    //> jsr DoNothing1
    doNothing1()
    //> inc Sprite0HitDetectFlag  ;set sprite #0 check flag
    sprite0HitDetectFlag = (sprite0HitDetectFlag + 1) and 0xFF
    //> inc OperMode_Task         ;increment to next task
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from InitializeMemory
fun initializeMemory(Y: Int): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = Y
    //> InitializeMemory:
    //> ldx #$07          ;set initial high byte to $0700-$07ff
    X = 0x07
    //> lda #$00          ;set initial low byte to start of page (at $00 of page)
    A = 0x00
    //> sta $06
    memory[0x6] = A.toUByte()
    Y = Y
    loop0@ do {
        loop1@ do {
            //> InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
            //> bne InitByte      ;if not, go ahead anyway
            if (X == 0x01) {
                //> cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
                //> bcs SkipByte      ;if so, skip write
                if (Y >= 0x60) {
                    //  goto SkipByte (internal forward branch)
                    //> SkipByte:     dey
                    Y = (Y - 1) and 0xFF
                    //> cpy #$ff          ;do this until all bytes in page have been erased
                    //> bne InitByteLoop
                    if (!(Y == 0xFF)) {
                        //  continue loop (branch back to InitByteLoop)
                        continue@loop1
                    }
                    //> dex               ;go onto the next page
                    X = (X - 1) and 0xFF
                    //> bpl InitPageLoop  ;do this until all pages of memory have been erased
                    if (!((X and 0x80) != 0)) {
                        //  continue loop (branch back to InitPageLoop)
                        continue@loop0
                    }
                    //> rts
                    return A
                }
            }
            //> InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
            memory[readWord(0x6) + Y] = A.toUByte()
            //> SkipByte:     dey
            Y = (Y - 1) and 0xFF
            //> cpy #$ff          ;do this until all bytes in page have been erased
            //> bne InitByteLoop
            if (!(Y == 0xFF)) {
                //  continue loop (branch back to InitByteLoop)
                continue@loop1
            }
        } while (Y != 0xFF)
        //> dex               ;go onto the next page
        X = (X - 1) and 0xFF
        //> bpl InitPageLoop  ;do this until all pages of memory have been erased
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to InitPageLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> rts
    return A
}

// Decompiled from GetAreaMusic
fun getAreaMusic() {
    var A: Int = 0
    var Y: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var operMode by MemoryByte(OperMode)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    val musicSelectData by MemoryByteIndexed(MusicSelectData)
    //> GetAreaMusic:
    //> lda OperMode           ;if in title screen mode, leave
    A = operMode
    //> beq ExitGetM
    if (A != 0) {
        //> lda AltEntranceControl ;check for specific alternate mode of entry
        A = altEntranceControl
        //> cmp #$02               ;if found, branch without checking starting position
        //> beq ChkAreaType        ;from area object data header
        if (A != 0x02) {
            //> ldy #$05               ;select music for pipe intro scene by default
            Y = 0x05
            //> lda PlayerEntranceCtrl ;check value from level header for certain values
            A = playerEntranceCtrl
            //> cmp #$06
            //> beq StoreMusic         ;load music for pipe intro scene if header
            if (A != 0x06) {
                //> cmp #$07               ;start position either value $06 or $07
                //> beq StoreMusic
                if (A == 0x07) {
                    //  goto StoreMusic (internal forward branch)
                    //> StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
                    A = musicSelectData[Y]
                    //> sta AreaMusicQueue     ;store in queue and leave
                    areaMusicQueue = A
                    return
                }
            }
        }
        //> ChkAreaType: ldy AreaType           ;load area type as offset for music bit
        Y = areaType
        //> lda CloudTypeOverride
        A = cloudTypeOverride
        //> beq StoreMusic         ;check for cloud type override
        if (A != 0) {
            //> ldy #$04               ;select music for cloud type level if found
            Y = 0x04
        }
        //> StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
        A = musicSelectData[Y]
        //> sta AreaMusicQueue     ;store in queue and leave
        areaMusicQueue = A
    }
    //> ExitGetM:    rts
    return
}

// Decompiled from Entrance_GameTimerSetup
fun entranceGametimersetup() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var blockYPosition by MemoryByte(Block_Y_Position)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var gameTimerSetting by MemoryByte(GameTimerSetting)
    var halfwayPage by MemoryByte(HalfwayPage)
    var joypadOverride by MemoryByte(JoypadOverride)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    val altYPosOffset by MemoryByteIndexed(AltYPosOffset)
    val gameTimerData by MemoryByteIndexed(GameTimerData)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    val playerBGPriorityData by MemoryByteIndexed(PlayerBGPriorityData)
    val playerstartingXPos by MemoryByteIndexed(PlayerStarting_X_Pos)
    val playerstartingYPos by MemoryByteIndexed(PlayerStarting_Y_Pos)
    //> Entrance_GameTimerSetup:
    //> lda ScreenLeft_PageLoc      ;set current page for area objects
    A = screenleftPageloc
    //> sta Player_PageLoc          ;as page location for player
    playerPageloc = A
    //> lda #$28                    ;store value here
    A = 0x28
    //> sta VerticalForceDown       ;for fractional movement downwards if necessary
    verticalForceDown = A
    //> lda #$01                    ;set high byte of player position and
    A = 0x01
    //> sta PlayerFacingDir         ;set facing direction so that player faces right
    playerFacingDir = A
    //> sta Player_Y_HighPos
    playerYHighpos = A
    //> lda #$00                    ;set player state to on the ground by default
    A = 0x00
    //> sta Player_State
    playerState = A
    //> dec Player_CollisionBits    ;initialize player's collision bits
    playerCollisionbits = (playerCollisionbits - 1) and 0xFF
    //> ldy #$00                    ;initialize halfway page
    Y = 0x00
    //> sty HalfwayPage
    halfwayPage = Y
    //> lda AreaType                ;check area type
    A = areaType
    //> bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
    if (A == 0) {
        //> iny
        Y = (Y + 1) and 0xFF
    }
    //> ChkStPos: sty SwimmingFlag
    swimmingFlag = Y
    //> ldx PlayerEntranceCtrl      ;get starting position loaded from header
    X = playerEntranceCtrl
    //> ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
    Y = altEntranceControl
    //> beq SetStPos
    if (Y != 0) {
        //> cpy #$01
        //> beq SetStPos
        if (Y != 0x01) {
            //> ldx AltYPosOffset-2,y       ;if not 0 or 1, override $0710 with new offset in X
            X = altYPosOffset[-2 + Y]
        }
    }
    //> SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
    A = playerstartingXPos[Y]
    //> sta Player_X_Position       ;and vertical positions for the player, using
    playerXPosition = A
    //> lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
    A = playerstartingYPos[X]
    //> sta Player_Y_Position       ;or value that overwrote $0710 as offset for vertical
    playerYPosition = A
    //> lda PlayerBGPriorityData,x
    A = playerBGPriorityData[X]
    //> sta Player_SprAttrib        ;set player sprite attributes using offset in X
    playerSprattrib = A
    //> jsr GetPlayerColors         ;get appropriate player palette
    getPlayerColors()
    //> ldy GameTimerSetting        ;get timer control value from header
    Y = gameTimerSetting
    //> beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
    if (Y != 0) {
        //> lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
        A = fetchNewGameTimerFlag
        //> beq ChkOverR                ;old game timer setting
        if (A != 0) {
            //> lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
            A = gameTimerData[Y]
            //> sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
            gameTimerDisplay[0] = A
            //> lda #$01
            A = 0x01
            //> sta GameTimerDisplay+2      ;set last digit of game timer to 1
            gameTimerDisplay[2] = A
            //> lsr
            val orig0: Int = A
            A = orig0 shr 1
            //> sta GameTimerDisplay+1      ;set second digit of game timer
            gameTimerDisplay[1] = A
            //> sta FetchNewGameTimerFlag   ;clear flag for game timer reset
            fetchNewGameTimerFlag = A
            //> sta StarInvincibleTimer     ;clear star mario timer
            starInvincibleTimer = A
        }
    }
    //> ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
    Y = joypadOverride
    //> beq ChkSwimE
    if (Y != 0) {
        //> lda #$03                    ;set player state to climbing
        A = 0x03
        //> sta Player_State
        playerState = A
        //> ldx #$00                    ;set offset for first slot, for block object
        X = 0x00
        //> jsr InitBlock_XY_Pos
        initblockXyPos(X)
        //> lda #$f0                    ;set vertical coordinate for block object
        A = 0xF0
        //> sta Block_Y_Position
        blockYPosition = A
        //> ldx #$05                    ;set offset in X for last enemy object buffer slot
        X = 0x05
        //> ldy #$00                    ;set offset in Y for object coordinates used earlier
        Y = 0x00
        //> jsr Setup_Vine              ;do a sub to grow vine
        setupVine(X, Y)
    }
    //> ChkSwimE: ldy AreaType                ;if level not water-type,
    Y = areaType
    //> bne SetPESub                ;skip this subroutine
    if (Y == 0) {
        //> jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
        setupBubble(X)
    }
    //> SetPESub: lda #$07                    ;set to run player entrance subroutine
    A = 0x07
    //> sta GameEngineSubroutine    ;on the next frame of game engine
    gameEngineSubroutine = A
    //> rts
    return
}

// Decompiled from PlayerLoseLife
fun playerLoseLife() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var halfwayPage by MemoryByte(HalfwayPage)
    var levelNumber by MemoryByte(LevelNumber)
    var numberofLives by MemoryByte(NumberofLives)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    var worldNumber by MemoryByte(WorldNumber)
    val halfwayPageNybbles by MemoryByteIndexed(HalfwayPageNybbles)
    //> PlayerLoseLife:
    //> inc DisableScreenFlag    ;disable screen and sprite 0 check
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> lda #$00
    A = 0x00
    //> sta Sprite0HitDetectFlag
    sprite0HitDetectFlag = A
    //> lda #Silence             ;silence music
    A = Silence
    //> sta EventMusicQueue
    eventMusicQueue = A
    //> dec NumberofLives        ;take one life from player
    numberofLives = (numberofLives - 1) and 0xFF
    //> bpl StillInGame          ;if player still has lives, branch
    if ((numberofLives and 0x80) != 0) {
        //> lda #$00
        A = 0x00
        //> sta OperMode_Task        ;initialize mode task,
        opermodeTask = A
        //> lda #GameOverModeValue   ;switch to game over mode
        A = GameOverModeValue
        //> sta OperMode             ;and leave
        operMode = A
        //> rts
        return
    } else {
        //> StillInGame: lda WorldNumber          ;multiply world number by 2 and use
        A = worldNumber
        //> asl                      ;as offset
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> tax
        X = A
        //> lda LevelNumber          ;if in area -3 or -4, increment
        A = levelNumber
        //> and #$02                 ;offset by one byte, otherwise
        A = A and 0x02
        //> beq GetHalfway           ;leave offset alone
        X = X
        if (A != 0) {
            //> inx
            X = (X + 1) and 0xFF
        }
    }
    //> GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
    Y = halfwayPageNybbles[X]
    //> lda LevelNumber          ;check area number's LSB
    A = levelNumber
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> tya                      ;if in area -2 or -4, use lower nybble
    A = Y
    //> bcs MaskHPNyb
    if ((orig1 and 0x01) == 0) {
        //> lsr                      ;move higher nybble to lower if area
        val orig2: Int = A
        A = orig2 shr 1
        //> lsr                      ;number is -1 or -3
        val orig3: Int = A
        A = orig3 shr 1
        //> lsr
        val orig4: Int = A
        A = orig4 shr 1
        //> lsr
        val orig5: Int = A
        A = orig5 shr 1
    }
    //> MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
    A = A and 0x0F
    //> cmp ScreenLeft_PageLoc
    //> beq SetHalfway           ;left side of screen must be at the halfway page,
    if (A != screenleftPageloc) {
        //> bcc SetHalfway           ;otherwise player must start at the
        if (A >= screenleftPageloc) {
            //> lda #$00                 ;beginning of the level
            A = 0x00
        }
    }
    //> SetHalfway:  sta HalfwayPage          ;store as halfway page for player
    halfwayPage = A
    //> jsr TransposePlayers     ;switch players around if 2-player game
    temp0 = transposePlayers()
    //> jmp ContinueGame         ;continue the game
    continueGame(temp0)
    return
}

// Decompiled from GameOverMode
fun gameOverMode() {
    var A: Int = 0
    var opermodeTask by MemoryByte(OperMode_Task)
    //> GameOverMode:
    //> lda OperMode_Task
    A = opermodeTask
    //> jsr JumpEngine
    when (A) {
        0 -> {
            setupGameOver()
        }
        1 -> {
            screenRoutines()
        }
        2 -> {
            runGameOver()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw SetupGameOver
    //> .dw ScreenRoutines
    //> .dw RunGameOver
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to setupGameOver
    setupGameOver()
    return
}

// Decompiled from SetupGameOver
fun setupGameOver() {
    var A: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    //> SetupGameOver:
    //> lda #$00                  ;reset screen routine task control for title screen, game,
    A = 0x00
    //> sta ScreenRoutineTask     ;and game over modes
    screenRoutineTask = A
    //> sta Sprite0HitDetectFlag  ;disable sprite 0 check
    sprite0HitDetectFlag = A
    //> lda #GameOverMusic
    A = GameOverMusic
    //> sta EventMusicQueue       ;put game over music in secondary queue
    eventMusicQueue = A
    //> inc DisableScreenFlag     ;disable screen output
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> inc OperMode_Task         ;set secondary mode to 1
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from RunGameOver
fun runGameOver() {
    var A: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    var screenTimer by MemoryByte(ScreenTimer)
    //> RunGameOver:
    //> lda #$00              ;reenable screen
    A = 0x00
    //> sta DisableScreenFlag
    disableScreenFlag = A
    //> lda SavedJoypad1Bits  ;check controller for start pressed
    A = savedJoypad1Bits
    //> and #Start_Button
    A = A and Start_Button
    //> bne TerminateGame
    if (!(A == 0)) {
        //  goto TerminateGame -> terminateGame
        terminateGame()
        return
    } else {
        //> lda ScreenTimer       ;if not pressed, wait for
        A = screenTimer
        //> bne GameIsOn          ;screen timer to expire
        if (!(A == 0)) {
            //  goto GameIsOn -> gameIsOn
            gameIsOn()
            return
        }
        //  Fall-through tail call to terminateGame
        terminateGame()
        return
    }
}

// Decompiled from TerminateGame
fun terminateGame() {
    var A: Int = 0
    var temp0: Int = 0
    var continueWorld by MemoryByte(ContinueWorld)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenTimer by MemoryByte(ScreenTimer)
    var worldNumber by MemoryByte(WorldNumber)
    //> TerminateGame:
    //> lda #Silence          ;silence music
    A = Silence
    //> sta EventMusicQueue
    eventMusicQueue = A
    //> jsr TransposePlayers  ;check if other player can keep
    temp0 = transposePlayers()
    //> bcc ContinueGame      ;going, and do so if possible
    if (!(flagC)) {
        //  goto ContinueGame -> continueGame
        continueGame(temp0)
        return
    } else {
        //> lda WorldNumber       ;otherwise put world number of current
        A = worldNumber
        //> sta ContinueWorld     ;player into secret continue function variable
        continueWorld = A
        //> lda #$00
        A = 0x00
        //> asl                   ;residual ASL instruction
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> sta OperMode_Task     ;reset all modes to title screen and
        opermodeTask = A
        //> sta ScreenTimer       ;leave
        screenTimer = A
        //> sta OperMode
        operMode = A
        //> rts
        return
    }
}

// Decompiled from ContinueGame
fun continueGame(A: Int) {
    var A: Int = A
    var temp0: Int = 0
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerSize by MemoryByte(PlayerSize)
    var playerStatus by MemoryByte(PlayerStatus)
    var timerControl by MemoryByte(TimerControl)
    //> ContinueGame:
    //> jsr LoadAreaPointer       ;update level pointer with
    temp0 = loadAreaPointer(A)
    //> lda #$01                  ;actual world and area numbers, then
    A = 0x01
    //> sta PlayerSize            ;reset player's size, status, and
    playerSize = A
    //> inc FetchNewGameTimerFlag ;set game timer flag to reload
    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
    //> lda #$00                  ;game timer from header
    A = 0x00
    //> sta TimerControl          ;also set flag for timers to count again
    timerControl = A
    //> sta PlayerStatus
    playerStatus = A
    //> sta GameEngineSubroutine  ;reset task for game core
    gameEngineSubroutine = A
    //> sta OperMode_Task         ;set modes and leave
    opermodeTask = A
    //> lda #$01                  ;if in game over mode, switch back to
    A = 0x01
    //> sta OperMode              ;game mode, because game is still on
    operMode = A
    //  Fall-through tail call to gameIsOn
    gameIsOn()
    return
}

// Decompiled from GameIsOn
fun gameIsOn() {
    //> GameIsOn:  rts
    return
}

// Decompiled from TransposePlayers
fun transposePlayers(): Int {
    var A: Int = 0
    var X: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    var offscrNumberoflives by MemoryByte(OffScr_NumberofLives)
    val offscreenPlayerInfo by MemoryByteIndexed(OffscreenPlayerInfo)
    val onscreenPlayerInfo by MemoryByteIndexed(OnscreenPlayerInfo)
    //> TransposePlayers:
    //> sec                       ;set carry flag by default to end game
    //> lda NumberOfPlayers       ;if only a 1 player game, leave
    A = numberOfPlayers
    //> beq ExTrans
    if (A != 0) {
        //> lda OffScr_NumberofLives  ;does offscreen player have any lives left?
        A = offscrNumberoflives
        //> bmi ExTrans               ;branch if not
        if ((A and 0x80) == 0) {
            //> lda CurrentPlayer         ;invert bit to update
            A = currentPlayer
            //> eor #%00000001            ;which player is on the screen
            A = A xor 0x01
            //> sta CurrentPlayer
            currentPlayer = A
            //> ldx #$06
            X = 0x06
            loop0@ do {
                //> TransLoop: lda OnscreenPlayerInfo,x    ;transpose the information
                A = onscreenPlayerInfo[X]
                //> pha                         ;of the onscreen player
                push(A)
                //> lda OffscreenPlayerInfo,x   ;with that of the offscreen player
                A = offscreenPlayerInfo[X]
                //> sta OnscreenPlayerInfo,x
                onscreenPlayerInfo[X] = A
                //> pla
                A = pull()
                //> sta OffscreenPlayerInfo,x
                offscreenPlayerInfo[X] = A
                //> dex
                X = (X - 1) and 0xFF
                //> bpl TransLoop
                if (!((X and 0x80) != 0)) {
                    //  continue loop (branch back to TransLoop)
                    continue@loop0
                }
            } while ((X and 0x80) == 0)
            //> clc            ;clear carry flag to get game going
        }
    }
    //> ExTrans:   rts
    return A
}

// Decompiled from DoNothing1
fun doNothing1() {
    var A: Int = 0
    //> DoNothing1:
    //> lda #$ff       ;this is residual code, this value is
    A = 0xFF
    //> sta $06c9      ;not used anywhere in the program
    memory[0x6C9] = A.toUByte()
    //  Fall-through tail call to doNothing2
    doNothing2()
    return
}

// Decompiled from DoNothing2
fun doNothing2() {
    //> DoNothing2:
    //> rts
    return
}

// Decompiled from AreaParserTaskHandler
fun areaParserTaskHandler() {
    var A: Int = 0
    var Y: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    //> AreaParserTaskHandler:
    //> ldy AreaParserTaskNum     ;check number of tasks here
    Y = areaParserTaskNum
    //> bne DoAPTasks             ;if already set, go ahead
    if (Y == 0) {
        //> ldy #$08
        Y = 0x08
        //> sty AreaParserTaskNum     ;otherwise, set eight by default
        areaParserTaskNum = Y
    }
    //> DoAPTasks:    dey
    Y = (Y - 1) and 0xFF
    //> tya
    A = Y
    //> jsr AreaParserTasks
    areaParserTasks(A)
    //> dec AreaParserTaskNum     ;if all tasks not complete do not
    areaParserTaskNum = (areaParserTaskNum - 1) and 0xFF
    //> bne SkipATRender          ;render attribute table yet
    A = A
    if (areaParserTaskNum == 0) {
        //> jsr RenderAttributeTables
        renderAttributeTables()
    }
    //> SkipATRender: rts
    return
}

// Decompiled from AreaParserTasks
fun areaParserTasks(A: Int) {
    //> AreaParserTasks:
    //> jsr JumpEngine
    when (A) {
        0 -> {
            incrementColumnPos()
        }
        1 -> {
            renderAreaGraphics()
        }
        2 -> {
            renderAreaGraphics()
        }
        3 -> {
            areaParserCore()
        }
        4 -> {
            incrementColumnPos()
        }
        5 -> {
            renderAreaGraphics()
        }
        6 -> {
            renderAreaGraphics()
        }
        7 -> {
            areaParserCore()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw IncrementColumnPos
    //> .dw RenderAreaGraphics
    //> .dw RenderAreaGraphics
    //> .dw AreaParserCore
    //> .dw IncrementColumnPos
    //> .dw RenderAreaGraphics
    //> .dw RenderAreaGraphics
    //> .dw AreaParserCore
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to incrementColumnPos
    incrementColumnPos()
    return
}

// Decompiled from IncrementColumnPos
fun incrementColumnPos() {
    var A: Int = 0
    var blockBufferColumnPos by MemoryByte(BlockBufferColumnPos)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    //> IncrementColumnPos:
    //> inc CurrentColumnPos     ;increment column where we're at
    currentColumnPos = (currentColumnPos + 1) and 0xFF
    //> lda CurrentColumnPos
    A = currentColumnPos
    //> and #%00001111           ;mask out higher nybble
    A = A and 0x0F
    //> bne NoColWrap
    if (A == 0) {
        //> sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
        currentColumnPos = A
        //> inc CurrentPageLoc       ;and increment page number where we're at
        currentPageLoc = (currentPageLoc + 1) and 0xFF
    }
    //> NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
    blockBufferColumnPos = (blockBufferColumnPos + 1) and 0xFF
    //> lda BlockBufferColumnPos
    A = blockBufferColumnPos
    //> and #%00011111           ;mask out all but 5 LSB (0-1f)
    A = A and 0x1F
    //> sta BlockBufferColumnPos ;and save
    blockBufferColumnPos = A
    //> rts
    return
}

// Decompiled from AreaParserCore
fun areaParserCore() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaType by MemoryByte(AreaType)
    var backgroundScenery by MemoryByte(BackgroundScenery)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var foregroundScenery by MemoryByte(ForegroundScenery)
    var worldNumber by MemoryByte(WorldNumber)
    val bSceneDataOffsets by MemoryByteIndexed(BSceneDataOffsets)
    val backSceneryData by MemoryByteIndexed(BackSceneryData)
    val backSceneryMetatiles by MemoryByteIndexed(BackSceneryMetatiles)
    val fSceneDataOffsets by MemoryByteIndexed(FSceneDataOffsets)
    val foreSceneryData by MemoryByteIndexed(ForeSceneryData)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val terrainMetatiles by MemoryByteIndexed(TerrainMetatiles)
    //> AreaParserCore:
    //> lda BackloadingFlag       ;check to see if we are starting right of start
    A = backloadingFlag
    //> beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
    if (A != 0) {
        //> jsr ProcessAreaData       ;otherwise skip ahead and load level data
        processAreaData()
    }
    //> RenderSceneryTerrain:
    //> ldx #$0c
    X = 0x0C
    //> lda #$00
    A = 0x00
    loop0@ do {
        //> ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
        metatileBuffer[X] = A
        //> dex
        X = (X - 1) and 0xFF
        //> bpl ClrMTBuf
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to ClrMTBuf)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> ldy BackgroundScenery      ;do we need to render the background scenery?
    Y = backgroundScenery
    //> beq RendFore               ;if not, skip to check the foreground
    if (Y != 0) {
        //> lda CurrentPageLoc         ;otherwise check for every third page
        A = currentPageLoc
        loop1@ while ((A and 0x80) == 0) {
            //> sec
            //> sbc #$03                   ;if 3 or more, subtract 3 and
            temp0 = A - 0x03
            A = temp0 and 0xFF
            //> bpl ThirdP                 ;do an unconditional branch
            if (!((temp0 and 0xFF and 0x80) != 0)) {
                //  continue loop (branch back to ThirdP)
                continue@loop1
            }
        }
        //> RendBack: asl                        ;move results to higher nybble
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> asl
        val orig1: Int = A
        A = (orig1 shl 1) and 0xFF
        //> asl
        val orig2: Int = A
        A = (orig2 shl 1) and 0xFF
        //> asl
        val orig3: Int = A
        A = (orig3 shl 1) and 0xFF
        //> adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
        temp1 = A + bSceneDataOffsets[-1 + Y] + if ((orig3 and 0x80) != 0) 1 else 0
        A = temp1 and 0xFF
        //> adc CurrentColumnPos       ;add to the result our current column position
        temp2 = A + currentColumnPos + if (temp1 > 0xFF) 1 else 0
        A = temp2 and 0xFF
        //> tax
        X = A
        //> lda BackSceneryData,x      ;load data from sum of offsets
        A = backSceneryData[X]
        //> beq RendFore               ;if zero, no scenery for that part
        if (A != 0) {
            //> pha
            push(A)
            //> and #$0f                   ;save to stack and clear high nybble
            A = A and 0x0F
            //> sec
            //> sbc #$01                   ;subtract one (because low nybble is $01-$0c)
            temp3 = A - 0x01
            A = temp3 and 0xFF
            //> sta $00                    ;save low nybble
            memory[0x0] = A.toUByte()
            //> asl                        ;multiply by three (shift to left and add result to old one)
            val orig4: Int = A
            A = (orig4 shl 1) and 0xFF
            //> adc $00                    ;note that since d7 was nulled, the carry flag is always clear
            temp4 = A + memory[0x0].toInt() + if ((orig4 and 0x80) != 0) 1 else 0
            A = temp4 and 0xFF
            //> tax                        ;save as offset for background scenery metatile data
            X = A
            //> pla                        ;get high nybble from stack, move low
            A = pull()
            //> lsr
            val orig5: Int = A
            A = orig5 shr 1
            //> lsr
            val orig6: Int = A
            A = orig6 shr 1
            //> lsr
            val orig7: Int = A
            A = orig7 shr 1
            //> lsr
            val orig8: Int = A
            A = orig8 shr 1
            //> tay                        ;use as second offset (used to determine height)
            Y = A
            //> lda #$03                   ;use previously saved memory location for counter
            A = 0x03
            //> sta $00
            memory[0x0] = A.toUByte()
            loop2@ while (A != 0) {
                //> dec $00                    ;decrement until counter expires, barring exception
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bne SceLoop1
                if (!(memory[0x0].toInt() == 0)) {
                    //  continue loop (branch back to SceLoop1)
                    continue@loop2
                }
            }
        }
    }
    //> RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
    X = foregroundScenery
    //> beq RendTerr               ;if not, skip this part
    if (X != 0) {
        //> ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
        Y = fSceneDataOffsets[-1 + X]
        //> ldx #$00                   ;reinit X
        X = 0x00
        loop3@ do {
            //> SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
            A = foreSceneryData[Y]
            //> beq NoFore                 ;do not store if zero found
            if (A != 0) {
                //> sta MetatileBuffer,x
                metatileBuffer[X] = A
            }
            //> NoFore:   iny
            Y = (Y + 1) and 0xFF
            //> inx
            X = (X + 1) and 0xFF
            //> cpx #$0d                   ;store up to end of metatile buffer
            //> bne SceLoop2
            if (!(X == 0x0D)) {
                //  continue loop (branch back to SceLoop2)
                continue@loop3
            }
        } while (X != 0x0D)
    }
    //> RendTerr: ldy AreaType               ;check world type for water level
    Y = areaType
    //> bne TerMTile               ;if not water level, skip this part
    if (Y == 0) {
        //> lda WorldNumber            ;check world number, if not world number eight
        A = worldNumber
        //> cmp #World8                ;then skip this part
        //> bne TerMTile
        if (A == World8) {
            //> lda #$62                   ;if set as water level and world number eight,
            A = 0x62
            //> jmp StoreMT                ;use castle wall metatile as terrain type
            storeMT(A)
            return
        }
    }
    //> TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
    A = terrainMetatiles[Y]
    //> ldy CloudTypeOverride      ;check for cloud type override
    Y = cloudTypeOverride
    //> beq StoreMT                ;if not set, keep value otherwise
    if (Y == 0) {
        //  goto StoreMT -> storeMT
        storeMT(A)
        return
    } else {
        //> lda #$88                   ;use cloud block terrain
        A = 0x88
        //  Fall-through tail call to storeMT
        storeMT(A)
        return
    }
}

// Decompiled from StoreMT
fun storeMT(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    var blockBufferColumnPos by MemoryByte(BlockBufferColumnPos)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var terrainControl by MemoryByte(TerrainControl)
    val bitmasks by MemoryByteIndexed(Bitmasks)
    val blockBuffLowBounds by MemoryByteIndexed(BlockBuffLowBounds)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val terrainRenderBits by MemoryByteIndexed(TerrainRenderBits)
    //> StoreMT:  sta $07                    ;store value here
    memory[0x7] = A.toUByte()
    //> ldx #$00                   ;initialize X, use as metatile buffer offset
    X = 0x00
    //> lda TerrainControl         ;use yet another value from the header
    A = terrainControl
    //> asl                        ;multiply by 2 and use as yet another offset
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> tay
    Y = A
    Y = Y
    loop0@ do {
        //> TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
        A = terrainRenderBits[Y]
        //> sta $00
        memory[0x0] = A.toUByte()
        //> iny                        ;increment Y and use as offset next time around
        Y = (Y + 1) and 0xFF
        //> sty $01
        memory[0x1] = Y.toUByte()
        //> lda CloudTypeOverride      ;skip if value here is zero
        A = cloudTypeOverride
        //> beq NoCloud2
        if (A != 0) {
            //> cpx #$00                   ;otherwise, check if we're doing the ceiling byte
            //> beq NoCloud2
            if (X != 0x00) {
                //> lda $00                    ;if not, mask out all but d3
                A = memory[0x0].toInt()
                //> and #%00001000
                A = A and 0x08
                //> sta $00
                memory[0x0] = A.toUByte()
            }
        }
        //> NoCloud2: ldy #$00                   ;start at beginning of bitmasks
        Y = 0x00
        loop1@ do {
            //> TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
            A = bitmasks[Y]
            //> bit $00
            //> beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
            if ((A and memory[0x0].toInt()) != 0) {
                //> lda $07
                A = memory[0x7].toInt()
                //> sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
                metatileBuffer[X] = A
            }
            //> NextTBit: inx                        ;continue until end of buffer
            X = (X + 1) and 0xFF
            //> cpx #$0d
            //> beq RendBBuf               ;if we're at the end, break out of this loop
            if (X != 0x0D) {
                //> lda AreaType               ;check world type for underground area
                A = areaType
                //> cmp #$02
                //> bne EndUChk                ;if not underground, skip this part
                if (A == 0x02) {
                    //> cpx #$0b
                    //> bne EndUChk                ;if we're at the bottom of the screen, override
                    if (X == 0x0B) {
                        //> lda #$54                   ;old terrain type with ground level terrain type
                        A = 0x54
                        //> sta $07
                        memory[0x7] = A.toUByte()
                    }
                }
                //> EndUChk:  iny                        ;increment bitmasks offset in Y
                Y = (Y + 1) and 0xFF
                //> cpy #$08
                //> bne TerrBChk               ;if not all bits checked, loop back
                if (!(Y == 0x08)) {
                    //  continue loop (branch back to TerrBChk)
                    continue@loop1
                }
            } else {
                break@loop0
            }
        } while (Y != 0x08)
        //> ldy $01
        Y = memory[0x1].toInt()
        //> bne TerrLoop               ;unconditional branch, use Y to load next byte
        if (!(Y == 0)) {
            //  continue loop (branch back to TerrLoop)
            continue@loop0
        }
    } while (Y != 0)
    //> RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
    processAreaData()
    //> lda BlockBufferColumnPos
    A = blockBufferColumnPos
    //> jsr GetBlockBufferAddr     ;get block buffer address from where we're at
    getBlockBufferAddr(A)
    //> ldx #$00
    X = 0x00
    //> ldy #$00                   ;init index regs and start at beginning of smaller buffer
    Y = 0x00
    loop2@ do {
        //> ChkMTLow: sty $00
        memory[0x0] = Y.toUByte()
        //> lda MetatileBuffer,x       ;load stored metatile number
        A = metatileBuffer[X]
        //> and #%11000000             ;mask out all but 2 MSB
        A = A and 0xC0
        //> asl
        val orig1: Int = A
        A = (orig1 shl 1) and 0xFF
        //> rol                        ;make %xx000000 into %000000xx
        val orig2: Int = A
        A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x80) != 0) 1 else 0
        //> rol
        val orig3: Int = A
        A = (orig3 shl 1) and 0xFE or if ((orig2 and 0x80) != 0) 1 else 0
        //> tay                        ;use as offset in Y
        Y = A
        //> lda MetatileBuffer,x       ;reload original unmasked value here
        A = metatileBuffer[X]
        //> cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
        //> bcs StrBlock               ;if equal or greater, branch
        if (!(A >= blockBuffLowBounds[Y])) {
            //> lda #$00                   ;if less, init value before storing
            A = 0x00
        }
        //> StrBlock: ldy $00                    ;get offset for block buffer
        Y = memory[0x0].toInt()
        //> sta ($06),y                ;store value into block buffer
        memory[readWord(0x6) + Y] = A.toUByte()
        //> tya
        A = Y
        //> clc                        ;add 16 (move down one row) to offset
        //> adc #$10
        temp0 = A + 0x10
        A = temp0 and 0xFF
        //> tay
        Y = A
        //> inx                        ;increment column value
        X = (X + 1) and 0xFF
        //> cpx #$0d
        //> bcc ChkMTLow               ;continue until we pass last row, then leave
        if (!(X >= 0x0D)) {
            //  continue loop (branch back to ChkMTLow)
            continue@loop2
        }
    } while (!(X >= 0x0D))
    //> rts
    return
}

// Decompiled from ProcessAreaData
fun processAreaData() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageLoc by MemoryByte(AreaObjectPageLoc)
    var areaObjectPageSel by MemoryByte(AreaObjectPageSel)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var behindAreaParserFlag by MemoryByte(BehindAreaParserFlag)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var objectOffset by MemoryByte(ObjectOffset)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    loop0@ do {
        loop1@ do {
            //> ProcADLoop: stx ObjectOffset
            objectOffset = X
            //> lda #$00                 ;reset flag
            A = 0x00
            //> sta BehindAreaParserFlag
            behindAreaParserFlag = A
            //> ldy AreaDataOffset       ;get offset of area data pointer
            Y = areaDataOffset
            //> lda (AreaData),y         ;get first byte of area object
            A = memory[readWord(AreaData) + Y].toInt()
            //> cmp #$fd                 ;if end-of-area, skip all this crap
            //> beq RdyDecode
            if (A != 0xFD) {
                //> lda AreaObjectLength,x   ;check area object buffer flag
                A = areaObjectLength[X]
                //> bpl RdyDecode            ;if buffer not negative, branch, otherwise
                if ((A and 0x80) != 0) {
                    //> iny
                    Y = (Y + 1) and 0xFF
                    //> lda (AreaData),y         ;get second byte of area object
                    A = memory[readWord(AreaData) + Y].toInt()
                    //> asl                      ;check for page select bit (d7), branch if not set
                    val orig0: Int = A
                    A = (orig0 shl 1) and 0xFF
                    //> bcc Chk1Row13
                    if ((orig0 and 0x80) != 0) {
                        //> lda AreaObjectPageSel    ;check page select
                        A = areaObjectPageSel
                        //> bne Chk1Row13
                        if (A == 0) {
                            //> inc AreaObjectPageSel    ;if not already set, set it now
                            areaObjectPageSel = (areaObjectPageSel + 1) and 0xFF
                            //> inc AreaObjectPageLoc    ;and increment page location
                            areaObjectPageLoc = (areaObjectPageLoc + 1) and 0xFF
                        }
                    }
                    //> Chk1Row13:  dey
                    Y = (Y - 1) and 0xFF
                    //> lda (AreaData),y         ;reread first byte of level object
                    A = memory[readWord(AreaData) + Y].toInt()
                    //> and #$0f                 ;mask out high nybble
                    A = A and 0x0F
                    //> cmp #$0d                 ;row 13?
                    //> bne Chk1Row14
                    if (A == 0x0D) {
                        //> iny                      ;if so, reread second byte of level object
                        Y = (Y + 1) and 0xFF
                        //> lda (AreaData),y
                        A = memory[readWord(AreaData) + Y].toInt()
                        //> dey                      ;decrement to get ready to read first byte
                        Y = (Y - 1) and 0xFF
                        //> and #%01000000           ;check for d6 set (if not, object is page control)
                        A = A and 0x40
                        //> bne CheckRear
                        if (A == 0) {
                            //> lda AreaObjectPageSel    ;if page select is set, do not reread
                            A = areaObjectPageSel
                            //> bne CheckRear
                            if (A == 0) {
                                //> iny                      ;if d6 not set, reread second byte
                                Y = (Y + 1) and 0xFF
                                //> lda (AreaData),y
                                A = memory[readWord(AreaData) + Y].toInt()
                                //> and #%00011111           ;mask out all but 5 LSB and store in page control
                                A = A and 0x1F
                                //> sta AreaObjectPageLoc
                                areaObjectPageLoc = A
                                //> inc AreaObjectPageSel    ;increment page select
                                areaObjectPageSel = (areaObjectPageSel + 1) and 0xFF
                                //> jmp NextAObj
                                //> jmp NextAObj (not a known function)
                            }
                        }
                    }
                    //> Chk1Row14:  cmp #$0e                 ;row 14?
                    //> bne CheckRear
                    if (A == 0x0E) {
                        //> lda BackloadingFlag      ;check flag for saved page number and branch if set
                        A = backloadingFlag
                        //> bne RdyDecode            ;to render the object (otherwise bg might not look right)
                        if (!(A == 0)) {
                            //  goto RdyDecode (internal forward branch)
                            //> RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
                            decodeAreaData(0)
                            //> jmp ChkLength
                            //> jmp ChkLength (not a known function)
                            return
                        }
                    }
                    //> CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
                    A = areaObjectPageLoc
                    //> cmp CurrentPageLoc       ;behind current page of renderer
                    //> bcc SetBehind            ;if so branch
                    if (!(A >= currentPageLoc)) {
                        //  goto SetBehind (internal forward branch)
                        //> SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
                        behindAreaParserFlag = (behindAreaParserFlag + 1) and 0xFF
                        return
                    }
                }
            }
            //> RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
            decodeAreaData(0)
            //> jmp ChkLength
            //> jmp ChkLength (not a known function)
            //> SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
            behindAreaParserFlag = (behindAreaParserFlag + 1) and 0xFF
            //> NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
            incAreaObjOffset()
            //> ChkLength:  ldx ObjectOffset         ;get buffer offset
            X = objectOffset
            //> lda AreaObjectLength,x   ;check object length for anything stored here
            A = areaObjectLength[X]
            //> bmi ProcLoopb            ;if not, branch to handle loopback
            if ((A and 0x80) == 0) {
                //> dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
                areaObjectLength[X] = (areaObjectLength[X] - 1) and 0xFF
            }
            //> ProcLoopb:  dex                      ;decrement buffer offset
            X = (X - 1) and 0xFF
            //> bpl ProcADLoop           ;and loopback unless exceeded buffer
            if (!((X and 0x80) != 0)) {
                //  continue loop (branch back to ProcADLoop)
                continue@loop1
            }
        } while ((X and 0x80) == 0)
        //> lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
        A = behindAreaParserFlag
        //> bne ProcessAreaData      ;branch if true to load more level data, otherwise
        if (!(A == 0)) {
            //  continue loop (branch back to ProcessAreaData)
            continue@loop0
        }
        //> lda BackloadingFlag      ;check for flag set if starting right of page $00
        A = backloadingFlag
        //> bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
        if (!(A == 0)) {
            //  continue loop (branch back to ProcessAreaData)
            continue@loop0
        }
        //  Fall-through tail call to endAParse
        endAParse()
        return
    } while (A != 0)
    // Fall-through tail call to endAParse
    endAParse()
    return
}

// Decompiled from EndAParse
fun endAParse() {
    //> EndAParse:  rts
    return
}

// Decompiled from IncAreaObjOffset
fun incAreaObjOffset() {
    var A: Int = 0
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageSel by MemoryByte(AreaObjectPageSel)
    //> IncAreaObjOffset:
    //> inc AreaDataOffset    ;increment offset of level pointer
    areaDataOffset = (areaDataOffset + 1) and 0xFF
    //> inc AreaDataOffset
    areaDataOffset = (areaDataOffset + 1) and 0xFF
    //> lda #$00              ;reset page select
    A = 0x00
    //> sta AreaObjectPageSel
    areaObjectPageSel = A
    //> rts
    return
}

// Decompiled from DecodeAreaData
fun decodeAreaData(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var loopCommand by MemoryByte(LoopCommand)
    var objectOffset by MemoryByte(ObjectOffset)
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> DecodeAreaData:
    //> lda AreaObjectLength,x     ;check current buffer flag
    A = areaObjectLength[X]
    //> bmi Chk1stB
    X = X
    if ((A and 0x80) == 0) {
        //> ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
        Y = areaObjOffsetBuffer[X]
    }
    //> Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
    X = 0x10
    //> lda (AreaData),y           ;get first byte of level object again
    A = memory[readWord(AreaData) + Y].toInt()
    //> cmp #$fd
    //> beq EndAParse              ;if end of level, leave this routine
    if (A == 0xFD) {
        //> EndAParse:  rts
        return
    } else {
        //> and #$0f                   ;otherwise, mask out low nybble
        A = A and 0x0F
        //> cmp #$0f                   ;row 15?
        //> beq ChkRow14               ;if so, keep the offset of 16
        if (A != 0x0F) {
            //> ldx #$08                   ;otherwise load offset of 8 for special row 12
            X = 0x08
            //> cmp #$0c                   ;row 12?
            //> beq ChkRow14               ;if so, keep the offset value of 8
            if (A != 0x0C) {
                //> ldx #$00                   ;otherwise nullify value by default
                X = 0x00
            }
        }
    }
    //> ChkRow14: stx $07                    ;store whatever value we just loaded here
    memory[0x7] = X.toUByte()
    //> ldx ObjectOffset           ;get object offset again
    X = objectOffset
    //> cmp #$0e                   ;row 14?
    //> bne ChkRow13
    if (A == 0x0E) {
        //> lda #$00                   ;if so, load offset with $00
        A = 0x00
        //> sta $07
        memory[0x7] = A.toUByte()
        //> lda #$2e                   ;and load A with another value
        A = 0x2E
        //> bne NormObj                ;unconditional branch
        if (!(A == 0)) {
            //  goto NormObj -> normObj
            normObj(A, X)
            return
        }
    }
    //> ChkRow13: cmp #$0d                   ;row 13?
    //> bne ChkSRows
    if (A == 0x0D) {
        //> lda #$22                   ;if so, load offset with 34
        A = 0x22
        //> sta $07
        memory[0x7] = A.toUByte()
        //> iny                        ;get next byte
        Y = (Y + 1) and 0xFF
        //> lda (AreaData),y
        A = memory[readWord(AreaData) + Y].toInt()
        //> and #%01000000             ;mask out all but d6 (page control obj bit)
        A = A and 0x40
        //> beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
        if (A == 0) {
            //  goto LeavePar -> leavePar
            leavePar()
            return
        }
        //> lda (AreaData),y           ;otherwise, get byte again
        A = memory[readWord(AreaData) + Y].toInt()
        //> and #%01111111             ;mask out d7
        A = A and 0x7F
        //> cmp #$4b                   ;check for loop command in low nybble
        //> bne Mask2MSB               ;(plus d6 set for object other than page control)
        if (A == 0x4B) {
            //> inc LoopCommand            ;if loop command, set loop command flag
            loopCommand = (loopCommand + 1) and 0xFF
        }
        //> Mask2MSB: and #%00111111             ;mask out d7 and d6
        A = A and 0x3F
        //> jmp NormObj                ;and jump
        normObj(A, X)
        return
    } else {
        //> ChkSRows: cmp #$0c                   ;row 12-15?
        //> bcs SpecObj
        if (!(A >= 0x0C)) {
            //> iny                        ;if not, get second byte of level object
            Y = (Y + 1) and 0xFF
            //> lda (AreaData),y
            A = memory[readWord(AreaData) + Y].toInt()
            //> and #%01110000             ;mask out all but d6-d4
            A = A and 0x70
            //> bne LrgObj                 ;if any bits set, branch to handle large object
            if (A == 0) {
                //> lda #$16
                A = 0x16
                //> sta $07                    ;otherwise set offset of 24 for small object
                memory[0x7] = A.toUByte()
                //> lda (AreaData),y           ;reload second byte of level object
                A = memory[readWord(AreaData) + Y].toInt()
                //> and #%00001111             ;mask out higher nybble and jump
                A = A and 0x0F
                //> jmp NormObj
                normObj(A, X)
                return
            }
            //> LrgObj:   sta $00                    ;store value here (branch for large objects)
            memory[0x0] = A.toUByte()
            //> cmp #$70                   ;check for vertical pipe object
            //> bne NotWPipe
            if (A == 0x70) {
                //> lda (AreaData),y           ;if not, reload second byte
                A = memory[readWord(AreaData) + Y].toInt()
                //> and #%00001000             ;mask out all but d3 (usage control bit)
                A = A and 0x08
                //> beq NotWPipe               ;if d3 clear, branch to get original value
                if (A != 0) {
                    //> lda #$00                   ;otherwise, nullify value for warp pipe
                    A = 0x00
                    //> sta $00
                    memory[0x0] = A.toUByte()
                }
            }
            //> NotWPipe: lda $00                    ;get value and jump ahead
            A = memory[0x0].toInt()
            //> jmp MoveAOId
            moveAOId(A, X)
            return
        }
    }
    //> SpecObj:  iny                        ;branch here for rows 12-15
    Y = (Y + 1) and 0xFF
    //> lda (AreaData),y
    A = memory[readWord(AreaData) + Y].toInt()
    //> and #%01110000             ;get next byte and mask out all but d6-d4
    A = A and 0x70
    //  Fall-through tail call to moveAOId
    moveAOId(A, X)
    return
}

// Decompiled from MoveAOId
fun moveAOId(A: Int, X: Int) {
    var A: Int = A
    //> MoveAOId: lsr                        ;move d6-d4 to lower nybble
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> lsr
    val orig3: Int = A
    A = orig3 shr 1
    //  Fall-through tail call to normObj
    normObj(A, X)
    return
}

// Decompiled from NormObj
fun normObj(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageLoc by MemoryByte(AreaObjectPageLoc)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var behindAreaParserFlag by MemoryByte(BehindAreaParserFlag)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var objectOffset by MemoryByte(ObjectOffset)
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
    memory[0x0] = A.toUByte()
    //> lda AreaObjectLength,x     ;is there something stored here already?
    A = areaObjectLength[X]
    //> bpl RunAObj                ;if so, branch to do its particular sub
    X = X
    if ((A and 0x80) != 0) {
        //> lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
        A = areaObjectPageLoc
        //> cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
        //> beq InitRear
        if (A != currentPageLoc) {
            //> ldy AreaDataOffset         ;if not, get old offset of level pointer
            Y = areaDataOffset
            //> lda (AreaData),y           ;and reload first byte
            A = memory[readWord(AreaData) + Y].toInt()
            //> and #%00001111
            A = A and 0x0F
            //> cmp #$0e                   ;row 14?
            //> bne LeavePar
            if (!(A == 0x0E)) {
                //  goto LeavePar -> leavePar
                leavePar()
                return
            }
            //> lda BackloadingFlag        ;if so, check backloading flag
            A = backloadingFlag
            //> bne StrAObj                ;if set, branch to render object, else leave
            if (!(A == 0)) {
                //  goto StrAObj (internal forward branch)
                //> StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
                A = areaDataOffset
                //> sta AreaObjOffsetBuffer,x
                areaObjOffsetBuffer[X] = A
                //> jsr IncAreaObjOffset       ;do sub to increment to next object data
                incAreaObjOffset()
                return
            }
            //  Fall-through tail call to leavePar
            leavePar()
            return
        }
        //> InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
        A = backloadingFlag
        //> beq BackColC               ;branch to column-wise check
        if (A != 0) {
            //> lda #$00                   ;if not, initialize both backloading and
            A = 0x00
            //> sta BackloadingFlag        ;behind-renderer flags and leave
            backloadingFlag = A
            //> sta BehindAreaParserFlag
            behindAreaParserFlag = A
            //> sta ObjectOffset
            objectOffset = A
            //  Fall-through tail call to loopCmdE
            loopCmdE()
            return
        }
        //> BackColC: ldy AreaDataOffset         ;get first byte again
        Y = areaDataOffset
        //> lda (AreaData),y
        A = memory[readWord(AreaData) + Y].toInt()
        //> and #%11110000             ;mask out low nybble and move high to low
        A = A and 0xF0
        //> lsr
        val orig0: Int = A
        A = orig0 shr 1
        //> lsr
        val orig1: Int = A
        A = orig1 shr 1
        //> lsr
        val orig2: Int = A
        A = orig2 shr 1
        //> lsr
        val orig3: Int = A
        A = orig3 shr 1
        //> cmp CurrentColumnPos       ;is this where we're at?
        //> bne LeavePar               ;if not, branch to leave
        if (A != currentColumnPos) {
            //> LeavePar: rts
            return
        }
        //> StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
        A = areaDataOffset
        //> sta AreaObjOffsetBuffer,x
        areaObjOffsetBuffer[X] = A
        //> jsr IncAreaObjOffset       ;do sub to increment to next object data
        incAreaObjOffset()
    }
    //> RunAObj:  lda $00                    ;get stored value and add offset to it
    A = memory[0x0].toInt()
    //> clc                        ;then use the jump engine with current contents of A
    //> adc $07
    temp0 = A + memory[0x7].toInt()
    A = temp0 and 0xFF
    //> jsr JumpEngine
    when (A) {
        0 -> {
            verticalPipe(X, Y)
        }
        1 -> {
            areaStyleObject(X, Y)
        }
        2 -> {
            rowOfBricks(X)
        }
        3 -> {
            rowOfSolidBlocks(X)
        }
        4 -> {
            rowOfCoins(X)
        }
        5 -> {
            columnOfBricks(X)
        }
        6 -> {
            columnOfSolidBlocks(X)
        }
        7 -> {
            verticalPipe(X, Y)
        }
        8 -> {
            holeEmpty(X, Y)
        }
        9 -> {
            pulleyRopeObject(X, Y)
        }
        10 -> {
            bridgeHigh(X, Y)
        }
        11 -> {
            bridgeMiddle()
        }
        12 -> {
            bridgeLow()
        }
        13 -> {
            holeWater(X, Y)
        }
        14 -> {
            questionblockrowHigh(X, Y)
        }
        15 -> {
            questionblockrowLow()
        }
        16 -> {
            endlessRope()
        }
        17 -> {
            balancePlatRope(X)
        }
        18 -> {
            castleObject(X, Y)
        }
        19 -> {
            staircaseObject(X, Y)
        }
        20 -> {
            exitPipe(X)
        }
        21 -> {
            flagballsResidual(X, Y)
        }
        22 -> {
            questionBlock(X, Y)
        }
        23 -> {
            questionBlock(X, Y)
        }
        24 -> {
            questionBlock(X, Y)
        }
        25 -> {
            hidden1UpBlock(X, Y)
        }
        26 -> {
            brickWithItem(X, Y)
        }
        27 -> {
            brickWithItem(X, Y)
        }
        28 -> {
            brickWithItem(X, Y)
        }
        29 -> {
            brickWithCoins(X, Y)
        }
        30 -> {
            brickWithItem(X, Y)
        }
        31 -> {
            waterPipe(X)
        }
        32 -> {
            emptyBlock(X)
        }
        33 -> {
            jumpspring(33, X)
        }
        34 -> {
            introPipe(X)
        }
        35 -> {
            flagpoleObject()
        }
        36 -> {
            axeObj()
        }
        37 -> {
            chainObj()
        }
        38 -> {
            castleBridgeObj(X)
        }
        39 -> {
            scrolllockobjectWarp()
        }
        40 -> {
            scrollLockObject()
        }
        41 -> {
            scrollLockObject()
        }
        42 -> {
            areaFrenzy()
        }
        43 -> {
            areaFrenzy()
        }
        44 -> {
            areaFrenzy()
        }
        45 -> {
            loopCmdE()
        }
        46 -> {
            alterAreaAttributes(X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> ;large objects (rows $00-$0b or 00-11, d6-d4 set)
    //> .dw VerticalPipe         ;used by warp pipes
    //> .dw AreaStyleObject
    //> .dw RowOfBricks
    //> .dw RowOfSolidBlocks
    //> .dw RowOfCoins
    //> .dw ColumnOfBricks
    //> .dw ColumnOfSolidBlocks
    //> .dw VerticalPipe         ;used by decoration pipes
    //> ;objects for special row $0c or 12
    //> .dw Hole_Empty
    //> .dw PulleyRopeObject
    //> .dw Bridge_High
    //> .dw Bridge_Middle
    //> .dw Bridge_Low
    //> .dw Hole_Water
    //> .dw QuestionBlockRow_High
    //> .dw QuestionBlockRow_Low
    //> ;objects for special row $0f or 15
    //> .dw EndlessRope
    //> .dw BalancePlatRope
    //> .dw CastleObject
    //> .dw StaircaseObject
    //> .dw ExitPipe
    //> .dw FlagBalls_Residual
    //> ;small objects (rows $00-$0b or 00-11, d6-d4 all clear)
    //> .dw QuestionBlock     ;power-up
    //> .dw QuestionBlock     ;coin
    //> .dw QuestionBlock     ;hidden, coin
    //> .dw Hidden1UpBlock    ;hidden, 1-up
    //> .dw BrickWithItem     ;brick, power-up
    //> .dw BrickWithItem     ;brick, vine
    //> .dw BrickWithItem     ;brick, star
    //> .dw BrickWithCoins    ;brick, coins
    //> .dw BrickWithItem     ;brick, 1-up
    //> .dw WaterPipe
    //> .dw EmptyBlock
    //> .dw Jumpspring
    //> ;objects for special row $0d or 13 (d6 set)
    //> .dw IntroPipe
    //> .dw FlagpoleObject
    //> .dw AxeObj
    //> .dw ChainObj
    //> .dw CastleBridgeObj
    //> .dw ScrollLockObject_Warp
    //> .dw ScrollLockObject
    //> .dw ScrollLockObject
    //> .dw AreaFrenzy            ;flying cheep-cheeps
    //> .dw AreaFrenzy            ;bullet bills or swimming cheep-cheeps
    //> .dw AreaFrenzy            ;stop frenzy
    //> .dw LoopCmdE
    //> ;object for special row $0e or 14
    //> .dw AlterAreaAttributes
    //> ;-------------------------------------------------------------------------------------
    //> ;(these apply to all area object subroutines in this section unless otherwise stated)
    //> ;$00 - used to store offset used to find object code
    //> ;$07 - starts with adder from area parser, used to store row offset
    //  Fall-through tail call to alterAreaAttributes
    alterAreaAttributes(X)
    return
}

// Decompiled from LeavePar
fun leavePar() {
    //> LeavePar: rts
    return
}

// Decompiled from LoopCmdE
fun loopCmdE() {
    //> LoopCmdE: rts
    return
}

// Decompiled from AlterAreaAttributes
fun alterAreaAttributes(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var backgroundScenery by MemoryByte(BackgroundScenery)
    var foregroundScenery by MemoryByte(ForegroundScenery)
    var terrainControl by MemoryByte(TerrainControl)
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    //> AlterAreaAttributes:
    //> ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
    Y = areaObjOffsetBuffer[X]
    //> iny                       ;load second byte
    Y = (Y + 1) and 0xFF
    //> lda (AreaData),y
    A = memory[readWord(AreaData) + Y].toInt()
    //> pha                       ;save in stack for now
    push(A)
    //> and #%01000000
    A = A and 0x40
    //> bne Alter2                ;branch if d6 is set
    X = X
    if (A == 0) {
        //> pla
        A = pull()
        //> pha                       ;pull and push offset to copy to A
        push(A)
        //> and #%00001111            ;mask out high nybble and store as
        A = A and 0x0F
        //> sta TerrainControl        ;new terrain height type bits
        terrainControl = A
        //> pla
        A = pull()
        //> and #%00110000            ;pull and mask out all but d5 and d4
        A = A and 0x30
        //> lsr                       ;move bits to lower nybble and store
        val orig0: Int = A
        A = orig0 shr 1
        //> lsr                       ;as new background scenery bits
        val orig1: Int = A
        A = orig1 shr 1
        //> lsr
        val orig2: Int = A
        A = orig2 shr 1
        //> lsr
        val orig3: Int = A
        A = orig3 shr 1
        //> sta BackgroundScenery     ;then leave
        backgroundScenery = A
        //> rts
        return
    } else {
        //> Alter2:  pla
        A = pull()
        //> and #%00000111            ;mask out all but 3 LSB
        A = A and 0x07
        //> cmp #$04                  ;if four or greater, set color control bits
        //> bcc SetFore               ;and nullify foreground scenery bits
        if (A >= 0x04) {
            //> sta BackgroundColorCtrl
            backgroundColorCtrl = A
            //> lda #$00
            A = 0x00
        }
    }
    //> SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
    foregroundScenery = A
    //> rts
    return
}

// Decompiled from ScrollLockObject_Warp
fun scrolllockobjectWarp(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    var worldNumber by MemoryByte(WorldNumber)
    //> ScrollLockObject_Warp:
    //> ldx #$04            ;load value of 4 for game text routine as default
    X = 0x04
    //> lda WorldNumber     ;warp zone (4-3-2), then check world number
    A = worldNumber
    //> beq WarpNum
    if (A != 0) {
        //> inx                 ;if world number > 1, increment for next warp zone (5)
        X = (X + 1) and 0xFF
        //> ldy AreaType        ;check area type
        Y = areaType
        //> dey
        Y = (Y - 1) and 0xFF
        //> bne WarpNum         ;if ground area type, increment for last warp zone
        if (Y == 0) {
            //> inx                 ;(8-7-6) and move on
            X = (X + 1) and 0xFF
        }
    }
    //> WarpNum: txa
    A = X
    //> sta WarpZoneControl ;store number here to be used by warp zone routine
    warpZoneControl = A
    //> jsr WriteGameText   ;print text and warp zone numbers
    writeGameText(A)
    //> lda #PiranhaPlant
    A = PiranhaPlant
    //> jsr KillEnemies     ;load identifier for piranha plants and do sub
    killEnemies(A)
    //  Fall-through tail call to scrollLockObject
    scrollLockObject()
    return X
}

// Decompiled from ScrollLockObject
fun scrollLockObject() {
    var A: Int = 0
    var scrollLock by MemoryByte(ScrollLock)
    //> ScrollLockObject:
    //> lda ScrollLock      ;invert scroll lock to turn it on
    A = scrollLock
    //> eor #%00000001
    A = A xor 0x01
    //> sta ScrollLock
    scrollLock = A
    //> rts
    return
}

// Decompiled from KillEnemies
fun killEnemies(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> KillEnemies:
    //> sta $00           ;store identifier here
    memory[0x0] = A.toUByte()
    //> lda #$00
    A = 0x00
    //> ldx #$04          ;check for identifier in enemy object buffer
    X = 0x04
    loop0@ do {
        //> KillELoop: ldy Enemy_ID,x
        Y = enemyId[X]
        //> cpy $00           ;if not found, branch
        //> bne NoKillE
        if (Y == memory[0x0].toInt()) {
            //> sta Enemy_Flag,x  ;if found, deactivate enemy object flag
            enemyFlag[X] = A
        }
        //> NoKillE:   dex               ;do this until all slots are checked
        X = (X - 1) and 0xFF
        //> bpl KillELoop
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to KillELoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> rts
    return
}

// Decompiled from AreaFrenzy
fun areaFrenzy(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var enemyFrenzyQueue by MemoryByte(EnemyFrenzyQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val frenzyIDData by MemoryByteIndexed(FrenzyIDData)
    //> AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
    X = memory[0x0].toInt()
    //> lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
    A = frenzyIDData[-8 + X]
    //> ldy #$05
    Y = 0x05
    loop0@ while ((Y and 0x80) == 0) {
        //> cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
        //> bne FreCompLoop
        if (!(A == enemyId[Y])) {
            //  continue loop (branch back to FreCompLoop)
            continue@loop0
        }
    }
    //> lda #$00              ;if enemy object already present, nullify queue and leave
    A = 0x00
    //> ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
    enemyFrenzyQueue = A
    //> rts
    return X
}

// Decompiled from AreaStyleObject
fun areaStyleObject(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var areaStyle by MemoryByte(AreaStyle)
    //> AreaStyleObject:
    //> lda AreaStyle        ;load level object style and jump to the right sub
    A = areaStyle
    //> jsr JumpEngine
    when (A) {
        0 -> {
            treeLedge(X, Y)
        }
        1 -> {
            mushroomLedge(X, Y)
        }
        2 -> {
            bulletBillCannon(X, Y)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return Pair(X, Y)
    //> .dw TreeLedge        ;also used for cloud type levels
    //> .dw MushroomLedge
    //> .dw BulletBillCannon
    //  Fall-through tail call to treeLedge
    return treeLedge(X, Y)
}

// Decompiled from TreeLedge
fun treeLedge(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> TreeLedge:
    //> jsr GetLrgObjAttrib     ;get row and length of green ledge
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> lda AreaObjectLength,x  ;check length counter for expiration
    A = areaObjectLength[X]
    //> beq EndTreeL
    X = X
    Y = temp1
    if (A != 0) {
        //> bpl MidTreeL
        if ((A and 0x80) != 0) {
            //> tya
            A = Y
            //> sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
            areaObjectLength[X] = A
            //> lda CurrentPageLoc
            A = currentPageLoc
            //> ora CurrentColumnPos    ;are we at the start of the level?
            A = A or currentColumnPos
            //> beq MidTreeL
            if (A != 0) {
                //> lda #$16                ;render start of tree ledge
                A = 0x16
                //> jmp NoUnder
                return noUnder(A)
            }
        }
        //> MidTreeL: ldx $07
        X = memory[0x7].toInt()
        //> lda #$17                ;render middle of tree ledge
        A = 0x17
        //> sta MetatileBuffer,x    ;note that this is also used if ledge position is
        metatileBuffer[X] = A
        //> lda #$4c                ;at the start of level for continuous effect
        A = 0x4C
        //> jmp AllUnder            ;now render the part underneath
        return allUnder(A, X)
    } else {
        //> EndTreeL: lda #$18                ;render end of tree ledge
        A = 0x18
        //> jmp NoUnder
        return noUnder(A)
    }
}

// Decompiled from MushroomLedge
fun mushroomLedge(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val mushroomLedgeHalfLen by MemoryByteIndexed(MushroomLedgeHalfLen)
    //> MushroomLedge:
    //> jsr ChkLrgObjLength        ;get shroom dimensions
    temp0 = chkLrgObjLength(X, Y)
    //> sty $06                    ;store length here for now
    memory[0x6] = temp0.toUByte()
    //> bcc EndMushL
    X = X
    Y = temp0
    if (flagC) {
        //> lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
        A = areaObjectLength[X]
        //> lsr
        val orig0: Int = A
        A = orig0 shr 1
        //> sta MushroomLedgeHalfLen,x
        mushroomLedgeHalfLen[X] = A
        //> lda #$19                   ;render start of mushroom
        A = 0x19
        //> jmp NoUnder
        return noUnder(A)
    } else {
        //> EndMushL: lda #$1b                   ;if at the end, render end of mushroom
        A = 0x1B
        //> ldy AreaObjectLength,x
        Y = areaObjectLength[X]
        //> beq NoUnder
        if (Y == 0) {
            //  goto NoUnder -> noUnder
            noUnder(A)
            return Pair(X, Y)
        }
    }
    //> lda MushroomLedgeHalfLen,x ;get divided length and store where length
    A = mushroomLedgeHalfLen[X]
    //> sta $06                    ;was stored originally
    memory[0x6] = A.toUByte()
    //> ldx $07
    X = memory[0x7].toInt()
    //> lda #$1a
    A = 0x1A
    //> sta MetatileBuffer,x       ;render middle of mushroom
    metatileBuffer[X] = A
    //> cpy $06                    ;are we smack dab in the center?
    //> bne MushLExit              ;if not, branch to leave
    if (!(Y == memory[0x6].toInt())) {
        //  goto MushLExit -> mushLExit
        mushLExit()
        return Pair(X, Y)
    } else {
        //> inx
        X = (X + 1) and 0xFF
        //> lda #$4f
        A = 0x4F
        //> sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
        metatileBuffer[X] = A
        //> lda #$50
        A = 0x50
        //  Fall-through tail call to allUnder
        return allUnder(A, X)
    }
}

// Decompiled from AllUnder
fun allUnder(A: Int, X: Int): Pair<Int, Int> {
    var X: Int = X
    var Y: Int = 0
    //> AllUnder: inx
    X = (X + 1) and 0xFF
    //> ldy #$0f                   ;set $0f to render all way down
    Y = 0x0F
    //> jmp RenderUnderPart       ;now render the stem of mushroom
    return renderUnderPart(A, X, Y)
}

// Decompiled from NoUnder
fun noUnder(A: Int): Pair<Int, Int> {
    var X: Int = 0
    var Y: Int = 0
    //> NoUnder:  ldx $07                    ;load row of ledge
    X = memory[0x7].toInt()
    //> ldy #$00                   ;set 0 for no bottom on this part
    Y = 0x00
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from PulleyRopeObject
fun pulleyRopeObject(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var metatileBuffer by MemoryByte(MetatileBuffer)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val pulleyRopeMetatiles by MemoryByteIndexed(PulleyRopeMetatiles)
    //> PulleyRopeObject:
    //> jsr ChkLrgObjLength       ;get length of pulley/rope object
    temp0 = chkLrgObjLength(X, Y)
    //> ldy #$00                  ;initialize metatile offset
    Y = 0x00
    //> bcs RenderPul             ;if starting, render left pulley
    X = X
    if (!flagC) {
        //> iny
        Y = (Y + 1) and 0xFF
        //> lda AreaObjectLength,x    ;if not at the end, render rope
        A = areaObjectLength[X]
        //> bne RenderPul
        if (A == 0) {
            //> iny                       ;otherwise render right pulley
            Y = (Y + 1) and 0xFF
        }
    }
    //> RenderPul: lda PulleyRopeMetatiles,y
    A = pulleyRopeMetatiles[Y]
    //> sta MetatileBuffer        ;render at the top of the screen
    metatileBuffer = A
    //  Fall-through tail call to mushLExit
    mushLExit()
    return
}

// Decompiled from MushLExit
fun mushLExit() {
    //> MushLExit: rts                       ;and leave
    return
}

// Decompiled from CastleObject
fun castleObject(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val castleMetatiles by MemoryByteIndexed(CastleMetatiles)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> CastleObject:
    //> jsr GetLrgObjAttrib      ;save lower nybble as starting row
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> sty $07                  ;if starting row is above $0a, game will crash!!!
    memory[0x7] = temp1.toUByte()
    //> ldy #$04
    Y = 0x04
    //> jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
    val flag0: Boolean = chkLrgObjFixedLength(X, Y)
    //> txa
    A = X
    //> pha                      ;save obj buffer offset to stack
    push(A)
    //> ldy AreaObjectLength,x   ;use current length as offset for castle data
    Y = areaObjectLength[X]
    //> ldx $07                  ;begin at starting row
    X = memory[0x7].toInt()
    //> lda #$0b
    A = 0x0B
    //> sta $06                  ;load upper limit of number of rows to print
    memory[0x6] = A.toUByte()
    loop0@ do {
        //> CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
        A = castleMetatiles[Y]
        //> sta MetatileBuffer,x
        metatileBuffer[X] = A
        //> inx                      ;store in buffer and increment buffer offset
        X = (X + 1) and 0xFF
        //> lda $06
        A = memory[0x6].toInt()
        //> beq ChkCFloor            ;have we reached upper limit yet?
        if (A != 0) {
            //> iny                      ;if not, increment column-wise
            Y = (Y + 1) and 0xFF
            //> iny                      ;to byte in next row
            Y = (Y + 1) and 0xFF
            //> iny
            Y = (Y + 1) and 0xFF
            //> iny
            Y = (Y + 1) and 0xFF
            //> iny
            Y = (Y + 1) and 0xFF
            //> dec $06                  ;move closer to upper limit
            memory[0x6] = ((memory[0x6].toInt() - 1) and 0xFF).toUByte()
        }
        //> ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
        //> bne CRendLoop            ;if not, go back and do another row
        if (!(X == 0x0B)) {
            //  continue loop (branch back to CRendLoop)
            continue@loop0
        }
    } while (X != 0x0B)
    //> pla
    A = pull()
    //> tax                      ;get obj buffer offset from before
    X = A
    //> lda CurrentPageLoc
    A = currentPageLoc
    //> beq ExitCastle           ;if we're at page 0, we do not need to do anything else
    if (A != 0) {
        //> lda AreaObjectLength,x   ;check length
        A = areaObjectLength[X]
        //> cmp #$01                 ;if length almost about to expire, put brick at floor
        //> beq PlayerStop
        if (A != 0x01) {
            //> ldy $07                  ;check starting row for tall castle ($00)
            Y = memory[0x7].toInt()
            //> bne NotTall
            if (Y == 0) {
                //> cmp #$03                 ;if found, then check to see if we're at the second column
                //> beq PlayerStop
                if (A == 0x03) {
                    //  goto PlayerStop (internal forward branch)
                    //> PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
                    Y = 0x52
                    //> sty MetatileBuffer+10    ;this is only done if we're on the second column
                    metatileBuffer[10] = Y
                    return X
                }
            }
            //> NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
            //> bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
            if (A == 0x02) {
                //> jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
                temp2 = getAreaObjXPosition()
                //> pha
                push(temp2)
                //> jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
                val pair1 = findEmptyEnemySlot()
                temp3 = pair1.first
                temp4 = pair1.second
                X = temp4
                //> pla
                A = pull()
                //> sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
                enemyXPosition[X] = A
                //> lda CurrentPageLoc
                A = currentPageLoc
                //> sta Enemy_PageLoc,x      ;set page location for star flag
                enemyPageloc[X] = A
                //> lda #$01
                A = 0x01
                //> sta Enemy_Y_HighPos,x    ;set vertical high byte
                enemyYHighpos[X] = A
                //> sta Enemy_Flag,x         ;set flag for buffer
                enemyFlag[X] = A
                //> lda #$90
                A = 0x90
                //> sta Enemy_Y_Position,x   ;set vertical coordinate
                enemyYPosition[X] = A
                //> lda #StarFlagObject      ;set star flag value in buffer itself
                A = StarFlagObject
                //> sta Enemy_ID,x
                enemyId[X] = A
                //> rts
                return X
            }
        }
        //> PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
        Y = 0x52
        //> sty MetatileBuffer+10    ;this is only done if we're on the second column
        metatileBuffer[10] = Y
    }
    //> ExitCastle: rts
    return X
}

// Decompiled from WaterPipe
fun waterPipe(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> WaterPipe:
    //> jsr GetLrgObjAttrib     ;get row and lower nybble
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
    Y = areaObjectLength[X]
    //> ldx $07                 ;get row
    X = memory[0x7].toInt()
    //> lda #$6b
    A = 0x6B
    //> sta MetatileBuffer,x    ;draw something here and below it
    metatileBuffer[X] = A
    //> lda #$6c
    A = 0x6C
    //> sta MetatileBuffer+1,x
    metatileBuffer[1 + X] = A
    //> rts
    return X
}

// Decompiled from IntroPipe
fun introPipe(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val verticalPipeData by MemoryByteIndexed(VerticalPipeData)
    //> IntroPipe:
    //> ldy #$03                 ;check if length set, if not set, set it
    Y = 0x03
    //> jsr ChkLrgObjFixedLength
    val flag0: Boolean = chkLrgObjFixedLength(X, Y)
    //> ldy #$0a                 ;set fixed value and render the sideways part
    Y = 0x0A
    //> jsr RenderSidewaysPipe
    val flag1: Boolean = renderSidewaysPipe(X, Y)
    //> bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
    X = X
    if (!flag1) {
        //> ldx #$06                 ;blank everything above the vertical pipe part
        X = 0x06
        loop0@ do {
            //> VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
            A = 0x00
            //> sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
            metatileBuffer[X] = A
            //> dex
            X = (X - 1) and 0xFF
            //> bpl VPipeSectLoop
            if (!((X and 0x80) != 0)) {
                //  continue loop (branch back to VPipeSectLoop)
                continue@loop0
            }
        } while ((X and 0x80) == 0)
        //> lda VerticalPipeData,y   ;draw the end of the vertical pipe part
        A = verticalPipeData[Y]
        //> sta MetatileBuffer+7
        metatileBuffer[7] = A
    }
    //> NoBlankP:      rts
    return X
}

// Decompiled from ExitPipe
fun exitPipe(X: Int): Boolean {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    //> ExitPipe:
    //> ldy #$03                 ;check if length set, if not set, set it
    Y = 0x03
    //> jsr ChkLrgObjFixedLength
    val flag0: Boolean = chkLrgObjFixedLength(X, Y)
    //> jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //  Fall-through tail call to renderSidewaysPipe
    renderSidewaysPipe(X, temp1)
    return false
}

// Decompiled from RenderSidewaysPipe
fun renderSidewaysPipe(X: Int, Y: Int): Boolean {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val sidePipeBottomPart by MemoryByteIndexed(SidePipeBottomPart)
    val sidePipeShaftData by MemoryByteIndexed(SidePipeShaftData)
    val sidePipeTopPart by MemoryByteIndexed(SidePipeTopPart)
    //> RenderSidewaysPipe:
    //> dey                       ;decrement twice to make room for shaft at bottom
    Y = (Y - 1) and 0xFF
    //> dey                       ;and store here for now as vertical length
    Y = (Y - 1) and 0xFF
    //> sty $05
    memory[0x5] = Y.toUByte()
    //> ldy AreaObjectLength,x    ;get length left over and store here
    Y = areaObjectLength[X]
    //> sty $06
    memory[0x6] = Y.toUByte()
    //> ldx $05                   ;get vertical length plus one, use as buffer offset
    X = memory[0x5].toInt()
    //> inx
    X = (X + 1) and 0xFF
    //> lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
    A = sidePipeShaftData[Y]
    //> cmp #$00
    //> beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
    if (A != 0x00) {
        //> ldx #$00
        X = 0x00
        //> ldy $05                   ;init buffer offset and get vertical length
        Y = memory[0x5].toInt()
        //> jsr RenderUnderPart       ;and render vertical shaft using tile number in A
        val pair0 = renderUnderPart(A, X, Y)
        temp0 = pair0.first
        temp1 = pair0.second
        X = temp0
        //> clc                       ;clear carry flag to be used by IntroPipe
    }
    //> DrawSidePart: ldy $06                   ;render side pipe part at the bottom
    Y = memory[0x6].toInt()
    //> lda SidePipeTopPart,y
    A = sidePipeTopPart[Y]
    //> sta MetatileBuffer,x      ;note that the pipe parts are stored
    metatileBuffer[X] = A
    //> lda SidePipeBottomPart,y  ;backwards horizontally
    A = sidePipeBottomPart[Y]
    //> sta MetatileBuffer+1,x
    metatileBuffer[1 + X] = A
    //> rts
    return false
}

// Decompiled from VerticalPipe
fun verticalPipe(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var worldNumber by MemoryByte(WorldNumber)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val verticalPipeData by MemoryByteIndexed(VerticalPipeData)
    //> VerticalPipe:
    //> jsr GetPipeHeight
    temp0 = getPipeHeight(X)
    //> lda $00                  ;check to see if value was nullified earlier
    A = memory[0x0].toInt()
    //> beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
    X = X
    Y = temp0
    if (A != 0) {
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                      ;add four if usage control bit was not set
        Y = (Y + 1) and 0xFF
    }
    //> WarpPipe: tya                      ;save value in stack
    A = Y
    //> pha
    push(A)
    //> lda AreaNumber
    A = areaNumber
    //> ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
    A = A or worldNumber
    //> beq DrawPipe
    if (A != 0) {
        //> ldy AreaObjectLength,x   ;if on second column of pipe, branch
        Y = areaObjectLength[X]
        //> beq DrawPipe             ;(because we only need to do this once)
        if (Y != 0) {
            //> jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
            val pair0 = findEmptyEnemySlot()
            temp1 = pair0.first
            temp2 = pair0.second
            X = temp2
            //> bcs DrawPipe             ;if not found, too many enemies, thus skip
            A = temp1
            Y = temp2
            if (!flagC) {
                //> jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
                temp3 = getAreaObjXPosition()
                //> clc
                //> adc #$08                 ;add eight to put the piranha plant in the center
                temp4 = temp3 + 0x08
                A = temp4 and 0xFF
                //> sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
                enemyXPosition[X] = A
                //> lda CurrentPageLoc       ;add carry to current page number
                A = currentPageLoc
                //> adc #$00
                temp5 = A + if (temp4 > 0xFF) 1 else 0
                A = temp5 and 0xFF
                //> sta Enemy_PageLoc,x      ;store as enemy's page coordinate
                enemyPageloc[X] = A
                //> lda #$01
                A = 0x01
                //> sta Enemy_Y_HighPos,x
                enemyYHighpos[X] = A
                //> sta Enemy_Flag,x         ;activate enemy flag
                enemyFlag[X] = A
                //> jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
                temp6 = getAreaObjYPosition()
                //> sta Enemy_Y_Position,x
                enemyYPosition[X] = temp6
                //> lda #PiranhaPlant        ;write piranha plant's value into buffer
                A = PiranhaPlant
                //> sta Enemy_ID,x
                enemyId[X] = A
                //> jsr InitPiranhaPlant
                initPiranhaPlant(X)
            }
        }
    }
    //> DrawPipe: pla                      ;get value saved earlier and use as Y
    A = pull()
    //> tay
    Y = A
    //> ldx $07                  ;get buffer offset
    X = memory[0x7].toInt()
    //> lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
    A = verticalPipeData[Y]
    //> sta MetatileBuffer,x     ;render the top of the pipe
    metatileBuffer[X] = A
    //> inx
    X = (X + 1) and 0xFF
    //> lda VerticalPipeData+2,y ;render the rest of the pipe
    A = verticalPipeData[2 + Y]
    //> ldy $06                  ;subtract one from length and render the part underneath
    Y = memory[0x6].toInt()
    //> dey
    Y = (Y - 1) and 0xFF
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from GetPipeHeight
fun getPipeHeight(X: Int): Int {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> GetPipeHeight:
    //> ldy #$01       ;check for length loaded, if not, load
    Y = 0x01
    //> jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
    val flag0: Boolean = chkLrgObjFixedLength(X, Y)
    //> jsr GetLrgObjAttrib
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> tya            ;get saved lower nybble as height
    A = temp1
    //> and #$07       ;save only the three lower bits as
    A = A and 0x07
    //> sta $06        ;vertical length, then load Y with
    memory[0x6] = A.toUByte()
    //> ldy AreaObjectLength,x    ;length left over
    Y = areaObjectLength[X]
    //> rts
    return Y
}

// Decompiled from FindEmptyEnemySlot
fun findEmptyEnemySlot(): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = 0
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    //> FindEmptyEnemySlot:
    //> ldx #$00          ;start at first enemy slot
    X = 0x00
    loop0@ while (X != 0) {
        //> inx
        X = (X + 1) and 0xFF
        //> cpx #$05          ;if nonzero, check next value
        //> bne EmptyChkLoop
        if (!(X == 0x05)) {
            //  continue loop (branch back to EmptyChkLoop)
            continue@loop0
        }
    }
    //> ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
    return Pair(A, X)
}

// Decompiled from Hole_Water
fun holeWater(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> Hole_Water:
    //> jsr ChkLrgObjLength   ;get low nybble and save as length
    temp0 = chkLrgObjLength(X, Y)
    //> lda #$86              ;render waves
    A = 0x86
    //> sta MetatileBuffer+10
    metatileBuffer[10] = A
    //> ldx #$0b
    X = 0x0B
    //> ldy #$01              ;now render the water underneath
    Y = 0x01
    //> lda #$87
    A = 0x87
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from QuestionBlockRow_High
fun questionblockrowHigh(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> QuestionBlockRow_High:
    //> lda #$03    ;start on the fourth row
    A = 0x03
    //> .db $2c     ;BIT instruction opcode
    //> QuestionBlockRow_Low:
    //> lda #$07             ;start on the eighth row
    //  (skipped by BIT $2C)
    //> pha                  ;save whatever row to the stack for now
    push(A)
    //> jsr ChkLrgObjLength  ;get low nybble and save as length
    temp0 = chkLrgObjLength(X, Y)
    //> pla
    A = pull()
    //> tax                  ;render question boxes with coins
    X = A
    //> lda #$c0
    A = 0xC0
    //> sta MetatileBuffer,x
    metatileBuffer[X] = A
    //> rts
    return X
}

// Decompiled from QuestionBlockRow_Low
fun questionblockrowLow() {
}

// Decompiled from Bridge_High
fun bridgeHigh(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> Bridge_High:
    //> lda #$06  ;start on the seventh row from top of screen
    A = 0x06
    //> .db $2c   ;BIT instruction opcode
    //> Bridge_Middle:
    //> lda #$07  ;start on the eighth row
    //  (skipped by BIT $2C)
    //> .db $2c   ;BIT instruction opcode
    //> Bridge_Low:
    //> lda #$09             ;start on the tenth row
    //  (skipped by BIT $2C)
    //> pha                  ;save whatever row to the stack for now
    push(A)
    //> jsr ChkLrgObjLength  ;get low nybble and save as length
    temp0 = chkLrgObjLength(X, Y)
    //> pla
    A = pull()
    //> tax                  ;render bridge railing
    X = A
    //> lda #$0b
    A = 0x0B
    //> sta MetatileBuffer,x
    metatileBuffer[X] = A
    //> inx
    X = (X + 1) and 0xFF
    //> ldy #$00             ;now render the bridge itself
    Y = 0x00
    //> lda #$63
    A = 0x63
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from Bridge_Middle
fun bridgeMiddle() {
    bridgeLow()
    return
}

// Decompiled from Bridge_Low
fun bridgeLow() {
}

// Decompiled from FlagBalls_Residual
fun flagballsResidual(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    //> FlagBalls_Residual:
    //> jsr GetLrgObjAttrib  ;get low nybble from object byte
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> ldx #$02             ;render flag balls on third row from top
    X = 0x02
    //> lda #$6d             ;of screen downwards based on low nybble
    A = 0x6D
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, temp1)
}

// Decompiled from FlagpoleObject
fun flagpoleObject(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var flagpolefnumYPos by MemoryByte(FlagpoleFNum_Y_Pos)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> FlagpoleObject:
    //> lda #$24                 ;render flagpole ball on top
    A = 0x24
    //> sta MetatileBuffer
    metatileBuffer[0] = A
    //> ldx #$01                 ;now render the flagpole shaft
    X = 0x01
    //> ldy #$08
    Y = 0x08
    //> lda #$25
    A = 0x25
    //> jsr RenderUnderPart
    val pair0 = renderUnderPart(A, X, Y)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda #$61                 ;render solid block at the bottom
    A = 0x61
    //> sta MetatileBuffer+10
    metatileBuffer[10] = A
    //> jsr GetAreaObjXPosition
    temp2 = getAreaObjXPosition()
    //> sec                      ;get pixel coordinate of where the flagpole is,
    //> sbc #$08                 ;subtract eight pixels and use as horizontal
    temp3 = temp2 - 0x08
    A = temp3 and 0xFF
    //> sta Enemy_X_Position+5   ;coordinate for the flag
    enemyXPosition[5] = A
    //> lda CurrentPageLoc
    A = currentPageLoc
    //> sbc #$00                 ;subtract borrow from page location and use as
    temp4 = A - if (temp3 >= 0) 0 else 1
    A = temp4 and 0xFF
    //> sta Enemy_PageLoc+5      ;page location for the flag
    enemyPageloc[5] = A
    //> lda #$30
    A = 0x30
    //> sta Enemy_Y_Position+5   ;set vertical coordinate for flag
    enemyYPosition[5] = A
    //> lda #$b0
    A = 0xB0
    //> sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
    flagpolefnumYPos = A
    //> lda #FlagpoleFlagObject
    A = FlagpoleFlagObject
    //> sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
    enemyId[5] = A
    //> inc Enemy_Flag+5         ;use last space in enemy object buffer
    enemyFlag[5] = (enemyFlag[5] + 1) and 0xFF
    //> rts
    return temp0
}

// Decompiled from EndlessRope
fun endlessRope(): Pair<Int, Int> {
    var X: Int = 0
    var Y: Int = 0
    //> EndlessRope:
    //> ldx #$00       ;render rope from the top to the bottom of screen
    X = 0x00
    //> ldy #$0f
    Y = 0x0F
    //> jmp DrawRope
    return drawRope(X, Y)
}

// Decompiled from BalancePlatRope
fun balancePlatRope(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    //> BalancePlatRope:
    //> txa                 ;save object buffer offset for now
    A = X
    //> pha
    push(A)
    //> ldx #$01            ;blank out all from second row to the bottom
    X = 0x01
    //> ldy #$0f            ;with blank used for balance platform rope
    Y = 0x0F
    //> lda #$44
    A = 0x44
    //> jsr RenderUnderPart
    val pair0 = renderUnderPart(A, X, Y)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> pla                 ;get back object buffer offset
    A = pull()
    //> tax
    X = A
    //> jsr GetLrgObjAttrib ;get vertical length from lower nybble
    val pair1 = getLrgObjAttrib(X)
    temp2 = pair1.first
    temp3 = pair1.second
    //> ldx #$01
    X = 0x01
    //  Fall-through tail call to drawRope
    return drawRope(X, temp3)
}

// Decompiled from DrawRope
fun drawRope(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    //> DrawRope: lda #$40            ;render the actual rope
    A = 0x40
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from RowOfCoins
fun rowOfCoins(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    val coinMetatileData by MemoryByteIndexed(CoinMetatileData)
    //> RowOfCoins:
    //> ldy AreaType            ;get area type
    Y = areaType
    //> lda CoinMetatileData,y  ;load appropriate coin metatile
    A = coinMetatileData[Y]
    //> jmp GetRow
    return getRow(A, X, Y)
}

// Decompiled from CastleBridgeObj
fun castleBridgeObj(X: Int): Pair<Int, Int> {
    var Y: Int = 0
    //> CastleBridgeObj:
    //> ldy #$0c                  ;load length of 13 columns
    Y = 0x0C
    //> jsr ChkLrgObjFixedLength
    val flag0: Boolean = chkLrgObjFixedLength(X, Y)
    //> jmp ChainObj
    return chainObj()
}

// Decompiled from AxeObj
fun axeObj(): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> AxeObj:
    //> lda #$08                  ;load bowser's palette into sprite portion of palette
    A = 0x08
    //> sta VRAM_Buffer_AddrCtrl
    vramBufferAddrctrl = A
    //  Fall-through tail call to chainObj
    return chainObj()
}

// Decompiled from ChainObj
fun chainObj(): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    val cObjectmetatile by MemoryByteIndexed(C_ObjectMetatile)
    val cObjectrow by MemoryByteIndexed(C_ObjectRow)
    //> ChainObj:
    //> ldy $00                   ;get value loaded earlier from decoder
    Y = memory[0x0].toInt()
    //> ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
    X = cObjectrow[-2 + Y]
    //> lda C_ObjectMetatile-2,y
    A = cObjectmetatile[-2 + Y]
    //> jmp ColObj
    return colObj(A, X)
}

// Decompiled from EmptyBlock
fun emptyBlock(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    //> EmptyBlock:
    //> jsr GetLrgObjAttrib  ;get row location
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> ldx $07
    X = memory[0x7].toInt()
    //> lda #$c4
    A = 0xC4
    //  Fall-through tail call to colObj
    return colObj(A, X)
}

// Decompiled from ColObj
fun colObj(A: Int, X: Int): Pair<Int, Int> {
    var Y: Int = 0
    //> ColObj: ldy #$00             ;column length of 1
    Y = 0x00
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from RowOfBricks
fun rowOfBricks(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    val brickMetatiles by MemoryByteIndexed(BrickMetatiles)
    //> RowOfBricks:
    //> ldy AreaType           ;load area type obtained from area offset pointer
    Y = areaType
    //> lda CloudTypeOverride  ;check for cloud type override
    A = cloudTypeOverride
    //> beq DrawBricks
    X = X
    if (A != 0) {
        //> ldy #$04               ;if cloud type, override area type
        Y = 0x04
    }
    //> DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
    A = brickMetatiles[Y]
    //> jmp GetRow             ;and go render it
    return getRow(A, X, Y)
}

// Decompiled from RowOfSolidBlocks
fun rowOfSolidBlocks(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    val solidBlockMetatiles by MemoryByteIndexed(SolidBlockMetatiles)
    //> RowOfSolidBlocks:
    //> ldy AreaType               ;load area type obtained from area offset pointer
    Y = areaType
    //> lda SolidBlockMetatiles,y  ;get metatile
    A = solidBlockMetatiles[Y]
    //  Fall-through tail call to getRow
    return getRow(A, X, Y)
}

// Decompiled from GetRow
fun getRow(A: Int, X: Int, Y: Int): Pair<Int, Int> {
    var temp0: Int = 0
    //> GetRow:  pha                        ;store metatile here
    push(A)
    //> jsr ChkLrgObjLength        ;get row number, load length
    temp0 = chkLrgObjLength(X, Y)
    //  Fall-through tail call to drawRow
    return drawRow()
}

// Decompiled from DrawRow
fun drawRow(): Pair<Int, Int> {
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    //> DrawRow: ldx $07
    X = memory[0x7].toInt()
    //> ldy #$00                   ;set vertical height of 1
    Y = 0x00
    //> pla
    temp0 = pull()
    //> jmp RenderUnderPart        ;render object
    return renderUnderPart(temp0, X, Y)
}

// Decompiled from ColumnOfBricks
fun columnOfBricks(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    val brickMetatiles by MemoryByteIndexed(BrickMetatiles)
    //> ColumnOfBricks:
    //> ldy AreaType          ;load area type obtained from area offset
    Y = areaType
    //> lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
    A = brickMetatiles[Y]
    //> jmp GetRow2
    return getRow2(A, X, Y)
}

// Decompiled from ColumnOfSolidBlocks
fun columnOfSolidBlocks(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    val solidBlockMetatiles by MemoryByteIndexed(SolidBlockMetatiles)
    //> ColumnOfSolidBlocks:
    //> ldy AreaType               ;load area type obtained from area offset
    Y = areaType
    //> lda SolidBlockMetatiles,y  ;get metatile
    A = solidBlockMetatiles[Y]
    //  Fall-through tail call to getRow2
    return getRow2(A, X, Y)
}

// Decompiled from GetRow2
fun getRow2(A: Int, X: Int, Y: Int): Pair<Int, Int> {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    //> GetRow2: pha                        ;save metatile to stack for now
    push(A)
    //> jsr GetLrgObjAttrib        ;get length and row
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> pla                        ;restore metatile
    temp2 = pull()
    //> ldx $07                    ;get starting row
    X = memory[0x7].toInt()
    //> jmp RenderUnderPart        ;now render the column
    return renderUnderPart(temp2, X, temp1)
}

// Decompiled from BulletBillCannon
fun bulletBillCannon(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var cannonOffset by MemoryByte(Cannon_Offset)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val cannonPageloc by MemoryByteIndexed(Cannon_PageLoc)
    val cannonXPosition by MemoryByteIndexed(Cannon_X_Position)
    val cannonYPosition by MemoryByteIndexed(Cannon_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> BulletBillCannon:
    //> jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> ldx $07                  ;start at first row
    X = memory[0x7].toInt()
    //> lda #$64                 ;render bullet bill cannon
    A = 0x64
    //> sta MetatileBuffer,x
    metatileBuffer[X] = A
    //> inx
    X = (X + 1) and 0xFF
    //> dey                      ;done yet?
    temp1 = (temp1 - 1) and 0xFF
    //> bmi SetupCannon
    Y = temp1
    if ((temp1 and 0x80) == 0) {
        //> lda #$65                 ;if not, render middle part
        A = 0x65
        //> sta MetatileBuffer,x
        metatileBuffer[X] = A
        //> inx
        X = (X + 1) and 0xFF
        //> dey                      ;done yet?
        Y = (Y - 1) and 0xFF
        //> bmi SetupCannon
        if ((Y and 0x80) == 0) {
            //> lda #$66                 ;if not, render bottom until length expires
            A = 0x66
            //> jsr RenderUnderPart
            val pair1 = renderUnderPart(A, X, Y)
            temp2 = pair1.first
            temp3 = pair1.second
            X = temp2
        }
    }
    //> SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
    X = cannonOffset
    //> jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
    temp4 = getAreaObjYPosition()
    //> sta Cannon_Y_Position,x  ;and store it here
    cannonYPosition[X] = temp4
    //> lda CurrentPageLoc
    A = currentPageLoc
    //> sta Cannon_PageLoc,x     ;store page number for cannon here
    cannonPageloc[X] = A
    //> jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
    temp5 = getAreaObjXPosition()
    //> sta Cannon_X_Position,x  ;and store it here
    cannonXPosition[X] = temp5
    //> inx
    X = (X + 1) and 0xFF
    //> cpx #$06                 ;increment and check offset
    //> bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
    A = temp5
    if (X >= 0x06) {
        //> ldx #$00                 ;otherwise initialize it
        X = 0x00
    }
    //> StrCOffset:  stx Cannon_Offset        ;save new offset and leave
    cannonOffset = X
    //> rts
    return X
}

// Decompiled from StaircaseObject
fun staircaseObject(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var staircaseControl by MemoryByte(StaircaseControl)
    val staircaseHeightData by MemoryByteIndexed(StaircaseHeightData)
    val staircaseRowData by MemoryByteIndexed(StaircaseRowData)
    //> StaircaseObject:
    //> jsr ChkLrgObjLength       ;check and load length
    temp0 = chkLrgObjLength(X, Y)
    //> bcc NextStair             ;if length already loaded, skip init part
    X = X
    Y = temp0
    if (flagC) {
        //> lda #$09                  ;start past the end for the bottom
        A = 0x09
        //> sta StaircaseControl      ;of the staircase
        staircaseControl = A
    }
    //> NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
    staircaseControl = (staircaseControl - 1) and 0xFF
    //> ldy StaircaseControl
    Y = staircaseControl
    //> ldx StaircaseRowData,y    ;get starting row and height to render
    X = staircaseRowData[Y]
    //> lda StaircaseHeightData,y
    A = staircaseHeightData[Y]
    //> tay
    Y = A
    //> lda #$61                  ;now render solid block staircase
    A = 0x61
    //> jmp RenderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from Jumpspring
fun jumpspring(A: Int, X: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val jumpspringFixedypos by MemoryByteIndexed(Jumpspring_FixedYPos)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> Jumpspring:
    //> jsr GetLrgObjAttrib
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
    val pair1 = findEmptyEnemySlot()
    temp2 = pair1.first
    temp3 = pair1.second
    X = temp3
    //> jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
    temp4 = getAreaObjXPosition()
    //> sta Enemy_X_Position,x      ;and store
    enemyXPosition[X] = temp4
    //> lda CurrentPageLoc          ;store page location of jumpspring
    A = currentPageLoc
    //> sta Enemy_PageLoc,x
    enemyPageloc[X] = A
    //> jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
    temp5 = getAreaObjYPosition()
    //> sta Enemy_Y_Position,x      ;and store
    enemyYPosition[X] = temp5
    //> sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
    jumpspringFixedypos[X] = temp5
    //> lda #JumpspringObject
    A = JumpspringObject
    //> sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
    enemyId[X] = A
    //> ldy #$01
    Y = 0x01
    //> sty Enemy_Y_HighPos,x       ;store vertical high byte
    enemyYHighpos[X] = Y
    //> inc Enemy_Flag,x            ;set flag for enemy object buffer
    enemyFlag[X] = (enemyFlag[X] + 1) and 0xFF
    //> ldx $07
    X = memory[0x7].toInt()
    //> lda #$67                    ;draw metatiles in two rows where jumpspring is
    A = 0x67
    //> sta MetatileBuffer,x
    metatileBuffer[X] = A
    //> lda #$68
    A = 0x68
    //> sta MetatileBuffer+1,x
    metatileBuffer[1 + X] = A
    //> rts
    return X
}

// Decompiled from Hidden1UpBlock
fun hidden1UpBlock(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    //> Hidden1UpBlock:
    //> lda Hidden1UpFlag  ;if flag not set, do not render object
    A = hidden1UpFlag
    //> beq ExitDecBlock
    if (A == 0) {
        //  goto ExitDecBlock -> exitDecBlock
        exitDecBlock()
        return Pair(X, Y)
    } else {
        //> lda #$00           ;if set, init for the next one
        A = 0x00
        //> sta Hidden1UpFlag
        hidden1UpFlag = A
        //> jmp BrickWithItem  ;jump to code shared with unbreakable bricks
        return brickWithItem(X, Y)
    }
}

// Decompiled from QuestionBlock
fun questionBlock(X: Int, Y: Int): Pair<Int, Int> {
    var temp0: Int = 0
    //> QuestionBlock:
    //> jsr GetAreaObjectID ;get value from level decoder routine
    temp0 = getAreaObjectID()
    //> jmp DrawQBlk        ;go to render it
    return drawQBlk(X, temp0)
}

// Decompiled from BrickWithCoins
fun brickWithCoins(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var brickCoinTimerFlag by MemoryByte(BrickCoinTimerFlag)
    //> BrickWithCoins:
    //> lda #$00                 ;initialize multi-coin timer flag
    A = 0x00
    //> sta BrickCoinTimerFlag
    brickCoinTimerFlag = A
    //  Fall-through tail call to brickWithItem
    return brickWithItem(X, Y)
}

// Decompiled from BrickWithItem
fun brickWithItem(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    //> BrickWithItem:
    //> jsr GetAreaObjectID         ;save area object ID
    temp0 = getAreaObjectID()
    //> sty $07
    memory[0x7] = temp0.toUByte()
    //> lda #$00                    ;load default adder for bricks with lines
    A = 0x00
    //> ldy AreaType                ;check level type for ground level
    Y = areaType
    //> dey
    Y = (Y - 1) and 0xFF
    //> beq BWithL                  ;if ground type, do not start with 5
    X = X
    if (Y != 0) {
        //> lda #$05                    ;otherwise use adder for bricks without lines
        A = 0x05
    }
    //> BWithL:   clc                         ;add object ID to adder
    //> adc $07
    temp1 = A + memory[0x7].toInt()
    A = temp1 and 0xFF
    //> tay                         ;use as offset for metatile
    Y = A
    //  Fall-through tail call to drawQBlk
    return drawQBlk(X, Y)
}

// Decompiled from DrawQBlk
fun drawQBlk(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val brickQBlockMetatiles by MemoryByteIndexed(BrickQBlockMetatiles)
    //> DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
    A = brickQBlockMetatiles[Y]
    //> pha                         ;if branched to here from question block routine)
    push(A)
    //> jsr GetLrgObjAttrib         ;get row from location byte
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //> jmp DrawRow                 ;now render the object
    return drawRow()
}

// Decompiled from GetAreaObjectID
fun getAreaObjectID(): Int {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    //> GetAreaObjectID:
    //> lda $00    ;get value saved from area parser routine
    A = memory[0x0].toInt()
    //> sec
    //> sbc #$00   ;possibly residual code
    temp0 = A
    A = temp0 and 0xFF
    //> tay        ;save to Y
    Y = A
    //  Fall-through tail call to exitDecBlock
    exitDecBlock()
    return Y
}

// Decompiled from ExitDecBlock
fun exitDecBlock() {
    //> ExitDecBlock: rts
    return
}

// Decompiled from Hole_Empty
fun holeEmpty(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var areaType by MemoryByte(AreaType)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var whirlpoolOffset by MemoryByte(Whirlpool_Offset)
    val holeMetatiles by MemoryByteIndexed(HoleMetatiles)
    val whirlpoolLeftextent by MemoryByteIndexed(Whirlpool_LeftExtent)
    val whirlpoolLength by MemoryByteIndexed(Whirlpool_Length)
    val whirlpoolPageloc by MemoryByteIndexed(Whirlpool_PageLoc)
    //> Hole_Empty:
    //> jsr ChkLrgObjLength          ;get lower nybble and save as length
    temp0 = chkLrgObjLength(X, Y)
    //> bcc NoWhirlP                 ;skip this part if length already loaded
    X = X
    Y = temp0
    if (flagC) {
        //> lda AreaType                 ;check for water type level
        A = areaType
        //> bne NoWhirlP                 ;if not water type, skip this part
        if (A == 0) {
            //> ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
            X = whirlpoolOffset
            //> jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
            temp1 = getAreaObjXPosition()
            //> sec
            //> sbc #$10                     ;subtract 16 pixels
            temp2 = temp1 - 0x10
            A = temp2 and 0xFF
            //> sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
            whirlpoolLeftextent[X] = A
            //> lda CurrentPageLoc           ;get page location of where we're at
            A = currentPageLoc
            //> sbc #$00                     ;subtract borrow
            temp3 = A - if (temp2 >= 0) 0 else 1
            A = temp3 and 0xFF
            //> sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
            whirlpoolPageloc[X] = A
            //> iny
            Y = (Y + 1) and 0xFF
            //> iny                          ;increment length by 2
            Y = (Y + 1) and 0xFF
            //> tya
            A = Y
            //> asl                          ;multiply by 16 to get size of whirlpool
            val orig0: Int = A
            A = (orig0 shl 1) and 0xFF
            //> asl                          ;note that whirlpool will always be
            val orig1: Int = A
            A = (orig1 shl 1) and 0xFF
            //> asl                          ;two blocks bigger than actual size of hole
            val orig2: Int = A
            A = (orig2 shl 1) and 0xFF
            //> asl                          ;and extend one block beyond each edge
            val orig3: Int = A
            A = (orig3 shl 1) and 0xFF
            //> sta Whirlpool_Length,x       ;save size of whirlpool here
            whirlpoolLength[X] = A
            //> inx
            X = (X + 1) and 0xFF
            //> cpx #$05                     ;increment and check offset
            //> bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
            if (X >= 0x05) {
                //> ldx #$00                     ;otherwise initialize it
                X = 0x00
            }
            //> StrWOffset: stx Whirlpool_Offset         ;save new offset here
            whirlpoolOffset = X
        }
    }
    //> NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
    X = areaType
    //> lda HoleMetatiles,x          ;render the hole proper
    A = holeMetatiles[X]
    //> ldx #$08
    X = 0x08
    //> ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
    Y = 0x0F
    //> ;--------------------------------
    //  Fall-through tail call to renderUnderPart
    return renderUnderPart(A, X, Y)
}

// Decompiled from RenderUnderPart
fun renderUnderPart(A: Int, X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = A
    var X: Int = X
    var Y: Int = Y
    var areaObjectHeight by MemoryByte(AreaObjectHeight)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    X = X
    Y = Y
    loop0@ do {
        //> RenderUnderPart:
        //> sty AreaObjectHeight  ;store vertical length to render
        areaObjectHeight = Y
        //> ldy MetatileBuffer,x  ;check current spot to see if there's something
        Y = metatileBuffer[X]
        //> beq DrawThisRow       ;we need to keep, if nothing, go ahead
        A = A
        if (Y != 0) {
            //> cpy #$17
            //> beq WaitOneRow        ;if middle part (tree ledge), wait until next row
            if (Y != 0x17) {
                //> cpy #$1a
                //> beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
                if (Y != 0x1A) {
                    //> cpy #$c0
                    //> beq DrawThisRow       ;if question block w/ coin, overwrite
                    if (Y != 0xC0) {
                        //> cpy #$c0
                        //> bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
                        if (!(Y >= 0xC0)) {
                            //> cpy #$54
                            //> bne DrawThisRow       ;if cracked rock terrain, overwrite
                            if (Y == 0x54) {
                                //> cmp #$50
                                //> beq WaitOneRow        ;if stem top of mushroom, wait until next row
                                if (A == 0x50) {
                                    //  goto WaitOneRow (internal forward branch)
                                    //> WaitOneRow:  inx
                                    X = (X + 1) and 0xFF
                                    //> cpx #$0d              ;stop rendering if we're at the bottom of the screen
                                    //> bcs ExitUPartR
                                    if (X >= 0x0D) {
                                        //  goto ExitUPartR
                                        break@loop0
                                    }
                                    //> ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
                                    Y = areaObjectHeight
                                    //> dey
                                    Y = (Y - 1) and 0xFF
                                    //> bpl RenderUnderPart
                                    if (!((Y and 0x80) != 0)) {
                                        //  continue loop (branch back to RenderUnderPart)
                                        continue@loop0
                                    }
                                    return Pair(X, Y)
                                }
                            }
                        }
                    }
                }
            }
        }
        //> DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
        metatileBuffer[X] = A
        //> WaitOneRow:  inx
        X = (X + 1) and 0xFF
        //> cpx #$0d              ;stop rendering if we're at the bottom of the screen
        //> bcs ExitUPartR
        if (!(X >= 0x0D)) {
            //> ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
            Y = areaObjectHeight
            //> dey
            Y = (Y - 1) and 0xFF
            //> bpl RenderUnderPart
            if (!((Y and 0x80) != 0)) {
                //  continue loop (branch back to RenderUnderPart)
                continue@loop0
            }
        } else {
            break@loop0
        }
    } while ((Y and 0x80) == 0)
    //> ExitUPartR:  rts
    return Pair(X, Y)
}

// Decompiled from ChkLrgObjLength
fun chkLrgObjLength(X: Int, Y: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    //> ChkLrgObjLength:
    //> jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
    val pair0 = getLrgObjAttrib(X)
    temp0 = pair0.first
    temp1 = pair0.second
    //  Fall-through tail call to chkLrgObjFixedLength
    chkLrgObjFixedLength(X, temp1)
    return Y
}

// Decompiled from ChkLrgObjFixedLength
fun chkLrgObjFixedLength(X: Int, Y: Int): Boolean {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> ChkLrgObjFixedLength:
    //> lda AreaObjectLength,x  ;check for set length counter
    A = areaObjectLength[X]
    //> clc                     ;clear carry flag for not just starting
    //> bpl LenSet              ;if counter not set, load it, otherwise leave alone
    X = X
    Y = Y
    if ((A and 0x80) != 0) {
        //> tya                     ;save length into length counter
        A = Y
        //> sta AreaObjectLength,x
        areaObjectLength[X] = A
        //> sec                     ;set carry flag if just starting
    }
    //> LenSet: rts
    return false
}

// Decompiled from GetLrgObjAttrib
fun getLrgObjAttrib(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    //> GetLrgObjAttrib:
    //> ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
    Y = areaObjOffsetBuffer[X]
    //> lda (AreaData),y          ;get first byte of level object
    A = memory[readWord(AreaData) + Y].toInt()
    //> and #%00001111
    A = A and 0x0F
    //> sta $07                   ;save row location
    memory[0x7] = A.toUByte()
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda (AreaData),y          ;get next byte, save lower nybble (length or height)
    A = memory[readWord(AreaData) + Y].toInt()
    //> and #%00001111            ;as Y, then leave
    A = A and 0x0F
    //> tay
    Y = A
    //> rts
    return Pair(A, Y)
}

// Decompiled from GetAreaObjXPosition
fun getAreaObjXPosition(): Int {
    var A: Int = 0
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    //> GetAreaObjXPosition:
    //> lda CurrentColumnPos    ;multiply current offset where we're at by 16
    A = currentColumnPos
    //> asl                     ;to obtain horizontal pixel coordinate
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> rts
    return A
}

// Decompiled from GetAreaObjYPosition
fun getAreaObjYPosition(): Int {
    var A: Int = 0
    var temp0: Int = 0
    //> GetAreaObjYPosition:
    //> lda $07  ;multiply value by 16
    A = memory[0x7].toInt()
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl      ;this will give us the proper vertical pixel coordinate
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> clc
    //> adc #32  ;add 32 pixels for the status bar
    temp0 = A + 0x20
    A = temp0 and 0xFF
    //> rts
    return A
}

// Decompiled from GetBlockBufferAddr
fun getBlockBufferAddr(A: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    val blockBufferAddr by MemoryByteIndexed(BlockBufferAddr)
    //> GetBlockBufferAddr:
    //> pha                      ;take value of A, save
    push(A)
    //> lsr                      ;move high nybble to low
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> lsr
    val orig3: Int = A
    A = orig3 shr 1
    //> tay                      ;use nybble as pointer to high byte
    Y = A
    //> lda BlockBufferAddr+2,y  ;of indirect here
    A = blockBufferAddr[2 + Y]
    //> sta $07
    memory[0x7] = A.toUByte()
    //> pla
    A = pull()
    //> and #%00001111           ;pull from stack, mask out high nybble
    A = A and 0x0F
    //> clc
    //> adc BlockBufferAddr,y    ;add to low byte
    temp0 = A + blockBufferAddr[Y]
    A = temp0 and 0xFF
    //> sta $06                  ;store here and leave
    memory[0x6] = A.toUByte()
    //> rts
    return
}

// Decompiled from LoadAreaPointer
fun loadAreaPointer(A: Int): Int {
    var temp0: Int = 0
    var areaPointer by MemoryByte(AreaPointer)
    //> LoadAreaPointer:
    //> jsr FindAreaPointer  ;find it and store it here
    temp0 = findAreaPointer()
    //> sta AreaPointer
    areaPointer = temp0
    //  Fall-through tail call to getAreaType
    return getAreaType(temp0)
}

// Decompiled from GetAreaType
fun getAreaType(A: Int): Int {
    var A: Int = A
    var areaType by MemoryByte(AreaType)
    //> GetAreaType: and #%01100000       ;mask out all but d6 and d5
    A = A and 0x60
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> rol
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFE or if ((orig0 and 0x80) != 0) 1 else 0
    //> rol
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x80) != 0) 1 else 0
    //> rol                  ;make %0xx00000 into %000000xx
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFE or if ((orig2 and 0x80) != 0) 1 else 0
    //> sta AreaType         ;save 2 MSB as area type
    areaType = A
    //> rts
    return A
}

// Decompiled from FindAreaPointer
fun findAreaPointer(): Int {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var worldNumber by MemoryByte(WorldNumber)
    val areaAddrOffsets by MemoryByteIndexed(AreaAddrOffsets)
    val worldAddrOffsets by MemoryByteIndexed(WorldAddrOffsets)
    //> FindAreaPointer:
    //> ldy WorldNumber        ;load offset from world variable
    Y = worldNumber
    //> lda WorldAddrOffsets,y
    A = worldAddrOffsets[Y]
    //> clc                    ;add area number used to find data
    //> adc AreaNumber
    temp0 = A + areaNumber
    A = temp0 and 0xFF
    //> tay
    Y = A
    //> lda AreaAddrOffsets,y  ;from there we have our area pointer
    A = areaAddrOffsets[Y]
    //> rts
    return A
}

// Decompiled from GetAreaDataAddrs
fun getAreaDataAddrs() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaAddrsLOffset by MemoryByte(AreaAddrsLOffset)
    var areaDataHigh by MemoryByte(AreaDataHigh)
    var areaDataLow by MemoryByte(AreaDataLow)
    var areaPointer by MemoryByte(AreaPointer)
    var areaStyle by MemoryByte(AreaStyle)
    var areaType by MemoryByte(AreaType)
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var backgroundScenery by MemoryByte(BackgroundScenery)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var enemyDataHigh by MemoryByte(EnemyDataHigh)
    var enemyDataLow by MemoryByte(EnemyDataLow)
    var foregroundScenery by MemoryByte(ForegroundScenery)
    var gameTimerSetting by MemoryByte(GameTimerSetting)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var terrainControl by MemoryByte(TerrainControl)
    val areaDataAddrHigh by MemoryByteIndexed(AreaDataAddrHigh)
    val areaDataAddrLow by MemoryByteIndexed(AreaDataAddrLow)
    val areaDataHOffsets by MemoryByteIndexed(AreaDataHOffsets)
    val enemyAddrHOffsets by MemoryByteIndexed(EnemyAddrHOffsets)
    val enemyDataAddrHigh by MemoryByteIndexed(EnemyDataAddrHigh)
    val enemyDataAddrLow by MemoryByteIndexed(EnemyDataAddrLow)
    //> GetAreaDataAddrs:
    //> lda AreaPointer          ;use 2 MSB for Y
    A = areaPointer
    //> jsr GetAreaType
    temp0 = getAreaType(A)
    //> tay
    Y = temp0
    //> lda AreaPointer          ;mask out all but 5 LSB
    A = areaPointer
    //> and #%00011111
    A = A and 0x1F
    //> sta AreaAddrsLOffset     ;save as low offset
    areaAddrsLOffset = A
    //> lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
    A = enemyAddrHOffsets[Y]
    //> clc                      ;then add base value to 5 LSB, result
    //> adc AreaAddrsLOffset     ;becomes offset for level data
    temp1 = A + areaAddrsLOffset
    A = temp1 and 0xFF
    //> tay
    Y = A
    //> lda EnemyDataAddrLow,y   ;use offset to load pointer
    A = enemyDataAddrLow[Y]
    //> sta EnemyDataLow
    enemyDataLow = A
    //> lda EnemyDataAddrHigh,y
    A = enemyDataAddrHigh[Y]
    //> sta EnemyDataHigh
    enemyDataHigh = A
    //> ldy AreaType             ;use area type as offset
    Y = areaType
    //> lda AreaDataHOffsets,y   ;do the same thing but with different base value
    A = areaDataHOffsets[Y]
    //> clc
    //> adc AreaAddrsLOffset
    temp2 = A + areaAddrsLOffset
    A = temp2 and 0xFF
    //> tay
    Y = A
    //> lda AreaDataAddrLow,y    ;use this offset to load another pointer
    A = areaDataAddrLow[Y]
    //> sta AreaDataLow
    areaDataLow = A
    //> lda AreaDataAddrHigh,y
    A = areaDataAddrHigh[Y]
    //> sta AreaDataHigh
    areaDataHigh = A
    //> ldy #$00                 ;load first byte of header
    Y = 0x00
    //> lda (AreaData),y
    A = memory[readWord(AreaData) + Y].toInt()
    //> pha                      ;save it to the stack for now
    push(A)
    //> and #%00000111           ;save 3 LSB for foreground scenery or bg color control
    A = A and 0x07
    //> cmp #$04
    //> bcc StoreFore
    if (A >= 0x04) {
        //> sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
        backgroundColorCtrl = A
        //> lda #$00
        A = 0x00
    }
    //> StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
    foregroundScenery = A
    //> pla                      ;pull byte from stack and push it back
    A = pull()
    //> pha
    push(A)
    //> and #%00111000           ;save player entrance control bits
    A = A and 0x38
    //> lsr                      ;shift bits over to LSBs
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> sta PlayerEntranceCtrl       ;save value here as player entrance control
    playerEntranceCtrl = A
    //> pla                      ;pull byte again but do not push it back
    A = pull()
    //> and #%11000000           ;save 2 MSB for game timer setting
    A = A and 0xC0
    //> clc
    //> rol                      ;rotate bits over to LSBs
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFE
    //> rol
    val orig4: Int = A
    A = (orig4 shl 1) and 0xFE or if ((orig3 and 0x80) != 0) 1 else 0
    //> rol
    val orig5: Int = A
    A = (orig5 shl 1) and 0xFE or if ((orig4 and 0x80) != 0) 1 else 0
    //> sta GameTimerSetting     ;save value here as game timer setting
    gameTimerSetting = A
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda (AreaData),y         ;load second byte of header
    A = memory[readWord(AreaData) + Y].toInt()
    //> pha                      ;save to stack
    push(A)
    //> and #%00001111           ;mask out all but lower nybble
    A = A and 0x0F
    //> sta TerrainControl
    terrainControl = A
    //> pla                      ;pull and push byte to copy it to A
    A = pull()
    //> pha
    push(A)
    //> and #%00110000           ;save 2 MSB for background scenery type
    A = A and 0x30
    //> lsr
    val orig6: Int = A
    A = orig6 shr 1
    //> lsr                      ;shift bits to LSBs
    val orig7: Int = A
    A = orig7 shr 1
    //> lsr
    val orig8: Int = A
    A = orig8 shr 1
    //> lsr
    val orig9: Int = A
    A = orig9 shr 1
    //> sta BackgroundScenery    ;save as background scenery
    backgroundScenery = A
    //> pla
    A = pull()
    //> and #%11000000
    A = A and 0xC0
    //> clc
    //> rol                      ;rotate bits over to LSBs
    val orig10: Int = A
    A = (orig10 shl 1) and 0xFE
    //> rol
    val orig11: Int = A
    A = (orig11 shl 1) and 0xFE or if ((orig10 and 0x80) != 0) 1 else 0
    //> rol
    val orig12: Int = A
    A = (orig12 shl 1) and 0xFE or if ((orig11 and 0x80) != 0) 1 else 0
    //> cmp #%00000011           ;if set to 3, store here
    //> bne StoreStyle           ;and nullify other value
    if (A == 0x03) {
        //> sta CloudTypeOverride    ;otherwise store value in other place
        cloudTypeOverride = A
        //> lda #$00
        A = 0x00
    }
    //> StoreStyle: sta AreaStyle
    areaStyle = A
    //> lda AreaDataLow          ;increment area data address by 2 bytes
    A = areaDataLow
    //> clc
    //> adc #$02
    temp3 = A + 0x02
    A = temp3 and 0xFF
    //> sta AreaDataLow
    areaDataLow = A
    //> lda AreaDataHigh
    A = areaDataHigh
    //> adc #$00
    temp4 = A + if (temp3 > 0xFF) 1 else 0
    A = temp4 and 0xFF
    //> sta AreaDataHigh
    areaDataHigh = A
    //> rts
    return
}

// Decompiled from GameMode
fun gameMode() {
    var A: Int = 0
    var opermodeTask by MemoryByte(OperMode_Task)
    //> GameMode:
    //> lda OperMode_Task
    A = opermodeTask
    //> jsr JumpEngine
    when (A) {
        0 -> {
            initializeArea()
        }
        1 -> {
            screenRoutines()
        }
        2 -> {
            secondaryGameSetup()
        }
        3 -> {
            gameCoreRoutine()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw InitializeArea
    //> .dw ScreenRoutines
    //> .dw SecondaryGameSetup
    //> .dw GameCoreRoutine
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to gameCoreRoutine
    gameCoreRoutine()
    return
}

// Decompiled from GameCoreRoutine
fun gameCoreRoutine() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var frameCounter by MemoryByte(FrameCounter)
    var intervalTimerControl by MemoryByte(IntervalTimerControl)
    var objectOffset by MemoryByte(ObjectOffset)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    val savedJoypadBits by MemoryByteIndexed(SavedJoypadBits)
    //> GameCoreRoutine:
    //> ldx CurrentPlayer          ;get which player is on the screen
    X = currentPlayer
    //> lda SavedJoypadBits,x      ;use appropriate player's controller bits
    A = savedJoypadBits[X]
    //> sta SavedJoypadBits        ;as the master controller bits
    savedJoypadBits[0] = A
    //> jsr GameRoutines           ;execute one of many possible subs
    gameRoutines()
    //> lda OperMode_Task          ;check major task of operating mode
    A = opermodeTask
    //> cmp #$03                   ;if we are supposed to be here,
    //> bcs GameEngine             ;branch to the game engine itself
    if (!(A >= 0x03)) {
        //> rts
        return
    } else {
        //> GameEngine:
        //> jsr ProcFireball_Bubble    ;process fireballs and air bubbles
        procfireballBubble()
        //> ldx #$00
        X = 0x00
    }
    loop0@ do {
        //> ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
        objectOffset = X
        //> jsr EnemiesAndLoopsCore    ;process enemy objects
        temp0 = enemiesAndLoopsCore(X)
        X = temp0
        //> jsr FloateyNumbersRoutine  ;process floatey numbers
        temp1 = floateyNumbersRoutine(temp0)
        X = temp1
        //> inx
        temp1 = (temp1 + 1) and 0xFF
        //> cpx #$06                   ;do these two subroutines until the whole buffer is done
        //> bne ProcELoop
        if (!(temp1 == 0x06)) {
            //  continue loop (branch back to ProcELoop)
            continue@loop0
        }
    } while (temp1 != 0x06)
    //> jsr GetPlayerOffscreenBits ;get offscreen bits for player object
    temp2 = getPlayerOffscreenBits()
    X = temp2
    //> jsr RelativePlayerPosition ;get relative coordinates for player object
    temp3 = relativePlayerPosition()
    X = temp3
    //> jsr PlayerGfxHandler       ;draw the player
    playerGfxHandler()
    //> jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
    blockobjmtUpdater()
    //> ldx #$01
    X = 0x01
    //> stx ObjectOffset           ;set offset for second
    objectOffset = X
    //> jsr BlockObjectsCore       ;process second block object
    temp4 = blockObjectsCore(X)
    X = temp4
    //> dex
    temp4 = (temp4 - 1) and 0xFF
    //> stx ObjectOffset           ;set offset for first
    objectOffset = temp4
    //> jsr BlockObjectsCore       ;process first block object
    temp5 = blockObjectsCore(temp4)
    X = temp5
    //> jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
    miscObjectsCore()
    //> jsr ProcessCannons         ;process bullet bill cannons
    processCannons()
    //> jsr ProcessWhirlpools      ;process whirlpools
    processWhirlpools()
    //> jsr FlagpoleRoutine        ;process the flagpole
    flagpoleRoutine()
    //> jsr RunGameTimer           ;count down the game timer
    runGameTimer()
    //> jsr ColorRotation          ;cycle one of the background colors
    colorRotation()
    //> lda Player_Y_HighPos
    A = playerYHighpos
    //> cmp #$02                   ;if player is below the screen, don't bother with the music
    //> bpl NoChgMus
    X = temp5
    if (((A - 0x02) and 0xFF and 0x80) != 0) {
        //> lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
        A = starInvincibleTimer
        //> beq ClrPlrPal              ;skip this part
        if (A != 0) {
            //> cmp #$04
            //> bne NoChgMus               ;if not yet at a certain point, continue
            if (A == 0x04) {
                //> lda IntervalTimerControl   ;if interval timer not yet expired,
                A = intervalTimerControl
                //> bne NoChgMus               ;branch ahead, don't bother with the music
                if (A == 0) {
                    //> jsr GetAreaMusic           ;to re-attain appropriate level music
                    getAreaMusic()
                }
            }
        }
    }
    //> NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
    Y = starInvincibleTimer
    //> lda FrameCounter           ;get frame counter
    A = frameCounter
    //> cpy #$08                   ;if timer still above certain point,
    //> bcs CycleTwo               ;branch to cycle player's palette quickly
    if (!(Y >= 0x08)) {
        //> lsr                        ;otherwise, divide by 8 to cycle every eighth frame
        val orig0: Int = A
        A = orig0 shr 1
        //> lsr
        val orig1: Int = A
        A = orig1 shr 1
    }
    //> CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
    val orig2: Int = A
    A = orig2 shr 1
    //> jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
    cyclePlayerPalette(A)
    //> jmp SaveAB                 ;then skip this sub to finish up the game engine
    saveAB()
    return
    //> ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
    resetPalStar()
    //  Fall-through tail call to saveAB
    saveAB()
    return
}

// Decompiled from SaveAB
fun saveAB() {
    var A: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    //> SaveAB:       lda A_B_Buttons            ;save current A and B button
    A = aBButtons
    //> sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
    previousaBButtons = A
    //> lda #$00
    A = 0x00
    //> sta Left_Right_Buttons     ;nullify left and right buttons temp variable
    leftRightButtons = A
    //  Fall-through tail call to updScrollVar
    updScrollVar()
    return
}

// Decompiled from UpdScrollVar
fun updScrollVar() {
    var A: Int = 0
    var temp0: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var scrollThirtyTwo by MemoryByte(ScrollThirtyTwo)
    var vramBuffer2Offset by MemoryByte(VRAM_Buffer2_Offset)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> UpdScrollVar: lda VRAM_Buffer_AddrCtrl
    A = vramBufferAddrctrl
    //> cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
    //> beq ExitEng                ;then branch to leave
    if (A != 0x06) {
        //> lda AreaParserTaskNum      ;otherwise check number of tasks
        A = areaParserTaskNum
        //> bne RunParser
        if (A == 0) {
            //> lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
            A = scrollThirtyTwo
            //> cmp #$20                   ;check to see if exceeded $21
            //> bmi ExitEng                ;branch to leave if not
            if (((A - 0x20) and 0xFF and 0x80) == 0) {
                //> lda ScrollThirtyTwo
                A = scrollThirtyTwo
                //> sbc #$20                   ;otherwise subtract $20 to set appropriately
                temp0 = A - 0x20 - if (A >= 0x20) 0 else 1
                A = temp0 and 0xFF
                //> sta ScrollThirtyTwo        ;and store
                scrollThirtyTwo = A
                //> lda #$00                   ;reset vram buffer offset used in conjunction with
                A = 0x00
                //> sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
                vramBuffer2Offset = A
            }
        }
        //> RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
        areaParserTaskHandler()
    }
    //> ExitEng:      rts                        ;and after all that, we're finally done!
    return
}

// Decompiled from ScrollHandler
fun scrollHandler() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var platformXScroll by MemoryByte(Platform_X_Scroll)
    var playerPosForscroll by MemoryByte(Player_Pos_ForScroll)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    var scrollAmount by MemoryByte(ScrollAmount)
    var scrollLock by MemoryByte(ScrollLock)
    var sideCollisionTimer by MemoryByte(SideCollisionTimer)
    //> ScrollHandler:
    //> lda Player_X_Scroll       ;load value saved here
    A = playerXScroll
    //> clc
    //> adc Platform_X_Scroll     ;add value used by left/right platforms
    temp0 = A + platformXScroll
    A = temp0 and 0xFF
    //> sta Player_X_Scroll       ;save as new value here to impose force on scroll
    playerXScroll = A
    //> lda ScrollLock            ;check scroll lock flag
    A = scrollLock
    //> bne InitScrlAmt           ;skip a bunch of code here if set
    if (A == 0) {
        //> lda Player_Pos_ForScroll
        A = playerPosForscroll
        //> cmp #$50                  ;check player's horizontal screen position
        //> bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
        if (A >= 0x50) {
            //> lda SideCollisionTimer    ;if timer related to player's side collision
            A = sideCollisionTimer
            //> bne InitScrlAmt           ;not expired, branch
            if (A == 0) {
                //> ldy Player_X_Scroll       ;get value and decrement by one
                Y = playerXScroll
                //> dey                       ;if value originally set to zero or otherwise
                Y = (Y - 1) and 0xFF
                //> bmi InitScrlAmt           ;negative for left movement, branch
                if ((Y and 0x80) == 0) {
                    //> iny
                    Y = (Y + 1) and 0xFF
                    //> cpy #$02                  ;if value $01, branch and do not decrement
                    //> bcc ChkNearMid
                    if (Y >= 0x02) {
                        //> dey                       ;otherwise decrement by one
                        Y = (Y - 1) and 0xFF
                    }
                    //> ChkNearMid: lda Player_Pos_ForScroll
                    A = playerPosForscroll
                    //> cmp #$70                  ;check player's horizontal screen position
                    //> bcc ScrollScreen          ;if less than 112 pixels to the right, branch
                    if (!(A >= 0x70)) {
                        //  goto ScrollScreen -> scrollScreen
                        scrollScreen(Y)
                        return
                    }
                    //> ldy Player_X_Scroll       ;otherwise get original value undecremented
                    Y = playerXScroll
                    //  Fall-through tail call to scrollScreen
                    scrollScreen(Y)
                    return
                }
            }
        }
    }
    //> InitScrlAmt:  lda #$00
    A = 0x00
    //> sta ScrollAmount          ;initialize value here
    scrollAmount = A
    //  Fall-through tail call to chkPOffscr
    chkPOffscr(A)
    return
}

// Decompiled from ScrollScreen
fun scrollScreen(Y: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var horizontalScroll by MemoryByte(HorizontalScroll)
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var scrollAmount by MemoryByte(ScrollAmount)
    var scrollIntervalTimer by MemoryByte(ScrollIntervalTimer)
    var scrollThirtyTwo by MemoryByte(ScrollThirtyTwo)
    //> ScrollScreen:
    //> tya
    A = Y
    //> sta ScrollAmount          ;save value here
    scrollAmount = A
    //> clc
    //> adc ScrollThirtyTwo       ;add to value already set here
    temp0 = A + scrollThirtyTwo
    //> sta ScrollThirtyTwo       ;save as new value here
    scrollThirtyTwo = temp0 and 0xFF
    //> tya
    A = Y
    //> clc
    //> adc ScreenLeft_X_Pos      ;add to left side coordinate
    temp1 = A + screenleftXPos
    //> sta ScreenLeft_X_Pos      ;save as new left side coordinate
    screenleftXPos = temp1 and 0xFF
    //> sta HorizontalScroll      ;save here also
    horizontalScroll = temp1 and 0xFF
    //> lda ScreenLeft_PageLoc
    A = screenleftPageloc
    //> adc #$00                  ;add carry to page location for left
    temp2 = A + if (temp1 > 0xFF) 1 else 0
    A = temp2 and 0xFF
    //> sta ScreenLeft_PageLoc    ;side of the screen
    screenleftPageloc = A
    //> and #$01                  ;get LSB of page location
    A = A and 0x01
    //> sta $00                   ;save as temp variable for PPU register 1 mirror
    memory[0x0] = A.toUByte()
    //> lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
    A = mirrorPpuCtrlReg1
    //> and #%11111110            ;save all bits except d0
    A = A and 0xFE
    //> ora $00                   ;get saved bit here and save in PPU register 1
    A = A or memory[0x0].toInt()
    //> sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
    mirrorPpuCtrlReg1 = A
    //> jsr GetScreenPosition     ;figure out where the right side is
    temp3 = getScreenPosition()
    //> lda #$08
    A = 0x08
    //> sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
    scrollIntervalTimer = A
    //> jmp ChkPOffscr            ;skip this part
    chkPOffscr(A)
    return
}

// Decompiled from ChkPOffscr
fun chkPOffscr(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var platformXScroll by MemoryByte(Platform_X_Scroll)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    val offscrJoypadBitsData by MemoryByteIndexed(OffscrJoypadBitsData)
    val screenedgePageloc by MemoryByteIndexed(ScreenEdge_PageLoc)
    val screenedgeXPos by MemoryByteIndexed(ScreenEdge_X_Pos)
    val xSubtracterdata by MemoryByteIndexed(X_SubtracterData)
    //> ChkPOffscr:   ldx #$00                  ;set X for player offset
    X = 0x00
    //> jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
    val pair0 = getXOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> sta $00                   ;save them here
    memory[0x0] = temp0.toUByte()
    //> ldy #$00                  ;load default offset (left side)
    Y = 0x00
    //> asl                       ;if d7 of offscreen bits are set,
    val orig0: Int = temp0
    temp0 = (orig0 shl 1) and 0xFF
    //> bcs KeepOnscr             ;branch with default offset
    A = temp0
    if ((orig0 and 0x80) == 0) {
        //> iny                         ;otherwise use different offset (right side)
        Y = (Y + 1) and 0xFF
        //> lda $00
        A = memory[0x0].toInt()
        //> and #%00100000              ;check offscreen bits for d5 set
        A = A and 0x20
        //> beq InitPlatScrl            ;if not set, branch ahead of this part
        if (A == 0) {
            //  goto InitPlatScrl (internal forward branch)
            //> InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
            A = 0x00
            //> sta Platform_X_Scroll
            platformXScroll = A
            //> rts
            return
        }
    }
    //> KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
    A = screenedgeXPos[Y]
    //> sec
    //> sbc X_SubtracterData,y      ;subtract amount based on offset
    temp2 = A - xSubtracterdata[Y]
    A = temp2 and 0xFF
    //> sta Player_X_Position       ;store as player position to prevent movement further
    playerXPosition = A
    //> lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
    A = screenedgePageloc[Y]
    //> sbc #$00                    ;subtract borrow
    temp3 = A - if (temp2 >= 0) 0 else 1
    A = temp3 and 0xFF
    //> sta Player_PageLoc          ;save as player's page location
    playerPageloc = A
    //> lda Left_Right_Buttons      ;check saved controller bits
    A = leftRightButtons
    //> cmp OffscrJoypadBitsData,y  ;against bits based on offset
    //> beq InitPlatScrl            ;if not equal, branch
    if (A != offscrJoypadBitsData[Y]) {
        //> lda #$00
        A = 0x00
        //> sta Player_X_Speed          ;otherwise nullify horizontal speed of player
        playerXSpeed = A
    }
    //> InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
    A = 0x00
    //> sta Platform_X_Scroll
    platformXScroll = A
    //> rts
    return
}

// Decompiled from GetScreenPosition
fun getScreenPosition(): Int {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    //> GetScreenPosition:
    //> lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
    A = screenleftXPos
    //> clc
    //> adc #$ff                ;add 255 pixels
    temp0 = A + 0xFF
    A = temp0 and 0xFF
    //> sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
    screenrightXPos = A
    //> lda ScreenLeft_PageLoc  ;get page number where left boundary is
    A = screenleftPageloc
    //> adc #$00                ;add carry from before
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta ScreenRight_PageLoc ;store as page number where right boundary is
    screenrightPageloc = A
    //> rts
    return A
}

// Decompiled from GameRoutines
fun gameRoutines() {
    var A: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    //> GameRoutines:
    //> lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
    A = gameEngineSubroutine
    //> jsr JumpEngine            ;merely placeholders as conditions for other routines)
    when (A) {
        0 -> {
            entranceGametimersetup()
        }
        1 -> {
            vineAutoclimb()
        }
        2 -> {
            sideExitPipeEntry()
        }
        3 -> {
            verticalPipeEntry()
        }
        4 -> {
            flagpoleSlide()
        }
        5 -> {
            playerEndLevel()
        }
        6 -> {
            playerLoseLife()
        }
        7 -> {
            playerEntrance()
        }
        8 -> {
            playerCtrlRoutine()
        }
        9 -> {
            playerChangeSize()
        }
        10 -> {
            playerInjuryBlink()
        }
        11 -> {
            playerDeath()
        }
        12 -> {
            playerFireFlower()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw Entrance_GameTimerSetup
    //> .dw Vine_AutoClimb
    //> .dw SideExitPipeEntry
    //> .dw VerticalPipeEntry
    //> .dw FlagpoleSlide
    //> .dw PlayerEndLevel
    //> .dw PlayerLoseLife
    //> .dw PlayerEntrance
    //> .dw PlayerCtrlRoutine
    //> .dw PlayerChangeSize
    //> .dw PlayerInjuryBlink
    //> .dw PlayerDeath
    //> .dw PlayerFireFlower
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to playerEntrance
    playerEntrance()
    return
}

// Decompiled from PlayerEntrance
fun playerEntrance() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    var disableCollisionDet by MemoryByte(DisableCollisionDet)
    var disableIntermediate by MemoryByte(DisableIntermediate)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var joypadOverride by MemoryByte(JoypadOverride)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var vineHeight by MemoryByte(VineHeight)
    val blockBuffer1 by MemoryByteIndexed(Block_Buffer_1)
    //> PlayerEntrance:
    //> lda AltEntranceControl    ;check for mode of alternate entry
    A = altEntranceControl
    //> cmp #$02
    //> beq EntrMode2             ;if found, branch to enter from pipe or with vine
    if (A != 0x02) {
        //> lda #$00
        A = 0x00
        //> ldy Player_Y_Position     ;if vertical position above a certain
        Y = playerYPosition
        //> cpy #$30                  ;point, nullify controller bits and continue
        //> bcc AutoControlPlayer     ;with player movement code, do not return
        if (!(Y >= 0x30)) {
            //  goto AutoControlPlayer -> autoControlPlayer
            autoControlPlayer(A)
            return
        }
        //> lda PlayerEntranceCtrl    ;check player entry bits from header
        A = playerEntranceCtrl
        //> cmp #$06
        //> beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
        if (A != 0x06) {
            //> cmp #$07                  ;otherwise branch to normal entry
            //> bne PlayerRdy
            if (!(A == 0x07)) {
                //  goto PlayerRdy (internal forward branch)
                //> PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
                A = 0x08
                //> sta GameEngineSubroutine
                gameEngineSubroutine = A
                //> lda #$01                  ;set to face player to the right
                A = 0x01
                //> sta PlayerFacingDir
                playerFacingDir = A
                //> lsr                       ;init A
                val orig0: Int = A
                A = orig0 shr 1
                //> sta AltEntranceControl    ;init mode of entry
                altEntranceControl = A
                //> sta DisableCollisionDet   ;init collision detection disable flag
                disableCollisionDet = A
                //> sta JoypadOverride        ;nullify controller override bits
                joypadOverride = A
                return
            }
        }
        //> ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
        A = playerSprattrib
        //> bne IntroEntr             ;branch if found
        if (A == 0) {
            //> lda #$01
            A = 0x01
            //> jmp AutoControlPlayer     ;force player to walk to the right
            autoControlPlayer(A)
            return
        }
        //> IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
        temp0 = enterSidePipe()
        //> dec ChangeAreaTimer       ;decrement timer for change of area
        changeAreaTimer = (changeAreaTimer - 1) and 0xFF
        //> bne ExitEntr              ;branch to exit if not yet expired
        A = temp0
        if (changeAreaTimer == 0) {
            //> inc DisableIntermediate   ;set flag to skip world and lives display
            disableIntermediate = (disableIntermediate + 1) and 0xFF
            //> jmp NextArea              ;jump to increment to next area and set modes
            nextArea(A)
            return
        }
    }
    //> EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
    A = joypadOverride
    //> bne VineEntr              ;branch to enter with vine
    if (A == 0) {
        //> lda #$ff                  ;otherwise, set value here then execute sub
        A = 0xFF
        //> jsr MovePlayerYAxis       ;to move player upwards (note $ff = -1)
        movePlayerYAxis(A)
        //> lda Player_Y_Position     ;check to see if player is at a specific coordinate
        A = playerYPosition
        //> cmp #$91                  ;if player risen to a certain point (this requires pipes
        //> bcc PlayerRdy             ;to be at specific height to look/function right) branch
        if (A >= 0x91) {
            //> rts                       ;to the last part, otherwise leave
            return
        }
    }
    //> VineEntr:   lda VineHeight
    A = vineHeight
    //> cmp #$60                  ;check vine height
    //> bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
    if (A == 0x60) {
        //> lda Player_Y_Position     ;get player's vertical coordinate
        A = playerYPosition
        //> cmp #$99                  ;check player's vertical coordinate against preset value
        //> ldy #$00                  ;load default values to be written to
        Y = 0x00
        //> lda #$01                  ;this value moves player to the right off the vine
        A = 0x01
        //> bcc OffVine               ;if vertical coordinate < preset value, use defaults
        if (A >= 0x99) {
            //> lda #$03
            A = 0x03
            //> sta Player_State          ;otherwise set player state to climbing
            playerState = A
            //> iny                       ;increment value in Y
            Y = (Y + 1) and 0xFF
            //> lda #$08                  ;set block in block buffer to cover hole, then
            A = 0x08
            //> sta Block_Buffer_1+$b4    ;use same value to force player to climb
            blockBuffer1[180] = A
        }
        //> OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
        disableCollisionDet = Y
        //> jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
        autoControlPlayer(A)
        //> lda Player_X_Position
        A = playerXPosition
        //> cmp #$48                  ;check player's horizontal position
        //> bcc ExitEntr              ;if not far enough to the right, branch to leave
        if (A >= 0x48) {
            //> PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
            A = 0x08
            //> sta GameEngineSubroutine
            gameEngineSubroutine = A
            //> lda #$01                  ;set to face player to the right
            A = 0x01
            //> sta PlayerFacingDir
            playerFacingDir = A
            //> lsr                       ;init A
            val orig1: Int = A
            A = orig1 shr 1
            //> sta AltEntranceControl    ;init mode of entry
            altEntranceControl = A
            //> sta DisableCollisionDet   ;init collision detection disable flag
            disableCollisionDet = A
            //> sta JoypadOverride        ;nullify controller override bits
            joypadOverride = A
        }
    }
    //> ExitEntr:   rts                       ;leave!
    return
}

// Decompiled from AutoControlPlayer
fun autoControlPlayer(A: Int) {
    var savedJoypadBits by MemoryByte(SavedJoypadBits)
    //> AutoControlPlayer:
    //> sta SavedJoypadBits         ;override controller bits with contents of A if executing here
    savedJoypadBits = A
    //  Fall-through tail call to playerCtrlRoutine
    playerCtrlRoutine()
    return
}

// Decompiled from PlayerCtrlRoutine
fun playerCtrlRoutine() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp16: Int = 0
    var temp17: Int = 0
    var temp18: Int = 0
    var temp19: Int = 0
    var temp2: Int = 0
    var temp20: Int = 0
    var temp21: Int = 0
    var temp22: Int = 0
    var temp23: Int = 0
    var temp24: Int = 0
    var temp25: Int = 0
    var temp26: Int = 0
    var temp27: Int = 0
    var temp28: Int = 0
    var temp29: Int = 0
    var temp3: Int = 0
    var temp30: Int = 0
    var temp31: Int = 0
    var temp32: Int = 0
    var temp33: Int = 0
    var temp34: Int = 0
    var temp35: Int = 0
    var temp36: Int = 0
    var temp37: Int = 0
    var temp38: Int = 0
    var temp39: Int = 0
    var temp4: Int = 0
    var temp40: Int = 0
    var temp41: Int = 0
    var temp42: Int = 0
    var temp43: Int = 0
    var temp44: Int = 0
    var temp45: Int = 0
    var temp46: Int = 0
    var temp47: Int = 0
    var temp48: Int = 0
    var temp49: Int = 0
    var temp5: Int = 0
    var temp50: Int = 0
    var temp51: Int = 0
    var temp52: Int = 0
    var temp53: Int = 0
    var temp54: Int = 0
    var temp55: Int = 0
    var temp56: Int = 0
    var temp57: Int = 0
    var temp58: Int = 0
    var temp59: Int = 0
    var temp6: Int = 0
    var temp60: Int = 0
    var temp61: Int = 0
    var temp62: Int = 0
    var temp63: Int = 0
    var temp64: Int = 0
    var temp65: Int = 0
    var temp66: Int = 0
    var temp67: Int = 0
    var temp68: Int = 0
    var temp69: Int = 0
    var temp7: Int = 0
    var temp70: Int = 0
    var temp71: Int = 0
    var temp72: Int = 0
    var temp73: Int = 0
    var temp74: Int = 0
    var temp75: Int = 0
    var temp76: Int = 0
    var temp77: Int = 0
    var temp78: Int = 0
    var temp79: Int = 0
    var temp8: Int = 0
    var temp80: Int = 0
    var temp81: Int = 0
    var temp82: Int = 0
    var temp83: Int = 0
    var temp84: Int = 0
    var temp85: Int = 0
    var temp9: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var deathMusicLoaded by MemoryByte(DeathMusicLoaded)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var joypadOverride by MemoryByte(JoypadOverride)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerSize by MemoryByte(PlayerSize)
    var playerBoundboxctrl by MemoryByte(Player_BoundBoxCtrl)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var savedJoypadBits by MemoryByte(SavedJoypadBits)
    var scrollLock by MemoryByte(ScrollLock)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    //> PlayerCtrlRoutine:
    //> lda GameEngineSubroutine    ;check task here
    A = gameEngineSubroutine
    //> cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
    //> beq SizeChk
    if (A != 0x0B) {
        //> lda AreaType                ;are we in a water type area?
        A = areaType
        //> bne SaveJoyp                ;if not, branch
        if (A == 0) {
            //> ldy Player_Y_HighPos
            Y = playerYHighpos
            //> dey                         ;if not in vertical area between
            Y = (Y - 1) and 0xFF
            //> bne DisJoyp                 ;status bar and bottom, branch
            if (Y == 0) {
                //> lda Player_Y_Position
                A = playerYPosition
                //> cmp #$d0                    ;if nearing the bottom of the screen or
                //> bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
                if (!(A >= 0xD0)) {
                    //  goto SaveJoyp (internal forward branch)
                    //> SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
                    A = savedJoypadBits
                    //> and #%11000000
                    A = A and 0xC0
                    //> sta A_B_Buttons
                    aBButtons = A
                    //> lda SavedJoypadBits         ;store left and right buttons in $0c
                    A = savedJoypadBits
                    //> and #%00000011
                    A = A and 0x03
                    //> sta Left_Right_Buttons
                    leftRightButtons = A
                    //> lda SavedJoypadBits         ;store up and down buttons in $0b
                    A = savedJoypadBits
                    //> and #%00001100
                    A = A and 0x0C
                    //> sta Up_Down_Buttons
                    upDownButtons = A
                    //> and #%00000100              ;check for pressing down
                    A = A and 0x04
                    //> beq SizeChk                 ;if not, branch
                    if (A == 0) {
                        //  goto SizeChk (internal forward branch)
                        //> SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
                        playerMovementSubs()
                        //> ldy #$01                    ;is player small?
                        Y = 0x01
                        //> lda PlayerSize
                        A = playerSize
                        //> bne ChkMoveDir
                        if (!(A == 0)) {
                            //  goto ChkMoveDir (internal forward branch)
                            //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
                            playerBoundboxctrl = Y
                            //> lda #$01                    ;set moving direction to right by default
                            A = 0x01
                            //> ldy Player_X_Speed          ;check player's horizontal speed
                            Y = playerXSpeed
                            //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
                            if (Y == 0) {
                                //  goto PlayerSubs (internal forward branch)
                                //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
                                scrollHandler()
                                //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
                                temp0 = getPlayerOffscreenBits()
                                X = temp0
                                //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
                                temp1 = relativePlayerPosition()
                                X = temp1
                                //> ldx #$00                    ;set offset for player object
                                X = 0x00
                                //> jsr BoundingBoxCore         ;get player's bounding box coordinates
                                val pair0 = boundingBoxCore(X, Y)
                                temp2 = pair0.first
                                temp3 = pair0.second
                                X = temp2
                                //> jsr PlayerBGCollision       ;do collision detection and process
                                temp4 = playerBGCollision()
                                X = temp4
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$40                    ;check to see if player is higher than 64th pixel
                                //> bcc PlayerHole              ;if so, branch ahead
                                if (!(A >= 0x40)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp5 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp6 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda GameEngineSubroutine
                                A = gameEngineSubroutine
                                //> cmp #$05                    ;if running end-of-level routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x05) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp7 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp8 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$07                    ;if running player entrance routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x07) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp9 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp10 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                                //> bcc PlayerHole
                                if (!(A >= 0x04)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp11 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp12 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda Player_SprAttrib
                                A = playerSprattrib
                                //> and #%11011111              ;otherwise nullify player's
                                A = A and 0xDF
                                //> sta Player_SprAttrib        ;background priority flag
                                playerSprattrib = A
                                return
                            }
                            //> bpl SetMoveDir              ;if moving to the right, use default moving direction
                            if (!((Y and 0x80) != 0)) {
                                //  goto SetMoveDir (internal forward branch)
                                //> SetMoveDir: sta Player_MovingDir        ;set moving direction
                                playerMovingdir = A
                                return
                            }
                            //> asl                         ;otherwise change to move to the left
                            val orig0: Int = A
                            A = (orig0 shl 1) and 0xFF
                            return
                        }
                        //> ldy #$00                    ;check for if crouching
                        Y = 0x00
                        //> lda CrouchingFlag
                        A = crouchingFlag
                        //> beq ChkMoveDir              ;if not, branch ahead
                        if (A == 0) {
                            //  goto ChkMoveDir (internal forward branch)
                            //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
                            playerBoundboxctrl = Y
                            //> lda #$01                    ;set moving direction to right by default
                            A = 0x01
                            //> ldy Player_X_Speed          ;check player's horizontal speed
                            Y = playerXSpeed
                            //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
                            if (Y == 0) {
                                //  goto PlayerSubs (internal forward branch)
                                //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
                                scrollHandler()
                                //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
                                temp13 = getPlayerOffscreenBits()
                                X = temp13
                                //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
                                temp14 = relativePlayerPosition()
                                X = temp14
                                //> ldx #$00                    ;set offset for player object
                                X = 0x00
                                //> jsr BoundingBoxCore         ;get player's bounding box coordinates
                                val pair1 = boundingBoxCore(X, Y)
                                temp15 = pair1.first
                                temp16 = pair1.second
                                X = temp15
                                //> jsr PlayerBGCollision       ;do collision detection and process
                                temp17 = playerBGCollision()
                                X = temp17
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$40                    ;check to see if player is higher than 64th pixel
                                //> bcc PlayerHole              ;if so, branch ahead
                                if (!(A >= 0x40)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp18 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp19 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda GameEngineSubroutine
                                A = gameEngineSubroutine
                                //> cmp #$05                    ;if running end-of-level routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x05) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp20 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp21 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$07                    ;if running player entrance routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x07) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp22 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp23 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                                //> bcc PlayerHole
                                if (!(A >= 0x04)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp24 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp25 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda Player_SprAttrib
                                A = playerSprattrib
                                //> and #%11011111              ;otherwise nullify player's
                                A = A and 0xDF
                                //> sta Player_SprAttrib        ;background priority flag
                                playerSprattrib = A
                                return
                            }
                            //> bpl SetMoveDir              ;if moving to the right, use default moving direction
                            if (!((Y and 0x80) != 0)) {
                                //  goto SetMoveDir (internal forward branch)
                                //> SetMoveDir: sta Player_MovingDir        ;set moving direction
                                playerMovingdir = A
                                return
                            }
                            //> asl                         ;otherwise change to move to the left
                            val orig1: Int = A
                            A = (orig1 shl 1) and 0xFF
                            return
                        }
                        //> ldy #$02                    ;if big and crouching, load y with 2
                        Y = 0x02
                        return
                    }
                    //> lda Player_State            ;check player's state
                    A = playerState
                    //> bne SizeChk                 ;if not on the ground, branch
                    if (!(A == 0)) {
                        //  goto SizeChk (internal forward branch)
                        //> SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
                        playerMovementSubs()
                        //> ldy #$01                    ;is player small?
                        Y = 0x01
                        //> lda PlayerSize
                        A = playerSize
                        //> bne ChkMoveDir
                        if (!(A == 0)) {
                            //  goto ChkMoveDir (internal forward branch)
                            //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
                            playerBoundboxctrl = Y
                            //> lda #$01                    ;set moving direction to right by default
                            A = 0x01
                            //> ldy Player_X_Speed          ;check player's horizontal speed
                            Y = playerXSpeed
                            //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
                            if (Y == 0) {
                                //  goto PlayerSubs (internal forward branch)
                                //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
                                scrollHandler()
                                //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
                                temp26 = getPlayerOffscreenBits()
                                X = temp26
                                //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
                                temp27 = relativePlayerPosition()
                                X = temp27
                                //> ldx #$00                    ;set offset for player object
                                X = 0x00
                                //> jsr BoundingBoxCore         ;get player's bounding box coordinates
                                val pair2 = boundingBoxCore(X, Y)
                                temp28 = pair2.first
                                temp29 = pair2.second
                                X = temp28
                                //> jsr PlayerBGCollision       ;do collision detection and process
                                temp30 = playerBGCollision()
                                X = temp30
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$40                    ;check to see if player is higher than 64th pixel
                                //> bcc PlayerHole              ;if so, branch ahead
                                if (!(A >= 0x40)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp31 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp32 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda GameEngineSubroutine
                                A = gameEngineSubroutine
                                //> cmp #$05                    ;if running end-of-level routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x05) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp33 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp34 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$07                    ;if running player entrance routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x07) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp35 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp36 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                                //> bcc PlayerHole
                                if (!(A >= 0x04)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp37 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp38 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda Player_SprAttrib
                                A = playerSprattrib
                                //> and #%11011111              ;otherwise nullify player's
                                A = A and 0xDF
                                //> sta Player_SprAttrib        ;background priority flag
                                playerSprattrib = A
                                return
                            }
                            //> bpl SetMoveDir              ;if moving to the right, use default moving direction
                            if (!((Y and 0x80) != 0)) {
                                //  goto SetMoveDir (internal forward branch)
                                //> SetMoveDir: sta Player_MovingDir        ;set moving direction
                                playerMovingdir = A
                                return
                            }
                            //> asl                         ;otherwise change to move to the left
                            val orig2: Int = A
                            A = (orig2 shl 1) and 0xFF
                            return
                        }
                        //> ldy #$00                    ;check for if crouching
                        Y = 0x00
                        //> lda CrouchingFlag
                        A = crouchingFlag
                        //> beq ChkMoveDir              ;if not, branch ahead
                        if (A == 0) {
                            //  goto ChkMoveDir (internal forward branch)
                            //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
                            playerBoundboxctrl = Y
                            //> lda #$01                    ;set moving direction to right by default
                            A = 0x01
                            //> ldy Player_X_Speed          ;check player's horizontal speed
                            Y = playerXSpeed
                            //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
                            if (Y == 0) {
                                //  goto PlayerSubs (internal forward branch)
                                //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
                                scrollHandler()
                                //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
                                temp39 = getPlayerOffscreenBits()
                                X = temp39
                                //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
                                temp40 = relativePlayerPosition()
                                X = temp40
                                //> ldx #$00                    ;set offset for player object
                                X = 0x00
                                //> jsr BoundingBoxCore         ;get player's bounding box coordinates
                                val pair3 = boundingBoxCore(X, Y)
                                temp41 = pair3.first
                                temp42 = pair3.second
                                X = temp41
                                //> jsr PlayerBGCollision       ;do collision detection and process
                                temp43 = playerBGCollision()
                                X = temp43
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$40                    ;check to see if player is higher than 64th pixel
                                //> bcc PlayerHole              ;if so, branch ahead
                                if (!(A >= 0x40)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp44 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp45 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda GameEngineSubroutine
                                A = gameEngineSubroutine
                                //> cmp #$05                    ;if running end-of-level routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x05) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp46 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp47 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$07                    ;if running player entrance routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x07) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp48 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp49 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                                //> bcc PlayerHole
                                if (!(A >= 0x04)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp50 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp51 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda Player_SprAttrib
                                A = playerSprattrib
                                //> and #%11011111              ;otherwise nullify player's
                                A = A and 0xDF
                                //> sta Player_SprAttrib        ;background priority flag
                                playerSprattrib = A
                                return
                            }
                            //> bpl SetMoveDir              ;if moving to the right, use default moving direction
                            if (!((Y and 0x80) != 0)) {
                                //  goto SetMoveDir (internal forward branch)
                                //> SetMoveDir: sta Player_MovingDir        ;set moving direction
                                playerMovingdir = A
                                return
                            }
                            //> asl                         ;otherwise change to move to the left
                            val orig3: Int = A
                            A = (orig3 shl 1) and 0xFF
                            return
                        }
                        //> ldy #$02                    ;if big and crouching, load y with 2
                        Y = 0x02
                        return
                    }
                    //> ldy Left_Right_Buttons      ;check left and right
                    Y = leftRightButtons
                    //> beq SizeChk                 ;if neither pressed, branch
                    if (Y == 0) {
                        //  goto SizeChk (internal forward branch)
                        //> SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
                        playerMovementSubs()
                        //> ldy #$01                    ;is player small?
                        Y = 0x01
                        //> lda PlayerSize
                        A = playerSize
                        //> bne ChkMoveDir
                        if (!(A == 0)) {
                            //  goto ChkMoveDir (internal forward branch)
                            //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
                            playerBoundboxctrl = Y
                            //> lda #$01                    ;set moving direction to right by default
                            A = 0x01
                            //> ldy Player_X_Speed          ;check player's horizontal speed
                            Y = playerXSpeed
                            //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
                            if (Y == 0) {
                                //  goto PlayerSubs (internal forward branch)
                                //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
                                scrollHandler()
                                //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
                                temp52 = getPlayerOffscreenBits()
                                X = temp52
                                //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
                                temp53 = relativePlayerPosition()
                                X = temp53
                                //> ldx #$00                    ;set offset for player object
                                X = 0x00
                                //> jsr BoundingBoxCore         ;get player's bounding box coordinates
                                val pair4 = boundingBoxCore(X, Y)
                                temp54 = pair4.first
                                temp55 = pair4.second
                                X = temp54
                                //> jsr PlayerBGCollision       ;do collision detection and process
                                temp56 = playerBGCollision()
                                X = temp56
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$40                    ;check to see if player is higher than 64th pixel
                                //> bcc PlayerHole              ;if so, branch ahead
                                if (!(A >= 0x40)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp57 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp58 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda GameEngineSubroutine
                                A = gameEngineSubroutine
                                //> cmp #$05                    ;if running end-of-level routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x05) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp59 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp60 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$07                    ;if running player entrance routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x07) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp61 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp62 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                                //> bcc PlayerHole
                                if (!(A >= 0x04)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp63 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp64 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda Player_SprAttrib
                                A = playerSprattrib
                                //> and #%11011111              ;otherwise nullify player's
                                A = A and 0xDF
                                //> sta Player_SprAttrib        ;background priority flag
                                playerSprattrib = A
                                return
                            }
                            //> bpl SetMoveDir              ;if moving to the right, use default moving direction
                            if (!((Y and 0x80) != 0)) {
                                //  goto SetMoveDir (internal forward branch)
                                //> SetMoveDir: sta Player_MovingDir        ;set moving direction
                                playerMovingdir = A
                                return
                            }
                            //> asl                         ;otherwise change to move to the left
                            val orig4: Int = A
                            A = (orig4 shl 1) and 0xFF
                            return
                        }
                        //> ldy #$00                    ;check for if crouching
                        Y = 0x00
                        //> lda CrouchingFlag
                        A = crouchingFlag
                        //> beq ChkMoveDir              ;if not, branch ahead
                        if (A == 0) {
                            //  goto ChkMoveDir (internal forward branch)
                            //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
                            playerBoundboxctrl = Y
                            //> lda #$01                    ;set moving direction to right by default
                            A = 0x01
                            //> ldy Player_X_Speed          ;check player's horizontal speed
                            Y = playerXSpeed
                            //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
                            if (Y == 0) {
                                //  goto PlayerSubs (internal forward branch)
                                //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
                                scrollHandler()
                                //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
                                temp65 = getPlayerOffscreenBits()
                                X = temp65
                                //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
                                temp66 = relativePlayerPosition()
                                X = temp66
                                //> ldx #$00                    ;set offset for player object
                                X = 0x00
                                //> jsr BoundingBoxCore         ;get player's bounding box coordinates
                                val pair5 = boundingBoxCore(X, Y)
                                temp67 = pair5.first
                                temp68 = pair5.second
                                X = temp67
                                //> jsr PlayerBGCollision       ;do collision detection and process
                                temp69 = playerBGCollision()
                                X = temp69
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$40                    ;check to see if player is higher than 64th pixel
                                //> bcc PlayerHole              ;if so, branch ahead
                                if (!(A >= 0x40)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp70 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp71 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda GameEngineSubroutine
                                A = gameEngineSubroutine
                                //> cmp #$05                    ;if running end-of-level routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x05) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp72 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp73 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$07                    ;if running player entrance routine, branch ahead
                                //> beq PlayerHole
                                if (A == 0x07) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp74 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp75 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                                //> bcc PlayerHole
                                if (!(A >= 0x04)) {
                                    //  goto PlayerHole (internal forward branch)
                                    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
                                    A = playerYHighpos
                                    //> cmp #$02                    ;for below the screen
                                    //> bmi ExitCtrl                ;branch to leave if not that far down
                                    if (((A - 0x02) and 0xFF and 0x80) != 0) {
                                        //  goto ExitCtrl (internal forward branch)
                                        //> ExitCtrl:   rts                         ;leave
                                        return
                                    }
                                    //> ldx #$01
                                    X = 0x01
                                    //> stx ScrollLock              ;set scroll lock
                                    scrollLock = X
                                    //> ldy #$04
                                    Y = 0x04
                                    //> sty $07                     ;set value here
                                    memory[0x7] = Y.toUByte()
                                    //> ldx #$00                    ;use X as flag, and clear for cloud level
                                    X = 0x00
                                    //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
                                    Y = gameTimerExpiredFlag
                                    //> bne HoleDie                 ;if set, branch
                                    if (!(Y == 0)) {
                                        //  goto HoleDie (internal forward branch)
                                        //> HoleDie:    inx                         ;set flag in X for player death
                                        X = (X + 1) and 0xFF
                                        //> ldy GameEngineSubroutine
                                        Y = gameEngineSubroutine
                                        //> cpy #$0b                    ;check for some other routine running
                                        //> beq ChkHoleX                ;if so, branch ahead
                                        if (Y == 0x0B) {
                                            //  goto ChkHoleX (internal forward branch)
                                            //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                            //> bmi ExitCtrl                ;if less, branch to leave
                                            if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> dex                         ;otherwise decrement flag in X
                                            X = (X - 1) and 0xFF
                                            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                            if ((X and 0x80) != 0) {
                                                //  goto CloudExit (internal forward branch)
                                                //> CloudExit:
                                                //> lda #$00
                                                A = 0x00
                                                //> sta JoypadOverride      ;clear controller override bits if any are set
                                                joypadOverride = A
                                                //> jsr SetEntr             ;do sub to set secondary mode
                                                temp76 = setEntr()
                                                //> inc AltEntranceControl  ;set mode of entry to 3
                                                altEntranceControl = (altEntranceControl + 1) and 0xFF
                                                //> rts
                                                return
                                            }
                                            //> ldy EventMusicBuffer        ;check to see if music is still playing
                                            Y = eventMusicBuffer
                                            //> bne ExitCtrl                ;branch to leave if so
                                            if (!(Y == 0)) {
                                                //  goto ExitCtrl (internal forward branch)
                                                //> ExitCtrl:   rts                         ;leave
                                                return
                                            }
                                            //> lda #$06                    ;otherwise set to run lose life routine
                                            A = 0x06
                                            //> sta GameEngineSubroutine    ;on next frame
                                            gameEngineSubroutine = A
                                            return
                                        }
                                        //> ldy DeathMusicLoaded        ;check value here
                                        Y = deathMusicLoaded
                                        //> bne HoleBottom              ;if already set, branch to next part
                                        if (!(Y == 0)) {
                                            //  goto HoleBottom (internal forward branch)
                                            //> HoleBottom: ldy #$06
                                            Y = 0x06
                                            //> sty $07                     ;change value here
                                            memory[0x7] = Y.toUByte()
                                            return
                                        }
                                        //> iny
                                        Y = (Y + 1) and 0xFF
                                        //> sty EventMusicQueue         ;otherwise play death music
                                        eventMusicQueue = Y
                                        //> sty DeathMusicLoaded        ;and set value here
                                        deathMusicLoaded = Y
                                        return
                                    }
                                    //> ldy CloudTypeOverride       ;check for cloud type override
                                    Y = cloudTypeOverride
                                    //> bne ChkHoleX                ;skip to last part if found
                                    if (!(Y == 0)) {
                                        //  goto ChkHoleX (internal forward branch)
                                        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                                        //> bmi ExitCtrl                ;if less, branch to leave
                                        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> dex                         ;otherwise decrement flag in X
                                        X = (X - 1) and 0xFF
                                        //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                                        if ((X and 0x80) != 0) {
                                            //  goto CloudExit (internal forward branch)
                                            //> CloudExit:
                                            //> lda #$00
                                            A = 0x00
                                            //> sta JoypadOverride      ;clear controller override bits if any are set
                                            joypadOverride = A
                                            //> jsr SetEntr             ;do sub to set secondary mode
                                            temp77 = setEntr()
                                            //> inc AltEntranceControl  ;set mode of entry to 3
                                            altEntranceControl = (altEntranceControl + 1) and 0xFF
                                            //> rts
                                            return
                                        }
                                        //> ldy EventMusicBuffer        ;check to see if music is still playing
                                        Y = eventMusicBuffer
                                        //> bne ExitCtrl                ;branch to leave if so
                                        if (!(Y == 0)) {
                                            //  goto ExitCtrl (internal forward branch)
                                            //> ExitCtrl:   rts                         ;leave
                                            return
                                        }
                                        //> lda #$06                    ;otherwise set to run lose life routine
                                        A = 0x06
                                        //> sta GameEngineSubroutine    ;on next frame
                                        gameEngineSubroutine = A
                                        return
                                    }
                                    return
                                }
                                //> lda Player_SprAttrib
                                A = playerSprattrib
                                //> and #%11011111              ;otherwise nullify player's
                                A = A and 0xDF
                                //> sta Player_SprAttrib        ;background priority flag
                                playerSprattrib = A
                                return
                            }
                            //> bpl SetMoveDir              ;if moving to the right, use default moving direction
                            if (!((Y and 0x80) != 0)) {
                                //  goto SetMoveDir (internal forward branch)
                                //> SetMoveDir: sta Player_MovingDir        ;set moving direction
                                playerMovingdir = A
                                return
                            }
                            //> asl                         ;otherwise change to move to the left
                            val orig5: Int = A
                            A = (orig5 shl 1) and 0xFF
                            return
                        }
                        //> ldy #$02                    ;if big and crouching, load y with 2
                        Y = 0x02
                        return
                    }
                    //> lda #$00
                    A = 0x00
                    //> sta Left_Right_Buttons      ;if pressing down while on the ground,
                    leftRightButtons = A
                    //> sta Up_Down_Buttons         ;nullify directional bits
                    upDownButtons = A
                    return
                }
            }
            //> DisJoyp:    lda #$00                    ;disable controller bits
            A = 0x00
            //> sta SavedJoypadBits
            savedJoypadBits = A
        }
        //> SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
        A = savedJoypadBits
        //> and #%11000000
        A = A and 0xC0
        //> sta A_B_Buttons
        aBButtons = A
        //> lda SavedJoypadBits         ;store left and right buttons in $0c
        A = savedJoypadBits
        //> and #%00000011
        A = A and 0x03
        //> sta Left_Right_Buttons
        leftRightButtons = A
        //> lda SavedJoypadBits         ;store up and down buttons in $0b
        A = savedJoypadBits
        //> and #%00001100
        A = A and 0x0C
        //> sta Up_Down_Buttons
        upDownButtons = A
        //> and #%00000100              ;check for pressing down
        A = A and 0x04
        //> beq SizeChk                 ;if not, branch
        if (A != 0) {
            //> lda Player_State            ;check player's state
            A = playerState
            //> bne SizeChk                 ;if not on the ground, branch
            if (A == 0) {
                //> ldy Left_Right_Buttons      ;check left and right
                Y = leftRightButtons
                //> beq SizeChk                 ;if neither pressed, branch
                if (Y != 0) {
                    //> lda #$00
                    A = 0x00
                    //> sta Left_Right_Buttons      ;if pressing down while on the ground,
                    leftRightButtons = A
                    //> sta Up_Down_Buttons         ;nullify directional bits
                    upDownButtons = A
                }
            }
        }
    }
    //> SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
    playerMovementSubs()
    //> ldy #$01                    ;is player small?
    Y = 0x01
    //> lda PlayerSize
    A = playerSize
    //> bne ChkMoveDir
    if (A == 0) {
        //> ldy #$00                    ;check for if crouching
        Y = 0x00
        //> lda CrouchingFlag
        A = crouchingFlag
        //> beq ChkMoveDir              ;if not, branch ahead
        if (A != 0) {
            //> ldy #$02                    ;if big and crouching, load y with 2
            Y = 0x02
        }
    }
    //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
    playerBoundboxctrl = Y
    //> lda #$01                    ;set moving direction to right by default
    A = 0x01
    //> ldy Player_X_Speed          ;check player's horizontal speed
    Y = playerXSpeed
    //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
    if (Y != 0) {
        //> bpl SetMoveDir              ;if moving to the right, use default moving direction
        if ((Y and 0x80) != 0) {
            //> asl                         ;otherwise change to move to the left
            val orig6: Int = A
            A = (orig6 shl 1) and 0xFF
        }
        //> SetMoveDir: sta Player_MovingDir        ;set moving direction
        playerMovingdir = A
    }
    //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
    scrollHandler()
    //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
    temp78 = getPlayerOffscreenBits()
    X = temp78
    //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
    temp79 = relativePlayerPosition()
    X = temp79
    //> ldx #$00                    ;set offset for player object
    X = 0x00
    //> jsr BoundingBoxCore         ;get player's bounding box coordinates
    val pair6 = boundingBoxCore(X, Y)
    temp80 = pair6.first
    temp81 = pair6.second
    X = temp80
    //> jsr PlayerBGCollision       ;do collision detection and process
    temp82 = playerBGCollision()
    X = temp82
    //> lda Player_Y_Position
    A = playerYPosition
    //> cmp #$40                    ;check to see if player is higher than 64th pixel
    //> bcc PlayerHole              ;if so, branch ahead
    X = temp82
    Y = temp81
    if (A >= 0x40) {
        //> lda GameEngineSubroutine
        A = gameEngineSubroutine
        //> cmp #$05                    ;if running end-of-level routine, branch ahead
        //> beq PlayerHole
        if (A != 0x05) {
            //> cmp #$07                    ;if running player entrance routine, branch ahead
            //> beq PlayerHole
            if (A != 0x07) {
                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                //> bcc PlayerHole
                if (A >= 0x04) {
                    //> lda Player_SprAttrib
                    A = playerSprattrib
                    //> and #%11011111              ;otherwise nullify player's
                    A = A and 0xDF
                    //> sta Player_SprAttrib        ;background priority flag
                    playerSprattrib = A
                }
            }
        }
    }
    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
    A = playerYHighpos
    //> cmp #$02                    ;for below the screen
    //> bmi ExitCtrl                ;branch to leave if not that far down
    if (((A - 0x02) and 0xFF and 0x80) == 0) {
        //> ldx #$01
        X = 0x01
        //> stx ScrollLock              ;set scroll lock
        scrollLock = X
        //> ldy #$04
        Y = 0x04
        //> sty $07                     ;set value here
        memory[0x7] = Y.toUByte()
        //> ldx #$00                    ;use X as flag, and clear for cloud level
        X = 0x00
        //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
        Y = gameTimerExpiredFlag
        //> bne HoleDie                 ;if set, branch
        if (Y == 0) {
            //> ldy CloudTypeOverride       ;check for cloud type override
            Y = cloudTypeOverride
            //> bne ChkHoleX                ;skip to last part if found
            if (!(Y == 0)) {
                //  goto ChkHoleX (internal forward branch)
                //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
                //> bmi ExitCtrl                ;if less, branch to leave
                if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
                    //  goto ExitCtrl (internal forward branch)
                    //> ExitCtrl:   rts                         ;leave
                    return
                }
                //> dex                         ;otherwise decrement flag in X
                X = (X - 1) and 0xFF
                //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
                if ((X and 0x80) != 0) {
                    //  goto CloudExit (internal forward branch)
                    //> CloudExit:
                    //> lda #$00
                    A = 0x00
                    //> sta JoypadOverride      ;clear controller override bits if any are set
                    joypadOverride = A
                    //> jsr SetEntr             ;do sub to set secondary mode
                    temp83 = setEntr()
                    //> inc AltEntranceControl  ;set mode of entry to 3
                    altEntranceControl = (altEntranceControl + 1) and 0xFF
                    //> rts
                    return
                }
                //> ldy EventMusicBuffer        ;check to see if music is still playing
                Y = eventMusicBuffer
                //> bne ExitCtrl                ;branch to leave if so
                if (!(Y == 0)) {
                    //  goto ExitCtrl (internal forward branch)
                    //> ExitCtrl:   rts                         ;leave
                    return
                }
                //> lda #$06                    ;otherwise set to run lose life routine
                A = 0x06
                //> sta GameEngineSubroutine    ;on next frame
                gameEngineSubroutine = A
                return
            }
        }
        //> HoleDie:    inx                         ;set flag in X for player death
        X = (X + 1) and 0xFF
        //> ldy GameEngineSubroutine
        Y = gameEngineSubroutine
        //> cpy #$0b                    ;check for some other routine running
        //> beq ChkHoleX                ;if so, branch ahead
        if (Y != 0x0B) {
            //> ldy DeathMusicLoaded        ;check value here
            Y = deathMusicLoaded
            //> bne HoleBottom              ;if already set, branch to next part
            if (Y == 0) {
                //> iny
                Y = (Y + 1) and 0xFF
                //> sty EventMusicQueue         ;otherwise play death music
                eventMusicQueue = Y
                //> sty DeathMusicLoaded        ;and set value here
                deathMusicLoaded = Y
            }
            //> HoleBottom: ldy #$06
            Y = 0x06
            //> sty $07                     ;change value here
            memory[0x7] = Y.toUByte()
        }
        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
        //> bmi ExitCtrl                ;if less, branch to leave
        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) == 0) {
            //> dex                         ;otherwise decrement flag in X
            X = (X - 1) and 0xFF
            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
            if ((X and 0x80) == 0) {
                //> ldy EventMusicBuffer        ;check to see if music is still playing
                Y = eventMusicBuffer
                //> bne ExitCtrl                ;branch to leave if so
                if (Y == 0) {
                    //> lda #$06                    ;otherwise set to run lose life routine
                    A = 0x06
                    //> sta GameEngineSubroutine    ;on next frame
                    gameEngineSubroutine = A
                }
            } else {
                //> CloudExit:
                //> lda #$00
                A = 0x00
                //> sta JoypadOverride      ;clear controller override bits if any are set
                joypadOverride = A
                //> jsr SetEntr             ;do sub to set secondary mode
                temp84 = setEntr()
                //> inc AltEntranceControl  ;set mode of entry to 3
                altEntranceControl = (altEntranceControl + 1) and 0xFF
                //> rts
                return
            }
        }
    }
    //> ExitCtrl:   rts                         ;leave
    return
    //> CloudExit:
    //> lda #$00
    A = 0x00
    //> sta JoypadOverride      ;clear controller override bits if any are set
    joypadOverride = A
    //> jsr SetEntr             ;do sub to set secondary mode
    temp85 = setEntr()
    //> inc AltEntranceControl  ;set mode of entry to 3
    altEntranceControl = (altEntranceControl + 1) and 0xFF
    //> rts
    return
}

// Decompiled from Vine_AutoClimb
fun vineAutoclimb() {
    var A: Int = 0
    var Y: Int = 0
    var joypadOverride by MemoryByte(JoypadOverride)
    var playerState by MemoryByte(Player_State)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    //> Vine_AutoClimb:
    //> lda Player_Y_HighPos   ;check to see whether player reached position
    A = playerYHighpos
    //> bne AutoClimb          ;above the status bar yet and if so, set modes
    if (A == 0) {
        //> lda Player_Y_Position
        A = playerYPosition
        //> cmp #$e4
        //> bcc SetEntr
        if (!(A >= 0xE4)) {
            //  goto SetEntr -> setEntr
            setEntr()
            return
        }
    }
    //> AutoClimb: lda #%00001000         ;set controller bits override to up
    A = 0x08
    //> sta JoypadOverride
    joypadOverride = A
    //> ldy #$03               ;set player state to climbing
    Y = 0x03
    //> sty Player_State
    playerState = Y
    //> jmp AutoControlPlayer
    autoControlPlayer(A)
    return
}

// Decompiled from SetEntr
fun setEntr(): Int {
    var A: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    //> SetEntr:   lda #$02               ;set starting position to override
    A = 0x02
    //> sta AltEntranceControl
    altEntranceControl = A
    //> jmp ChgAreaMode        ;set modes
    return chgAreaMode()
}

// Decompiled from VerticalPipeEntry
fun verticalPipeEntry(): Int {
    var A: Int = 0
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    //> VerticalPipeEntry:
    //> lda #$01             ;set 1 as movement amount
    A = 0x01
    //> jsr MovePlayerYAxis  ;do sub to move player downwards
    movePlayerYAxis(A)
    //> jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
    scrollHandler()
    //> ldy #$00             ;load default mode of entry
    Y = 0x00
    //> lda WarpZoneControl  ;check warp zone control variable/flag
    A = warpZoneControl
    //> bne ChgAreaPipe      ;if set, branch to use mode 0
    if (!(A == 0)) {
        //  goto ChgAreaPipe -> chgAreaPipe
        chgAreaPipe(Y)
        return A
    } else {
        //> iny
        Y = (Y + 1) and 0xFF
        //> lda AreaType         ;check for castle level type
        A = areaType
        //> cmp #$03
        //> bne ChgAreaPipe      ;if not castle type level, use mode 1
        if (!(A == 0x03)) {
            //  goto ChgAreaPipe -> chgAreaPipe
            chgAreaPipe(Y)
            return A
        }
    }
    //> iny
    Y = (Y + 1) and 0xFF
    //> jmp ChgAreaPipe      ;otherwise use mode 2
    return chgAreaPipe(Y)
}

// Decompiled from MovePlayerYAxis
fun movePlayerYAxis(A: Int) {
    var temp0: Int = 0
    var playerYPosition by MemoryByte(Player_Y_Position)
    //> MovePlayerYAxis:
    //> clc
    //> adc Player_Y_Position ;add contents of A to player position
    temp0 = A + playerYPosition
    //> sta Player_Y_Position
    playerYPosition = temp0 and 0xFF
    //> rts
    return
}

// Decompiled from SideExitPipeEntry
fun sideExitPipeEntry(): Int {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    //> SideExitPipeEntry:
    //> jsr EnterSidePipe         ;execute sub to move player to the right
    temp0 = enterSidePipe()
    //> ldy #$02
    Y = 0x02
    //  Fall-through tail call to chgAreaPipe
    return chgAreaPipe(Y)
}

// Decompiled from ChgAreaPipe
fun chgAreaPipe(Y: Int): Int {
    var A: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    //> ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
    changeAreaTimer = (changeAreaTimer - 1) and 0xFF
    //> bne ExitCAPipe
    if (!(changeAreaTimer == 0)) {
        //  goto ExitCAPipe -> exitCAPipe
        exitCAPipe()
        return A
    } else {
        //> sty AltEntranceControl    ;when timer expires set mode of alternate entry
        altEntranceControl = Y
        //  Fall-through tail call to chgAreaMode
        return chgAreaMode()
    }
}

// Decompiled from ChgAreaMode
fun chgAreaMode(): Int {
    var A: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var opermodeTask by MemoryByte(OperMode_Task)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    //> ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> lda #$00
    A = 0x00
    //> sta OperMode_Task         ;set secondary mode of operation
    opermodeTask = A
    //> sta Sprite0HitDetectFlag  ;disable sprite 0 check
    sprite0HitDetectFlag = A
    //  Fall-through tail call to exitCAPipe
    exitCAPipe()
    return A
}

// Decompiled from ExitCAPipe
fun exitCAPipe() {
    //> ExitCAPipe:  rts                       ;leave
    return
}

// Decompiled from EnterSidePipe
fun enterSidePipe(): Int {
    var A: Int = 0
    var Y: Int = 0
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> EnterSidePipe:
    //> lda #$08               ;set player's horizontal speed
    A = 0x08
    //> sta Player_X_Speed
    playerXSpeed = A
    //> ldy #$01               ;set controller right button by default
    Y = 0x01
    //> lda Player_X_Position  ;mask out higher nybble of player's
    A = playerXPosition
    //> and #%00001111         ;horizontal position
    A = A and 0x0F
    //> bne RightPipe
    if (A == 0) {
        //> sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
        playerXSpeed = A
        //> tay                    ;and nullify controller bit override here
        Y = A
    }
    //> RightPipe: tya                    ;use contents of Y to
    A = Y
    //> jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
    autoControlPlayer(A)
    //> rts
    return A
}

// Decompiled from PlayerChangeSize
fun playerChangeSize() {
    var A: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> PlayerChangeSize:
    //> lda TimerControl    ;check master timer control
    A = timerControl
    //> cmp #$f8            ;for specific moment in time
    //> bne EndChgSize      ;branch if before or after that point
    if (A == 0xF8) {
        //> jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
        initChangeSize()
        return
    } else {
        //> EndChgSize:  cmp #$c4            ;check again for another specific moment
        //> bne ExitChgSize     ;and branch to leave if before or after that point
        if (A == 0xC4) {
            //> jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
            donePlayerTask()
        }
    }
    //> ExitChgSize: rts                 ;and then leave
    return
}

// Decompiled from PlayerInjuryBlink
fun playerInjuryBlink() {
    var A: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> PlayerInjuryBlink:
    //> lda TimerControl       ;check master timer control
    A = timerControl
    //> cmp #$f0               ;for specific moment in time
    //> bcs ExitBlink          ;branch if before that point
    if (!(A >= 0xF0)) {
        //> cmp #$c8               ;check again for another specific point
        //> beq DonePlayerTask     ;branch if at that point, and not before or after
        if (A == 0xC8) {
            //  goto DonePlayerTask -> donePlayerTask
            donePlayerTask()
            return
        }
        //> jmp PlayerCtrlRoutine  ;otherwise run player control routine
        playerCtrlRoutine()
        return
    } else {
        //> ExitBlink: bne ExitBoth           ;do unconditional branch to leave
        if (!(A == 0xF0)) {
            //  goto ExitBoth -> exitBoth
            exitBoth()
            return
        }
    }
    //  Fall-through tail call to initChangeSize
    initChangeSize()
    return
}

// Decompiled from InitChangeSize
fun initChangeSize() {
    var A: Int = 0
    var Y: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    //> InitChangeSize:
    //> ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
    Y = playerChangeSizeFlag
    //> bne ExitBoth              ;then branch to leave
    if (!(Y == 0)) {
        //  goto ExitBoth -> exitBoth
        exitBoth()
        return
    } else {
        //> sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
        playerAnimCtrl = Y
        //> inc PlayerChangeSizeFlag  ;set growing/shrinking flag
        playerChangeSizeFlag = (playerChangeSizeFlag + 1) and 0xFF
        //> lda PlayerSize
        A = playerSize
        //> eor #$01                  ;invert player's size
        A = A xor 0x01
        //> sta PlayerSize
        playerSize = A
        //  Fall-through tail call to exitBoth
        exitBoth()
        return
    }
}

// Decompiled from ExitBoth
fun exitBoth() {
    //> ExitBoth: rts                       ;leave
    return
}

// Decompiled from PlayerDeath
fun playerDeath() {
    var A: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> PlayerDeath:
    //> lda TimerControl       ;check master timer control
    A = timerControl
    //> cmp #$f0               ;for specific moment in time
    //> bcs ExitDeath          ;branch to leave if before that point
    if (!(A >= 0xF0)) {
        //> jmp PlayerCtrlRoutine  ;otherwise run player control routine
        playerCtrlRoutine()
        return
    } else {
        //> ExitDeath:
        //> rts          ;leave from death routine
        return
    }
}

// Decompiled from DonePlayerTask
fun donePlayerTask() {
    var A: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var timerControl by MemoryByte(TimerControl)
    //> DonePlayerTask:
    //> lda #$00
    A = 0x00
    //> sta TimerControl          ;initialize master timer control to continue timers
    timerControl = A
    //> lda #$08
    A = 0x08
    //> sta GameEngineSubroutine  ;set player control routine to run next frame
    gameEngineSubroutine = A
    //> rts                       ;leave
    return
}

// Decompiled from PlayerFireFlower
fun playerFireFlower() {
    var A: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var timerControl by MemoryByte(TimerControl)
    //> PlayerFireFlower:
    //> lda TimerControl       ;check master timer control
    A = timerControl
    //> cmp #$c0               ;for specific moment in time
    //> beq ResetPalFireFlower ;branch if at moment, not before or after
    if (A != 0xC0) {
        //> lda FrameCounter       ;get frame counter
        A = frameCounter
        //> lsr
        val orig0: Int = A
        A = orig0 shr 1
        //> lsr                    ;divide by four to change every four frames
        val orig1: Int = A
        A = orig1 shr 1
        //  Fall-through tail call to cyclePlayerPalette
        cyclePlayerPalette(A)
        return
    } else {
        //> ResetPalFireFlower:
        //> jsr DonePlayerTask    ;do sub to init timer control and run player control routine
        donePlayerTask()
        //  Fall-through tail call to resetPalStar
        resetPalStar()
        return
    }
}

// Decompiled from CyclePlayerPalette
fun cyclePlayerPalette(A: Int) {
    var A: Int = A
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    //> CyclePlayerPalette:
    //> and #$03              ;mask out all but d1-d0 (previously d3-d2)
    A = A and 0x03
    //> sta $00               ;store result here to use as palette bits
    memory[0x0] = A.toUByte()
    //> lda Player_SprAttrib  ;get player attributes
    A = playerSprattrib
    //> and #%11111100        ;save any other bits but palette bits
    A = A and 0xFC
    //> ora $00               ;add palette bits
    A = A or memory[0x0].toInt()
    //> sta Player_SprAttrib  ;store as new player attributes
    playerSprattrib = A
    //> rts                   ;and leave
    return
}

// Decompiled from ResetPalStar
fun resetPalStar() {
    var A: Int = 0
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    //> ResetPalStar:
    //> lda Player_SprAttrib  ;get player attributes
    A = playerSprattrib
    //> and #%11111100        ;mask out palette bits to force palette 0
    A = A and 0xFC
    //> sta Player_SprAttrib  ;store as new player attributes
    playerSprattrib = A
    //> rts                   ;and leave
    return
}

// Decompiled from FlagpoleSlide
fun flagpoleSlide() {
    var A: Int = 0
    var Y: Int = 0
    var flagpoleSoundQueue by MemoryByte(FlagpoleSoundQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> FlagpoleSlide:
    //> lda Enemy_ID+5           ;check special use enemy slot
    A = enemyId[5]
    //> cmp #FlagpoleFlagObject  ;for flagpole flag object
    //> bne NoFPObj              ;if not found, branch to something residual
    if (A == FlagpoleFlagObject) {
        //> lda FlagpoleSoundQueue   ;load flagpole sound
        A = flagpoleSoundQueue
        //> sta Square1SoundQueue    ;into square 1's sfx queue
        square1SoundQueue = A
        //> lda #$00
        A = 0x00
        //> sta FlagpoleSoundQueue   ;init flagpole sound queue
        flagpoleSoundQueue = A
        //> ldy Player_Y_Position
        Y = playerYPosition
        //> cpy #$9e                 ;check to see if player has slid down
        //> bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
        if (!(Y >= 0x9E)) {
            //> lda #$04                 ;otherwise force player to climb down (to slide)
            A = 0x04
        }
        //> SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
        autoControlPlayer(A)
        return
    } else {
        //> NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
        gameEngineSubroutine = (gameEngineSubroutine + 1) and 0xFF
        //> rts                      ;be residual code)
        return
    }
}

// Decompiled from PlayerEndLevel
fun playerEndLevel() {
    var A: Int = 0
    var Y: Int = 0
    var coinTallyFor1Ups by MemoryByte(CoinTallyFor1Ups)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    var levelNumber by MemoryByte(LevelNumber)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var scrollLock by MemoryByte(ScrollLock)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    var worldNumber by MemoryByte(WorldNumber)
    val hidden1UpCoinAmts by MemoryByteIndexed(Hidden1UpCoinAmts)
    //> PlayerEndLevel:
    //> lda #$01                  ;force player to walk to the right
    A = 0x01
    //> jsr AutoControlPlayer
    autoControlPlayer(A)
    //> lda Player_Y_Position     ;check player's vertical position
    A = playerYPosition
    //> cmp #$ae
    //> bcc ChkStop               ;if player is not yet off the flagpole, skip this part
    if (A >= 0xAE) {
        //> lda ScrollLock            ;if scroll lock not set, branch ahead to next part
        A = scrollLock
        //> beq ChkStop               ;because we only need to do this part once
        if (A != 0) {
            //> lda #EndOfLevelMusic
            A = EndOfLevelMusic
            //> sta EventMusicQueue       ;load win level music in event music queue
            eventMusicQueue = A
            //> lda #$00
            A = 0x00
            //> sta ScrollLock            ;turn off scroll lock to skip this part later
            scrollLock = A
        }
    }
    //> ChkStop:  lda Player_CollisionBits  ;get player collision bits
    A = playerCollisionbits
    //> lsr                       ;check for d0 set
    val orig0: Int = A
    A = orig0 shr 1
    //> bcs RdyNextA              ;if d0 set, skip to next part
    if ((orig0 and 0x01) == 0) {
        //> lda StarFlagTaskControl   ;if star flag task control already set,
        A = starFlagTaskControl
        //> bne InCastle              ;go ahead with the rest of the code
        if (A == 0) {
            //> inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
            starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
        }
        //> InCastle: lda #%00100000            ;set player's background priority bit to
        A = 0x20
        //> sta Player_SprAttrib      ;give illusion of being inside the castle
        playerSprattrib = A
    }
    //> RdyNextA: lda StarFlagTaskControl
    A = starFlagTaskControl
    //> cmp #$05                  ;if star flag task control not yet set
    //> bne ExitNA                ;beyond last valid task number, branch to leave
    if (!(A == 0x05)) {
        //  goto ExitNA -> exitNA
        exitNA()
        return
    } else {
        //> inc LevelNumber           ;increment level number used for game logic
        levelNumber = (levelNumber + 1) and 0xFF
        //> lda LevelNumber
        A = levelNumber
        //> cmp #$03                  ;check to see if we have yet reached level -4
        //> bne NextArea              ;and skip this last part here if not
        if (!(A == 0x03)) {
            //  goto NextArea -> nextArea
            nextArea(A)
            return
        }
    }
    //> ldy WorldNumber           ;get world number as offset
    Y = worldNumber
    //> lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
    A = coinTallyFor1Ups
    //> cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
    //> bcc NextArea              ;at least this number of coins, leave flag clear
    if (!(A >= hidden1UpCoinAmts[Y])) {
        //  goto NextArea -> nextArea
        nextArea(A)
        return
    } else {
        //> inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
        hidden1UpFlag = (hidden1UpFlag + 1) and 0xFF
        //  Fall-through tail call to nextArea
        nextArea(A)
        return
    }
}

// Decompiled from NextArea
fun nextArea(A: Int) {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var halfwayPage by MemoryByte(HalfwayPage)
    //> NextArea: inc AreaNumber            ;increment area number used for address loader
    areaNumber = (areaNumber + 1) and 0xFF
    //> jsr LoadAreaPointer       ;get new level pointer
    temp0 = loadAreaPointer(A)
    //> inc FetchNewGameTimerFlag ;set flag to load new game timer
    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
    //> jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
    temp1 = chgAreaMode()
    //> sta HalfwayPage           ;reset halfway page to 0 (beginning)
    halfwayPage = temp1
    //> lda #Silence
    A = Silence
    //> sta EventMusicQueue       ;silence music and leave
    eventMusicQueue = A
    //  Fall-through tail call to exitNA
    exitNA()
    return
}

// Decompiled from ExitNA
fun exitNA() {
    //> ExitNA:   rts
    return
}

// Decompiled from PlayerMovementSubs
fun playerMovementSubs() {
    var A: Int = 0
    var Y: Int = 0
    var climbSideTimer by MemoryByte(ClimbSideTimer)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    var playerState by MemoryByte(Player_State)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    //> PlayerMovementSubs:
    //> lda #$00                  ;set A to init crouch flag by default
    A = 0x00
    //> ldy PlayerSize            ;is player small?
    Y = playerSize
    //> bne SetCrouch             ;if so, branch
    if (Y == 0) {
        //> lda Player_State          ;check state of player
        A = playerState
        //> bne ProcMove              ;if not on the ground, branch
        if (A == 0) {
            //> lda Up_Down_Buttons       ;load controller bits for up and down
            A = upDownButtons
            //> and #%00000100            ;single out bit for down button
            A = A and 0x04
        }
    }
    //> SetCrouch: sta CrouchingFlag         ;store value in crouch flag
    crouchingFlag = A
    //> ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
    playerPhysicsSub()
    //> lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
    A = playerChangeSizeFlag
    //> bne NoMoveSub             ;branch to leave
    if (A == 0) {
        //> lda Player_State
        A = playerState
        //> cmp #$03                  ;get player state
        //> beq MoveSubs              ;if climbing, branch ahead, leave timer unset
        if (A != 0x03) {
            //> ldy #$18
            Y = 0x18
            //> sty ClimbSideTimer        ;otherwise reset timer now
            climbSideTimer = Y
        }
        //> MoveSubs:  jsr JumpEngine
        when (A) {
            0 -> {
                onGroundStateSub()
            }
            1 -> {
                jumpSwimSub()
            }
            2 -> {
                fallingSub()
            }
            3 -> {
                climbingSub()
            }
            else -> {
                // Unknown JumpEngine index
            }
        }
        return
        //> .dw OnGroundStateSub
        //> .dw JumpSwimSub
        //> .dw FallingSub
        //> .dw ClimbingSub
    }
    //> NoMoveSub: rts
    return
}

// Decompiled from OnGroundStateSub
fun onGroundStateSub() {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    //> OnGroundStateSub:
    //> jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
    getPlayerAnimSpeed()
    //> lda Left_Right_Buttons
    A = leftRightButtons
    //> beq GndMove                ;if left/right controller bits not set, skip instruction
    if (A != 0) {
        //> sta PlayerFacingDir        ;otherwise set new facing direction
        playerFacingDir = A
    }
    //> GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
    temp0 = imposeFriction(A)
    //> jsr MovePlayerHorizontally ;do another sub to move player horizontally
    temp1 = movePlayerHorizontally()
    //> sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
    playerXScroll = temp1
    //> rts
    return
}

// Decompiled from FallingSub
fun fallingSub() {
    var A: Int = 0
    var verticalForce by MemoryByte(VerticalForce)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    //> FallingSub:
    //> lda VerticalForceDown
    A = verticalForceDown
    //> sta VerticalForce      ;dump vertical movement force for falling into main one
    verticalForce = A
    //> jmp LRAir              ;movement force, then skip ahead to process left/right movement
    lRAir()
    return
}

// Decompiled from JumpSwimSub
fun jumpSwimSub() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var diffToHaltJump by MemoryByte(DiffToHaltJump)
    var jumporiginYPosition by MemoryByte(JumpOrigin_Y_Position)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    var verticalForce by MemoryByte(VerticalForce)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    //> JumpSwimSub:
    //> ldy Player_Y_Speed         ;if player's vertical speed zero
    Y = playerYSpeed
    //> bpl DumpFall               ;or moving downwards, branch to falling
    if ((Y and 0x80) != 0) {
        //> lda A_B_Buttons
        A = aBButtons
        //> and #A_Button              ;check to see if A button is being pressed
        A = A and A_Button
        //> and PreviousA_B_Buttons    ;and was pressed in previous frame
        A = A and previousaBButtons
        //> bne ProcSwim               ;if so, branch elsewhere
        if (A == 0) {
            //> lda JumpOrigin_Y_Position  ;get vertical position player jumped from
            A = jumporiginYPosition
            //> sec
            //> sbc Player_Y_Position      ;subtract current from original vertical coordinate
            temp0 = A - playerYPosition
            A = temp0 and 0xFF
            //> cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
            //> bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
            if (!(A >= diffToHaltJump)) {
                //  goto ProcSwim (internal forward branch)
                //> ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
                A = swimmingFlag
                //> beq LRAir                  ;branch ahead to last part
                if (A == 0) {
                    //  goto LRAir -> lRAir
                    lRAir()
                    return
                }
                //> jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
                getPlayerAnimSpeed()
                //> lda Player_Y_Position
                A = playerYPosition
                //> cmp #$14                   ;check vertical position against preset value
                //> bcs LRWater                ;if not yet reached a certain position, branch ahead
                if (A >= 0x14) {
                    //  goto LRWater (internal forward branch)
                    //> LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
                    A = leftRightButtons
                    //> beq LRAir                  ;if not pressing any, skip
                    if (A == 0) {
                        //  goto LRAir -> lRAir
                        lRAir()
                        return
                    }
                    //> sta PlayerFacingDir        ;otherwise set facing direction accordingly
                    playerFacingDir = A
                    //  Fall-through tail call to lRAir
                    lRAir()
                    return
                }
                //> lda #$18
                A = 0x18
                //> sta VerticalForce          ;otherwise set fractional
                verticalForce = A
                return
            }
        }
    }
    //> DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
    A = verticalForceDown
    //> sta VerticalForce
    verticalForce = A
    //> ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
    A = swimmingFlag
    //> beq LRAir                  ;branch ahead to last part
    if (A == 0) {
        //  goto LRAir -> lRAir
        lRAir()
        return
    } else {
        //> jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
        getPlayerAnimSpeed()
        //> lda Player_Y_Position
        A = playerYPosition
        //> cmp #$14                   ;check vertical position against preset value
        //> bcs LRWater                ;if not yet reached a certain position, branch ahead
        if (!(A >= 0x14)) {
            //> lda #$18
            A = 0x18
            //> sta VerticalForce          ;otherwise set fractional
            verticalForce = A
        }
    }
    //> LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
    A = leftRightButtons
    //> beq LRAir                  ;if not pressing any, skip
    if (A == 0) {
        //  goto LRAir -> lRAir
        lRAir()
        return
    } else {
        //> sta PlayerFacingDir        ;otherwise set facing direction accordingly
        playerFacingDir = A
        //  Fall-through tail call to lRAir
        lRAir()
        return
    }
}

// Decompiled from LRAir
fun lRAir() {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    var verticalForce by MemoryByte(VerticalForce)
    //> LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
    A = leftRightButtons
    //> beq JSMove                 ;if not pressing any, skip
    if (A != 0) {
        //> jsr ImposeFriction         ;otherwise process horizontal movement
        temp0 = imposeFriction(A)
    }
    //> JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
    temp1 = movePlayerHorizontally()
    //> sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
    playerXScroll = temp1
    //> lda GameEngineSubroutine
    A = gameEngineSubroutine
    //> cmp #$0b                   ;check for specific routine selected
    //> bne ExitMov1               ;branch if not set to run
    if (A == 0x0B) {
        //> lda #$28
        A = 0x28
        //> sta VerticalForce          ;otherwise set fractional
        verticalForce = A
    }
    //> ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
    movePlayerVertically()
    return
}

// Decompiled from ClimbingSub
fun climbingSub() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var climbSideTimer by MemoryByte(ClimbSideTimer)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYmfDummy by MemoryByte(Player_YMF_Dummy)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val climbAdderHigh by MemoryByteIndexed(ClimbAdderHigh)
    val climbAdderLow by MemoryByteIndexed(ClimbAdderLow)
    //> ClimbingSub:
    //> lda Player_YMF_Dummy
    A = playerYmfDummy
    //> clc                      ;add movement force to dummy variable
    //> adc Player_Y_MoveForce   ;save with carry
    temp0 = A + playerYMoveforce
    A = temp0 and 0xFF
    //> sta Player_YMF_Dummy
    playerYmfDummy = A
    //> ldy #$00                 ;set default adder here
    Y = 0x00
    //> lda Player_Y_Speed       ;get player's vertical speed
    A = playerYSpeed
    //> bpl MoveOnVine           ;if not moving upwards, branch
    if ((A and 0x80) != 0) {
        //> dey                      ;otherwise set adder to $ff
        Y = (Y - 1) and 0xFF
    }
    //> MoveOnVine:  sty $00                  ;store adder here
    memory[0x0] = Y.toUByte()
    //> adc Player_Y_Position    ;add carry to player's vertical position
    temp1 = A + playerYPosition + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta Player_Y_Position    ;and store to move player up or down
    playerYPosition = A
    //> lda Player_Y_HighPos
    A = playerYHighpos
    //> adc $00                  ;add carry to player's page location
    temp2 = A + memory[0x0].toInt() + if (temp1 > 0xFF) 1 else 0
    A = temp2 and 0xFF
    //> sta Player_Y_HighPos     ;and store
    playerYHighpos = A
    //> lda Left_Right_Buttons   ;compare left/right controller bits
    A = leftRightButtons
    //> and Player_CollisionBits ;to collision flag
    A = A and playerCollisionbits
    //> beq InitCSTimer          ;if not set, skip to end
    if (A != 0) {
        //> ldy ClimbSideTimer       ;otherwise check timer
        Y = climbSideTimer
        //> bne ExitCSub             ;if timer not expired, branch to leave
        if (Y == 0) {
            //> ldy #$18
            Y = 0x18
            //> sty ClimbSideTimer       ;otherwise set timer now
            climbSideTimer = Y
            //> ldx #$00                 ;set default offset here
            X = 0x00
            //> ldy PlayerFacingDir      ;get facing direction
            Y = playerFacingDir
            //> lsr                      ;move right button controller bit to carry
            val orig0: Int = A
            A = orig0 shr 1
            //> bcs ClimbFD              ;if controller right pressed, branch ahead
            if ((orig0 and 0x01) == 0) {
                //> inx
                X = (X + 1) and 0xFF
                //> inx                      ;otherwise increment offset by 2 bytes
                X = (X + 1) and 0xFF
            }
            //> ClimbFD:     dey                      ;check to see if facing right
            Y = (Y - 1) and 0xFF
            //> beq CSetFDir             ;if so, branch, do not increment
            if (Y != 0) {
                //> inx                      ;otherwise increment by 1 byte
                X = (X + 1) and 0xFF
            }
            //> CSetFDir:    lda Player_X_Position
            A = playerXPosition
            //> clc                      ;add or subtract from player's horizontal position
            //> adc ClimbAdderLow,x      ;using value here as adder and X as offset
            temp3 = A + climbAdderLow[X]
            A = temp3 and 0xFF
            //> sta Player_X_Position
            playerXPosition = A
            //> lda Player_PageLoc       ;add or subtract carry or borrow using value here
            A = playerPageloc
            //> adc ClimbAdderHigh,x     ;from the player's page location
            temp4 = A + climbAdderHigh[X] + if (temp3 > 0xFF) 1 else 0
            A = temp4 and 0xFF
            //> sta Player_PageLoc
            playerPageloc = A
            //> lda Left_Right_Buttons   ;get left/right controller bits again
            A = leftRightButtons
            //> eor #%00000011           ;invert them and store them while player
            A = A xor 0x03
            //> sta PlayerFacingDir      ;is on vine to face player in opposite direction
            playerFacingDir = A
        }
        //> ExitCSub:    rts                      ;then leave
        return
    } else {
        //> InitCSTimer: sta ClimbSideTimer       ;initialize timer here
        climbSideTimer = A
        //> rts
        return
    }
}

// Decompiled from PlayerPhysicsSub
fun playerPhysicsSub() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var diffToHaltJump by MemoryByte(DiffToHaltJump)
    var jumporiginYHighpos by MemoryByte(JumpOrigin_Y_HighPos)
    var jumporiginYPosition by MemoryByte(JumpOrigin_Y_Position)
    var jumpSwimTimer by MemoryByte(JumpSwimTimer)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    var playerSize by MemoryByte(PlayerSize)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerState by MemoryByte(Player_State)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerYmfDummy by MemoryByte(Player_YMF_Dummy)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    var verticalForce by MemoryByte(VerticalForce)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    var whirlpoolFlag by MemoryByte(Whirlpool_Flag)
    val climbYMforcedata by MemoryByteIndexed(Climb_Y_MForceData)
    val climbYSpeeddata by MemoryByteIndexed(Climb_Y_SpeedData)
    val fallMForceData by MemoryByteIndexed(FallMForceData)
    val initMForceData by MemoryByteIndexed(InitMForceData)
    val jumpMForceData by MemoryByteIndexed(JumpMForceData)
    val playerYSpdData by MemoryByteIndexed(PlayerYSpdData)
    //> PlayerPhysicsSub:
    //> lda Player_State          ;check player state
    A = playerState
    //> cmp #$03
    //> bne CheckForJumping       ;if not climbing, branch
    if (A == 0x03) {
        //> ldy #$00
        Y = 0x00
        //> lda Up_Down_Buttons       ;get controller bits for up/down
        A = upDownButtons
        //> and Player_CollisionBits  ;check against player's collision detection bits
        A = A and playerCollisionbits
        //> beq ProcClimb             ;if not pressing up or down, branch
        if (A != 0) {
            //> iny
            Y = (Y + 1) and 0xFF
            //> and #%00001000            ;check for pressing up
            A = A and 0x08
            //> bne ProcClimb
            if (A == 0) {
                //> iny
                Y = (Y + 1) and 0xFF
            }
        }
        //> ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
        X = climbYMforcedata[Y]
        //> stx Player_Y_MoveForce    ;store as vertical movement force
        playerYMoveforce = X
        //> lda #$08                  ;load default animation timing
        A = 0x08
        //> ldx Climb_Y_SpeedData,y   ;load some other value here
        X = climbYSpeeddata[Y]
        //> stx Player_Y_Speed        ;store as vertical speed
        playerYSpeed = X
        //> bmi SetCAnim              ;if climbing down, use default animation timing value
        if ((X and 0x80) == 0) {
            //> lsr                       ;otherwise divide timer setting by 2
            val orig0: Int = A
            A = orig0 shr 1
        }
        //> SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
        playerAnimTimerSet = A
        //> rts
        return
    } else {
        //> CheckForJumping:
        //> lda JumpspringAnimCtrl    ;if jumpspring animating,
        A = jumpspringAnimCtrl
        //> bne NoJump                ;skip ahead to something else
        if (A == 0) {
            //> lda A_B_Buttons           ;check for A button press
            A = aBButtons
            //> and #A_Button
            A = A and A_Button
            //> beq NoJump                ;if not, branch to something else
            if (A != 0) {
                //> and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
                A = A and previousaBButtons
                //> beq ProcJumping
                if (A == 0) {
                    //  goto ProcJumping (internal forward branch)
                    //> ProcJumping:
                    //> lda Player_State           ;check player state
                    A = playerState
                    //> beq InitJS                 ;if on the ground, branch
                    if (A == 0) {
                        //  goto InitJS (internal forward branch)
                        //> InitJS:    lda #$20                   ;set jump/swim timer
                        A = 0x20
                        //> sta JumpSwimTimer
                        jumpSwimTimer = A
                        //> ldy #$00                   ;initialize vertical force and dummy variable
                        Y = 0x00
                        //> sty Player_YMF_Dummy
                        playerYmfDummy = Y
                        //> sty Player_Y_MoveForce
                        playerYMoveforce = Y
                        //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
                        A = playerYHighpos
                        //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
                        jumporiginYHighpos = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> sta JumpOrigin_Y_Position
                        jumporiginYPosition = A
                        //> lda #$01                   ;set player state to jumping/swimming
                        A = 0x01
                        //> sta Player_State
                        playerState = A
                        //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
                        A = playerXspeedabsolute
                        //> cmp #$09
                        //> bcc ChkWtr                 ;branch if below certain values, increment Y
                        if (!(A >= 0x09)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny                        ;for each amount equal or exceeded
                        Y = (Y + 1) and 0xFF
                        //> cmp #$10
                        //> bcc ChkWtr
                        if (!(A >= 0x10)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> cmp #$19
                        //> bcc ChkWtr
                        if (!(A >= 0x19)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> cmp #$1c
                        //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                        if (!(A >= 0x1C)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        return
                    }
                    //> lda SwimmingFlag           ;if swimming flag not set, jump to do something else
                    A = swimmingFlag
                    //> beq NoJump                 ;to prevent midair jumping, otherwise continue
                    //> lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
                    A = jumpSwimTimer
                    //> bne InitJS
                    if (!(A == 0)) {
                        //  goto InitJS (internal forward branch)
                        //> InitJS:    lda #$20                   ;set jump/swim timer
                        A = 0x20
                        //> sta JumpSwimTimer
                        jumpSwimTimer = A
                        //> ldy #$00                   ;initialize vertical force and dummy variable
                        Y = 0x00
                        //> sty Player_YMF_Dummy
                        playerYmfDummy = Y
                        //> sty Player_Y_MoveForce
                        playerYMoveforce = Y
                        //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
                        A = playerYHighpos
                        //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
                        jumporiginYHighpos = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> sta JumpOrigin_Y_Position
                        jumporiginYPosition = A
                        //> lda #$01                   ;set player state to jumping/swimming
                        A = 0x01
                        //> sta Player_State
                        playerState = A
                        //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
                        A = playerXspeedabsolute
                        //> cmp #$09
                        //> bcc ChkWtr                 ;branch if below certain values, increment Y
                        if (!(A >= 0x09)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny                        ;for each amount equal or exceeded
                        Y = (Y + 1) and 0xFF
                        //> cmp #$10
                        //> bcc ChkWtr
                        if (!(A >= 0x10)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> cmp #$19
                        //> bcc ChkWtr
                        if (!(A >= 0x19)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> cmp #$1c
                        //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                        if (!(A >= 0x1C)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        return
                    }
                    //> lda Player_Y_Speed         ;check player's vertical speed
                    A = playerYSpeed
                    //> bpl InitJS                 ;if player's vertical speed motionless or down, branch
                    if (!((A and 0x80) != 0)) {
                        //  goto InitJS (internal forward branch)
                        //> InitJS:    lda #$20                   ;set jump/swim timer
                        A = 0x20
                        //> sta JumpSwimTimer
                        jumpSwimTimer = A
                        //> ldy #$00                   ;initialize vertical force and dummy variable
                        Y = 0x00
                        //> sty Player_YMF_Dummy
                        playerYmfDummy = Y
                        //> sty Player_Y_MoveForce
                        playerYMoveforce = Y
                        //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
                        A = playerYHighpos
                        //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
                        jumporiginYHighpos = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> sta JumpOrigin_Y_Position
                        jumporiginYPosition = A
                        //> lda #$01                   ;set player state to jumping/swimming
                        A = 0x01
                        //> sta Player_State
                        playerState = A
                        //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
                        A = playerXspeedabsolute
                        //> cmp #$09
                        //> bcc ChkWtr                 ;branch if below certain values, increment Y
                        if (!(A >= 0x09)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny                        ;for each amount equal or exceeded
                        Y = (Y + 1) and 0xFF
                        //> cmp #$10
                        //> bcc ChkWtr
                        if (!(A >= 0x10)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> cmp #$19
                        //> bcc ChkWtr
                        if (!(A >= 0x19)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> cmp #$1c
                        //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                        if (!(A >= 0x1C)) {
                            //  goto ChkWtr (internal forward branch)
                            //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                            A = 0x01
                            //> sta DiffToHaltJump
                            diffToHaltJump = A
                            //> lda SwimmingFlag           ;if swimming flag disabled, branch
                            A = swimmingFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                            Y = 0x05
                            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                            A = whirlpoolFlag
                            //> beq GetYPhy
                            if (A == 0) {
                                //  goto GetYPhy (internal forward branch)
                                //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                                A = jumpMForceData[Y]
                                //> sta VerticalForce          ;data here
                                verticalForce = A
                                //> lda FallMForceData,y
                                A = fallMForceData[Y]
                                //> sta VerticalForceDown
                                verticalForceDown = A
                                //> lda InitMForceData,y
                                A = initMForceData[Y]
                                //> sta Player_Y_MoveForce
                                playerYMoveforce = A
                                //> lda PlayerYSpdData,y
                                A = playerYSpdData[Y]
                                //> sta Player_Y_Speed
                                playerYSpeed = A
                                //> lda SwimmingFlag           ;if swimming flag disabled, branch
                                A = swimmingFlag
                                //> beq PJumpSnd
                                if (A == 0) {
                                    //  goto PJumpSnd (internal forward branch)
                                    //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                                    A = Sfx_BigJump
                                    //> ldy PlayerSize             ;is mario big?
                                    Y = playerSize
                                    //> beq SJumpSnd
                                    if (Y == 0) {
                                        //  goto SJumpSnd (internal forward branch)
                                        //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                        square1SoundQueue = A
                                        //  Fall-through tail call to xPhysics
                                        xPhysics()
                                        return
                                    }
                                    //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                                    A = Sfx_SmallJump
                                    return
                                }
                                //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                                A = Sfx_EnemyStomp
                                //> sta Square1SoundQueue      ;square 1's sfx queue
                                square1SoundQueue = A
                                //> lda Player_Y_Position
                                A = playerYPosition
                                //> cmp #$14                   ;check vertical low byte of player position
                                //> bcs X_Physics              ;if below a certain point, branch
                                if (A >= 0x14) {
                                    //  goto X_Physics -> xPhysics
                                    xPhysics()
                                    return
                                }
                                //> lda #$00                   ;otherwise reset player's vertical speed
                                A = 0x00
                                //> sta Player_Y_Speed         ;and jump to something else to keep player
                                playerYSpeed = A
                                //> jmp X_Physics              ;from swimming above water level
                                xPhysics()
                                return
                            }
                            //> iny                        ;otherwise increment to 6
                            Y = (Y + 1) and 0xFF
                            return
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        return
                    }
                    //> jmp X_Physics              ;if timer at zero and player still rising, do not swim
                    xPhysics()
                    return
                }
            } else {
                //> NoJump: jmp X_Physics             ;otherwise, jump to something else
                xPhysics()
                return
            }
            //> ProcJumping:
            //> lda Player_State           ;check player state
            A = playerState
            //> beq InitJS                 ;if on the ground, branch
            if (A == 0) {
                //  goto InitJS (internal forward branch)
                //> InitJS:    lda #$20                   ;set jump/swim timer
                A = 0x20
                //> sta JumpSwimTimer
                jumpSwimTimer = A
                //> ldy #$00                   ;initialize vertical force and dummy variable
                Y = 0x00
                //> sty Player_YMF_Dummy
                playerYmfDummy = Y
                //> sty Player_Y_MoveForce
                playerYMoveforce = Y
                //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
                A = playerYHighpos
                //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
                jumporiginYHighpos = A
                //> lda Player_Y_Position
                A = playerYPosition
                //> sta JumpOrigin_Y_Position
                jumporiginYPosition = A
                //> lda #$01                   ;set player state to jumping/swimming
                A = 0x01
                //> sta Player_State
                playerState = A
                //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
                A = playerXspeedabsolute
                //> cmp #$09
                //> bcc ChkWtr                 ;branch if below certain values, increment Y
                if (!(A >= 0x09)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny                        ;for each amount equal or exceeded
                Y = (Y + 1) and 0xFF
                //> cmp #$10
                //> bcc ChkWtr
                if (!(A >= 0x10)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> cmp #$19
                //> bcc ChkWtr
                if (!(A >= 0x19)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> cmp #$1c
                //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                if (!(A >= 0x1C)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                return
            }
            //> lda SwimmingFlag           ;if swimming flag not set, jump to do something else
            A = swimmingFlag
            //> beq NoJump                 ;to prevent midair jumping, otherwise continue
            if (A == 0) {
                //> NoJump: jmp X_Physics             ;otherwise, jump to something else
                xPhysics()
                return
            }
            //> lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
            A = jumpSwimTimer
            //> bne InitJS
            if (!(A == 0)) {
                //  goto InitJS (internal forward branch)
                //> InitJS:    lda #$20                   ;set jump/swim timer
                A = 0x20
                //> sta JumpSwimTimer
                jumpSwimTimer = A
                //> ldy #$00                   ;initialize vertical force and dummy variable
                Y = 0x00
                //> sty Player_YMF_Dummy
                playerYmfDummy = Y
                //> sty Player_Y_MoveForce
                playerYMoveforce = Y
                //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
                A = playerYHighpos
                //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
                jumporiginYHighpos = A
                //> lda Player_Y_Position
                A = playerYPosition
                //> sta JumpOrigin_Y_Position
                jumporiginYPosition = A
                //> lda #$01                   ;set player state to jumping/swimming
                A = 0x01
                //> sta Player_State
                playerState = A
                //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
                A = playerXspeedabsolute
                //> cmp #$09
                //> bcc ChkWtr                 ;branch if below certain values, increment Y
                if (!(A >= 0x09)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny                        ;for each amount equal or exceeded
                Y = (Y + 1) and 0xFF
                //> cmp #$10
                //> bcc ChkWtr
                if (!(A >= 0x10)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> cmp #$19
                //> bcc ChkWtr
                if (!(A >= 0x19)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> cmp #$1c
                //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                if (!(A >= 0x1C)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                return
            }
            //> lda Player_Y_Speed         ;check player's vertical speed
            A = playerYSpeed
            //> bpl InitJS                 ;if player's vertical speed motionless or down, branch
            if (!((A and 0x80) != 0)) {
                //  goto InitJS (internal forward branch)
                //> InitJS:    lda #$20                   ;set jump/swim timer
                A = 0x20
                //> sta JumpSwimTimer
                jumpSwimTimer = A
                //> ldy #$00                   ;initialize vertical force and dummy variable
                Y = 0x00
                //> sty Player_YMF_Dummy
                playerYmfDummy = Y
                //> sty Player_Y_MoveForce
                playerYMoveforce = Y
                //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
                A = playerYHighpos
                //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
                jumporiginYHighpos = A
                //> lda Player_Y_Position
                A = playerYPosition
                //> sta JumpOrigin_Y_Position
                jumporiginYPosition = A
                //> lda #$01                   ;set player state to jumping/swimming
                A = 0x01
                //> sta Player_State
                playerState = A
                //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
                A = playerXspeedabsolute
                //> cmp #$09
                //> bcc ChkWtr                 ;branch if below certain values, increment Y
                if (!(A >= 0x09)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny                        ;for each amount equal or exceeded
                Y = (Y + 1) and 0xFF
                //> cmp #$10
                //> bcc ChkWtr
                if (!(A >= 0x10)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> cmp #$19
                //> bcc ChkWtr
                if (!(A >= 0x19)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> cmp #$1c
                //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                if (!(A >= 0x1C)) {
                    //  goto ChkWtr (internal forward branch)
                    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
                    A = 0x01
                    //> sta DiffToHaltJump
                    diffToHaltJump = A
                    //> lda SwimmingFlag           ;if swimming flag disabled, branch
                    A = swimmingFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
                    Y = 0x05
                    //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
                    A = whirlpoolFlag
                    //> beq GetYPhy
                    if (A == 0) {
                        //  goto GetYPhy (internal forward branch)
                        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
                        A = jumpMForceData[Y]
                        //> sta VerticalForce          ;data here
                        verticalForce = A
                        //> lda FallMForceData,y
                        A = fallMForceData[Y]
                        //> sta VerticalForceDown
                        verticalForceDown = A
                        //> lda InitMForceData,y
                        A = initMForceData[Y]
                        //> sta Player_Y_MoveForce
                        playerYMoveforce = A
                        //> lda PlayerYSpdData,y
                        A = playerYSpdData[Y]
                        //> sta Player_Y_Speed
                        playerYSpeed = A
                        //> lda SwimmingFlag           ;if swimming flag disabled, branch
                        A = swimmingFlag
                        //> beq PJumpSnd
                        if (A == 0) {
                            //  goto PJumpSnd (internal forward branch)
                            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
                            A = Sfx_BigJump
                            //> ldy PlayerSize             ;is mario big?
                            Y = playerSize
                            //> beq SJumpSnd
                            if (Y == 0) {
                                //  goto SJumpSnd (internal forward branch)
                                //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
                                square1SoundQueue = A
                                //  Fall-through tail call to xPhysics
                                xPhysics()
                                return
                            }
                            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                            A = Sfx_SmallJump
                            return
                        }
                        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
                        A = Sfx_EnemyStomp
                        //> sta Square1SoundQueue      ;square 1's sfx queue
                        square1SoundQueue = A
                        //> lda Player_Y_Position
                        A = playerYPosition
                        //> cmp #$14                   ;check vertical low byte of player position
                        //> bcs X_Physics              ;if below a certain point, branch
                        if (A >= 0x14) {
                            //  goto X_Physics -> xPhysics
                            xPhysics()
                            return
                        }
                        //> lda #$00                   ;otherwise reset player's vertical speed
                        A = 0x00
                        //> sta Player_Y_Speed         ;and jump to something else to keep player
                        playerYSpeed = A
                        //> jmp X_Physics              ;from swimming above water level
                        xPhysics()
                        return
                    }
                    //> iny                        ;otherwise increment to 6
                    Y = (Y + 1) and 0xFF
                    return
                }
                //> iny
                Y = (Y + 1) and 0xFF
                return
            }
            //> jmp X_Physics              ;if timer at zero and player still rising, do not swim
            xPhysics()
            return
        } else {
            //> NoJump: jmp X_Physics             ;otherwise, jump to something else
            xPhysics()
            return
        }
    }
    //> iny                        ;for each amount equal or exceeded
    Y = (Y + 1) and 0xFF
    //> cmp #$10
    //> bcc ChkWtr
    if (A >= 0x10) {
        //> iny
        Y = (Y + 1) and 0xFF
        //> cmp #$19
        //> bcc ChkWtr
        if (A >= 0x19) {
            //> iny
            Y = (Y + 1) and 0xFF
            //> cmp #$1c
            //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
            if (A >= 0x1C) {
                //> iny
                Y = (Y + 1) and 0xFF
            }
        }
    }
    //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
    A = 0x01
    //> sta DiffToHaltJump
    diffToHaltJump = A
    //> lda SwimmingFlag           ;if swimming flag disabled, branch
    A = swimmingFlag
    //> beq GetYPhy
    if (A != 0) {
        //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
        Y = 0x05
        //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
        A = whirlpoolFlag
        //> beq GetYPhy
        if (A != 0) {
            //> iny                        ;otherwise increment to 6
            Y = (Y + 1) and 0xFF
        }
    }
    //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
    A = jumpMForceData[Y]
    //> sta VerticalForce          ;data here
    verticalForce = A
    //> lda FallMForceData,y
    A = fallMForceData[Y]
    //> sta VerticalForceDown
    verticalForceDown = A
    //> lda InitMForceData,y
    A = initMForceData[Y]
    //> sta Player_Y_MoveForce
    playerYMoveforce = A
    //> lda PlayerYSpdData,y
    A = playerYSpdData[Y]
    //> sta Player_Y_Speed
    playerYSpeed = A
    //> lda SwimmingFlag           ;if swimming flag disabled, branch
    A = swimmingFlag
    //> beq PJumpSnd
    if (A != 0) {
        //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
        A = Sfx_EnemyStomp
        //> sta Square1SoundQueue      ;square 1's sfx queue
        square1SoundQueue = A
        //> lda Player_Y_Position
        A = playerYPosition
        //> cmp #$14                   ;check vertical low byte of player position
        //> bcs X_Physics              ;if below a certain point, branch
        if (A >= 0x14) {
            //  goto X_Physics -> xPhysics
            xPhysics()
            return
        }
        //> lda #$00                   ;otherwise reset player's vertical speed
        A = 0x00
        //> sta Player_Y_Speed         ;and jump to something else to keep player
        playerYSpeed = A
        //> jmp X_Physics              ;from swimming above water level
        xPhysics()
        return
    } else {
        //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
        A = Sfx_BigJump
        //> ldy PlayerSize             ;is mario big?
        Y = playerSize
        //> beq SJumpSnd
        if (Y != 0) {
            //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
            A = Sfx_SmallJump
        }
    }
    //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
    square1SoundQueue = A
    //  Fall-through tail call to xPhysics
    xPhysics()
    return
}

// Decompiled from X_Physics
fun xPhysics() {
    var A: Int = 0
    var Y: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var areaType by MemoryByte(AreaType)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerState by MemoryByte(Player_State)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var runningSpeed by MemoryByte(RunningSpeed)
    var runningTimer by MemoryByte(RunningTimer)
    //> X_Physics: ldy #$00
    Y = 0x00
    //> sty $00                    ;init value here
    memory[0x0] = Y.toUByte()
    //> lda Player_State           ;if mario is on the ground, branch
    A = playerState
    //> beq ProcPRun
    if (A != 0) {
        //> lda Player_XSpeedAbsolute  ;check something that seems to be related
        A = playerXspeedabsolute
        //> cmp #$19                   ;to mario's speed
        //> bcs GetXPhy                ;if =>$19 branch here
        if (A >= 0x19) {
            //  goto GetXPhy -> getXPhy
            getXPhy(Y)
            return
        }
        //> bcc ChkRFast               ;if not branch elsewhere
        if (!(A >= 0x19)) {
            //  goto ChkRFast (internal forward branch)
            //> ChkRFast:  iny                        ;if running timer not set or level type is water,
            Y = (Y + 1) and 0xFF
            //> inc $00                    ;increment Y again and temp variable in memory
            memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
            //> lda RunningSpeed
            A = runningSpeed
            //> bne FastXSp                ;if running speed set here, branch
            if (!(A == 0)) {
                //  goto FastXSp (internal forward branch)
                //> FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
                memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
                //> jmp GetXPhy                ;and jump ahead
                getXPhy(Y)
                return
            }
            //> lda Player_XSpeedAbsolute
            A = playerXspeedabsolute
            //> cmp #$21                   ;otherwise check player's walking/running speed
            //> bcc GetXPhy                ;if less than a certain amount, branch ahead
            if (!(A >= 0x21)) {
                //  goto GetXPhy -> getXPhy
                getXPhy(Y)
                return
            }
            return
        }
    }
    //> ProcPRun:  iny                        ;if mario on the ground, increment Y
    Y = (Y + 1) and 0xFF
    //> lda AreaType               ;check area type
    A = areaType
    //> beq ChkRFast               ;if water type, branch
    if (A != 0) {
        //> dey                        ;decrement Y by default for non-water type area
        Y = (Y - 1) and 0xFF
        //> lda Left_Right_Buttons     ;get left/right controller bits
        A = leftRightButtons
        //> cmp Player_MovingDir       ;check against moving direction
        //> bne ChkRFast               ;if controller bits <> moving direction, skip this part
        if (A == playerMovingdir) {
            //> lda A_B_Buttons            ;check for b button pressed
            A = aBButtons
            //> and #B_Button
            A = A and B_Button
            //> bne SetRTmr                ;if pressed, skip ahead to set timer
            if (A == 0) {
                //> lda RunningTimer           ;check for running timer set
                A = runningTimer
                //> bne GetXPhy                ;if set, branch
                if (!(A == 0)) {
                    //  goto GetXPhy -> getXPhy
                    getXPhy(Y)
                    return
                }
            }
        }
    }
    //> ChkRFast:  iny                        ;if running timer not set or level type is water,
    Y = (Y + 1) and 0xFF
    //> inc $00                    ;increment Y again and temp variable in memory
    memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
    //> lda RunningSpeed
    A = runningSpeed
    //> bne FastXSp                ;if running speed set here, branch
    if (A == 0) {
        //> lda Player_XSpeedAbsolute
        A = playerXspeedabsolute
        //> cmp #$21                   ;otherwise check player's walking/running speed
        //> bcc GetXPhy                ;if less than a certain amount, branch ahead
        if (!(A >= 0x21)) {
            //  goto GetXPhy -> getXPhy
            getXPhy(Y)
            return
        }
    }
    //> FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
    memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
    //> jmp GetXPhy                ;and jump ahead
    getXPhy(Y)
    return
    //> SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
    A = 0x0A
    //> sta RunningTimer
    runningTimer = A
    //  Fall-through tail call to getXPhy
    getXPhy(Y)
    return
}

// Decompiled from GetXPhy
fun getXPhy(Y: Int) {
    var A: Int = 0
    var Y: Int = Y
    var frictionAdderHigh by MemoryByte(FrictionAdderHigh)
    var frictionAdderLow by MemoryByte(FrictionAdderLow)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var maximumLeftSpeed by MemoryByte(MaximumLeftSpeed)
    var maximumRightSpeed by MemoryByte(MaximumRightSpeed)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    val frictionData by MemoryByteIndexed(FrictionData)
    val maxLeftXSpdData by MemoryByteIndexed(MaxLeftXSpdData)
    val maxRightXSpdData by MemoryByteIndexed(MaxRightXSpdData)
    //> GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
    A = maxLeftXSpdData[Y]
    //> sta MaximumLeftSpeed
    maximumLeftSpeed = A
    //> lda GameEngineSubroutine   ;check for specific routine running
    A = gameEngineSubroutine
    //> cmp #$07                   ;(player entrance)
    //> bne GetXPhy2               ;if not running, skip and use old value of Y
    Y = Y
    if (A == 0x07) {
        //> ldy #$03                   ;otherwise set Y to 3
        Y = 0x03
    }
    //> GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
    A = maxRightXSpdData[Y]
    //> sta MaximumRightSpeed
    maximumRightSpeed = A
    //> ldy $00                    ;get other value in memory
    Y = memory[0x0].toInt()
    //> lda FrictionData,y         ;get value using value in memory as offset
    A = frictionData[Y]
    //> sta FrictionAdderLow
    frictionAdderLow = A
    //> lda #$00
    A = 0x00
    //> sta FrictionAdderHigh      ;init something here
    frictionAdderHigh = A
    //> lda PlayerFacingDir
    A = playerFacingDir
    //> cmp Player_MovingDir       ;check facing direction against moving direction
    //> beq ExitPhy                ;if the same, branch to leave
    if (A != playerMovingdir) {
        //> asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
        val orig0: Int = frictionAdderLow
        val carryFromAsl1: Boolean = (orig0 and 0x80) != 0
        frictionAdderLow = (orig0 shl 1) and 0xFF
        //> rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
        frictionAdderHigh = (frictionAdderHigh shl 1) and 0xFE or if (carryFromAsl1) 1 else 0
    }
    //> ExitPhy:   rts                        ;and then leave
    return
}

// Decompiled from GetPlayerAnimSpeed
fun getPlayerAnimSpeed() {
    var A: Int = 0
    var Y: Int = 0
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerXMoveforce by MemoryByte(Player_X_MoveForce)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var runningSpeed by MemoryByte(RunningSpeed)
    var savedJoypadBits by MemoryByte(SavedJoypadBits)
    //> GetPlayerAnimSpeed:
    //> ldy #$00                   ;initialize offset in Y
    Y = 0x00
    //> lda Player_XSpeedAbsolute  ;check player's walking/running speed
    A = playerXspeedabsolute
    //> cmp #$1c                   ;against preset amount
    //> bcs SetRunSpd              ;if greater than a certain amount, branch ahead
    if (!(A >= 0x1C)) {
        //> iny                        ;otherwise increment Y
        Y = (Y + 1) and 0xFF
        //> cmp #$0e                   ;compare against lower amount
        //> bcs ChkSkid                ;if greater than this but not greater than first, skip increment
        if (!(A >= 0x0E)) {
            //> iny                        ;otherwise increment Y again
            Y = (Y + 1) and 0xFF
        }
        //> ChkSkid:    lda SavedJoypadBits        ;get controller bits
        A = savedJoypadBits
        //> and #%01111111             ;mask out A button
        A = A and 0x7F
        //> beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
        if (A == 0) {
            //  goto SetAnimSpd -> setAnimSpd
            setAnimSpd(Y)
            return
        }
        //> and #$03                   ;mask out all others except left and right
        A = A and 0x03
        //> cmp Player_MovingDir       ;check against moving direction
        //> bne ProcSkid               ;if left/right controller bits <> moving direction, branch
        if (A == playerMovingdir) {
            //> lda #$00                   ;otherwise set zero value here
            A = 0x00
        }
    }
    //> SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
    runningSpeed = A
    //> jmp SetAnimSpd
    setAnimSpd(Y)
    return
    //> ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
    A = playerXspeedabsolute
    //> cmp #$0b                   ;against one last amount
    //> bcs SetAnimSpd             ;if greater than this amount, branch
    if (A >= 0x0B) {
        //  goto SetAnimSpd -> setAnimSpd
        setAnimSpd(Y)
        return
    } else {
        //> lda PlayerFacingDir
        A = playerFacingDir
        //> sta Player_MovingDir       ;otherwise use facing direction to set moving direction
        playerMovingdir = A
        //> lda #$00
        A = 0x00
        //> sta Player_X_Speed         ;nullify player's horizontal speed
        playerXSpeed = A
        //> sta Player_X_MoveForce     ;and dummy variable for player
        playerXMoveforce = A
        //  Fall-through tail call to setAnimSpd
        setAnimSpd(Y)
        return
    }
}

// Decompiled from SetAnimSpd
fun setAnimSpd(Y: Int) {
    var A: Int = 0
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    val playerAnimTmrData by MemoryByteIndexed(PlayerAnimTmrData)
    //> SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
    A = playerAnimTmrData[Y]
    //> sta PlayerAnimTimerSet
    playerAnimTimerSet = A
    //> rts
    return
}

// Decompiled from ImposeFriction
fun imposeFriction(A: Int): Int {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var frictionAdderHigh by MemoryByte(FrictionAdderHigh)
    var frictionAdderLow by MemoryByte(FrictionAdderLow)
    var maximumLeftSpeed by MemoryByte(MaximumLeftSpeed)
    var maximumRightSpeed by MemoryByte(MaximumRightSpeed)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerXMoveforce by MemoryByte(Player_X_MoveForce)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> ImposeFriction:
    //> and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
    A = A and playerCollisionbits
    //> cmp #$00                  ;then compare to zero (this instruction is redundant)
    //> bne JoypFrict             ;if any bits set, branch to next part
    A = A
    if (A == 0x00) {
        //> lda Player_X_Speed
        A = playerXSpeed
        //> beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
        if (A == 0) {
            //  goto SetAbsSpd -> setAbsSpd
            setAbsSpd(A)
            return A
        }
        //> bpl RghtFrict             ;if player moving to the right, branch to slow
        if ((A and 0x80) != 0) {
            //> bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
            if ((A and 0x80) != 0) {
                //  goto LeftFrict (internal forward branch)
                //> LeftFrict: lda Player_X_MoveForce    ;load value set here
                A = playerXMoveforce
                //> clc
                //> adc FrictionAdderLow      ;add to it another value set here
                temp0 = A + frictionAdderLow
                A = temp0 and 0xFF
                //> sta Player_X_MoveForce    ;store here
                playerXMoveforce = A
                //> lda Player_X_Speed
                A = playerXSpeed
                //> adc FrictionAdderHigh     ;add value plus carry to horizontal speed
                temp1 = A + frictionAdderHigh + if (temp0 > 0xFF) 1 else 0
                A = temp1 and 0xFF
                //> sta Player_X_Speed        ;set as new horizontal speed
                playerXSpeed = A
                //> cmp MaximumRightSpeed     ;compare against maximum value for right movement
                //> bmi XSpdSign              ;if horizontal speed greater negatively, branch
                if (((A - maximumRightSpeed) and 0xFF and 0x80) != 0) {
                    //  goto XSpdSign (internal forward branch)
                    //> XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
                    //> bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
                    if (!(((A) and 0xFF and 0x80) != 0)) {
                        //  goto SetAbsSpd -> setAbsSpd
                        setAbsSpd(A)
                        return A
                    }
                    //> eor #$ff
                    A = A xor 0xFF
                    //> clc                       ;otherwise get two's compliment to get absolute
                    //> adc #$01                  ;unsigned walking/running speed
                    temp2 = A + 0x01
                    A = temp2 and 0xFF
                    //  Fall-through tail call to setAbsSpd
                    setAbsSpd(A)
                    return A
                }
                //> lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
                A = maximumRightSpeed
                //> sta Player_X_Speed        ;thus slowing the player's left movement down
                playerXSpeed = A
                //> jmp SetAbsSpd             ;skip to the end
                setAbsSpd(A)
                return A
            }
        }
    }
    //> JoypFrict: lsr                       ;put right controller bit into carry
    val orig0: Int = A
    A = orig0 shr 1
    //> bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
    if ((orig0 and 0x01) != 0) {
        //> LeftFrict: lda Player_X_MoveForce    ;load value set here
        A = playerXMoveforce
        //> clc
        //> adc FrictionAdderLow      ;add to it another value set here
        temp3 = A + frictionAdderLow
        A = temp3 and 0xFF
        //> sta Player_X_MoveForce    ;store here
        playerXMoveforce = A
        //> lda Player_X_Speed
        A = playerXSpeed
        //> adc FrictionAdderHigh     ;add value plus carry to horizontal speed
        temp4 = A + frictionAdderHigh + if (temp3 > 0xFF) 1 else 0
        A = temp4 and 0xFF
        //> sta Player_X_Speed        ;set as new horizontal speed
        playerXSpeed = A
        //> cmp MaximumRightSpeed     ;compare against maximum value for right movement
        //> bmi XSpdSign              ;if horizontal speed greater negatively, branch
        if (((A - maximumRightSpeed) and 0xFF and 0x80) == 0) {
            //> lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
            A = maximumRightSpeed
            //> sta Player_X_Speed        ;thus slowing the player's left movement down
            playerXSpeed = A
            //> jmp SetAbsSpd             ;skip to the end
            setAbsSpd(A)
            return A
        }
    }
    //> RghtFrict: lda Player_X_MoveForce    ;load value set here
    A = playerXMoveforce
    //> sec
    //> sbc FrictionAdderLow      ;subtract from it another value set here
    temp5 = A - frictionAdderLow
    A = temp5 and 0xFF
    //> sta Player_X_MoveForce    ;store here
    playerXMoveforce = A
    //> lda Player_X_Speed
    A = playerXSpeed
    //> sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
    temp6 = A - frictionAdderHigh - if (temp5 >= 0) 0 else 1
    A = temp6 and 0xFF
    //> sta Player_X_Speed        ;set as new horizontal speed
    playerXSpeed = A
    //> cmp MaximumLeftSpeed      ;compare against maximum value for left movement
    //> bpl XSpdSign              ;if horizontal speed greater positively, branch
    if (((A - maximumLeftSpeed) and 0xFF and 0x80) != 0) {
        //> lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
        A = maximumLeftSpeed
        //> sta Player_X_Speed        ;thus slowing the player's right movement down
        playerXSpeed = A
    }
    //> XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
    //> bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
    if (!(((A) and 0xFF and 0x80) != 0)) {
        //  goto SetAbsSpd -> setAbsSpd
        setAbsSpd(A)
        return A
    } else {
        //> eor #$ff
        A = A xor 0xFF
        //> clc                       ;otherwise get two's compliment to get absolute
        //> adc #$01                  ;unsigned walking/running speed
        temp7 = A + 0x01
        A = temp7 and 0xFF
        //  Fall-through tail call to setAbsSpd
        setAbsSpd(A)
        return A
    }
}

// Decompiled from SetAbsSpd
fun setAbsSpd(A: Int) {
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    //> SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
    playerXspeedabsolute = A
    //> rts
    return
}

// Decompiled from ProcFireball_Bubble
fun procfireballBubble() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var areaType by MemoryByte(AreaType)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var fireballCounter by MemoryByte(FireballCounter)
    var fireballThrowingTimer by MemoryByte(FireballThrowingTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    var playerStatus by MemoryByte(PlayerStatus)
    var playerState by MemoryByte(Player_State)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val fireballState by MemoryByteIndexed(Fireball_State)
    //> ProcFireball_Bubble:
    //> lda PlayerStatus           ;check player's status
    A = playerStatus
    //> cmp #$02
    //> bcc ProcAirBubbles         ;if not fiery, branch
    if (A >= 0x02) {
        //> lda A_B_Buttons
        A = aBButtons
        //> and #B_Button              ;check for b button pressed
        A = A and B_Button
        //> beq ProcFireballs          ;branch if not pressed
        if (A != 0) {
            //> and PreviousA_B_Buttons
            A = A and previousaBButtons
            //> bne ProcFireballs          ;if button pressed in previous frame, branch
            if (A == 0) {
                //> lda FireballCounter        ;load fireball counter
                A = fireballCounter
                //> and #%00000001             ;get LSB and use as offset for buffer
                A = A and 0x01
                //> tax
                X = A
                //> lda Fireball_State,x       ;load fireball state
                A = fireballState[X]
                //> bne ProcFireballs          ;if not inactive, branch
                X = X
                if (A == 0) {
                    //> ldy Player_Y_HighPos       ;if player too high or too low, branch
                    Y = playerYHighpos
                    //> dey
                    Y = (Y - 1) and 0xFF
                    //> bne ProcFireballs
                    if (Y == 0) {
                        //> lda CrouchingFlag          ;if player crouching, branch
                        A = crouchingFlag
                        //> bne ProcFireballs
                        if (A == 0) {
                            //> lda Player_State           ;if player's state = climbing, branch
                            A = playerState
                            //> cmp #$03
                            //> beq ProcFireballs
                            if (A != 0x03) {
                                //> lda #Sfx_Fireball          ;play fireball sound effect
                                A = Sfx_Fireball
                                //> sta Square1SoundQueue
                                square1SoundQueue = A
                                //> lda #$02                   ;load state
                                A = 0x02
                                //> sta Fireball_State,x
                                fireballState[X] = A
                                //> ldy PlayerAnimTimerSet     ;copy animation frame timer setting
                                Y = playerAnimTimerSet
                                //> sty FireballThrowingTimer  ;into fireball throwing timer
                                fireballThrowingTimer = Y
                                //> dey
                                Y = (Y - 1) and 0xFF
                                //> sty PlayerAnimTimer        ;decrement and store in player's animation timer
                                playerAnimTimer = Y
                                //> inc FireballCounter        ;increment fireball counter
                                fireballCounter = (fireballCounter + 1) and 0xFF
                            }
                        }
                    }
                }
            }
        }
        //> ProcFireballs:
        //> ldx #$00
        X = 0x00
        //> jsr FireballObjCore  ;process first fireball object
        fireballObjCore(X)
        //> ldx #$01
        X = 0x01
        //> jsr FireballObjCore  ;process second fireball object, then do air bubbles
        fireballObjCore(X)
    }
    //> ProcAirBubbles:
    //> lda AreaType                ;if not water type level, skip the rest of this
    A = areaType
    //> bne BublExit
    if (A == 0) {
        //> ldx #$02                    ;otherwise load counter and use as offset
        X = 0x02
        loop0@ do {
            //> BublLoop: stx ObjectOffset            ;store offset
            objectOffset = X
            //> jsr BubbleCheck             ;check timers and coordinates, create air bubble
            bubbleCheck(X)
            //> jsr RelativeBubblePosition  ;get relative coordinates
            temp0 = relativeBubblePosition(X)
            X = temp0
            //> jsr GetBubbleOffscreenBits  ;get offscreen information
            temp1 = getBubbleOffscreenBits(temp0)
            X = temp1
            //> jsr DrawBubble              ;draw the air bubble
            drawBubble(temp1)
            //> dex
            temp1 = (temp1 - 1) and 0xFF
            //> bpl BublLoop                ;do this until all three are handled
            if (!((temp1 and 0x80) != 0)) {
                //  continue loop (branch back to BublLoop)
                continue@loop0
            }
        } while ((temp1 and 0x80) == 0)
    }
    //> BublExit: rts                         ;then leave
    return
}

// Decompiled from FireballObjCore
fun fireballObjCore(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var fballOffscreenbits by MemoryByte(FBall_OffscreenBits)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val fireballXSpdData by MemoryByteIndexed(FireballXSpdData)
    val fireballBoundboxctrl by MemoryByteIndexed(Fireball_BoundBoxCtrl)
    val fireballPageloc by MemoryByteIndexed(Fireball_PageLoc)
    val fireballState by MemoryByteIndexed(Fireball_State)
    val fireballXPosition by MemoryByteIndexed(Fireball_X_Position)
    val fireballXSpeed by MemoryByteIndexed(Fireball_X_Speed)
    val fireballYHighpos by MemoryByteIndexed(Fireball_Y_HighPos)
    val fireballYPosition by MemoryByteIndexed(Fireball_Y_Position)
    val fireballYSpeed by MemoryByteIndexed(Fireball_Y_Speed)
    //> FireballObjCore:
    //> stx ObjectOffset             ;store offset as current object
    objectOffset = X
    //> lda Fireball_State,x         ;check for d7 = 1
    A = fireballState[X]
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
    X = X
    if ((orig0 and 0x80) == 0) {
        //> ldy Fireball_State,x         ;if fireball inactive, branch to leave
        Y = fireballState[X]
        //> beq NoFBall
        if (Y != 0) {
            //> dey                          ;if fireball state set to 1, skip this part and just run it
            Y = (Y - 1) and 0xFF
            //> beq RunFB
            if (Y != 0) {
                //> lda Player_X_Position        ;get player's horizontal position
                A = playerXPosition
                //> adc #$04                     ;add four pixels and store as fireball's horizontal position
                temp0 = A + 0x04 + if ((orig0 and 0x80) != 0) 1 else 0
                A = temp0 and 0xFF
                //> sta Fireball_X_Position,x
                fireballXPosition[X] = A
                //> lda Player_PageLoc           ;get player's page location
                A = playerPageloc
                //> adc #$00                     ;add carry and store as fireball's page location
                temp1 = A + if (temp0 > 0xFF) 1 else 0
                A = temp1 and 0xFF
                //> sta Fireball_PageLoc,x
                fireballPageloc[X] = A
                //> lda Player_Y_Position        ;get player's vertical position and store
                A = playerYPosition
                //> sta Fireball_Y_Position,x
                fireballYPosition[X] = A
                //> lda #$01                     ;set high byte of vertical position
                A = 0x01
                //> sta Fireball_Y_HighPos,x
                fireballYHighpos[X] = A
                //> ldy PlayerFacingDir          ;get player's facing direction
                Y = playerFacingDir
                //> dey                          ;decrement to use as offset here
                Y = (Y - 1) and 0xFF
                //> lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
                A = fireballXSpdData[Y]
                //> sta Fireball_X_Speed,x
                fireballXSpeed[X] = A
                //> lda #$04                     ;set vertical speed of fireball
                A = 0x04
                //> sta Fireball_Y_Speed,x
                fireballYSpeed[X] = A
                //> lda #$07
                A = 0x07
                //> sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
                fireballBoundboxctrl[X] = A
                //> dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
                fireballState[X] = (fireballState[X] - 1) and 0xFF
            }
            //> RunFB:   txa                          ;add 7 to offset to use
            A = X
            //> clc                          ;as fireball offset for next routines
            //> adc #$07
            temp2 = A + 0x07
            A = temp2 and 0xFF
            //> tax
            X = A
            //> lda #$50                     ;set downward movement force here
            A = 0x50
            //> sta $00
            memory[0x0] = A.toUByte()
            //> lda #$03                     ;set maximum speed here
            A = 0x03
            //> sta $02
            memory[0x2] = A.toUByte()
            //> lda #$00
            A = 0x00
            //> jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
            imposeGravity(A, X)
            //> jsr MoveObjectHorizontally   ;do another sub to move it horizontally
            moveObjectHorizontally(X)
            //> ldx ObjectOffset             ;return fireball offset to X
            X = objectOffset
            //> jsr RelativeFireballPosition ;get relative coordinates
            temp3 = relativeFireballPosition(X)
            X = temp3
            //> jsr GetFireballOffscreenBits ;get offscreen information
            temp4 = getFireballOffscreenBits(temp3)
            X = temp4
            //> jsr GetFireballBoundBox      ;get bounding box coordinates
            temp5 = getFireballBoundBox(temp4)
            X = temp5
            //> jsr FireballBGCollision      ;do fireball to background collision detection
            temp6 = fireballBGCollision(temp5)
            X = temp6
            //> lda FBall_OffscreenBits      ;get fireball offscreen bits
            A = fballOffscreenbits
            //> and #%11001100               ;mask out certain bits
            A = A and 0xCC
            //> bne EraseFB                  ;if any bits still set, branch to kill fireball
            X = temp6
            if (A == 0) {
                //> jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
                temp7 = fireballEnemyCollision(X)
                X = temp7
                //> jmp DrawFireball             ;draw fireball appropriately and leave
                drawFireball(temp7)
                return
            }
            //> EraseFB: lda #$00                     ;erase fireball state
            A = 0x00
            //> sta Fireball_State,x
            fireballState[X] = A
        }
        //> NoFBall: rts                          ;leave
        return
    } else {
        //> FireballExplosion:
        //> jsr RelativeFireballPosition
        temp8 = relativeFireballPosition(X)
        X = temp8
        //> jmp DrawExplosion_Fireball
        drawexplosionFireball(temp8)
        return
    }
}

// Decompiled from BubbleCheck
fun bubbleCheck(X: Int) {
    var A: Int = 0
    var airBubbleTimer by MemoryByte(AirBubbleTimer)
    val bubbleYPosition by MemoryByteIndexed(Bubble_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> BubbleCheck:
    //> lda PseudoRandomBitReg+1,x  ;get part of LSFR
    A = pseudoRandomBitReg[1 + X]
    //> and #$01
    A = A and 0x01
    //> sta $07                     ;store pseudorandom bit here
    memory[0x7] = A.toUByte()
    //> lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
    A = bubbleYPosition[X]
    //> cmp #$f8                    ;if offscreen coordinate not set,
    //> bne MoveBubl                ;branch to move air bubble
    if (!(A == 0xF8)) {
        //  goto MoveBubl -> moveBubl
        moveBubl(X)
        return
    } else {
        //> lda AirBubbleTimer          ;if air bubble timer not expired,
        A = airBubbleTimer
        //> bne ExitBubl                ;branch to leave, otherwise create new air bubble
        if (!(A == 0)) {
            //  goto ExitBubl -> exitBubl
            exitBubl()
            return
        }
    }
    //  Fall-through tail call to setupBubble
    setupBubble(X)
    return
}

// Decompiled from SetupBubble
fun setupBubble(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var airBubbleTimer by MemoryByte(AirBubbleTimer)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val bubbleTimerData by MemoryByteIndexed(BubbleTimerData)
    val bubblePageloc by MemoryByteIndexed(Bubble_PageLoc)
    val bubbleXPosition by MemoryByteIndexed(Bubble_X_Position)
    val bubbleYHighpos by MemoryByteIndexed(Bubble_Y_HighPos)
    val bubbleYPosition by MemoryByteIndexed(Bubble_Y_Position)
    //> SetupBubble:
    //> ldy #$00                 ;load default value here
    Y = 0x00
    //> lda PlayerFacingDir      ;get player's facing direction
    A = playerFacingDir
    //> lsr                      ;move d0 to carry
    val orig0: Int = A
    A = orig0 shr 1
    //> bcc PosBubl              ;branch to use default value if facing left
    X = X
    if ((orig0 and 0x01) != 0) {
        //> ldy #$08                 ;otherwise load alternate value here
        Y = 0x08
    }
    //> PosBubl:  tya                      ;use value loaded as adder
    A = Y
    //> adc Player_X_Position    ;add to player's horizontal position
    temp0 = A + playerXPosition + if ((orig0 and 0x01) != 0) 1 else 0
    A = temp0 and 0xFF
    //> sta Bubble_X_Position,x  ;save as horizontal position for airbubble
    bubbleXPosition[X] = A
    //> lda Player_PageLoc
    A = playerPageloc
    //> adc #$00                 ;add carry to player's page location
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta Bubble_PageLoc,x     ;save as page location for airbubble
    bubblePageloc[X] = A
    //> lda Player_Y_Position
    A = playerYPosition
    //> clc                      ;add eight pixels to player's vertical position
    //> adc #$08
    temp2 = A + 0x08
    A = temp2 and 0xFF
    //> sta Bubble_Y_Position,x  ;save as vertical position for air bubble
    bubbleYPosition[X] = A
    //> lda #$01
    A = 0x01
    //> sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
    bubbleYHighpos[X] = A
    //> ldy $07                  ;get pseudorandom bit, use as offset
    Y = memory[0x7].toInt()
    //> lda BubbleTimerData,y    ;get data for air bubble timer
    A = bubbleTimerData[Y]
    //> sta AirBubbleTimer       ;set air bubble timer
    airBubbleTimer = A
    //  Fall-through tail call to moveBubl
    moveBubl(X)
    return
}

// Decompiled from MoveBubl
fun moveBubl(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val bubbleMforcedata by MemoryByteIndexed(Bubble_MForceData)
    val bubbleYmfDummy by MemoryByteIndexed(Bubble_YMF_Dummy)
    val bubbleYPosition by MemoryByteIndexed(Bubble_Y_Position)
    //> MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
    Y = memory[0x7].toInt()
    //> lda Bubble_YMF_Dummy,x
    A = bubbleYmfDummy[X]
    //> sec                      ;subtract pseudorandom amount from dummy variable
    //> sbc Bubble_MForceData,y
    temp0 = A - bubbleMforcedata[Y]
    A = temp0 and 0xFF
    //> sta Bubble_YMF_Dummy,x   ;save dummy variable
    bubbleYmfDummy[X] = A
    //> lda Bubble_Y_Position,x
    A = bubbleYPosition[X]
    //> sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
    temp1 = A - if (temp0 >= 0) 0 else 1
    A = temp1 and 0xFF
    //> cmp #$20                 ;if below the status bar,
    //> bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
    if (A >= 0x20) {
        //  goto Y_Bubl -> yBubl
        yBubl(A, X)
        return
    }
    //  Fall-through tail call to func_6428
    func_6428(X)
    return
}

// Decompiled from @6428
fun func_6428(X: Int) {
    var A: Int = 0
    //> lda #$f8                 ;otherwise set offscreen coordinate
    A = 0xF8
    //  Fall-through tail call to yBubl
    yBubl(A, X)
    return
}

// Decompiled from Y_Bubl
fun yBubl(A: Int, X: Int) {
    val bubbleYPosition by MemoryByteIndexed(Bubble_Y_Position)
    //> Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
    bubbleYPosition[X] = A
    //  Fall-through tail call to exitBubl
    exitBubl()
    return
}

// Decompiled from ExitBubl
fun exitBubl() {
    //> ExitBubl: rts                      ;leave
    return
}

// Decompiled from RunGameTimer
fun runGameTimer() {
    var A: Int = 0
    var Y: Int = 0
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var gameTimerCtrlTimer by MemoryByte(GameTimerCtrlTimer)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var operMode by MemoryByte(OperMode)
    var playerStatus by MemoryByte(PlayerStatus)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    //> RunGameTimer:
    //> lda OperMode               ;get primary mode of operation
    A = operMode
    //> beq ExGTimer               ;branch to leave if in title screen mode
    if (A == 0) {
        //  goto ExGTimer -> exGTimer
        exGTimer()
        return
    } else {
        //> lda GameEngineSubroutine
        A = gameEngineSubroutine
        //> cmp #$08                   ;if routine number less than eight running,
        //> bcc ExGTimer               ;branch to leave
        if (!(A >= 0x08)) {
            //  goto ExGTimer -> exGTimer
            exGTimer()
            return
        }
    }
    //> cmp #$0b                   ;if running death routine,
    //> beq ExGTimer               ;branch to leave
    if (A == 0x0B) {
        //  goto ExGTimer -> exGTimer
        exGTimer()
        return
    } else {
        //> lda Player_Y_HighPos
        A = playerYHighpos
        //> cmp #$02                   ;if player below the screen,
        //> bcs ExGTimer               ;branch to leave regardless of level type
        if (A >= 0x02) {
            //  goto ExGTimer -> exGTimer
            exGTimer()
            return
        }
    }
    //> lda GameTimerCtrlTimer     ;if game timer control not yet expired,
    A = gameTimerCtrlTimer
    //> bne ExGTimer               ;branch to leave
    if (!(A == 0)) {
        //  goto ExGTimer -> exGTimer
        exGTimer()
        return
    } else {
        //> lda GameTimerDisplay
        A = gameTimerDisplay[0]
        //> ora GameTimerDisplay+1     ;otherwise check game timer digits
        A = A or gameTimerDisplay[1]
        //> ora GameTimerDisplay+2
        A = A or gameTimerDisplay[2]
        //> beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
        if (A != 0) {
            //> ldy GameTimerDisplay       ;otherwise check first digit
            Y = gameTimerDisplay[0]
            //> dey                        ;if first digit not on 1,
            Y = (Y - 1) and 0xFF
            //> bne ResGTCtrl              ;branch to reset game timer control
            if (Y == 0) {
                //> lda GameTimerDisplay+1     ;otherwise check second and third digits
                A = gameTimerDisplay[1]
                //> ora GameTimerDisplay+2
                A = A or gameTimerDisplay[2]
                //> bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
                if (A == 0) {
                    //> lda #TimeRunningOutMusic
                    A = TimeRunningOutMusic
                    //> sta EventMusicQueue        ;otherwise load time running out music
                    eventMusicQueue = A
                }
            }
            //> ResGTCtrl: lda #$18                   ;reset game timer control
            A = 0x18
            //> sta GameTimerCtrlTimer
            gameTimerCtrlTimer = A
            //> ldy #$23                   ;set offset for last digit
            Y = 0x23
            //> lda #$ff                   ;set value to decrement game timer digit
            A = 0xFF
            //> sta DigitModifier+5
            digitModifier[5] = A
            //> jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
            digitsMathRoutine(Y)
            //> lda #$a4                   ;set status nybbles to update game timer display
            A = 0xA4
            //> jmp PrintStatusBarNumbers  ;do sub to update the display
            printStatusBarNumbers(A)
            return
        }
    }
    //> TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
    playerStatus = A
    //> jsr ForceInjury            ;do sub to kill the player (note player is small here)
    forceInjury(A)
    //> inc GameTimerExpiredFlag   ;set game timer expiration flag
    gameTimerExpiredFlag = (gameTimerExpiredFlag + 1) and 0xFF
    //  Fall-through tail call to exGTimer
    exGTimer()
    return
}

// Decompiled from ExGTimer
fun exGTimer() {
    //> ExGTimer:  rts                        ;leave
    return
}

// Decompiled from WarpZoneObject
fun warpZoneObject(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var scrollLock by MemoryByte(ScrollLock)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    //> WarpZoneObject:
    //> lda ScrollLock         ;check for scroll lock flag
    A = scrollLock
    //> beq ExGTimer           ;branch if not set to leave
    X = X
    if (A == 0) {
        //> ExGTimer:  rts                        ;leave
        return A
    } else {
        //> lda Player_Y_Position  ;check to see if player's vertical coordinate has
        A = playerYPosition
        //> and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
        A = A and playerYHighpos
        //> bne ExGTimer           ;if so, branch to leave
        if (A != 0) {
            //> ExGTimer:  rts                        ;leave
            return A
        }
    }
    //> sta ScrollLock         ;otherwise nullify scroll lock flag
    scrollLock = A
    //> inc WarpZoneControl    ;increment warp zone flag to make warp pipes for warp zone
    warpZoneControl = (warpZoneControl + 1) and 0xFF
    //> jmp EraseEnemyObject   ;kill this object
    return eraseEnemyObject(X)
}

// Decompiled from ProcessWhirlpools
fun processWhirlpools() {
    var A: Int = 0
    var Y: Int = 0
    var exitFlag0: Boolean = false
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaType by MemoryByte(AreaType)
    var frameCounter by MemoryByte(FrameCounter)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var timerControl by MemoryByte(TimerControl)
    var whirlpoolFlag by MemoryByte(Whirlpool_Flag)
    val whirlpoolLeftextent by MemoryByteIndexed(Whirlpool_LeftExtent)
    val whirlpoolLength by MemoryByteIndexed(Whirlpool_Length)
    val whirlpoolPageloc by MemoryByteIndexed(Whirlpool_PageLoc)
    //> ProcessWhirlpools:
    //> lda AreaType                ;check for water type level
    A = areaType
    //> bne ExitWh                  ;branch to leave if not found
    if (A == 0) {
        //> sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
        whirlpoolFlag = A
        //> lda TimerControl            ;if master timer control set,
        A = timerControl
        //> bne ExitWh                  ;branch to leave
        if (A == 0) {
            //> ldy #$04                    ;otherwise start with last whirlpool data
            Y = 0x04
            loop0@ do {
                //> WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
                A = whirlpoolLeftextent[Y]
                //> clc
                //> adc Whirlpool_Length,y      ;add length of whirlpool
                temp0 = A + whirlpoolLength[Y]
                A = temp0 and 0xFF
                //> sta $02                     ;store result as right extent here
                memory[0x2] = A.toUByte()
                //> lda Whirlpool_PageLoc,y     ;get page location
                A = whirlpoolPageloc[Y]
                //> beq NextWh                  ;if none or page 0, branch to get next data
                if (A != 0) {
                    //> adc #$00                    ;add carry
                    temp1 = A + if (temp0 > 0xFF) 1 else 0
                    A = temp1 and 0xFF
                    //> sta $01                     ;store result as page location of right extent here
                    memory[0x1] = A.toUByte()
                    //> lda Player_X_Position       ;get player's horizontal position
                    A = playerXPosition
                    //> sec
                    //> sbc Whirlpool_LeftExtent,y  ;subtract left extent
                    temp2 = A - whirlpoolLeftextent[Y]
                    A = temp2 and 0xFF
                    //> lda Player_PageLoc          ;get player's page location
                    A = playerPageloc
                    //> sbc Whirlpool_PageLoc,y     ;subtract borrow
                    temp3 = A - whirlpoolPageloc[Y] - if (temp2 >= 0) 0 else 1
                    A = temp3 and 0xFF
                    //> bmi NextWh                  ;if player too far left, branch to get next data
                    if ((temp3 and 0xFF and 0x80) == 0) {
                        //> lda $02                     ;otherwise get right extent
                        A = memory[0x2].toInt()
                        //> sec
                        //> sbc Player_X_Position       ;subtract player's horizontal coordinate
                        temp4 = A - playerXPosition
                        A = temp4 and 0xFF
                        //> lda $01                     ;get right extent's page location
                        A = memory[0x1].toInt()
                        //> sbc Player_PageLoc          ;subtract borrow
                        temp5 = A - playerPageloc - if (temp4 >= 0) 0 else 1
                        A = temp5 and 0xFF
                        //> bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
                        if (!((temp5 and 0xFF and 0x80) != 0)) {
                            //  goto WhirlpoolActivate
                            exitFlag0 = true
                            break@loop0
                        }
                    }
                }
                //> NextWh: dey                         ;move onto next whirlpool data
                Y = (Y - 1) and 0xFF
                //> bpl WhLoop                  ;do this until all whirlpools are checked
                if (!((Y and 0x80) != 0)) {
                    //  continue loop (branch back to WhLoop)
                    continue@loop0
                }
            } while ((Y and 0x80) == 0)
            //> WhirlpoolActivate:
            //> lda Whirlpool_Length,y      ;get length of whirlpool
            A = whirlpoolLength[Y]
            //> lsr                         ;divide by 2
            val orig0: Int = A
            A = orig0 shr 1
            //> sta $00                     ;save here
            memory[0x0] = A.toUByte()
            //> lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
            A = whirlpoolLeftextent[Y]
            //> clc
            //> adc $00                     ;add length divided by 2
            temp6 = A + memory[0x0].toInt()
            A = temp6 and 0xFF
            //> sta $01                     ;save as center of whirlpool
            memory[0x1] = A.toUByte()
            //> lda Whirlpool_PageLoc,y     ;get page location
            A = whirlpoolPageloc[Y]
            //> adc #$00                    ;add carry
            temp7 = A + if (temp6 > 0xFF) 1 else 0
            A = temp7 and 0xFF
            //> sta $00                     ;save as page location of whirlpool center
            memory[0x0] = A.toUByte()
            //> lda FrameCounter            ;get frame counter
            A = frameCounter
            //> lsr                         ;shift d0 into carry (to run on every other frame)
            val orig1: Int = A
            A = orig1 shr 1
            //> bcc WhPull                  ;if d0 not set, branch to last part of code
            if (!((orig1 and 0x01) != 0)) {
                //  goto WhPull -> whPull
                whPull()
                return
            }
        } else {
            //> ExitWh: rts                         ;leave
            return
        }
        //> WhirlpoolActivate:
        //> lda Whirlpool_Length,y      ;get length of whirlpool
        A = whirlpoolLength[Y]
        //> lsr                         ;divide by 2
        val orig2: Int = A
        A = orig2 shr 1
        //> sta $00                     ;save here
        memory[0x0] = A.toUByte()
        //> lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
        A = whirlpoolLeftextent[Y]
        //> clc
        //> adc $00                     ;add length divided by 2
        temp8 = A + memory[0x0].toInt()
        A = temp8 and 0xFF
        //> sta $01                     ;save as center of whirlpool
        memory[0x1] = A.toUByte()
        //> lda Whirlpool_PageLoc,y     ;get page location
        A = whirlpoolPageloc[Y]
        //> adc #$00                    ;add carry
        temp9 = A + if (temp8 > 0xFF) 1 else 0
        A = temp9 and 0xFF
        //> sta $00                     ;save as page location of whirlpool center
        memory[0x0] = A.toUByte()
        //> lda FrameCounter            ;get frame counter
        A = frameCounter
        //> lsr                         ;shift d0 into carry (to run on every other frame)
        val orig3: Int = A
        A = orig3 shr 1
        //> bcc WhPull                  ;if d0 not set, branch to last part of code
        if (!((orig3 and 0x01) != 0)) {
            //  goto WhPull -> whPull
            whPull()
            return
        }
    } else {
        //> ExitWh: rts                         ;leave
        return
    }
    //> lda $01                     ;get center
    A = memory[0x1].toInt()
    //> sec
    //> sbc Player_X_Position       ;subtract player's horizontal coordinate
    temp10 = A - playerXPosition
    A = temp10 and 0xFF
    //> lda $00                     ;get page location of center
    A = memory[0x0].toInt()
    //> sbc Player_PageLoc          ;subtract borrow
    temp11 = A - playerPageloc - if (temp10 >= 0) 0 else 1
    A = temp11 and 0xFF
    //> bpl LeftWh                  ;if player to the left of center, branch
    if ((temp11 and 0xFF and 0x80) != 0) {
        //> lda Player_X_Position       ;otherwise slowly pull player left, towards the center
        A = playerXPosition
        //> sec
        //> sbc #$01                    ;subtract one pixel
        temp12 = A - 0x01
        A = temp12 and 0xFF
        //> sta Player_X_Position       ;set player's new horizontal coordinate
        playerXPosition = A
        //> lda Player_PageLoc
        A = playerPageloc
        //> sbc #$00                    ;subtract borrow
        temp13 = A - if (temp12 >= 0) 0 else 1
        A = temp13 and 0xFF
        //> jmp SetPWh                  ;jump to set player's new page location
        setPWh(A)
        return
    } else {
        //> LeftWh: lda Player_CollisionBits    ;get player's collision bits
        A = playerCollisionbits
        //> lsr                         ;shift d0 into carry
        val orig4: Int = A
        A = orig4 shr 1
        //> bcc WhPull                  ;if d0 not set, branch
        if (!((orig4 and 0x01) != 0)) {
            //  goto WhPull -> whPull
            whPull()
            return
        }
    }
    //> lda Player_X_Position       ;otherwise slowly pull player right, towards the center
    A = playerXPosition
    //> clc
    //> adc #$01                    ;add one pixel
    temp14 = A + 0x01
    A = temp14 and 0xFF
    //> sta Player_X_Position       ;set player's new horizontal coordinate
    playerXPosition = A
    //> lda Player_PageLoc
    A = playerPageloc
    //> adc #$00                    ;add carry
    temp15 = A + if (temp14 > 0xFF) 1 else 0
    A = temp15 and 0xFF
    //  Fall-through tail call to setPWh
    setPWh(A)
    return
}

// Decompiled from SetPWh
fun setPWh(A: Int) {
    var playerPageloc by MemoryByte(Player_PageLoc)
    //> SetPWh: sta Player_PageLoc          ;set player's new page location
    playerPageloc = A
    //  Fall-through tail call to whPull
    whPull()
    return
}

// Decompiled from WhPull
fun whPull() {
    var A: Int = 0
    var X: Int = 0
    var whirlpoolFlag by MemoryByte(Whirlpool_Flag)
    //> WhPull: lda #$10
    A = 0x10
    //> sta $00                     ;set vertical movement force
    memory[0x0] = A.toUByte()
    //> lda #$01
    A = 0x01
    //> sta Whirlpool_Flag          ;set whirlpool flag to be used later
    whirlpoolFlag = A
    //> sta $02                     ;also set maximum vertical speed
    memory[0x2] = A.toUByte()
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> tax                         ;set X for player offset
    X = A
    //> jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
    imposeGravity(A, X)
    return
}

// Decompiled from FlagpoleRoutine
fun flagpoleRoutine() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var flagpolefnumYmfdummy by MemoryByte(FlagpoleFNum_YMFDummy)
    var flagpolefnumYPos by MemoryByte(FlagpoleFNum_Y_Pos)
    var flagpoleScore by MemoryByte(FlagpoleScore)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerState by MemoryByte(Player_State)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flagpoleScoreDigits by MemoryByteIndexed(FlagpoleScoreDigits)
    val flagpoleScoreMods by MemoryByteIndexed(FlagpoleScoreMods)
    //> FlagpoleRoutine:
    //> ldx #$05                  ;set enemy object offset
    X = 0x05
    //> stx ObjectOffset          ;to special use slot
    objectOffset = X
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #FlagpoleFlagObject   ;if flagpole flag not found,
    //> bne ExitFlagP             ;branch to leave
    if (!(A == FlagpoleFlagObject)) {
        //  goto ExitFlagP -> exitFlagP
        exitFlagP()
        return
    } else {
        //> lda GameEngineSubroutine
        A = gameEngineSubroutine
        //> cmp #$04                  ;if flagpole slide routine not running,
        //> bne SkipScore             ;branch to near the end of code
        if (A == 0x04) {
            //> lda Player_State
            A = playerState
            //> cmp #$03                  ;if player state not climbing,
            //> bne SkipScore             ;branch to near the end of code
            if (A == 0x03) {
                //> lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
                A = enemyYPosition[X]
                //> cmp #$aa                  ;if flagpole flag down to a certain point,
                //> bcs GiveFPScr             ;branch to end the level
                if (!(A >= 0xAA)) {
                    //> lda Player_Y_Position     ;check player's vertical coordinate
                    A = playerYPosition
                    //> cmp #$a2                  ;if player down to a certain point,
                    //> bcs GiveFPScr             ;branch to end the level
                    if (!(A >= 0xA2)) {
                        //> lda Enemy_YMF_Dummy,x
                        A = enemyYmfDummy[X]
                        //> adc #$ff                  ;add movement amount to dummy variable
                        temp0 = A + 0xFF + if (A >= 0xA2) 1 else 0
                        A = temp0 and 0xFF
                        //> sta Enemy_YMF_Dummy,x     ;save dummy variable
                        enemyYmfDummy[X] = A
                        //> lda Enemy_Y_Position,x    ;get flag's vertical coordinate
                        A = enemyYPosition[X]
                        //> adc #$01                  ;add 1 plus carry to move flag, and
                        temp1 = A + 0x01 + if (temp0 > 0xFF) 1 else 0
                        A = temp1 and 0xFF
                        //> sta Enemy_Y_Position,x    ;store vertical coordinate
                        enemyYPosition[X] = A
                        //> lda FlagpoleFNum_YMFDummy
                        A = flagpolefnumYmfdummy
                        //> sec                       ;subtract movement amount from dummy variable
                        //> sbc #$ff
                        temp2 = A - 0xFF
                        A = temp2 and 0xFF
                        //> sta FlagpoleFNum_YMFDummy ;save dummy variable
                        flagpolefnumYmfdummy = A
                        //> lda FlagpoleFNum_Y_Pos
                        A = flagpolefnumYPos
                        //> sbc #$01                  ;subtract one plus borrow to move floatey number,
                        temp3 = A - 0x01 - if (temp2 >= 0) 0 else 1
                        A = temp3 and 0xFF
                        //> sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
                        flagpolefnumYPos = A
                    }
                }
            }
        }
    }
    //> SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
    fPGfx(X)
    return
    //> GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
    Y = flagpoleScore
    //> lda FlagpoleScoreMods,y   ;get amount to award player points
    A = flagpoleScoreMods[Y]
    //> ldx FlagpoleScoreDigits,y ;get digit with which to award points
    X = flagpoleScoreDigits[Y]
    //> sta DigitModifier,x       ;store in digit modifier
    digitModifier[X] = A
    //> jsr AddToScore            ;do sub to award player points depending on height of collision
    temp4 = addToScore()
    X = temp4
    //> lda #$05
    A = 0x05
    //> sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
    gameEngineSubroutine = A
    //  Fall-through tail call to fPGfx
    fPGfx(temp4)
    return
}

// Decompiled from FPGfx
fun fPGfx(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    //> FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> jsr RelativeEnemyPosition ;get relative coordinates
    temp2 = relativeEnemyPosition(temp0)
    X = temp2
    //> jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
    flagpoleGfxHandler(temp2)
    //  Fall-through tail call to exitFlagP
    exitFlagP()
    return
}

// Decompiled from ExitFlagP
fun exitFlagP() {
    //> ExitFlagP: rts
    return
}

// Decompiled from JumpspringHandler
fun jumpspringHandler(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var timerControl by MemoryByte(TimerControl)
    //> JumpspringHandler:
    //> jsr GetEnemyOffscreenBits   ;get offscreen information
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda TimerControl            ;check master timer control
    A = timerControl
    //> bne DrawJSpr                ;branch to last section if set
    if (!(A == 0)) {
        //  goto DrawJSpr -> drawJSpr
        drawJSpr(temp0)
        return
    } else {
        //> lda JumpspringAnimCtrl      ;check jumpspring frame control
        A = jumpspringAnimCtrl
        //> beq DrawJSpr                ;branch to last section if not set
        if (A == 0) {
            //  goto DrawJSpr -> drawJSpr
            drawJSpr(temp0)
            return
        }
    }
    //> tay
    Y = A
    //> dey                         ;subtract one from frame control,
    Y = (Y - 1) and 0xFF
    //> tya                         ;the only way a poor nmos 6502 can
    A = Y
    //> and #%00000010              ;mask out all but d1, original value still in Y
    A = A and 0x02
    //> bne DownJSpr                ;if set, branch to move player up
    X = temp0
    Y = Y
    if (A == 0) {
        //> inc Player_Y_Position
        playerYPosition = (playerYPosition + 1) and 0xFF
        //> inc Player_Y_Position       ;move player's vertical position down two pixels
        playerYPosition = (playerYPosition + 1) and 0xFF
        //> jmp PosJSpr                 ;skip to next part
        posJSpr(X, Y)
        return
    } else {
        //> DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
        playerYPosition = (playerYPosition - 1) and 0xFF
        //> dec Player_Y_Position
        playerYPosition = (playerYPosition - 1) and 0xFF
        //  Fall-through tail call to posJSpr
        posJSpr(X, Y)
        return
    }
}

// Decompiled from PosJSpr
fun posJSpr(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var jumpspringForce by MemoryByte(JumpspringForce)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val jumpspringFixedypos by MemoryByteIndexed(Jumpspring_FixedYPos)
    val jumpspringYPosdata by MemoryByteIndexed(Jumpspring_Y_PosData)
    //> PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
    A = jumpspringFixedypos[X]
    //> clc
    //> adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
    temp0 = A + jumpspringYPosdata[Y]
    A = temp0 and 0xFF
    //> sta Enemy_Y_Position,x      ;store as new vertical position
    enemyYPosition[X] = A
    //> cpy #$01                    ;check frame control offset (second frame is $00)
    //> bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
    X = X
    Y = Y
    if (Y >= 0x01) {
        //> lda A_B_Buttons
        A = aBButtons
        //> and #A_Button               ;check saved controller bits for A button press
        A = A and A_Button
        //> beq BounceJS                ;skip to next part if A not pressed
        if (A != 0) {
            //> and PreviousA_B_Buttons     ;check for A button pressed in previous frame
            A = A and previousaBButtons
            //> bne BounceJS                ;skip to next part if so
            if (A == 0) {
                //> lda #$f4
                A = 0xF4
                //> sta JumpspringForce         ;otherwise write new jumpspring force here
                jumpspringForce = A
            }
        }
    }
    //> BounceJS:  cpy #$03                    ;check frame control offset again
    //> bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
    if (!(Y == 0x03)) {
        //  goto DrawJSpr -> drawJSpr
        drawJSpr(X)
        return
    } else {
        //> lda JumpspringForce
        A = jumpspringForce
        //> sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
        playerYSpeed = A
        //> lda #$00
        A = 0x00
        //> sta JumpspringAnimCtrl      ;initialize jumpspring frame control
        jumpspringAnimCtrl = A
        //  Fall-through tail call to drawJSpr
        drawJSpr(X)
        return
    }
}

// Decompiled from DrawJSpr
fun drawJSpr(X: Int) {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    //> DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
    temp0 = relativeEnemyPosition(X)
    X = temp0
    //> jsr EnemyGfxHandler         ;draw jumpspring
    val pair0 = enemyGfxHandler(temp0)
    temp1 = pair0.first
    temp2 = pair0.second
    X = temp1
    //> jsr OffscreenBoundsCheck    ;check to see if we need to kill it
    offscreenBoundsCheck(temp1)
    //> lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
    A = jumpspringAnimCtrl
    //> beq ExJSpring               ;trying to animate it, just leave
    if (A == 0) {
        //  goto ExJSpring -> exJSpring
        exJSpring()
        return
    }
    //  Fall-through tail call to func_6672
    func_6672()
    return
}

// Decompiled from @6672
fun func_6672() {
    var A: Int = 0
    var jumpspringTimer by MemoryByte(JumpspringTimer)
    //> lda JumpspringTimer
    A = jumpspringTimer
    //> bne ExJSpring               ;if jumpspring timer not expired yet, leave
    if (!(A == 0)) {
        //  goto ExJSpring -> exJSpring
        exJSpring()
        return
    }
    //  Fall-through tail call to func_6674
    func_6674()
    return
}

// Decompiled from @6674
fun func_6674() {
    var A: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var jumpspringTimer by MemoryByte(JumpspringTimer)
    //> lda #$04
    A = 0x04
    //> sta JumpspringTimer         ;otherwise initialize jumpspring timer
    jumpspringTimer = A
    //> inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
    jumpspringAnimCtrl = (jumpspringAnimCtrl + 1) and 0xFF
    //  Fall-through tail call to exJSpring
    exJSpring()
    return
}

// Decompiled from ExJSpring
fun exJSpring() {
    //> ExJSpring: rts                         ;leave
    return
}

// Decompiled from Setup_Vine
fun setupVine(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var vineFlagOffset by MemoryByte(VineFlagOffset)
    var vinestartYPosition by MemoryByte(VineStart_Y_Position)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val vineObjOffset by MemoryByteIndexed(VineObjOffset)
    //> Setup_Vine:
    //> lda #VineObject          ;load identifier for vine object
    A = VineObject
    //> sta Enemy_ID,x           ;store in buffer
    enemyId[X] = A
    //> lda #$01
    A = 0x01
    //> sta Enemy_Flag,x         ;set flag for enemy object buffer
    enemyFlag[X] = A
    //> lda Block_PageLoc,y
    A = blockPageloc[Y]
    //> sta Enemy_PageLoc,x      ;copy page location from previous object
    enemyPageloc[X] = A
    //> lda Block_X_Position,y
    A = blockXPosition[Y]
    //> sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
    enemyXPosition[X] = A
    //> lda Block_Y_Position,y
    A = blockYPosition[Y]
    //> sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
    enemyYPosition[X] = A
    //> ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
    Y = vineFlagOffset
    //> bne NextVO               ;if set at all, don't bother to store vertical
    X = X
    if (Y == 0) {
        //> sta VineStart_Y_Position ;otherwise store vertical coordinate here
        vinestartYPosition = A
    }
    //> NextVO: txa                      ;store object offset to next available vine slot
    A = X
    //> sta VineObjOffset,y      ;using vine flag as offset
    vineObjOffset[Y] = A
    //> inc VineFlagOffset       ;increment vine flag offset
    vineFlagOffset = (vineFlagOffset + 1) and 0xFF
    //> lda #Sfx_GrowVine
    A = Sfx_GrowVine
    //> sta Square2SoundQueue    ;load vine grow sound
    square2SoundQueue = A
    //> rts
    return
}

// Decompiled from VineObjectHandler
fun vineObjectHandler(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var vineFlagOffset by MemoryByte(VineFlagOffset)
    var vineHeight by MemoryByte(VineHeight)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val vineHeightData by MemoryByteIndexed(VineHeightData)
    val vineObjOffset by MemoryByteIndexed(VineObjOffset)
    //> VineObjectHandler:
    //> cpx #$05                  ;check enemy offset for special use slot
    //> bne ExitVH                ;if not in last slot, branch to leave
    X = X
    if (X == 0x05) {
        //> ldy VineFlagOffset
        Y = vineFlagOffset
        //> dey                       ;decrement vine flag in Y, use as offset
        Y = (Y - 1) and 0xFF
        //> lda VineHeight
        A = vineHeight
        //> cmp VineHeightData,y      ;if vine has reached certain height,
        //> beq RunVSubs              ;branch ahead to skip this part
        if (A != vineHeightData[Y]) {
            //> lda FrameCounter          ;get frame counter
            A = frameCounter
            //> lsr                       ;shift d1 into carry
            val orig0: Int = A
            A = orig0 shr 1
            //> lsr
            val orig1: Int = A
            A = orig1 shr 1
            //> bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
            if ((orig1 and 0x01) != 0) {
                //> lda Enemy_Y_Position+5
                A = enemyYPosition[5]
                //> sbc #$01                  ;subtract vertical position of vine
                temp0 = A - 0x01 - if ((orig1 and 0x01) != 0) 0 else 1
                A = temp0 and 0xFF
                //> sta Enemy_Y_Position+5    ;one pixel every frame it's time
                enemyYPosition[5] = A
                //> inc VineHeight            ;increment vine height
                vineHeight = (vineHeight + 1) and 0xFF
            }
        }
        //> RunVSubs:  lda VineHeight            ;if vine still very small,
        A = vineHeight
        //> cmp #$08                  ;branch to leave
        //> bcc ExitVH
        if (A >= 0x08) {
            //> jsr RelativeEnemyPosition ;get relative coordinates of vine,
            temp1 = relativeEnemyPosition(X)
            X = temp1
            //> jsr GetEnemyOffscreenBits ;and any offscreen bits
            val pair0 = getEnemyOffscreenBits(temp1)
            temp2 = pair0.first
            temp3 = pair0.second
            X = temp2
            //> ldy #$00                  ;initialize offset used in draw vine sub
            Y = 0x00
            X = temp2
            loop0@ do {
                //> VDrawLoop: jsr DrawVine              ;draw vine
                temp4 = drawVine(Y)
                //> iny                       ;increment offset
                temp4 = (temp4 + 1) and 0xFF
                //> cpy VineFlagOffset        ;if offset in Y and offset here
                //> bne VDrawLoop             ;do not yet match, loop back to draw more vine
                if (!(temp4 == vineFlagOffset)) {
                    //  continue loop (branch back to VDrawLoop)
                    continue@loop0
                }
            } while (temp4 != vineFlagOffset)
            //> lda Enemy_OffscreenBits
            A = enemyOffscreenbits
            //> and #%00001100            ;mask offscreen bits
            A = A and 0x0C
            //> beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
            Y = temp4
            if (A != 0) {
                //> dey                       ;otherwise decrement Y to get proper offset again
                Y = (Y - 1) and 0xFF
                loop1@ do {
                    //> KillVine:  ldx VineObjOffset,y       ;get enemy object offset for this vine object
                    X = vineObjOffset[Y]
                    //> jsr EraseEnemyObject      ;kill this vine object
                    temp5 = eraseEnemyObject(X)
                    //> dey                       ;decrement Y
                    Y = (Y - 1) and 0xFF
                    //> bpl KillVine              ;if any vine objects left, loop back to kill it
                    if (!((Y and 0x80) != 0)) {
                        //  continue loop (branch back to KillVine)
                        continue@loop1
                    }
                } while ((Y and 0x80) == 0)
                //> sta VineFlagOffset        ;initialize vine flag/offset
                vineFlagOffset = temp5
                //> sta VineHeight            ;initialize vine height
                vineHeight = temp5
            }
            //> WrCMTile:  lda VineHeight            ;check vine height
            A = vineHeight
            //> cmp #$20                  ;if vine small (less than 32 pixels tall)
            //> bcc ExitVH                ;then branch ahead to leave
            if (A >= 0x20) {
                //> ldx #$06                  ;set offset in X to last enemy slot
                X = 0x06
                //> lda #$01                  ;set A to obtain horizontal in $04, but we don't care
                A = 0x01
                //> ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
                Y = 0x1B
                //> jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
                temp6 = blockBufferCollision(A, X, Y)
                //> ldy $02
                Y = memory[0x2].toInt()
                //> cpy #$d0                  ;if vertical high nybble offset beyond extent of
                //> bcs ExitVH                ;current block buffer, branch to leave, do not write
                A = temp6
                if (!(Y >= 0xD0)) {
                    //> lda ($06),y               ;otherwise check contents of block buffer at
                    A = memory[readWord(0x6) + Y].toInt()
                    //> bne ExitVH                ;current offset, if not empty, branch to leave
                    if (A == 0) {
                        //> lda #$26
                        A = 0x26
                        //> sta ($06),y               ;otherwise, write climbing metatile to block buffer
                        memory[readWord(0x6) + Y] = A.toUByte()
                    }
                }
            }
        }
    }
    //> ExitVH:    ldx ObjectOffset          ;get enemy object offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from ProcessCannons
fun processCannons() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var areaType by MemoryByte(AreaType)
    var objectOffset by MemoryByte(ObjectOffset)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var timerControl by MemoryByte(TimerControl)
    val cannonBitmasks by MemoryByteIndexed(CannonBitmasks)
    val cannonPageloc by MemoryByteIndexed(Cannon_PageLoc)
    val cannonTimer by MemoryByteIndexed(Cannon_Timer)
    val cannonXPosition by MemoryByteIndexed(Cannon_X_Position)
    val cannonYPosition by MemoryByteIndexed(Cannon_Y_Position)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> ProcessCannons:
    //> lda AreaType                ;get area type
    A = areaType
    //> beq ExCannon                ;if water type area, branch to leave
    if (A != 0) {
        //> ldx #$02
        X = 0x02
        loop0@ do {
            //> ThreeSChk: stx ObjectOffset            ;start at third enemy slot
            objectOffset = X
            //> lda Enemy_Flag,x            ;check enemy buffer flag
            A = enemyFlag[X]
            //> bne Chk_BB                  ;if set, branch to check enemy
            if (A == 0) {
                //> lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
                A = pseudoRandomBitReg[1 + X]
                //> ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
                Y = secondaryHardMode
                //> and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
                A = A and cannonBitmasks[Y]
                //> cmp #$06                    ;check to see if lower nybble is above certain value
                //> bcs Chk_BB                  ;if so, branch to check enemy
                if (!(A >= 0x06)) {
                    //> tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
                    Y = A
                    //> lda Cannon_PageLoc,y        ;get page location
                    A = cannonPageloc[Y]
                    //> beq Chk_BB                  ;if not set or on page 0, branch to check enemy
                    if (A != 0) {
                        //> lda Cannon_Timer,y          ;get cannon timer
                        A = cannonTimer[Y]
                        //> beq FireCannon              ;if expired, branch to fire cannon
                        if (A != 0) {
                            //> sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
                            temp0 = A - if (A >= 0x06) 0 else 1
                            A = temp0 and 0xFF
                            //> sta Cannon_Timer,y          ;to count timer down
                            cannonTimer[Y] = A
                            //> jmp Chk_BB                  ;then jump ahead to check enemy
                            //> jmp Chk_BB (not a known function)
                        } else {
                            //> FireCannon:
                            //> lda TimerControl           ;if master timer control set,
                            A = timerControl
                            //> bne Chk_BB                 ;branch to check enemy
                            if (A == 0) {
                                //> lda #$0e                   ;otherwise we start creating one
                                A = 0x0E
                                //> sta Cannon_Timer,y         ;first, reset cannon timer
                                cannonTimer[Y] = A
                                //> lda Cannon_PageLoc,y       ;get page location of cannon
                                A = cannonPageloc[Y]
                                //> sta Enemy_PageLoc,x        ;save as page location of bullet bill
                                enemyPageloc[X] = A
                                //> lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
                                A = cannonXPosition[Y]
                                //> sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
                                enemyXPosition[X] = A
                                //> lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
                                A = cannonYPosition[Y]
                                //> sec
                                //> sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
                                temp1 = A - 0x08
                                A = temp1 and 0xFF
                                //> sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
                                enemyYPosition[X] = A
                                //> lda #$01
                                A = 0x01
                                //> sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
                                enemyYHighpos[X] = A
                                //> sta Enemy_Flag,x           ;set buffer flag
                                enemyFlag[X] = A
                                //> lsr                        ;shift right once to init A
                                val orig0: Int = A
                                A = orig0 shr 1
                                //> sta Enemy_State,x          ;then initialize enemy's state
                                enemyState[X] = A
                                //> lda #$09
                                A = 0x09
                                //> sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
                                enemyBoundboxctrl[X] = A
                                //> lda #BulletBill_CannonVar
                                A = BulletBill_CannonVar
                                //> sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
                                enemyId[X] = A
                                //> jmp Next3Slt               ;move onto next slot
                                //> jmp Next3Slt (not a known function)
                            }
                        }
                    }
                }
            } else {
                //> Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
                A = enemyId[X]
                //> cmp #BulletBill_CannonVar
                //> bne Next3Slt               ;if not found, branch to get next slot
                if (A == BulletBill_CannonVar) {
                    //> jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
                    offscreenBoundsCheck(X)
                    //> lda Enemy_Flag,x           ;check enemy buffer flag
                    A = enemyFlag[X]
                    //> beq Next3Slt               ;if not set, branch to get next slot
                    if (A != 0) {
                        //> jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
                        val pair0 = getEnemyOffscreenBits(X)
                        temp2 = pair0.first
                        temp3 = pair0.second
                        X = temp2
                        //> jsr BulletBillHandler      ;then do sub to handle bullet bill
                        val pair1 = bulletBillHandler(temp2, temp3)
                        temp4 = pair1.first
                        temp5 = pair1.second
                        X = temp4
                    }
                }
            }
            //> Next3Slt: dex                        ;move onto next slot
            X = (X - 1) and 0xFF
            //> bpl ThreeSChk              ;do this until first three slots are checked
            if (!((X and 0x80) != 0)) {
                //  continue loop (branch back to ThreeSChk)
                continue@loop0
            }
        } while ((X and 0x80) == 0)
    }
    //> ExCannon: rts                        ;then leave
    return
}

// Decompiled from BulletBillHandler
fun bulletBillHandler(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var timerControl by MemoryByte(TimerControl)
    val bulletBillXSpdData by MemoryByteIndexed(BulletBillXSpdData)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> BulletBillHandler:
    //> lda TimerControl          ;if master timer control set,
    A = timerControl
    //> bne RunBBSubs             ;branch to run subroutines except movement sub
    X = X
    Y = Y
    if (A == 0) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
        if (A == 0) {
            //> lda Enemy_OffscreenBits   ;otherwise load offscreen bits
            A = enemyOffscreenbits
            //> and #%00001100            ;mask out bits
            A = A and 0x0C
            //> cmp #%00001100            ;check to see if all bits are set
            //> beq KillBB                ;if so, branch to kill this object
            if (A != 0x0C) {
                //> ldy #$01                  ;set to move right by default
                Y = 0x01
                //> jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
                val flag0: Boolean = playerEnemyDiff(X)
                //> bmi SetupBB               ;if enemy to the left of player, branch
                if ((A and 0x80) == 0) {
                    //> iny                       ;otherwise increment to move left
                    Y = (Y + 1) and 0xFF
                }
                //> SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
                enemyMovingdir[X] = Y
                //> dey                       ;decrement to use as offset
                Y = (Y - 1) and 0xFF
                //> lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
                A = bulletBillXSpdData[Y]
                //> sta Enemy_X_Speed,x       ;and store it
                enemyXSpeed[X] = A
                //> lda $00                   ;get horizontal difference
                A = memory[0x0].toInt()
                //> adc #$28                  ;add 40 pixels
                temp0 = A + 0x28 + if (flag0) 1 else 0
                A = temp0 and 0xFF
                //> cmp #$50                  ;if less than a certain amount, player is too close
                //> bcc KillBB                ;to cannon either on left or right side, thus branch
                if (A >= 0x50) {
                    //> lda #$01
                    A = 0x01
                    //> sta Enemy_State,x         ;otherwise set bullet bill's state
                    enemyState[X] = A
                    //> lda #$0a
                    A = 0x0A
                    //> sta EnemyFrameTimer,x     ;set enemy frame timer
                    enemyFrameTimer[X] = A
                    //> lda #Sfx_Blast
                    A = Sfx_Blast
                    //> sta Square2SoundQueue     ;play fireworks/gunfire sound
                    square2SoundQueue = A
                }
            }
        }
        //> ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
        A = enemyState[X]
        //> and #%00100000
        A = A and 0x20
        //> beq BBFly                 ;if not set, skip to move horizontally
        if (A != 0) {
            //> jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
            temp1 = movedEnemyvertically(X)
            X = temp1
        }
        //> BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
        val pair0 = moveEnemyHorizontally(A, X)
        temp2 = pair0.first
        temp3 = pair0.second
        X = temp3
    }
    //> RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
    val pair1 = getEnemyOffscreenBits(X)
    temp4 = pair1.first
    temp5 = pair1.second
    X = temp4
    //> jsr RelativeEnemyPosition ;get relative coordinates
    temp6 = relativeEnemyPosition(temp4)
    X = temp6
    //> jsr GetEnemyBoundBox      ;get bounding box coordinates
    val pair2 = getEnemyBoundBox(temp6)
    temp7 = pair2.first
    temp8 = pair2.second
    X = temp7
    //> jsr PlayerEnemyCollision  ;handle player to enemy collisions
    temp9 = playerEnemyCollision(temp7, temp8)
    X = temp9
    //> jmp EnemyGfxHandler       ;draw the bullet bill and leave
    return enemyGfxHandler(temp9)
    //> KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
    temp10 = eraseEnemyObject(temp9)
    //> rts
    return Pair(temp9, temp8)
}

// Decompiled from SpawnHammerObj
fun spawnHammerObj(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val hammerEnemyOffset by MemoryByteIndexed(HammerEnemyOffset)
    val hammerEnemyOfsData by MemoryByteIndexed(HammerEnemyOfsData)
    val miscBoundboxctrl by MemoryByteIndexed(Misc_BoundBoxCtrl)
    val miscState by MemoryByteIndexed(Misc_State)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> SpawnHammerObj:
    //> lda PseudoRandomBitReg+1 ;get pseudorandom bits from
    A = pseudoRandomBitReg[1]
    //> and #%00000111           ;second part of LSFR
    A = A and 0x07
    //> bne SetMOfs              ;if any bits are set, branch and use as offset
    if (A == 0) {
        //> lda PseudoRandomBitReg+1
        A = pseudoRandomBitReg[1]
        //> and #%00001000           ;get d3 from same part of LSFR
        A = A and 0x08
    }
    //> SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
    Y = A
    //> lda Misc_State,y         ;if any values loaded in
    A = miscState[Y]
    //> bne NoHammer             ;$2a-$32 where offset is then leave with carry clear
    Y = Y
    if (A == 0) {
        //> ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
        X = hammerEnemyOfsData[Y]
        //> lda Enemy_Flag,x         ;check enemy buffer flag at offset
        A = enemyFlag[X]
        //> bne NoHammer             ;if buffer flag set, branch to leave with carry clear
        if (A == 0) {
            //> ldx ObjectOffset         ;get original enemy object offset
            X = objectOffset
            //> txa
            A = X
            //> sta HammerEnemyOffset,y  ;save here
            hammerEnemyOffset[Y] = A
            //> lda #$90
            A = 0x90
            //> sta Misc_State,y         ;save hammer's state here
            miscState[Y] = A
            //> lda #$07
            A = 0x07
            //> sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
            miscBoundboxctrl[Y] = A
            //> sec                      ;return with carry set
            //> rts
            return X
        }
    }
    //> NoHammer: ldx ObjectOffset         ;get original enemy object offset
    X = objectOffset
    //> clc                      ;return with carry clear
    //> rts
    return X
}

// Decompiled from ProcHammerObj
fun procHammerObj(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val hammerEnemyOffset by MemoryByteIndexed(HammerEnemyOffset)
    val hammerXSpdData by MemoryByteIndexed(HammerXSpdData)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscXSpeed by MemoryByteIndexed(Misc_X_Speed)
    val miscYHighpos by MemoryByteIndexed(Misc_Y_HighPos)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> ProcHammerObj:
    //> lda TimerControl           ;if master timer control set
    A = timerControl
    //> bne RunHSubs               ;skip all of this code and go to last subs at the end
    if (!(A == 0)) {
        //  goto RunHSubs -> runHSubs
        runHSubs(X)
        return
    } else {
        //> lda Misc_State,x           ;otherwise get hammer's state
        A = miscState[X]
        //> and #%01111111             ;mask out d7
        A = A and 0x7F
        //> ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
        Y = hammerEnemyOffset[X]
        //> cmp #$02                   ;check hammer's state
        //> beq SetHSpd                ;if currently at 2, branch
        X = X
        if (A != 0x02) {
            //> bcs SetHPos                ;if greater than 2, branch elsewhere
            if (!(A >= 0x02)) {
                //> txa
                A = X
                //> clc                        ;add 13 bytes to use
                //> adc #$0d                   ;proper misc object
                temp0 = A + 0x0D
                A = temp0 and 0xFF
                //> tax                        ;return offset to X
                X = A
                //> lda #$10
                A = 0x10
                //> sta $00                    ;set downward movement force
                memory[0x0] = A.toUByte()
                //> lda #$0f
                A = 0x0F
                //> sta $01                    ;set upward movement force (not used)
                memory[0x1] = A.toUByte()
                //> lda #$04
                A = 0x04
                //> sta $02                    ;set maximum vertical speed
                memory[0x2] = A.toUByte()
                //> lda #$00                   ;set A to impose gravity on hammer
                A = 0x00
                //> jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
                imposeGravity(A, X)
                //> jsr MoveObjectHorizontally ;do sub to move it horizontally
                moveObjectHorizontally(X)
                //> ldx ObjectOffset           ;get original misc object offset
                X = objectOffset
                //> jmp RunAllH                ;branch to essential subroutines
                runAllH(X)
                return
            }
        }
    }
    //> SetHSpd:  lda #$fe
    A = 0xFE
    //> sta Misc_Y_Speed,x         ;set hammer's vertical speed
    miscYSpeed[X] = A
    //> lda Enemy_State,y          ;get enemy object state
    A = enemyState[Y]
    //> and #%11110111             ;mask out d3
    A = A and 0xF7
    //> sta Enemy_State,y          ;store new state
    enemyState[Y] = A
    //> ldx Enemy_MovingDir,y      ;get enemy's moving direction
    X = enemyMovingdir[Y]
    //> dex                        ;decrement to use as offset
    X = (X - 1) and 0xFF
    //> lda HammerXSpdData,x       ;get proper speed to use based on moving direction
    A = hammerXSpdData[X]
    //> ldx ObjectOffset           ;reobtain hammer's buffer offset
    X = objectOffset
    //> sta Misc_X_Speed,x         ;set hammer's horizontal speed
    miscXSpeed[X] = A
    //> SetHPos:  dec Misc_State,x           ;decrement hammer's state
    miscState[X] = (miscState[X] - 1) and 0xFF
    //> lda Enemy_X_Position,y     ;get enemy's horizontal position
    A = enemyXPosition[Y]
    //> clc
    //> adc #$02                   ;set position 2 pixels to the right
    temp1 = A + 0x02
    A = temp1 and 0xFF
    //> sta Misc_X_Position,x      ;store as hammer's horizontal position
    miscXPosition[X] = A
    //> lda Enemy_PageLoc,y        ;get enemy's page location
    A = enemyPageloc[Y]
    //> adc #$00                   ;add carry
    temp2 = A + if (temp1 > 0xFF) 1 else 0
    A = temp2 and 0xFF
    //> sta Misc_PageLoc,x         ;store as hammer's page location
    miscPageloc[X] = A
    //> lda Enemy_Y_Position,y     ;get enemy's vertical position
    A = enemyYPosition[Y]
    //> sec
    //> sbc #$0a                   ;move position 10 pixels upward
    temp3 = A - 0x0A
    A = temp3 and 0xFF
    //> sta Misc_Y_Position,x      ;store as hammer's vertical position
    miscYPosition[X] = A
    //> lda #$01
    A = 0x01
    //> sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
    miscYHighpos[X] = A
    //> bne RunHSubs               ;unconditional branch to skip first routine
    if (!(A == 0)) {
        //  goto RunHSubs -> runHSubs
        runHSubs(X)
        return
    }
    //  Fall-through tail call to runAllH
    runAllH(X)
    return
}

// Decompiled from RunAllH
fun runAllH(X: Int) {
    //> RunAllH:  jsr PlayerHammerCollision  ;handle collisions
    playerHammerCollision(X)
    //  Fall-through tail call to runHSubs
    runHSubs(X)
    return
}

// Decompiled from RunHSubs
fun runHSubs(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    //> RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
    temp0 = getMiscOffscreenBits(X)
    X = temp0
    //> jsr RelativeMiscPosition   ;get relative coordinates
    temp1 = relativeMiscPosition(temp0)
    X = temp1
    //> jsr GetMiscBoundBox        ;get bounding box coordinates
    temp2 = getMiscBoundBox(temp1)
    X = temp2
    //> jsr DrawHammer             ;draw the hammer
    drawHammer(temp2)
    //> rts                        ;and we are done here
    return
}

// Decompiled from CoinBlock
fun coinBlock(X: Int, Y: Int): Int {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    //> CoinBlock:
    //> jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
    temp0 = findEmptyMiscSlot()
    //> lda Block_PageLoc,x     ;get page location of block object
    A = blockPageloc[X]
    //> sta Misc_PageLoc,y      ;store as page location of misc object
    miscPageloc[temp0] = A
    //> lda Block_X_Position,x  ;get horizontal coordinate of block object
    A = blockXPosition[X]
    //> ora #$05                ;add 5 pixels
    A = A or 0x05
    //> sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
    miscXPosition[temp0] = A
    //> lda Block_Y_Position,x  ;get vertical coordinate of block object
    A = blockYPosition[X]
    //> sbc #$10                ;subtract 16 pixels
    temp1 = A - 0x10
    A = temp1 and 0xFF
    //> sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
    miscYPosition[temp0] = A
    //> jmp JCoinC              ;jump to rest of code as applies to this misc object
    return jCoinC(X, temp0)
}

// Decompiled from SetupJumpCoin
fun setupJumpCoin(X: Int, Y: Int): Int {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val blockPageloc2 by MemoryByteIndexed(Block_PageLoc2)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    //> SetupJumpCoin:
    //> jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
    temp0 = findEmptyMiscSlot()
    //> lda Block_PageLoc2,x   ;get page location saved earlier
    A = blockPageloc2[X]
    //> sta Misc_PageLoc,y     ;and save as page location for misc object
    miscPageloc[temp0] = A
    //> lda $06                ;get low byte of block buffer offset
    A = memory[0x6].toInt()
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                    ;multiply by 16 to use lower nybble
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> ora #$05               ;add five pixels
    A = A or 0x05
    //> sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
    miscXPosition[temp0] = A
    //> lda $02                ;get vertical high nybble offset from earlier
    A = memory[0x2].toInt()
    //> adc #$20               ;add 32 pixels for the status bar
    temp1 = A + 0x20 + if ((orig3 and 0x80) != 0) 1 else 0
    A = temp1 and 0xFF
    //> sta Misc_Y_Position,y  ;store as vertical coordinate
    miscYPosition[temp0] = A
    //  Fall-through tail call to jCoinC
    return jCoinC(X, temp0)
}

// Decompiled from JCoinC
fun jCoinC(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var coinTallyFor1Ups by MemoryByte(CoinTallyFor1Ups)
    var objectOffset by MemoryByte(ObjectOffset)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscYHighpos by MemoryByteIndexed(Misc_Y_HighPos)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> JCoinC: lda #$fb
    A = 0xFB
    //> sta Misc_Y_Speed,y     ;set vertical speed
    miscYSpeed[Y] = A
    //> lda #$01
    A = 0x01
    //> sta Misc_Y_HighPos,y   ;set vertical high byte
    miscYHighpos[Y] = A
    //> sta Misc_State,y       ;set state for misc object
    miscState[Y] = A
    //> sta Square2SoundQueue  ;load coin grab sound
    square2SoundQueue = A
    //> stx ObjectOffset       ;store current control bit as misc object offset
    objectOffset = X
    //> jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
    temp0 = giveOneCoin()
    X = temp0
    //> inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
    coinTallyFor1Ups = (coinTallyFor1Ups + 1) and 0xFF
    //> rts
    return temp0
}

// Decompiled from FindEmptyMiscSlot
fun findEmptyMiscSlot(): Int {
    var Y: Int = 0
    var jumpCoinMiscOffset by MemoryByte(JumpCoinMiscOffset)
    val miscState by MemoryByteIndexed(Misc_State)
    //> FindEmptyMiscSlot:
    //> ldy #$08                ;start at end of misc objects buffer
    Y = 0x08
    loop0@ while (Y != 0) {
        //> dey                     ;decrement offset
        Y = (Y - 1) and 0xFF
        //> cpy #$05                ;do this for three slots
        //> bne FMiscLoop           ;do this until all slots are checked
        if (!(Y == 0x05)) {
            //  continue loop (branch back to FMiscLoop)
            continue@loop0
        }
    }
    //> ldy #$08                ;if no empty slots found, use last slot
    Y = 0x08
    //> UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
    jumpCoinMiscOffset = Y
    //> rts
    return Y
}

// Decompiled from MiscObjectsCore
fun miscObjectsCore() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var scrollAmount by MemoryByte(ScrollAmount)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> MiscObjectsCore:
    //> ldx #$08          ;set at end of misc object buffer
    X = 0x08
    loop0@ do {
        //> MiscLoop: stx ObjectOffset  ;store misc object offset here
        objectOffset = X
        //> lda Misc_State,x  ;check misc object state
        A = miscState[X]
        //> beq MiscLoopBack  ;branch to check next slot
        if (A != 0) {
            //> asl               ;otherwise shift d7 into carry
            val orig0: Int = A
            A = (orig0 shl 1) and 0xFF
            //> bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
            if ((orig0 and 0x80) != 0) {
                //> jsr ProcHammerObj ;otherwise go to process hammer,
                procHammerObj(X)
                //> jmp MiscLoopBack  ;then check next slot
                //> jmp MiscLoopBack (not a known function)
            } else {
                //> ProcJumpCoin:
                //> ldy Misc_State,x          ;check misc object state
                Y = miscState[X]
                //> dey                       ;decrement to see if it's set to 1
                Y = (Y - 1) and 0xFF
                //> beq JCoinRun              ;if so, branch to handle jumping coin
                if (Y != 0) {
                    //> inc Misc_State,x          ;otherwise increment state to either start off or as timer
                    miscState[X] = (miscState[X] + 1) and 0xFF
                    //> lda Misc_X_Position,x     ;get horizontal coordinate for misc object
                    A = miscXPosition[X]
                    //> clc                       ;whether its jumping coin (state 0 only) or floatey number
                    //> adc ScrollAmount          ;add current scroll speed
                    temp0 = A + scrollAmount
                    A = temp0 and 0xFF
                    //> sta Misc_X_Position,x     ;store as new horizontal coordinate
                    miscXPosition[X] = A
                    //> lda Misc_PageLoc,x        ;get page location
                    A = miscPageloc[X]
                    //> adc #$00                  ;add carry
                    temp1 = A + if (temp0 > 0xFF) 1 else 0
                    A = temp1 and 0xFF
                    //> sta Misc_PageLoc,x        ;store as new page location
                    miscPageloc[X] = A
                    //> lda Misc_State,x
                    A = miscState[X]
                    //> cmp #$30                  ;check state of object for preset value
                    //> bne RunJCSubs             ;if not yet reached, branch to subroutines
                    if (A == 0x30) {
                        //> lda #$00
                        A = 0x00
                        //> sta Misc_State,x          ;otherwise nullify object state
                        miscState[X] = A
                        //> jmp MiscLoopBack          ;and move onto next slot
                        //> jmp MiscLoopBack (not a known function)
                    }
                } else {
                    //> JCoinRun:  txa
                    A = X
                    //> clc                       ;add 13 bytes to offset for next subroutine
                    //> adc #$0d
                    temp2 = A + 0x0D
                    A = temp2 and 0xFF
                    //> tax
                    X = A
                    //> lda #$50                  ;set downward movement amount
                    A = 0x50
                    //> sta $00
                    memory[0x0] = A.toUByte()
                    //> lda #$06                  ;set maximum vertical speed
                    A = 0x06
                    //> sta $02
                    memory[0x2] = A.toUByte()
                    //> lsr                       ;divide by 2 and set
                    val orig1: Int = A
                    A = orig1 shr 1
                    //> sta $01                   ;as upward movement amount (apparently residual)
                    memory[0x1] = A.toUByte()
                    //> lda #$00                  ;set A to impose gravity on jumping coin
                    A = 0x00
                    //> jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
                    imposeGravity(A, X)
                    //> ldx ObjectOffset          ;get original misc object offset
                    X = objectOffset
                    //> lda Misc_Y_Speed,x        ;check vertical speed
                    A = miscYSpeed[X]
                    //> cmp #$05
                    //> bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
                    if (A == 0x05) {
                        //> inc Misc_State,x          ;otherwise increment state to change to floatey number
                        miscState[X] = (miscState[X] + 1) and 0xFF
                    }
                    //> RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
                    temp3 = relativeMiscPosition(X)
                    X = temp3
                    //> jsr GetMiscOffscreenBits  ;get offscreen information
                    temp4 = getMiscOffscreenBits(temp3)
                    X = temp4
                    //> jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
                    temp5 = getMiscBoundBox(temp4)
                    X = temp5
                    //> jsr JCoinGfxHandler       ;draw the coin or floatey number
                    temp6 = jCoinGfxHandler(temp5)
                    X = temp6
                }
            }
        }
        //> MiscLoopBack:
        //> dex                       ;decrement misc object offset
        X = (X - 1) and 0xFF
        //> bpl MiscLoop              ;loop back until all misc objects handled
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to MiscLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> rts                       ;then leave
    return
}

// Decompiled from GiveOneCoin
fun giveOneCoin(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var coinTally by MemoryByte(CoinTally)
    var currentPlayer by MemoryByte(CurrentPlayer)
    var numberofLives by MemoryByte(NumberofLives)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val coinTallyOffsets by MemoryByteIndexed(CoinTallyOffsets)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    //> GiveOneCoin:
    //> lda #$01               ;set digit modifier to add 1 coin
    A = 0x01
    //> sta DigitModifier+5    ;to the current player's coin tally
    digitModifier[5] = A
    //> ldx CurrentPlayer      ;get current player on the screen
    X = currentPlayer
    //> ldy CoinTallyOffsets,x ;get offset for player's coin tally
    Y = coinTallyOffsets[X]
    //> jsr DigitsMathRoutine  ;update the coin tally
    digitsMathRoutine(Y)
    //> inc CoinTally          ;increment onscreen player's coin amount
    coinTally = (coinTally + 1) and 0xFF
    //> lda CoinTally
    A = coinTally
    //> cmp #100               ;does player have 100 coins yet?
    //> bne CoinPoints         ;if not, skip all of this
    if (A == 0x64) {
        //> lda #$00
        A = 0x00
        //> sta CoinTally          ;otherwise, reinitialize coin amount
        coinTally = A
        //> inc NumberofLives      ;give the player an extra life
        numberofLives = (numberofLives + 1) and 0xFF
        //> lda #Sfx_ExtraLife
        A = Sfx_ExtraLife
        //> sta Square2SoundQueue  ;play 1-up sound
        square2SoundQueue = A
    }
    //> CoinPoints:
    //> lda #$02               ;set digit modifier to award
    A = 0x02
    //> sta DigitModifier+4    ;200 points to the player
    digitModifier[4] = A
    //  Fall-through tail call to addToScore
    return addToScore()
}

// Decompiled from AddToScore
fun addToScore(): Int {
    var X: Int = 0
    var Y: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    val scoreOffsets by MemoryByteIndexed(ScoreOffsets)
    //> AddToScore:
    //> ldx CurrentPlayer      ;get current player
    X = currentPlayer
    //> ldy ScoreOffsets,x     ;get offset for player's score
    Y = scoreOffsets[X]
    //> jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
    digitsMathRoutine(Y)
    //  Fall-through tail call to getSBNybbles
    getSBNybbles()
    return X
}

// Decompiled from GetSBNybbles
fun getSBNybbles() {
    var A: Int = 0
    var Y: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    val statusBarNybbles by MemoryByteIndexed(StatusBarNybbles)
    //> GetSBNybbles:
    //> ldy CurrentPlayer      ;get current player
    Y = currentPlayer
    //> lda StatusBarNybbles,y ;get nybbles based on player, use to update score and coins
    A = statusBarNybbles[Y]
    //  Fall-through tail call to updateNumber
    updateNumber(A)
    return
}

// Decompiled from UpdateNumber
fun updateNumber(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> UpdateNumber:
    //> jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
    printStatusBarNumbers(A)
    //> ldy VRAM_Buffer1_Offset
    Y = vramBuffer1Offset
    //> lda VRAM_Buffer1-6,y      ;check highest digit of score
    A = vramBuffer1[-6 + Y]
    //> bne NoZSup                ;if zero, overwrite with space tile for zero suppression
    if (A == 0) {
        //> lda #$24
        A = 0x24
        //> sta VRAM_Buffer1-6,y
        vramBuffer1[-6 + Y] = A
    }
    //> NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
    X = objectOffset
    //> rts
    return
}

// Decompiled from SetupPowerUp
fun setupPowerUp(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> SetupPowerUp:
    //> lda #PowerUpObject        ;load power-up identifier into
    A = PowerUpObject
    //> sta Enemy_ID+5            ;special use slot of enemy object buffer
    enemyId[5] = A
    //> lda Block_PageLoc,x       ;store page location of block object
    A = blockPageloc[X]
    //> sta Enemy_PageLoc+5       ;as page location of power-up object
    enemyPageloc[5] = A
    //> lda Block_X_Position,x    ;store horizontal coordinate of block object
    A = blockXPosition[X]
    //> sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
    enemyXPosition[5] = A
    //> lda #$01
    A = 0x01
    //> sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
    enemyYHighpos[5] = A
    //> lda Block_Y_Position,x    ;get vertical coordinate of block object
    A = blockYPosition[X]
    //> sec
    //> sbc #$08                  ;subtract 8 pixels
    temp0 = A - 0x08
    A = temp0 and 0xFF
    //> sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
    enemyYPosition[5] = A
    //  Fall-through tail call to pwrUpJmp
    pwrUpJmp()
    return
}

// Decompiled from PwrUpJmp
fun pwrUpJmp() {
    var A: Int = 0
    var playerStatus by MemoryByte(PlayerStatus)
    var powerUpType by MemoryByte(PowerUpType)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
    A = 0x01
    //> sta Enemy_State+5         ;set power-up object's state
    enemyState[5] = A
    //> sta Enemy_Flag+5          ;set buffer flag
    enemyFlag[5] = A
    //> lda #$03
    A = 0x03
    //> sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
    enemyBoundboxctrl[5] = A
    //> lda PowerUpType
    A = powerUpType
    //> cmp #$02                  ;check currently loaded power-up type
    //> bcs PutBehind             ;if star or 1-up, branch ahead
    if (!(A >= 0x02)) {
        //> lda PlayerStatus          ;otherwise check player's current status
        A = playerStatus
        //> cmp #$02
        //> bcc StrType               ;if player not fiery, use status as power-up type
        if (A >= 0x02) {
            //> lsr                       ;otherwise shift right to force fire flower type
            val orig0: Int = A
            A = orig0 shr 1
        }
        //> StrType:   sta PowerUpType           ;store type here
        powerUpType = A
    }
    //> PutBehind: lda #%00100000
    A = 0x20
    //> sta Enemy_SprAttrib+5     ;set background priority bit
    enemySprattrib[5] = A
    //> lda #Sfx_GrowPowerUp
    A = Sfx_GrowPowerUp
    //> sta Square2SoundQueue     ;load power-up reveal sound and leave
    square2SoundQueue = A
    //> rts
    return
}

// Decompiled from PowerUpObjHandler
fun powerUpObjHandler(Y: Int) {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var powerUpType by MemoryByte(PowerUpType)
    var timerControl by MemoryByte(TimerControl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> PowerUpObjHandler:
    //> ldx #$05                   ;set object offset for last slot in enemy object buffer
    X = 0x05
    //> stx ObjectOffset
    objectOffset = X
    //> lda Enemy_State+5          ;check power-up object's state
    A = enemyState[5]
    //> beq ExitPUp                ;if not set, branch to leave
    if (A == 0) {
        //  goto ExitPUp -> exitPUp
        exitPUp()
        return
    } else {
        //> asl                        ;shift to check if d7 was set in object state
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
        Y = Y
        if ((orig0 and 0x80) != 0) {
            //> lda TimerControl           ;if master timer control set,
            A = timerControl
            //> bne RunPUSubs              ;branch ahead to enemy object routines
            if (!(A == 0)) {
                //  goto RunPUSubs -> runPUSubs
                runPUSubs(X, Y)
                return
            }
            //> lda PowerUpType            ;check power-up type
            A = powerUpType
            //> beq ShroomM                ;if normal mushroom, branch ahead to move it
            if (A != 0) {
                //> cmp #$03
                //> beq ShroomM                ;if 1-up mushroom, branch ahead to move it
                if (A != 0x03) {
                    //> cmp #$02
                    //> bne RunPUSubs              ;if not star, branch elsewhere to skip movement
                    if (!(A == 0x02)) {
                        //  goto RunPUSubs -> runPUSubs
                        runPUSubs(X, Y)
                        return
                    }
                    //> jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
                    val pair0 = moveJumpingEnemy(X, Y)
                    temp0 = pair0.first
                    temp1 = pair0.second
                    X = temp1
                    //> jsr EnemyJump              ;note that green paratroopa shares the same code here
                    val pair1 = enemyJump(X, temp1)
                    temp2 = pair1.first
                    temp3 = pair1.second
                    X = temp2
                    //> jmp RunPUSubs              ;then jump to other power-up subroutines
                    runPUSubs(temp2, temp3)
                    return
                }
            }
            //> ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
            val pair2 = moveNormalEnemy(X)
            temp4 = pair2.first
            temp5 = pair2.second
            X = temp5
            //> jsr EnemyToBGCollisionDet  ;deal with collisions
            val pair3 = enemyToBGCollisionDet(X)
            temp6 = pair3.first
            temp7 = pair3.second
            X = temp6
            //> jmp RunPUSubs              ;run the other subroutines
            runPUSubs(temp6, temp7)
            return
        }
    }
    //> GrowThePowerUp:
    //> lda FrameCounter           ;get frame counter
    A = frameCounter
    //> and #$03                   ;mask out all but 2 LSB
    A = A and 0x03
    //> bne ChkPUSte               ;if any bits set here, branch
    if (A == 0) {
        //> dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
        enemyYPosition[5] = (enemyYPosition[5] - 1) and 0xFF
        //> lda Enemy_State+5          ;load power-up object state
        A = enemyState[5]
        //> inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
        enemyState[5] = (enemyState[5] + 1) and 0xFF
        //> cmp #$11                   ;if power-up object state not yet past 16th pixel,
        //> bcc ChkPUSte               ;branch ahead to last part here
        if (A >= 0x11) {
            //> lda #$10
            A = 0x10
            //> sta Enemy_X_Speed,x        ;otherwise set horizontal speed
            enemyXSpeed[X] = A
            //> lda #%10000000
            A = 0x80
            //> sta Enemy_State+5          ;and then set d7 in power-up object's state
            enemyState[5] = A
            //> asl                        ;shift once to init A
            val orig1: Int = A
            A = (orig1 shl 1) and 0xFF
            //> sta Enemy_SprAttrib+5      ;initialize background priority bit set here
            enemySprattrib[5] = A
            //> rol                        ;rotate A to set right moving direction
            val orig2: Int = A
            A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x80) != 0) 1 else 0
            //> sta Enemy_MovingDir,x      ;set moving direction
            enemyMovingdir[X] = A
        }
    }
    //> ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
    A = enemyState[5]
    //> cmp #$06                   ;for if power-up has risen enough
    //> bcc ExitPUp                ;if not, don't even bother running these routines
    if (!(A >= 0x06)) {
        //  goto ExitPUp -> exitPUp
        exitPUp()
        return
    }
    //  Fall-through tail call to runPUSubs
    runPUSubs(X, Y)
    return
}

// Decompiled from RunPUSubs
fun runPUSubs(X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    //> RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
    temp0 = relativeEnemyPosition(X)
    X = temp0
    //> jsr GetEnemyOffscreenBits  ;get offscreen bits
    val pair0 = getEnemyOffscreenBits(temp0)
    temp1 = pair0.first
    temp2 = pair0.second
    X = temp1
    //> jsr GetEnemyBoundBox       ;get bounding box coordinates
    val pair1 = getEnemyBoundBox(temp1)
    temp3 = pair1.first
    temp4 = pair1.second
    X = temp3
    //> jsr DrawPowerUp            ;draw the power-up object
    drawPowerUp()
    //> jsr PlayerEnemyCollision   ;check for collision with player
    temp5 = playerEnemyCollision(temp3, temp4)
    X = temp5
    //> jsr OffscreenBoundsCheck   ;check to see if it went offscreen
    offscreenBoundsCheck(temp5)
    //  Fall-through tail call to exitPUp
    exitPUp()
    return
}

// Decompiled from ExitPUp
fun exitPUp() {
    //> ExitPUp:   rts                        ;and we're done
    return
}

// Decompiled from PlayerHeadCollision
fun playerHeadCollision(A: Int): Int {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var blockBounceTimer by MemoryByte(BlockBounceTimer)
    var brickCoinTimer by MemoryByte(BrickCoinTimer)
    var brickCoinTimerFlag by MemoryByte(BrickCoinTimerFlag)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var playerSize by MemoryByte(PlayerSize)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    val blockYPosAdderData by MemoryByteIndexed(BlockYPosAdderData)
    val blockBbufLow by MemoryByteIndexed(Block_BBuf_Low)
    val blockMetatile by MemoryByteIndexed(Block_Metatile)
    val blockOrigYpos by MemoryByteIndexed(Block_Orig_YPos)
    val blockState by MemoryByteIndexed(Block_State)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    //> PlayerHeadCollision:
    //> pha                      ;store metatile number to stack
    push(A)
    //> lda #$11                 ;load unbreakable block object state by default
    A = 0x11
    //> ldx SprDataOffset_Ctrl   ;load offset control bit here
    X = sprdataoffsetCtrl
    //> ldy PlayerSize           ;check player's size
    Y = playerSize
    //> bne DBlockSte            ;if small, branch
    if (Y == 0) {
        //> lda #$12                 ;otherwise load breakable block object state
        A = 0x12
    }
    //> DBlockSte: sta Block_State,x        ;store into block object buffer
    blockState[X] = A
    //> jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
    val pair0 = destroyBlockMetatile(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> ldx SprDataOffset_Ctrl   ;load offset control bit
    X = sprdataoffsetCtrl
    //> lda $02                  ;get vertical high nybble offset used in block buffer routine
    A = memory[0x2].toInt()
    //> sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
    blockOrigYpos[X] = A
    //> tay
    Y = A
    //> lda $06                  ;get low byte of block buffer address used in same routine
    A = memory[0x6].toInt()
    //> sta Block_BBuf_Low,x     ;save as offset here to be used later
    blockBbufLow[X] = A
    //> lda ($06),y              ;get contents of block buffer at old address at $06, $07
    A = memory[readWord(0x6) + Y].toInt()
    //> jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
    temp2 = blockBumpedChk(A)
    //> sta $00                  ;store metatile here
    memory[0x0] = A.toUByte()
    //> ldy PlayerSize           ;check player's size
    Y = playerSize
    //> bne ChkBrick             ;if small, use metatile itself as contents of A
    if (Y == 0) {
        //> tya                      ;otherwise init A (note: big = 0)
        A = Y
    }
    //> ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
    if (flagC) {
        //> ldy #$11                 ;otherwise load unbreakable state into block object buffer
        Y = 0x11
        //> sty Block_State,x        ;note this applies to both player sizes
        blockState[X] = Y
        //> lda #$c4                 ;load empty block metatile into A for now
        A = 0xC4
        //> ldy $00                  ;get metatile from before
        Y = memory[0x0].toInt()
        //> cpy #$58                 ;is it brick with coins (with line)?
        //> beq StartBTmr            ;if so, branch
        if (Y != 0x58) {
            //> cpy #$5d                 ;is it brick with coins (without line)?
            //> bne PutMTileB            ;if not, branch ahead to store empty block metatile
            if (!(Y == 0x5D)) {
                //  goto PutMTileB (internal forward branch)
                //> PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
                blockMetatile[X] = A
                //> jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
                initblockXyPos(X)
                //> ldy $02                  ;get vertical high nybble offset
                Y = memory[0x2].toInt()
                //> lda #$23
                A = 0x23
                //> sta ($06),y              ;write blank metatile $23 to block buffer
                memory[readWord(0x6) + Y] = A.toUByte()
                //> lda #$10
                A = 0x10
                //> sta BlockBounceTimer     ;set block bounce timer
                blockBounceTimer = A
                //> pla                      ;pull original metatile from stack
                A = pull()
                //> sta $05                  ;and save here
                memory[0x5] = A.toUByte()
                //> ldy #$00                 ;set default offset
                Y = 0x00
                //> lda CrouchingFlag        ;is player crouching?
                A = crouchingFlag
                //> bne SmallBP              ;if so, branch to increment offset
                if (!(A == 0)) {
                    //  goto SmallBP (internal forward branch)
                    //> SmallBP:   iny                      ;increment for small or big and crouching
                    Y = (Y + 1) and 0xFF
                    return X
                }
                //> lda PlayerSize           ;is player big?
                A = playerSize
                //> beq BigBP                ;if so, branch to use default offset
                if (A == 0) {
                    //  goto BigBP (internal forward branch)
                    //> BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
                    A = playerYPosition
                    //> clc
                    //> adc BlockYPosAdderData,y ;add value determined by size
                    temp3 = A + blockYPosAdderData[Y]
                    A = temp3 and 0xFF
                    //> and #$f0                 ;mask out low nybble to get 16-pixel correspondence
                    A = A and 0xF0
                    //> sta Block_Y_Position,x   ;save as vertical coordinate for block object
                    blockYPosition[X] = A
                    //> ldy Block_State,x        ;get block object state
                    Y = blockState[X]
                    //> cpy #$11
                    //> beq Unbreak              ;if set to value loaded for unbreakable, branch
                    if (Y == 0x11) {
                        //  goto Unbreak (internal forward branch)
                        //> Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
                        bumpBlock(X, Y)
                        //  Fall-through tail call to invOBit
                        invOBit()
                        return X
                    }
                    //> jsr BrickShatter         ;execute code for breakable brick
                    brickShatter(X)
                    //> jmp InvOBit              ;skip subroutine to do last part of code here
                    invOBit()
                    return X
                }
                return X
            }
        }
        //> StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
        A = brickCoinTimerFlag
        //> bne ContBTmr             ;if set, timer expired or counting down, thus branch
        if (A == 0) {
            //> lda #$0b
            A = 0x0B
            //> sta BrickCoinTimer       ;if not set, set brick coin timer
            brickCoinTimer = A
            //> inc BrickCoinTimerFlag   ;and set flag linked to it
            brickCoinTimerFlag = (brickCoinTimerFlag + 1) and 0xFF
        }
        //> ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
        A = brickCoinTimer
        //> bne PutOldMT             ;if not yet expired, branch to use current metatile
        if (A == 0) {
            //> ldy #$c4                 ;otherwise use empty block metatile
            Y = 0xC4
        }
        //> PutOldMT:  tya                      ;put metatile into A
        A = Y
    }
    //> PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
    blockMetatile[X] = A
    //> jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
    initblockXyPos(X)
    //> ldy $02                  ;get vertical high nybble offset
    Y = memory[0x2].toInt()
    //> lda #$23
    A = 0x23
    //> sta ($06),y              ;write blank metatile $23 to block buffer
    memory[readWord(0x6) + Y] = A.toUByte()
    //> lda #$10
    A = 0x10
    //> sta BlockBounceTimer     ;set block bounce timer
    blockBounceTimer = A
    //> pla                      ;pull original metatile from stack
    A = pull()
    //> sta $05                  ;and save here
    memory[0x5] = A.toUByte()
    //> ldy #$00                 ;set default offset
    Y = 0x00
    //> lda CrouchingFlag        ;is player crouching?
    A = crouchingFlag
    //> bne SmallBP              ;if so, branch to increment offset
    if (A == 0) {
        //> lda PlayerSize           ;is player big?
        A = playerSize
        //> beq BigBP                ;if so, branch to use default offset
        if (A == 0) {
            //  goto BigBP (internal forward branch)
            //> BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
            A = playerYPosition
            //> clc
            //> adc BlockYPosAdderData,y ;add value determined by size
            temp4 = A + blockYPosAdderData[Y]
            A = temp4 and 0xFF
            //> and #$f0                 ;mask out low nybble to get 16-pixel correspondence
            A = A and 0xF0
            //> sta Block_Y_Position,x   ;save as vertical coordinate for block object
            blockYPosition[X] = A
            //> ldy Block_State,x        ;get block object state
            Y = blockState[X]
            //> cpy #$11
            //> beq Unbreak              ;if set to value loaded for unbreakable, branch
            if (Y == 0x11) {
                //  goto Unbreak (internal forward branch)
                //> Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
                bumpBlock(X, Y)
                //  Fall-through tail call to invOBit
                invOBit()
                return X
            }
            //> jsr BrickShatter         ;execute code for breakable brick
            brickShatter(X)
            //> jmp InvOBit              ;skip subroutine to do last part of code here
            invOBit()
            return X
        }
    }
    //> SmallBP:   iny                      ;increment for small or big and crouching
    Y = (Y + 1) and 0xFF
    //> BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
    A = playerYPosition
    //> clc
    //> adc BlockYPosAdderData,y ;add value determined by size
    temp5 = A + blockYPosAdderData[Y]
    A = temp5 and 0xFF
    //> and #$f0                 ;mask out low nybble to get 16-pixel correspondence
    A = A and 0xF0
    //> sta Block_Y_Position,x   ;save as vertical coordinate for block object
    blockYPosition[X] = A
    //> ldy Block_State,x        ;get block object state
    Y = blockState[X]
    //> cpy #$11
    //> beq Unbreak              ;if set to value loaded for unbreakable, branch
    if (Y != 0x11) {
        //> jsr BrickShatter         ;execute code for breakable brick
        brickShatter(X)
        //> jmp InvOBit              ;skip subroutine to do last part of code here
        invOBit()
        return X
    } else {
        //> Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
        bumpBlock(X, Y)
        //  Fall-through tail call to invOBit
        invOBit()
        return X
    }
}

// Decompiled from InvOBit
fun invOBit() {
    var A: Int = 0
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    //> InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
    A = sprdataoffsetCtrl
    //> eor #$01                 ;and floatey numbers
    A = A xor 0x01
    //> sta SprDataOffset_Ctrl
    sprdataoffsetCtrl = A
    //> rts                      ;leave!
    return
}

// Decompiled from InitBlock_XY_Pos
fun initblockXyPos(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockPageloc2 by MemoryByteIndexed(Block_PageLoc2)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYHighpos by MemoryByteIndexed(Block_Y_HighPos)
    //> InitBlock_XY_Pos:
    //> lda Player_X_Position   ;get player's horizontal coordinate
    A = playerXPosition
    //> clc
    //> adc #$08                ;add eight pixels
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> and #$f0                ;mask out low nybble to give 16-pixel correspondence
    A = A and 0xF0
    //> sta Block_X_Position,x  ;save as horizontal coordinate for block object
    blockXPosition[X] = A
    //> lda Player_PageLoc
    A = playerPageloc
    //> adc #$00                ;add carry to page location of player
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta Block_PageLoc,x     ;save as page location of block object
    blockPageloc[X] = A
    //> sta Block_PageLoc2,x    ;save elsewhere to be used later
    blockPageloc2[X] = A
    //> lda Player_Y_HighPos
    A = playerYHighpos
    //> sta Block_Y_HighPos,x   ;save vertical high byte of player into
    blockYHighpos[X] = A
    //> rts                     ;vertical high byte of block object and leave
    return
}

// Decompiled from BumpBlock
fun bumpBlock(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val blockXSpeed by MemoryByteIndexed(Block_X_Speed)
    val blockYMoveforce by MemoryByteIndexed(Block_Y_MoveForce)
    val blockYSpeed by MemoryByteIndexed(Block_Y_Speed)
    //> BumpBlock:
    //> jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
    val pair0 = checkTopOfBlock()
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda #Sfx_Bump
    A = Sfx_Bump
    //> sta Square1SoundQueue   ;play bump sound
    square1SoundQueue = A
    //> lda #$00
    A = 0x00
    //> sta Block_X_Speed,x     ;initialize horizontal speed for block object
    blockXSpeed[temp0] = A
    //> sta Block_Y_MoveForce,x ;init fractional movement force
    blockYMoveforce[temp0] = A
    //> sta Player_Y_Speed      ;init player's vertical speed
    playerYSpeed = A
    //> lda #$fe
    A = 0xFE
    //> sta Block_Y_Speed,x     ;set vertical speed for block object
    blockYSpeed[temp0] = A
    //> lda $05                 ;get original metatile from stack
    A = memory[0x5].toInt()
    //> jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
    temp2 = blockBumpedChk(A)
    //> bcc ExitBlockChk        ;if no match was found, branch to leave
    if (!(flagC)) {
        //  goto ExitBlockChk -> exitBlockChk
        exitBlockChk()
        return
    } else {
        //> tya                     ;move block number to A
        A = temp2
        //> cmp #$09                ;if block number was within 0-8 range,
        //> bcc BlockCode           ;branch to use current number
        X = temp0
        Y = temp2
        if (A >= 0x09) {
            //> sbc #$05                ;otherwise subtract 5 for second set to get proper number
            temp3 = A - 0x05 - if (A >= 0x09) 0 else 1
            A = temp3 and 0xFF
        }
    }
    //> BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
    when (A) {
        0 -> {
            mushFlowerBlock(X)
        }
        1 -> {
            coinBlock(X, Y)
        }
        2 -> {
            coinBlock(X, Y)
        }
        3 -> {
            extraLifeMushBlock()
        }
        4 -> {
            mushFlowerBlock(X)
        }
        5 -> {
            vineBlock()
        }
        6 -> {
            starBlock()
        }
        7 -> {
            coinBlock(X, Y)
        }
        8 -> {
            extraLifeMushBlock()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw MushFlowerBlock
    //> .dw CoinBlock
    //> .dw CoinBlock
    //> .dw ExtraLifeMushBlock
    //> .dw MushFlowerBlock
    //> .dw VineBlock
    //> .dw StarBlock
    //> .dw CoinBlock
    //> .dw ExtraLifeMushBlock
    //> ;--------------------------------
    //  Fall-through tail call to mushFlowerBlock
    mushFlowerBlock(X)
    return
}

// Decompiled from MushFlowerBlock
fun mushFlowerBlock(X: Int) {
    var A: Int = 0
    //> MushFlowerBlock:
    //> lda #$00       ;load mushroom/fire flower into power-up type
    A = 0x00
    //> .db $2c        ;BIT instruction opcode
    //> StarBlock:
    //> lda #$02       ;load star into power-up type
    //  (skipped by BIT $2C)
    //> .db $2c        ;BIT instruction opcode
    //> ExtraLifeMushBlock:
    //> lda #$03         ;load 1-up mushroom into power-up type
    //  (skipped by BIT $2C)
    //> sta $39          ;store correct power-up type
    memory[0x39] = A.toUByte()
    //> jmp SetupPowerUp
    setupPowerUp(X)
    return
}

// Decompiled from StarBlock
fun starBlock() {
    extraLifeMushBlock()
    return
}

// Decompiled from ExtraLifeMushBlock
fun extraLifeMushBlock() {
}

// Decompiled from VineBlock
fun vineBlock(): Int {
    var X: Int = 0
    var Y: Int = 0
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    //> VineBlock:
    //> ldx #$05                ;load last slot for enemy object buffer
    X = 0x05
    //> ldy SprDataOffset_Ctrl  ;get control bit
    Y = sprdataoffsetCtrl
    //> jsr Setup_Vine          ;set up vine object
    setupVine(X, Y)
    //  Fall-through tail call to exitBlockChk
    exitBlockChk()
    return X
}

// Decompiled from ExitBlockChk
fun exitBlockChk() {
    //> ExitBlockChk:
    //> rts                     ;leave
    return
}

// Decompiled from BlockBumpedChk
fun blockBumpedChk(A: Int): Int {
    var Y: Int = 0
    var exitFlag0: Boolean = false
    val brickQBlockMetatiles by MemoryByteIndexed(BrickQBlockMetatiles)
    //> BlockBumpedChk:
    //> ldy #$0d                    ;start at end of metatile data
    Y = 0x0D
    loop0@ while (Y != 0) {
        //> dey                         ;otherwise move onto next metatile
        Y = (Y - 1) and 0xFF
        //> bpl BumpChkLoop             ;do this until all metatiles are checked
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to BumpChkLoop)
            continue@loop0
        }
    }
    //> clc                         ;if none match, return with carry clear
    //> MatchBump:   rts                         ;note carry is set if found match
    return Y
}

// Decompiled from BrickShatter
fun brickShatter(X: Int) {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    //> BrickShatter:
    //> jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
    val pair0 = checkTopOfBlock()
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda #Sfx_BrickShatter
    A = Sfx_BrickShatter
    //> sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
    blockRepflag[temp0] = A
    //> sta NoiseSoundQueue    ;load brick shatter sound
    noiseSoundQueue = A
    //> jsr SpawnBrickChunks   ;create brick chunk objects
    spawnBrickChunks(temp0)
    //> lda #$fe
    A = 0xFE
    //> sta Player_Y_Speed     ;set vertical speed for player
    playerYSpeed = A
    //> lda #$05
    A = 0x05
    //> sta DigitModifier+5    ;set digit modifier to give player 50 points
    digitModifier[5] = A
    //> jsr AddToScore         ;do sub to update the score
    temp2 = addToScore()
    X = temp2
    //> ldx SprDataOffset_Ctrl ;load control bit and leave
    X = sprdataoffsetCtrl
    //> rts
    return
}

// Decompiled from CheckTopOfBlock
fun checkTopOfBlock(): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    //> CheckTopOfBlock:
    //> ldx SprDataOffset_Ctrl  ;load control bit
    X = sprdataoffsetCtrl
    //> ldy $02                 ;get vertical high nybble offset used in block buffer
    Y = memory[0x2].toInt()
    //> beq TopEx               ;branch to leave if set to zero, because we're at the top
    if (Y != 0) {
        //> tya                     ;otherwise set to A
        A = Y
        //> sec
        //> sbc #$10                ;subtract $10 to move up one row in the block buffer
        temp0 = A - 0x10
        //> sta $02                 ;store as new vertical high nybble offset
        memory[0x2] = (temp0 and 0xFF).toUByte()
        //> tay
        Y = temp0 and 0xFF
        //> lda ($06),y             ;get contents of block buffer in same column, one row up
        A = memory[readWord(0x6) + Y].toInt()
        //> cmp #$c2                ;is it a coin? (not underwater)
        //> bne TopEx               ;if not, branch to leave
        if (A == 0xC2) {
            //> lda #$00
            A = 0x00
            //> sta ($06),y             ;otherwise put blank metatile where coin was
            memory[readWord(0x6) + Y] = A.toUByte()
            //> jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
            removecoinAxe()
            //> ldx SprDataOffset_Ctrl  ;get control bit
            X = sprdataoffsetCtrl
            //> jsr SetupJumpCoin       ;create jumping coin object and update coin variables
            temp1 = setupJumpCoin(X, Y)
            X = temp1
        }
    }
    //> TopEx: rts                     ;leave!
    return Pair(X, Y)
}

// Decompiled from SpawnBrickChunks
fun spawnBrickChunks(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val blockOrigXpos by MemoryByteIndexed(Block_Orig_XPos)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockXSpeed by MemoryByteIndexed(Block_X_Speed)
    val blockYMoveforce by MemoryByteIndexed(Block_Y_MoveForce)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val blockYSpeed by MemoryByteIndexed(Block_Y_Speed)
    //> SpawnBrickChunks:
    //> lda Block_X_Position,x     ;set horizontal coordinate of block object
    A = blockXPosition[X]
    //> sta Block_Orig_XPos,x      ;as original horizontal coordinate here
    blockOrigXpos[X] = A
    //> lda #$f0
    A = 0xF0
    //> sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
    blockXSpeed[X] = A
    //> sta Block_X_Speed+2,x
    blockXSpeed[2 + X] = A
    //> lda #$fa
    A = 0xFA
    //> sta Block_Y_Speed,x        ;set vertical speed for one
    blockYSpeed[X] = A
    //> lda #$fc
    A = 0xFC
    //> sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
    blockYSpeed[2 + X] = A
    //> lda #$00
    A = 0x00
    //> sta Block_Y_MoveForce,x    ;init fractional movement force for both
    blockYMoveforce[X] = A
    //> sta Block_Y_MoveForce+2,x
    blockYMoveforce[2 + X] = A
    //> lda Block_PageLoc,x
    A = blockPageloc[X]
    //> sta Block_PageLoc+2,x      ;copy page location
    blockPageloc[2 + X] = A
    //> lda Block_X_Position,x
    A = blockXPosition[X]
    //> sta Block_X_Position+2,x   ;copy horizontal coordinate
    blockXPosition[2 + X] = A
    //> lda Block_Y_Position,x
    A = blockYPosition[X]
    //> clc                        ;add 8 pixels to vertical coordinate
    //> adc #$08                   ;and save as vertical coordinate for one of them
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> sta Block_Y_Position+2,x
    blockYPosition[2 + X] = A
    //> lda #$fa
    A = 0xFA
    //> sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
    blockYSpeed[X] = A
    //> rts
    return
}

// Decompiled from BlockObjectsCore
fun blockObjectsCore(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    val blockState by MemoryByteIndexed(Block_State)
    val blockYHighpos by MemoryByteIndexed(Block_Y_HighPos)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    //> BlockObjectsCore:
    //> lda Block_State,x           ;get state of block object
    A = blockState[X]
    //> beq UpdSte                  ;if not set, branch to leave
    X = X
    if (A != 0) {
        //> and #$0f                    ;mask out high nybble
        A = A and 0x0F
        //> pha                         ;push to stack
        push(A)
        //> tay                         ;put in Y for now
        Y = A
        //> txa
        A = X
        //> clc
        //> adc #$09                    ;add 9 bytes to offset (note two block objects are created
        temp0 = A + 0x09
        A = temp0 and 0xFF
        //> tax                         ;when using brick chunks, but only one offset for both)
        X = A
        //> dey                         ;decrement Y to check for solid block state
        Y = (Y - 1) and 0xFF
        //> beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
        Y = Y
        if (Y != 0) {
            //> jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
            imposeGravityBlock(X)
            //> jsr MoveObjectHorizontally  ;do another sub to move horizontally
            moveObjectHorizontally(X)
            //> txa
            A = X
            //> clc                         ;move onto next block object
            //> adc #$02
            temp1 = A + 0x02
            A = temp1 and 0xFF
            //> tax
            X = A
            //> jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
            imposeGravityBlock(X)
            //> jsr MoveObjectHorizontally  ;do another sub to move horizontally
            moveObjectHorizontally(X)
            //> ldx ObjectOffset            ;get block object offset used for both
            X = objectOffset
            //> jsr RelativeBlockPosition   ;get relative coordinates
            temp2 = relativeBlockPosition(X)
            X = temp2
            //> jsr GetBlockOffscreenBits   ;get offscreen information
            temp3 = getBlockOffscreenBits(temp2)
            X = temp3
            //> jsr DrawBrickChunks         ;draw the brick chunks
            drawBrickChunks(temp3)
            //> pla                         ;get lower nybble of saved state
            A = pull()
            //> ldy Block_Y_HighPos,x       ;check vertical high byte of block object
            Y = blockYHighpos[temp3]
            //> beq UpdSte                  ;if above the screen, branch to kill it
            X = temp3
            if (Y != 0) {
                //> pha                         ;otherwise save state back into stack
                push(A)
                //> lda #$f0
                A = 0xF0
                //> cmp Block_Y_Position+2,x    ;check to see if bottom block object went
                //> bcs ChkTop                  ;to the bottom of the screen, and branch if not
                if (!(A >= blockYPosition[2 + X])) {
                    //> sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
                    blockYPosition[2 + X] = A
                }
                //> ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
                A = blockYPosition[X]
                //> cmp #$f0                    ;see if it went to the bottom of the screen
                //> pla                         ;pull block object state from stack
                A = pull()
                //> bcc UpdSte                  ;if not, branch to save state
                if (A >= 0xF0) {
                    //> bcs KillBlock               ;otherwise do unconditional branch to kill it
                    if (!(A >= 0xF0)) {
                    }
                }
            }
        }
        //> BouncingBlockHandler:
        //> jsr ImposeGravityBlock     ;do sub to impose gravity on block object
        imposeGravityBlock(X)
        //> ldx ObjectOffset           ;get block object offset
        X = objectOffset
        //> jsr RelativeBlockPosition  ;get relative coordinates
        temp4 = relativeBlockPosition(X)
        X = temp4
        //> jsr GetBlockOffscreenBits  ;get offscreen information
        temp5 = getBlockOffscreenBits(temp4)
        X = temp5
        //> jsr DrawBlock              ;draw the block
        val pair0 = drawBlock(temp5)
        temp6 = pair0.first
        temp7 = pair0.second
        X = temp7
        //> lda Block_Y_Position,x     ;get vertical coordinate
        A = blockYPosition[temp5]
        //> and #$0f                   ;mask out high nybble
        A = A and 0x0F
        //> cmp #$05                   ;check to see if low nybble wrapped around
        //> pla                        ;pull state from stack
        A = pull()
        //> bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
        X = temp5
        Y = temp7
        if (!(A >= 0x05)) {
            //> lda #$01
            A = 0x01
            //> sta Block_RepFlag,x        ;otherwise set flag to replace metatile
            blockRepflag[X] = A
            //> KillBlock: lda #$00                   ;if branched here, nullify object state
            A = 0x00
        }
    }
    //> UpdSte:    sta Block_State,x          ;store contents of A in block object state
    blockState[X] = A
    //> rts
    return X
}

// Decompiled from BlockObjMT_Updater
fun blockobjmtUpdater() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var vramBuffer1 by MemoryByte(VRAM_Buffer1)
    val blockBbufLow by MemoryByteIndexed(Block_BBuf_Low)
    val blockMetatile by MemoryByteIndexed(Block_Metatile)
    val blockOrigYpos by MemoryByteIndexed(Block_Orig_YPos)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    //> BlockObjMT_Updater:
    //> ldx #$01                  ;set offset to start with second block object
    X = 0x01
    loop0@ do {
        //> UpdateLoop: stx ObjectOffset          ;set offset here
        objectOffset = X
        //> lda VRAM_Buffer1          ;if vram buffer already being used here,
        A = vramBuffer1
        //> bne NextBUpd              ;branch to move onto next block object
        if (A == 0) {
            //> lda Block_RepFlag,x       ;if flag for block object already clear,
            A = blockRepflag[X]
            //> beq NextBUpd              ;branch to move onto next block object
            if (A != 0) {
                //> lda Block_BBuf_Low,x      ;get low byte of block buffer
                A = blockBbufLow[X]
                //> sta $06                   ;store into block buffer address
                memory[0x6] = A.toUByte()
                //> lda #$05
                A = 0x05
                //> sta $07                   ;set high byte of block buffer address
                memory[0x7] = A.toUByte()
                //> lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
                A = blockOrigYpos[X]
                //> sta $02                   ;store here and use as offset to block buffer
                memory[0x2] = A.toUByte()
                //> tay
                Y = A
                //> lda Block_Metatile,x      ;get metatile to be written
                A = blockMetatile[X]
                //> sta ($06),y               ;write it to the block buffer
                memory[readWord(0x6) + Y] = A.toUByte()
                //> jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
                temp0 = replaceBlockMetatile(A, X)
                X = temp0
                //> lda #$00
                A = 0x00
                //> sta Block_RepFlag,x       ;clear block object flag
                blockRepflag[temp0] = A
            }
        }
        //> NextBUpd:   dex                       ;decrement block object offset
        X = (X - 1) and 0xFF
        //> bpl UpdateLoop            ;do this until both block objects are dealt with
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to UpdateLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> rts                       ;then leave
    return
}

// Decompiled from MoveEnemyHorizontally
fun moveEnemyHorizontally(A: Int, X: Int): Pair<Int, Int> {
    var X: Int = X
    var Y: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> MoveEnemyHorizontally:
    //> inx                         ;increment offset for enemy offset
    X = (X + 1) and 0xFF
    //> jsr MoveObjectHorizontally  ;position object horizontally according to
    moveObjectHorizontally(X)
    //> ldx ObjectOffset            ;counters, return with saved value in A,
    X = objectOffset
    //> rts                         ;put enemy offset back in X and leave
    return Pair(A, Y)
}

// Decompiled from MovePlayerHorizontally
fun movePlayerHorizontally(): Int {
    var A: Int = 0
    var X: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    //> MovePlayerHorizontally:
    //> lda JumpspringAnimCtrl  ;if jumpspring currently animating,
    A = jumpspringAnimCtrl
    //> bne ExXMove             ;branch to leave
    if (!(A == 0)) {
        //  goto ExXMove -> exXMove
        exXMove()
        return A
    } else {
        //> tax                     ;otherwise set zero for offset to use player's stuff
        X = A
        //  Fall-through tail call to moveObjectHorizontally
        moveObjectHorizontally(X)
        return A
    }
}

// Decompiled from MoveObjectHorizontally
fun moveObjectHorizontally(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXMoveforce by MemoryByteIndexed(SprObject_X_MoveForce)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val sprobjectXSpeed by MemoryByteIndexed(SprObject_X_Speed)
    //> MoveObjectHorizontally:
    //> lda SprObject_X_Speed,x     ;get currently saved value (horizontal
    A = sprobjectXSpeed[X]
    //> asl                         ;speed, secondary counter, whatever)
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                         ;and move low nybble to high
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> sta $01                     ;store result here
    memory[0x1] = A.toUByte()
    //> lda SprObject_X_Speed,x     ;get saved value again
    A = sprobjectXSpeed[X]
    //> lsr                         ;move high nybble to low
    val orig4: Int = A
    A = orig4 shr 1
    //> lsr
    val orig5: Int = A
    A = orig5 shr 1
    //> lsr
    val orig6: Int = A
    A = orig6 shr 1
    //> lsr
    val orig7: Int = A
    A = orig7 shr 1
    //> cmp #$08                    ;if < 8, branch, do not change
    //> bcc SaveXSpd
    X = X
    if (A >= 0x08) {
        //> ora #%11110000              ;otherwise alter high nybble
        A = A or 0xF0
    }
    //> SaveXSpd: sta $00                     ;save result here
    memory[0x0] = A.toUByte()
    //> ldy #$00                    ;load default Y value here
    Y = 0x00
    //> cmp #$00                    ;if result positive, leave Y alone
    //> bpl UseAdder
    if ((A and 0xFF and 0x80) != 0) {
        //> dey                         ;otherwise decrement Y
        Y = (Y - 1) and 0xFF
    }
    //> UseAdder: sty $02                     ;save Y here
    memory[0x2] = Y.toUByte()
    //> lda SprObject_X_MoveForce,x ;get whatever number's here
    A = sprobjectXMoveforce[X]
    //> clc
    //> adc $01                     ;add low nybble moved to high
    temp0 = A + memory[0x1].toInt()
    A = temp0 and 0xFF
    //> sta SprObject_X_MoveForce,x ;store result here
    sprobjectXMoveforce[X] = A
    //> lda #$00                    ;init A
    A = 0x00
    //> rol                         ;rotate carry into d0
    val orig8: Int = A
    A = (orig8 shl 1) and 0xFE or if (temp0 > 0xFF) 1 else 0
    //> pha                         ;push onto stack
    push(A)
    //> ror                         ;rotate d0 back onto carry
    val orig9: Int = A
    A = orig9 shr 1 or if ((orig8 and 0x80) != 0) 0x80 else 0
    //> lda SprObject_X_Position,x
    A = sprobjectXPosition[X]
    //> adc $00                     ;add carry plus saved value (high nybble moved to low
    temp1 = A + memory[0x0].toInt() + if ((orig9 and 0x01) != 0) 1 else 0
    A = temp1 and 0xFF
    //> sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
    sprobjectXPosition[X] = A
    //> lda SprObject_PageLoc,x
    A = sprobjectPageloc[X]
    //> adc $02                     ;add carry plus other saved value to the
    temp2 = A + memory[0x2].toInt() + if (temp1 > 0xFF) 1 else 0
    A = temp2 and 0xFF
    //> sta SprObject_PageLoc,x     ;object's page location and save
    sprobjectPageloc[X] = A
    //> pla
    A = pull()
    //> clc                         ;pull old carry from stack and add
    //> adc $00                     ;to high nybble moved to low
    temp3 = A + memory[0x0].toInt()
    A = temp3 and 0xFF
    //  Fall-through tail call to exXMove
    exXMove()
    return
}

// Decompiled from ExXMove
fun exXMove() {
    //> ExXMove:  rts                         ;and leave
    return
}

// Decompiled from MovePlayerVertically
fun movePlayerVertically() {
    var A: Int = 0
    var X: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var timerControl by MemoryByte(TimerControl)
    var verticalForce by MemoryByte(VerticalForce)
    //> MovePlayerVertically:
    //> ldx #$00                ;set X for player offset
    X = 0x00
    //> lda TimerControl
    A = timerControl
    //> bne NoJSChk             ;if master timer control set, branch ahead
    if (A == 0) {
        //> lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
        A = jumpspringAnimCtrl
        //> bne ExXMove             ;branch to leave if so
        if (A != 0) {
            //> ExXMove:  rts                         ;and leave
            return
        }
    }
    //> NoJSChk: lda VerticalForce       ;dump vertical force
    A = verticalForce
    //> sta $00
    memory[0x0] = A.toUByte()
    //> lda #$04                ;set maximum vertical speed here
    A = 0x04
    //> jmp ImposeGravitySprObj ;then jump to move player vertically
    imposeGravitySprObj(A, X)
    return
}

// Decompiled from MoveD_EnemyVertically
fun movedEnemyvertically(X: Int): Int {
    var A: Int = 0
    var Y: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> MoveD_EnemyVertically:
    //> ldy #$3d           ;set quick movement amount downwards
    Y = 0x3D
    //> lda Enemy_State,x  ;then check enemy state
    A = enemyState[X]
    //> cmp #$05           ;if not set to unique state for spiny's egg, go ahead
    //> bne ContVMove      ;and use, otherwise set different movement amount, continue on
    if (!(A == 0x05)) {
        //  goto ContVMove -> contVMove
        contVMove(X, Y)
        return X
    } else {
        //  Fall-through tail call to moveFallingPlatform
        return moveFallingPlatform(X)
    }
}

// Decompiled from MoveFallingPlatform
fun moveFallingPlatform(X: Int): Int {
    var Y: Int = 0
    //> MoveFallingPlatform:
    //> ldy #$20       ;set movement amount
    Y = 0x20
    //  Fall-through tail call to contVMove
    return contVMove(X, Y)
}

// Decompiled from ContVMove
fun contVMove(X: Int, Y: Int): Int {
    //> ContVMove: jmp SetHiMax   ;jump to skip the rest of this
    return setHiMax(X, Y)
}

// Decompiled from MoveRedPTroopaDown
fun moveRedPTroopaDown(X: Int) {
    var Y: Int = 0
    //> MoveRedPTroopaDown:
    //> ldy #$00            ;set Y to move downwards
    Y = 0x00
    //> jmp MoveRedPTroopa  ;skip to movement routine
    moveRedPTroopa(X, Y)
    return
}

// Decompiled from MoveRedPTroopaUp
fun moveRedPTroopaUp(X: Int) {
    var Y: Int = 0
    //> MoveRedPTroopaUp:
    //> ldy #$01            ;set Y to move upwards
    Y = 0x01
    //  Fall-through tail call to moveRedPTroopa
    moveRedPTroopa(X, Y)
    return
}

// Decompiled from MoveRedPTroopa
fun moveRedPTroopa(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    //> MoveRedPTroopa:
    //> inx                 ;increment X for enemy offset
    X = (X + 1) and 0xFF
    //> lda #$03
    A = 0x03
    //> sta $00             ;set downward movement amount here
    memory[0x0] = A.toUByte()
    //> lda #$06
    A = 0x06
    //> sta $01             ;set upward movement amount here
    memory[0x1] = A.toUByte()
    //> lda #$02
    A = 0x02
    //> sta $02             ;set maximum speed here
    memory[0x2] = A.toUByte()
    //> tya                 ;set movement direction in A, and
    A = Y
    //> jmp RedPTroopaGrav  ;jump to move this thing
    redPTroopaGrav(A, X)
    return
}

// Decompiled from MoveDropPlatform
fun moveDropPlatform(): Int {
    var Y: Int = 0
    //> MoveDropPlatform:
    //> ldy #$7f      ;set movement amount for drop platform
    Y = 0x7F
    //> bne SetMdMax  ;skip ahead of other value set here
    if (!(Y == 0)) {
        //  goto SetMdMax -> setMdMax
        setMdMax()
        return Y
    } else {
        //  Fall-through tail call to moveEnemySlowVert
        return moveEnemySlowVert()
    }
}

// Decompiled from MoveEnemySlowVert
fun moveEnemySlowVert(): Int {
    var Y: Int = 0
    //> MoveEnemySlowVert:
    //> ldy #$0f         ;set movement amount for bowser/other objects
    Y = 0x0F
    //  Fall-through tail call to setMdMax
    setMdMax()
    return Y
}

// Decompiled from SetMdMax
fun setMdMax() {
    var A: Int = 0
    //> SetMdMax: lda #$02         ;set maximum speed in A
    A = 0x02
    //> bne SetXMoveAmt  ;unconditional branch
    if (!(A == 0)) {
        //  goto SetXMoveAmt -> setXMoveAmt
        setXMoveAmt(A, 0, 0)
        return
    }
    //  Fall-through tail call to func_7643
    func_7643(0)
    return
}

// Decompiled from @7643
fun func_7643(X: Int): Int {
    //> ;--------------------------------
    //  Fall-through tail call to movejEnemyvertically
    return movejEnemyvertically(X)
}

// Decompiled from MoveJ_EnemyVertically
fun movejEnemyvertically(X: Int): Int {
    var Y: Int = 0
    //> MoveJ_EnemyVertically:
    //> ldy #$1c                ;set movement amount for podoboo/other objects
    Y = 0x1C
    //  Fall-through tail call to setHiMax
    return setHiMax(X, Y)
}

// Decompiled from SetHiMax
fun setHiMax(X: Int, Y: Int): Int {
    var A: Int = 0
    //> SetHiMax:    lda #$03                ;set maximum speed in A
    A = 0x03
    //  Fall-through tail call to setXMoveAmt
    return setXMoveAmt(A, X, Y)
}

// Decompiled from SetXMoveAmt
fun setXMoveAmt(A: Int, X: Int, Y: Int): Int {
    var X: Int = X
    var objectOffset by MemoryByte(ObjectOffset)
    //> SetXMoveAmt: sty $00                 ;set movement amount here
    memory[0x0] = Y.toUByte()
    //> inx                     ;increment X for enemy offset
    X = (X + 1) and 0xFF
    //> jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
    imposeGravitySprObj(A, X)
    //> ldx ObjectOffset        ;get enemy object buffer offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from ImposeGravityBlock
fun imposeGravityBlock(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    val maxSpdBlockData by MemoryByteIndexed(MaxSpdBlockData)
    //> ImposeGravityBlock:
    //> ldy #$01       ;set offset for maximum speed
    Y = 0x01
    //> lda #$50       ;set movement amount here
    A = 0x50
    //> sta $00
    memory[0x0] = A.toUByte()
    //> lda MaxSpdBlockData,y    ;get maximum speed
    A = maxSpdBlockData[Y]
    //  Fall-through tail call to imposeGravitySprObj
    imposeGravitySprObj(A, X)
    return
}

// Decompiled from ImposeGravitySprObj
fun imposeGravitySprObj(A: Int, X: Int) {
    var A: Int = A
    //> ImposeGravitySprObj:
    //> sta $02            ;set maximum speed here
    memory[0x2] = A.toUByte()
    //> lda #$00           ;set value to move downwards
    A = 0x00
    //> jmp ImposeGravity  ;jump to the code that actually moves it
    imposeGravity(A, X)
    return
}

// Decompiled from MovePlatformDown
fun movePlatformDown(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> MovePlatformDown:
    //> lda #$00    ;save value to stack (if branching here, execute next
    A = 0x00
    //> .db $2c     ;part as BIT instruction)
    //> MovePlatformUp:
    //> lda #$01        ;save value to stack
    //  (skipped by BIT $2C)
    //> pha
    push(A)
    //> ldy Enemy_ID,x  ;get enemy object identifier
    Y = enemyId[X]
    //> inx             ;increment offset for enemy object
    X = (X + 1) and 0xFF
    //> lda #$05        ;load default value here
    A = 0x05
    //> cpy #$29        ;residual comparison, object #29 never executes
    //> bne SetDplSpd   ;this code, thus unconditional branch here
    X = X
    if (Y == 0x29) {
        //> lda #$09        ;residual code
        A = 0x09
    }
    //> SetDplSpd: sta $00         ;save downward movement amount here
    memory[0x0] = A.toUByte()
    //> lda #$0a        ;save upward movement amount here
    A = 0x0A
    //> sta $01
    memory[0x1] = A.toUByte()
    //> lda #$03        ;save maximum vertical speed here
    A = 0x03
    //> sta $02
    memory[0x2] = A.toUByte()
    //> pla             ;get value from stack
    A = pull()
    //> tay             ;use as Y, then move onto code shared by red koopa
    Y = A
    //  Fall-through tail call to redPTroopaGrav
    redPTroopaGrav(A, X)
    return X
}

// Decompiled from MovePlatformUp
fun movePlatformUp() {
    // Fall-through tail call to movePlatformDown
    movePlatformDown(0)
    return
}

// Decompiled from RedPTroopaGrav
fun redPTroopaGrav(A: Int, X: Int) {
    var X: Int = X
    var objectOffset by MemoryByte(ObjectOffset)
    //> RedPTroopaGrav:
    //> jsr ImposeGravity  ;do a sub to move object gradually
    imposeGravity(A, X)
    //> ldx ObjectOffset   ;get enemy object offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from ImposeGravity
fun imposeGravity(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    val sprobjectYmfDummy by MemoryByteIndexed(SprObject_YMF_Dummy)
    val sprobjectYHighpos by MemoryByteIndexed(SprObject_Y_HighPos)
    val sprobjectYMoveforce by MemoryByteIndexed(SprObject_Y_MoveForce)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    val sprobjectYSpeed by MemoryByteIndexed(SprObject_Y_Speed)
    //> ImposeGravity:
    //> pha                          ;push value to stack
    push(A)
    //> lda SprObject_YMF_Dummy,x
    A = sprobjectYmfDummy[X]
    //> clc                          ;add value in movement force to contents of dummy variable
    //> adc SprObject_Y_MoveForce,x
    temp0 = A + sprobjectYMoveforce[X]
    A = temp0 and 0xFF
    //> sta SprObject_YMF_Dummy,x
    sprobjectYmfDummy[X] = A
    //> ldy #$00                     ;set Y to zero by default
    Y = 0x00
    //> lda SprObject_Y_Speed,x      ;get current vertical speed
    A = sprobjectYSpeed[X]
    //> bpl AlterYP                  ;if currently moving downwards, do not decrement Y
    X = X
    if ((A and 0x80) != 0) {
        //> dey                          ;otherwise decrement Y
        Y = (Y - 1) and 0xFF
    }
    //> AlterYP: sty $07                      ;store Y here
    memory[0x7] = Y.toUByte()
    //> adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
    temp1 = A + sprobjectYPosition[X] + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta SprObject_Y_Position,x   ;store as new vertical position
    sprobjectYPosition[X] = A
    //> lda SprObject_Y_HighPos,x
    A = sprobjectYHighpos[X]
    //> adc $07                      ;add carry plus contents of $07 to vertical high byte
    temp2 = A + memory[0x7].toInt() + if (temp1 > 0xFF) 1 else 0
    A = temp2 and 0xFF
    //> sta SprObject_Y_HighPos,x    ;store as new vertical high byte
    sprobjectYHighpos[X] = A
    //> lda SprObject_Y_MoveForce,x
    A = sprobjectYMoveforce[X]
    //> clc
    //> adc $00                      ;add downward movement amount to contents of $0433
    temp3 = A + memory[0x0].toInt()
    A = temp3 and 0xFF
    //> sta SprObject_Y_MoveForce,x
    sprobjectYMoveforce[X] = A
    //> lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
    A = sprobjectYSpeed[X]
    //> adc #$00
    temp4 = A + if (temp3 > 0xFF) 1 else 0
    A = temp4 and 0xFF
    //> sta SprObject_Y_Speed,x
    sprobjectYSpeed[X] = A
    //> cmp $02                      ;compare to maximum speed
    //> bmi ChkUpM                   ;if less than preset value, skip this part
    if (((A - memory[0x2].toInt()) and 0xFF and 0x80) == 0) {
        //> lda SprObject_Y_MoveForce,x
        A = sprobjectYMoveforce[X]
        //> cmp #$80                     ;if less positively than preset maximum, skip this part
        //> bcc ChkUpM
        if (A >= 0x80) {
            //> lda $02
            A = memory[0x2].toInt()
            //> sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
            sprobjectYSpeed[X] = A
            //> lda #$00
            A = 0x00
            //> sta SprObject_Y_MoveForce,x  ;clear fractional
            sprobjectYMoveforce[X] = A
        }
    }
    //> ChkUpM:  pla                          ;get value from stack
    A = pull()
    //> beq ExVMove                  ;if set to zero, branch to leave
    if (A != 0) {
        //> lda $02
        A = memory[0x2].toInt()
        //> eor #%11111111               ;otherwise get two's compliment of maximum speed
        A = A xor 0xFF
        //> tay
        Y = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> sty $07                      ;store two's compliment here
        memory[0x7] = Y.toUByte()
        //> lda SprObject_Y_MoveForce,x
        A = sprobjectYMoveforce[X]
        //> sec                          ;subtract upward movement amount from contents
        //> sbc $01                      ;of movement force, note that $01 is twice as large as $00,
        temp5 = A - memory[0x1].toInt()
        A = temp5 and 0xFF
        //> sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
        sprobjectYMoveforce[X] = A
        //> lda SprObject_Y_Speed,x
        A = sprobjectYSpeed[X]
        //> sbc #$00                     ;subtract borrow from vertical speed and store
        temp6 = A - if (temp5 >= 0) 0 else 1
        A = temp6 and 0xFF
        //> sta SprObject_Y_Speed,x
        sprobjectYSpeed[X] = A
        //> cmp $07                      ;compare vertical speed to two's compliment
        //> bpl ExVMove                  ;if less negatively than preset maximum, skip this part
        if (((A - memory[0x7].toInt()) and 0xFF and 0x80) != 0) {
            //> lda SprObject_Y_MoveForce,x
            A = sprobjectYMoveforce[X]
            //> cmp #$80                     ;check if fractional part is above certain amount,
            //> bcs ExVMove                  ;and if so, branch to leave
            if (!(A >= 0x80)) {
                //> lda $07
                A = memory[0x7].toInt()
                //> sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
                sprobjectYSpeed[X] = A
                //> lda #$ff
                A = 0xFF
                //> sta SprObject_Y_MoveForce,x  ;clear fractional
                sprobjectYMoveforce[X] = A
            }
        }
    }
    //> ExVMove: rts                          ;leave!
    return
}

// Decompiled from EnemiesAndLoopsCore
fun enemiesAndLoopsCore(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    //> EnemiesAndLoopsCore:
    //> lda Enemy_Flag,x         ;check data here for MSB set
    A = enemyFlag[X]
    //> pha                      ;save in stack
    push(A)
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
    X = X
    if ((orig0 and 0x80) == 0) {
        //> pla                      ;get from stack
        A = pull()
        //> beq ChkAreaTsk           ;if data zero, branch
        if (A != 0) {
            //> jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
            return runEnemyObjectsCore()
        }
        //> ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
        A = areaParserTaskNum
        //> and #$07
        A = A and 0x07
        //> cmp #$07                 ;if at a specific task, jump and leave
        //> beq ExitELCore
        if (A != 0x07) {
            //> jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
            return procLoopCommand(X)
        }
    }
    //> ChkBowserF: pla                      ;get data from stack
    A = pull()
    //> and #%00001111           ;mask out high nybble
    A = A and 0x0F
    //> tay
    Y = A
    //> lda Enemy_Flag,y         ;use as pointer and load same place with different offset
    A = enemyFlag[Y]
    //> bne ExitELCore
    Y = Y
    if (A == 0) {
        //> sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
        enemyFlag[X] = A
    }
    //> ExitELCore: rts
    return X
}

// Decompiled from ExecGameLoopback
fun execGameLoopback(Y: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageLoc by MemoryByte(AreaObjectPageLoc)
    var areaObjectPageSel by MemoryByte(AreaObjectPageSel)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    var enemyObjectPageLoc by MemoryByte(EnemyObjectPageLoc)
    var enemyObjectPageSel by MemoryByte(EnemyObjectPageSel)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    val areaDataOfsLoopback by MemoryByteIndexed(AreaDataOfsLoopback)
    //> ExecGameLoopback:
    //> lda Player_PageLoc        ;send player back four pages
    A = playerPageloc
    //> sec
    //> sbc #$04
    temp0 = A - 0x04
    A = temp0 and 0xFF
    //> sta Player_PageLoc
    playerPageloc = A
    //> lda CurrentPageLoc        ;send current page back four pages
    A = currentPageLoc
    //> sec
    //> sbc #$04
    temp1 = A - 0x04
    A = temp1 and 0xFF
    //> sta CurrentPageLoc
    currentPageLoc = A
    //> lda ScreenLeft_PageLoc    ;subtract four from page location
    A = screenleftPageloc
    //> sec                       ;of screen's left border
    //> sbc #$04
    temp2 = A - 0x04
    A = temp2 and 0xFF
    //> sta ScreenLeft_PageLoc
    screenleftPageloc = A
    //> lda ScreenRight_PageLoc   ;do the same for the page location
    A = screenrightPageloc
    //> sec                       ;of screen's right border
    //> sbc #$04
    temp3 = A - 0x04
    A = temp3 and 0xFF
    //> sta ScreenRight_PageLoc
    screenrightPageloc = A
    //> lda AreaObjectPageLoc     ;subtract four from page control
    A = areaObjectPageLoc
    //> sec                       ;for area objects
    //> sbc #$04
    temp4 = A - 0x04
    A = temp4 and 0xFF
    //> sta AreaObjectPageLoc
    areaObjectPageLoc = A
    //> lda #$00                  ;initialize page select for both
    A = 0x00
    //> sta EnemyObjectPageSel    ;area and enemy objects
    enemyObjectPageSel = A
    //> sta AreaObjectPageSel
    areaObjectPageSel = A
    //> sta EnemyDataOffset       ;initialize enemy object data offset
    enemyDataOffset = A
    //> sta EnemyObjectPageLoc    ;and enemy object page control
    enemyObjectPageLoc = A
    //> lda AreaDataOfsLoopback,y ;adjust area object offset based on
    A = areaDataOfsLoopback[Y]
    //> sta AreaDataOffset        ;which loop command we encountered
    areaDataOffset = A
    //> rts
    return
}

// Decompiled from ProcLoopCommand
fun procLoopCommand(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp16: Int = 0
    var temp17: Int = 0
    var temp18: Int = 0
    var temp19: Int = 0
    var temp2: Int = 0
    var temp20: Int = 0
    var temp21: Int = 0
    var temp22: Int = 0
    var temp23: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaPointer by MemoryByte(AreaPointer)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    var enemyFrenzyQueue by MemoryByte(EnemyFrenzyQueue)
    var enemyObjectPageLoc by MemoryByte(EnemyObjectPageLoc)
    var enemyObjectPageSel by MemoryByte(EnemyObjectPageSel)
    var entrancePage by MemoryByte(EntrancePage)
    var loopCommand by MemoryByte(LoopCommand)
    var multiLoopCorrectCntr by MemoryByte(MultiLoopCorrectCntr)
    var multiLoopPassCntr by MemoryByte(MultiLoopPassCntr)
    var playerState by MemoryByte(Player_State)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var worldNumber by MemoryByte(WorldNumber)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val loopCmdPageNumber by MemoryByteIndexed(LoopCmdPageNumber)
    val loopCmdWorldNumber by MemoryByteIndexed(LoopCmdWorldNumber)
    val loopCmdYPosition by MemoryByteIndexed(LoopCmdYPosition)
    //> ProcLoopCommand:
    //> lda LoopCommand           ;check if loop command was found
    A = loopCommand
    //> beq ChkEnemyFrenzy
    X = X
    if (A != 0) {
        //> lda CurrentColumnPos      ;check to see if we're still on the first page
        A = currentColumnPos
        //> bne ChkEnemyFrenzy        ;if not, do not loop yet
        if (A == 0) {
            //> ldy #$0b                  ;start at the end of each set of loop data
            Y = 0x0B
            loop0@ while ((Y and 0x80) == 0) {
                //> lda WorldNumber           ;check to see if one of the world numbers
                A = worldNumber
                //> cmp LoopCmdWorldNumber,y  ;matches our current world number
                //> bne FindLoop
                if (!(A == loopCmdWorldNumber[Y])) {
                    //  continue loop (branch back to FindLoop)
                    continue@loop0
                }
                //> lda CurrentPageLoc        ;check to see if one of the page numbers
                A = currentPageLoc
                //> cmp LoopCmdPageNumber,y   ;matches the page we're currently on
                //> bne FindLoop
                if (!(A == loopCmdPageNumber[Y])) {
                    //  continue loop (branch back to FindLoop)
                    continue@loop0
                }
            }
            //> lda Player_Y_Position     ;check to see if the player is at the correct position
            A = playerYPosition
            //> cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
            //> bne WrongChk
            if (A == loopCmdYPosition[Y]) {
                //> lda Player_State          ;check to see if the player is
                A = playerState
                //> cmp #$00                  ;on solid ground (i.e. not jumping or falling)
                //> bne WrongChk              ;if not, player fails to pass loop, and loopback
                if (A == 0x00) {
                    //> lda WorldNumber           ;are we in world 7? (check performed on correct
                    A = worldNumber
                    //> cmp #World7               ;vertical position and on solid ground)
                    //> bne InitMLp               ;if not, initialize flags used there, otherwise
                    if (A == World7) {
                        //> inc MultiLoopCorrectCntr  ;increment counter for correct progression
                        multiLoopCorrectCntr = (multiLoopCorrectCntr + 1) and 0xFF
                        //> IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
                        multiLoopPassCntr = (multiLoopPassCntr + 1) and 0xFF
                        //> lda MultiLoopPassCntr     ;have we done all three parts?
                        A = multiLoopPassCntr
                        //> cmp #$03
                        //> bne InitLCmd              ;if not, skip this part
                        if (A == 0x03) {
                            //> lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
                            A = multiLoopCorrectCntr
                            //> cmp #$03
                            //> beq InitMLp               ;if so, branch past unnecessary check here
                            if (A != 0x03) {
                                //> bne DoLpBack              ;unconditional branch if previous branch fails
                                if (!(A == 0x03)) {
                                    //  goto DoLpBack (internal forward branch)
                                    //> DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
                                    execGameLoopback(Y)
                                    //> jsr KillAllEnemies
                                    killAllEnemies(A)
                                    return X
                                }
                            }
                        }
                    }
                }
            }
            loop1@ do {
                //> IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
                multiLoopPassCntr = (multiLoopPassCntr + 1) and 0xFF
                //> lda MultiLoopPassCntr     ;have we done all three parts?
                A = multiLoopPassCntr
                //> cmp #$03
                //> bne InitLCmd              ;if not, skip this part
                if (!(A == 0x03)) {
                    //  goto InitLCmd (internal forward branch)
                    //> InitLCmd: lda #$00                  ;initialize loop command flag
                    A = 0x00
                    //> sta LoopCommand
                    loopCommand = A
                    //> ;--------------------------------
                    return X
                }
                //> lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
                A = multiLoopCorrectCntr
                //> cmp #$03
                //> beq InitMLp               ;if so, branch past unnecessary check here
                if (A == 0x03) {
                    //  goto InitMLp (internal forward branch)
                    //> InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
                    A = 0x00
                    //> sta MultiLoopPassCntr
                    multiLoopPassCntr = A
                    //> sta MultiLoopCorrectCntr
                    multiLoopCorrectCntr = A
                    return X
                }
                //> bne DoLpBack              ;unconditional branch if previous branch fails
                if (!(A == 0x03)) {
                    //  goto DoLpBack
                    break@loop1
                }
                //> WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
                A = worldNumber
                //> cmp #World7               ;incorrect vertical position or not on solid ground)
                //> beq IncMLoop
                if (A == World7) {
                    //  continue loop (branch back to IncMLoop)
                    continue@loop1
                }
            } while (A == World7)
            //> DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
            execGameLoopback(Y)
            //> jsr KillAllEnemies
            killAllEnemies(A)
        }
    }
    //> ChkEnemyFrenzy:
    //> lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
    A = enemyFrenzyQueue
    //> beq ProcessEnemyData  ;if not, skip this part
    if (A != 0) {
        //> sta Enemy_ID,x        ;store as enemy object identifier here
        enemyId[X] = A
        //> lda #$01
        A = 0x01
        //> sta Enemy_Flag,x      ;activate enemy object flag
        enemyFlag[X] = A
        //> lda #$00
        A = 0x00
        //> sta Enemy_State,x     ;initialize state and frenzy queue
        enemyState[X] = A
        //> sta EnemyFrenzyQueue
        enemyFrenzyQueue = A
        //> jmp InitEnemyObject   ;and then jump to deal with this enemy
        initEnemyObject(X)
        return X
    } else {
        //> ProcessEnemyData:
        //> ldy EnemyDataOffset      ;get offset of enemy object data
        Y = enemyDataOffset
        //> lda (EnemyData),y        ;load first byte
        A = memory[readWord(EnemyData) + Y].toInt()
        //> cmp #$ff                 ;check for EOD terminator
        //> bne CheckEndofBuffer
        if (A == 0xFF) {
            //> jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
            checkFrenzyBuffer(X)
            return X
        }
    }
    //> CheckEndofBuffer:
    //> and #%00001111           ;check for special row $0e
    A = A and 0x0F
    //> cmp #$0e
    //> beq CheckRightBounds     ;if found, branch, otherwise
    if (A != 0x0E) {
        //> cpx #$05                 ;check for end of buffer
        //> bcc CheckRightBounds     ;if not at end of buffer, branch
        if (X >= 0x05) {
            //> iny
            Y = (Y + 1) and 0xFF
            //> lda (EnemyData),y        ;check for specific value here
            A = memory[readWord(EnemyData) + Y].toInt()
            //> and #%00111111           ;not sure what this was intended for, exactly
            A = A and 0x3F
            //> cmp #$2e                 ;this part is quite possibly residual code
            //> beq CheckRightBounds     ;but it has the effect of keeping enemies out of
            if (A != 0x2E) {
                //> rts                      ;the sixth slot
                return X
            }
        }
    }
    //> CheckRightBounds:
    //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
    A = screenrightXPos
    //> clc
    //> adc #$30
    temp0 = A + 0x30
    A = temp0 and 0xFF
    //> and #%11110000           ;store high nybble
    A = A and 0xF0
    //> sta $07
    memory[0x7] = A.toUByte()
    //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
    A = screenrightPageloc
    //> adc #$00
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta $06                  ;store page location + carry
    memory[0x6] = A.toUByte()
    //> ldy EnemyDataOffset
    Y = enemyDataOffset
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
    A = memory[readWord(EnemyData) + Y].toInt()
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> bcc CheckPageCtrlRow
    if ((orig0 and 0x80) != 0) {
        //> lda EnemyObjectPageSel   ;if page select already set, do not set again
        A = enemyObjectPageSel
        //> bne CheckPageCtrlRow
        if (A == 0) {
            //> inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
            enemyObjectPageSel = (enemyObjectPageSel + 1) and 0xFF
            //> inc EnemyObjectPageLoc   ;and increment page control
            enemyObjectPageLoc = (enemyObjectPageLoc + 1) and 0xFF
        }
    }
    //> CheckPageCtrlRow:
    //> dey
    Y = (Y - 1) and 0xFF
    //> lda (EnemyData),y        ;reread first byte
    A = memory[readWord(EnemyData) + Y].toInt()
    //> and #$0f
    A = A and 0x0F
    //> cmp #$0f                 ;check for special row $0f
    //> bne PositionEnemyObj     ;if not found, branch to position enemy object
    if (A == 0x0F) {
        //> lda EnemyObjectPageSel   ;if page select set,
        A = enemyObjectPageSel
        //> bne PositionEnemyObj     ;branch without reading second byte
        if (A == 0) {
            loop2@ while (true) {
                //> FindLoop: dey
                Y = (Y - 1) and 0xFF
                //> bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
                if ((Y and 0x80) != 0) {
                    //  goto ChkEnemyFrenzy (internal forward branch)
                    //> ChkEnemyFrenzy:
                    //> lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
                    A = enemyFrenzyQueue
                    //> beq ProcessEnemyData  ;if not, skip this part
                    if (A == 0) {
                        //  goto ProcessEnemyData (internal forward branch)
                        //> ProcessEnemyData:
                        //> ldy EnemyDataOffset      ;get offset of enemy object data
                        Y = enemyDataOffset
                        //> lda (EnemyData),y        ;load first byte
                        A = memory[readWord(EnemyData) + Y].toInt()
                        //> cmp #$ff                 ;check for EOD terminator
                        //> bne CheckEndofBuffer
                        if (!(A == 0xFF)) {
                            //  goto CheckEndofBuffer (internal forward branch)
                            //> CheckEndofBuffer:
                            //> and #%00001111           ;check for special row $0e
                            A = A and 0x0F
                            //> cmp #$0e
                            //> beq CheckRightBounds     ;if found, branch, otherwise
                            if (A == 0x0E) {
                                //  goto CheckRightBounds (internal forward branch)
                                //> CheckRightBounds:
                                //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
                                A = screenrightXPos
                                //> clc
                                //> adc #$30
                                temp2 = A + 0x30
                                A = temp2 and 0xFF
                                //> and #%11110000           ;store high nybble
                                A = A and 0xF0
                                //> sta $07
                                memory[0x7] = A.toUByte()
                                //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
                                A = screenrightPageloc
                                //> adc #$00
                                temp3 = A + if (temp2 > 0xFF) 1 else 0
                                A = temp3 and 0xFF
                                //> sta $06                  ;store page location + carry
                                memory[0x6] = A.toUByte()
                                //> ldy EnemyDataOffset
                                Y = enemyDataOffset
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> asl
                                val orig1: Int = A
                                A = (orig1 shl 1) and 0xFF
                                //> bcc CheckPageCtrlRow
                                if (!((orig1 and 0x80) != 0)) {
                                    //  goto CheckPageCtrlRow (internal forward branch)
                                    //> CheckPageCtrlRow:
                                    //> dey
                                    Y = (Y - 1) and 0xFF
                                    //> lda (EnemyData),y        ;reread first byte
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #$0f
                                    A = A and 0x0F
                                    //> cmp #$0f                 ;check for special row $0f
                                    //> bne PositionEnemyObj     ;if not found, branch to position enemy object
                                    if (!(A == 0x0F)) {
                                        //  goto PositionEnemyObj (internal forward branch)
                                        //> PositionEnemyObj:
                                        //> lda EnemyObjectPageLoc   ;store page control as page location
                                        A = enemyObjectPageLoc
                                        //> sta Enemy_PageLoc,x      ;for enemy object
                                        enemyPageloc[X] = A
                                        //> lda (EnemyData),y        ;get first byte of enemy object
                                        A = memory[readWord(EnemyData) + Y].toInt()
                                        //> and #%11110000
                                        A = A and 0xF0
                                        //> sta Enemy_X_Position,x   ;store column position
                                        enemyXPosition[X] = A
                                        //> cmp ScreenRight_X_Pos    ;check column position against right boundary
                                        //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
                                        A = enemyPageloc[X]
                                        //> sbc ScreenRight_PageLoc  ;from page location
                                        temp4 = A - screenrightPageloc - if (A >= screenrightXPos) 0 else 1
                                        A = temp4 and 0xFF
                                        //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
                                        if (temp4 >= 0) {
                                            //  goto CheckRightExtBounds (internal forward branch)
                                            //> CheckRightExtBounds:
                                            //> lda $07                  ;check right boundary + 48 against
                                            A = memory[0x7].toInt()
                                            //> cmp Enemy_X_Position,x   ;column position without subtracting,
                                            //> lda $06                  ;then subtract borrow from page control temp
                                            A = memory[0x6].toInt()
                                            //> sbc Enemy_PageLoc,x      ;plus carry
                                            temp5 = A - enemyPageloc[X] - if (A >= enemyXPosition[X]) 0 else 1
                                            A = temp5 and 0xFF
                                            //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
                                            if (!(temp5 >= 0)) {
                                                //  goto CheckFrenzyBuffer -> checkFrenzyBuffer
                                                checkFrenzyBuffer(X)
                                                return X
                                            }
                                            //> lda #$01                 ;store value in vertical high byte
                                            A = 0x01
                                            //> sta Enemy_Y_HighPos,x
                                            enemyYHighpos[X] = A
                                            //> lda (EnemyData),y        ;get first byte again
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> asl                      ;multiply by four to get the vertical
                                            val orig2: Int = A
                                            A = (orig2 shl 1) and 0xFF
                                            //> asl                      ;coordinate
                                            val orig3: Int = A
                                            A = (orig3 shl 1) and 0xFF
                                            //> asl
                                            val orig4: Int = A
                                            A = (orig4 shl 1) and 0xFF
                                            //> asl
                                            val orig5: Int = A
                                            A = (orig5 shl 1) and 0xFF
                                            //> sta Enemy_Y_Position,x
                                            enemyYPosition[X] = A
                                            //> cmp #$e0                 ;do one last check for special row $0e
                                            //> beq ParseRow0e           ;(necessary if branched to $c1cb)
                                            if (A == 0xE0) {
                                                //  goto ParseRow0e (internal forward branch)
                                                //> ParseRow0e:
                                                //> iny                      ;increment Y to load third byte of object
                                                Y = (Y + 1) and 0xFF
                                                //> iny
                                                Y = (Y + 1) and 0xFF
                                                //> lda (EnemyData),y
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> lsr                      ;move 3 MSB to the bottom, effectively
                                                val orig6: Int = A
                                                A = orig6 shr 1
                                                //> lsr                      ;making %xxx00000 into %00000xxx
                                                val orig7: Int = A
                                                A = orig7 shr 1
                                                //> lsr
                                                val orig8: Int = A
                                                A = orig8 shr 1
                                                //> lsr
                                                val orig9: Int = A
                                                A = orig9 shr 1
                                                //> lsr
                                                val orig10: Int = A
                                                A = orig10 shr 1
                                                //> cmp WorldNumber          ;is it the same world number as we're on?
                                                //> bne NotUse               ;if not, do not use (this allows multiple uses
                                                if (!(A == worldNumber)) {
                                                    //  goto NotUse (internal forward branch)
                                                    //> NotUse: jmp Inc3B
                                                    return inc3B()
                                                }
                                                //> dey                      ;of the same area, like the underground bonus areas)
                                                Y = (Y - 1) and 0xFF
                                                //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> sta AreaPointer          ;to addresses for level and enemy object data
                                                areaPointer = A
                                                //> iny
                                                Y = (Y + 1) and 0xFF
                                                //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                                A = A and 0x1F
                                                //> sta EntrancePage         ;used upon entry to area, if area is entered
                                                entrancePage = A
                                                return X
                                            }
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y        ;get second byte of object
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> and #%01000000           ;check to see if hard mode bit is set
                                            A = A and 0x40
                                            //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
                                            if (A == 0) {
                                                //  goto CheckForEnemyGroup (internal forward branch)
                                                //> CheckForEnemyGroup:
                                                //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> and #%00111111
                                                A = A and 0x3F
                                                //> cmp #$37               ;check for value below $37
                                                //> bcc BuzzyBeetleMutate
                                                if (!(A >= 0x37)) {
                                                    //  goto BuzzyBeetleMutate (internal forward branch)
                                                    //> BuzzyBeetleMutate:
                                                    //> cmp #Goomba          ;if below $37, check for goomba
                                                    //> bne StrID            ;value ($3f or more always fails)
                                                    if (!(A == Goomba)) {
                                                        //  goto StrID (internal forward branch)
                                                        //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                                        enemyId[X] = A
                                                        //> lda #$01
                                                        A = 0x01
                                                        //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                                        enemyFlag[X] = A
                                                        //> jsr InitEnemyObject
                                                        initEnemyObject(X)
                                                        //> lda Enemy_Flag,x     ;check to see if flag is set
                                                        A = enemyFlag[X]
                                                        //> bne Inc2B            ;if not, leave, otherwise branch
                                                        if (!(A == 0)) {
                                                            //  goto Inc2B -> inc2B
                                                            inc2B()
                                                            return X
                                                        }
                                                        //> rts
                                                        return X
                                                    }
                                                    //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                                                    Y = primaryHardMode
                                                    //> beq StrID            ;and if so, change goomba to buzzy beetle
                                                    if (Y == 0) {
                                                        //  goto StrID (internal forward branch)
                                                        //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                                        enemyId[X] = A
                                                        //> lda #$01
                                                        A = 0x01
                                                        //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                                        enemyFlag[X] = A
                                                        //> jsr InitEnemyObject
                                                        initEnemyObject(X)
                                                        //> lda Enemy_Flag,x     ;check to see if flag is set
                                                        A = enemyFlag[X]
                                                        //> bne Inc2B            ;if not, leave, otherwise branch
                                                        if (!(A == 0)) {
                                                            //  goto Inc2B -> inc2B
                                                            inc2B()
                                                            return X
                                                        }
                                                        //> rts
                                                        return X
                                                    }
                                                    //> lda #BuzzyBeetle
                                                    A = BuzzyBeetle
                                                    return X
                                                }
                                                //> cmp #$3f               ;if $37 or greater, check for value
                                                //> bcc DoGroup            ;below $3f, branch if below $3f
                                                if (!(A >= 0x3F)) {
                                                    //  goto DoGroup (internal forward branch)
                                                    //> DoGroup:
                                                    //> jmp HandleGroupEnemies   ;handle enemy group objects
                                                    return handleGroupEnemies(A)
                                                }
                                                return X
                                            }
                                            //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                                            A = secondaryHardMode
                                            //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                                            if (A == 0) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            return X
                                        }
                                        //> lda (EnemyData),y
                                        A = memory[readWord(EnemyData) + Y].toInt()
                                        //> and #%00001111           ;check for special row $0e
                                        A = A and 0x0F
                                        //> cmp #$0e                 ;if found, jump elsewhere
                                        //> beq ParseRow0e
                                        if (A == 0x0E) {
                                            //  goto ParseRow0e (internal forward branch)
                                            //> ParseRow0e:
                                            //> iny                      ;increment Y to load third byte of object
                                            Y = (Y + 1) and 0xFF
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> lsr                      ;move 3 MSB to the bottom, effectively
                                            val orig11: Int = A
                                            A = orig11 shr 1
                                            //> lsr                      ;making %xxx00000 into %00000xxx
                                            val orig12: Int = A
                                            A = orig12 shr 1
                                            //> lsr
                                            val orig13: Int = A
                                            A = orig13 shr 1
                                            //> lsr
                                            val orig14: Int = A
                                            A = orig14 shr 1
                                            //> lsr
                                            val orig15: Int = A
                                            A = orig15 shr 1
                                            //> cmp WorldNumber          ;is it the same world number as we're on?
                                            //> bne NotUse               ;if not, do not use (this allows multiple uses
                                            if (!(A == worldNumber)) {
                                                //  goto NotUse (internal forward branch)
                                                //> NotUse: jmp Inc3B
                                                return inc3B()
                                            }
                                            //> dey                      ;of the same area, like the underground bonus areas)
                                            Y = (Y - 1) and 0xFF
                                            //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> sta AreaPointer          ;to addresses for level and enemy object data
                                            areaPointer = A
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                            A = A and 0x1F
                                            //> sta EntrancePage         ;used upon entry to area, if area is entered
                                            entrancePage = A
                                            return X
                                        }
                                        //> jmp CheckThreeBytes      ;if not found, unconditional jump
                                        return checkThreeBytes()
                                    }
                                    return X
                                }
                                return X
                            }
                            //> cpx #$05                 ;check for end of buffer
                            //> bcc CheckRightBounds     ;if not at end of buffer, branch
                            if (!(X >= 0x05)) {
                                //  goto CheckRightBounds (internal forward branch)
                                //> CheckRightBounds:
                                //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
                                A = screenrightXPos
                                //> clc
                                //> adc #$30
                                temp6 = A + 0x30
                                A = temp6 and 0xFF
                                //> and #%11110000           ;store high nybble
                                A = A and 0xF0
                                //> sta $07
                                memory[0x7] = A.toUByte()
                                //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
                                A = screenrightPageloc
                                //> adc #$00
                                temp7 = A + if (temp6 > 0xFF) 1 else 0
                                A = temp7 and 0xFF
                                //> sta $06                  ;store page location + carry
                                memory[0x6] = A.toUByte()
                                //> ldy EnemyDataOffset
                                Y = enemyDataOffset
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> asl
                                val orig16: Int = A
                                A = (orig16 shl 1) and 0xFF
                                //> bcc CheckPageCtrlRow
                                if (!((orig16 and 0x80) != 0)) {
                                    //  goto CheckPageCtrlRow (internal forward branch)
                                    //> CheckPageCtrlRow:
                                    //> dey
                                    Y = (Y - 1) and 0xFF
                                    //> lda (EnemyData),y        ;reread first byte
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #$0f
                                    A = A and 0x0F
                                    //> cmp #$0f                 ;check for special row $0f
                                    //> bne PositionEnemyObj     ;if not found, branch to position enemy object
                                    if (!(A == 0x0F)) {
                                        //  goto PositionEnemyObj (internal forward branch)
                                        //> PositionEnemyObj:
                                        //> lda EnemyObjectPageLoc   ;store page control as page location
                                        A = enemyObjectPageLoc
                                        //> sta Enemy_PageLoc,x      ;for enemy object
                                        enemyPageloc[X] = A
                                        //> lda (EnemyData),y        ;get first byte of enemy object
                                        A = memory[readWord(EnemyData) + Y].toInt()
                                        //> and #%11110000
                                        A = A and 0xF0
                                        //> sta Enemy_X_Position,x   ;store column position
                                        enemyXPosition[X] = A
                                        //> cmp ScreenRight_X_Pos    ;check column position against right boundary
                                        //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
                                        A = enemyPageloc[X]
                                        //> sbc ScreenRight_PageLoc  ;from page location
                                        temp8 = A - screenrightPageloc - if (A >= screenrightXPos) 0 else 1
                                        A = temp8 and 0xFF
                                        //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
                                        if (temp8 >= 0) {
                                            //  goto CheckRightExtBounds (internal forward branch)
                                            //> CheckRightExtBounds:
                                            //> lda $07                  ;check right boundary + 48 against
                                            A = memory[0x7].toInt()
                                            //> cmp Enemy_X_Position,x   ;column position without subtracting,
                                            //> lda $06                  ;then subtract borrow from page control temp
                                            A = memory[0x6].toInt()
                                            //> sbc Enemy_PageLoc,x      ;plus carry
                                            temp9 = A - enemyPageloc[X] - if (A >= enemyXPosition[X]) 0 else 1
                                            A = temp9 and 0xFF
                                            //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
                                            if (!(temp9 >= 0)) {
                                                //  goto CheckFrenzyBuffer -> checkFrenzyBuffer
                                                checkFrenzyBuffer(X)
                                                return X
                                            }
                                            //> lda #$01                 ;store value in vertical high byte
                                            A = 0x01
                                            //> sta Enemy_Y_HighPos,x
                                            enemyYHighpos[X] = A
                                            //> lda (EnemyData),y        ;get first byte again
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> asl                      ;multiply by four to get the vertical
                                            val orig17: Int = A
                                            A = (orig17 shl 1) and 0xFF
                                            //> asl                      ;coordinate
                                            val orig18: Int = A
                                            A = (orig18 shl 1) and 0xFF
                                            //> asl
                                            val orig19: Int = A
                                            A = (orig19 shl 1) and 0xFF
                                            //> asl
                                            val orig20: Int = A
                                            A = (orig20 shl 1) and 0xFF
                                            //> sta Enemy_Y_Position,x
                                            enemyYPosition[X] = A
                                            //> cmp #$e0                 ;do one last check for special row $0e
                                            //> beq ParseRow0e           ;(necessary if branched to $c1cb)
                                            if (A == 0xE0) {
                                                //  goto ParseRow0e (internal forward branch)
                                                //> ParseRow0e:
                                                //> iny                      ;increment Y to load third byte of object
                                                Y = (Y + 1) and 0xFF
                                                //> iny
                                                Y = (Y + 1) and 0xFF
                                                //> lda (EnemyData),y
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> lsr                      ;move 3 MSB to the bottom, effectively
                                                val orig21: Int = A
                                                A = orig21 shr 1
                                                //> lsr                      ;making %xxx00000 into %00000xxx
                                                val orig22: Int = A
                                                A = orig22 shr 1
                                                //> lsr
                                                val orig23: Int = A
                                                A = orig23 shr 1
                                                //> lsr
                                                val orig24: Int = A
                                                A = orig24 shr 1
                                                //> lsr
                                                val orig25: Int = A
                                                A = orig25 shr 1
                                                //> cmp WorldNumber          ;is it the same world number as we're on?
                                                //> bne NotUse               ;if not, do not use (this allows multiple uses
                                                if (!(A == worldNumber)) {
                                                    //  goto NotUse (internal forward branch)
                                                    //> NotUse: jmp Inc3B
                                                    return inc3B()
                                                }
                                                //> dey                      ;of the same area, like the underground bonus areas)
                                                Y = (Y - 1) and 0xFF
                                                //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> sta AreaPointer          ;to addresses for level and enemy object data
                                                areaPointer = A
                                                //> iny
                                                Y = (Y + 1) and 0xFF
                                                //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                                A = A and 0x1F
                                                //> sta EntrancePage         ;used upon entry to area, if area is entered
                                                entrancePage = A
                                                return X
                                            }
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y        ;get second byte of object
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> and #%01000000           ;check to see if hard mode bit is set
                                            A = A and 0x40
                                            //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
                                            if (A == 0) {
                                                //  goto CheckForEnemyGroup (internal forward branch)
                                                //> CheckForEnemyGroup:
                                                //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> and #%00111111
                                                A = A and 0x3F
                                                //> cmp #$37               ;check for value below $37
                                                //> bcc BuzzyBeetleMutate
                                                if (!(A >= 0x37)) {
                                                    //  goto BuzzyBeetleMutate (internal forward branch)
                                                    //> BuzzyBeetleMutate:
                                                    //> cmp #Goomba          ;if below $37, check for goomba
                                                    //> bne StrID            ;value ($3f or more always fails)
                                                    if (!(A == Goomba)) {
                                                        //  goto StrID (internal forward branch)
                                                        //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                                        enemyId[X] = A
                                                        //> lda #$01
                                                        A = 0x01
                                                        //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                                        enemyFlag[X] = A
                                                        //> jsr InitEnemyObject
                                                        initEnemyObject(X)
                                                        //> lda Enemy_Flag,x     ;check to see if flag is set
                                                        A = enemyFlag[X]
                                                        //> bne Inc2B            ;if not, leave, otherwise branch
                                                        if (!(A == 0)) {
                                                            //  goto Inc2B -> inc2B
                                                            inc2B()
                                                            return X
                                                        }
                                                        //> rts
                                                        return X
                                                    }
                                                    //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                                                    Y = primaryHardMode
                                                    //> beq StrID            ;and if so, change goomba to buzzy beetle
                                                    if (Y == 0) {
                                                        //  goto StrID (internal forward branch)
                                                        //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                                        enemyId[X] = A
                                                        //> lda #$01
                                                        A = 0x01
                                                        //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                                        enemyFlag[X] = A
                                                        //> jsr InitEnemyObject
                                                        initEnemyObject(X)
                                                        //> lda Enemy_Flag,x     ;check to see if flag is set
                                                        A = enemyFlag[X]
                                                        //> bne Inc2B            ;if not, leave, otherwise branch
                                                        if (!(A == 0)) {
                                                            //  goto Inc2B -> inc2B
                                                            inc2B()
                                                            return X
                                                        }
                                                        //> rts
                                                        return X
                                                    }
                                                    //> lda #BuzzyBeetle
                                                    A = BuzzyBeetle
                                                    return X
                                                }
                                                //> cmp #$3f               ;if $37 or greater, check for value
                                                //> bcc DoGroup            ;below $3f, branch if below $3f
                                                if (!(A >= 0x3F)) {
                                                    //  goto DoGroup (internal forward branch)
                                                    //> DoGroup:
                                                    //> jmp HandleGroupEnemies   ;handle enemy group objects
                                                    return handleGroupEnemies(A)
                                                }
                                                return X
                                            }
                                            //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                                            A = secondaryHardMode
                                            //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                                            if (A == 0) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            return X
                                        }
                                        //> lda (EnemyData),y
                                        A = memory[readWord(EnemyData) + Y].toInt()
                                        //> and #%00001111           ;check for special row $0e
                                        A = A and 0x0F
                                        //> cmp #$0e                 ;if found, jump elsewhere
                                        //> beq ParseRow0e
                                        if (A == 0x0E) {
                                            //  goto ParseRow0e (internal forward branch)
                                            //> ParseRow0e:
                                            //> iny                      ;increment Y to load third byte of object
                                            Y = (Y + 1) and 0xFF
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> lsr                      ;move 3 MSB to the bottom, effectively
                                            val orig26: Int = A
                                            A = orig26 shr 1
                                            //> lsr                      ;making %xxx00000 into %00000xxx
                                            val orig27: Int = A
                                            A = orig27 shr 1
                                            //> lsr
                                            val orig28: Int = A
                                            A = orig28 shr 1
                                            //> lsr
                                            val orig29: Int = A
                                            A = orig29 shr 1
                                            //> lsr
                                            val orig30: Int = A
                                            A = orig30 shr 1
                                            //> cmp WorldNumber          ;is it the same world number as we're on?
                                            //> bne NotUse               ;if not, do not use (this allows multiple uses
                                            if (!(A == worldNumber)) {
                                                //  goto NotUse (internal forward branch)
                                                //> NotUse: jmp Inc3B
                                                return inc3B()
                                            }
                                            //> dey                      ;of the same area, like the underground bonus areas)
                                            Y = (Y - 1) and 0xFF
                                            //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> sta AreaPointer          ;to addresses for level and enemy object data
                                            areaPointer = A
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                            A = A and 0x1F
                                            //> sta EntrancePage         ;used upon entry to area, if area is entered
                                            entrancePage = A
                                            return X
                                        }
                                        //> jmp CheckThreeBytes      ;if not found, unconditional jump
                                        return checkThreeBytes()
                                    }
                                    return X
                                }
                                return X
                            }
                            //> iny
                            Y = (Y + 1) and 0xFF
                            //> lda (EnemyData),y        ;check for specific value here
                            A = memory[readWord(EnemyData) + Y].toInt()
                            //> and #%00111111           ;not sure what this was intended for, exactly
                            A = A and 0x3F
                            //> cmp #$2e                 ;this part is quite possibly residual code
                            //> beq CheckRightBounds     ;but it has the effect of keeping enemies out of
                            if (A == 0x2E) {
                                //  goto CheckRightBounds (internal forward branch)
                                //> CheckRightBounds:
                                //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
                                A = screenrightXPos
                                //> clc
                                //> adc #$30
                                temp10 = A + 0x30
                                A = temp10 and 0xFF
                                //> and #%11110000           ;store high nybble
                                A = A and 0xF0
                                //> sta $07
                                memory[0x7] = A.toUByte()
                                //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
                                A = screenrightPageloc
                                //> adc #$00
                                temp11 = A + if (temp10 > 0xFF) 1 else 0
                                A = temp11 and 0xFF
                                //> sta $06                  ;store page location + carry
                                memory[0x6] = A.toUByte()
                                //> ldy EnemyDataOffset
                                Y = enemyDataOffset
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> asl
                                val orig31: Int = A
                                A = (orig31 shl 1) and 0xFF
                                //> bcc CheckPageCtrlRow
                                if (!((orig31 and 0x80) != 0)) {
                                    //  goto CheckPageCtrlRow (internal forward branch)
                                    //> CheckPageCtrlRow:
                                    //> dey
                                    Y = (Y - 1) and 0xFF
                                    //> lda (EnemyData),y        ;reread first byte
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #$0f
                                    A = A and 0x0F
                                    //> cmp #$0f                 ;check for special row $0f
                                    //> bne PositionEnemyObj     ;if not found, branch to position enemy object
                                    if (!(A == 0x0F)) {
                                        //  goto PositionEnemyObj (internal forward branch)
                                        //> PositionEnemyObj:
                                        //> lda EnemyObjectPageLoc   ;store page control as page location
                                        A = enemyObjectPageLoc
                                        //> sta Enemy_PageLoc,x      ;for enemy object
                                        enemyPageloc[X] = A
                                        //> lda (EnemyData),y        ;get first byte of enemy object
                                        A = memory[readWord(EnemyData) + Y].toInt()
                                        //> and #%11110000
                                        A = A and 0xF0
                                        //> sta Enemy_X_Position,x   ;store column position
                                        enemyXPosition[X] = A
                                        //> cmp ScreenRight_X_Pos    ;check column position against right boundary
                                        //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
                                        A = enemyPageloc[X]
                                        //> sbc ScreenRight_PageLoc  ;from page location
                                        temp12 = A - screenrightPageloc - if (A >= screenrightXPos) 0 else 1
                                        A = temp12 and 0xFF
                                        //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
                                        if (temp12 >= 0) {
                                            //  goto CheckRightExtBounds (internal forward branch)
                                            //> CheckRightExtBounds:
                                            //> lda $07                  ;check right boundary + 48 against
                                            A = memory[0x7].toInt()
                                            //> cmp Enemy_X_Position,x   ;column position without subtracting,
                                            //> lda $06                  ;then subtract borrow from page control temp
                                            A = memory[0x6].toInt()
                                            //> sbc Enemy_PageLoc,x      ;plus carry
                                            temp13 = A - enemyPageloc[X] - if (A >= enemyXPosition[X]) 0 else 1
                                            A = temp13 and 0xFF
                                            //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
                                            if (!(temp13 >= 0)) {
                                                //  goto CheckFrenzyBuffer -> checkFrenzyBuffer
                                                checkFrenzyBuffer(X)
                                                return X
                                            }
                                            //> lda #$01                 ;store value in vertical high byte
                                            A = 0x01
                                            //> sta Enemy_Y_HighPos,x
                                            enemyYHighpos[X] = A
                                            //> lda (EnemyData),y        ;get first byte again
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> asl                      ;multiply by four to get the vertical
                                            val orig32: Int = A
                                            A = (orig32 shl 1) and 0xFF
                                            //> asl                      ;coordinate
                                            val orig33: Int = A
                                            A = (orig33 shl 1) and 0xFF
                                            //> asl
                                            val orig34: Int = A
                                            A = (orig34 shl 1) and 0xFF
                                            //> asl
                                            val orig35: Int = A
                                            A = (orig35 shl 1) and 0xFF
                                            //> sta Enemy_Y_Position,x
                                            enemyYPosition[X] = A
                                            //> cmp #$e0                 ;do one last check for special row $0e
                                            //> beq ParseRow0e           ;(necessary if branched to $c1cb)
                                            if (A == 0xE0) {
                                                //  goto ParseRow0e (internal forward branch)
                                                //> ParseRow0e:
                                                //> iny                      ;increment Y to load third byte of object
                                                Y = (Y + 1) and 0xFF
                                                //> iny
                                                Y = (Y + 1) and 0xFF
                                                //> lda (EnemyData),y
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> lsr                      ;move 3 MSB to the bottom, effectively
                                                val orig36: Int = A
                                                A = orig36 shr 1
                                                //> lsr                      ;making %xxx00000 into %00000xxx
                                                val orig37: Int = A
                                                A = orig37 shr 1
                                                //> lsr
                                                val orig38: Int = A
                                                A = orig38 shr 1
                                                //> lsr
                                                val orig39: Int = A
                                                A = orig39 shr 1
                                                //> lsr
                                                val orig40: Int = A
                                                A = orig40 shr 1
                                                //> cmp WorldNumber          ;is it the same world number as we're on?
                                                //> bne NotUse               ;if not, do not use (this allows multiple uses
                                                if (!(A == worldNumber)) {
                                                    //  goto NotUse (internal forward branch)
                                                    //> NotUse: jmp Inc3B
                                                    return inc3B()
                                                }
                                                //> dey                      ;of the same area, like the underground bonus areas)
                                                Y = (Y - 1) and 0xFF
                                                //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> sta AreaPointer          ;to addresses for level and enemy object data
                                                areaPointer = A
                                                //> iny
                                                Y = (Y + 1) and 0xFF
                                                //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                                A = A and 0x1F
                                                //> sta EntrancePage         ;used upon entry to area, if area is entered
                                                entrancePage = A
                                                return X
                                            }
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y        ;get second byte of object
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> and #%01000000           ;check to see if hard mode bit is set
                                            A = A and 0x40
                                            //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
                                            if (A == 0) {
                                                //  goto CheckForEnemyGroup (internal forward branch)
                                                //> CheckForEnemyGroup:
                                                //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
                                                A = memory[readWord(EnemyData) + Y].toInt()
                                                //> and #%00111111
                                                A = A and 0x3F
                                                //> cmp #$37               ;check for value below $37
                                                //> bcc BuzzyBeetleMutate
                                                if (!(A >= 0x37)) {
                                                    //  goto BuzzyBeetleMutate (internal forward branch)
                                                    //> BuzzyBeetleMutate:
                                                    //> cmp #Goomba          ;if below $37, check for goomba
                                                    //> bne StrID            ;value ($3f or more always fails)
                                                    if (!(A == Goomba)) {
                                                        //  goto StrID (internal forward branch)
                                                        //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                                        enemyId[X] = A
                                                        //> lda #$01
                                                        A = 0x01
                                                        //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                                        enemyFlag[X] = A
                                                        //> jsr InitEnemyObject
                                                        initEnemyObject(X)
                                                        //> lda Enemy_Flag,x     ;check to see if flag is set
                                                        A = enemyFlag[X]
                                                        //> bne Inc2B            ;if not, leave, otherwise branch
                                                        if (!(A == 0)) {
                                                            //  goto Inc2B -> inc2B
                                                            inc2B()
                                                            return X
                                                        }
                                                        //> rts
                                                        return X
                                                    }
                                                    //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                                                    Y = primaryHardMode
                                                    //> beq StrID            ;and if so, change goomba to buzzy beetle
                                                    if (Y == 0) {
                                                        //  goto StrID (internal forward branch)
                                                        //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                                        enemyId[X] = A
                                                        //> lda #$01
                                                        A = 0x01
                                                        //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                                        enemyFlag[X] = A
                                                        //> jsr InitEnemyObject
                                                        initEnemyObject(X)
                                                        //> lda Enemy_Flag,x     ;check to see if flag is set
                                                        A = enemyFlag[X]
                                                        //> bne Inc2B            ;if not, leave, otherwise branch
                                                        if (!(A == 0)) {
                                                            //  goto Inc2B -> inc2B
                                                            inc2B()
                                                            return X
                                                        }
                                                        //> rts
                                                        return X
                                                    }
                                                    //> lda #BuzzyBeetle
                                                    A = BuzzyBeetle
                                                    return X
                                                }
                                                //> cmp #$3f               ;if $37 or greater, check for value
                                                //> bcc DoGroup            ;below $3f, branch if below $3f
                                                if (!(A >= 0x3F)) {
                                                    //  goto DoGroup (internal forward branch)
                                                    //> DoGroup:
                                                    //> jmp HandleGroupEnemies   ;handle enemy group objects
                                                    return handleGroupEnemies(A)
                                                }
                                                return X
                                            }
                                            //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                                            A = secondaryHardMode
                                            //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                                            if (A == 0) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            return X
                                        }
                                        //> lda (EnemyData),y
                                        A = memory[readWord(EnemyData) + Y].toInt()
                                        //> and #%00001111           ;check for special row $0e
                                        A = A and 0x0F
                                        //> cmp #$0e                 ;if found, jump elsewhere
                                        //> beq ParseRow0e
                                        if (A == 0x0E) {
                                            //  goto ParseRow0e (internal forward branch)
                                            //> ParseRow0e:
                                            //> iny                      ;increment Y to load third byte of object
                                            Y = (Y + 1) and 0xFF
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> lsr                      ;move 3 MSB to the bottom, effectively
                                            val orig41: Int = A
                                            A = orig41 shr 1
                                            //> lsr                      ;making %xxx00000 into %00000xxx
                                            val orig42: Int = A
                                            A = orig42 shr 1
                                            //> lsr
                                            val orig43: Int = A
                                            A = orig43 shr 1
                                            //> lsr
                                            val orig44: Int = A
                                            A = orig44 shr 1
                                            //> lsr
                                            val orig45: Int = A
                                            A = orig45 shr 1
                                            //> cmp WorldNumber          ;is it the same world number as we're on?
                                            //> bne NotUse               ;if not, do not use (this allows multiple uses
                                            if (!(A == worldNumber)) {
                                                //  goto NotUse (internal forward branch)
                                                //> NotUse: jmp Inc3B
                                                return inc3B()
                                            }
                                            //> dey                      ;of the same area, like the underground bonus areas)
                                            Y = (Y - 1) and 0xFF
                                            //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> sta AreaPointer          ;to addresses for level and enemy object data
                                            areaPointer = A
                                            //> iny
                                            Y = (Y + 1) and 0xFF
                                            //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                            A = memory[readWord(EnemyData) + Y].toInt()
                                            //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                            A = A and 0x1F
                                            //> sta EntrancePage         ;used upon entry to area, if area is entered
                                            entrancePage = A
                                            return X
                                        }
                                        //> jmp CheckThreeBytes      ;if not found, unconditional jump
                                        return checkThreeBytes()
                                    }
                                    return X
                                }
                                return X
                            }
                            //> rts                      ;the sixth slot
                            return X
                        }
                        //> jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
                        checkFrenzyBuffer(X)
                        return X
                    }
                    //> sta Enemy_ID,x        ;store as enemy object identifier here
                    enemyId[X] = A
                    //> lda #$01
                    A = 0x01
                    //> sta Enemy_Flag,x      ;activate enemy object flag
                    enemyFlag[X] = A
                    //> lda #$00
                    A = 0x00
                    //> sta Enemy_State,x     ;initialize state and frenzy queue
                    enemyState[X] = A
                    //> sta EnemyFrenzyQueue
                    enemyFrenzyQueue = A
                    //> jmp InitEnemyObject   ;and then jump to deal with this enemy
                    initEnemyObject(X)
                    return X
                }
                //> lda Player_State          ;check to see if the player is
                A = playerState
                //> cmp #$00                  ;on solid ground (i.e. not jumping or falling)
                //> bne WrongChk              ;if not, player fails to pass loop, and loopback
                if (!(A == 0x00)) {
                    //  goto WrongChk (internal forward branch)
                    //> WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
                    A = worldNumber
                    //> cmp #World7               ;incorrect vertical position or not on solid ground)
                    //> beq IncMLoop
                    return X
                }
                //> lda WorldNumber           ;are we in world 7? (check performed on correct
                A = worldNumber
                //> cmp #World7               ;vertical position and on solid ground)
                //> bne InitMLp               ;if not, initialize flags used there, otherwise
                if (!(A == World7)) {
                    //  goto InitMLp (internal forward branch)
                    //> InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
                    A = 0x00
                    //> sta MultiLoopPassCntr
                    multiLoopPassCntr = A
                    //> sta MultiLoopCorrectCntr
                    multiLoopCorrectCntr = A
                    return X
                }
                //> inc MultiLoopCorrectCntr  ;increment counter for correct progression
                multiLoopCorrectCntr = (multiLoopCorrectCntr + 1) and 0xFF
                //> sta Enemy_ID,x        ;store as enemy object identifier here
                enemyId[X] = A
                //> lda #$01
                A = 0x01
                //> sta Enemy_Flag,x      ;activate enemy object flag
                enemyFlag[X] = A
                //> lda #$00
                A = 0x00
                //> sta Enemy_State,x     ;initialize state and frenzy queue
                enemyState[X] = A
                //> sta EnemyFrenzyQueue
                enemyFrenzyQueue = A
                //> jmp InitEnemyObject   ;and then jump to deal with this enemy
                initEnemyObject(X)
                return X
                //> jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
                checkFrenzyBuffer(X)
                return X
                //> cpx #$05                 ;check for end of buffer
                //> bcc CheckRightBounds     ;if not at end of buffer, branch
                if (!(X >= 0x05)) {
                    //  goto CheckRightBounds (internal forward branch)
                    //> CheckRightBounds:
                    //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
                    A = screenrightXPos
                    //> clc
                    //> adc #$30
                    temp14 = A + 0x30
                    A = temp14 and 0xFF
                    //> and #%11110000           ;store high nybble
                    A = A and 0xF0
                    //> sta $07
                    memory[0x7] = A.toUByte()
                    //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
                    A = screenrightPageloc
                    //> adc #$00
                    temp15 = A + if (temp14 > 0xFF) 1 else 0
                    A = temp15 and 0xFF
                    //> sta $06                  ;store page location + carry
                    memory[0x6] = A.toUByte()
                    //> ldy EnemyDataOffset
                    Y = enemyDataOffset
                    //> iny
                    Y = (Y + 1) and 0xFF
                    //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
                    A = memory[readWord(EnemyData) + Y].toInt()
                    //> asl
                    val orig46: Int = A
                    A = (orig46 shl 1) and 0xFF
                    //> bcc CheckPageCtrlRow
                    if (!((orig46 and 0x80) != 0)) {
                        //  goto CheckPageCtrlRow (internal forward branch)
                        //> CheckPageCtrlRow:
                        //> dey
                        Y = (Y - 1) and 0xFF
                        //> lda (EnemyData),y        ;reread first byte
                        A = memory[readWord(EnemyData) + Y].toInt()
                        //> and #$0f
                        A = A and 0x0F
                        //> cmp #$0f                 ;check for special row $0f
                        //> bne PositionEnemyObj     ;if not found, branch to position enemy object
                        if (!(A == 0x0F)) {
                            //  goto PositionEnemyObj (internal forward branch)
                            //> PositionEnemyObj:
                            //> lda EnemyObjectPageLoc   ;store page control as page location
                            A = enemyObjectPageLoc
                            //> sta Enemy_PageLoc,x      ;for enemy object
                            enemyPageloc[X] = A
                            //> lda (EnemyData),y        ;get first byte of enemy object
                            A = memory[readWord(EnemyData) + Y].toInt()
                            //> and #%11110000
                            A = A and 0xF0
                            //> sta Enemy_X_Position,x   ;store column position
                            enemyXPosition[X] = A
                            //> cmp ScreenRight_X_Pos    ;check column position against right boundary
                            //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
                            A = enemyPageloc[X]
                            //> sbc ScreenRight_PageLoc  ;from page location
                            temp16 = A - screenrightPageloc - if (A >= screenrightXPos) 0 else 1
                            A = temp16 and 0xFF
                            //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
                            if (temp16 >= 0) {
                                //  goto CheckRightExtBounds (internal forward branch)
                                //> CheckRightExtBounds:
                                //> lda $07                  ;check right boundary + 48 against
                                A = memory[0x7].toInt()
                                //> cmp Enemy_X_Position,x   ;column position without subtracting,
                                //> lda $06                  ;then subtract borrow from page control temp
                                A = memory[0x6].toInt()
                                //> sbc Enemy_PageLoc,x      ;plus carry
                                temp17 = A - enemyPageloc[X] - if (A >= enemyXPosition[X]) 0 else 1
                                A = temp17 and 0xFF
                                //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
                                if (!(temp17 >= 0)) {
                                    //  goto CheckFrenzyBuffer -> checkFrenzyBuffer
                                    checkFrenzyBuffer(X)
                                    return X
                                }
                                //> lda #$01                 ;store value in vertical high byte
                                A = 0x01
                                //> sta Enemy_Y_HighPos,x
                                enemyYHighpos[X] = A
                                //> lda (EnemyData),y        ;get first byte again
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> asl                      ;multiply by four to get the vertical
                                val orig47: Int = A
                                A = (orig47 shl 1) and 0xFF
                                //> asl                      ;coordinate
                                val orig48: Int = A
                                A = (orig48 shl 1) and 0xFF
                                //> asl
                                val orig49: Int = A
                                A = (orig49 shl 1) and 0xFF
                                //> asl
                                val orig50: Int = A
                                A = (orig50 shl 1) and 0xFF
                                //> sta Enemy_Y_Position,x
                                enemyYPosition[X] = A
                                //> cmp #$e0                 ;do one last check for special row $0e
                                //> beq ParseRow0e           ;(necessary if branched to $c1cb)
                                if (A == 0xE0) {
                                    //  goto ParseRow0e (internal forward branch)
                                    //> ParseRow0e:
                                    //> iny                      ;increment Y to load third byte of object
                                    Y = (Y + 1) and 0xFF
                                    //> iny
                                    Y = (Y + 1) and 0xFF
                                    //> lda (EnemyData),y
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> lsr                      ;move 3 MSB to the bottom, effectively
                                    val orig51: Int = A
                                    A = orig51 shr 1
                                    //> lsr                      ;making %xxx00000 into %00000xxx
                                    val orig52: Int = A
                                    A = orig52 shr 1
                                    //> lsr
                                    val orig53: Int = A
                                    A = orig53 shr 1
                                    //> lsr
                                    val orig54: Int = A
                                    A = orig54 shr 1
                                    //> lsr
                                    val orig55: Int = A
                                    A = orig55 shr 1
                                    //> cmp WorldNumber          ;is it the same world number as we're on?
                                    //> bne NotUse               ;if not, do not use (this allows multiple uses
                                    if (!(A == worldNumber)) {
                                        //  goto NotUse (internal forward branch)
                                        //> NotUse: jmp Inc3B
                                        return inc3B()
                                    }
                                    //> dey                      ;of the same area, like the underground bonus areas)
                                    Y = (Y - 1) and 0xFF
                                    //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> sta AreaPointer          ;to addresses for level and enemy object data
                                    areaPointer = A
                                    //> iny
                                    Y = (Y + 1) and 0xFF
                                    //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                    A = A and 0x1F
                                    //> sta EntrancePage         ;used upon entry to area, if area is entered
                                    entrancePage = A
                                    return X
                                }
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;get second byte of object
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> and #%01000000           ;check to see if hard mode bit is set
                                A = A and 0x40
                                //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
                                if (A == 0) {
                                    //  goto CheckForEnemyGroup (internal forward branch)
                                    //> CheckForEnemyGroup:
                                    //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #%00111111
                                    A = A and 0x3F
                                    //> cmp #$37               ;check for value below $37
                                    //> bcc BuzzyBeetleMutate
                                    if (!(A >= 0x37)) {
                                        //  goto BuzzyBeetleMutate (internal forward branch)
                                        //> BuzzyBeetleMutate:
                                        //> cmp #Goomba          ;if below $37, check for goomba
                                        //> bne StrID            ;value ($3f or more always fails)
                                        if (!(A == Goomba)) {
                                            //  goto StrID (internal forward branch)
                                            //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                            enemyId[X] = A
                                            //> lda #$01
                                            A = 0x01
                                            //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                            enemyFlag[X] = A
                                            //> jsr InitEnemyObject
                                            initEnemyObject(X)
                                            //> lda Enemy_Flag,x     ;check to see if flag is set
                                            A = enemyFlag[X]
                                            //> bne Inc2B            ;if not, leave, otherwise branch
                                            if (!(A == 0)) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            //> rts
                                            return X
                                        }
                                        //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                                        Y = primaryHardMode
                                        //> beq StrID            ;and if so, change goomba to buzzy beetle
                                        if (Y == 0) {
                                            //  goto StrID (internal forward branch)
                                            //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                            enemyId[X] = A
                                            //> lda #$01
                                            A = 0x01
                                            //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                            enemyFlag[X] = A
                                            //> jsr InitEnemyObject
                                            initEnemyObject(X)
                                            //> lda Enemy_Flag,x     ;check to see if flag is set
                                            A = enemyFlag[X]
                                            //> bne Inc2B            ;if not, leave, otherwise branch
                                            if (!(A == 0)) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            //> rts
                                            return X
                                        }
                                        //> lda #BuzzyBeetle
                                        A = BuzzyBeetle
                                        return X
                                    }
                                    //> cmp #$3f               ;if $37 or greater, check for value
                                    //> bcc DoGroup            ;below $3f, branch if below $3f
                                    if (!(A >= 0x3F)) {
                                        //  goto DoGroup (internal forward branch)
                                        //> DoGroup:
                                        //> jmp HandleGroupEnemies   ;handle enemy group objects
                                        return handleGroupEnemies(A)
                                    }
                                    return X
                                }
                                //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                                A = secondaryHardMode
                                //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                                if (A == 0) {
                                    //  goto Inc2B -> inc2B
                                    inc2B()
                                    return X
                                }
                                return X
                            }
                            //> lda (EnemyData),y
                            A = memory[readWord(EnemyData) + Y].toInt()
                            //> and #%00001111           ;check for special row $0e
                            A = A and 0x0F
                            //> cmp #$0e                 ;if found, jump elsewhere
                            //> beq ParseRow0e
                            if (A == 0x0E) {
                                //  goto ParseRow0e (internal forward branch)
                                //> ParseRow0e:
                                //> iny                      ;increment Y to load third byte of object
                                Y = (Y + 1) and 0xFF
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> lsr                      ;move 3 MSB to the bottom, effectively
                                val orig56: Int = A
                                A = orig56 shr 1
                                //> lsr                      ;making %xxx00000 into %00000xxx
                                val orig57: Int = A
                                A = orig57 shr 1
                                //> lsr
                                val orig58: Int = A
                                A = orig58 shr 1
                                //> lsr
                                val orig59: Int = A
                                A = orig59 shr 1
                                //> lsr
                                val orig60: Int = A
                                A = orig60 shr 1
                                //> cmp WorldNumber          ;is it the same world number as we're on?
                                //> bne NotUse               ;if not, do not use (this allows multiple uses
                                if (!(A == worldNumber)) {
                                    //  goto NotUse (internal forward branch)
                                    //> NotUse: jmp Inc3B
                                    return inc3B()
                                }
                                //> dey                      ;of the same area, like the underground bonus areas)
                                Y = (Y - 1) and 0xFF
                                //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> sta AreaPointer          ;to addresses for level and enemy object data
                                areaPointer = A
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                A = A and 0x1F
                                //> sta EntrancePage         ;used upon entry to area, if area is entered
                                entrancePage = A
                                return X
                            }
                            //> jmp CheckThreeBytes      ;if not found, unconditional jump
                            return checkThreeBytes()
                        }
                        return X
                    }
                    return X
                }
                //> iny
                Y = (Y + 1) and 0xFF
                //> lda (EnemyData),y        ;check for specific value here
                A = memory[readWord(EnemyData) + Y].toInt()
                //> and #%00111111           ;not sure what this was intended for, exactly
                A = A and 0x3F
                //> cmp #$2e                 ;this part is quite possibly residual code
                //> beq CheckRightBounds     ;but it has the effect of keeping enemies out of
                if (A == 0x2E) {
                    //  goto CheckRightBounds (internal forward branch)
                    //> CheckRightBounds:
                    //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
                    A = screenrightXPos
                    //> clc
                    //> adc #$30
                    temp18 = A + 0x30
                    A = temp18 and 0xFF
                    //> and #%11110000           ;store high nybble
                    A = A and 0xF0
                    //> sta $07
                    memory[0x7] = A.toUByte()
                    //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
                    A = screenrightPageloc
                    //> adc #$00
                    temp19 = A + if (temp18 > 0xFF) 1 else 0
                    A = temp19 and 0xFF
                    //> sta $06                  ;store page location + carry
                    memory[0x6] = A.toUByte()
                    //> ldy EnemyDataOffset
                    Y = enemyDataOffset
                    //> iny
                    Y = (Y + 1) and 0xFF
                    //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
                    A = memory[readWord(EnemyData) + Y].toInt()
                    //> asl
                    val orig61: Int = A
                    A = (orig61 shl 1) and 0xFF
                    //> bcc CheckPageCtrlRow
                    if (!((orig61 and 0x80) != 0)) {
                        //  goto CheckPageCtrlRow (internal forward branch)
                        //> CheckPageCtrlRow:
                        //> dey
                        Y = (Y - 1) and 0xFF
                        //> lda (EnemyData),y        ;reread first byte
                        A = memory[readWord(EnemyData) + Y].toInt()
                        //> and #$0f
                        A = A and 0x0F
                        //> cmp #$0f                 ;check for special row $0f
                        //> bne PositionEnemyObj     ;if not found, branch to position enemy object
                        if (!(A == 0x0F)) {
                            //  goto PositionEnemyObj (internal forward branch)
                            //> PositionEnemyObj:
                            //> lda EnemyObjectPageLoc   ;store page control as page location
                            A = enemyObjectPageLoc
                            //> sta Enemy_PageLoc,x      ;for enemy object
                            enemyPageloc[X] = A
                            //> lda (EnemyData),y        ;get first byte of enemy object
                            A = memory[readWord(EnemyData) + Y].toInt()
                            //> and #%11110000
                            A = A and 0xF0
                            //> sta Enemy_X_Position,x   ;store column position
                            enemyXPosition[X] = A
                            //> cmp ScreenRight_X_Pos    ;check column position against right boundary
                            //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
                            A = enemyPageloc[X]
                            //> sbc ScreenRight_PageLoc  ;from page location
                            temp20 = A - screenrightPageloc - if (A >= screenrightXPos) 0 else 1
                            A = temp20 and 0xFF
                            //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
                            if (temp20 >= 0) {
                                //  goto CheckRightExtBounds (internal forward branch)
                                //> CheckRightExtBounds:
                                //> lda $07                  ;check right boundary + 48 against
                                A = memory[0x7].toInt()
                                //> cmp Enemy_X_Position,x   ;column position without subtracting,
                                //> lda $06                  ;then subtract borrow from page control temp
                                A = memory[0x6].toInt()
                                //> sbc Enemy_PageLoc,x      ;plus carry
                                temp21 = A - enemyPageloc[X] - if (A >= enemyXPosition[X]) 0 else 1
                                A = temp21 and 0xFF
                                //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
                                if (!(temp21 >= 0)) {
                                    //  goto CheckFrenzyBuffer -> checkFrenzyBuffer
                                    checkFrenzyBuffer(X)
                                    return X
                                }
                                //> lda #$01                 ;store value in vertical high byte
                                A = 0x01
                                //> sta Enemy_Y_HighPos,x
                                enemyYHighpos[X] = A
                                //> lda (EnemyData),y        ;get first byte again
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> asl                      ;multiply by four to get the vertical
                                val orig62: Int = A
                                A = (orig62 shl 1) and 0xFF
                                //> asl                      ;coordinate
                                val orig63: Int = A
                                A = (orig63 shl 1) and 0xFF
                                //> asl
                                val orig64: Int = A
                                A = (orig64 shl 1) and 0xFF
                                //> asl
                                val orig65: Int = A
                                A = (orig65 shl 1) and 0xFF
                                //> sta Enemy_Y_Position,x
                                enemyYPosition[X] = A
                                //> cmp #$e0                 ;do one last check for special row $0e
                                //> beq ParseRow0e           ;(necessary if branched to $c1cb)
                                if (A == 0xE0) {
                                    //  goto ParseRow0e (internal forward branch)
                                    //> ParseRow0e:
                                    //> iny                      ;increment Y to load third byte of object
                                    Y = (Y + 1) and 0xFF
                                    //> iny
                                    Y = (Y + 1) and 0xFF
                                    //> lda (EnemyData),y
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> lsr                      ;move 3 MSB to the bottom, effectively
                                    val orig66: Int = A
                                    A = orig66 shr 1
                                    //> lsr                      ;making %xxx00000 into %00000xxx
                                    val orig67: Int = A
                                    A = orig67 shr 1
                                    //> lsr
                                    val orig68: Int = A
                                    A = orig68 shr 1
                                    //> lsr
                                    val orig69: Int = A
                                    A = orig69 shr 1
                                    //> lsr
                                    val orig70: Int = A
                                    A = orig70 shr 1
                                    //> cmp WorldNumber          ;is it the same world number as we're on?
                                    //> bne NotUse               ;if not, do not use (this allows multiple uses
                                    if (!(A == worldNumber)) {
                                        //  goto NotUse (internal forward branch)
                                        //> NotUse: jmp Inc3B
                                        return inc3B()
                                    }
                                    //> dey                      ;of the same area, like the underground bonus areas)
                                    Y = (Y - 1) and 0xFF
                                    //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> sta AreaPointer          ;to addresses for level and enemy object data
                                    areaPointer = A
                                    //> iny
                                    Y = (Y + 1) and 0xFF
                                    //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                    A = A and 0x1F
                                    //> sta EntrancePage         ;used upon entry to area, if area is entered
                                    entrancePage = A
                                    return X
                                }
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;get second byte of object
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> and #%01000000           ;check to see if hard mode bit is set
                                A = A and 0x40
                                //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
                                if (A == 0) {
                                    //  goto CheckForEnemyGroup (internal forward branch)
                                    //> CheckForEnemyGroup:
                                    //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
                                    A = memory[readWord(EnemyData) + Y].toInt()
                                    //> and #%00111111
                                    A = A and 0x3F
                                    //> cmp #$37               ;check for value below $37
                                    //> bcc BuzzyBeetleMutate
                                    if (!(A >= 0x37)) {
                                        //  goto BuzzyBeetleMutate (internal forward branch)
                                        //> BuzzyBeetleMutate:
                                        //> cmp #Goomba          ;if below $37, check for goomba
                                        //> bne StrID            ;value ($3f or more always fails)
                                        if (!(A == Goomba)) {
                                            //  goto StrID (internal forward branch)
                                            //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                            enemyId[X] = A
                                            //> lda #$01
                                            A = 0x01
                                            //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                            enemyFlag[X] = A
                                            //> jsr InitEnemyObject
                                            initEnemyObject(X)
                                            //> lda Enemy_Flag,x     ;check to see if flag is set
                                            A = enemyFlag[X]
                                            //> bne Inc2B            ;if not, leave, otherwise branch
                                            if (!(A == 0)) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            //> rts
                                            return X
                                        }
                                        //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                                        Y = primaryHardMode
                                        //> beq StrID            ;and if so, change goomba to buzzy beetle
                                        if (Y == 0) {
                                            //  goto StrID (internal forward branch)
                                            //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                                            enemyId[X] = A
                                            //> lda #$01
                                            A = 0x01
                                            //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                                            enemyFlag[X] = A
                                            //> jsr InitEnemyObject
                                            initEnemyObject(X)
                                            //> lda Enemy_Flag,x     ;check to see if flag is set
                                            A = enemyFlag[X]
                                            //> bne Inc2B            ;if not, leave, otherwise branch
                                            if (!(A == 0)) {
                                                //  goto Inc2B -> inc2B
                                                inc2B()
                                                return X
                                            }
                                            //> rts
                                            return X
                                        }
                                        //> lda #BuzzyBeetle
                                        A = BuzzyBeetle
                                        return X
                                    }
                                    //> cmp #$3f               ;if $37 or greater, check for value
                                    //> bcc DoGroup            ;below $3f, branch if below $3f
                                    if (!(A >= 0x3F)) {
                                        //  goto DoGroup (internal forward branch)
                                        //> DoGroup:
                                        //> jmp HandleGroupEnemies   ;handle enemy group objects
                                        return handleGroupEnemies(A)
                                    }
                                    return X
                                }
                                //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                                A = secondaryHardMode
                                //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                                if (A == 0) {
                                    //  goto Inc2B -> inc2B
                                    inc2B()
                                    return X
                                }
                                return X
                            }
                            //> lda (EnemyData),y
                            A = memory[readWord(EnemyData) + Y].toInt()
                            //> and #%00001111           ;check for special row $0e
                            A = A and 0x0F
                            //> cmp #$0e                 ;if found, jump elsewhere
                            //> beq ParseRow0e
                            if (A == 0x0E) {
                                //  goto ParseRow0e (internal forward branch)
                                //> ParseRow0e:
                                //> iny                      ;increment Y to load third byte of object
                                Y = (Y + 1) and 0xFF
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> lsr                      ;move 3 MSB to the bottom, effectively
                                val orig71: Int = A
                                A = orig71 shr 1
                                //> lsr                      ;making %xxx00000 into %00000xxx
                                val orig72: Int = A
                                A = orig72 shr 1
                                //> lsr
                                val orig73: Int = A
                                A = orig73 shr 1
                                //> lsr
                                val orig74: Int = A
                                A = orig74 shr 1
                                //> lsr
                                val orig75: Int = A
                                A = orig75 shr 1
                                //> cmp WorldNumber          ;is it the same world number as we're on?
                                //> bne NotUse               ;if not, do not use (this allows multiple uses
                                if (!(A == worldNumber)) {
                                    //  goto NotUse (internal forward branch)
                                    //> NotUse: jmp Inc3B
                                    return inc3B()
                                }
                                //> dey                      ;of the same area, like the underground bonus areas)
                                Y = (Y - 1) and 0xFF
                                //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> sta AreaPointer          ;to addresses for level and enemy object data
                                areaPointer = A
                                //> iny
                                Y = (Y + 1) and 0xFF
                                //> lda (EnemyData),y        ;get third byte again, and this time mask out
                                A = memory[readWord(EnemyData) + Y].toInt()
                                //> and #%00011111           ;the 3 MSB from before, save as page number to be
                                A = A and 0x1F
                                //> sta EntrancePage         ;used upon entry to area, if area is entered
                                entrancePage = A
                                return X
                            }
                            //> jmp CheckThreeBytes      ;if not found, unconditional jump
                            return checkThreeBytes()
                        }
                        return X
                    }
                    return X
                }
                //> rts                      ;the sixth slot
                return X
                //> iny
                Y = (Y + 1) and 0xFF
                //> lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
                A = memory[readWord(EnemyData) + Y].toInt()
                //> and #%00111111
                A = A and 0x3F
                //> sta EnemyObjectPageLoc   ;store as page control for enemy object data
                enemyObjectPageLoc = A
                //> inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
                enemyDataOffset = (enemyDataOffset + 1) and 0xFF
                //> inc EnemyDataOffset
                enemyDataOffset = (enemyDataOffset + 1) and 0xFF
                //> inc EnemyObjectPageSel   ;set page select for enemy object data and
                enemyObjectPageSel = (enemyObjectPageSel + 1) and 0xFF
                //> jmp ProcLoopCommand      ;jump back to process loop commands again
            }
        }
    }
    //> PositionEnemyObj:
    //> lda EnemyObjectPageLoc   ;store page control as page location
    A = enemyObjectPageLoc
    //> sta Enemy_PageLoc,x      ;for enemy object
    enemyPageloc[X] = A
    //> lda (EnemyData),y        ;get first byte of enemy object
    A = memory[readWord(EnemyData) + Y].toInt()
    //> and #%11110000
    A = A and 0xF0
    //> sta Enemy_X_Position,x   ;store column position
    enemyXPosition[X] = A
    //> cmp ScreenRight_X_Pos    ;check column position against right boundary
    //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
    A = enemyPageloc[X]
    //> sbc ScreenRight_PageLoc  ;from page location
    temp22 = A - screenrightPageloc - if (A >= screenrightXPos) 0 else 1
    A = temp22 and 0xFF
    //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
    if (!(temp22 >= 0)) {
        //> lda (EnemyData),y
        A = memory[readWord(EnemyData) + Y].toInt()
        //> and #%00001111           ;check for special row $0e
        A = A and 0x0F
        //> cmp #$0e                 ;if found, jump elsewhere
        //> beq ParseRow0e
        if (A != 0x0E) {
            //> jmp CheckThreeBytes      ;if not found, unconditional jump
            return checkThreeBytes()
        }
    }
    //> CheckRightExtBounds:
    //> lda $07                  ;check right boundary + 48 against
    A = memory[0x7].toInt()
    //> cmp Enemy_X_Position,x   ;column position without subtracting,
    //> lda $06                  ;then subtract borrow from page control temp
    A = memory[0x6].toInt()
    //> sbc Enemy_PageLoc,x      ;plus carry
    temp23 = A - enemyPageloc[X] - if (A >= enemyXPosition[X]) 0 else 1
    A = temp23 and 0xFF
    //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
    if (!(temp23 >= 0)) {
        //  goto CheckFrenzyBuffer -> checkFrenzyBuffer
        checkFrenzyBuffer(X)
        return X
    } else {
        //> lda #$01                 ;store value in vertical high byte
        A = 0x01
        //> sta Enemy_Y_HighPos,x
        enemyYHighpos[X] = A
        //> lda (EnemyData),y        ;get first byte again
        A = memory[readWord(EnemyData) + Y].toInt()
        //> asl                      ;multiply by four to get the vertical
        val orig76: Int = A
        A = (orig76 shl 1) and 0xFF
        //> asl                      ;coordinate
        val orig77: Int = A
        A = (orig77 shl 1) and 0xFF
        //> asl
        val orig78: Int = A
        A = (orig78 shl 1) and 0xFF
        //> asl
        val orig79: Int = A
        A = (orig79 shl 1) and 0xFF
        //> sta Enemy_Y_Position,x
        enemyYPosition[X] = A
        //> cmp #$e0                 ;do one last check for special row $0e
        //> beq ParseRow0e           ;(necessary if branched to $c1cb)
        if (A != 0xE0) {
            //> iny
            Y = (Y + 1) and 0xFF
            //> lda (EnemyData),y        ;get second byte of object
            A = memory[readWord(EnemyData) + Y].toInt()
            //> and #%01000000           ;check to see if hard mode bit is set
            A = A and 0x40
            //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
            if (A != 0) {
                //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                A = secondaryHardMode
                //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                if (A == 0) {
                    //  goto Inc2B -> inc2B
                    inc2B()
                    return X
                }
            }
            //> CheckForEnemyGroup:
            //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
            A = memory[readWord(EnemyData) + Y].toInt()
            //> and #%00111111
            A = A and 0x3F
            //> cmp #$37               ;check for value below $37
            //> bcc BuzzyBeetleMutate
            if (A >= 0x37) {
                //> cmp #$3f               ;if $37 or greater, check for value
                //> bcc DoGroup            ;below $3f, branch if below $3f
                if (A >= 0x3F) {
                } else {
                    //> DoGroup:
                    //> jmp HandleGroupEnemies   ;handle enemy group objects
                    return handleGroupEnemies(A)
                }
            }
            //> BuzzyBeetleMutate:
            //> cmp #Goomba          ;if below $37, check for goomba
            //> bne StrID            ;value ($3f or more always fails)
            if (A == Goomba) {
                //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                Y = primaryHardMode
                //> beq StrID            ;and if so, change goomba to buzzy beetle
                if (Y != 0) {
                    //> lda #BuzzyBeetle
                    A = BuzzyBeetle
                }
            }
            //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
            enemyId[X] = A
            //> lda #$01
            A = 0x01
            //> sta Enemy_Flag,x     ;set flag for enemy in buffer
            enemyFlag[X] = A
            //> jsr InitEnemyObject
            initEnemyObject(X)
            //> lda Enemy_Flag,x     ;check to see if flag is set
            A = enemyFlag[X]
            //> bne Inc2B            ;if not, leave, otherwise branch
            if (!(A == 0)) {
                //  goto Inc2B -> inc2B
                inc2B()
                return X
            }
            //> rts
            return X
            //> DoGroup:
            //> jmp HandleGroupEnemies   ;handle enemy group objects
            return handleGroupEnemies(A)
        }
    }
    //> ParseRow0e:
    //> iny                      ;increment Y to load third byte of object
    Y = (Y + 1) and 0xFF
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda (EnemyData),y
    A = memory[readWord(EnemyData) + Y].toInt()
    //> lsr                      ;move 3 MSB to the bottom, effectively
    val orig80: Int = A
    A = orig80 shr 1
    //> lsr                      ;making %xxx00000 into %00000xxx
    val orig81: Int = A
    A = orig81 shr 1
    //> lsr
    val orig82: Int = A
    A = orig82 shr 1
    //> lsr
    val orig83: Int = A
    A = orig83 shr 1
    //> lsr
    val orig84: Int = A
    A = orig84 shr 1
    //> cmp WorldNumber          ;is it the same world number as we're on?
    //> bne NotUse               ;if not, do not use (this allows multiple uses
    if (A == worldNumber) {
        //> dey                      ;of the same area, like the underground bonus areas)
        Y = (Y - 1) and 0xFF
        //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
        A = memory[readWord(EnemyData) + Y].toInt()
        //> sta AreaPointer          ;to addresses for level and enemy object data
        areaPointer = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> lda (EnemyData),y        ;get third byte again, and this time mask out
        A = memory[readWord(EnemyData) + Y].toInt()
        //> and #%00011111           ;the 3 MSB from before, save as page number to be
        A = A and 0x1F
        //> sta EntrancePage         ;used upon entry to area, if area is entered
        entrancePage = A
    }
    //> NotUse: jmp Inc3B
    return inc3B()
}

// Decompiled from CheckFrenzyBuffer
fun checkFrenzyBuffer(X: Int) {
    var A: Int = 0
    var X: Int = X
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var vineFlagOffset by MemoryByte(VineFlagOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> CheckFrenzyBuffer:
    //> lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
    A = enemyFrenzyBuffer
    //> bne StrFre               ;then branch ahead to store in enemy object buffer
    X = X
    if (A == 0) {
        //> lda VineFlagOffset       ;otherwise check vine flag offset
        A = vineFlagOffset
        //> cmp #$01
        //> bne ExEPar               ;if other value <> 1, leave
        if (!(A == 0x01)) {
            //  goto ExEPar -> exEPar
            exEPar()
            return
        }
        //> lda #VineObject          ;otherwise put vine in enemy identifier
        A = VineObject
    }
    //> StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
    enemyId[X] = A
    //  Fall-through tail call to initEnemyObject
    initEnemyObject(X)
    return
}

// Decompiled from InitEnemyObject
fun initEnemyObject(X: Int) {
    var A: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> InitEnemyObject:
    //> lda #$00                 ;initialize enemy state
    A = 0x00
    //> sta Enemy_State,x
    enemyState[X] = A
    //> jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
    checkpointEnemyID(X)
    //  Fall-through tail call to exEPar
    exEPar()
    return
}

// Decompiled from ExEPar
fun exEPar() {
    //> ExEPar: rts                      ;then leave
    return
}

// Decompiled from CheckThreeBytes
fun checkThreeBytes(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    //> CheckThreeBytes:
    //> ldy EnemyDataOffset      ;load current offset for enemy object data
    Y = enemyDataOffset
    //> lda (EnemyData),y        ;get first byte
    A = memory[readWord(EnemyData) + Y].toInt()
    //> and #%00001111           ;check for special row $0e
    A = A and 0x0F
    //> cmp #$0e
    //> bne Inc2B
    if (!(A == 0x0E)) {
        //  goto Inc2B -> inc2B
        inc2B()
        return X
    }
    //  Fall-through tail call to inc3B
    return inc3B()
}

// Decompiled from Inc3B
fun inc3B(): Int {
    var X: Int = 0
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    //> Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
    //  Fall-through tail call to inc2B
    return inc2B()
}

// Decompiled from Inc2B
fun inc2B(): Int {
    var A: Int = 0
    var X: Int = 0
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    var enemyObjectPageSel by MemoryByte(EnemyObjectPageSel)
    var objectOffset by MemoryByte(ObjectOffset)
    //> Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
    //> inc EnemyDataOffset
    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
    //> lda #$00                 ;init page select for enemy objects
    A = 0x00
    //> sta EnemyObjectPageSel
    enemyObjectPageSel = A
    //> ldx ObjectOffset         ;reload current offset in enemy buffers
    X = objectOffset
    //> rts                      ;and leave
    return X
}

// Decompiled from CheckpointEnemyID
fun checkpointEnemyID(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> CheckpointEnemyID:
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #$15                     ;check enemy object identifier for $15 or greater
    //> bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
    X = X
    if (!(A >= 0x15)) {
        //> tay                          ;save identifier in Y register for now
        Y = A
        //> lda Enemy_Y_Position,x
        A = enemyYPosition[X]
        //> adc #$08                     ;add eight pixels to what will eventually be the
        temp0 = A + 0x08 + if (A >= 0x15) 1 else 0
        A = temp0 and 0xFF
        //> sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
        enemyYPosition[X] = A
        //> lda #$01
        A = 0x01
        //> sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
        enemyOffscrBitsMasked[X] = A
        //> tya                          ;get identifier back and use as offset for jump engine
        A = Y
    }
    //> InitEnemyRoutines:
    //> jsr JumpEngine
    when (A) {
        0 -> {
            initNormalEnemy(X)
        }
        1 -> {
            initNormalEnemy(X)
        }
        2 -> {
            initNormalEnemy(X)
        }
        3 -> {
            initRedKoopa(X)
        }
        4 -> {
            noInitCode()
        }
        5 -> {
            initHammerBro(X)
        }
        6 -> {
            initGoomba(X)
        }
        7 -> {
            initBloober(X)
        }
        8 -> {
            initBulletBill(X)
        }
        9 -> {
            noInitCode()
        }
        10 -> {
            initCheepCheep(X)
        }
        11 -> {
            initCheepCheep(X)
        }
        12 -> {
            initPodoboo(X)
        }
        13 -> {
            initPiranhaPlant(X)
        }
        14 -> {
            initJumpGPTroopa(X)
        }
        15 -> {
            initRedPTroopa(X)
        }
        16 -> {
            initHorizFlySwimEnemy(X)
        }
        17 -> {
            initLakitu(X)
        }
        18 -> {
            initEnemyFrenzy(X)
        }
        19 -> {
            noInitCode()
        }
        20 -> {
            initEnemyFrenzy(X)
        }
        21 -> {
            initEnemyFrenzy(X)
        }
        22 -> {
            initEnemyFrenzy(X)
        }
        23 -> {
            initEnemyFrenzy(X)
        }
        24 -> {
            endFrenzy(X)
        }
        25 -> {
            noInitCode()
        }
        26 -> {
            noInitCode()
        }
        27 -> {
            initShortFirebar(X)
        }
        28 -> {
            initShortFirebar(X)
        }
        29 -> {
            initShortFirebar(X)
        }
        30 -> {
            initShortFirebar(X)
        }
        31 -> {
            initLongFirebar(X)
        }
        32 -> {
            noInitCode()
        }
        33 -> {
            noInitCode()
        }
        34 -> {
            noInitCode()
        }
        35 -> {
            noInitCode()
        }
        36 -> {
            initBalPlatform(X)
        }
        37 -> {
            initVertPlatform(X)
        }
        38 -> {
            largeLiftUp(X)
        }
        39 -> {
            largeLiftDown(X)
        }
        40 -> {
            initHoriPlatform(X)
        }
        41 -> {
            initDropPlatform(X)
        }
        42 -> {
            initHoriPlatform(X)
        }
        43 -> {
            platLiftUp(X)
        }
        44 -> {
            platLiftDown(X)
        }
        45 -> {
            initBowser(X)
        }
        46 -> {
            pwrUpJmp()
        }
        47 -> {
            setupVine(X, 0)
        }
        48 -> {
            noInitCode()
        }
        49 -> {
            noInitCode()
        }
        50 -> {
            noInitCode()
        }
        51 -> {
            noInitCode()
        }
        52 -> {
            noInitCode()
        }
        53 -> {
            initRetainerObj(X)
        }
        54 -> {
            endOfEnemyInitCode()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> ;jump engine table for newly loaded enemy objects
    //> .dw InitNormalEnemy  ;for objects $00-$0f
    //> .dw InitNormalEnemy
    //> .dw InitNormalEnemy
    //> .dw InitRedKoopa
    //> .dw NoInitCode
    //> .dw InitHammerBro
    //> .dw InitGoomba
    //> .dw InitBloober
    //> .dw InitBulletBill
    //> .dw NoInitCode
    //> .dw InitCheepCheep
    //> .dw InitCheepCheep
    //> .dw InitPodoboo
    //> .dw InitPiranhaPlant
    //> .dw InitJumpGPTroopa
    //> .dw InitRedPTroopa
    //> .dw InitHorizFlySwimEnemy  ;for objects $10-$1f
    //> .dw InitLakitu
    //> .dw InitEnemyFrenzy
    //> .dw NoInitCode
    //> .dw InitEnemyFrenzy
    //> .dw InitEnemyFrenzy
    //> .dw InitEnemyFrenzy
    //> .dw InitEnemyFrenzy
    //> .dw EndFrenzy
    //> .dw NoInitCode
    //> .dw NoInitCode
    //> .dw InitShortFirebar
    //> .dw InitShortFirebar
    //> .dw InitShortFirebar
    //> .dw InitShortFirebar
    //> .dw InitLongFirebar
    //> .dw NoInitCode ;for objects $20-$2f
    //> .dw NoInitCode
    //> .dw NoInitCode
    //> .dw NoInitCode
    //> .dw InitBalPlatform
    //> .dw InitVertPlatform
    //> .dw LargeLiftUp
    //> .dw LargeLiftDown
    //> .dw InitHoriPlatform
    //> .dw InitDropPlatform
    //> .dw InitHoriPlatform
    //> .dw PlatLiftUp
    //> .dw PlatLiftDown
    //> .dw InitBowser
    //> .dw PwrUpJmp   ;possibly dummy value
    //> .dw Setup_Vine
    //> .dw NoInitCode ;for objects $30-$36
    //> .dw NoInitCode
    //> .dw NoInitCode
    //> .dw NoInitCode
    //> .dw NoInitCode
    //> .dw InitRetainerObj
    //> .dw EndOfEnemyInitCode
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to noInitCode
    noInitCode()
    return
}

// Decompiled from NoInitCode
fun noInitCode() {
    //> NoInitCode:
    //> rts               ;this executed when enemy object has no init code
    return
}

// Decompiled from InitGoomba
fun initGoomba(X: Int): Int {
    var A: Int = 0
    var temp0: Int = 0
    //> InitGoomba:
    //> jsr InitNormalEnemy  ;set appropriate horizontal speed
    temp0 = initNormalEnemy(X)
    //> jmp SmallBBox        ;set $09 as bounding box control, set other values
    return smallBBox(X)
}

// Decompiled from InitPodoboo
fun initPodoboo(X: Int): Int {
    var A: Int = 0
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> InitPodoboo:
    //> lda #$02                  ;set enemy position to below
    A = 0x02
    //> sta Enemy_Y_HighPos,x     ;the bottom of the screen
    enemyYHighpos[X] = A
    //> sta Enemy_Y_Position,x
    enemyYPosition[X] = A
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> sta EnemyIntervalTimer,x  ;set timer for enemy
    enemyIntervalTimer[X] = A
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> sta Enemy_State,x         ;initialize enemy state, then jump to use
    enemyState[X] = A
    //> jmp SmallBBox             ;$09 as bounding box size and set other things
    return smallBBox(X)
}

// Decompiled from InitRetainerObj
fun initRetainerObj(X: Int) {
    var A: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> InitRetainerObj:
    //> lda #$b8                ;set fixed vertical position for
    A = 0xB8
    //> sta Enemy_Y_Position,x  ;princess/mushroom retainer object
    enemyYPosition[X] = A
    //> rts
    return
}

// Decompiled from InitNormalEnemy
fun initNormalEnemy(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    val normalXSpdData by MemoryByteIndexed(NormalXSpdData)
    //> InitNormalEnemy:
    //> ldy #$01              ;load offset of 1 by default
    Y = 0x01
    //> lda PrimaryHardMode   ;check for primary hard mode flag set
    A = primaryHardMode
    //> bne GetESpd
    X = X
    if (A == 0) {
        //> dey                   ;if not set, decrement offset
        Y = (Y - 1) and 0xFF
    }
    //> GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
    A = normalXSpdData[Y]
    //  Fall-through tail call to setESpd
    return setESpd(A, X)
}

// Decompiled from SetESpd
fun setESpd(A: Int, X: Int): Int {
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
    enemyXSpeed[X] = A
    //> jmp TallBBox          ;branch to set bounding box control and other data
    return tallBBox(X)
}

// Decompiled from InitRedKoopa
fun initRedKoopa(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> InitRedKoopa:
    //> jsr InitNormalEnemy   ;load appropriate horizontal speed
    temp0 = initNormalEnemy(X)
    //> lda #$01              ;set enemy state for red koopa troopa $03
    A = 0x01
    //> sta Enemy_State,x
    enemyState[X] = A
    //> rts
    return
}

// Decompiled from InitHammerBro
fun initHammerBro(X: Int): Int {
    var A: Int = 0
    var Y: Int = 0
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val hBroWalkingTimerData by MemoryByteIndexed(HBroWalkingTimerData)
    val hammerThrowingTimer by MemoryByteIndexed(HammerThrowingTimer)
    //> InitHammerBro:
    //> lda #$00                    ;init horizontal speed and timer used by hammer bro
    A = 0x00
    //> sta HammerThrowingTimer,x   ;apparently to time hammer throwing
    hammerThrowingTimer[X] = A
    //> sta Enemy_X_Speed,x
    enemyXSpeed[X] = A
    //> ldy SecondaryHardMode       ;get secondary hard mode flag
    Y = secondaryHardMode
    //> lda HBroWalkingTimerData,y
    A = hBroWalkingTimerData[Y]
    //> sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
    enemyIntervalTimer[X] = A
    //> lda #$0b                    ;set specific value for bounding box size control
    A = 0x0B
    //> jmp SetBBox
    return setBBox(A, X)
}

// Decompiled from InitHorizFlySwimEnemy
fun initHorizFlySwimEnemy(X: Int): Int {
    var A: Int = 0
    //> InitHorizFlySwimEnemy:
    //> lda #$00        ;initialize horizontal speed
    A = 0x00
    //> jmp SetESpd
    return setESpd(A, X)
}

// Decompiled from InitBloober
fun initBloober(X: Int): Int {
    var A: Int = 0
    val blooperMoveSpeed by MemoryByteIndexed(BlooperMoveSpeed)
    //> InitBloober:
    //> lda #$00               ;initialize horizontal speed
    A = 0x00
    //> sta BlooperMoveSpeed,x
    blooperMoveSpeed[X] = A
    //  Fall-through tail call to smallBBox
    return smallBBox(X)
}

// Decompiled from SmallBBox
fun smallBBox(X: Int): Int {
    var A: Int = 0
    //> SmallBBox: lda #$09               ;set specific bounding box size control
    A = 0x09
    //> bne SetBBox            ;unconditional branch
    if (!(A == 0)) {
        //  goto SetBBox -> setBBox
        setBBox(A, X)
        return A
    } else {
        //> ;--------------------------------
        //  Fall-through tail call to initRedPTroopa
        return initRedPTroopa(X)
    }
}

// Decompiled from InitRedPTroopa
fun initRedPTroopa(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val redPTroopaCenterYPos by MemoryByteIndexed(RedPTroopaCenterYPos)
    val redPTroopaOrigXPos by MemoryByteIndexed(RedPTroopaOrigXPos)
    //> InitRedPTroopa:
    //> ldy #$30                    ;load central position adder for 48 pixels down
    Y = 0x30
    //> lda Enemy_Y_Position,x      ;set vertical coordinate into location to
    A = enemyYPosition[X]
    //> sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
    redPTroopaOrigXPos[X] = A
    //> bpl GetCent                 ;if vertical coordinate < $80
    X = X
    if ((A and 0x80) != 0) {
        //> ldy #$e0                    ;if => $80, load position adder for 32 pixels up
        Y = 0xE0
    }
    //> GetCent:  tya                         ;send central position adder to A
    A = Y
    //> adc Enemy_Y_Position,x      ;add to current vertical coordinate
    temp0 = A + enemyYPosition[X]
    A = temp0 and 0xFF
    //> sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
    redPTroopaCenterYPos[X] = A
    //  Fall-through tail call to tallBBox
    return tallBBox(X)
}

// Decompiled from TallBBox
fun tallBBox(X: Int): Int {
    var A: Int = 0
    //> TallBBox: lda #$03                    ;set specific bounding box size control
    A = 0x03
    //  Fall-through tail call to setBBox
    return setBBox(A, X)
}

// Decompiled from SetBBox
fun setBBox(A: Int, X: Int): Int {
    var A: Int = A
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
    enemyBoundboxctrl[X] = A
    //> lda #$02                    ;set moving direction for left
    A = 0x02
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = A
    //  Fall-through tail call to initVStf
    return initVStf(X)
}

// Decompiled from InitVStf
fun initVStf(X: Int): Int {
    var A: Int = 0
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> InitVStf: lda #$00                    ;initialize vertical speed
    A = 0x00
    //> sta Enemy_Y_Speed,x         ;and movement force
    enemyYSpeed[X] = A
    //> sta Enemy_Y_MoveForce,x
    enemyYMoveforce[X] = A
    //> rts
    return A
}

// Decompiled from InitBulletBill
fun initBulletBill(X: Int) {
    var A: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> InitBulletBill:
    //> lda #$02                  ;set moving direction for left
    A = 0x02
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = A
    //> lda #$09                  ;set bounding box control for $09
    A = 0x09
    //> sta Enemy_BoundBoxCtrl,x
    enemyBoundboxctrl[X] = A
    //> rts
    return
}

// Decompiled from InitCheepCheep
fun initCheepCheep(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val cheepCheepMoveMFlag by MemoryByteIndexed(CheepCheepMoveMFlag)
    val cheepCheepOrigYPos by MemoryByteIndexed(CheepCheepOrigYPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> InitCheepCheep:
    //> jsr SmallBBox              ;set vertical bounding box, speed, init others
    temp0 = smallBBox(X)
    //> lda PseudoRandomBitReg,x   ;check one portion of LSFR
    A = pseudoRandomBitReg[X]
    //> and #%00010000             ;get d4 from it
    A = A and 0x10
    //> sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
    cheepCheepMoveMFlag[X] = A
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
    cheepCheepOrigYPos[X] = A
    //> rts
    return
}

// Decompiled from InitLakitu
fun initLakitu(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    //> InitLakitu:
    //> lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
    A = enemyFrenzyBuffer
    //> bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
    X = X
    if (A == 0) {
        //  Fall-through tail call to setupLakitu
        setupLakitu(X)
        return A
    } else {
        //> KillLakitu:
        //> jmp EraseEnemyObject
        return eraseEnemyObject(X)
    }
}

// Decompiled from SetupLakitu
fun setupLakitu(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var lakituReappearTimer by MemoryByte(LakituReappearTimer)
    //> SetupLakitu:
    //> lda #$00                   ;erase counter for lakitu's reappearance
    A = 0x00
    //> sta LakituReappearTimer
    lakituReappearTimer = A
    //> jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
    temp0 = initHorizFlySwimEnemy(X)
    //> jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
    tallBBox2(X)
    return
}

// Decompiled from LakituAndSpinyHandler
fun lakituAndSpinyHandler(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var lakituReappearTimer by MemoryByte(LakituReappearTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val pRDiffAdjustData by MemoryByteIndexed(PRDiffAdjustData)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> LakituAndSpinyHandler:
    //> lda FrenzyEnemyTimer    ;if timer here not expired, leave
    A = frenzyEnemyTimer
    //> bne ExLSHand
    X = X
    if (A == 0) {
        //> cpx #$05                ;if we are on the special use slot, leave
        //> bcs ExLSHand
        if (!(X >= 0x05)) {
            //> lda #$80                ;set timer
            A = 0x80
            //> sta FrenzyEnemyTimer
            frenzyEnemyTimer = A
            //> ldy #$04                ;start with the last enemy slot
            Y = 0x04
            loop0@ while (Y != 0) {
                //> dey                     ;otherwise check another slot
                Y = (Y - 1) and 0xFF
                //> bpl ChkLak              ;loop until all slots are checked
                if (!((Y and 0x80) != 0)) {
                    //  continue loop (branch back to ChkLak)
                    continue@loop0
                }
            }
            //> inc LakituReappearTimer ;increment reappearance timer
            lakituReappearTimer = (lakituReappearTimer + 1) and 0xFF
            //> lda LakituReappearTimer
            A = lakituReappearTimer
            //> cmp #$07                ;check to see if we're up to a certain value yet
            //> bcc ExLSHand            ;if not, leave
            if (A >= 0x07) {
                //> ldx #$04                ;start with the last enemy slot again
                X = 0x04
                loop1@ while (X != 0) {
                    //> dex                     ;otherwise check next slot
                    X = (X - 1) and 0xFF
                    //> bpl ChkNoEn             ;branch until all slots are checked
                    if (!((X and 0x80) != 0)) {
                        //  continue loop (branch back to ChkNoEn)
                        continue@loop1
                    }
                }
                //> bmi RetEOfs             ;if no empty slots were found, branch to leave
                if ((X and 0x80) == 0) {
                    //> CreateL:  lda #$00                ;initialize enemy state
                    A = 0x00
                    //> sta Enemy_State,x
                    enemyState[X] = A
                    //> lda #Lakitu             ;create lakitu enemy object
                    A = Lakitu
                    //> sta Enemy_ID,x
                    enemyId[X] = A
                    //> jsr SetupLakitu         ;do a sub to set up lakitu
                    setupLakitu(X)
                    //> lda #$20
                    A = 0x20
                    //> jsr PutAtRightExtent    ;finish setting up lakitu
                    temp0 = putAtRightExtent(A, X)
                }
                //> RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
                X = objectOffset
            }
        }
    }
    //> ExLSHand: rts
    return
    //> CreateSpiny:
    //> lda Player_Y_Position      ;if player above a certain point, branch to leave
    A = playerYPosition
    //> cmp #$2c
    //> bcc ExLSHand
    if (!(A >= 0x2C)) {
    }
    //> lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
    A = enemyState[Y]
    //> bne ExLSHand
    if (A != 0) {
    }
    //> lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
    A = enemyPageloc[Y]
    //> sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
    enemyPageloc[X] = A
    //> lda Enemy_X_Position,y
    A = enemyXPosition[Y]
    //> sta Enemy_X_Position,x
    enemyXPosition[X] = A
    //> lda #$01                   ;put spiny within vertical screen unit
    A = 0x01
    //> sta Enemy_Y_HighPos,x
    enemyYHighpos[X] = A
    //> lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
    A = enemyYPosition[Y]
    //> sec
    //> sbc #$08
    temp1 = A - 0x08
    A = temp1 and 0xFF
    //> sta Enemy_Y_Position,x
    enemyYPosition[X] = A
    //> lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
    A = pseudoRandomBitReg[X]
    //> and #%00000011
    A = A and 0x03
    //> tay
    Y = A
    //> ldx #$02
    X = 0x02
    loop2@ do {
        //> DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
        A = pRDiffAdjustData[Y]
        //> sta $01,x                  ;to $01-$03
        memory[0x1 + X] = A.toUByte()
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                        ;increment Y four bytes for each value
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> dex                        ;decrement X for each one
        X = (X - 1) and 0xFF
        //> bpl DifLoop                ;loop until all three are written
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to DifLoop)
            continue@loop2
        }
    } while ((X and 0x80) == 0)
    //> ldx ObjectOffset           ;get enemy object buffer offset
    X = objectOffset
    //> jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
    temp2 = playerLakituDiff(X)
    //> ldy Player_X_Speed         ;check player's horizontal speed
    Y = playerXSpeed
    //> cpy #$08
    //> bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
    A = temp2
    if (!(Y >= 0x08)) {
        //> tay                        ;otherwise save value in A to Y for now
        Y = A
        //> lda PseudoRandomBitReg+1,x
        A = pseudoRandomBitReg[1 + X]
        //> and #%00000011             ;get one of the LSFR parts and save the 2 LSB
        A = A and 0x03
        //> beq UsePosv                ;branch if neither bits are set
        if (A != 0) {
            //> tya
            A = Y
            //> eor #%11111111             ;otherwise get two's compliment of Y
            A = A xor 0xFF
            //> tay
            Y = A
            //> iny
            Y = (Y + 1) and 0xFF
        }
        //> UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
        A = Y
    }
    //> SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
    temp3 = smallBBox(X)
    //> ldy #$02
    Y = 0x02
    //> sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
    enemyXSpeed[X] = temp3
    //> cmp #$00                   ;of A were lost...branch here will never be taken for
    //> bmi SpinyRte               ;the same reason
    A = temp3
    if ((temp3 and 0xFF and 0x80) == 0) {
        //> dey
        Y = (Y - 1) and 0xFF
    }
    //> SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
    enemyMovingdir[X] = Y
    //> lda #$fd
    A = 0xFD
    //> sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
    enemyYSpeed[X] = A
    //> lda #$01
    A = 0x01
    //> sta Enemy_Flag,x           ;enable enemy object by setting flag
    enemyFlag[X] = A
    //> lda #$05
    A = 0x05
    //> sta Enemy_State,x          ;put spiny in egg state and leave
    enemyState[X] = A
    //  Fall-through tail call to chpChpEx
    chpChpEx()
    return
}

// Decompiled from ChpChpEx
fun chpChpEx() {
    //> ChpChpEx: rts
    return
}

// Decompiled from InitLongFirebar
fun initLongFirebar(X: Int) {
    //> InitLongFirebar:
    //> jsr DuplicateEnemyObj       ;create enemy object for long firebar
    duplicateEnemyObj(X)
    //  Fall-through tail call to initShortFirebar
    initShortFirebar(X)
    return
}

// Decompiled from InitShortFirebar
fun initShortFirebar(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val firebarSpinDirData by MemoryByteIndexed(FirebarSpinDirData)
    val firebarSpinDirection by MemoryByteIndexed(FirebarSpinDirection)
    val firebarSpinSpdData by MemoryByteIndexed(FirebarSpinSpdData)
    val firebarSpinSpeed by MemoryByteIndexed(FirebarSpinSpeed)
    val firebarspinstateLow by MemoryByteIndexed(FirebarSpinState_Low)
    //> InitShortFirebar:
    //> lda #$00                    ;initialize low byte of spin state
    A = 0x00
    //> sta FirebarSpinState_Low,x
    firebarspinstateLow[X] = A
    //> lda Enemy_ID,x              ;subtract $1b from enemy identifier
    A = enemyId[X]
    //> sec                         ;to get proper offset for firebar data
    //> sbc #$1b
    temp0 = A - 0x1B
    A = temp0 and 0xFF
    //> tay
    Y = A
    //> lda FirebarSpinSpdData,y    ;get spinning speed of firebar
    A = firebarSpinSpdData[Y]
    //> sta FirebarSpinSpeed,x
    firebarSpinSpeed[X] = A
    //> lda FirebarSpinDirData,y    ;get spinning direction of firebar
    A = firebarSpinDirData[Y]
    //> sta FirebarSpinDirection,x
    firebarSpinDirection[X] = A
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> clc                         ;add four pixels to vertical coordinate
    //> adc #$04
    temp1 = A + 0x04
    A = temp1 and 0xFF
    //> sta Enemy_Y_Position,x
    enemyYPosition[X] = A
    //> lda Enemy_X_Position,x
    A = enemyXPosition[X]
    //> clc                         ;add four pixels to horizontal coordinate
    //> adc #$04
    temp2 = A + 0x04
    A = temp2 and 0xFF
    //> sta Enemy_X_Position,x
    enemyXPosition[X] = A
    //> lda Enemy_PageLoc,x
    A = enemyPageloc[X]
    //> adc #$00                    ;add carry to page location
    temp3 = A + if (temp2 > 0xFF) 1 else 0
    A = temp3 and 0xFF
    //> sta Enemy_PageLoc,x
    enemyPageloc[X] = A
    //> jmp TallBBox2               ;set bounding box control (not used) and leave
    tallBBox2(X)
    return
}

// Decompiled from InitFlyingCheepCheep
fun initFlyingCheepCheep(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val flyCCTimerData by MemoryByteIndexed(FlyCCTimerData)
    val flyCCXPositionData by MemoryByteIndexed(FlyCCXPositionData)
    val flyCCXSpeedData by MemoryByteIndexed(FlyCCXSpeedData)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> InitFlyingCheepCheep:
    //> lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
    A = frenzyEnemyTimer
    //> bne ChpChpEx
    X = X
    if (A != 0) {
        //> ChpChpEx: rts
        return
    } else {
        //> jsr SmallBBox              ;jump to set bounding box size $09 and init other values
        temp0 = smallBBox(X)
        //> lda PseudoRandomBitReg+1,x
        A = pseudoRandomBitReg[1 + X]
        //> and #%00000011             ;set pseudorandom offset here
        A = A and 0x03
        //> tay
        Y = A
        //> lda FlyCCTimerData,y       ;load timer with pseudorandom offset
        A = flyCCTimerData[Y]
        //> sta FrenzyEnemyTimer
        frenzyEnemyTimer = A
        //> ldy #$03                   ;load Y with default value
        Y = 0x03
        //> lda SecondaryHardMode
        A = secondaryHardMode
        //> beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
        if (A != 0) {
            //> iny                        ;otherwise, increment Y to allow as many as four onscreen
            Y = (Y + 1) and 0xFF
        }
    }
    //> MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
    memory[0x0] = Y.toUByte()
    //> cpx $00                    ;compare enemy object buffer offset with Y
    //> bcs ChpChpEx               ;if X => Y, branch to leave
    if (X >= memory[0x0].toInt()) {
        //> ChpChpEx: rts
        return
    } else {
        //> lda PseudoRandomBitReg,x
        A = pseudoRandomBitReg[X]
        //> and #%00000011             ;get last two bits of LSFR, first part
        A = A and 0x03
        //> sta $00                    ;and store in two places
        memory[0x0] = A.toUByte()
        //> sta $01
        memory[0x1] = A.toUByte()
        //> lda #$fb                   ;set vertical speed for cheep-cheep
        A = 0xFB
        //> sta Enemy_Y_Speed,x
        enemyYSpeed[X] = A
        //> lda #$00                   ;load default value
        A = 0x00
        //> ldy Player_X_Speed         ;check player's horizontal speed
        Y = playerXSpeed
        //> beq GSeed                  ;if player not moving left or right, skip this part
        if (Y != 0) {
            //> lda #$04
            A = 0x04
            //> cpy #$19                   ;if moving to the right but not very quickly,
            //> bcc GSeed                  ;do not change A
            if (Y >= 0x19) {
                //> asl                        ;otherwise, multiply A by 2
                val orig0: Int = A
                A = (orig0 shl 1) and 0xFF
            }
        }
    }
    //> GSeed:   pha                        ;save to stack
    push(A)
    //> clc
    //> adc $00                    ;add to last two bits of LSFR we saved earlier
    temp1 = A + memory[0x0].toInt()
    A = temp1 and 0xFF
    //> sta $00                    ;save it there
    memory[0x0] = A.toUByte()
    //> lda PseudoRandomBitReg+1,x
    A = pseudoRandomBitReg[1 + X]
    //> and #%00000011             ;if neither of the last two bits of second LSFR set,
    A = A and 0x03
    //> beq RSeed                  ;skip this part and save contents of $00
    if (A != 0) {
        //> lda PseudoRandomBitReg+2,x
        A = pseudoRandomBitReg[2 + X]
        //> and #%00001111             ;otherwise overwrite with lower nybble of
        A = A and 0x0F
        //> sta $00                    ;third LSFR part
        memory[0x0] = A.toUByte()
    }
    //> RSeed:   pla                        ;get value from stack we saved earlier
    A = pull()
    //> clc
    //> adc $01                    ;add to last two bits of LSFR we saved in other place
    temp2 = A + memory[0x1].toInt()
    A = temp2 and 0xFF
    //> tay                        ;use as pseudorandom offset here
    Y = A
    //> lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
    A = flyCCXSpeedData[Y]
    //> sta Enemy_X_Speed,x
    enemyXSpeed[X] = A
    //> lda #$01                   ;set to move towards the right
    A = 0x01
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = A
    //> lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
    A = playerXSpeed
    //> bne D2XPos1
    if (A == 0) {
        //> ldy $00                    ;get first LSFR or third LSFR lower nybble
        Y = memory[0x0].toInt()
        //> tya                        ;and check for d1 set
        A = Y
        //> and #%00000010
        A = A and 0x02
        //> beq D2XPos1                ;if d1 not set, branch
        if (A != 0) {
            //> lda Enemy_X_Speed,x
            A = enemyXSpeed[X]
            //> eor #$ff                   ;if d1 set, change horizontal speed
            A = A xor 0xFF
            //> clc                        ;into two's compliment, thus moving in the opposite
            //> adc #$01                   ;direction
            temp3 = A + 0x01
            A = temp3 and 0xFF
            //> sta Enemy_X_Speed,x
            enemyXSpeed[X] = A
            //> inc Enemy_MovingDir,x      ;increment to move towards the left
            enemyMovingdir[X] = (enemyMovingdir[X] + 1) and 0xFF
        }
    }
    //> D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
    A = Y
    //> and #%00000010
    A = A and 0x02
    //> beq D2XPos2                ;check for d1 set again, branch again if not set
    if (A != 0) {
        //> lda Player_X_Position      ;get player's horizontal position
        A = playerXPosition
        //> clc
        //> adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
        temp4 = A + flyCCXPositionData[Y]
        A = temp4 and 0xFF
        //> sta Enemy_X_Position,x     ;and save as enemy's horizontal position
        enemyXPosition[X] = A
        //> lda Player_PageLoc         ;get player's page location
        A = playerPageloc
        //> adc #$00                   ;add carry and jump past this part
        temp5 = A + if (temp4 > 0xFF) 1 else 0
        A = temp5 and 0xFF
        //> jmp FinCCSt
        finCCSt(A, X)
        return
    } else {
        //> D2XPos2: lda Player_X_Position      ;get player's horizontal position
        A = playerXPosition
        //> sec
        //> sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
        temp6 = A - flyCCXPositionData[Y]
        A = temp6 and 0xFF
        //> sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
        enemyXPosition[X] = A
        //> lda Player_PageLoc         ;get player's page location
        A = playerPageloc
        //> sbc #$00                   ;subtract borrow
        temp7 = A - if (temp6 >= 0) 0 else 1
        A = temp7 and 0xFF
        //  Fall-through tail call to finCCSt
        finCCSt(A, X)
        return
    }
}

// Decompiled from FinCCSt
fun finCCSt(A: Int, X: Int) {
    var A: Int = A
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
    enemyPageloc[X] = A
    //> lda #$01
    A = 0x01
    //> sta Enemy_Flag,x           ;set enemy's buffer flag
    enemyFlag[X] = A
    //> sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
    enemyYHighpos[X] = A
    //> lda #$f8
    A = 0xF8
    //> sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
    enemyYPosition[X] = A
    //> rts
    return
}

// Decompiled from InitBowser
fun initBowser(X: Int) {
    var A: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFeetCounter by MemoryByte(BowserFeetCounter)
    var bowserFireBreathTimer by MemoryByte(BowserFireBreathTimer)
    var bowserfrontOffset by MemoryByte(BowserFront_Offset)
    var bowserHitPoints by MemoryByte(BowserHitPoints)
    var bowserMovementSpeed by MemoryByte(BowserMovementSpeed)
    var bowserOrigXPos by MemoryByte(BowserOrigXPos)
    var bridgeCollapseOffset by MemoryByte(BridgeCollapseOffset)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> InitBowser:
    //> jsr DuplicateEnemyObj     ;jump to create another bowser object
    duplicateEnemyObj(X)
    //> stx BowserFront_Offset    ;save offset of first here
    bowserfrontOffset = X
    //> lda #$00
    A = 0x00
    //> sta BowserBodyControls    ;initialize bowser's body controls
    bowserBodyControls = A
    //> sta BridgeCollapseOffset  ;and bridge collapse offset
    bridgeCollapseOffset = A
    //> lda Enemy_X_Position,x
    A = enemyXPosition[X]
    //> sta BowserOrigXPos        ;store original horizontal position here
    bowserOrigXPos = A
    //> lda #$df
    A = 0xDF
    //> sta BowserFireBreathTimer ;store something here
    bowserFireBreathTimer = A
    //> sta Enemy_MovingDir,x     ;and in moving direction
    enemyMovingdir[X] = A
    //> lda #$20
    A = 0x20
    //> sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
    bowserFeetCounter = A
    //> sta EnemyFrameTimer,x
    enemyFrameTimer[X] = A
    //> lda #$05
    A = 0x05
    //> sta BowserHitPoints       ;give bowser 5 hit points
    bowserHitPoints = A
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> sta BowserMovementSpeed   ;set default movement speed here
    bowserMovementSpeed = A
    //> rts
    return
}

// Decompiled from DuplicateEnemyObj
fun duplicateEnemyObj(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> DuplicateEnemyObj:
    //> ldy #$ff                ;start at beginning of enemy slots
    Y = 0xFF
    X = X
    loop0@ do {
        //> FSLoop: iny                     ;increment one slot
        Y = (Y + 1) and 0xFF
        //> lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
        A = enemyFlag[Y]
        //> bne FSLoop              ;if set, branch and keep checking
        if (!(A == 0)) {
            //  continue loop (branch back to FSLoop)
            continue@loop0
        }
    } while (A != 0)
    //> sty DuplicateObj_Offset ;otherwise set offset here
    duplicateobjOffset = Y
    //> txa                     ;transfer original enemy buffer offset
    A = X
    //> ora #%10000000          ;store with d7 set as flag in new enemy
    A = A or 0x80
    //> sta Enemy_Flag,y        ;slot as well as enemy offset
    enemyFlag[Y] = A
    //> lda Enemy_PageLoc,x
    A = enemyPageloc[X]
    //> sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
    enemyPageloc[Y] = A
    //> lda Enemy_X_Position,x  ;from original enemy to new enemy
    A = enemyXPosition[X]
    //> sta Enemy_X_Position,y
    enemyXPosition[Y] = A
    //> lda #$01
    A = 0x01
    //> sta Enemy_Flag,x        ;set flag as normal for original enemy
    enemyFlag[X] = A
    //> sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
    enemyYHighpos[Y] = A
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
    enemyYPosition[Y] = A
    //  Fall-through tail call to flmEx
    flmEx()
    return
}

// Decompiled from FlmEx
fun flmEx() {
    //> FlmEx:  rts                     ;and then leave
    return
}

// Decompiled from InitBowserFlame
fun initBowserFlame(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var bowserfrontOffset by MemoryByte(BowserFront_Offset)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val bowserFlamePRandomOfs by MemoryByteIndexed(BowserFlamePRandomOfs)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flameYMFAdderData by MemoryByteIndexed(FlameYMFAdderData)
    val flameYPosData by MemoryByteIndexed(FlameYPosData)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> InitBowserFlame:
    //> lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
    A = frenzyEnemyTimer
    //> bne FlmEx
    X = X
    if (A != 0) {
        //> FlmEx:  rts                     ;and then leave
        return A
    } else {
        //> sta Enemy_Y_MoveForce,x     ;reset something here
        enemyYMoveforce[X] = A
        //> lda NoiseSoundQueue
        A = noiseSoundQueue
        //> ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
        A = A or Sfx_BowserFlame
        //> sta NoiseSoundQueue
        noiseSoundQueue = A
        //> ldy BowserFront_Offset      ;get bowser's buffer offset
        Y = bowserfrontOffset
        //> lda Enemy_ID,y              ;check for bowser
        A = enemyId[Y]
        //> cmp #Bowser
        //> beq SpawnFromMouth          ;branch if found
        if (A != Bowser) {
            //> jsr SetFlameTimer           ;get timer data based on flame counter
            temp0 = setFlameTimer()
            //> clc
            //> adc #$20                    ;add 32 frames by default
            temp1 = temp0 + 0x20
            A = temp1 and 0xFF
            //> ldy SecondaryHardMode
            Y = secondaryHardMode
            //> beq SetFrT                  ;if secondary mode flag not set, use as timer setting
            if (Y != 0) {
                //> sec
                //> sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
                temp2 = A - 0x10
                A = temp2 and 0xFF
            }
            //> SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
            frenzyEnemyTimer = A
            //> lda PseudoRandomBitReg,x
            A = pseudoRandomBitReg[X]
            //> and #%00000011              ;get 2 LSB from first part of LSFR
            A = A and 0x03
            //> sta BowserFlamePRandomOfs,x ;set here
            bowserFlamePRandomOfs[X] = A
            //> tay                         ;use as offset
            Y = A
            //> lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
            A = flameYPosData[Y]
            //  Fall-through tail call to putAtRightExtent
            return putAtRightExtent(A, X)
        }
    }
    //> SpawnFromMouth:
    //> lda Enemy_X_Position,y    ;get bowser's horizontal position
    A = enemyXPosition[Y]
    //> sec
    //> sbc #$0e                  ;subtract 14 pixels
    temp3 = A - 0x0E
    A = temp3 and 0xFF
    //> sta Enemy_X_Position,x    ;save as flame's horizontal position
    enemyXPosition[X] = A
    //> lda Enemy_PageLoc,y
    A = enemyPageloc[Y]
    //> sta Enemy_PageLoc,x       ;copy page location from bowser to flame
    enemyPageloc[X] = A
    //> lda Enemy_Y_Position,y
    A = enemyYPosition[Y]
    //> clc                       ;add 8 pixels to bowser's vertical position
    //> adc #$08
    temp4 = A + 0x08
    A = temp4 and 0xFF
    //> sta Enemy_Y_Position,x    ;save as flame's vertical position
    enemyYPosition[X] = A
    //> lda PseudoRandomBitReg,x
    A = pseudoRandomBitReg[X]
    //> and #%00000011            ;get 2 LSB from first part of LSFR
    A = A and 0x03
    //> sta Enemy_YMF_Dummy,x     ;save here
    enemyYmfDummy[X] = A
    //> tay                       ;use as offset
    Y = A
    //> lda FlameYPosData,y       ;get value here using bits as offset
    A = flameYPosData[Y]
    //> ldy #$00                  ;load default offset
    Y = 0x00
    //> cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
    //> bcc SetMF                 ;if less, do not increment offset
    if (A >= enemyYPosition[X]) {
        //> iny                       ;otherwise increment now
        Y = (Y + 1) and 0xFF
    }
    //> SetMF: lda FlameYMFAdderData,y   ;get value here and save
    A = flameYMFAdderData[Y]
    //> sta Enemy_Y_MoveForce,x   ;to vertical movement force
    enemyYMoveforce[X] = A
    //> lda #$00
    A = 0x00
    //> sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
    enemyFrenzyBuffer = A
    //  Fall-through tail call to finishFlame
    return finishFlame(X)
}

// Decompiled from PutAtRightExtent
fun putAtRightExtent(A: Int, X: Int): Int {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> PutAtRightExtent:
    //> sta Enemy_Y_Position,x    ;set vertical position
    enemyYPosition[X] = A
    //> lda ScreenRight_X_Pos
    A = screenrightXPos
    //> clc
    //> adc #$20                  ;place enemy 32 pixels beyond right side of screen
    temp0 = A + 0x20
    A = temp0 and 0xFF
    //> sta Enemy_X_Position,x
    enemyXPosition[X] = A
    //> lda ScreenRight_PageLoc
    A = screenrightPageloc
    //> adc #$00                  ;add carry
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta Enemy_PageLoc,x
    enemyPageloc[X] = A
    //> jmp FinishFlame           ;skip this part to finish setting values
    return finishFlame(X)
}

// Decompiled from FinishFlame
fun finishFlame(X: Int): Int {
    var A: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXMoveforce by MemoryByteIndexed(Enemy_X_MoveForce)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    //> FinishFlame:
    //> lda #$08                 ;set $08 for bounding box control
    A = 0x08
    //> sta Enemy_BoundBoxCtrl,x
    enemyBoundboxctrl[X] = A
    //> lda #$01                 ;set high byte of vertical and
    A = 0x01
    //> sta Enemy_Y_HighPos,x    ;enemy buffer flag
    enemyYHighpos[X] = A
    //> sta Enemy_Flag,x
    enemyFlag[X] = A
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
    enemyXMoveforce[X] = A
    //> sta Enemy_State,x        ;enemy state
    enemyState[X] = A
    //> rts
    return A
}

// Decompiled from InitFireworks
fun initFireworks(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var fireworksCounter by MemoryByte(FireworksCounter)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val explosionGfxCounter by MemoryByteIndexed(ExplosionGfxCounter)
    val explosionTimerCounter by MemoryByteIndexed(ExplosionTimerCounter)
    val fireworksXPosData by MemoryByteIndexed(FireworksXPosData)
    val fireworksYPosData by MemoryByteIndexed(FireworksYPosData)
    //> InitFireworks:
    //> lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
    A = frenzyEnemyTimer
    //> bne ExitFWk
    X = X
    if (A == 0) {
        //> lda #$20                     ;otherwise reset timer
        A = 0x20
        //> sta FrenzyEnemyTimer
        frenzyEnemyTimer = A
        //> dec FireworksCounter         ;decrement for each explosion
        fireworksCounter = (fireworksCounter - 1) and 0xFF
        //> ldy #$06                     ;start at last slot
        Y = 0x06
        loop0@ do {
            //> StarFChk: dey
            Y = (Y - 1) and 0xFF
            //> lda Enemy_ID,y               ;check for presence of star flag object
            A = enemyId[Y]
            //> cmp #StarFlagObject          ;if there isn't a star flag object,
            //> bne StarFChk                 ;routine goes into infinite loop = crash
            if (!(A == StarFlagObject)) {
                //  continue loop (branch back to StarFChk)
                continue@loop0
            }
        } while (A != StarFlagObject)
        //> lda Enemy_X_Position,y
        A = enemyXPosition[Y]
        //> sec                          ;get horizontal coordinate of star flag object, then
        //> sbc #$30                     ;subtract 48 pixels from it and save to
        temp0 = A - 0x30
        A = temp0 and 0xFF
        //> pha                          ;the stack
        push(A)
        //> lda Enemy_PageLoc,y
        A = enemyPageloc[Y]
        //> sbc #$00                     ;subtract the carry from the page location
        temp1 = A - if (temp0 >= 0) 0 else 1
        A = temp1 and 0xFF
        //> sta $00                      ;of the star flag object
        memory[0x0] = A.toUByte()
        //> lda FireworksCounter         ;get fireworks counter
        A = fireworksCounter
        //> clc
        //> adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
        temp2 = A + enemyState[Y]
        A = temp2 and 0xFF
        //> tay                          ;use as offset
        Y = A
        //> pla                          ;get saved horizontal coordinate of star flag - 48 pixels
        A = pull()
        //> clc
        //> adc FireworksXPosData,y      ;add number based on offset of fireworks counter
        temp3 = A + fireworksXPosData[Y]
        A = temp3 and 0xFF
        //> sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
        enemyXPosition[X] = A
        //> lda $00
        A = memory[0x0].toInt()
        //> adc #$00                     ;add carry and store as page location for
        temp4 = A + if (temp3 > 0xFF) 1 else 0
        A = temp4 and 0xFF
        //> sta Enemy_PageLoc,x          ;the fireworks object
        enemyPageloc[X] = A
        //> lda FireworksYPosData,y      ;get vertical position using same offset
        A = fireworksYPosData[Y]
        //> sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
        enemyYPosition[X] = A
        //> lda #$01
        A = 0x01
        //> sta Enemy_Y_HighPos,x        ;store in vertical high byte
        enemyYHighpos[X] = A
        //> sta Enemy_Flag,x             ;and activate enemy buffer flag
        enemyFlag[X] = A
        //> lsr
        val orig0: Int = A
        A = orig0 shr 1
        //> sta ExplosionGfxCounter,x    ;initialize explosion counter
        explosionGfxCounter[X] = A
        //> lda #$08
        A = 0x08
        //> sta ExplosionTimerCounter,x  ;set explosion timing counter
        explosionTimerCounter[X] = A
    }
    //> ExitFWk:  rts
    return
}

// Decompiled from BulletBillCheepCheep
fun bulletBillCheepCheep(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var exitFlag0: Boolean = false
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    var bitMFilter by MemoryByte(BitMFilter)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var worldNumber by MemoryByte(WorldNumber)
    val bitmasks by MemoryByteIndexed(Bitmasks)
    val enemy17YPosData by MemoryByteIndexed(Enemy17YPosData)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    val swimccIddata by MemoryByteIndexed(SwimCC_IDData)
    //> BulletBillCheepCheep:
    //> lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
    A = frenzyEnemyTimer
    //> bne ExF17
    X = X
    if (A == 0) {
        //> lda AreaType              ;are we in a water-type level?
        A = areaType
        //> bne DoBulletBills         ;if not, branch elsewhere
        if (A == 0) {
            //> cpx #$03                  ;are we past third enemy slot?
            //> bcs ExF17                 ;if so, branch to leave
            if (!(X >= 0x03)) {
                //> ldy #$00                  ;load default offset
                Y = 0x00
                //> lda PseudoRandomBitReg,x
                A = pseudoRandomBitReg[X]
                //> cmp #$aa                  ;check first part of LSFR against preset value
                //> bcc ChkW2                 ;if less than preset, do not increment offset
                if (A >= 0xAA) {
                    //> iny                       ;otherwise increment
                    Y = (Y + 1) and 0xFF
                }
                //> ChkW2:   lda WorldNumber           ;check world number
                A = worldNumber
                //> cmp #World2
                //> beq Get17ID               ;if we're on world 2, do not increment offset
                if (A != World2) {
                    //> iny                       ;otherwise increment
                    Y = (Y + 1) and 0xFF
                }
                //> Get17ID: tya
                A = Y
                //> and #%00000001            ;mask out all but last bit of offset
                A = A and 0x01
                //> tay
                Y = A
                //> lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
                A = swimccIddata[Y]
                //> Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
                enemyId[X] = A
                //> lda BitMFilter
                A = bitMFilter
                //> cmp #$ff                  ;if not all bits set, skip init part and compare bits
                //> bne GetRBit
                if (A == 0xFF) {
                    //> lda #$00                  ;initialize vertical position filter
                    A = 0x00
                    //> sta BitMFilter
                    bitMFilter = A
                }
                //> GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
                A = pseudoRandomBitReg[X]
                //> and #%00000111            ;mask out all but 3 LSB
                A = A and 0x07
                loop0@ while (A != 0) {
                    loop1@ while (true) {
                        //> ChkRBit: tay                       ;use as offset
                        Y = A
                        //> lda Bitmasks,y            ;load bitmask
                        A = bitmasks[Y]
                        //> bit BitMFilter            ;perform AND on filter without changing it
                        //> beq AddFBit
                        if ((A and bitMFilter) == 0) {
                            //  goto AddFBit
                            break@loop0
                        }
                        //> iny                       ;increment offset
                        Y = (Y + 1) and 0xFF
                        //> tya
                        A = Y
                        //> and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
                        A = A and 0x07
                        //> jmp ChkRBit               ;do another check
                        //> jmp ChkRBit (not a known function)
                    }
                }
                //> AddFBit: ora BitMFilter            ;add bit to already set bits in filter
                A = A or bitMFilter
                //> sta BitMFilter            ;and store
                bitMFilter = A
                //> lda Enemy17YPosData,y     ;load vertical position using offset
                A = enemy17YPosData[Y]
                //> jsr PutAtRightExtent      ;set vertical position and other values
                temp0 = putAtRightExtent(A, X)
                //> sta Enemy_YMF_Dummy,x     ;initialize dummy variable
                enemyYmfDummy[X] = temp0
                //> lda #$20                  ;set timer
                A = 0x20
                //> sta FrenzyEnemyTimer
                frenzyEnemyTimer = A
                //> jmp CheckpointEnemyID     ;process our new enemy object
                checkpointEnemyID(X)
                return X
            }
        }
        //> DoBulletBills:
        //> ldy #$ff                   ;start at beginning of enemy slots
        Y = 0xFF
        loop2@ while (!(Y >= 0x05)) {
            //> lda Enemy_Flag,y           ;if enemy buffer flag not set,
            A = enemyFlag[Y]
            //> beq BB_SLoop               ;loop back and check another slot
            if (A == 0) {
                //  continue loop (branch back to BB_SLoop)
                continue@loop2
            }
            //> lda Enemy_ID,y
            A = enemyId[Y]
            //> cmp #BulletBill_FrenzyVar  ;check enemy identifier for
            //> bne BB_SLoop               ;bullet bill object (frenzy variant)
            if (!(A == BulletBill_FrenzyVar)) {
                //  continue loop (branch back to BB_SLoop)
                continue@loop2
            }
        }
    }
    //> ExF17:    rts                        ;if found, leave
    if (exitFlag0) {
        //> FireBulletBill:
        //> lda Square2SoundQueue
        A = square2SoundQueue
        //> ora #Sfx_Blast            ;play fireworks/gunfire sound
        A = A or Sfx_Blast
        //> sta Square2SoundQueue
        square2SoundQueue = A
        //> lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
        A = BulletBill_FrenzyVar
        //> bne Set17ID               ;unconditional branch
        //> ;--------------------------------
        //> ;$00 - used to store Y position of group enemies
        //> ;$01 - used to store enemy ID
        //> ;$02 - used to store page location of right side of screen
        //> ;$03 - used to store X position of right side of screen
        //  Fall-through tail call to handleGroupEnemies
        return handleGroupEnemies(A)
    }
    return X
}

// Decompiled from HandleGroupEnemies
fun handleGroupEnemies(A: Int): Int {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var numberofGroupEnemies by MemoryByte(NumberofGroupEnemies)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> HandleGroupEnemies:
    //> ldy #$00                  ;load value for green koopa troopa
    Y = 0x00
    //> sec
    //> sbc #$37                  ;subtract $37 from second byte read
    temp0 = A - 0x37
    //> pha                       ;save result in stack for now
    push(temp0 and 0xFF)
    //> cmp #$04                  ;was byte in $3b-$3e range?
    //> bcs SnglID                ;if so, branch
    A = temp0 and 0xFF
    if (!((temp0 and 0xFF) >= 0x04)) {
        //> pha                       ;save another copy to stack
        push(A)
        //> ldy #Goomba               ;load value for goomba enemy
        Y = Goomba
        //> lda PrimaryHardMode       ;if primary hard mode flag not set,
        A = primaryHardMode
        //> beq PullID                ;branch, otherwise change to value
        if (A != 0) {
            //> ldy #BuzzyBeetle          ;for buzzy beetle
            Y = BuzzyBeetle
        }
        //> PullID: pla                       ;get second copy from stack
        A = pull()
    }
    //> SnglID: sty $01                   ;save enemy id here
    memory[0x1] = Y.toUByte()
    //> ldy #$b0                  ;load default y coordinate
    Y = 0xB0
    //> and #$02                  ;check to see if d1 was set
    A = A and 0x02
    //> beq SetYGp                ;if so, move y coordinate up,
    if (A != 0) {
        //> ldy #$70                  ;otherwise branch and use default
        Y = 0x70
    }
    //> SetYGp: sty $00                   ;save y coordinate here
    memory[0x0] = Y.toUByte()
    //> lda ScreenRight_PageLoc   ;get page number of right edge of screen
    A = screenrightPageloc
    //> sta $02                   ;save here
    memory[0x2] = A.toUByte()
    //> lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
    A = screenrightXPos
    //> sta $03                   ;save here
    memory[0x3] = A.toUByte()
    //> ldy #$02                  ;load two enemies by default
    Y = 0x02
    //> pla                       ;get first copy from stack
    A = pull()
    //> lsr                       ;check to see if d0 was set
    val orig0: Int = A
    A = orig0 shr 1
    //> bcc CntGrp                ;if not, use default value
    if ((orig0 and 0x01) != 0) {
        //> iny                       ;otherwise increment to three enemies
        Y = (Y + 1) and 0xFF
    }
    //> CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
    numberofGroupEnemies = Y
    loop0@ do {
        loop1@ while ((orig0 and 0x01) == 0) {
            //> lda Enemy_Flag,x          ;check to see if enemy is already
            A = enemyFlag[X]
            //> bne GSltLp                ;stored in buffer, and branch if so
            if (!(A == 0)) {
                //  continue loop (branch back to GSltLp)
                continue@loop1
            }
        }
        //> lda $01
        A = memory[0x1].toInt()
        //> sta Enemy_ID,x            ;store enemy object identifier
        enemyId[X] = A
        //> lda $02
        A = memory[0x2].toInt()
        //> sta Enemy_PageLoc,x       ;store page location for enemy object
        enemyPageloc[X] = A
        //> lda $03
        A = memory[0x3].toInt()
        //> sta Enemy_X_Position,x    ;store x coordinate for enemy object
        enemyXPosition[X] = A
        //> clc
        //> adc #$18                  ;add 24 pixels for next enemy
        temp1 = A + 0x18
        A = temp1 and 0xFF
        //> sta $03
        memory[0x3] = A.toUByte()
        //> lda $02                   ;add carry to page location for
        A = memory[0x2].toInt()
        //> adc #$00                  ;next enemy
        temp2 = A + if (temp1 > 0xFF) 1 else 0
        A = temp2 and 0xFF
        //> sta $02
        memory[0x2] = A.toUByte()
        //> lda $00                   ;store y coordinate for enemy object
        A = memory[0x0].toInt()
        //> sta Enemy_Y_Position,x
        enemyYPosition[X] = A
        //> lda #$01                  ;activate flag for buffer, and
        A = 0x01
        //> sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
        enemyYHighpos[X] = A
        //> sta Enemy_Flag,x
        enemyFlag[X] = A
        //> jsr CheckpointEnemyID     ;process each enemy object separately
        checkpointEnemyID(0)
        //> dec NumberofGroupEnemies  ;do this until we run out of enemy objects
        numberofGroupEnemies = (numberofGroupEnemies - 1) and 0xFF
        //> bne GrLoop
        if (!(numberofGroupEnemies == 0)) {
            //  continue loop (branch back to GrLoop)
            continue@loop0
        }
    } while (numberofGroupEnemies != 0)
    //> NextED: jmp Inc2B                 ;jump to increment data offset and leave
    return inc2B()
}

// Decompiled from InitPiranhaPlant
fun initPiranhaPlant(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val piranhaPlantDownYPos by MemoryByteIndexed(PiranhaPlantDownYPos)
    val piranhaPlantUpYPos by MemoryByteIndexed(PiranhaPlantUpYPos)
    val piranhaplantMoveflag by MemoryByteIndexed(PiranhaPlant_MoveFlag)
    val piranhaplantYSpeed by MemoryByteIndexed(PiranhaPlant_Y_Speed)
    //> InitPiranhaPlant:
    //> lda #$01                     ;set initial speed
    A = 0x01
    //> sta PiranhaPlant_Y_Speed,x
    piranhaplantYSpeed[X] = A
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> sta Enemy_State,x            ;initialize enemy state and what would normally
    enemyState[X] = A
    //> sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
    piranhaplantMoveflag[X] = A
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
    piranhaPlantDownYPos[X] = A
    //> sec
    //> sbc #$18
    temp0 = A - 0x18
    A = temp0 and 0xFF
    //> sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
    piranhaPlantUpYPos[X] = A
    //> lda #$09
    A = 0x09
    //> jmp SetBBox2                 ;set specific value for bounding box control
    setBBox2(A, X)
    return
}

// Decompiled from InitEnemyFrenzy
fun initEnemyFrenzy(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> InitEnemyFrenzy:
    //> lda Enemy_ID,x        ;load enemy identifier
    A = enemyId[X]
    //> sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
    enemyFrenzyBuffer = A
    //> sec
    //> sbc #$12              ;subtract 12 and use as offset for jump engine
    temp0 = A - 0x12
    A = temp0 and 0xFF
    //> jsr JumpEngine
    when (A) {
        0 -> {
            lakituAndSpinyHandler(X)
        }
        1 -> {
            noFrenzyCode()
        }
        2 -> {
            initFlyingCheepCheep(X)
        }
        3 -> {
            initBowserFlame(X)
        }
        4 -> {
            initFireworks(X)
        }
        5 -> {
            bulletBillCheepCheep(X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> ;frenzy object jump table
    //> .dw LakituAndSpinyHandler
    //> .dw NoFrenzyCode
    //> .dw InitFlyingCheepCheep
    //> .dw InitBowserFlame
    //> .dw InitFireworks
    //> .dw BulletBillCheepCheep
    //> ;--------------------------------
    //  Fall-through tail call to noFrenzyCode
    noFrenzyCode()
    return
}

// Decompiled from NoFrenzyCode
fun noFrenzyCode() {
    //> NoFrenzyCode:
    //> rts
    return
}

// Decompiled from EndFrenzy
fun endFrenzy(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> EndFrenzy:
    //> ldy #$05               ;start at last slot
    Y = 0x05
    X = X
    loop0@ do {
        //> LakituChk: lda Enemy_ID,y         ;check enemy identifiers
        A = enemyId[Y]
        //> cmp #Lakitu            ;for lakitu
        //> bne NextFSlot
        if (A == Lakitu) {
            //> lda #$01               ;if found, set state
            A = 0x01
            //> sta Enemy_State,y
            enemyState[Y] = A
        }
        //> NextFSlot: dey                    ;move onto the next slot
        Y = (Y - 1) and 0xFF
        //> bpl LakituChk          ;do this until all slots are checked
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to LakituChk)
            continue@loop0
        }
    } while ((Y and 0x80) == 0)
    //> lda #$00
    A = 0x00
    //> sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
    enemyFrenzyBuffer = A
    //> sta Enemy_Flag,x       ;disable enemy buffer flag for this object
    enemyFlag[X] = A
    //> rts
    return
}

// Decompiled from InitJumpGPTroopa
fun initJumpGPTroopa(X: Int) {
    var A: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> InitJumpGPTroopa:
    //> lda #$02                  ;set for movement to the left
    A = 0x02
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = A
    //> lda #$f8                  ;set horizontal speed
    A = 0xF8
    //> sta Enemy_X_Speed,x
    enemyXSpeed[X] = A
    //  Fall-through tail call to tallBBox2
    tallBBox2(X)
    return
}

// Decompiled from TallBBox2
fun tallBBox2(X: Int) {
    var A: Int = 0
    //> TallBBox2: lda #$03                  ;set specific value for bounding box control
    A = 0x03
    //  Fall-through tail call to setBBox2
    setBBox2(A, X)
    return
}

// Decompiled from SetBBox2
fun setBBox2(A: Int, X: Int) {
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    //> SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
    enemyBoundboxctrl[X] = A
    //> rts
    return
}

// Decompiled from InitBalPlatform
fun initBalPlatform(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var balPlatformAlignment by MemoryByte(BalPlatformAlignment)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> InitBalPlatform:
    //> dec Enemy_Y_Position,x    ;raise vertical position by two pixels
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> dec Enemy_Y_Position,x
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> ldy SecondaryHardMode     ;if secondary hard mode flag not set,
    Y = secondaryHardMode
    //> bne AlignP                ;branch ahead
    X = X
    if (Y == 0) {
        //> ldy #$02                  ;otherwise set value here
        Y = 0x02
        //> jsr PosPlatform           ;do a sub to add or subtract pixels
        posPlatform(X, Y)
    }
    //> AlignP: ldy #$ff                  ;set default value here for now
    Y = 0xFF
    //> lda BalPlatformAlignment  ;get current balance platform alignment
    A = balPlatformAlignment
    //> sta Enemy_State,x         ;set platform alignment to object state here
    enemyState[X] = A
    //> bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
    if ((A and 0x80) != 0) {
        //> txa                       ;if old contents already $ff, put
        A = X
        //> tay                       ;object offset as alignment to make next positive
        Y = A
    }
    //> SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
    balPlatformAlignment = Y
    //> lda #$00
    A = 0x00
    //> sta Enemy_MovingDir,x     ;init moving direction
    enemyMovingdir[X] = A
    //> tay                       ;init Y
    Y = A
    //> jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
    posPlatform(X, Y)
    //> ;--------------------------------
    //  Fall-through tail call to initDropPlatform
    initDropPlatform(X)
    return
}

// Decompiled from InitDropPlatform
fun initDropPlatform(X: Int) {
    var A: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> InitDropPlatform:
    //> lda #$ff
    A = 0xFF
    //> sta PlatformCollisionFlag,x  ;set some value here
    platformCollisionFlag[X] = A
    //> jmp CommonPlatCode           ;then jump ahead to execute more code
    commonPlatCode(X)
    return
}

// Decompiled from InitHoriPlatform
fun initHoriPlatform(X: Int) {
    var A: Int = 0
    val xMoveSecondaryCounter by MemoryByteIndexed(XMoveSecondaryCounter)
    //> InitHoriPlatform:
    //> lda #$00
    A = 0x00
    //> sta XMoveSecondaryCounter,x  ;init one of the moving counters
    xMoveSecondaryCounter[X] = A
    //> jmp CommonPlatCode           ;jump ahead to execute more code
    commonPlatCode(X)
    return
}

// Decompiled from InitVertPlatform
fun initVertPlatform(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val yPlatformCenterYPos by MemoryByteIndexed(YPlatformCenterYPos)
    val yPlatformTopYPos by MemoryByteIndexed(YPlatformTopYPos)
    //> InitVertPlatform:
    //> ldy #$40                    ;set default value here
    Y = 0x40
    //> lda Enemy_Y_Position,x      ;check vertical position
    A = enemyYPosition[X]
    //> bpl SetYO                   ;if above a certain point, skip this part
    X = X
    if ((A and 0x80) != 0) {
        //> eor #$ff
        A = A xor 0xFF
        //> clc                         ;otherwise get two's compliment
        //> adc #$01
        temp0 = A + 0x01
        A = temp0 and 0xFF
        //> ldy #$c0                    ;get alternate value to add to vertical position
        Y = 0xC0
    }
    //> SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
    yPlatformTopYPos[X] = A
    //> tya
    A = Y
    //> clc                         ;load value from earlier, add number of pixels
    //> adc Enemy_Y_Position,x      ;to vertical position
    temp1 = A + enemyYPosition[X]
    A = temp1 and 0xFF
    //> sta YPlatformCenterYPos,x   ;save result as central vertical position
    yPlatformCenterYPos[X] = A
    //> ;--------------------------------
    //  Fall-through tail call to commonPlatCode
    commonPlatCode(X)
    return
}

// Decompiled from CommonPlatCode
fun commonPlatCode(X: Int) {
    var temp0: Int = 0
    //> CommonPlatCode:
    //> jsr InitVStf              ;do a sub to init certain other values
    temp0 = initVStf(X)
    //  Fall-through tail call to sPBBox
    sPBBox(X)
    return
}

// Decompiled from SPBBox
fun sPBBox(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    //> SPBBox: lda #$05                  ;set default bounding box size control
    A = 0x05
    //> ldy AreaType
    Y = areaType
    //> cpy #$03                  ;check for castle-type level
    //> beq CasPBB                ;use default value if found
    X = X
    if (Y != 0x03) {
        //> ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
        Y = secondaryHardMode
        //> bne CasPBB                ;if set, use default value
        if (Y == 0) {
            //> lda #$06                  ;use alternate value if not castle or secondary not set
            A = 0x06
        }
    }
    //> CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
    enemyBoundboxctrl[X] = A
    //> rts
    return
}

// Decompiled from LargeLiftUp
fun largeLiftUp(X: Int) {
    //> LargeLiftUp:
    //> jsr PlatLiftUp       ;execute code for platforms going up
    platLiftUp(X)
    //> jmp LargeLiftBBox    ;overwrite bounding box for large platforms
    largeLiftBBox(X)
    return
}

// Decompiled from LargeLiftDown
fun largeLiftDown(X: Int) {
    //> LargeLiftDown:
    //> jsr PlatLiftDown     ;execute code for platforms going down
    platLiftDown(X)
    //  Fall-through tail call to largeLiftBBox
    largeLiftBBox(X)
    return
}

// Decompiled from LargeLiftBBox
fun largeLiftBBox(X: Int) {
    //> LargeLiftBBox:
    //> jmp SPBBox           ;jump to overwrite bounding box size control
    sPBBox(X)
    return
}

// Decompiled from PlatLiftUp
fun platLiftUp(X: Int) {
    var A: Int = 0
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> PlatLiftUp:
    //> lda #$10                 ;set movement amount here
    A = 0x10
    //> sta Enemy_Y_MoveForce,x
    enemyYMoveforce[X] = A
    //> lda #$ff                 ;set moving speed for platforms going up
    A = 0xFF
    //> sta Enemy_Y_Speed,x
    enemyYSpeed[X] = A
    //> jmp CommonSmallLift      ;skip ahead to part we should be executing
    commonSmallLift(X)
    return
}

// Decompiled from PlatLiftDown
fun platLiftDown(X: Int) {
    var A: Int = 0
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> PlatLiftDown:
    //> lda #$f0                 ;set movement amount here
    A = 0xF0
    //> sta Enemy_Y_MoveForce,x
    enemyYMoveforce[X] = A
    //> lda #$00                 ;set moving speed for platforms going down
    A = 0x00
    //> sta Enemy_Y_Speed,x
    enemyYSpeed[X] = A
    //> ;--------------------------------
    //  Fall-through tail call to commonSmallLift
    commonSmallLift(X)
    return
}

// Decompiled from CommonSmallLift
fun commonSmallLift(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    //> CommonSmallLift:
    //> ldy #$01
    Y = 0x01
    //> jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
    posPlatform(X, Y)
    //> lda #$04
    A = 0x04
    //> sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
    enemyBoundboxctrl[X] = A
    //> rts
    return
}

// Decompiled from PosPlatform
fun posPlatform(X: Int, Y: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val platPosDataHigh by MemoryByteIndexed(PlatPosDataHigh)
    val platPosDataLow by MemoryByteIndexed(PlatPosDataLow)
    //> PosPlatform:
    //> lda Enemy_X_Position,x  ;get horizontal coordinate
    A = enemyXPosition[X]
    //> clc
    //> adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
    temp0 = A + platPosDataLow[Y]
    A = temp0 and 0xFF
    //> sta Enemy_X_Position,x  ;store as new horizontal coordinate
    enemyXPosition[X] = A
    //> lda Enemy_PageLoc,x
    A = enemyPageloc[X]
    //> adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
    temp1 = A + platPosDataHigh[Y] + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta Enemy_PageLoc,x     ;store as new page location
    enemyPageloc[X] = A
    //> rts                     ;and go back
    return
}

// Decompiled from EndOfEnemyInitCode
fun endOfEnemyInitCode() {
    //> EndOfEnemyInitCode:
    //> rts
    return
}

// Decompiled from RunEnemyObjectsCore
fun runEnemyObjectsCore(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> RunEnemyObjectsCore:
    //> ldx ObjectOffset  ;get offset for enemy object buffer
    X = objectOffset
    //> lda #$00          ;load value 0 for jump engine by default
    A = 0x00
    //> ldy Enemy_ID,x
    Y = enemyId[X]
    //> cpy #$15          ;if enemy object < $15, use default value
    //> bcc JmpEO
    if (Y >= 0x15) {
        //> tya               ;otherwise subtract $14 from the value and use
        A = Y
        //> sbc #$14          ;as value for jump engine
        temp0 = A - 0x14 - if (Y >= 0x15) 0 else 1
        A = temp0 and 0xFF
    }
    //> JmpEO: jsr JumpEngine
    when (A) {
        0 -> {
            runNormalEnemies(X, Y)
        }
        1 -> {
            runBowserFlame(X, Y)
        }
        2 -> {
            runFireworks(X)
        }
        3 -> {
            noRunCode()
        }
        4 -> {
            noRunCode()
        }
        5 -> {
            noRunCode()
        }
        6 -> {
            noRunCode()
        }
        7 -> {
            runFirebarObj(X)
        }
        8 -> {
            runFirebarObj(X)
        }
        9 -> {
            runFirebarObj(X)
        }
        10 -> {
            runFirebarObj(X)
        }
        11 -> {
            runFirebarObj(X)
        }
        12 -> {
            runFirebarObj(X)
        }
        13 -> {
            runFirebarObj(X)
        }
        14 -> {
            runFirebarObj(X)
        }
        15 -> {
            noRunCode()
        }
        16 -> {
            runLargePlatform(16, X, Y)
        }
        17 -> {
            runLargePlatform(17, X, Y)
        }
        18 -> {
            runLargePlatform(18, X, Y)
        }
        19 -> {
            runLargePlatform(19, X, Y)
        }
        20 -> {
            runLargePlatform(20, X, Y)
        }
        21 -> {
            runLargePlatform(21, X, Y)
        }
        22 -> {
            runLargePlatform(22, X, Y)
        }
        23 -> {
            runSmallPlatform(X, Y)
        }
        24 -> {
            runSmallPlatform(X, Y)
        }
        25 -> {
            runBowser(X)
        }
        26 -> {
            powerUpObjHandler(Y)
        }
        27 -> {
            vineObjectHandler(X)
        }
        28 -> {
            noRunCode()
        }
        29 -> {
            runStarFlagObj(X)
        }
        30 -> {
            jumpspringHandler(X)
        }
        31 -> {
            noRunCode()
        }
        32 -> {
            warpZoneObject(X)
        }
        33 -> {
            runRetainerObj(X, Y)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return X
    //> .dw RunNormalEnemies  ;for objects $00-$14
    //> .dw RunBowserFlame    ;for objects $15-$1f
    //> .dw RunFireworks
    //> .dw NoRunCode
    //> .dw NoRunCode
    //> .dw NoRunCode
    //> .dw NoRunCode
    //> .dw RunFirebarObj
    //> .dw RunFirebarObj
    //> .dw RunFirebarObj
    //> .dw RunFirebarObj
    //> .dw RunFirebarObj
    //> .dw RunFirebarObj     ;for objects $20-$2f
    //> .dw RunFirebarObj
    //> .dw RunFirebarObj
    //> .dw NoRunCode
    //> .dw RunLargePlatform
    //> .dw RunLargePlatform
    //> .dw RunLargePlatform
    //> .dw RunLargePlatform
    //> .dw RunLargePlatform
    //> .dw RunLargePlatform
    //> .dw RunLargePlatform
    //> .dw RunSmallPlatform
    //> .dw RunSmallPlatform
    //> .dw RunBowser
    //> .dw PowerUpObjHandler
    //> .dw VineObjectHandler
    //> .dw NoRunCode         ;for objects $30-$35
    //> .dw RunStarFlagObj
    //> .dw JumpspringHandler
    //> .dw NoRunCode
    //> .dw WarpZoneObject
    //> .dw RunRetainerObj
    //> ;--------------------------------
    //  Fall-through tail call to noRunCode
    noRunCode()
    return X
}

// Decompiled from NoRunCode
fun noRunCode() {
    //> NoRunCode:
    //> rts
    return
}

// Decompiled from RunRetainerObj
fun runRetainerObj(X: Int, Y: Int): Pair<Int, Int> {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    //> RunRetainerObj:
    //> jsr GetEnemyOffscreenBits
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> jsr RelativeEnemyPosition
    temp2 = relativeEnemyPosition(temp0)
    X = temp2
    //> jmp EnemyGfxHandler
    return enemyGfxHandler(temp2)
}

// Decompiled from RunNormalEnemies
fun runNormalEnemies(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var timerControl by MemoryByte(TimerControl)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    //> RunNormalEnemies:
    //> lda #$00                  ;init sprite attributes
    A = 0x00
    //> sta Enemy_SprAttrib,x
    enemySprattrib[X] = A
    //> jsr GetEnemyOffscreenBits
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> jsr RelativeEnemyPosition
    temp2 = relativeEnemyPosition(temp0)
    X = temp2
    //> jsr EnemyGfxHandler
    val pair1 = enemyGfxHandler(temp2)
    temp3 = pair1.first
    temp4 = pair1.second
    X = temp3
    //> jsr GetEnemyBoundBox
    val pair2 = getEnemyBoundBox(temp3)
    temp5 = pair2.first
    temp6 = pair2.second
    X = temp5
    //> jsr EnemyToBGCollisionDet
    val pair3 = enemyToBGCollisionDet(temp5)
    temp7 = pair3.first
    temp8 = pair3.second
    X = temp7
    //> jsr EnemiesCollision
    temp9 = enemiesCollision(temp7, temp8)
    X = temp9
    //> jsr PlayerEnemyCollision
    temp10 = playerEnemyCollision(temp9, temp8)
    X = temp10
    //> ldy TimerControl          ;if master timer control set, skip to last routine
    Y = timerControl
    //> bne SkipMove
    X = temp10
    if (Y == 0) {
        //> jsr EnemyMovementSubs
        enemyMovementSubs(X)
    }
    //> SkipMove: jmp OffscreenBoundsCheck
    offscreenBoundsCheck(X)
    return
}

// Decompiled from EnemyMovementSubs
fun enemyMovementSubs(X: Int) {
    var A: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> EnemyMovementSubs:
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> jsr JumpEngine
    when (A) {
        0 -> {
            moveNormalEnemy(X)
        }
        1 -> {
            moveNormalEnemy(X)
        }
        2 -> {
            moveNormalEnemy(X)
        }
        3 -> {
            moveNormalEnemy(X)
        }
        4 -> {
            moveNormalEnemy(X)
        }
        5 -> {
            procHammerBro(X)
        }
        6 -> {
            moveNormalEnemy(X)
        }
        7 -> {
            moveBloober(X)
        }
        8 -> {
            moveBulletBill(X)
        }
        9 -> {
            noMoveCode()
        }
        10 -> {
            moveSwimmingCheepCheep(X)
        }
        11 -> {
            moveSwimmingCheepCheep(X)
        }
        12 -> {
            movePodoboo(X)
        }
        13 -> {
            movePiranhaPlant(X)
        }
        14 -> {
            moveJumpingEnemy(X, 0)
        }
        15 -> {
            procMoveRedPTroopa(X)
        }
        16 -> {
            moveFlyGreenPTroopa(X)
        }
        17 -> {
            moveLakitu(X)
        }
        18 -> {
            moveNormalEnemy(X)
        }
        19 -> {
            noMoveCode()
        }
        20 -> {
            moveFlyingCheepCheep(X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
    //> .dw MoveNormalEnemy      ;only objects $00-$14 use this table
    //> .dw MoveNormalEnemy
    //> .dw MoveNormalEnemy
    //> .dw MoveNormalEnemy
    //> .dw MoveNormalEnemy
    //> .dw ProcHammerBro
    //> .dw MoveNormalEnemy
    //> .dw MoveBloober
    //> .dw MoveBulletBill
    //> .dw NoMoveCode
    //> .dw MoveSwimmingCheepCheep
    //> .dw MoveSwimmingCheepCheep
    //> .dw MovePodoboo
    //> .dw MovePiranhaPlant
    //> .dw MoveJumpingEnemy
    //> .dw ProcMoveRedPTroopa
    //> .dw MoveFlyGreenPTroopa
    //> .dw MoveLakitu
    //> .dw MoveNormalEnemy
    //> .dw NoMoveCode   ;dummy
    //> .dw MoveFlyingCheepCheep
    //> ;--------------------------------
    //  Fall-through tail call to noMoveCode
    noMoveCode()
    return
}

// Decompiled from NoMoveCode
fun noMoveCode() {
    //> NoMoveCode:
    //> rts
    return
}

// Decompiled from RunBowserFlame
fun runBowserFlame(X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    //> RunBowserFlame:
    //> jsr ProcBowserFlame
    temp0 = procBowserFlame(X)
    X = temp0
    //> jsr GetEnemyOffscreenBits
    val pair0 = getEnemyOffscreenBits(temp0)
    temp1 = pair0.first
    temp2 = pair0.second
    X = temp1
    //> jsr RelativeEnemyPosition
    temp3 = relativeEnemyPosition(temp1)
    X = temp3
    //> jsr GetEnemyBoundBox
    val pair1 = getEnemyBoundBox(temp3)
    temp4 = pair1.first
    temp5 = pair1.second
    X = temp4
    //> jsr PlayerEnemyCollision
    temp6 = playerEnemyCollision(temp4, temp5)
    X = temp6
    //> jmp OffscreenBoundsCheck
    offscreenBoundsCheck(temp6)
    return
}

// Decompiled from RunFirebarObj
fun runFirebarObj(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    //> RunFirebarObj:
    //> jsr ProcFirebar
    temp0 = procFirebar(X)
    X = temp0
    //> jmp OffscreenBoundsCheck
    offscreenBoundsCheck(temp0)
    return
}

// Decompiled from RunSmallPlatform
fun runSmallPlatform(X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    //> RunSmallPlatform:
    //> jsr GetEnemyOffscreenBits
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> jsr RelativeEnemyPosition
    temp2 = relativeEnemyPosition(temp0)
    X = temp2
    //> jsr SmallPlatformBoundBox
    val pair1 = smallPlatformBoundBox(temp2)
    temp3 = pair1.first
    temp4 = pair1.second
    X = temp3
    //> jsr SmallPlatformCollision
    temp5 = smallPlatformCollision(temp3, temp4)
    X = temp5
    //> jsr RelativeEnemyPosition
    temp6 = relativeEnemyPosition(temp5)
    X = temp6
    //> jsr DrawSmallPlatform
    temp7 = drawSmallPlatform(temp6)
    X = temp7
    //> jsr MoveSmallPlatform
    moveSmallPlatform(temp7)
    //> jmp OffscreenBoundsCheck
    offscreenBoundsCheck(temp7)
    return
}

// Decompiled from RunLargePlatform
fun runLargePlatform(A: Int, X: Int, Y: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> RunLargePlatform:
    //> jsr GetEnemyOffscreenBits
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> jsr RelativeEnemyPosition
    temp2 = relativeEnemyPosition(temp0)
    X = temp2
    //> jsr LargePlatformBoundBox
    val pair1 = largePlatformBoundBox(A, temp2)
    temp3 = pair1.first
    temp4 = pair1.second
    X = temp3
    //> jsr LargePlatformCollision
    temp5 = largePlatformCollision(temp3, temp4)
    X = temp5
    //> lda TimerControl             ;if master timer control set,
    A = timerControl
    //> bne SkipPT                   ;skip subroutine tree
    X = temp5
    Y = temp4
    if (A == 0) {
        //> jsr LargePlatformSubroutines
        temp6 = largePlatformSubroutines(X)
    }
    //> SkipPT: jsr RelativeEnemyPosition
    temp7 = relativeEnemyPosition(X)
    X = temp7
    //> jsr DrawLargePlatform
    temp8 = drawLargePlatform(temp7)
    X = temp8
    //> jmp OffscreenBoundsCheck
    offscreenBoundsCheck(temp8)
    return
}

// Decompiled from LargePlatformSubroutines
fun largePlatformSubroutines(X: Int): Int {
    var A: Int = 0
    var temp0: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> LargePlatformSubroutines:
    //> lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
    A = enemyId[X]
    //> sec
    //> sbc #$24
    temp0 = A - 0x24
    A = temp0 and 0xFF
    //> jsr JumpEngine
    when (A) {
        0 -> {
            balancePlatform(X)
        }
        1 -> {
            yMovingPlatform(X)
        }
        2 -> {
            moveLargeLiftPlat(X)
        }
        3 -> {
            moveLargeLiftPlat(X)
        }
        4 -> {
            xMovingPlatform(X)
        }
        5 -> {
            dropPlatform(X)
        }
        6 -> {
            rightPlatform(6, X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return A
    //> .dw BalancePlatform   ;table used by objects $24-$2a
    //> .dw YMovingPlatform
    //> .dw MoveLargeLiftPlat
    //> .dw MoveLargeLiftPlat
    //> .dw XMovingPlatform
    //> .dw DropPlatform
    //> .dw RightPlatform
    //> ;-------------------------------------------------------------------------------------
    //  Fall-through tail call to eraseEnemyObject
    return eraseEnemyObject(X)
}

// Decompiled from EraseEnemyObject
fun eraseEnemyObject(X: Int): Int {
    var A: Int = 0
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val shellChainCounter by MemoryByteIndexed(ShellChainCounter)
    //> EraseEnemyObject:
    //> lda #$00                 ;clear all enemy object variables
    A = 0x00
    //> sta Enemy_Flag,x
    enemyFlag[X] = A
    //> sta Enemy_ID,x
    enemyId[X] = A
    //> sta Enemy_State,x
    enemyState[X] = A
    //> sta FloateyNum_Control,x
    floateynumControl[X] = A
    //> sta EnemyIntervalTimer,x
    enemyIntervalTimer[X] = A
    //> sta ShellChainCounter,x
    shellChainCounter[X] = A
    //> sta Enemy_SprAttrib,x
    enemySprattrib[X] = A
    //> sta EnemyFrameTimer,x
    enemyFrameTimer[X] = A
    //> rts
    return A
}

// Decompiled from MovePodoboo
fun movePodoboo(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> MovePodoboo:
    //> lda EnemyIntervalTimer,x   ;check enemy timer
    A = enemyIntervalTimer[X]
    //> bne PdbM                   ;branch to move enemy if not expired
    X = X
    if (A == 0) {
        //> jsr InitPodoboo            ;otherwise set up podoboo again
        temp0 = initPodoboo(X)
        //> lda PseudoRandomBitReg+1,x ;get part of LSFR
        A = pseudoRandomBitReg[1 + X]
        //> ora #%10000000             ;set d7
        A = A or 0x80
        //> sta Enemy_Y_MoveForce,x    ;store as movement force
        enemyYMoveforce[X] = A
        //> and #%00001111             ;mask out high nybble
        A = A and 0x0F
        //> ora #$06                   ;set for at least six intervals
        A = A or 0x06
        //> sta EnemyIntervalTimer,x   ;store as new enemy timer
        enemyIntervalTimer[X] = A
        //> lda #$f9
        A = 0xF9
        //> sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
        enemyYSpeed[X] = A
    }
    //> PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
    return movejEnemyvertically(X)
}

// Decompiled from ProcHammerBro
fun procHammerBro(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val hammerBroJumpTimer by MemoryByteIndexed(HammerBroJumpTimer)
    val hammerThrowTmrData by MemoryByteIndexed(HammerThrowTmrData)
    val hammerThrowingTimer by MemoryByteIndexed(HammerThrowingTimer)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> ProcHammerBro:
    //> lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
    A = enemyState[X]
    //> and #%00100000
    A = A and 0x20
    //> beq ChkJH                  ;if not set, go ahead with code
    X = X
    if (A != 0) {
        //> jmp MoveDefeatedEnemy      ;otherwise jump to something else
        return moveDefeatedEnemy(X)
    } else {
        //> ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
        A = hammerBroJumpTimer[X]
        //> beq HammerBroJumpCode      ;if expired, branch to jump
        if (A != 0) {
            //> dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
            hammerBroJumpTimer[X] = (hammerBroJumpTimer[X] - 1) and 0xFF
            //> lda Enemy_OffscreenBits
            A = enemyOffscreenbits
            //> and #%00001100             ;check offscreen bits
            A = A and 0x0C
            //> bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
            if (!(A == 0)) {
                //  goto MoveHammerBroXDir -> moveHammerBroXDir
                moveHammerBroXDir(X)
                return Pair(A, Y)
            }
            //> lda HammerThrowingTimer,x  ;check hammer throwing timer
            A = hammerThrowingTimer[X]
            //> bne DecHT                  ;if not expired, skip ahead, do not throw hammer
            if (A == 0) {
                //> ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
                Y = secondaryHardMode
                //> lda HammerThrowTmrData,y   ;get timer data using flag as offset
                A = hammerThrowTmrData[Y]
                //> sta HammerThrowingTimer,x  ;set as new timer
                hammerThrowingTimer[X] = A
                //> jsr SpawnHammerObj         ;do a sub here to spawn hammer object
                temp0 = spawnHammerObj()
                X = temp0
                //> bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
                X = temp0
                if (flagC) {
                    //> lda Enemy_State,x
                    A = enemyState[X]
                    //> ora #%00001000             ;set d3 in enemy state for hammer throw
                    A = A or 0x08
                    //> sta Enemy_State,x
                    enemyState[X] = A
                    //> jmp MoveHammerBroXDir      ;jump to move hammer bro
                    return moveHammerBroXDir(X)
                }
            }
            //> DecHT: dec HammerThrowingTimer,x  ;decrement timer
            hammerThrowingTimer[X] = (hammerThrowingTimer[X] - 1) and 0xFF
            //> jmp MoveHammerBroXDir      ;jump to move hammer bro
            return moveHammerBroXDir(X)
        }
    }
    //> HammerBroJumpCode:
    //> lda Enemy_State,x           ;get hammer bro's enemy state
    A = enemyState[X]
    //> and #%00000111              ;mask out all but 3 LSB
    A = A and 0x07
    //> cmp #$01                    ;check for d0 set (for jumping)
    //> beq MoveHammerBroXDir       ;if set, branch ahead to moving code
    if (A == 0x01) {
        //  goto MoveHammerBroXDir -> moveHammerBroXDir
        moveHammerBroXDir(X)
        return Pair(A, Y)
    } else {
        //> lda #$00                    ;load default value here
        A = 0x00
        //> sta $00                     ;save into temp variable for now
        memory[0x0] = A.toUByte()
        //> ldy #$fa                    ;set default vertical speed
        Y = 0xFA
        //> lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
        A = enemyYPosition[X]
        //> bmi SetHJ                   ;if on the bottom half of the screen, use current speed
        if ((A and 0x80) != 0) {
            //  goto SetHJ -> setHJ
            setHJ(X, Y)
            return Pair(A, Y)
        }
    }
    //> ldy #$fd                    ;otherwise set alternate vertical speed
    Y = 0xFD
    //> cmp #$70                    ;check to see if hammer bro is above the middle of screen
    //> inc $00                     ;increment preset value to $01
    memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
    //> bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
    if (!(A >= 0x70)) {
        //  goto SetHJ -> setHJ
        setHJ(X, Y)
        return Pair(A, Y)
    } else {
        //> dec $00                     ;otherwise return value to $00
        memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
        //> lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
        A = pseudoRandomBitReg[1 + X]
        //> and #$01
        A = A and 0x01
        //> bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
        if (!(A == 0)) {
            //  goto SetHJ -> setHJ
            setHJ(X, Y)
            return Pair(A, Y)
        }
    }
    //> ldy #$fa                    ;otherwise reset to default vertical speed
    Y = 0xFA
    //  Fall-through tail call to setHJ
    return setHJ(X, Y)
}

// Decompiled from SetHJ
fun setHJ(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val hammerBroJumpLData by MemoryByteIndexed(HammerBroJumpLData)
    val hammerBroJumpTimer by MemoryByteIndexed(HammerBroJumpTimer)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
    enemyYSpeed[X] = Y
    //> lda Enemy_State,x           ;set d0 in enemy state for jumping
    A = enemyState[X]
    //> ora #$01
    A = A or 0x01
    //> sta Enemy_State,x
    enemyState[X] = A
    //> lda $00                     ;load preset value here to use as bitmask
    A = memory[0x0].toInt()
    //> and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
    A = A and pseudoRandomBitReg[2 + X]
    //> tay                         ;then use as offset
    Y = A
    //> lda SecondaryHardMode       ;check secondary hard mode flag
    A = secondaryHardMode
    //> bne HJump
    X = X
    Y = Y
    if (A == 0) {
        //> tay                         ;if secondary hard mode flag clear, set offset to 0
        Y = A
    }
    //> HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
    A = hammerBroJumpLData[Y]
    //> sta EnemyFrameTimer,x       ;save in enemy timer
    enemyFrameTimer[X] = A
    //> lda PseudoRandomBitReg+1,x
    A = pseudoRandomBitReg[1 + X]
    //> ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
    A = A or 0xC0
    //> sta HammerBroJumpTimer,x    ;store in jump timer
    hammerBroJumpTimer[X] = A
    //  Fall-through tail call to moveHammerBroXDir
    return moveHammerBroXDir(X)
}

// Decompiled from MoveHammerBroXDir
fun moveHammerBroXDir(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> MoveHammerBroXDir:
    //> ldy #$fc                  ;move hammer bro a little to the left
    Y = 0xFC
    //> lda FrameCounter
    A = frameCounter
    //> and #%01000000            ;change hammer bro's direction every 64 frames
    A = A and 0x40
    //> bne Shimmy
    X = X
    if (A == 0) {
        //> ldy #$04                  ;if d6 set in counter, move him a little to the right
        Y = 0x04
    }
    //> Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
    enemyXSpeed[X] = Y
    //> ldy #$01                  ;set to face right by default
    Y = 0x01
    //> jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
    val flag0: Boolean = playerEnemyDiff(X)
    //> bmi SetShim               ;if enemy to the left of player, skip this part
    if ((A and 0x80) == 0) {
        //> iny                       ;set to face left
        Y = (Y + 1) and 0xFF
        //> lda EnemyIntervalTimer,x  ;check walking timer
        A = enemyIntervalTimer[X]
        //> bne SetShim               ;if not yet expired, skip to set moving direction
        if (A == 0) {
            //> lda #$f8
            A = 0xF8
            //> sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
            enemyXSpeed[X] = A
        }
    }
    //> SetShim: sty Enemy_MovingDir,x     ;set moving direction
    enemyMovingdir[X] = Y
    //  Fall-through tail call to moveNormalEnemy
    return moveNormalEnemy(X)
}

// Decompiled from MoveNormalEnemy
fun moveNormalEnemy(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val revivedXSpeed by MemoryByteIndexed(RevivedXSpeed)
    val xSpeedAdderData by MemoryByteIndexed(XSpeedAdderData)
    //> MoveNormalEnemy:
    //> ldy #$00                   ;init Y to leave horizontal movement as-is
    Y = 0x00
    //> lda Enemy_State,x
    A = enemyState[X]
    //> and #%01000000             ;check enemy state for d6 set, if set skip
    A = A and 0x40
    //> bne FallE                  ;to move enemy vertically, then horizontally if necessary
    X = X
    if (A == 0) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> asl                        ;check enemy state for d7 set
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> bcs SteadM                 ;if set, branch to move enemy horizontally
        if ((orig0 and 0x80) == 0) {
            //> lda Enemy_State,x
            A = enemyState[X]
            //> and #%00100000             ;check enemy state for d5 set
            A = A and 0x20
            //> bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
            if (!(A == 0)) {
                //  goto MoveDefeatedEnemy -> moveDefeatedEnemy
                moveDefeatedEnemy(X)
                return Pair(A, Y)
            }
            //> lda Enemy_State,x
            A = enemyState[X]
            //> and #%00000111             ;check d2-d0 of enemy state for any set bits
            A = A and 0x07
            //> beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
            if (A != 0) {
                //> cmp #$05
                //> beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
                if (A != 0x05) {
                    //> cmp #$03
                    //> bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
                    if (A >= 0x03) {
                        //  goto ReviveStunned (internal forward branch)
                        //> ReviveStunned:
                        //> lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
                        A = enemyIntervalTimer[X]
                        //> bne ChkKillGoomba         ;skip ahead to something else
                        if (!(A == 0)) {
                            //  goto ChkKillGoomba (internal forward branch)
                            //> ChkKillGoomba:
                            //> cmp #$0e              ;check to see if enemy timer has reached
                            //> bne NKGmba            ;a certain point, and branch to leave if not
                            if (!(A == 0x0E)) {
                                //  goto NKGmba (internal forward branch)
                                //> NKGmba: rts                   ;leave!
                                return Pair(A, Y)
                            }
                            //> lda Enemy_ID,x
                            A = enemyId[X]
                            //> cmp #Goomba           ;check for goomba object
                            //> bne NKGmba            ;branch if not found
                            if (!(A == Goomba)) {
                                //  goto NKGmba (internal forward branch)
                                //> NKGmba: rts                   ;leave!
                                return Pair(A, Y)
                            }
                            //> jsr EraseEnemyObject  ;otherwise, kill this goomba object
                            temp0 = eraseEnemyObject(X)
                            return Pair(A, Y)
                        }
                        //> sta Enemy_State,x         ;otherwise initialize enemy state to normal
                        enemyState[X] = A
                        //> lda FrameCounter
                        A = frameCounter
                        //> and #$01                  ;get d0 of frame counter
                        A = A and 0x01
                        //> tay                       ;use as Y and increment for movement direction
                        Y = A
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
                        enemyMovingdir[X] = Y
                        //> dey                       ;decrement for use as pointer
                        Y = (Y - 1) and 0xFF
                        //> lda PrimaryHardMode       ;check primary hard mode flag
                        A = primaryHardMode
                        //> beq SetRSpd               ;if not set, use pointer as-is
                        if (A == 0) {
                            //  goto SetRSpd (internal forward branch)
                            //> SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
                            A = revivedXSpeed[Y]
                            //> sta Enemy_X_Speed,x       ;and leave
                            enemyXSpeed[X] = A
                            //> rts
                            return Pair(A, Y)
                        }
                        //> iny
                        Y = (Y + 1) and 0xFF
                        //> iny                       ;otherwise increment 2 bytes to next data
                        Y = (Y + 1) and 0xFF
                        return Pair(A, Y)
                    }
                }
            }
        }
    }
    //> FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
    temp1 = movedEnemyvertically(X)
    X = temp1
    //> ldy #$00
    Y = 0x00
    //> lda Enemy_State,x          ;check for enemy state $02
    A = enemyState[temp1]
    //> cmp #$02
    //> beq MEHor                  ;if found, branch to move enemy horizontally
    X = temp1
    if (A != 0x02) {
        //> and #%01000000             ;check for d6 set
        A = A and 0x40
        //> beq SteadM                 ;if not set, branch to something else
        if (A != 0) {
            //> lda Enemy_ID,x
            A = enemyId[X]
            //> cmp #PowerUpObject         ;check for power-up object
            //> beq SteadM
            if (A != PowerUpObject) {
                //> bne SlowM                  ;if any other object where d6 set, jump to set Y
                if (!(A == PowerUpObject)) {
                    //  goto SlowM (internal forward branch)
                    //> SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
                    Y = 0x01
                    return Pair(A, Y)
                }
            }
        }
        //> SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
        Y = 0x01
    } else {
        //> MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
        return moveEnemyHorizontally(A, X)
    }
    //> SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
    A = enemyXSpeed[X]
    //> pha                       ;save to stack
    push(A)
    //> bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
    if ((A and 0x80) != 0) {
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                       ;otherwise increment Y to next data
        Y = (Y + 1) and 0xFF
    }
    //> AddHS:  clc
    //> adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
    temp2 = A + xSpeedAdderData[Y]
    A = temp2 and 0xFF
    //> sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
    enemyXSpeed[X] = A
    //> jsr MoveEnemyHorizontally ;then do a sub to move horizontally
    val pair0 = moveEnemyHorizontally(A, X)
    temp3 = pair0.first
    temp4 = pair0.second
    X = temp4
    //> pla
    A = pull()
    //> sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
    enemyXSpeed[X] = A
    //> rts                       ;original memory location, then leave
    return Pair(A, temp4)
    //> ReviveStunned:
    //> lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
    A = enemyIntervalTimer[X]
    //> bne ChkKillGoomba         ;skip ahead to something else
    Y = temp4
    if (A == 0) {
        //> sta Enemy_State,x         ;otherwise initialize enemy state to normal
        enemyState[X] = A
        //> lda FrameCounter
        A = frameCounter
        //> and #$01                  ;get d0 of frame counter
        A = A and 0x01
        //> tay                       ;use as Y and increment for movement direction
        Y = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
        enemyMovingdir[X] = Y
        //> dey                       ;decrement for use as pointer
        Y = (Y - 1) and 0xFF
        //> lda PrimaryHardMode       ;check primary hard mode flag
        A = primaryHardMode
        //> beq SetRSpd               ;if not set, use pointer as-is
        if (A != 0) {
            //> iny
            Y = (Y + 1) and 0xFF
            //> iny                       ;otherwise increment 2 bytes to next data
            Y = (Y + 1) and 0xFF
        }
        //> SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
        A = revivedXSpeed[Y]
        //> sta Enemy_X_Speed,x       ;and leave
        enemyXSpeed[X] = A
        //> rts
        return Pair(A, Y)
    } else {
        //> ChkKillGoomba:
        //> cmp #$0e              ;check to see if enemy timer has reached
        //> bne NKGmba            ;a certain point, and branch to leave if not
        if (A == 0x0E) {
            //> lda Enemy_ID,x
            A = enemyId[X]
            //> cmp #Goomba           ;check for goomba object
            //> bne NKGmba            ;branch if not found
            if (A == Goomba) {
                //> jsr EraseEnemyObject  ;otherwise, kill this goomba object
                temp5 = eraseEnemyObject(X)
            }
        }
    }
    //> NKGmba: rts                   ;leave!
    return Pair(A, Y)
}

// Decompiled from MoveDefeatedEnemy
fun moveDefeatedEnemy(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> MoveDefeatedEnemy:
    //> jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
    temp0 = movedEnemyvertically(X)
    X = temp0
    //> jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
    return moveEnemyHorizontally(0, temp0)
}

// Decompiled from MoveJumpingEnemy
fun moveJumpingEnemy(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    //> MoveJumpingEnemy:
    //> jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
    temp0 = movejEnemyvertically(X)
    X = temp0
    //> jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
    return moveEnemyHorizontally(0, temp0)
}

// Decompiled from ProcMoveRedPTroopa
fun procMoveRedPTroopa(X: Int) {
    var A: Int = 0
    var X: Int = X
    var frameCounter by MemoryByte(FrameCounter)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val redPTroopaCenterYPos by MemoryByteIndexed(RedPTroopaCenterYPos)
    val redPTroopaOrigXPos by MemoryByteIndexed(RedPTroopaOrigXPos)
    //> ProcMoveRedPTroopa:
    //> lda Enemy_Y_Speed,x
    A = enemyYSpeed[X]
    //> ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
    A = A or enemyYMoveforce[X]
    //> bne MoveRedPTUpOrDown       ;branch if any found
    X = X
    if (A == 0) {
        //> sta Enemy_YMF_Dummy,x       ;initialize something here
        enemyYmfDummy[X] = A
        //> lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
        A = enemyYPosition[X]
        //> cmp RedPTroopaOrigXPos,x
        //> bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
        if (!(A >= redPTroopaOrigXPos[X])) {
            //> lda FrameCounter            ;get frame counter
            A = frameCounter
            //> and #%00000111              ;mask out all but 3 LSB
            A = A and 0x07
            //> bne NoIncPT                 ;if any bits set, branch to leave
            if (A == 0) {
                //> inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
                enemyYPosition[X] = (enemyYPosition[X] + 1) and 0xFF
            }
            //> NoIncPT:  rts                         ;leave
            return
        }
    }
    //> MoveRedPTUpOrDown:
    //> lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
    A = enemyYPosition[X]
    //> cmp RedPTroopaCenterYPos,x
    //> bcc MovPTDwn                ;if current < central, jump to move downwards
    if (A >= redPTroopaCenterYPos[X]) {
        //> jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
        moveRedPTroopaUp(X)
        return
    } else {
        //> MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
        moveRedPTroopaDown(X)
        return
    }
}

// Decompiled from MoveFlyGreenPTroopa
fun moveFlyGreenPTroopa(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> MoveFlyGreenPTroopa:
    //> jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
    xmovecntrGreenptroopa(X)
    //> jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
    temp0 = moveWithXMCntrs(X)
    X = temp0
    //> ldy #$01                   ;set Y to move green paratroopa down
    Y = 0x01
    //> lda FrameCounter
    A = frameCounter
    //> and #%00000011             ;check frame counter 2 LSB for any bits set
    A = A and 0x03
    //> bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
    X = temp0
    if (A == 0) {
        //> lda FrameCounter
        A = frameCounter
        //> and #%01000000             ;check frame counter for d6 set
        A = A and 0x40
        //> bne YSway                  ;branch to move green paratroopa down if set
        if (A == 0) {
            //> ldy #$ff                   ;otherwise set Y to move green paratroopa up
            Y = 0xFF
        }
        //> YSway:  sty $00                    ;store adder here
        memory[0x0] = Y.toUByte()
        //> lda Enemy_Y_Position,x
        A = enemyYPosition[X]
        //> clc                        ;add or subtract from vertical position
        //> adc $00                    ;to give green paratroopa a wavy flight
        temp1 = A + memory[0x0].toInt()
        A = temp1 and 0xFF
        //> sta Enemy_Y_Position,x
        enemyYPosition[X] = A
    }
    //> NoMGPT: rts                        ;leave!
    return
}

// Decompiled from XMoveCntr_GreenPTroopa
fun xmovecntrGreenptroopa(X: Int) {
    var A: Int = 0
    //> XMoveCntr_GreenPTroopa:
    //> lda #$13                    ;load preset maximum value for secondary counter
    A = 0x13
    //  Fall-through tail call to xmovecntrPlatform
    xmovecntrPlatform(A, X)
    return
}

// Decompiled from XMoveCntr_Platform
fun xmovecntrPlatform(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val xMovePrimaryCounter by MemoryByteIndexed(XMovePrimaryCounter)
    val xMoveSecondaryCounter by MemoryByteIndexed(XMoveSecondaryCounter)
    //> XMoveCntr_Platform:
    //> sta $01                     ;store value here
    memory[0x1] = A.toUByte()
    //> lda FrameCounter
    A = frameCounter
    //> and #%00000011              ;branch to leave if not on
    A = A and 0x03
    //> bne NoIncXM                 ;every fourth frame
    X = X
    if (A == 0) {
        //> ldy XMoveSecondaryCounter,x ;get secondary counter
        Y = xMoveSecondaryCounter[X]
        //> lda XMovePrimaryCounter,x   ;get primary counter
        A = xMovePrimaryCounter[X]
        //> lsr
        val orig0: Int = A
        A = orig0 shr 1
        //> bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
        if ((orig0 and 0x01) == 0) {
            //> cpy $01                     ;compare secondary counter to preset maximum value
            //> beq IncPXM                  ;if equal, branch ahead of this part
            if (Y != memory[0x1].toInt()) {
                //> inc XMoveSecondaryCounter,x ;increment secondary counter and leave
                xMoveSecondaryCounter[X] = (xMoveSecondaryCounter[X] + 1) and 0xFF
            }
        }
    }
    //> NoIncXM: rts
    return
    //> IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
    xMovePrimaryCounter[X] = (xMovePrimaryCounter[X] + 1) and 0xFF
    //> rts
    return
    //> DecSeXM: tya                         ;put secondary counter in A
    A = Y
    //> beq IncPXM                  ;if secondary counter at zero, branch back
    if (A == 0) {
    }
    //> dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
    xMoveSecondaryCounter[X] = (xMoveSecondaryCounter[X] - 1) and 0xFF
    //> rts
    return
}

// Decompiled from MoveWithXMCntrs
fun moveWithXMCntrs(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val xMovePrimaryCounter by MemoryByteIndexed(XMovePrimaryCounter)
    val xMoveSecondaryCounter by MemoryByteIndexed(XMoveSecondaryCounter)
    //> MoveWithXMCntrs:
    //> lda XMoveSecondaryCounter,x  ;save secondary counter to stack
    A = xMoveSecondaryCounter[X]
    //> pha
    push(A)
    //> ldy #$01                     ;set value here by default
    Y = 0x01
    //> lda XMovePrimaryCounter,x
    A = xMovePrimaryCounter[X]
    //> and #%00000010               ;if d1 of primary counter is
    A = A and 0x02
    //> bne XMRight                  ;set, branch ahead of this part here
    X = X
    if (A == 0) {
        //> lda XMoveSecondaryCounter,x
        A = xMoveSecondaryCounter[X]
        //> eor #$ff                     ;otherwise change secondary
        A = A xor 0xFF
        //> clc                          ;counter to two's compliment
        //> adc #$01
        temp0 = A + 0x01
        A = temp0 and 0xFF
        //> sta XMoveSecondaryCounter,x
        xMoveSecondaryCounter[X] = A
        //> ldy #$02                     ;load alternate value here
        Y = 0x02
    }
    //> XMRight: sty Enemy_MovingDir,x        ;store as moving direction
    enemyMovingdir[X] = Y
    //> jsr MoveEnemyHorizontally
    val pair0 = moveEnemyHorizontally(A, X)
    temp1 = pair0.first
    temp2 = pair0.second
    X = temp2
    //> sta $00                      ;save value obtained from sub here
    memory[0x0] = temp1.toUByte()
    //> pla                          ;get secondary counter from stack
    A = pull()
    //> sta XMoveSecondaryCounter,x  ;and return to original place
    xMoveSecondaryCounter[X] = A
    //> rts
    return X
}

// Decompiled from MoveBloober
fun moveBloober(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val blooberBitmasks by MemoryByteIndexed(BlooberBitmasks)
    val blooperMoveSpeed by MemoryByteIndexed(BlooperMoveSpeed)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> MoveBloober:
    //> lda Enemy_State,x
    A = enemyState[X]
    //> and #%00100000             ;check enemy state for d5 set
    A = A and 0x20
    //> bne MoveDefeatedBloober    ;branch if set to move defeated bloober
    X = X
    if (A == 0) {
        //> ldy SecondaryHardMode      ;use secondary hard mode flag as offset
        Y = secondaryHardMode
        //> lda PseudoRandomBitReg+1,x ;get LSFR
        A = pseudoRandomBitReg[1 + X]
        //> and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
        A = A and blooberBitmasks[Y]
        //> bne BlooberSwim            ;if any bits set, skip ahead to make swim
        if (A == 0) {
            //> txa
            A = X
            //> lsr                        ;check to see if on second or fourth slot (1 or 3)
            val orig0: Int = A
            A = orig0 shr 1
            //> bcc FBLeft                 ;if not, branch to figure out moving direction
            if ((orig0 and 0x01) != 0) {
                //> ldy Player_MovingDir       ;otherwise, load player's moving direction and
                Y = playerMovingdir
                //> bcs SBMDir                 ;do an unconditional branch to set
                if ((orig0 and 0x01) != 0) {
                    //  goto SBMDir (internal forward branch)
                    //> SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
                    enemyMovingdir[X] = Y
                    return Y
                }
            }
            //> FBLeft: ldy #$02                   ;set left moving direction by default
            Y = 0x02
            //> jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
            val flag1: Boolean = playerEnemyDiff(X)
            //> bpl SBMDir                 ;if enemy to the right of player, keep left
            if ((A and 0x80) != 0) {
                //> dey                        ;otherwise decrement to set right moving direction
                Y = (Y - 1) and 0xFF
            }
            //> SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
            enemyMovingdir[X] = Y
        }
        //> BlooberSwim:
        //> jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
        procSwimmingB(X)
        //> lda Enemy_Y_Position,x   ;get vertical coordinate
        A = enemyYPosition[X]
        //> sec
        //> sbc Enemy_Y_MoveForce,x  ;subtract movement force
        temp0 = A - enemyYMoveforce[X]
        A = temp0 and 0xFF
        //> cmp #$20                 ;check to see if position is above edge of status bar
        //> bcc SwimX                ;if so, don't do it
        if (A >= 0x20) {
            //> sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
            enemyYPosition[X] = A
        }
        //> SwimX: ldy Enemy_MovingDir,x    ;check moving direction
        Y = enemyMovingdir[X]
        //> dey
        Y = (Y - 1) and 0xFF
        //> bne LeftSwim             ;if moving to the left, branch to second part
        if (Y == 0) {
            //> lda Enemy_X_Position,x
            A = enemyXPosition[X]
            //> clc                      ;add movement speed to horizontal coordinate
            //> adc BlooperMoveSpeed,x
            temp1 = A + blooperMoveSpeed[X]
            A = temp1 and 0xFF
            //> sta Enemy_X_Position,x   ;store result as new horizontal coordinate
            enemyXPosition[X] = A
            //> lda Enemy_PageLoc,x
            A = enemyPageloc[X]
            //> adc #$00                 ;add carry to page location
            temp2 = A + if (temp1 > 0xFF) 1 else 0
            A = temp2 and 0xFF
            //> sta Enemy_PageLoc,x      ;store as new page location and leave
            enemyPageloc[X] = A
            //> rts
            return Y
        } else {
            //> LeftSwim:
            //> lda Enemy_X_Position,x
            A = enemyXPosition[X]
            //> sec                      ;subtract movement speed from horizontal coordinate
            //> sbc BlooperMoveSpeed,x
            temp3 = A - blooperMoveSpeed[X]
            A = temp3 and 0xFF
            //> sta Enemy_X_Position,x   ;store result as new horizontal coordinate
            enemyXPosition[X] = A
            //> lda Enemy_PageLoc,x
            A = enemyPageloc[X]
            //> sbc #$00                 ;subtract borrow from page location
            temp4 = A - if (temp3 >= 0) 0 else 1
            A = temp4 and 0xFF
            //> sta Enemy_PageLoc,x      ;store as new page location and leave
            enemyPageloc[X] = A
            //> rts
            return Y
            //> MoveDefeatedBloober:
            //> jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
            return moveEnemySlowVert()
        }
    } else {
        //> MoveDefeatedBloober:
        //> jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
        return moveEnemySlowVert()
    }
    return Y
}

// Decompiled from ProcSwimmingB
fun procSwimmingB(X: Int) {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val blooperMoveCounter by MemoryByteIndexed(BlooperMoveCounter)
    val blooperMoveSpeed by MemoryByteIndexed(BlooperMoveSpeed)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ProcSwimmingB:
    //> lda BlooperMoveCounter,x  ;get enemy's movement counter
    A = blooperMoveCounter[X]
    //> and #%00000010            ;check for d1 set
    A = A and 0x02
    //> bne ChkForFloatdown       ;branch if set
    X = X
    if (A == 0) {
        //> lda FrameCounter
        A = frameCounter
        //> and #%00000111            ;get 3 LSB of frame counter
        A = A and 0x07
        //> pha                       ;and save it to the stack
        push(A)
        //> lda BlooperMoveCounter,x  ;get enemy's movement counter
        A = blooperMoveCounter[X]
        //> lsr                       ;check for d0 set
        val orig0: Int = A
        A = orig0 shr 1
        //> bcs SlowSwim              ;branch if set
        if ((orig0 and 0x01) == 0) {
            //> pla                       ;pull 3 LSB of frame counter from the stack
            A = pull()
            //> bne BSwimE                ;branch to leave, execute code only every eighth frame
            if (A == 0) {
                //> lda Enemy_Y_MoveForce,x
                A = enemyYMoveforce[X]
                //> clc                       ;add to movement force to speed up swim
                //> adc #$01
                temp0 = A + 0x01
                A = temp0 and 0xFF
                //> sta Enemy_Y_MoveForce,x   ;set movement force
                enemyYMoveforce[X] = A
                //> sta BlooperMoveSpeed,x    ;set as movement speed
                blooperMoveSpeed[X] = A
                //> cmp #$02
                //> bne BSwimE                ;if certain horizontal speed, branch to leave
                if (A == 0x02) {
                    //> inc BlooperMoveCounter,x  ;otherwise increment movement counter
                    blooperMoveCounter[X] = (blooperMoveCounter[X] + 1) and 0xFF
                }
            }
            //> BSwimE: rts
            return
        }
        //> SlowSwim:
        //> pla                      ;pull 3 LSB of frame counter from the stack
        A = pull()
        //> bne NoSSw                ;branch to leave, execute code only every eighth frame
        if (A == 0) {
            //> lda Enemy_Y_MoveForce,x
            A = enemyYMoveforce[X]
            //> sec                      ;subtract from movement force to slow swim
            //> sbc #$01
            temp1 = A - 0x01
            A = temp1 and 0xFF
            //> sta Enemy_Y_MoveForce,x  ;set movement force
            enemyYMoveforce[X] = A
            //> sta BlooperMoveSpeed,x   ;set as movement speed
            blooperMoveSpeed[X] = A
            //> bne NoSSw                ;if any speed, branch to leave
            if ((temp1 and 0xFF) == 0) {
                //> inc BlooperMoveCounter,x ;otherwise increment movement counter
                blooperMoveCounter[X] = (blooperMoveCounter[X] + 1) and 0xFF
                //> lda #$02
                A = 0x02
                //> sta EnemyIntervalTimer,x ;set enemy's timer
                enemyIntervalTimer[X] = A
            }
        }
        //> NoSSw: rts                      ;leave
        return
    } else {
        //> ChkForFloatdown:
        //> lda EnemyIntervalTimer,x ;get enemy timer
        A = enemyIntervalTimer[X]
        //> beq ChkNearPlayer        ;branch if expired
        if (A != 0) {
            //> Floatdown:
            //> lda FrameCounter        ;get frame counter
            A = frameCounter
            //> lsr                     ;check for d0 set
            val orig1: Int = A
            A = orig1 shr 1
            //> bcs NoFD                ;branch to leave on every other frame
            if ((orig1 and 0x01) == 0) {
                //> inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
                enemyYPosition[X] = (enemyYPosition[X] + 1) and 0xFF
            }
            //> NoFD: rts                     ;leave
            return
        }
    }
    loop0@ do {
        //> Floatdown:
        //> lda FrameCounter        ;get frame counter
        A = frameCounter
        //> lsr                     ;check for d0 set
        val orig2: Int = A
        A = orig2 shr 1
        //> bcs NoFD                ;branch to leave on every other frame
        if ((orig2 and 0x01) != 0) {
            //  goto NoFD (internal forward branch)
            //> NoFD: rts                     ;leave
            return
        }
        //> inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
        enemyYPosition[X] = (enemyYPosition[X] + 1) and 0xFF
        //> ChkNearPlayer:
        //> lda Enemy_Y_Position,x    ;get vertical coordinate
        A = enemyYPosition[X]
        //> adc #$10                  ;add sixteen pixels
        temp2 = A + 0x10 + if ((orig2 and 0x01) != 0) 1 else 0
        A = temp2 and 0xFF
        //> cmp Player_Y_Position     ;compare result with player's vertical coordinate
        //> bcc Floatdown             ;if modified vertical less than player's, branch
        if (!(A >= playerYPosition)) {
            //  continue loop (branch back to Floatdown)
            continue@loop0
        }
    } while (!(A >= playerYPosition))
    //> lda #$00
    A = 0x00
    //> sta BlooperMoveCounter,x  ;otherwise nullify movement counter
    blooperMoveCounter[X] = A
    //> rts
    return
}

// Decompiled from MoveBulletBill
fun moveBulletBill(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> MoveBulletBill:
    //> lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
    A = enemyState[X]
    //> and #%00100000
    A = A and 0x20
    //> beq NotDefB                ;if not set, continue with movement code
    X = X
    if (A != 0) {
        //> jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
        movejEnemyvertically(X)
        return Pair(A, Y)
    } else {
        //> NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
        A = 0xE8
        //> sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
        enemyXSpeed[X] = A
        //> jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
        return moveEnemyHorizontally(A, X)
    }
}

// Decompiled from MoveSwimmingCheepCheep
fun moveSwimmingCheepCheep(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    val cheepCheepMoveMFlag by MemoryByteIndexed(CheepCheepMoveMFlag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXMoveforce by MemoryByteIndexed(Enemy_X_MoveForce)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val swimCCXMoveData by MemoryByteIndexed(SwimCCXMoveData)
    //> MoveSwimmingCheepCheep:
    //> lda Enemy_State,x         ;check cheep-cheep's enemy object state
    A = enemyState[X]
    //> and #%00100000            ;for d5 set
    A = A and 0x20
    //> beq CCSwim                ;if not set, continue with movement code
    X = X
    if (A != 0) {
        //> jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
        return moveEnemySlowVert()
    } else {
        //> CCSwim: sta $03                   ;save enemy state in $03
        memory[0x3] = A.toUByte()
        //> lda Enemy_ID,x            ;get enemy identifier
        A = enemyId[X]
        //> sec
        //> sbc #$0a                  ;subtract ten for cheep-cheep identifiers
        temp0 = A - 0x0A
        A = temp0 and 0xFF
        //> tay                       ;use as offset
        Y = A
        //> lda SwimCCXMoveData,y     ;load value here
        A = swimCCXMoveData[Y]
        //> sta $02
        memory[0x2] = A.toUByte()
        //> lda Enemy_X_MoveForce,x   ;load horizontal force
        A = enemyXMoveforce[X]
        //> sec
        //> sbc $02                   ;subtract preset value from horizontal force
        temp1 = A - memory[0x2].toInt()
        A = temp1 and 0xFF
        //> sta Enemy_X_MoveForce,x   ;store as new horizontal force
        enemyXMoveforce[X] = A
        //> lda Enemy_X_Position,x    ;get horizontal coordinate
        A = enemyXPosition[X]
        //> sbc #$00                  ;subtract borrow (thus moving it slowly)
        temp2 = A - if (temp1 >= 0) 0 else 1
        A = temp2 and 0xFF
        //> sta Enemy_X_Position,x    ;and save as new horizontal coordinate
        enemyXPosition[X] = A
        //> lda Enemy_PageLoc,x
        A = enemyPageloc[X]
        //> sbc #$00                  ;subtract borrow again, this time from the
        temp3 = A - if (temp2 >= 0) 0 else 1
        A = temp3 and 0xFF
        //> sta Enemy_PageLoc,x       ;page location, then save
        enemyPageloc[X] = A
        //> lda #$20
        A = 0x20
        //> sta $02                   ;save new value here
        memory[0x2] = A.toUByte()
        //> cpx #$02                  ;check enemy object offset
        //> bcc ExSwCC                ;if in first or second slot, branch to leave
        if (!(X >= 0x02)) {
            //  goto ExSwCC -> exSwCC
            exSwCC()
            return Y
        }
    }
    //> lda CheepCheepMoveMFlag,x ;check movement flag
    A = cheepCheepMoveMFlag[X]
    //> cmp #$10                  ;if movement speed set to $00,
    //> bcc CCSwimUpwards         ;branch to move upwards
    Y = Y
    if (A >= 0x10) {
        //> lda Enemy_YMF_Dummy,x
        A = enemyYmfDummy[X]
        //> clc
        //> adc $02                   ;add preset value to dummy variable to get carry
        temp4 = A + memory[0x2].toInt()
        A = temp4 and 0xFF
        //> sta Enemy_YMF_Dummy,x     ;and save dummy
        enemyYmfDummy[X] = A
        //> lda Enemy_Y_Position,x    ;get vertical coordinate
        A = enemyYPosition[X]
        //> adc $03                   ;add carry to it plus enemy state to slowly move it downwards
        temp5 = A + memory[0x3].toInt() + if (temp4 > 0xFF) 1 else 0
        A = temp5 and 0xFF
        //> sta Enemy_Y_Position,x    ;save as new vertical coordinate
        enemyYPosition[X] = A
        //> lda Enemy_Y_HighPos,x
        A = enemyYHighpos[X]
        //> adc #$00                  ;add carry to page location and
        temp6 = A + if (temp5 > 0xFF) 1 else 0
        A = temp6 and 0xFF
        //> jmp ChkSwimYPos           ;jump to end of movement code
        chkSwimYPos(A, X)
        return Y
    } else {
        //> CCSwimUpwards:
        //> lda Enemy_YMF_Dummy,x
        A = enemyYmfDummy[X]
        //> sec
        //> sbc $02                   ;subtract preset value to dummy variable to get borrow
        temp7 = A - memory[0x2].toInt()
        A = temp7 and 0xFF
        //> sta Enemy_YMF_Dummy,x     ;and save dummy
        enemyYmfDummy[X] = A
        //> lda Enemy_Y_Position,x    ;get vertical coordinate
        A = enemyYPosition[X]
        //> sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
        temp8 = A - memory[0x3].toInt() - if (temp7 >= 0) 0 else 1
        A = temp8 and 0xFF
        //> sta Enemy_Y_Position,x    ;save as new vertical coordinate
        enemyYPosition[X] = A
        //> lda Enemy_Y_HighPos,x
        A = enemyYHighpos[X]
        //> sbc #$00                  ;subtract borrow from page location
        temp9 = A - if (temp8 >= 0) 0 else 1
        A = temp9 and 0xFF
        //  Fall-through tail call to chkSwimYPos
        chkSwimYPos(A, X)
        return Y
    }
}

// Decompiled from ChkSwimYPos
fun chkSwimYPos(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val cheepCheepMoveMFlag by MemoryByteIndexed(CheepCheepMoveMFlag)
    val cheepCheepOrigYPos by MemoryByteIndexed(CheepCheepOrigYPos)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ChkSwimYPos:
    //> sta Enemy_Y_HighPos,x     ;save new page location here
    enemyYHighpos[X] = A
    //> ldy #$00                  ;load movement speed to upwards by default
    Y = 0x00
    //> lda Enemy_Y_Position,x    ;get vertical coordinate
    A = enemyYPosition[X]
    //> sec
    //> sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
    temp0 = A - cheepCheepOrigYPos[X]
    A = temp0 and 0xFF
    //> bpl YPDiff                ;if result positive, skip to next part
    X = X
    if ((temp0 and 0xFF and 0x80) != 0) {
        //> ldy #$10                  ;otherwise load movement speed to downwards
        Y = 0x10
        //> eor #$ff
        A = A xor 0xFF
        //> clc                       ;get two's compliment of result
        //> adc #$01                  ;to obtain total difference of original vs. current
        temp1 = A + 0x01
        A = temp1 and 0xFF
    }
    //> YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
    //> bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
    if (!(A >= 0x0F)) {
        //  goto ExSwCC -> exSwCC
        exSwCC()
        return
    } else {
        //> tya
        A = Y
        //> sta CheepCheepMoveMFlag,x ;otherwise change movement speed
        cheepCheepMoveMFlag[X] = A
        //  Fall-through tail call to exSwCC
        exSwCC()
        return
    }
}

// Decompiled from ExSwCC
fun exSwCC() {
    //> ExSwCC: rts                       ;leave
    return
}

// Decompiled from ProcFirebar
fun procFirebar(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var timerControl by MemoryByte(TimerControl)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val firebarSpinSpeed by MemoryByteIndexed(FirebarSpinSpeed)
    val firebarspinstateHigh by MemoryByteIndexed(FirebarSpinState_High)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> ProcFirebar:
    //> jsr GetEnemyOffscreenBits   ;get offscreen information
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda Enemy_OffscreenBits     ;check for d3 set
    A = enemyOffscreenbits
    //> and #%00001000              ;if so, branch to leave
    A = A and 0x08
    //> bne SkipFBar
    X = temp0
    Y = temp1
    if (A == 0) {
        //> lda TimerControl            ;if master timer control set, branch
        A = timerControl
        //> bne SusFbar                 ;ahead of this part
        if (A == 0) {
            //> lda FirebarSpinSpeed,x      ;load spinning speed of firebar
            A = firebarSpinSpeed[X]
            //> jsr FirebarSpin             ;modify current spinstate
            temp2 = firebarSpin(A, X)
            //> and #%00011111              ;mask out all but 5 LSB
            A = temp2 and 0x1F
            //> sta FirebarSpinState_High,x ;and store as new high byte of spinstate
            firebarspinstateHigh[X] = A
        }
        //> SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
        A = firebarspinstateHigh[X]
        //> ldy Enemy_ID,x              ;check enemy identifier
        Y = enemyId[X]
        //> cpy #$1f
        //> bcc SetupGFB                ;if < $1f (long firebar), branch
        if (Y >= 0x1F) {
            //> cmp #$08                    ;check high byte of spinstate
            //> beq SkpFSte                 ;if eight, branch to change
            if (A != 0x08) {
                //> cmp #$18
                //> bne SetupGFB                ;if not at twenty-four branch to not change
                if (!(A == 0x18)) {
                    //  goto SetupGFB (internal forward branch)
                    //> SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
                    memory[0xEF] = A.toUByte()
                    //> jsr RelativeEnemyPosition   ;get relative coordinates to screen
                    temp3 = relativeEnemyPosition(X)
                    X = temp3
                    //> jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
                    getFirebarPosition(A)
                    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
                    Y = enemySprdataoffset[temp3]
                    //> lda Enemy_Rel_YPos          ;get relative vertical coordinate
                    A = enemyRelYpos
                    //> sta Sprite_Y_Position,y     ;store as Y in OAM data
                    spriteYPosition[Y] = A
                    //> sta $07                     ;also save here
                    memory[0x7] = A.toUByte()
                    //> lda Enemy_Rel_XPos          ;get relative horizontal coordinate
                    A = enemyRelXpos
                    //> sta Sprite_X_Position,y     ;store as X in OAM data
                    spriteXPosition[Y] = A
                    //> sta $06                     ;also save here
                    memory[0x6] = A.toUByte()
                    //> lda #$01
                    A = 0x01
                    //> sta $00                     ;set $01 value here (not necessary)
                    memory[0x0] = A.toUByte()
                    //> jsr FirebarCollision        ;draw fireball part and do collision detection
                    firebarCollision(Y)
                    //> ldy #$05                    ;load value for short firebars by default
                    Y = 0x05
                    //> lda Enemy_ID,x
                    A = enemyId[temp3]
                    //> cmp #$1f                    ;are we doing a long firebar?
                    //> bcc SetMFbar                ;no, branch then
                    if (!(A >= 0x1F)) {
                        //  goto SetMFbar (internal forward branch)
                        //> SetMFbar: sty $ed                     ;store maximum value for length of firebars
                        memory[0xED] = Y.toUByte()
                        //> lda #$00
                        A = 0x00
                        //> sta $00                     ;initialize counter here
                        memory[0x0] = A.toUByte()
                        return X
                    }
                    //> ldy #$0b                    ;otherwise load value for long firebars
                    Y = 0x0B
                    return X
                }
            }
            //> SkpFSte:  clc
            //> adc #$01                    ;add one to spinning thing to avoid horizontal state
            temp4 = A + 0x01
            A = temp4 and 0xFF
            //> sta FirebarSpinState_High,x
            firebarspinstateHigh[X] = A
        }
        //> SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
        memory[0xEF] = A.toUByte()
        //> jsr RelativeEnemyPosition   ;get relative coordinates to screen
        temp5 = relativeEnemyPosition(X)
        X = temp5
        //> jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
        getFirebarPosition(A)
        //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
        Y = enemySprdataoffset[temp5]
        //> lda Enemy_Rel_YPos          ;get relative vertical coordinate
        A = enemyRelYpos
        //> sta Sprite_Y_Position,y     ;store as Y in OAM data
        spriteYPosition[Y] = A
        //> sta $07                     ;also save here
        memory[0x7] = A.toUByte()
        //> lda Enemy_Rel_XPos          ;get relative horizontal coordinate
        A = enemyRelXpos
        //> sta Sprite_X_Position,y     ;store as X in OAM data
        spriteXPosition[Y] = A
        //> sta $06                     ;also save here
        memory[0x6] = A.toUByte()
        //> lda #$01
        A = 0x01
        //> sta $00                     ;set $01 value here (not necessary)
        memory[0x0] = A.toUByte()
        //> jsr FirebarCollision        ;draw fireball part and do collision detection
        firebarCollision(Y)
        //> ldy #$05                    ;load value for short firebars by default
        Y = 0x05
        //> lda Enemy_ID,x
        A = enemyId[temp5]
        //> cmp #$1f                    ;are we doing a long firebar?
        //> bcc SetMFbar                ;no, branch then
        X = temp5
        if (A >= 0x1F) {
            //> ldy #$0b                    ;otherwise load value for long firebars
            Y = 0x0B
        }
        //> SetMFbar: sty $ed                     ;store maximum value for length of firebars
        memory[0xED] = Y.toUByte()
        //> lda #$00
        A = 0x00
        //> sta $00                     ;initialize counter here
        memory[0x0] = A.toUByte()
        loop0@ do {
            //> DrawFbar: lda $ef                     ;load high byte of spinstate
            A = memory[0xEF].toInt()
            //> jsr GetFirebarPosition      ;get fireball position data depending on firebar part
            getFirebarPosition(A)
            //> jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
            drawfirebarCollision()
            //> lda $00                     ;check which firebar part
            A = memory[0x0].toInt()
            //> cmp #$04
            //> bne NextFbar
            if (A == 0x04) {
                //> ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
                Y = duplicateobjOffset
                //> lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
                A = enemySprdataoffset[Y]
                //> sta $06                     ;using long firebar offset, then store as new one here
                memory[0x6] = A.toUByte()
            }
            //> NextFbar: inc $00                     ;move onto the next firebar part
            memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
            //> lda $00
            A = memory[0x0].toInt()
            //> cmp $ed                     ;if we end up at the maximum part, go on and leave
            //> bcc DrawFbar                ;otherwise go back and do another
            if (!(A >= memory[0xED].toInt())) {
                //  continue loop (branch back to DrawFbar)
                continue@loop0
            }
        } while (!(A >= memory[0xED].toInt()))
    }
    //> SkipFBar: rts
    return X
}

// Decompiled from DrawFirebar_Collision
fun drawfirebarCollision() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    //> DrawFirebar_Collision:
    //> lda $03                  ;store mirror data elsewhere
    A = memory[0x3].toInt()
    //> sta $05
    memory[0x5] = A.toUByte()
    //> ldy $06                  ;load OAM data offset for firebar
    Y = memory[0x6].toInt()
    //> lda $01                  ;load horizontal adder we got from position loader
    A = memory[0x1].toInt()
    //> lsr $05                  ;shift LSB of mirror data
    memory[0x5] = ((memory[0x5].toInt() shr 1) and 0xFF).toUByte()
    //> bcs AddHA                ;if carry was set, skip this part
    if ((memory[0x5].toInt() and 0x01) == 0) {
        //> eor #$ff
        A = A xor 0xFF
        //> adc #$01                 ;otherwise get two's compliment of horizontal adder
        temp0 = A + 0x01 + if ((memory[0x5].toInt() and 0x01) != 0) 1 else 0
        A = temp0 and 0xFF
    }
    //> AddHA:   clc                      ;add horizontal coordinate relative to screen to
    //> adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
    temp1 = A + enemyRelXpos
    A = temp1 and 0xFF
    //> sta Sprite_X_Position,y  ;store as X coordinate here
    spriteXPosition[Y] = A
    //> sta $06                  ;store here for now, note offset is saved in Y still
    memory[0x6] = A.toUByte()
    //> cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
    //> bcs SubtR1               ;if sprite coordinate => original coordinate, branch
    if (!(A >= enemyRelXpos)) {
        //> lda Enemy_Rel_XPos
        A = enemyRelXpos
        //> sec                      ;otherwise subtract sprite X from the
        //> sbc $06                  ;original one and skip this part
        temp2 = A - memory[0x6].toInt()
        A = temp2 and 0xFF
        //> jmp ChkFOfs
        chkFOfs(A, Y)
        return
    } else {
        //> SubtR1:  sec                      ;subtract original X from the
        //> sbc Enemy_Rel_XPos       ;current sprite X
        temp3 = A - enemyRelXpos
        A = temp3 and 0xFF
        //  Fall-through tail call to chkFOfs
        chkFOfs(A, Y)
        return
    }
}

// Decompiled from ChkFOfs
fun chkFOfs(A: Int, Y: Int) {
    var A: Int = A
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
    //> bcc VAHandl              ;continue by handling vertical adder
    A = A
    Y = Y
    if (A >= 0x59) {
        //> lda #$f8                 ;otherwise, load offscreen Y coordinate
        A = 0xF8
        //> bne SetVFbr              ;and unconditionally branch to move sprite offscreen
        if (!(A == 0)) {
            //  goto SetVFbr (internal forward branch)
            //> SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
            spriteYPosition[Y] = A
            //> sta $07                  ;also store here for now
            memory[0x7] = A.toUByte()
            //  Fall-through tail call to firebarCollision
            firebarCollision(Y)
            return
        }
    }
    //> VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
    A = enemyRelYpos
    //> cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
    //> beq SetVFbr
    if (A != 0xF8) {
        //> lda $02                  ;load vertical adder we got from position loader
        A = memory[0x2].toInt()
        //> lsr $05                  ;shift LSB of mirror data one more time
        memory[0x5] = ((memory[0x5].toInt() shr 1) and 0xFF).toUByte()
        //> bcs AddVA                ;if carry was set, skip this part
        if ((memory[0x5].toInt() and 0x01) == 0) {
            //> eor #$ff
            A = A xor 0xFF
            //> adc #$01                 ;otherwise get two's compliment of second part
            temp0 = A + 0x01 + if ((memory[0x5].toInt() and 0x01) != 0) 1 else 0
            A = temp0 and 0xFF
        }
        //> AddVA:   clc                      ;add vertical coordinate relative to screen to
        //> adc Enemy_Rel_YPos       ;the second data, modified or otherwise
        temp1 = A + enemyRelYpos
        A = temp1 and 0xFF
    }
    //> SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
    spriteYPosition[Y] = A
    //> sta $07                  ;also store here for now
    memory[0x7] = A.toUByte()
    //  Fall-through tail call to firebarCollision
    firebarCollision(Y)
    return
}

// Decompiled from FirebarCollision
fun firebarCollision(Y: Int) {
    var A: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var playerSize by MemoryByte(PlayerSize)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var timerControl by MemoryByte(TimerControl)
    //> FirebarCollision:
    //> jsr DrawFirebar          ;run sub here to draw current tile of firebar
    drawFirebar(Y)
    //> tya                      ;return OAM data offset and save
    A = Y
    //> pha                      ;to the stack for now
    push(A)
    //> lda StarInvincibleTimer  ;if star mario invincibility timer
    A = starInvincibleTimer
    //> ora TimerControl         ;or master timer controls set
    A = A or timerControl
    //> bne NoColFB              ;then skip all of this
    if (!(A == 0)) {
        //  goto NoColFB -> noColFB
        noColFB()
        return
    } else {
        //> sta $05                  ;otherwise initialize counter
        memory[0x5] = A.toUByte()
        //> ldy Player_Y_HighPos
        Y = playerYHighpos
        //> dey                      ;if player's vertical high byte offscreen,
        Y = (Y - 1) and 0xFF
        //> bne NoColFB              ;skip all of this
        if (!(Y == 0)) {
            //  goto NoColFB -> noColFB
            noColFB()
            return
        }
    }
    //> ldy Player_Y_Position    ;get player's vertical position
    Y = playerYPosition
    //> lda PlayerSize           ;get player's size
    A = playerSize
    //> bne AdjSm                ;if player small, branch to alter variables
    if (A == 0) {
        //> lda CrouchingFlag
        A = crouchingFlag
        //> beq BigJp                ;if player big and not crouching, jump ahead
        if (A == 0) {
            //  goto BigJp (internal forward branch)
            //> BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
            A = Y
            //  Fall-through tail call to fBCLoop
            fBCLoop(A)
            return
        }
    }
    //> AdjSm:   inc $05                  ;if small or big but crouching, execute this part
    memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
    //> inc $05                  ;first increment our counter twice (setting $02 as flag)
    memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
    //> tya
    A = Y
    //> clc                      ;then add 24 pixels to the player's
    //> adc #$18                 ;vertical coordinate
    temp0 = A + 0x18
    A = temp0 and 0xFF
    //> tay
    Y = A
    //> BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
    A = Y
    //  Fall-through tail call to fBCLoop
    fBCLoop(A)
    return
}

// Decompiled from FBCLoop
fun fBCLoop(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyMovingdir by MemoryByte(Enemy_MovingDir)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val firebarYPos by MemoryByteIndexed(FirebarYPos)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    //> FBCLoop: sec                      ;subtract vertical position of firebar
    //> sbc $07                  ;from the vertical coordinate of the player
    temp0 = A - memory[0x7].toInt()
    //> bpl ChkVFBD              ;if player lower on the screen than firebar,
    A = temp0 and 0xFF
    if ((temp0 and 0xFF and 0x80) != 0) {
        //> eor #$ff                 ;skip two's compliment part
        A = A xor 0xFF
        //> clc                      ;otherwise get two's compliment
        //> adc #$01
        temp1 = A + 0x01
        A = temp1 and 0xFF
    }
    //> ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
    //> bcs Chk2Ofs
    if (!(A >= 0x08)) {
        //> lda $06                  ;if firebar on far right on the screen, skip this,
        A = memory[0x6].toInt()
        //> cmp #$f0                 ;because, really, what's the point?
        //> bcs Chk2Ofs
        if (!(A >= 0xF0)) {
            //> lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
            A = spriteXPosition[4]
            //> clc
            //> adc #$04                 ;add four pixels
            temp2 = A + 0x04
            A = temp2 and 0xFF
            //> sta $04                  ;store here
            memory[0x4] = A.toUByte()
            //> sec                      ;subtract horizontal coordinate of firebar
            //> sbc $06                  ;from the X coordinate of player's sprite 1
            temp3 = A - memory[0x6].toInt()
            A = temp3 and 0xFF
            //> bpl ChkFBCl              ;if modded X coordinate to the right of firebar
            if ((temp3 and 0xFF and 0x80) != 0) {
                //> eor #$ff                 ;skip two's compliment part
                A = A xor 0xFF
                //> clc                      ;otherwise get two's compliment
                //> adc #$01
                temp4 = A + 0x01
                A = temp4 and 0xFF
            }
            //> ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
            //> bcc ChgSDir              ;to process
            if (!(A >= 0x08)) {
                //  goto ChgSDir (internal forward branch)
                //> ChgSDir: ldx #$01                 ;set movement direction by default
                X = 0x01
                //> lda $04                  ;if OAM X coordinate of player's sprite 1
                A = memory[0x4].toInt()
                //> cmp $06                  ;is greater than horizontal coordinate of firebar
                //> bcs SetSDir              ;then do not alter movement direction
                if (A >= memory[0x6].toInt()) {
                    //  goto SetSDir (internal forward branch)
                    //> SetSDir: stx Enemy_MovingDir      ;store movement direction here
                    enemyMovingdir = X
                    //> ldx #$00
                    X = 0x00
                    //> lda $00                  ;save value written to $00 to stack
                    A = memory[0x0].toInt()
                    //> pha
                    push(A)
                    //> jsr InjurePlayer         ;perform sub to hurt or kill player
                    injurePlayer()
                    //> pla
                    A = pull()
                    //> sta $00                  ;get value of $00 from stack
                    memory[0x0] = A.toUByte()
                    //  Fall-through tail call to noColFB
                    noColFB()
                    return
                }
                //> inx                      ;otherwise increment it
                X = (X + 1) and 0xFF
                return
            }
        }
    }
    //> Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
    A = memory[0x5].toInt()
    //> cmp #$02                 ;branch to increment OAM offset and leave, no collision
    //> beq NoColFB
    if (A == 0x02) {
        //  goto NoColFB -> noColFB
        noColFB()
        return
    } else {
        loop0@ while (true) {
            //> lda $06                  ;if firebar on far right on the screen, skip this,
            A = memory[0x6].toInt()
            //> cmp #$f0                 ;because, really, what's the point?
            //> bcs Chk2Ofs
            if (A >= 0xF0) {
                //  goto Chk2Ofs (internal forward branch)
                //> Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
                A = memory[0x5].toInt()
                //> cmp #$02                 ;branch to increment OAM offset and leave, no collision
                //> beq NoColFB
                if (A == 0x02) {
                    //  goto NoColFB -> noColFB
                    noColFB()
                    return
                }
                //> ldy $05                  ;otherwise get temp here and use as offset
                Y = memory[0x5].toInt()
                //> lda Player_Y_Position
                A = playerYPosition
                //> clc
                //> adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
                temp5 = A + firebarYPos[Y]
                A = temp5 and 0xFF
                //> inc $05                  ;then increment temp and jump back
                memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
                //> jmp FBCLoop
                return
            }
            //> lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
            A = spriteXPosition[4]
            //> clc
            //> adc #$04                 ;add four pixels
            temp6 = A + 0x04
            A = temp6 and 0xFF
            //> sta $04                  ;store here
            memory[0x4] = A.toUByte()
            //> sec                      ;subtract horizontal coordinate of firebar
            //> sbc $06                  ;from the X coordinate of player's sprite 1
            temp7 = A - memory[0x6].toInt()
            A = temp7 and 0xFF
            //> bpl ChkFBCl              ;if modded X coordinate to the right of firebar
            if (!((temp7 and 0xFF and 0x80) != 0)) {
                //  goto ChkFBCl (internal forward branch)
                //> ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
                //> bcc ChgSDir              ;to process
                if (!(A >= 0x08)) {
                    //  goto ChgSDir (internal forward branch)
                    //> ChgSDir: ldx #$01                 ;set movement direction by default
                    X = 0x01
                    //> lda $04                  ;if OAM X coordinate of player's sprite 1
                    A = memory[0x4].toInt()
                    //> cmp $06                  ;is greater than horizontal coordinate of firebar
                    //> bcs SetSDir              ;then do not alter movement direction
                    if (A >= memory[0x6].toInt()) {
                        //  goto SetSDir (internal forward branch)
                        //> SetSDir: stx Enemy_MovingDir      ;store movement direction here
                        enemyMovingdir = X
                        //> ldx #$00
                        X = 0x00
                        //> lda $00                  ;save value written to $00 to stack
                        A = memory[0x0].toInt()
                        //> pha
                        push(A)
                        //> jsr InjurePlayer         ;perform sub to hurt or kill player
                        injurePlayer()
                        //> pla
                        A = pull()
                        //> sta $00                  ;get value of $00 from stack
                        memory[0x0] = A.toUByte()
                        //  Fall-through tail call to noColFB
                        noColFB()
                        return
                    }
                    //> inx                      ;otherwise increment it
                    X = (X + 1) and 0xFF
                    return
                }
                return
            }
            //> eor #$ff                 ;skip two's compliment part
            A = A xor 0xFF
            //> clc                      ;otherwise get two's compliment
            //> adc #$01
            temp8 = A + 0x01
            A = temp8 and 0xFF
            //> ldy $05                  ;otherwise get temp here and use as offset
            Y = memory[0x5].toInt()
            //> lda Player_Y_Position
            A = playerYPosition
            //> clc
            //> adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
            temp9 = A + firebarYPos[Y]
            A = temp9 and 0xFF
            //> inc $05                  ;then increment temp and jump back
            memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
            //> jmp FBCLoop
        }
    }
    //> ChgSDir: ldx #$01                 ;set movement direction by default
    X = 0x01
    //> lda $04                  ;if OAM X coordinate of player's sprite 1
    A = memory[0x4].toInt()
    //> cmp $06                  ;is greater than horizontal coordinate of firebar
    //> bcs SetSDir              ;then do not alter movement direction
    if (!(A >= memory[0x6].toInt())) {
        //> inx                      ;otherwise increment it
        X = (X + 1) and 0xFF
    }
    //> SetSDir: stx Enemy_MovingDir      ;store movement direction here
    enemyMovingdir = X
    //> ldx #$00
    X = 0x00
    //> lda $00                  ;save value written to $00 to stack
    A = memory[0x0].toInt()
    //> pha
    push(A)
    //> jsr InjurePlayer         ;perform sub to hurt or kill player
    injurePlayer()
    //> pla
    A = pull()
    //> sta $00                  ;get value of $00 from stack
    memory[0x0] = A.toUByte()
    //  Fall-through tail call to noColFB
    noColFB()
    return
}

// Decompiled from NoColFB
fun noColFB() {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> NoColFB: pla                      ;get OAM data offset
    temp0 = pull()
    //> clc                      ;add four to it and save
    //> adc #$04
    temp1 = temp0 + 0x04
    //> sta $06
    memory[0x6] = (temp1 and 0xFF).toUByte()
    //> ldx ObjectOffset         ;get enemy object buffer offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from GetFirebarPosition
fun getFirebarPosition(A: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    val firebarMirrorData by MemoryByteIndexed(FirebarMirrorData)
    val firebarPosLookupTbl by MemoryByteIndexed(FirebarPosLookupTbl)
    val firebarTblOffsets by MemoryByteIndexed(FirebarTblOffsets)
    //> GetFirebarPosition:
    //> pha                        ;save high byte of spinstate to the stack
    push(A)
    //> and #%00001111             ;mask out low nybble
    A = A and 0x0F
    //> cmp #$09
    //> bcc GetHAdder              ;if lower than $09, branch ahead
    A = A
    if (A >= 0x09) {
        //> eor #%00001111             ;otherwise get two's compliment to oscillate
        A = A xor 0x0F
        //> clc
        //> adc #$01
        temp0 = A + 0x01
        A = temp0 and 0xFF
    }
    //> GetHAdder: sta $01                    ;store result, modified or not, here
    memory[0x1] = A.toUByte()
    //> ldy $00                    ;load number of firebar ball where we're at
    Y = memory[0x0].toInt()
    //> lda FirebarTblOffsets,y    ;load offset to firebar position data
    A = firebarTblOffsets[Y]
    //> clc
    //> adc $01                    ;add oscillated high byte of spinstate
    temp1 = A + memory[0x1].toInt()
    A = temp1 and 0xFF
    //> tay                        ;to offset here and use as new offset
    Y = A
    //> lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
    A = firebarPosLookupTbl[Y]
    //> sta $01
    memory[0x1] = A.toUByte()
    //> pla                        ;pull whatever was in A from the stack
    A = pull()
    //> pha                        ;save it again because we still need it
    push(A)
    //> clc
    //> adc #$08                   ;add eight this time, to get vertical adder
    temp2 = A + 0x08
    A = temp2 and 0xFF
    //> and #%00001111             ;mask out high nybble
    A = A and 0x0F
    //> cmp #$09                   ;if lower than $09, branch ahead
    //> bcc GetVAdder
    if (A >= 0x09) {
        //> eor #%00001111             ;otherwise get two's compliment
        A = A xor 0x0F
        //> clc
        //> adc #$01
        temp3 = A + 0x01
        A = temp3 and 0xFF
    }
    //> GetVAdder: sta $02                    ;store result here
    memory[0x2] = A.toUByte()
    //> ldy $00
    Y = memory[0x0].toInt()
    //> lda FirebarTblOffsets,y    ;load offset to firebar position data again
    A = firebarTblOffsets[Y]
    //> clc
    //> adc $02                    ;this time add value in $02 to offset here and use as offset
    temp4 = A + memory[0x2].toInt()
    A = temp4 and 0xFF
    //> tay
    Y = A
    //> lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
    A = firebarPosLookupTbl[Y]
    //> sta $02
    memory[0x2] = A.toUByte()
    //> pla                        ;pull out whatever was in A one last time
    A = pull()
    //> lsr                        ;divide by eight or shift three to the right
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> tay                        ;use as offset
    Y = A
    //> lda FirebarMirrorData,y    ;load mirroring data here
    A = firebarMirrorData[Y]
    //> sta $03                    ;store
    memory[0x3] = A.toUByte()
    //> rts
    return
}

// Decompiled from MoveFlyingCheepCheep
fun moveFlyingCheepCheep(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flyCCBPriority by MemoryByteIndexed(FlyCCBPriority)
    val pRandomSubtracter by MemoryByteIndexed(PRandomSubtracter)
    //> MoveFlyingCheepCheep:
    //> lda Enemy_State,x          ;check cheep-cheep's enemy state
    A = enemyState[X]
    //> and #%00100000             ;for d5 set
    A = A and 0x20
    //> beq FlyCC                  ;branch to continue code if not set
    X = X
    if (A != 0) {
        //> lda #$00
        A = 0x00
        //> sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
        enemySprattrib[X] = A
        //> jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
        return movejEnemyvertically(X)
    } else {
        //> FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
        val pair0 = moveEnemyHorizontally(A, X)
        temp0 = pair0.first
        temp1 = pair0.second
        X = temp1
        //> ldy #$0d                   ;set vertical movement amount
        Y = 0x0D
        //> lda #$05                   ;set maximum speed
        A = 0x05
        //> jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
        temp2 = setXMoveAmt(A, X, Y)
        X = temp2
        //> lda Enemy_Y_MoveForce,x
        A = enemyYMoveforce[temp2]
        //> lsr                        ;get vertical movement force and
        val orig0: Int = A
        A = orig0 shr 1
        //> lsr                        ;move high nybble to low
        val orig1: Int = A
        A = orig1 shr 1
        //> lsr
        val orig2: Int = A
        A = orig2 shr 1
        //> lsr
        val orig3: Int = A
        A = orig3 shr 1
        //> tay                        ;save as offset (note this tends to go into reach of code)
        Y = A
        //> lda Enemy_Y_Position,x     ;get vertical position
        A = enemyYPosition[temp2]
        //> sec                        ;subtract pseudorandom value based on offset from position
        //> sbc PRandomSubtracter,y
        temp3 = A - pRandomSubtracter[Y]
        A = temp3 and 0xFF
        //> bpl AddCCF                  ;if result within top half of screen, skip this part
        X = temp2
        if ((temp3 and 0xFF and 0x80) != 0) {
            //> eor #$ff
            A = A xor 0xFF
            //> clc                        ;otherwise get two's compliment
            //> adc #$01
            temp4 = A + 0x01
            A = temp4 and 0xFF
        }
    }
    //> AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
    //> bcs BPGet                  ;skip to the end without changing movement force
    if (!(A >= 0x08)) {
        //> lda Enemy_Y_MoveForce,x
        A = enemyYMoveforce[X]
        //> clc
        //> adc #$10                   ;otherwise add to it
        temp5 = A + 0x10
        A = temp5 and 0xFF
        //> sta Enemy_Y_MoveForce,x
        enemyYMoveforce[X] = A
        //> lsr                        ;move high nybble to low again
        val orig4: Int = A
        A = orig4 shr 1
        //> lsr
        val orig5: Int = A
        A = orig5 shr 1
        //> lsr
        val orig6: Int = A
        A = orig6 shr 1
        //> lsr
        val orig7: Int = A
        A = orig7 shr 1
        //> tay
        Y = A
    }
    //> BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
    A = flyCCBPriority[Y]
    //> sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
    enemySprattrib[X] = A
    //> rts                        ;drawing it next frame), then leave
    return X
}

// Decompiled from MoveLakitu
fun moveLakitu(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val lakituDiffAdj by MemoryByteIndexed(LakituDiffAdj)
    val lakituMoveDirection by MemoryByteIndexed(LakituMoveDirection)
    val lakituMoveSpeed by MemoryByteIndexed(LakituMoveSpeed)
    //> MoveLakitu:
    //> lda Enemy_State,x          ;check lakitu's enemy state
    A = enemyState[X]
    //> and #%00100000             ;for d5 set
    A = A and 0x20
    //> beq ChkLS                  ;if not set, continue with code
    X = X
    if (A != 0) {
        //> jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
        movedEnemyvertically(X)
        return Pair(A, Y)
    } else {
        //> ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
        A = enemyState[X]
        //> beq Fr12S                  ;go ahead and continue with code
        if (A != 0) {
            //> lda #$00
            A = 0x00
            //> sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
            lakituMoveDirection[X] = A
            //> sta EnemyFrenzyBuffer      ;initialize frenzy buffer
            enemyFrenzyBuffer = A
            //> lda #$10
            A = 0x10
            //> bne SetLSpd                ;load horizontal speed and do unconditional branch
            if (!(A == 0)) {
                //  goto SetLSpd (internal forward branch)
                //> SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
                lakituMoveSpeed[X] = A
                //> ldy #$01                   ;set moving direction to right by default
                Y = 0x01
                //> lda LakituMoveDirection,x
                A = lakituMoveDirection[X]
                //> and #$01                   ;get LSB of moving direction
                A = A and 0x01
                //> bne SetLMov                ;if set, branch to the end to use moving direction
                if (!(A == 0)) {
                    //  goto SetLMov (internal forward branch)
                    //> SetLMov: sty Enemy_MovingDir,x      ;store moving direction
                    enemyMovingdir[X] = Y
                    //> jmp MoveEnemyHorizontally  ;move lakitu horizontally
                    return moveEnemyHorizontally(A, X)
                }
                //> lda LakituMoveSpeed,x
                A = lakituMoveSpeed[X]
                //> eor #$ff                   ;get two's compliment of moving speed
                A = A xor 0xFF
                //> clc
                //> adc #$01
                temp0 = A + 0x01
                A = temp0 and 0xFF
                //> sta LakituMoveSpeed,x      ;store as new moving speed
                lakituMoveSpeed[X] = A
                //> iny                        ;increment moving direction to left
                Y = (Y + 1) and 0xFF
                return Pair(A, Y)
            }
        }
    }
    //> Fr12S:   lda #Spiny
    A = Spiny
    //> sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
    enemyFrenzyBuffer = A
    //> ldy #$02
    Y = 0x02
    loop0@ do {
        //> LdLDa:   lda LakituDiffAdj,y        ;load values
        A = lakituDiffAdj[Y]
        //> sta $0001,y                ;store in zero page
        memory[0x1 + Y] = A.toUByte()
        //> dey
        Y = (Y - 1) and 0xFF
        //> bpl LdLDa                  ;do this until all values are stired
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to LdLDa)
            continue@loop0
        }
    } while ((Y and 0x80) == 0)
    //> jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
    temp1 = playerLakituDiff(X)
    //> SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
    lakituMoveSpeed[X] = temp1
    //> ldy #$01                   ;set moving direction to right by default
    Y = 0x01
    //> lda LakituMoveDirection,x
    A = lakituMoveDirection[X]
    //> and #$01                   ;get LSB of moving direction
    A = A and 0x01
    //> bne SetLMov                ;if set, branch to the end to use moving direction
    if (A == 0) {
        //> lda LakituMoveSpeed,x
        A = lakituMoveSpeed[X]
        //> eor #$ff                   ;get two's compliment of moving speed
        A = A xor 0xFF
        //> clc
        //> adc #$01
        temp2 = A + 0x01
        A = temp2 and 0xFF
        //> sta LakituMoveSpeed,x      ;store as new moving speed
        lakituMoveSpeed[X] = A
        //> iny                        ;increment moving direction to left
        Y = (Y + 1) and 0xFF
    }
    //> SetLMov: sty Enemy_MovingDir,x      ;store moving direction
    enemyMovingdir[X] = Y
    //> jmp MoveEnemyHorizontally  ;move lakitu horizontally
    return moveEnemyHorizontally(A, X)
}

// Decompiled from PlayerLakituDiff
fun playerLakituDiff(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var scrollAmount by MemoryByte(ScrollAmount)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val lakituMoveDirection by MemoryByteIndexed(LakituMoveDirection)
    val lakituMoveSpeed by MemoryByteIndexed(LakituMoveSpeed)
    //> PlayerLakituDiff:
    //> ldy #$00                   ;set Y for default value
    Y = 0x00
    //> jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
    val flag0: Boolean = playerEnemyDiff(X)
    //> bpl ChkLakDif              ;branch if enemy is to the right of the player
    X = X
    if ((Y and 0x80) != 0) {
        //> iny                        ;increment Y for left of player
        Y = (Y + 1) and 0xFF
        //> lda $00
        A = memory[0x0].toInt()
        //> eor #$ff                   ;get two's compliment of low byte of horizontal difference
        A = A xor 0xFF
        //> clc
        //> adc #$01                   ;store two's compliment as horizontal difference
        temp0 = A + 0x01
        A = temp0 and 0xFF
        //> sta $00
        memory[0x0] = A.toUByte()
    }
    //> ChkLakDif: lda $00                    ;get low byte of horizontal difference
    A = memory[0x0].toInt()
    //> cmp #$3c                   ;if within a certain distance of player, branch
    //> bcc ChkPSpeed
    if (A >= 0x3C) {
        //> lda #$3c                   ;otherwise set maximum distance
        A = 0x3C
        //> sta $00
        memory[0x0] = A.toUByte()
        //> lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
        A = enemyId[X]
        //> cmp #Lakitu
        //> bne ChkPSpeed              ;if not, branch elsewhere
        if (A == Lakitu) {
            //> tya                        ;compare contents of Y, now in A
            A = Y
            //> cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
            //> beq ChkPSpeed              ;if moving toward the player, branch, do not alter
            if (A != lakituMoveDirection[X]) {
                //> lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
                A = lakituMoveDirection[X]
                //> beq SetLMovD               ;branch and alter without delay
                if (A != 0) {
                    //> dec LakituMoveSpeed,x      ;decrement horizontal speed
                    lakituMoveSpeed[X] = (lakituMoveSpeed[X] - 1) and 0xFF
                    //> lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
                    A = lakituMoveSpeed[X]
                    //> bne ExMoveLak
                    if (!(A == 0)) {
                        //  goto ExMoveLak (internal forward branch)
                        //> ExMoveLak: rts                        ;leave!!!
                        return A
                    }
                }
                //> SetLMovD:  tya                        ;set horizontal direction depending on horizontal
                A = Y
                //> sta LakituMoveDirection,x  ;difference between enemy and player if necessary
                lakituMoveDirection[X] = A
            }
        }
    }
    //> ChkPSpeed: lda $00
    A = memory[0x0].toInt()
    //> and #%00111100             ;mask out all but four bits in the middle
    A = A and 0x3C
    //> lsr                        ;divide masked difference by four
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> sta $00                    ;store as new value
    memory[0x0] = A.toUByte()
    //> ldy #$00                   ;init offset
    Y = 0x00
    //> lda Player_X_Speed
    A = playerXSpeed
    //> beq SubDifAdj              ;if player not moving horizontally, branch
    if (A != 0) {
        //> lda ScrollAmount
        A = scrollAmount
        //> beq SubDifAdj              ;if scroll speed not set, branch to same place
        if (A != 0) {
            //> iny                        ;otherwise increment offset
            Y = (Y + 1) and 0xFF
            //> lda Player_X_Speed
            A = playerXSpeed
            //> cmp #$19                   ;if player not running, branch
            //> bcc ChkSpinyO
            if (A >= 0x19) {
                //> lda ScrollAmount
                A = scrollAmount
                //> cmp #$02                   ;if scroll speed below a certain amount, branch
                //> bcc ChkSpinyO              ;to same place
                if (A >= 0x02) {
                    //> iny                        ;otherwise increment once more
                    Y = (Y + 1) and 0xFF
                }
            }
            //> ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
            A = enemyId[X]
            //> cmp #Spiny
            //> bne ChkEmySpd              ;branch if not found
            if (A == Spiny) {
                //> lda Player_X_Speed         ;if player not moving, skip this part
                A = playerXSpeed
                //> bne SubDifAdj
                if (!(A == 0)) {
                    //  goto SubDifAdj (internal forward branch)
                    //> SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
                    A = memory[0x1 + Y].toInt()
                    //> ldy $00                    ;get saved horizontal difference
                    Y = memory[0x0].toInt()
                    return A
                }
            }
            //> ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
            A = enemyYSpeed[X]
            //> bne SubDifAdj              ;branch if nonzero
            if (A == 0) {
                //> ldy #$00                   ;otherwise reinit offset
                Y = 0x00
            }
        }
    }
    //> SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
    A = memory[0x1 + Y].toInt()
    //> ldy $00                    ;get saved horizontal difference
    Y = memory[0x0].toInt()
    loop0@ do {
        //> SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
        //> sbc #$01                   ;from one of three saved values
        temp1 = A - 0x01
        A = temp1 and 0xFF
        //> dey
        Y = (Y - 1) and 0xFF
        //> bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
        if (!((Y and 0x80) != 0)) {
            //  continue loop (branch back to SPixelLak)
            continue@loop0
        }
    } while ((Y and 0x80) == 0)
    //> ExMoveLak: rts                        ;leave!!!
    return A
}

// Decompiled from BridgeCollapse
fun bridgeCollapse() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFeetCounter by MemoryByte(BowserFeetCounter)
    var bowserfrontOffset by MemoryByte(BowserFront_Offset)
    var bridgeCollapseOffset by MemoryByte(BridgeCollapseOffset)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var objectOffset by MemoryByte(ObjectOffset)
    var opermodeTask by MemoryByte(OperMode_Task)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val bridgeCollapseData by MemoryByteIndexed(BridgeCollapseData)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> BridgeCollapse:
    //> ldx BowserFront_Offset    ;get enemy offset for bowser
    X = bowserfrontOffset
    //> lda Enemy_ID,x            ;check enemy object identifier for bowser
    A = enemyId[X]
    //> cmp #Bowser               ;if not found, branch ahead,
    //> bne SetM2                 ;metatile removal not necessary
    if (A == Bowser) {
        //> stx ObjectOffset          ;store as enemy offset here
        objectOffset = X
        //> lda Enemy_State,x         ;if bowser in normal state, skip all of this
        A = enemyState[X]
        //> beq RemoveBridge
        if (A != 0) {
            //> and #%01000000            ;if bowser's state has d6 clear, skip to silence music
            A = A and 0x40
            //> beq SetM2
            if (A != 0) {
                //> lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
                A = enemyYPosition[X]
                //> cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
                //> bcc MoveD_Bowser
                if (!(A >= 0xE0)) {
                    //  goto MoveD_Bowser -> movedBowser
                    movedBowser(X, 0)
                    return
                }
            }
        }
    }
    //> SetM2: lda #Silence              ;silence music
    A = Silence
    //> sta EventMusicQueue
    eventMusicQueue = A
    //> inc OperMode_Task         ;move onto next secondary mode in autoctrl mode
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
    killAllEnemies(A)
    return
    //> RemoveBridge:
    //> dec BowserFeetCounter     ;decrement timer to control bowser's feet
    bowserFeetCounter = (bowserFeetCounter - 1) and 0xFF
    //> bne NoBFall               ;if not expired, skip all of this
    if (bowserFeetCounter == 0) {
        //> lda #$04
        A = 0x04
        //> sta BowserFeetCounter     ;otherwise, set timer now
        bowserFeetCounter = A
        //> lda BowserBodyControls
        A = bowserBodyControls
        //> eor #$01                  ;invert bit to control bowser's feet
        A = A xor 0x01
        //> sta BowserBodyControls
        bowserBodyControls = A
        //> lda #$22                  ;put high byte of name table address here for now
        A = 0x22
        //> sta $05
        memory[0x5] = A.toUByte()
        //> ldy BridgeCollapseOffset  ;get bridge collapse offset here
        Y = bridgeCollapseOffset
        //> lda BridgeCollapseData,y  ;load low byte of name table address and store here
        A = bridgeCollapseData[Y]
        //> sta $04
        memory[0x4] = A.toUByte()
        //> ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
        Y = vramBuffer1Offset
        //> iny
        Y = (Y + 1) and 0xFF
        //> ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
        X = 0x0C
        //> jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
        remBridge(X, Y)
        //> ldx ObjectOffset          ;get enemy offset
        X = objectOffset
        //> jsr MoveVOffset           ;set new vram buffer offset
        temp0 = moveVOffset(Y)
        //> lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
        A = Sfx_Blast
        //> sta Square2SoundQueue     ;queue while at the same time loading the brick
        square2SoundQueue = A
        //> lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
        A = Sfx_BrickShatter
        //> sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
        noiseSoundQueue = A
        //> inc BridgeCollapseOffset  ;increment bridge collapse offset
        bridgeCollapseOffset = (bridgeCollapseOffset + 1) and 0xFF
        //> lda BridgeCollapseOffset
        A = bridgeCollapseOffset
        //> cmp #$0f                  ;if bridge collapse offset has not yet reached
        //> bne NoBFall               ;the end, go ahead and skip this part
        Y = temp0
        if (A == 0x0F) {
            //> jsr InitVStf              ;initialize whatever vertical speed bowser has
            temp1 = initVStf(X)
            //> lda #%01000000
            A = 0x40
            //> sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
            enemyState[X] = A
            //> lda #Sfx_BowserFall
            A = Sfx_BowserFall
            //> sta Square2SoundQueue     ;play bowser defeat sound
            square2SoundQueue = A
        }
    }
    //> NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
    bowserGfxHandler(X, Y)
    return
}

// Decompiled from MoveD_Bowser
fun movedBowser(X: Int, Y: Int) {
    var temp0: Int = 0
    //> MoveD_Bowser:
    //> jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
    temp0 = moveEnemySlowVert()
    //> jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
    bowserGfxHandler(X, temp0)
    return
}

// Decompiled from RunBowser
fun runBowser(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFeetCounter by MemoryByte(BowserFeetCounter)
    var bowserFireBreathTimer by MemoryByte(BowserFireBreathTimer)
    var bowserMovementSpeed by MemoryByte(BowserMovementSpeed)
    var bowserOrigXPos by MemoryByte(BowserOrigXPos)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var frameCounter by MemoryByte(FrameCounter)
    var maxRangeFromOrigin by MemoryByte(MaxRangeFromOrigin)
    var timerControl by MemoryByte(TimerControl)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pRandomRange by MemoryByteIndexed(PRandomRange)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> RunBowser:
    //> lda Enemy_State,x       ;if d5 in enemy state is not set
    A = enemyState[X]
    //> and #%00100000          ;then branch elsewhere to run bowser
    A = A and 0x20
    //> beq BowserControl
    X = X
    if (A != 0) {
        //> lda Enemy_Y_Position,x  ;otherwise check vertical position
        A = enemyYPosition[X]
        //> cmp #$e0                ;if above a certain point, branch to move defeated bowser
        //> bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
        if (!(A >= 0xE0)) {
            //> MoveD_Bowser:
            //> jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
            temp0 = moveEnemySlowVert()
            //> jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
            bowserGfxHandler(X, temp0)
            return
        }
        //  Fall-through tail call to killAllEnemies
        killAllEnemies(A)
        return
    } else {
        //> BowserControl:
        //> lda #$00
        A = 0x00
        //> sta EnemyFrenzyBuffer      ;empty frenzy buffer
        enemyFrenzyBuffer = A
        //> lda TimerControl           ;if master timer control not set,
        A = timerControl
        //> beq ChkMouth               ;skip jump and execute code here
        if (A != 0) {
            //> jmp SkipToFB               ;otherwise, jump over a bunch of code
            skipToFB(X)
            return
        }
    }
    //> ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
    A = bowserBodyControls
    //> bpl FeetTmr                ;if bit clear, go ahead with code here
    if ((A and 0x80) != 0) {
        //> jmp HammerChk              ;otherwise skip a whole section starting here
        hammerChk(X)
        return
    } else {
        //> FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
        bowserFeetCounter = (bowserFeetCounter - 1) and 0xFF
        //> bne ResetMDr               ;if not expired, skip this part
        if (bowserFeetCounter == 0) {
            //> lda #$20                   ;otherwise, reset timer
            A = 0x20
            //> sta BowserFeetCounter
            bowserFeetCounter = A
            //> lda BowserBodyControls     ;and invert bit used
            A = bowserBodyControls
            //> eor #%00000001             ;to control bowser's feet
            A = A xor 0x01
            //> sta BowserBodyControls
            bowserBodyControls = A
        }
    }
    //> ResetMDr:  lda FrameCounter           ;check frame counter
    A = frameCounter
    //> and #%00001111             ;if not on every sixteenth frame, skip
    A = A and 0x0F
    //> bne B_FaceP                ;ahead to continue code
    if (A == 0) {
        //> lda #$02                   ;otherwise reset moving/facing direction every
        A = 0x02
        //> sta Enemy_MovingDir,x      ;sixteen frames
        enemyMovingdir[X] = A
    }
    //> B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
    A = enemyFrameTimer[X]
    //> beq GetPRCmp               ;branch to next section
    if (A != 0) {
        //> jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
        val flag0: Boolean = playerEnemyDiff(X)
        //> bpl GetPRCmp               ;and branch if bowser to the right of the player
        if ((A and 0x80) != 0) {
            //> lda #$01
            A = 0x01
            //> sta Enemy_MovingDir,x      ;set bowser to move and face to the right
            enemyMovingdir[X] = A
            //> lda #$02
            A = 0x02
            //> sta BowserMovementSpeed    ;set movement speed
            bowserMovementSpeed = A
            //> lda #$20
            A = 0x20
            //> sta EnemyFrameTimer,x      ;set timer here
            enemyFrameTimer[X] = A
            //> sta BowserFireBreathTimer  ;set timer used for bowser's flame
            bowserFireBreathTimer = A
            //> lda Enemy_X_Position,x
            A = enemyXPosition[X]
            //> cmp #$c8                   ;if bowser to the right past a certain point,
            //> bcs HammerChk              ;skip ahead to some other section
            if (A >= 0xC8) {
                //  goto HammerChk -> hammerChk
                hammerChk(X)
                return
            }
        }
    }
    //> GetPRCmp:  lda FrameCounter           ;get frame counter
    A = frameCounter
    //> and #%00000011
    A = A and 0x03
    //> bne HammerChk              ;execute this code every fourth frame, otherwise branch
    if (!(A == 0)) {
        //  goto HammerChk -> hammerChk
        hammerChk(X)
        return
    } else {
        //> lda Enemy_X_Position,x
        A = enemyXPosition[X]
        //> cmp BowserOrigXPos         ;if bowser not at original horizontal position,
        //> bne GetDToO                ;branch to skip this part
        if (A == bowserOrigXPos) {
            //> lda PseudoRandomBitReg,x
            A = pseudoRandomBitReg[X]
            //> and #%00000011             ;get pseudorandom offset
            A = A and 0x03
            //> tay
            Y = A
            //> lda PRandomRange,y         ;load value using pseudorandom offset
            A = pRandomRange[Y]
            //> sta MaxRangeFromOrigin     ;and store here
            maxRangeFromOrigin = A
        }
    }
    //> GetDToO:   lda Enemy_X_Position,x
    A = enemyXPosition[X]
    //> clc                        ;add movement speed to bowser's horizontal
    //> adc BowserMovementSpeed    ;coordinate and save as new horizontal position
    temp1 = A + bowserMovementSpeed
    A = temp1 and 0xFF
    //> sta Enemy_X_Position,x
    enemyXPosition[X] = A
    //> ldy Enemy_MovingDir,x
    Y = enemyMovingdir[X]
    //> cpy #$01                   ;if bowser moving and facing to the right, skip ahead
    //> beq HammerChk
    if (Y == 0x01) {
        //  goto HammerChk -> hammerChk
        hammerChk(X)
        return
    } else {
        //> ldy #$ff                   ;set default movement speed here (move left)
        Y = 0xFF
        //> sec                        ;get difference of current vs. original
        //> sbc BowserOrigXPos         ;horizontal position
        temp2 = A - bowserOrigXPos
        A = temp2 and 0xFF
        //> bpl CompDToO               ;if current position to the right of original, skip ahead
        if ((temp2 and 0xFF and 0x80) != 0) {
            //> eor #$ff
            A = A xor 0xFF
            //> clc                        ;get two's compliment
            //> adc #$01
            temp3 = A + 0x01
            A = temp3 and 0xFF
            //> ldy #$01                   ;set alternate movement speed here (move right)
            Y = 0x01
        }
    }
    //> CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
    //> bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
    if (!(A >= maxRangeFromOrigin)) {
        //  goto HammerChk -> hammerChk
        hammerChk(X)
        return
    } else {
        //> sty BowserMovementSpeed    ;otherwise change bowser's movement speed
        bowserMovementSpeed = Y
        //  Fall-through tail call to hammerChk
        hammerChk(X)
        return
    }
}

// Decompiled from KillAllEnemies
fun killAllEnemies(A: Int) {
    var X: Int = 0
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var objectOffset by MemoryByte(ObjectOffset)
    //> KillAllEnemies:
    //> ldx #$04              ;start with last enemy slot
    X = 0x04
    loop0@ do {
        //> KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
        temp0 = eraseEnemyObject(X)
        //> dex                   ;move onto next enemy slot
        X = (X - 1) and 0xFF
        //> bpl KillLoop          ;do this until all slots are emptied
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to KillLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> sta EnemyFrenzyBuffer ;empty frenzy buffer
    enemyFrenzyBuffer = temp0
    //> ldx ObjectOffset      ;get enemy object offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from HammerChk
fun hammerChk(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var worldNumber by MemoryByte(WorldNumber)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val pRandomRange by MemoryByteIndexed(PRandomRange)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
    A = enemyFrameTimer[X]
    //> bne MakeBJump              ;some other section of code
    X = X
    if (A == 0) {
        //> jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
        temp0 = moveEnemySlowVert()
        //> lda WorldNumber            ;check world number
        A = worldNumber
        //> cmp #World6
        //> bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
        Y = temp0
        if (A >= World6) {
            //> lda FrameCounter
            A = frameCounter
            //> and #%00000011             ;check to see if it's time to execute sub
            A = A and 0x03
            //> bne SetHmrTmr              ;if not, skip sub, otherwise
            if (A == 0) {
                //> jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn misc object (hammer)
                temp1 = spawnHammerObj()
                X = temp1
            }
        }
        //> SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
        A = enemyYPosition[X]
        //> cmp #$80                   ;if still above a certain point
        //> bcc ChkFireB               ;then skip to world number check for flames
        if (!(A >= 0x80)) {
            //  goto ChkFireB -> chkFireB
            chkFireB(X)
            return
        }
        //> lda PseudoRandomBitReg,x
        A = pseudoRandomBitReg[X]
        //> and #%00000011             ;get pseudorandom offset
        A = A and 0x03
        //> tay
        Y = A
        //> lda PRandomRange,y         ;get value using pseudorandom offset
        A = pRandomRange[Y]
        //> sta EnemyFrameTimer,x      ;set for timer here
        enemyFrameTimer[X] = A
        //  Fall-through tail call to skipToFB
        skipToFB(X)
        return
    } else {
        //> MakeBJump: cmp #$01                   ;if timer not yet about to expire,
        //> bne ChkFireB               ;skip ahead to next part
        if (!(A == 0x01)) {
            //  goto ChkFireB -> chkFireB
            chkFireB(X)
            return
        }
    }
    //> dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> jsr InitVStf               ;initialize movement amount
    temp2 = initVStf(X)
    //> lda #$fe
    A = 0xFE
    //> sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
    enemyYSpeed[X] = A
    //  Fall-through tail call to chkFireB
    chkFireB(X)
    return
}

// Decompiled from SkipToFB
fun skipToFB(X: Int) {
    //> SkipToFB:  jmp ChkFireB               ;jump to execute flames code
    chkFireB(X)
    return
}

// Decompiled from ChkFireB
fun chkFireB(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFireBreathTimer by MemoryByte(BowserFireBreathTimer)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var worldNumber by MemoryByte(WorldNumber)
    X = X
    loop0@ do {
        //> ChkFireB:  lda WorldNumber            ;check world number here
        A = worldNumber
        //> cmp #World8                ;world 8?
        //> beq SpawnFBr               ;if so, execute this part here
        if (A != World8) {
            //> cmp #World6                ;world 6-7?
            //> bcs BowserGfxHandler       ;if so, skip this part here
            if (A >= World6) {
                //  goto BowserGfxHandler
                break@loop0
            }
        }
        //> SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
        A = bowserFireBreathTimer
        //> bne BowserGfxHandler       ;if not expired yet, skip all of this
        if (!(A == 0)) {
            //  goto BowserGfxHandler
            break@loop0
        }
        //> lda #$20
        A = 0x20
        //> sta BowserFireBreathTimer  ;set timer here
        bowserFireBreathTimer = A
        //> lda BowserBodyControls
        A = bowserBodyControls
        //> eor #%10000000             ;invert bowser's mouth bit to open
        A = A xor 0x80
        //> sta BowserBodyControls     ;and close bowser's mouth
        bowserBodyControls = A
        //> bmi ChkFireB               ;if bowser's mouth open, loop back
        if ((A and 0x80) != 0) {
            //  continue loop (branch back to ChkFireB)
            continue@loop0
        }
    } while ((A and 0x80) != 0)
    //> jsr SetFlameTimer          ;get timing for bowser's flame
    temp0 = setFlameTimer()
    //> ldy SecondaryHardMode
    Y = secondaryHardMode
    //> beq SetFBTmr               ;if secondary hard mode flag not set, skip this
    A = temp0
    if (Y != 0) {
        //> sec
        //> sbc #$10                   ;otherwise subtract from value in A
        temp1 = A - 0x10
        A = temp1 and 0xFF
    }
    //> SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
    bowserFireBreathTimer = A
    //> lda #BowserFlame           ;put bowser's flame identifier
    A = BowserFlame
    //> sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
    enemyFrenzyBuffer = A
    //> ;--------------------------------
    //  Fall-through tail call to bowserGfxHandler
    bowserGfxHandler(X, Y)
    return
}

// Decompiled from BowserGfxHandler
fun bowserGfxHandler(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> BowserGfxHandler:
    //> jsr ProcessBowserHalf    ;do a sub here to process bowser's front
    temp0 = processBowserHalf(X, Y)
    X = temp0
    //> ldy #$10                 ;load default value here to position bowser's rear
    Y = 0x10
    //> lda Enemy_MovingDir,x    ;check moving direction
    A = enemyMovingdir[temp0]
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> bcc CopyFToR             ;if moving left, use default
    X = temp0
    if ((orig0 and 0x01) != 0) {
        //> ldy #$f0                 ;otherwise load alternate positioning value here
        Y = 0xF0
    }
    //> CopyFToR: tya                      ;move bowser's rear object position value to A
    A = Y
    //> clc
    //> adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
    temp1 = A + enemyXPosition[X]
    A = temp1 and 0xFF
    //> ldy DuplicateObj_Offset  ;get bowser's rear object offset
    Y = duplicateobjOffset
    //> sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
    enemyXPosition[Y] = A
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> clc                      ;add eight pixels to bowser's front object
    //> adc #$08                 ;vertical coordinate and store as vertical coordinate
    temp2 = A + 0x08
    A = temp2 and 0xFF
    //> sta Enemy_Y_Position,y   ;for bowser's rear
    enemyYPosition[Y] = A
    //> lda Enemy_State,x
    A = enemyState[X]
    //> sta Enemy_State,y        ;copy enemy state directly from front to rear
    enemyState[Y] = A
    //> lda Enemy_MovingDir,x
    A = enemyMovingdir[X]
    //> sta Enemy_MovingDir,y    ;copy moving direction also
    enemyMovingdir[Y] = A
    //> lda ObjectOffset         ;save enemy object offset of front to stack
    A = objectOffset
    //> pha
    push(A)
    //> ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
    X = duplicateobjOffset
    //> stx ObjectOffset
    objectOffset = X
    //> lda #Bowser              ;set bowser's enemy identifier
    A = Bowser
    //> sta Enemy_ID,x           ;store in bowser's rear object
    enemyId[X] = A
    //> jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
    temp3 = processBowserHalf(X, Y)
    X = temp3
    //> pla
    A = pull()
    //> sta ObjectOffset         ;get original enemy object offset
    objectOffset = A
    //> tax
    X = A
    //> lda #$00                 ;nullify bowser's front/rear graphics flag
    A = 0x00
    //> sta BowserGfxFlag
    bowserGfxFlag = A
    //  Fall-through tail call to exBGfxH
    exBGfxH()
    return
}

// Decompiled from ExBGfxH
fun exBGfxH() {
    //> ExBGfxH:  rts                      ;leave!
    return
}

// Decompiled from ProcessBowserHalf
fun processBowserHalf(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> ProcessBowserHalf:
    //> inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
    bowserGfxFlag = (bowserGfxFlag + 1) and 0xFF
    //> jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
    val pair0 = runRetainerObj(X, Y)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda Enemy_State,x
    A = enemyState[temp0]
    //> bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
    X = temp0
    Y = temp1
    if (A != 0) {
        //> ExBGfxH:  rts                      ;leave!
        return X
    } else {
        //> lda #$0a
        A = 0x0A
        //> sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
        enemyBoundboxctrl[X] = A
        //> jsr GetEnemyBoundBox      ;get bounding box coordinates
        val pair1 = getEnemyBoundBox(X)
        temp2 = pair1.first
        temp3 = pair1.second
        X = temp2
        //> jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
        return playerEnemyCollision(temp2, temp3)
    }
}

// Decompiled from SetFlameTimer
fun setFlameTimer(): Int {
    var A: Int = 0
    var Y: Int = 0
    var bowserFlameTimerCtrl by MemoryByte(BowserFlameTimerCtrl)
    val flameTimerData by MemoryByteIndexed(FlameTimerData)
    //> SetFlameTimer:
    //> ldy BowserFlameTimerCtrl  ;load counter as offset
    Y = bowserFlameTimerCtrl
    //> inc BowserFlameTimerCtrl  ;increment
    bowserFlameTimerCtrl = (bowserFlameTimerCtrl + 1) and 0xFF
    //> lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
    A = bowserFlameTimerCtrl
    //> and #%00000111            ;to keep in range of 0-7
    A = A and 0x07
    //> sta BowserFlameTimerCtrl
    bowserFlameTimerCtrl = A
    //> lda FlameTimerData,y      ;load value to be used then leave
    A = flameTimerData[Y]
    //  Fall-through tail call to exFl
    exFl()
    return A
}

// Decompiled from ExFl
fun exFl() {
    //> ExFl: rts
    return
}

// Decompiled from ProcBowserFlame
fun procBowserFlame(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var timerControl by MemoryByte(TimerControl)
    val bowserFlamePRandomOfs by MemoryByteIndexed(BowserFlamePRandomOfs)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXMoveforce by MemoryByteIndexed(Enemy_X_MoveForce)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flameYPosData by MemoryByteIndexed(FlameYPosData)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> ProcBowserFlame:
    //> lda TimerControl            ;if master timer control flag set,
    A = timerControl
    //> bne SetGfxF                 ;skip all of this
    X = X
    if (A == 0) {
        //> lda #$40                    ;load default movement force
        A = 0x40
        //> ldy SecondaryHardMode
        Y = secondaryHardMode
        //> beq SFlmX                   ;if secondary hard mode flag not set, use default
        if (Y != 0) {
            //> lda #$60                    ;otherwise load alternate movement force to go faster
            A = 0x60
        }
        //> SFlmX:   sta $00                     ;store value here
        memory[0x0] = A.toUByte()
        //> lda Enemy_X_MoveForce,x
        A = enemyXMoveforce[X]
        //> sec                         ;subtract value from movement force
        //> sbc $00
        temp0 = A - memory[0x0].toInt()
        A = temp0 and 0xFF
        //> sta Enemy_X_MoveForce,x     ;save new value
        enemyXMoveforce[X] = A
        //> lda Enemy_X_Position,x
        A = enemyXPosition[X]
        //> sbc #$01                    ;subtract one from horizontal position to move
        temp1 = A - 0x01 - if (temp0 >= 0) 0 else 1
        A = temp1 and 0xFF
        //> sta Enemy_X_Position,x      ;to the left
        enemyXPosition[X] = A
        //> lda Enemy_PageLoc,x
        A = enemyPageloc[X]
        //> sbc #$00                    ;subtract borrow from page location
        temp2 = A - if (temp1 >= 0) 0 else 1
        A = temp2 and 0xFF
        //> sta Enemy_PageLoc,x
        enemyPageloc[X] = A
        //> ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
        Y = bowserFlamePRandomOfs[X]
        //> lda Enemy_Y_Position,x      ;load vertical coordinate
        A = enemyYPosition[X]
        //> cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
        //> beq SetGfxF                 ;if equal, branch and do not modify coordinate
        if (A != flameYPosData[Y]) {
            //> clc
            //> adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
            temp3 = A + enemyYMoveforce[X]
            A = temp3 and 0xFF
            //> sta Enemy_Y_Position,x      ;as new vertical coordinate
            enemyYPosition[X] = A
        }
    }
    //> SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
    temp4 = relativeEnemyPosition(X)
    X = temp4
    //> lda Enemy_State,x           ;if bowser's flame not in normal state,
    A = enemyState[temp4]
    //> bne ExFl                    ;branch to leave
    X = temp4
    if (A != 0) {
        //> ExFl: rts
        return X
    } else {
        //> lda #$51                    ;otherwise, continue
        A = 0x51
        //> sta $00                     ;write first tile number
        memory[0x0] = A.toUByte()
        //> ldy #$02                    ;load attributes without vertical flip by default
        Y = 0x02
        //> lda FrameCounter
        A = frameCounter
        //> and #%00000010              ;invert vertical flip bit every 2 frames
        A = A and 0x02
        //> beq FlmeAt                  ;if d1 not set, write default value
        if (A != 0) {
            //> ldy #$82                    ;otherwise write value with vertical flip bit set
            Y = 0x82
        }
    }
    //> FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
    memory[0x1] = Y.toUByte()
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    Y = enemySprdataoffset[X]
    //> ldx #$00
    X = 0x00
    loop0@ do {
        //> DrawFlameLoop:
        //> lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
        A = enemyRelYpos
        //> sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
        spriteYPosition[Y] = A
        //> lda $00
        A = memory[0x0].toInt()
        //> sta Sprite_Tilenumber,y    ;write current tile number into OAM data
        spriteTilenumber[Y] = A
        //> inc $00                    ;increment tile number to draw more bowser's flame
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> lda $01
        A = memory[0x1].toInt()
        //> sta Sprite_Attributes,y    ;write saved attributes into OAM data
        spriteAttributes[Y] = A
        //> lda Enemy_Rel_XPos
        A = enemyRelXpos
        //> sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
        spriteXPosition[Y] = A
        //> clc
        //> adc #$08
        temp5 = A + 0x08
        A = temp5 and 0xFF
        //> sta Enemy_Rel_XPos         ;then add eight to it and store
        enemyRelXpos = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                        ;increment Y four times to move onto the next OAM
        Y = (Y + 1) and 0xFF
        //> inx                        ;move onto the next OAM, and branch if three
        X = (X + 1) and 0xFF
        //> cpx #$03                   ;have not yet been done
        //> bcc DrawFlameLoop
        if (!(X >= 0x03)) {
            //  continue loop (branch back to DrawFlameLoop)
            continue@loop0
        }
    } while (!(X >= 0x03))
    //> ldx ObjectOffset           ;reload original enemy offset
    X = objectOffset
    //> jsr GetEnemyOffscreenBits  ;get offscreen information
    val pair0 = getEnemyOffscreenBits(X)
    temp6 = pair0.first
    temp7 = pair0.second
    X = temp6
    //> ldy Enemy_SprDataOffset,x  ;get OAM data offset
    Y = enemySprdataoffset[temp6]
    //> lda Enemy_OffscreenBits    ;get enemy object offscreen bits
    A = enemyOffscreenbits
    //> lsr                        ;move d0 to carry and result to stack
    val orig0: Int = A
    A = orig0 shr 1
    //> pha
    push(A)
    //> bcc M3FOfs                 ;branch if carry not set
    X = temp6
    if ((orig0 and 0x01) != 0) {
        //> lda #$f8                   ;otherwise move sprite offscreen, this part likely
        A = 0xF8
        //> sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
        spriteYPosition[12 + Y] = A
    }
    //> M3FOfs:  pla                        ;get bits from stack
    A = pull()
    //> lsr                        ;move d1 to carry and move bits back to stack
    val orig1: Int = A
    A = orig1 shr 1
    //> pha
    push(A)
    //> bcc M2FOfs                 ;branch if carry not set again
    if ((orig1 and 0x01) != 0) {
        //> lda #$f8                   ;otherwise move third sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position+8,y
        spriteYPosition[8 + Y] = A
    }
    //> M2FOfs:  pla                        ;get bits from stack again
    A = pull()
    //> lsr                        ;move d2 to carry and move bits back to stack again
    val orig2: Int = A
    A = orig2 shr 1
    //> pha
    push(A)
    //> bcc M1FOfs                 ;branch if carry not set yet again
    if ((orig2 and 0x01) != 0) {
        //> lda #$f8                   ;otherwise move second sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position+4,y
        spriteYPosition[4 + Y] = A
    }
    //> M1FOfs:  pla                        ;get bits from stack one last time
    A = pull()
    //> lsr                        ;move d3 to carry
    val orig3: Int = A
    A = orig3 shr 1
    //> bcc ExFlmeD                ;branch if carry not set one last time
    if ((orig3 and 0x01) != 0) {
        //> lda #$f8
        A = 0xF8
        //> sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
        spriteYPosition[Y] = A
    }
    //> ExFlmeD: rts                        ;leave
    return X
}

// Decompiled from RunFireworks
fun runFireworks(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var fireballRelXpos by MemoryByte(Fireball_Rel_XPos)
    var fireballRelYpos by MemoryByte(Fireball_Rel_YPos)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val explosionGfxCounter by MemoryByteIndexed(ExplosionGfxCounter)
    val explosionTimerCounter by MemoryByteIndexed(ExplosionTimerCounter)
    //> RunFireworks:
    //> dec ExplosionTimerCounter,x ;decrement explosion timing counter here
    explosionTimerCounter[X] = (explosionTimerCounter[X] - 1) and 0xFF
    //> bne SetupExpl               ;if not expired, skip this part
    X = X
    if (explosionTimerCounter[X] == 0) {
        //> lda #$08
        A = 0x08
        //> sta ExplosionTimerCounter,x ;reset counter
        explosionTimerCounter[X] = A
        //> inc ExplosionGfxCounter,x   ;increment explosion graphics counter
        explosionGfxCounter[X] = (explosionGfxCounter[X] + 1) and 0xFF
        //> lda ExplosionGfxCounter,x
        A = explosionGfxCounter[X]
        //> cmp #$03                    ;check explosion graphics counter
        //> bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
        if (A >= 0x03) {
            //  goto FireworksSoundScore (internal forward branch)
            //> FireworksSoundScore:
            //> lda #$00               ;disable enemy buffer flag
            A = 0x00
            //> sta Enemy_Flag,x
            enemyFlag[X] = A
            //> lda #Sfx_Blast         ;play fireworks/gunfire sound
            A = Sfx_Blast
            //> sta Square2SoundQueue
            square2SoundQueue = A
            //> lda #$05               ;set part of score modifier for 500 points
            A = 0x05
            //> sta DigitModifier+4
            digitModifier[4] = A
            //> jmp EndAreaPoints     ;jump to award points accordingly then leave
            endAreaPoints()
            return
        }
    } else {
        //> SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
        temp0 = relativeEnemyPosition(X)
        X = temp0
        //> lda Enemy_Rel_YPos          ;copy relative coordinates
        A = enemyRelYpos
        //> sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
        fireballRelYpos = A
        //> lda Enemy_Rel_XPos          ;first vertical, then horizontal
        A = enemyRelXpos
        //> sta Fireball_Rel_XPos
        fireballRelXpos = A
        //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
        Y = enemySprdataoffset[temp0]
        //> lda ExplosionGfxCounter,x   ;get explosion graphics counter
        A = explosionGfxCounter[temp0]
        //> jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
        drawexplosionFireworks(A, Y)
        //> rts
        return
    }
}

// Decompiled from RunStarFlagObj
fun runStarFlagObj(X: Int) {
    var A: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    //> RunStarFlagObj:
    //> lda #$00                 ;initialize enemy frenzy buffer
    A = 0x00
    //> sta EnemyFrenzyBuffer
    enemyFrenzyBuffer = A
    //> lda StarFlagTaskControl  ;check star flag object task number here
    A = starFlagTaskControl
    //> cmp #$05                 ;if greater than 5, branch to exit
    //> bcs StarFlagExit
    if (A >= 0x05) {
        //  goto StarFlagExit -> starFlagExit
        starFlagExit()
        return
    } else {
        //> jsr JumpEngine           ;otherwise jump to appropriate sub
        when (A) {
            0 -> {
                starFlagExit()
            }
            1 -> {
                gameTimerFireworks(X)
            }
            2 -> {
                awardGameTimerPoints()
            }
            3 -> {
                raiseFlagSetoffFWorks(X)
            }
            4 -> {
                delayToAreaEnd(X)
            }
            else -> {
                // Unknown JumpEngine index
            }
        }
        return
    }
}

// Decompiled from GameTimerFireworks
fun gameTimerFireworks(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var fireworksCounter by MemoryByte(FireworksCounter)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    //> GameTimerFireworks:
    //> ldy #$05               ;set default state for star flag object
    Y = 0x05
    //> lda GameTimerDisplay+2 ;get game timer's last digit
    A = gameTimerDisplay[2]
    //> cmp #$01
    //> beq SetFWC             ;if last digit of game timer set to 1, skip ahead
    X = X
    if (A != 0x01) {
        //> ldy #$03               ;otherwise load new value for state
        Y = 0x03
        //> cmp #$03
        //> beq SetFWC             ;if last digit of game timer set to 3, skip ahead
        if (A != 0x03) {
            //> ldy #$00               ;otherwise load one more potential value for state
            Y = 0x00
            //> cmp #$06
            //> beq SetFWC             ;if last digit of game timer set to 6, skip ahead
            if (A != 0x06) {
                //> lda #$ff               ;otherwise set value for no fireworks
                A = 0xFF
            }
        }
    }
    //> SetFWC: sta FireworksCounter   ;set fireworks counter here
    fireworksCounter = A
    //> sty Enemy_State,x      ;set whatever state we have in star flag object
    enemyState[X] = Y
    //  Fall-through tail call to incrementSFTask1
    incrementSFTask1()
    return
}

// Decompiled from IncrementSFTask1
fun incrementSFTask1() {
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    //> IncrementSFTask1:
    //> inc StarFlagTaskControl  ;increment star flag object task number
    starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
    //  Fall-through tail call to starFlagExit
    starFlagExit()
    return
}

// Decompiled from StarFlagExit
fun starFlagExit() {
    //> StarFlagExit:
    //> rts                      ;leave
    return
}

// Decompiled from AwardGameTimerPoints
fun awardGameTimerPoints() {
    var A: Int = 0
    var Y: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    //> AwardGameTimerPoints:
    //> lda GameTimerDisplay   ;check all game timer digits for any intervals left
    A = gameTimerDisplay[0]
    //> ora GameTimerDisplay+1
    A = A or gameTimerDisplay[1]
    //> ora GameTimerDisplay+2
    A = A or gameTimerDisplay[2]
    //> beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
    if (A == 0) {
        //  goto IncrementSFTask1 -> incrementSFTask1
        incrementSFTask1()
        return
    } else {
        //> lda FrameCounter
        A = frameCounter
        //> and #%00000100         ;check frame counter for d2 set (skip ahead
        A = A and 0x04
        //> beq NoTTick            ;for four frames every four frames) branch if not set
        if (A != 0) {
            //> lda #Sfx_TimerTick
            A = Sfx_TimerTick
            //> sta Square2SoundQueue  ;load timer tick sound
            square2SoundQueue = A
        }
    }
    //> NoTTick: ldy #$23               ;set offset here to subtract from game timer's last digit
    Y = 0x23
    //> lda #$ff               ;set adder here to $ff, or -1, to subtract one
    A = 0xFF
    //> sta DigitModifier+5    ;from the last digit of the game timer
    digitModifier[5] = A
    //> jsr DigitsMathRoutine  ;subtract digit
    digitsMathRoutine(Y)
    //> lda #$05               ;set now to add 50 points
    A = 0x05
    //> sta DigitModifier+5    ;per game timer interval subtracted
    digitModifier[5] = A
    //  Fall-through tail call to endAreaPoints
    endAreaPoints()
    return
}

// Decompiled from EndAreaPoints
fun endAreaPoints() {
    var A: Int = 0
    var Y: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    //> EndAreaPoints:
    //> ldy #$0b               ;load offset for mario's score by default
    Y = 0x0B
    //> lda CurrentPlayer      ;check player on the screen
    A = currentPlayer
    //> beq ELPGive            ;if mario, do not change
    if (A != 0) {
        //> ldy #$11               ;otherwise load offset for luigi's score
        Y = 0x11
    }
    //> ELPGive: jsr DigitsMathRoutine  ;award 50 points per game timer interval
    digitsMathRoutine(Y)
    //> lda CurrentPlayer      ;get player on the screen (or 500 points per
    A = currentPlayer
    //> asl                    ;fireworks explosion if branched here from there)
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                    ;shift to high nybble
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> ora #%00000100         ;add four to set nybble for game timer
    A = A or 0x04
    //> jmp UpdateNumber       ;jump to print the new score and game timer
    updateNumber(A)
    return
}

// Decompiled from RaiseFlagSetoffFWorks
fun raiseFlagSetoffFWorks(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var fireworksCounter by MemoryByte(FireworksCounter)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> RaiseFlagSetoffFWorks:
    //> lda Enemy_Y_Position,x  ;check star flag's vertical position
    A = enemyYPosition[X]
    //> cmp #$72                ;against preset value
    //> bcc SetoffF             ;if star flag higher vertically, branch to other code
    X = X
    if (A >= 0x72) {
        //> dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
        enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
        //> jmp DrawStarFlag        ;and skip this part here
        return drawStarFlag(X)
    } else {
        //> SetoffF: lda FireworksCounter    ;check fireworks counter
        A = fireworksCounter
        //> beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
        if (A != 0) {
            //> bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
            if ((A and 0x80) == 0) {
                //> lda #Fireworks
                A = Fireworks
                //> sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
                enemyFrenzyBuffer = A
                //  Fall-through tail call to drawStarFlag
                return drawStarFlag(X)
            }
        }
    }
    //> DrawFlagSetTimer:
    //> jsr DrawStarFlag          ;do sub to draw star flag
    temp0 = drawStarFlag(X)
    X = temp0
    //> lda #$06
    A = 0x06
    //> sta EnemyIntervalTimer,x  ;set interval timer here
    enemyIntervalTimer[temp0] = A
    //  Fall-through tail call to incrementSFTask2
    incrementSFTask2()
    return X
}

// Decompiled from DrawStarFlag
fun drawStarFlag(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    val starFlagTileData by MemoryByteIndexed(StarFlagTileData)
    val starFlagXPosAdder by MemoryByteIndexed(StarFlagXPosAdder)
    val starFlagYPosAdder by MemoryByteIndexed(StarFlagYPosAdder)
    //> DrawStarFlag:
    //> jsr RelativeEnemyPosition  ;get relative coordinates of star flag
    temp0 = relativeEnemyPosition(X)
    X = temp0
    //> ldy Enemy_SprDataOffset,x  ;get OAM data offset
    Y = enemySprdataoffset[temp0]
    //> ldx #$03                   ;do four sprites
    X = 0x03
    loop0@ do {
        //> DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
        A = enemyRelYpos
        //> clc
        //> adc StarFlagYPosAdder,x    ;add Y coordinate adder data
        temp1 = A + starFlagYPosAdder[X]
        A = temp1 and 0xFF
        //> sta Sprite_Y_Position,y    ;store as Y coordinate
        spriteYPosition[Y] = A
        //> lda StarFlagTileData,x     ;get tile number
        A = starFlagTileData[X]
        //> sta Sprite_Tilenumber,y    ;store as tile number
        spriteTilenumber[Y] = A
        //> lda #$22                   ;set palette and background priority bits
        A = 0x22
        //> sta Sprite_Attributes,y    ;store as attributes
        spriteAttributes[Y] = A
        //> lda Enemy_Rel_XPos         ;get relative horizontal coordinate
        A = enemyRelXpos
        //> clc
        //> adc StarFlagXPosAdder,x    ;add X coordinate adder data
        temp2 = A + starFlagXPosAdder[X]
        A = temp2 and 0xFF
        //> sta Sprite_X_Position,y    ;store as X coordinate
        spriteXPosition[Y] = A
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                        ;increment OAM data offset four bytes
        Y = (Y + 1) and 0xFF
        //> iny                        ;for next sprite
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> dex                        ;move onto next sprite
        X = (X - 1) and 0xFF
        //> bpl DSFLoop                ;do this until all sprites are done
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to DSFLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> ldx ObjectOffset           ;get enemy object offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from IncrementSFTask2
fun incrementSFTask2() {
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    //> IncrementSFTask2:
    //> inc StarFlagTaskControl   ;move onto next task
    starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
    //> rts
    return
}

// Decompiled from DelayToAreaEnd
fun delayToAreaEnd(X: Int) {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    //> DelayToAreaEnd:
    //> jsr DrawStarFlag          ;do sub to draw star flag
    temp0 = drawStarFlag(X)
    X = temp0
    //> lda EnemyIntervalTimer,x  ;if interval timer set in previous task
    A = enemyIntervalTimer[temp0]
    //> bne StarFlagExit2         ;not yet expired, branch to leave
    X = temp0
    if (A == 0) {
        //> lda EventMusicBuffer      ;if event music buffer empty,
        A = eventMusicBuffer
        //> beq IncrementSFTask2      ;branch to increment task
        if (A == 0) {
            //> IncrementSFTask2:
            //> inc StarFlagTaskControl   ;move onto next task
            starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
            //> rts
            return
        }
    }
    //> StarFlagExit2:
    //> rts                       ;otherwise leave
    return
}

// Decompiled from MovePiranhaPlant
fun movePiranhaPlant(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var timerControl by MemoryByte(TimerControl)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val piranhaPlantDownYPos by MemoryByteIndexed(PiranhaPlantDownYPos)
    val piranhaPlantUpYPos by MemoryByteIndexed(PiranhaPlantUpYPos)
    val piranhaplantMoveflag by MemoryByteIndexed(PiranhaPlant_MoveFlag)
    val piranhaplantYSpeed by MemoryByteIndexed(PiranhaPlant_Y_Speed)
    //> MovePiranhaPlant:
    //> lda Enemy_State,x           ;check enemy state
    A = enemyState[X]
    //> bne PutinPipe               ;if set at all, branch to leave
    X = X
    if (A == 0) {
        //> lda EnemyFrameTimer,x       ;check enemy's timer here
        A = enemyFrameTimer[X]
        //> bne PutinPipe               ;branch to end if not yet expired
        if (A == 0) {
            //> lda PiranhaPlant_MoveFlag,x ;check movement flag
            A = piranhaplantMoveflag[X]
            //> bne SetupToMovePPlant       ;if moving, skip to part ahead
            if (A == 0) {
                //> lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
                A = piranhaplantYSpeed[X]
                //> bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
                if ((A and 0x80) == 0) {
                    //> jsr PlayerEnemyDiff         ;get horizontal difference between player and
                    val flag0: Boolean = playerEnemyDiff(X)
                    //> bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
                    if ((A and 0x80) != 0) {
                        //> lda $00                     ;otherwise get saved horizontal difference
                        A = memory[0x0].toInt()
                        //> eor #$ff
                        A = A xor 0xFF
                        //> clc                         ;and change to two's compliment
                        //> adc #$01
                        temp0 = A + 0x01
                        A = temp0 and 0xFF
                        //> sta $00                     ;save as new horizontal difference
                        memory[0x0] = A.toUByte()
                    }
                    //> ChkPlayerNearPipe:
                    //> lda $00                     ;get saved horizontal difference
                    A = memory[0x0].toInt()
                    //> cmp #$21
                    //> bcc PutinPipe               ;if player within a certain distance, branch to leave
                    if (A >= 0x21) {
                    }
                }
                //> ReversePlantSpeed:
                //> lda PiranhaPlant_Y_Speed,x  ;get vertical speed
                A = piranhaplantYSpeed[X]
                //> eor #$ff
                A = A xor 0xFF
                //> clc                         ;change to two's compliment
                //> adc #$01
                temp1 = A + 0x01
                A = temp1 and 0xFF
                //> sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
                piranhaplantYSpeed[X] = A
                //> inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
                piranhaplantMoveflag[X] = (piranhaplantMoveflag[X] + 1) and 0xFF
            }
            //> SetupToMovePPlant:
            //> lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
            A = piranhaPlantDownYPos[X]
            //> ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
            Y = piranhaplantYSpeed[X]
            //> bpl RiseFallPiranhaPlant    ;branch if moving downwards
            if ((Y and 0x80) != 0) {
                //> lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
                A = piranhaPlantUpYPos[X]
            }
            //> RiseFallPiranhaPlant:
            //> sta $00                     ;save vertical coordinate here
            memory[0x0] = A.toUByte()
            //> lda FrameCounter            ;get frame counter
            A = frameCounter
            //> lsr
            val orig1: Int = A
            A = orig1 shr 1
            //> bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
            if ((orig1 and 0x01) != 0) {
                //> lda TimerControl            ;get master timer control
                A = timerControl
                //> bne PutinPipe               ;branch to leave if set (likely not necessary)
                if (A == 0) {
                    //> lda Enemy_Y_Position,x      ;get current vertical coordinate
                    A = enemyYPosition[X]
                    //> clc
                    //> adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
                    temp2 = A + piranhaplantYSpeed[X]
                    A = temp2 and 0xFF
                    //> sta Enemy_Y_Position,x      ;save as new vertical coordinate
                    enemyYPosition[X] = A
                    //> cmp $00                     ;compare against low or high coordinate
                    //> bne PutinPipe               ;branch to leave if not yet reached
                    if (A == memory[0x0].toInt()) {
                        //> lda #$00
                        A = 0x00
                        //> sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
                        piranhaplantMoveflag[X] = A
                        //> lda #$40
                        A = 0x40
                        //> sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
                        enemyFrameTimer[X] = A
                    }
                }
            }
        }
    }
    //> PutinPipe:
    //> lda #%00100000              ;set background priority bit in sprite
    A = 0x20
    //> sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
    enemySprattrib[X] = A
    //> rts                         ;then leave
    return
}

// Decompiled from FirebarSpin
fun firebarSpin(A: Int, X: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val firebarSpinDirection by MemoryByteIndexed(FirebarSpinDirection)
    val firebarspinstateHigh by MemoryByteIndexed(FirebarSpinState_High)
    val firebarspinstateLow by MemoryByteIndexed(FirebarSpinState_Low)
    //> FirebarSpin:
    //> sta $07                     ;save spinning speed here
    memory[0x7] = A.toUByte()
    //> lda FirebarSpinDirection,x  ;check spinning direction
    A = firebarSpinDirection[X]
    //> bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
    X = X
    if (A == 0) {
        //> ldy #$18                    ;possibly residual ldy
        Y = 0x18
        //> lda FirebarSpinState_Low,x
        A = firebarspinstateLow[X]
        //> clc                         ;add spinning speed to what would normally be
        //> adc $07                     ;the horizontal speed
        temp0 = A + memory[0x7].toInt()
        A = temp0 and 0xFF
        //> sta FirebarSpinState_Low,x
        firebarspinstateLow[X] = A
        //> lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
        A = firebarspinstateHigh[X]
        //> adc #$00
        temp1 = A + if (temp0 > 0xFF) 1 else 0
        A = temp1 and 0xFF
        //> rts
        return A
    } else {
        //> SpinCounterClockwise:
        //> ldy #$08                    ;possibly residual ldy
        Y = 0x08
        //> lda FirebarSpinState_Low,x
        A = firebarspinstateLow[X]
        //> sec                         ;subtract spinning speed to what would normally be
        //> sbc $07                     ;the horizontal speed
        temp2 = A - memory[0x7].toInt()
        A = temp2 and 0xFF
        //> sta FirebarSpinState_Low,x
        firebarspinstateLow[X] = A
        //> lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
        A = firebarspinstateHigh[X]
        //> sbc #$00
        temp3 = A - if (temp2 >= 0) 0 else 1
        A = temp3 and 0xFF
        //> rts
        return A
    }
}

// Decompiled from BalancePlatform
fun balancePlatform(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> BalancePlatform:
    //> lda Enemy_Y_HighPos,x       ;check high byte of vertical position
    A = enemyYHighpos[X]
    //> cmp #$03
    //> bne DoBPl
    X = X
    if (A == 0x03) {
        //> jmp EraseEnemyObject        ;if far below screen, kill the object
        eraseEnemyObject(X)
        return Pair(A, X)
    } else {
        //> DoBPl: lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
        A = enemyState[X]
        //> bpl CheckBalPlatform        ;if doing other balance platform, branch to leave
        if ((A and 0x80) != 0) {
            //> rts
            return Pair(A, X)
        }
    }
    //> CheckBalPlatform:
    //> tay                         ;save offset from state as Y
    Y = A
    //> lda PlatformCollisionFlag,x ;get collision flag of platform
    A = platformCollisionFlag[X]
    //> sta $00                     ;store here
    memory[0x0] = A.toUByte()
    //> lda Enemy_MovingDir,x       ;get moving direction
    A = enemyMovingdir[X]
    //> beq ChkForFall
    Y = Y
    if (A != 0) {
        //> jmp PlatformFall            ;if set, jump here
        platformFall(X, Y)
        return Pair(A, X)
    } else {
        //> ChkForFall:
        //> lda #$2d                    ;check if platform is above a certain point
        A = 0x2D
        //> cmp Enemy_Y_Position,x
        //> bcc ChkOtherForFall         ;if not, branch elsewhere
        if (A >= enemyYPosition[X]) {
            //> cpy $00                     ;if collision flag is set to same value as
            //> beq MakePlatformFall        ;enemy state, branch to make platforms fall
            if (Y != memory[0x0].toInt()) {
                //> clc
                //> adc #$02                    ;otherwise add 2 pixels to vertical position
                temp0 = A + 0x02
                A = temp0 and 0xFF
                //> sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
                enemyYPosition[X] = A
                //> jmp StopPlatforms           ;to make platforms stop
                stopPlatforms(A, X, Y)
                return Pair(A, X)
            }
            //> MakePlatformFall:
            //> jmp InitPlatformFall        ;make platforms fall
            initPlatformFall(Y)
            return Pair(A, X)
        }
    }
    //> ChkOtherForFall:
    //> cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
    //> bcc ChkToMoveBalPlat        ;if not, branch elsewhere
    if (A >= enemyYPosition[Y]) {
        //> cpx $00                     ;if collision flag is set to same value as
        //> beq MakePlatformFall        ;enemy state, branch to make platforms fall
        if (X == memory[0x0].toInt()) {
            //> MakePlatformFall:
            //> jmp InitPlatformFall        ;make platforms fall
            initPlatformFall(Y)
            return Pair(A, X)
        }
        //> clc
        //> adc #$02                    ;otherwise add 2 pixels to vertical position
        temp1 = A + 0x02
        A = temp1 and 0xFF
        //> sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
        enemyYPosition[Y] = A
        //> jmp StopPlatforms           ;jump to stop movement and do not return
        stopPlatforms(A, X, Y)
        return Pair(A, X)
    } else {
        //> ChkToMoveBalPlat:
        //> lda Enemy_Y_Position,x      ;save vertical position to stack
        A = enemyYPosition[X]
        //> pha
        push(A)
        //> lda PlatformCollisionFlag,x ;get collision flag
        A = platformCollisionFlag[X]
        //> bpl ColFlg                  ;branch if collision
        if ((A and 0x80) != 0) {
            //> lda Enemy_Y_MoveForce,x
            A = enemyYMoveforce[X]
            //> clc                         ;add $05 to contents of moveforce, whatever they be
            //> adc #$05
            temp2 = A + 0x05
            A = temp2 and 0xFF
            //> sta $00                     ;store here
            memory[0x0] = A.toUByte()
            //> lda Enemy_Y_Speed,x
            A = enemyYSpeed[X]
            //> adc #$00                    ;add carry to vertical speed
            temp3 = A + if (temp2 > 0xFF) 1 else 0
            A = temp3 and 0xFF
            //> bmi PlatDn                  ;branch if moving downwards
            if ((temp3 and 0xFF and 0x80) == 0) {
                //> bne PlatUp                  ;branch elsewhere if moving upwards
                if ((temp3 and 0xFF) == 0) {
                    //> lda $00
                    A = memory[0x0].toInt()
                    //> cmp #$0b                    ;check if there's still a little force left
                    //> bcc PlatSt                  ;if not enough, branch to stop movement
                    if (A >= 0x0B) {
                        //> bcs PlatUp                  ;otherwise keep branch to move upwards
                        if (A >= 0x0B) {
                            //  goto PlatUp (internal forward branch)
                            //> PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
                            movePlatformUp()
                            //> jmp DoOtherPlatform         ;jump ahead to remaining code
                            doOtherPlatform(X)
                            return Pair(A, X)
                        }
                    } else {
                        //> PlatSt: jsr StopPlatforms           ;do a sub to stop movement
                        stopPlatforms(A, X, Y)
                        //> jmp DoOtherPlatform         ;jump ahead to remaining code
                        doOtherPlatform(X)
                        return Pair(A, X)
                    }
                }
            }
        }
    }
    //> ColFlg: cmp ObjectOffset            ;if collision flag matches
    //> beq PlatDn                  ;current enemy object offset, branch
    if (A != objectOffset) {
        //> PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
        movePlatformUp()
        //> jmp DoOtherPlatform         ;jump ahead to remaining code
        doOtherPlatform(X)
        return Pair(A, X)
        //> PlatSt: jsr StopPlatforms           ;do a sub to stop movement
        stopPlatforms(A, X, Y)
        //> jmp DoOtherPlatform         ;jump ahead to remaining code
        doOtherPlatform(X)
        return Pair(A, X)
    } else {
        //> PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
        temp4 = movePlatformDown(X)
        X = temp4
        //  Fall-through tail call to doOtherPlatform
        doOtherPlatform(temp4)
        return Pair(A, X)
    }
}

// Decompiled from DoOtherPlatform
fun doOtherPlatform(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> DoOtherPlatform:
    //> ldy Enemy_State,x           ;get offset of other platform
    Y = enemyState[X]
    //> pla                         ;get old vertical coordinate from stack
    temp0 = pull()
    //> sec
    //> sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
    temp1 = temp0 - enemyYPosition[X]
    //> clc
    //> adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
    temp2 = (temp1 and 0xFF) + enemyYPosition[Y]
    //> sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
    enemyYPosition[Y] = temp2 and 0xFF
    //> lda PlatformCollisionFlag,x ;if no collision, skip this part here
    A = platformCollisionFlag[X]
    //> bmi DrawEraseRope
    X = X
    if ((A and 0x80) == 0) {
        //> tax                         ;put offset which collision occurred here
        X = A
        //> jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
        positionPlayerOnVPlat()
    }
    //> DrawEraseRope:
    //> ldy ObjectOffset            ;get enemy object offset
    Y = objectOffset
    //> lda Enemy_Y_Speed,y         ;check to see if current platform is
    A = enemyYSpeed[Y]
    //> ora Enemy_Y_MoveForce,y     ;moving at all
    A = A or enemyYMoveforce[Y]
    //> beq ExitRp                  ;if not, skip all of this and branch to leave
    if (A == 0) {
        //  goto ExitRp -> exitRp
        exitRp()
        return X
    } else {
        //> ldx VRAM_Buffer1_Offset     ;get vram buffer offset
        X = vramBuffer1Offset
        //> cpx #$20                    ;if offset beyond a certain point, go ahead
        //> bcs ExitRp                  ;and skip this, branch to leave
        if (X >= 0x20) {
            //  goto ExitRp -> exitRp
            exitRp()
            return X
        }
    }
    //> lda Enemy_Y_Speed,y
    A = enemyYSpeed[Y]
    //> pha                         ;save two copies of vertical speed to stack
    push(A)
    //> pha
    push(A)
    //> jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
    temp3 = setupPlatformRope(A, Y)
    X = temp3
    //> lda $01                     ;write name table address to vram buffer
    A = memory[0x1].toInt()
    //> sta VRAM_Buffer1,x          ;first the high byte, then the low
    vramBuffer1[temp3] = A
    //> lda $00
    A = memory[0x0].toInt()
    //> sta VRAM_Buffer1+1,x
    vramBuffer1[1 + temp3] = A
    //> lda #$02                    ;set length for 2 bytes
    A = 0x02
    //> sta VRAM_Buffer1+2,x
    vramBuffer1[2 + temp3] = A
    //> lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
    A = enemyYSpeed[Y]
    //> bmi EraseR1                 ;to do something else
    X = temp3
    if ((A and 0x80) == 0) {
        //> lda #$a2
        A = 0xA2
        //> sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
        vramBuffer1[3 + X] = A
        //> lda #$a3                    ;and right sides of rope in vram buffer
        A = 0xA3
        //> sta VRAM_Buffer1+4,x
        vramBuffer1[4 + X] = A
        //> jmp OtherRope               ;jump to skip this part
        return otherRope(X, Y)
    } else {
        //> EraseR1: lda #$24                    ;put blank tiles in vram buffer
        A = 0x24
        //> sta VRAM_Buffer1+3,x        ;to erase rope
        vramBuffer1[3 + X] = A
        //> sta VRAM_Buffer1+4,x
        vramBuffer1[4 + X] = A
        //  Fall-through tail call to otherRope
        return otherRope(X, Y)
    }
}

// Decompiled from OtherRope
fun otherRope(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> OtherRope:
    //> lda Enemy_State,y           ;get offset of other platform from state
    A = enemyState[Y]
    //> tay                         ;use as Y here
    Y = A
    //> pla                         ;pull second copy of vertical speed from stack
    A = pull()
    //> eor #$ff                    ;invert bits to reverse speed
    A = A xor 0xFF
    //> jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
    temp0 = setupPlatformRope(A, Y)
    X = temp0
    //> lda $01                     ;write name table address to vram buffer
    A = memory[0x1].toInt()
    //> sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
    vramBuffer1[5 + temp0] = A
    //> lda $00                     ;the other platform
    A = memory[0x0].toInt()
    //> sta VRAM_Buffer1+6,x
    vramBuffer1[6 + temp0] = A
    //> lda #$02
    A = 0x02
    //> sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
    vramBuffer1[7 + temp0] = A
    //> pla                         ;pull first copy of vertical speed from stack
    A = pull()
    //> bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
    X = temp0
    Y = Y
    if ((A and 0x80) != 0) {
        //> lda #$a2
        A = 0xA2
        //> sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
        vramBuffer1[8 + X] = A
        //> lda #$a3                    ;and right sides of rope in vram
        A = 0xA3
        //> sta VRAM_Buffer1+9,x        ;transfer buffer
        vramBuffer1[9 + X] = A
        //> jmp EndRp                   ;jump to skip this part
        endRp(X)
        return X
    } else {
        //> EraseR2: lda #$24                    ;put blank tiles in vram buffer
        A = 0x24
        //> sta VRAM_Buffer1+8,x        ;to erase rope
        vramBuffer1[8 + X] = A
        //> sta VRAM_Buffer1+9,x
        vramBuffer1[9 + X] = A
        //  Fall-through tail call to endRp
        endRp(X)
        return X
    }
}

// Decompiled from EndRp
fun endRp(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> EndRp:   lda #$00                    ;put null terminator at the end
    A = 0x00
    //> sta VRAM_Buffer1+10,x
    vramBuffer1[10 + X] = A
    //> lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
    A = vramBuffer1Offset
    //> clc                         ;and store
    //> adc #10
    temp0 = A + 0x0A
    A = temp0 and 0xFF
    //> sta VRAM_Buffer1_Offset
    vramBuffer1Offset = A
    //  Fall-through tail call to exitRp
    exitRp()
    return
}

// Decompiled from ExitRp
fun exitRp() {
    var X: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from SetupPlatformRope
fun setupPlatformRope(A: Int, Y: Int): Int {
    var A: Int = A
    var X: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> SetupPlatformRope:
    //> pha                     ;save second/third copy to stack
    push(A)
    //> lda Enemy_X_Position,y  ;get horizontal coordinate
    A = enemyXPosition[Y]
    //> clc
    //> adc #$08                ;add eight pixels
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> ldx SecondaryHardMode   ;if secondary hard mode flag set,
    X = secondaryHardMode
    //> bne GetLRp              ;use coordinate as-is
    Y = Y
    if (X == 0) {
        //> clc
        //> adc #$10                ;otherwise add sixteen more pixels
        temp1 = A + 0x10
        A = temp1 and 0xFF
    }
    //> GetLRp: pha                     ;save modified horizontal coordinate to stack
    push(A)
    //> lda Enemy_PageLoc,y
    A = enemyPageloc[Y]
    //> adc #$00                ;add carry to page location
    temp2 = A
    A = temp2 and 0xFF
    //> sta $02                 ;and save here
    memory[0x2] = A.toUByte()
    //> pla                     ;pull modified horizontal coordinate
    A = pull()
    //> and #%11110000          ;from the stack, mask out low nybble
    A = A and 0xF0
    //> lsr                     ;and shift three bits to the right
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> sta $00                 ;store result here as part of name table low byte
    memory[0x0] = A.toUByte()
    //> ldx Enemy_Y_Position,y  ;get vertical coordinate
    X = enemyYPosition[Y]
    //> pla                     ;get second/third copy of vertical speed from stack
    A = pull()
    //> bpl GetHRp              ;skip this part if moving downwards or not at all
    if ((A and 0x80) != 0) {
        //> txa
        A = X
        //> clc
        //> adc #$08                ;add eight to vertical coordinate and
        temp3 = A + 0x08
        A = temp3 and 0xFF
        //> tax                     ;save as X
        X = A
    }
    //> GetHRp: txa                     ;move vertical coordinate to A
    A = X
    //> ldx VRAM_Buffer1_Offset ;get vram buffer offset
    X = vramBuffer1Offset
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> rol                     ;rotate d7 to d0 and d6 into carry
    val orig4: Int = A
    A = (orig4 shl 1) and 0xFE or if ((orig3 and 0x80) != 0) 1 else 0
    //> pha                     ;save modified vertical coordinate to stack
    push(A)
    //> rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
    val orig5: Int = A
    A = (orig5 shl 1) and 0xFE or if ((orig4 and 0x80) != 0) 1 else 0
    //> and #%00000011          ;mask out all bits but d7 and d6, then set
    A = A and 0x03
    //> ora #%00100000          ;d5 to get appropriate high byte of name table
    A = A or 0x20
    //> sta $01                 ;address, then store
    memory[0x1] = A.toUByte()
    //> lda $02                 ;get saved page location from earlier
    A = memory[0x2].toInt()
    //> and #$01                ;mask out all but LSB
    A = A and 0x01
    //> asl
    val orig6: Int = A
    A = (orig6 shl 1) and 0xFF
    //> asl                     ;shift twice to the left and save with the
    val orig7: Int = A
    A = (orig7 shl 1) and 0xFF
    //> ora $01                 ;rest of the bits of the high byte, to get
    A = A or memory[0x1].toInt()
    //> sta $01                 ;the proper name table and the right place on it
    memory[0x1] = A.toUByte()
    //> pla                     ;get modified vertical coordinate from stack
    A = pull()
    //> and #%11100000          ;mask out low nybble and LSB of high nybble
    A = A and 0xE0
    //> clc
    //> adc $00                 ;add to horizontal part saved here
    temp4 = A + memory[0x0].toInt()
    A = temp4 and 0xFF
    //> sta $00                 ;save as name table low byte
    memory[0x0] = A.toUByte()
    //> lda Enemy_Y_Position,y
    A = enemyYPosition[Y]
    //> cmp #$e8                ;if vertical position not below the
    //> bcc ExPRp               ;bottom of the screen, we're done, branch to leave
    if (A >= 0xE8) {
        //> lda $00
        A = memory[0x0].toInt()
        //> and #%10111111          ;mask out d6 of low byte of name table address
        A = A and 0xBF
        //> sta $00
        memory[0x0] = A.toUByte()
    }
    //> ExPRp:  rts                     ;leave!
    return X
}

// Decompiled from InitPlatformFall
fun initPlatformFall(Y: Int): Int {
    var A: Int = 0
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerRelXpos by MemoryByte(Player_Rel_XPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val floateynumXPos by MemoryByteIndexed(FloateyNum_X_Pos)
    val floateynumYPos by MemoryByteIndexed(FloateyNum_Y_Pos)
    //> InitPlatformFall:
    //> tya                        ;move offset of other platform from Y to X
    A = Y
    //> tax
    X = A
    //> jsr GetEnemyOffscreenBits  ;get offscreen bits
    val pair0 = getEnemyOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> lda #$06
    A = 0x06
    //> jsr SetupFloateyNumber     ;award 1000 points to player
    temp2 = setupFloateyNumber(A, temp0)
    //> lda Player_Rel_XPos
    A = playerRelXpos
    //> sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
    floateynumXPos[temp0] = A
    //> lda Player_Y_Position
    A = playerYPosition
    //> sta FloateyNum_Y_Pos,x
    floateynumYPos[temp0] = A
    //> lda #$01                   ;set moving direction as flag for
    A = 0x01
    //> sta Enemy_MovingDir,x      ;falling platforms
    enemyMovingdir[temp0] = A
    //  Fall-through tail call to stopPlatforms
    stopPlatforms(A, temp0, temp1)
    return X
}

// Decompiled from StopPlatforms
fun stopPlatforms(A: Int, X: Int, Y: Int) {
    var temp0: Int = 0
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> StopPlatforms:
    //> jsr InitVStf             ;initialize vertical speed and low byte
    temp0 = initVStf(X)
    //> sta Enemy_Y_Speed,y      ;for both platforms and leave
    enemyYSpeed[Y] = temp0
    //> sta Enemy_Y_MoveForce,y
    enemyYMoveforce[Y] = temp0
    //> rts
    return
}

// Decompiled from PlatformFall
fun platformFall(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> PlatformFall:
    //> tya                         ;save offset for other platform to stack
    A = Y
    //> pha
    push(A)
    //> jsr MoveFallingPlatform     ;make current platform fall
    temp0 = moveFallingPlatform(X)
    X = temp0
    //> pla
    temp1 = pull()
    //> tax                         ;pull offset from stack and save to X
    X = temp1
    //> jsr MoveFallingPlatform     ;make other platform fall
    temp2 = moveFallingPlatform(X)
    X = temp2
    //> ldx ObjectOffset
    X = objectOffset
    //> lda PlatformCollisionFlag,x ;if player not standing on either platform,
    A = platformCollisionFlag[X]
    //> bmi ExPF                    ;skip this part
    Y = Y
    if ((A and 0x80) == 0) {
        //> tax                         ;transfer collision flag offset as offset to X
        X = A
        //> jsr PositionPlayerOnVPlat   ;and position player appropriately
        positionPlayerOnVPlat()
    }
    //> ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from YMovingPlatform
fun yMovingPlatform(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val yPlatformCenterYPos by MemoryByteIndexed(YPlatformCenterYPos)
    val yPlatformTopYPos by MemoryByteIndexed(YPlatformTopYPos)
    //> YMovingPlatform:
    //> lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
    A = enemyYSpeed[X]
    //> ora Enemy_Y_MoveForce,x      ;check on other position
    A = A or enemyYMoveforce[X]
    //> bne ChkYCenterPos
    X = X
    if (A == 0) {
        //> sta Enemy_YMF_Dummy,x        ;initialize dummy variable
        enemyYmfDummy[X] = A
        //> lda Enemy_Y_Position,x
        A = enemyYPosition[X]
        //> cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
        //> bcs ChkYCenterPos            ;ahead of all this
        if (!(A >= yPlatformTopYPos[X])) {
            //> lda FrameCounter
            A = frameCounter
            //> and #%00000111               ;check for every eighth frame
            A = A and 0x07
            //> bne SkipIY
            if (A == 0) {
                //> inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
                enemyYPosition[X] = (enemyYPosition[X] + 1) and 0xFF
            }
            //> SkipIY: jmp ChkYPCollision           ;skip ahead to last part
            chkYPCollision(X)
            return X
        }
    }
    //> ChkYCenterPos:
    //> lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
    A = enemyYPosition[X]
    //> cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
    //> bcc YMDown
    if (A >= yPlatformCenterYPos[X]) {
        //> jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
        movePlatformUp()
        //> jmp ChkYPCollision
        chkYPCollision(X)
        return X
    } else {
        //> YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
        temp0 = movePlatformDown(X)
        X = temp0
        //  Fall-through tail call to chkYPCollision
        chkYPCollision(temp0)
        return X
    }
}

// Decompiled from ChkYPCollision
fun chkYPCollision(X: Int) {
    var A: Int = 0
    var X: Int = X
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> ChkYPCollision:
    //> lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
    A = platformCollisionFlag[X]
    //> bmi ExYPl                    ;to leave
    X = X
    if ((A and 0x80) == 0) {
        //> jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
        positionPlayerOnVPlat()
    }
    //> ExYPl: rts                          ;leave
    return
}

// Decompiled from XMovingPlatform
fun xMovingPlatform(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> XMovingPlatform:
    //> lda #$0e                     ;load preset maximum value for secondary counter
    A = 0x0E
    //> jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
    xmovecntrPlatform(A, X)
    //> jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
    temp0 = moveWithXMCntrs(X)
    X = temp0
    //> lda PlatformCollisionFlag,x  ;if no collision with player,
    A = platformCollisionFlag[temp0]
    //> bmi ExXMP                    ;branch ahead to leave
    if ((A and 0x80) != 0) {
        //  goto ExXMP -> exXMP
        exXMP()
        return X
    } else {
        //  Fall-through tail call to positionPlayerOnHPlat
        positionPlayerOnHPlat()
        return X
    }
}

// Decompiled from PositionPlayerOnHPlat
fun positionPlayerOnHPlat() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    //> PositionPlayerOnHPlat:
    //> lda Player_X_Position
    A = playerXPosition
    //> clc                       ;add saved value from second subroutine to
    //> adc $00                   ;current player's position to position
    temp0 = A + memory[0x0].toInt()
    A = temp0 and 0xFF
    //> sta Player_X_Position     ;player accordingly in horizontal position
    playerXPosition = A
    //> lda Player_PageLoc        ;get player's page location
    A = playerPageloc
    //> ldy $00                   ;check to see if saved value here is positive or negative
    Y = memory[0x0].toInt()
    //> bmi PPHSubt               ;if negative, branch to subtract
    if ((Y and 0x80) == 0) {
        //> adc #$00                  ;otherwise add carry to page location
        temp1 = A + if (temp0 > 0xFF) 1 else 0
        A = temp1 and 0xFF
        //> jmp SetPVar               ;jump to skip subtraction
        setPVar(A, Y)
        return
    } else {
        //> PPHSubt: sbc #$00                  ;subtract borrow from page location
        temp2 = A - if (temp0 > 0xFF) 0 else 1
        A = temp2 and 0xFF
        //  Fall-through tail call to setPVar
        setPVar(A, Y)
        return
    }
}

// Decompiled from SetPVar
fun setPVar(A: Int, Y: Int) {
    var platformXScroll by MemoryByte(Platform_X_Scroll)
    var playerPageloc by MemoryByte(Player_PageLoc)
    //> SetPVar: sta Player_PageLoc        ;save result to player's page location
    playerPageloc = A
    //> sty Platform_X_Scroll     ;put saved value from second sub here to be used later
    platformXScroll = Y
    //> jsr PositionPlayerOnVPlat ;position player vertically and appropriately
    positionPlayerOnVPlat()
    //  Fall-through tail call to exXMP
    exXMP()
    return
}

// Decompiled from ExXMP
fun exXMP() {
    //> ExXMP:   rts                       ;and we are done here
    return
}

// Decompiled from DropPlatform
fun dropPlatform(X: Int) {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> DropPlatform:
    //> lda PlatformCollisionFlag,x  ;if no collision between platform and player
    A = platformCollisionFlag[X]
    //> bmi ExDPl                    ;occurred, just leave without moving anything
    X = X
    if ((A and 0x80) == 0) {
        //> jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
        temp0 = moveDropPlatform()
        //> jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
        positionPlayerOnVPlat()
    }
    //> ExDPl: rts                          ;leave
    return
}

// Decompiled from RightPlatform
fun rightPlatform(A: Int, X: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> RightPlatform:
    //> jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
    val pair0 = moveEnemyHorizontally(A, X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> sta $00                       ;store saved value here (residual code)
    memory[0x0] = temp0.toUByte()
    //> lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
    A = platformCollisionFlag[X]
    //> bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
    Y = temp1
    if ((A and 0x80) == 0) {
        //> lda #$10
        A = 0x10
        //> sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
        enemyXSpeed[X] = A
        //> jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
        positionPlayerOnHPlat()
    }
    //> ExRPl: rts                           ;then leave
    return X
}

// Decompiled from MoveLargeLiftPlat
fun moveLargeLiftPlat(X: Int) {
    //> MoveLargeLiftPlat:
    //> jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
    moveLiftPlatforms(X)
    //> jmp ChkYPCollision     ;branch to position player correctly
    chkYPCollision(X)
    return
}

// Decompiled from MoveSmallPlatform
fun moveSmallPlatform(X: Int) {
    //> MoveSmallPlatform:
    //> jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
    moveLiftPlatforms(X)
    //> jmp ChkSmallPlatCollision  ;branch to position player correctly
    chkSmallPlatCollision(X)
    return
}

// Decompiled from MoveLiftPlatforms
fun moveLiftPlatforms(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var timerControl by MemoryByte(TimerControl)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> MoveLiftPlatforms:
    //> lda TimerControl         ;if master timer control set, skip all of this
    A = timerControl
    //> bne ExLiftP              ;and branch to leave
    if (!(A == 0)) {
        //  goto ExLiftP -> exLiftP
        exLiftP()
        return
    } else {
        //> lda Enemy_YMF_Dummy,x
        A = enemyYmfDummy[X]
        //> clc                      ;add contents of movement amount to whatever's here
        //> adc Enemy_Y_MoveForce,x
        temp0 = A + enemyYMoveforce[X]
        A = temp0 and 0xFF
        //> sta Enemy_YMF_Dummy,x
        enemyYmfDummy[X] = A
        //> lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
        A = enemyYPosition[X]
        //> adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
        temp1 = A + enemyYSpeed[X] + if (temp0 > 0xFF) 1 else 0
        A = temp1 and 0xFF
        //> sta Enemy_Y_Position,x   ;and then leave
        enemyYPosition[X] = A
        //> rts
        return
    }
}

// Decompiled from ChkSmallPlatCollision
fun chkSmallPlatCollision(X: Int) {
    var A: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> ChkSmallPlatCollision:
    //> lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
    A = platformCollisionFlag[X]
    //> beq ExLiftP                 ;if none found, leave player position alone
    if (A == 0) {
        //  goto ExLiftP -> exLiftP
        exLiftP()
        return
    } else {
        //> jsr PositionPlayerOnS_Plat  ;use to position player correctly
        positionplayeronsPlat(A, X)
        //  Fall-through tail call to exLiftP
        exLiftP()
        return
    }
}

// Decompiled from ExLiftP
fun exLiftP() {
    //> ExLiftP: rts                         ;then leave
    return
}

// Decompiled from OffscreenBoundsCheck
fun offscreenBoundsCheck(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> OffscreenBoundsCheck:
    //> lda Enemy_ID,x          ;check for cheep-cheep object
    A = enemyId[X]
    //> cmp #FlyingCheepCheep   ;branch to leave if found
    //> beq ExScrnBd
    X = X
    if (A != FlyingCheepCheep) {
        //> lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
        A = screenleftXPos
        //> ldy Enemy_ID,x
        Y = enemyId[X]
        //> cpy #HammerBro          ;check for hammer bro object
        //> beq LimitB
        if (Y != HammerBro) {
            //> cpy #PiranhaPlant       ;check for piranha plant object
            //> bne ExtendLB            ;these two will be erased sooner than others if too far left
            if (!(Y == PiranhaPlant)) {
                //  goto ExtendLB (internal forward branch - not inlined due to size)
                return
            }
        }
        //> LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
        temp0 = A + 0x38 + if (Y >= HammerBro) 1 else 0
        A = temp0 and 0xFF
        //> ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
        temp1 = A - 0x48 - if (temp0 > 0xFF) 0 else 1
        A = temp1 and 0xFF
        //> sta $01                 ;store result here
        memory[0x1] = A.toUByte()
        //> lda ScreenLeft_PageLoc
        A = screenleftPageloc
        //> sbc #$00                ;subtract borrow from page location of left side
        temp2 = A - if (temp1 >= 0) 0 else 1
        A = temp2 and 0xFF
        //> sta $00                 ;store result here
        memory[0x0] = A.toUByte()
        //> lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
        A = screenrightXPos
        //> adc #$48
        temp3 = A + 0x48 + if (temp2 >= 0) 1 else 0
        A = temp3 and 0xFF
        //> sta $03                 ;store result here
        memory[0x3] = A.toUByte()
        //> lda ScreenRight_PageLoc
        A = screenrightPageloc
        //> adc #$00                ;then add the carry to the page location
        temp4 = A + if (temp3 > 0xFF) 1 else 0
        A = temp4 and 0xFF
        //> sta $02                 ;and store result here
        memory[0x2] = A.toUByte()
        //> lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
        A = enemyXPosition[X]
        //> cmp $01                 ;to modified horizontal left edge coordinate to get carry
        //> lda Enemy_PageLoc,x
        A = enemyPageloc[X]
        //> sbc $00                 ;then subtract it from the page coordinate of the enemy object
        temp5 = A - memory[0x0].toInt() - if (A >= memory[0x1].toInt()) 0 else 1
        A = temp5 and 0xFF
        //> bmi TooFar              ;if enemy object is too far left, branch to erase it
        if ((temp5 and 0xFF and 0x80) == 0) {
            //> lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
            A = enemyXPosition[X]
            //> cmp $03                 ;to modified horizontal right edge coordinate to get carry
            //> lda Enemy_PageLoc,x
            A = enemyPageloc[X]
            //> sbc $02                 ;then subtract it from the page coordinate of the enemy object
            temp6 = A - memory[0x2].toInt() - if (A >= memory[0x3].toInt()) 0 else 1
            A = temp6 and 0xFF
            //> bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
            if ((temp6 and 0xFF and 0x80) == 0) {
                //> lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
                A = enemyState[X]
                //> cmp #HammerBro          ;if in state used by spiny's egg, do not erase
                //> beq ExScrnBd
                if (A != HammerBro) {
                    //> cpy #PiranhaPlant       ;if piranha plant, do not erase
                    //> beq ExScrnBd
                    if (Y != PiranhaPlant) {
                        //> cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
                        //> beq ExScrnBd
                        if (Y != FlagpoleFlagObject) {
                            //> cpy #StarFlagObject     ;if star flag, do not erase
                            //> beq ExScrnBd
                            if (Y != StarFlagObject) {
                                //> cpy #JumpspringObject   ;if jumpspring, do not erase
                                //> beq ExScrnBd            ;erase all others too far to the right
                                if (Y == JumpspringObject) {
                                    //  goto ExScrnBd (internal forward branch)
                                    //> ExScrnBd: rts                     ;leave
                                    return
                                }
                            }
                        }
                    }
                }
            }
        }
        //> TooFar:   jsr EraseEnemyObject    ;erase object if necessary
        temp7 = eraseEnemyObject(X)
    }
    //> ExScrnBd: rts                     ;leave
    return
}

// Decompiled from FireballEnemyCollision
fun fireballEnemyCollision(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val fireballState by MemoryByteIndexed(Fireball_State)
    //> FireballEnemyCollision:
    //> lda Fireball_State,x  ;check to see if fireball state is set at all
    A = fireballState[X]
    //> beq ExitFBallEnemy    ;branch to leave if not
    X = X
    if (A != 0) {
        //> asl
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
        if ((orig0 and 0x80) == 0) {
            //> lda FrameCounter
            A = frameCounter
            //> lsr                   ;get LSB of frame counter
            val orig1: Int = A
            A = orig1 shr 1
            //> bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
            if ((orig1 and 0x01) == 0) {
                //> txa
                A = X
                //> asl                   ;multiply fireball offset by four
                val orig2: Int = A
                A = (orig2 shl 1) and 0xFF
                //> asl
                val orig3: Int = A
                A = (orig3 shl 1) and 0xFF
                //> clc
                //> adc #$1c              ;then add $1c or 28 bytes to it
                temp0 = A + 0x1C
                A = temp0 and 0xFF
                //> tay                   ;to use fireball's bounding box coordinates
                Y = A
                //> ldx #$04
                X = 0x04
                Y = Y
                loop0@ do {
                    //> FireballEnemyCDLoop:
                    //> stx $01                     ;store enemy object offset here
                    memory[0x1] = X.toUByte()
                    //> tya
                    A = Y
                    //> pha                         ;push fireball offset to the stack
                    push(A)
                    //> lda Enemy_State,x
                    A = enemyState[X]
                    //> and #%00100000              ;check to see if d5 is set in enemy state
                    A = A and 0x20
                    //> bne NoFToECol               ;if so, skip to next enemy slot
                    if (A == 0) {
                        //> lda Enemy_Flag,x            ;check to see if buffer flag is set
                        A = enemyFlag[X]
                        //> beq NoFToECol               ;if not, skip to next enemy slot
                        if (A != 0) {
                            //> lda Enemy_ID,x              ;check enemy identifier
                            A = enemyId[X]
                            //> cmp #$24
                            //> bcc GoombaDie               ;if < $24, branch to check further
                            if (A >= 0x24) {
                                //> cmp #$2b
                                //> bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
                                if (!(A >= 0x2B)) {
                                    //  goto NoFToECol (internal forward branch)
                                    //> NoFToECol: pla                         ;pull fireball offset from stack
                                    A = pull()
                                    //> tay                         ;put it in Y
                                    Y = A
                                    //> ldx $01                     ;get enemy object offset
                                    X = memory[0x1].toInt()
                                    //> dex                         ;decrement it
                                    X = (X - 1) and 0xFF
                                    //> bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
                                    if (!((X and 0x80) != 0)) {
                                        //  continue loop (branch back to FireballEnemyCDLoop)
                                        continue@loop0
                                    }
                                    return X
                                }
                            }
                            //> GoombaDie: cmp #Goomba                 ;check for goomba identifier
                            //> bne NotGoomba               ;if not found, continue with code
                            if (A == Goomba) {
                                //> lda Enemy_State,x           ;otherwise check for defeated state
                                A = enemyState[X]
                                //> cmp #$02                    ;if stomped or otherwise defeated,
                                //> bcs NoFToECol               ;skip to next enemy slot
                                if (A >= 0x02) {
                                    //  goto NoFToECol (internal forward branch)
                                    //> NoFToECol: pla                         ;pull fireball offset from stack
                                    A = pull()
                                    //> tay                         ;put it in Y
                                    Y = A
                                    //> ldx $01                     ;get enemy object offset
                                    X = memory[0x1].toInt()
                                    //> dex                         ;decrement it
                                    X = (X - 1) and 0xFF
                                    //> bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
                                    if (!((X and 0x80) != 0)) {
                                        //  continue loop (branch back to FireballEnemyCDLoop)
                                        continue@loop0
                                    }
                                    return X
                                }
                            }
                            //> NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
                            A = enemyOffscrBitsMasked[X]
                            //> bne NoFToECol               ;skip to next enemy slot
                            if (A == 0) {
                                //> txa
                                A = X
                                //> asl                         ;otherwise multiply enemy offset by four
                                val orig4: Int = A
                                A = (orig4 shl 1) and 0xFF
                                //> asl
                                val orig5: Int = A
                                A = (orig5 shl 1) and 0xFF
                                //> clc
                                //> adc #$04                    ;add 4 bytes to it
                                temp1 = A + 0x04
                                A = temp1 and 0xFF
                                //> tax                         ;to use enemy's bounding box coordinates
                                X = A
                                //> jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
                                val flag6: Boolean = sprObjectCollisionCore(X, Y)
                                //> ldx ObjectOffset            ;return fireball's original offset
                                X = objectOffset
                                //> bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
                                if (flag6) {
                                    //> lda #%10000000
                                    A = 0x80
                                    //> sta Fireball_State,x        ;set d7 in enemy state
                                    fireballState[X] = A
                                    //> ldx $01                     ;get enemy offset
                                    X = memory[0x1].toInt()
                                    //> jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
                                    handleEnemyFBallCol(X)
                                }
                            }
                        }
                    }
                    //> NoFToECol: pla                         ;pull fireball offset from stack
                    A = pull()
                    //> tay                         ;put it in Y
                    Y = A
                    //> ldx $01                     ;get enemy object offset
                    X = memory[0x1].toInt()
                    //> dex                         ;decrement it
                    X = (X - 1) and 0xFF
                    //> bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
                    if (!((X and 0x80) != 0)) {
                        //  continue loop (branch back to FireballEnemyCDLoop)
                        continue@loop0
                    }
                } while ((X and 0x80) == 0)
            }
        }
    }
    //> ExitFBallEnemy:
    //> ldx ObjectOffset                 ;get original fireball offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from HandleEnemyFBallCol
fun handleEnemyFBallCol(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var bowserHitPoints by MemoryByte(BowserHitPoints)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var worldNumber by MemoryByte(WorldNumber)
    val bowserIdentities by MemoryByteIndexed(BowserIdentities)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> HandleEnemyFBallCol:
    //> jsr RelativeEnemyPosition  ;get relative coordinate of enemy
    temp0 = relativeEnemyPosition(X)
    X = temp0
    //> ldx $01                    ;get current enemy object offset
    X = memory[0x1].toInt()
    //> lda Enemy_Flag,x           ;check buffer flag for d7 set
    A = enemyFlag[X]
    //> bpl ChkBuzzyBeetle         ;branch if not set to continue
    if ((A and 0x80) != 0) {
        //> and #%00001111             ;otherwise mask out high nybble and
        A = A and 0x0F
        //> tax                        ;use low nybble as enemy offset
        X = A
        //> lda Enemy_ID,x
        A = enemyId[X]
        //> cmp #Bowser                ;check enemy identifier for bowser
        //> beq HurtBowser             ;branch if found
        if (A != Bowser) {
            //> ldx $01                    ;otherwise retrieve current enemy offset
            X = memory[0x1].toInt()
        }
    }
    //> ChkBuzzyBeetle:
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #BuzzyBeetle           ;check for buzzy beetle
    //> beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
    if (A == BuzzyBeetle) {
        //  goto ExHCF -> exHCF
        exHCF()
        return
    } else {
        //> cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
        //> bne ChkOtherEnemies        ;if not found, branch to check other enemies
        if (A == Bowser) {
            //> HurtBowser:
            //> dec BowserHitPoints        ;decrement bowser's hit points
            bowserHitPoints = (bowserHitPoints - 1) and 0xFF
            //> bne ExHCF                  ;if bowser still has hit points, branch to leave
            if (!(bowserHitPoints == 0)) {
                //  goto ExHCF -> exHCF
                exHCF()
                return
            }
            //> jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
            temp1 = initVStf(X)
            //> sta Enemy_X_Speed,x        ;initialize horizontal speed
            enemyXSpeed[X] = temp1
            //> sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
            enemyFrenzyBuffer = temp1
            //> lda #$fe
            A = 0xFE
            //> sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
            enemyYSpeed[X] = A
            //> ldy WorldNumber            ;use world number as offset
            Y = worldNumber
            //> lda BowserIdentities,y     ;get enemy identifier to replace bowser with
            A = bowserIdentities[Y]
            //> sta Enemy_ID,x             ;set as new enemy identifier
            enemyId[X] = A
            //> lda #$20                   ;set A to use starting value for state
            A = 0x20
            //> cpy #$03                   ;check to see if using offset of 3 or more
            //> bcs SetDBSte               ;branch if so
            if (!(Y >= 0x03)) {
                //> ora #$03                   ;otherwise add 3 to enemy state
                A = A or 0x03
            }
            //> SetDBSte: sta Enemy_State,x          ;set defeated enemy state
            enemyState[X] = A
            //> lda #Sfx_BowserFall
            A = Sfx_BowserFall
            //> sta Square2SoundQueue      ;load bowser defeat sound
            square2SoundQueue = A
            //> ldx $01                    ;get enemy offset
            X = memory[0x1].toInt()
            //> lda #$09                   ;award 5000 points to player for defeating bowser
            A = 0x09
            //> bne EnemySmackScore        ;unconditional branch to award points
            if (!(A == 0)) {
                //  goto EnemySmackScore -> enemySmackScore
                enemySmackScore(A, X)
                return
            }
        }
    }
    //> ChkOtherEnemies:
    //> cmp #BulletBill_FrenzyVar
    //> beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
    if (A == BulletBill_FrenzyVar) {
        //  goto ExHCF -> exHCF
        exHCF()
        return
    } else {
        //> cmp #Podoboo
        //> beq ExHCF                 ;branch to leave if podoboo
        if (A == Podoboo) {
            //  goto ExHCF -> exHCF
            exHCF()
            return
        }
    }
    //> cmp #$15
    //> bcs ExHCF                 ;branch to leave if identifier => $15
    if (A >= 0x15) {
        //  goto ExHCF -> exHCF
        exHCF()
        return
    } else {
        //  Fall-through tail call to shellOrBlockDefeat
        shellOrBlockDefeat(X)
        return
    }
}

// Decompiled from ShellOrBlockDefeat
fun shellOrBlockDefeat(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ShellOrBlockDefeat:
    //> lda Enemy_ID,x            ;check for piranha plant
    A = enemyId[X]
    //> cmp #PiranhaPlant
    //> bne StnE                  ;branch if not found
    X = X
    if (A == PiranhaPlant) {
        //> lda Enemy_Y_Position,x
        A = enemyYPosition[X]
        //> adc #$18                  ;add 24 pixels to enemy object's vertical position
        temp0 = A + 0x18 + if (A >= PiranhaPlant) 1 else 0
        A = temp0 and 0xFF
        //> sta Enemy_Y_Position,x
        enemyYPosition[X] = A
    }
    //> StnE: jsr ChkToStunEnemies      ;do yet another sub
    chkToStunEnemies(A, X)
    //> lda Enemy_State,x
    A = enemyState[X]
    //> and #%00011111            ;mask out 2 MSB of enemy object's state
    A = A and 0x1F
    //> ora #%00100000            ;set d5 to defeat enemy and save as new state
    A = A or 0x20
    //> sta Enemy_State,x
    enemyState[X] = A
    //> lda #$02                  ;award 200 points by default
    A = 0x02
    //> ldy Enemy_ID,x            ;check for hammer bro
    Y = enemyId[X]
    //> cpy #HammerBro
    //> bne GoombaPoints          ;branch if not found
    if (Y == HammerBro) {
        //> lda #$06                  ;award 1000 points for hammer bro
        A = 0x06
    }
    //> GoombaPoints:
    //> cpy #Goomba               ;check for goomba
    //> bne EnemySmackScore       ;branch if not found
    if (!(Y == Goomba)) {
        //  goto EnemySmackScore -> enemySmackScore
        enemySmackScore(A, X)
        return
    } else {
        //> lda #$01                  ;award 100 points for goomba
        A = 0x01
        //  Fall-through tail call to enemySmackScore
        enemySmackScore(A, X)
        return
    }
}

// Decompiled from EnemySmackScore
fun enemySmackScore(A: Int, X: Int) {
    var A: Int = A
    var temp0: Int = 0
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    //> EnemySmackScore:
    //> jsr SetupFloateyNumber   ;update necessary score variables
    temp0 = setupFloateyNumber(A, X)
    //> lda #Sfx_EnemySmack      ;play smack enemy sound
    A = Sfx_EnemySmack
    //> sta Square1SoundQueue
    square1SoundQueue = A
    //  Fall-through tail call to exHCF
    exHCF()
    return
}

// Decompiled from ExHCF
fun exHCF() {
    //> ExHCF: rts                      ;and now let's leave
    return
}

// Decompiled from PlayerHammerCollision
fun playerHammerCollision(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var miscOffscreenbits by MemoryByte(Misc_OffscreenBits)
    var objectOffset by MemoryByte(ObjectOffset)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var timerControl by MemoryByte(TimerControl)
    val miscCollisionFlag by MemoryByteIndexed(Misc_Collision_Flag)
    val miscXSpeed by MemoryByteIndexed(Misc_X_Speed)
    //> PlayerHammerCollision:
    //> lda FrameCounter          ;get frame counter
    A = frameCounter
    //> lsr                       ;shift d0 into carry
    val orig0: Int = A
    A = orig0 shr 1
    //> bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
    X = X
    if ((orig0 and 0x01) != 0) {
        //> lda TimerControl          ;if either master timer control
        A = timerControl
        //> ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
        A = A or miscOffscreenbits
        //> bne ExPHC                 ;branch to leave
        if (A == 0) {
            //> txa
            A = X
            //> asl                       ;multiply misc object offset by four
            val orig1: Int = A
            A = (orig1 shl 1) and 0xFF
            //> asl
            val orig2: Int = A
            A = (orig2 shl 1) and 0xFF
            //> clc
            //> adc #$24                  ;add 36 or $24 bytes to get proper offset
            temp0 = A + 0x24
            A = temp0 and 0xFF
            //> tay                       ;for misc object bounding box coordinates
            Y = A
            //> jsr PlayerCollisionCore   ;do player-to-hammer collision detection
            val flag3: Boolean = playerCollisionCore(Y)
            //> ldx ObjectOffset          ;get misc object offset
            X = objectOffset
            //> bcc ClHCol                ;if no collision, then branch
            Y = Y
            if (flag3) {
                //> lda Misc_Collision_Flag,x ;otherwise read collision flag
                A = miscCollisionFlag[X]
                //> bne ExPHC                 ;if collision flag already set, branch to leave
                if (A == 0) {
                    //> lda #$01
                    A = 0x01
                    //> sta Misc_Collision_Flag,x ;otherwise set collision flag now
                    miscCollisionFlag[X] = A
                    //> lda Misc_X_Speed,x
                    A = miscXSpeed[X]
                    //> eor #$ff                  ;get two's compliment of
                    A = A xor 0xFF
                    //> clc                       ;hammer's horizontal speed
                    //> adc #$01
                    temp1 = A + 0x01
                    A = temp1 and 0xFF
                    //> sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
                    miscXSpeed[X] = A
                    //> lda StarInvincibleTimer   ;if star mario invincibility timer set,
                    A = starInvincibleTimer
                    //> bne ExPHC                 ;branch to leave
                    if (A == 0) {
                        //> jmp InjurePlayer          ;otherwise jump to hurt player, do not return
                        injurePlayer()
                        return
                    }
                }
            }
            //> ClHCol: lda #$00                  ;clear collision flag
            A = 0x00
            //> sta Misc_Collision_Flag,x
            miscCollisionFlag[X] = A
        }
    }
    //> ExPHC:  rts
    return
}

// Decompiled from HandlePowerUpCollision
fun handlePowerUpCollision(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerStatus by MemoryByte(PlayerStatus)
    var powerUpType by MemoryByte(PowerUpType)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    //> HandlePowerUpCollision:
    //> jsr EraseEnemyObject    ;erase the power-up object
    temp0 = eraseEnemyObject(X)
    //> lda #$06
    A = 0x06
    //> jsr SetupFloateyNumber  ;award 1000 points to player by default
    temp1 = setupFloateyNumber(A, X)
    //> lda #Sfx_PowerUpGrab
    A = Sfx_PowerUpGrab
    //> sta Square2SoundQueue   ;play the power-up sound
    square2SoundQueue = A
    //> lda PowerUpType         ;check power-up type
    A = powerUpType
    //> cmp #$02
    //> bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
    X = X
    if (A >= 0x02) {
        //> cmp #$03
        //> beq SetFor1Up           ;if 1-up mushroom, branch
        if (A != 0x03) {
            //> lda #$23                ;otherwise set star mario invincibility
            A = 0x23
            //> sta StarInvincibleTimer ;timer, and load the star mario music
            starInvincibleTimer = A
            //> lda #StarPowerMusic     ;into the area music queue, then leave
            A = StarPowerMusic
            //> sta AreaMusicQueue
            areaMusicQueue = A
            //> rts
            return X
        } else {
            //> SetFor1Up:
            //> lda #$0b                 ;change 1000 points into 1-up instead
            A = 0x0B
            //> sta FloateyNum_Control,x ;and then leave
            floateynumControl[X] = A
            //> rts
            return X
        }
    }
    //> Shroom_Flower_PUp:
    //> lda PlayerStatus    ;if player status = small, branch
    A = playerStatus
    //> beq UpToSuper
    if (A != 0) {
        //> cmp #$01            ;if player status not super, leave
        //> bne NoPUp
        if (!(A == 0x01)) {
            //  goto NoPUp -> noPUp
            noPUp()
            return X
        }
        //> ldx ObjectOffset    ;get enemy offset, not necessary
        X = objectOffset
        //> lda #$02            ;set player status to fiery
        A = 0x02
        //> sta PlayerStatus
        playerStatus = A
        //> jsr GetPlayerColors ;run sub to change colors of player
        getPlayerColors()
        //> ldx ObjectOffset    ;get enemy offset again, and again not necessary
        X = objectOffset
        //> lda #$0c            ;set value to be used by subroutine tree (fiery)
        A = 0x0C
        //> jmp UpToFiery       ;jump to set values accordingly
        upToFiery(A)
        return X
        //> SetFor1Up:
        //> lda #$0b                 ;change 1000 points into 1-up instead
        A = 0x0B
        //> sta FloateyNum_Control,x ;and then leave
        floateynumControl[X] = A
        //> rts
        return X
    } else {
        //> UpToSuper:
        //> lda #$01         ;set player status to super
        A = 0x01
        //> sta PlayerStatus
        playerStatus = A
        //> lda #$09         ;set value to be used by subroutine tree (super)
        A = 0x09
        //  Fall-through tail call to upToFiery
        upToFiery(A)
        return X
    }
}

// Decompiled from UpToFiery
fun upToFiery(A: Int) {
    var Y: Int = 0
    //> UpToFiery:
    //> ldy #$00         ;set value to be used as new player state
    Y = 0x00
    //> jsr SetPRout     ;set values to stop certain things in motion
    setPRout(A, Y)
    //  Fall-through tail call to noPUp
    noPUp()
    return
}

// Decompiled from NoPUp
fun noPUp() {
    //> NoPUp: rts
    return
}

// Decompiled from PlayerEnemyCollision
fun playerEnemyCollision(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaType by MemoryByte(AreaType)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var frameCounter by MemoryByte(FrameCounter)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var injuryTimer by MemoryByte(InjuryTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerRelXpos by MemoryByte(Player_Rel_XPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var stompChainCounter by MemoryByte(StompChainCounter)
    var stompTimer by MemoryByte(StompTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyCollisionbits by MemoryByteIndexed(Enemy_CollisionBits)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val kickedShellPtsData by MemoryByteIndexed(KickedShellPtsData)
    val kickedShellXSpdData by MemoryByteIndexed(KickedShellXSpdData)
    //> PlayerEnemyCollision:
    //> lda FrameCounter            ;check counter for d0 set
    A = frameCounter
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> bcs NoPUp                   ;if set, branch to leave
    X = X
    Y = Y
    if ((orig0 and 0x01) != 0) {
        //> NoPUp: rts
        return X
    } else {
        //> jsr CheckPlayerVertical     ;if player object is completely offscreen or
        val flag1: Boolean = checkPlayerVertical()
        //> bcs NoPECol                 ;if down past 224th pixel row, branch to leave
        if (!flag1) {
            //> lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
            A = enemyOffscrBitsMasked[X]
            //> bne NoPECol                 ;go ahead and branch to leave
            if (A == 0) {
                //> lda GameEngineSubroutine
                A = gameEngineSubroutine
                //> cmp #$08                    ;if not set to run player control routine
                //> bne NoPECol                 ;on next frame, branch to leave
                if (A == 0x08) {
                    //> lda Enemy_State,x
                    A = enemyState[X]
                    //> and #%00100000              ;if enemy state has d5 set, branch to leave
                    A = A and 0x20
                    //> bne NoPECol
                    if (A == 0) {
                        //> jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
                        temp0 = getEnemyBoundBoxOfs()
                        //> jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
                        val flag2: Boolean = playerCollisionCore(Y)
                        //> ldx ObjectOffset            ;get enemy object buffer offset
                        X = objectOffset
                        //> bcs CheckForPUpCollision    ;if collision, branch past this part here
                        A = temp0
                        if (!flag2) {
                            //> lda Enemy_CollisionBits,x
                            A = enemyCollisionbits[X]
                            //> and #%11111110              ;otherwise, clear d0 of current enemy object's
                            A = A and 0xFE
                            //> sta Enemy_CollisionBits,x   ;collision bit
                            enemyCollisionbits[X] = A
                        }
                    }
                }
            }
        }
    }
    //> NoPECol: rts
    return X
    //> CheckForPUpCollision:
    //> ldy Enemy_ID,x
    Y = enemyId[X]
    //> cpy #PowerUpObject            ;check for power-up object
    //> bne EColl                     ;if not found, branch to next part
    if (Y == PowerUpObject) {
        //> jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
        return handlePowerUpCollision(X)
    } else {
        //> EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
        A = starInvincibleTimer
        //> beq HandlePECollisions        ;perform task here, otherwise kill enemy like
        if (A != 0) {
            //> jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
            shellOrBlockDefeat(X)
            return X
        }
    }
    //> HandlePECollisions:
    //> lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
    A = enemyCollisionbits[X]
    //> and #%00000001               ;or for being offscreen at all
    A = A and 0x01
    //> ora EnemyOffscrBitsMasked,x
    A = A or enemyOffscrBitsMasked[X]
    //> bne ExPEC                    ;branch to leave if either is true
    if (A == 0) {
        //> lda #$01
        A = 0x01
        //> ora Enemy_CollisionBits,x    ;otherwise set d0 now
        A = A or enemyCollisionbits[X]
        //> sta Enemy_CollisionBits,x
        enemyCollisionbits[X] = A
        //> cpy #Spiny                   ;branch if spiny
        //> beq ChkForPlayerInjury
        if (Y != Spiny) {
            //> cpy #PiranhaPlant            ;branch if piranha plant
            //> beq InjurePlayer
            if (Y == PiranhaPlant) {
                //  goto InjurePlayer -> injurePlayer
                injurePlayer()
                return X
            }
            //> cpy #Podoboo                 ;branch if podoboo
            //> beq InjurePlayer
            if (Y == Podoboo) {
                //  goto InjurePlayer -> injurePlayer
                injurePlayer()
                return X
            }
            //> cpy #BulletBill_CannonVar    ;branch if bullet bill
            //> beq ChkForPlayerInjury
            if (Y != BulletBill_CannonVar) {
                //> cpy #$15                     ;branch if object => $15
                //> bcs InjurePlayer
                if (Y >= 0x15) {
                    //  goto InjurePlayer -> injurePlayer
                    injurePlayer()
                    return X
                }
                //> lda AreaType                 ;branch if water type level
                A = areaType
                //> beq InjurePlayer
                if (A == 0) {
                    //  goto InjurePlayer -> injurePlayer
                    injurePlayer()
                    return X
                }
                //> lda Enemy_State,x            ;branch if d7 of enemy state was set
                A = enemyState[X]
                //> asl
                val orig3: Int = A
                A = (orig3 shl 1) and 0xFF
                //> bcs ChkForPlayerInjury
                if ((orig3 and 0x80) == 0) {
                    //> lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
                    A = enemyState[X]
                    //> and #%00000111
                    A = A and 0x07
                    //> cmp #$02                     ;branch if enemy is in normal or falling state
                    //> bcc ChkForPlayerInjury
                    if (A >= 0x02) {
                        //> lda Enemy_ID,x               ;branch to leave if goomba in defeated state
                        A = enemyId[X]
                        //> cmp #Goomba
                        //> beq ExPEC
                        if (A != Goomba) {
                            //> lda #Sfx_EnemySmack          ;play smack enemy sound
                            A = Sfx_EnemySmack
                            //> sta Square1SoundQueue
                            square1SoundQueue = A
                            //> lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
                            A = enemyState[X]
                            //> ora #%10000000
                            A = A or 0x80
                            //> sta Enemy_State,x
                            enemyState[X] = A
                            //> jsr EnemyFacePlayer          ;set moving direction and get offset
                            temp1 = enemyFacePlayer(X)
                            //> lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
                            A = kickedShellXSpdData[temp1]
                            //> sta Enemy_X_Speed,x
                            enemyXSpeed[X] = A
                            //> lda #$03                     ;add three to whatever the stomp counter contains
                            A = 0x03
                            //> clc                          ;to give points for kicking the shell
                            //> adc StompChainCounter
                            temp2 = A + stompChainCounter
                            A = temp2 and 0xFF
                            //> ldy EnemyIntervalTimer,x     ;check shell enemy's timer
                            Y = enemyIntervalTimer[X]
                            //> cpy #$03                     ;if above a certain point, branch using the points
                            //> bcs KSPts                    ;data obtained from the stomp counter + 3
                            if (!(Y >= 0x03)) {
                                //> lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
                                A = kickedShellPtsData[Y]
                            }
                            //> KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
                            temp3 = setupFloateyNumber(A, X)
                        }
                    }
                }
            }
        }
    }
    //> ExPEC: rts                          ;leave!!!
    return X
    //> ChkForPlayerInjury:
    //> lda Player_Y_Speed     ;check player's vertical speed
    A = playerYSpeed
    //> bmi ChkInj             ;perform procedure below if player moving upwards
    if ((A and 0x80) == 0) {
        //> bne EnemyStomped       ;or not at all, and branch elsewhere if moving downwards
        if (!(A == 0)) {
            //  goto EnemyStomped -> enemyStomped
            enemyStomped(X)
            return X
        }
    }
    //> ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
    A = enemyId[X]
    //> cmp #Bloober
    //> bcc ChkETmrs
    if (A >= Bloober) {
        //> lda Player_Y_Position  ;add 12 pixels to player's vertical position
        A = playerYPosition
        //> clc
        //> adc #$0c
        temp4 = A + 0x0C
        A = temp4 and 0xFF
        //> cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
        //> bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
        if (!(A >= enemyYPosition[X])) {
            //  goto EnemyStomped -> enemyStomped
            enemyStomped(X)
            return X
        }
    }
    //> ChkETmrs: lda StompTimer         ;check stomp timer
    A = stompTimer
    //> bne EnemyStomped       ;branch if set
    if (!(A == 0)) {
        //  goto EnemyStomped -> enemyStomped
        enemyStomped(X)
        return X
    } else {
        //> lda InjuryTimer        ;check to see if injured invincibility timer still
        A = injuryTimer
        //> bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
        if (!(A == 0)) {
            //  goto ExInjColRoutines -> exInjColRoutines
            exInjColRoutines()
            return X
        }
    }
    //> lda Player_Rel_XPos
    A = playerRelXpos
    //> cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
    //> bcc TInjE              ;relative position, branch here
    if (A >= enemyRelXpos) {
        //> jmp ChkEnemyFaceRight  ;otherwise do a jump here
        chkEnemyFaceRight(X)
        return X
    } else {
        //> TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
        A = enemyMovingdir[X]
        //> cmp #$01               ;branch, otherwise do a jump here
        //> bne InjurePlayer       ;to turn the enemy around
        if (!(A == 0x01)) {
            //  goto InjurePlayer -> injurePlayer
            injurePlayer()
            return X
        }
    }
    //> jmp LInj
    lInj(X)
    return X
}

// Decompiled from InjurePlayer
fun injurePlayer() {
    var A: Int = 0
    var injuryTimer by MemoryByte(InjuryTimer)
    //> InjurePlayer:
    //> lda InjuryTimer          ;check again to see if injured invincibility timer is
    A = injuryTimer
    //> bne ExInjColRoutines     ;at zero, and branch to leave if so
    if (!(A == 0)) {
        //  goto ExInjColRoutines -> exInjColRoutines
        exInjColRoutines()
        return
    } else {
        //  Fall-through tail call to forceInjury
        forceInjury(A)
        return
    }
}

// Decompiled from ForceInjury
fun forceInjury(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var injuryTimer by MemoryByte(InjuryTimer)
    var playerStatus by MemoryByte(PlayerStatus)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    //> ForceInjury:
    //> ldx PlayerStatus          ;check player's status
    X = playerStatus
    //> beq KillPlayer            ;branch if small
    A = A
    if (X != 0) {
        //> sta PlayerStatus          ;otherwise set player's status to small
        playerStatus = A
        //> lda #$08
        A = 0x08
        //> sta InjuryTimer           ;set injured invincibility timer
        injuryTimer = A
        //> asl
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> sta Square1SoundQueue     ;play pipedown/injury sound
        square1SoundQueue = A
        //> jsr GetPlayerColors       ;change player's palette if necessary
        getPlayerColors()
        //> lda #$0a                  ;set subroutine to run on next frame
        A = 0x0A
        //> SetKRout: ldy #$01                  ;set new player state
        Y = 0x01
        //  Fall-through tail call to setPRout
        setPRout(A, Y)
        return
    } else {
        loop0@ do {
            //> SetKRout: ldy #$01                  ;set new player state
            Y = 0x01
            //  Fall-through tail call to setPRout
            setPRout(A, Y)
            return
            //> KillPlayer:
            //> stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
            playerXSpeed = X
            //> inx
            X = (X + 1) and 0xFF
            //> stx EventMusicQueue  ;set event music queue to death music
            eventMusicQueue = X
            //> lda #$fc
            A = 0xFC
            //> sta Player_Y_Speed   ;set new vertical speed
            playerYSpeed = A
            //> lda #$0b             ;set subroutine to run on next frame
            A = 0x0B
            //> bne SetKRout         ;branch to set player's state and other things
            if (!(A == 0)) {
                //  continue loop (branch back to SetKRout)
                continue@loop0
            }
        } while (A != 0)
    }
    //> StompedEnemyPtsData:
    //> .db $02, $06, $05, $06
    //  Fall-through tail call to enemyStomped
    enemyStomped(X)
    return
}

// Decompiled from SetPRout
fun setPRout(A: Int, Y: Int) {
    var Y: Int = Y
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerState by MemoryByte(Player_State)
    var scrollAmount by MemoryByte(ScrollAmount)
    var timerControl by MemoryByte(TimerControl)
    //> SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
    gameEngineSubroutine = A
    //> sty Player_State          ;store new player state
    playerState = Y
    //> ldy #$ff
    Y = 0xFF
    //> sty TimerControl          ;set master timer control flag to halt timers
    timerControl = Y
    //> iny
    Y = (Y + 1) and 0xFF
    //> sty ScrollAmount          ;initialize scroll speed
    scrollAmount = Y
    //  Fall-through tail call to exInjColRoutines
    exInjColRoutines()
    return
}

// Decompiled from ExInjColRoutines
fun exInjColRoutines() {
    var X: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> ExInjColRoutines:
    //> ldx ObjectOffset              ;get enemy offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from EnemyStomped
fun enemyStomped(X: Int) {
    var A: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> EnemyStomped:
    //> lda Enemy_ID,x             ;check for spiny, branch to hurt player
    A = enemyId[X]
    //> cmp #Spiny                 ;if found
    //> beq InjurePlayer
    if (A == Spiny) {
        //  goto InjurePlayer -> injurePlayer
        injurePlayer()
        return
    }
    //  Fall-through tail call to func_11447
    func_11447(X)
    return
}

// Decompiled from @11447
fun func_11447(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
    A = Sfx_EnemyStomp
    //> sta Square1SoundQueue
    square1SoundQueue = A
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> ldy #$00                   ;initialize points data offset for stomped enemies
    Y = 0x00
    //> cmp #FlyingCheepCheep      ;branch for cheep-cheep
    //> beq EnemyStompedPts
    if (A == FlyingCheepCheep) {
        //  goto EnemyStompedPts -> enemyStompedPts
        enemyStompedPts(X, Y)
        return
    }
    //  Fall-through tail call to func_11453
    func_11453(A)
    return
}

// Decompiled from @11453
fun func_11453(A: Int) {
    //> cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
    //> beq EnemyStompedPts
    if (A == BulletBill_FrenzyVar) {
        //  goto EnemyStompedPts -> enemyStompedPts
        enemyStompedPts(0, 0)
        return
    }
    //  Fall-through tail call to func_11455
    func_11455(A)
    return
}

// Decompiled from @11455
fun func_11455(A: Int) {
    //> cmp #BulletBill_CannonVar
    //> beq EnemyStompedPts
    if (A == BulletBill_CannonVar) {
        //  goto EnemyStompedPts -> enemyStompedPts
        enemyStompedPts(0, 0)
        return
    }
    //  Fall-through tail call to func_11457
    func_11457(A)
    return
}

// Decompiled from @11457
fun func_11457(A: Int) {
    //> cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
    //> beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
    if (A == Podoboo) {
        //  goto EnemyStompedPts -> enemyStompedPts
        enemyStompedPts(0, 0)
        return
    }
    //  Fall-through tail call to func_11459
    func_11459(A, 0)
    return
}

// Decompiled from @11459
fun func_11459(A: Int, Y: Int) {
    var Y: Int = Y
    //> iny                        ;increment points data offset
    Y = (Y + 1) and 0xFF
    //> cmp #HammerBro             ;branch for hammer bro
    //> beq EnemyStompedPts
    if (A == HammerBro) {
        //  goto EnemyStompedPts -> enemyStompedPts
        enemyStompedPts(0, Y)
        return
    }
    //  Fall-through tail call to func_11462
    func_11462(A, Y)
    return
}

// Decompiled from @11462
fun func_11462(A: Int, Y: Int) {
    var Y: Int = Y
    //> iny                        ;increment points data offset
    Y = (Y + 1) and 0xFF
    //> cmp #Lakitu                ;branch for lakitu
    //> beq EnemyStompedPts
    if (A == Lakitu) {
        //  goto EnemyStompedPts -> enemyStompedPts
        enemyStompedPts(0, Y)
        return
    }
    //  Fall-through tail call to func_11465
    func_11465(A, Y)
    return
}

// Decompiled from @11465
fun func_11465(A: Int, Y: Int) {
    var Y: Int = Y
    //> iny                        ;increment points data offset
    Y = (Y + 1) and 0xFF
    //> cmp #Bloober               ;branch if NOT bloober
    //> bne ChkForDemoteKoopa
    if (!(A == Bloober)) {
        //  goto ChkForDemoteKoopa -> chkForDemoteKoopa
        chkForDemoteKoopa(A)
        return
    }
    //  Fall-through tail call to func_11468
    func_11468(0, Y)
    return
}

// Decompiled from @11468
fun func_11468(X: Int, Y: Int) {
    //  Fall-through tail call to enemyStompedPts
    enemyStompedPts(X, Y)
    return
}

// Decompiled from EnemyStompedPts
fun enemyStompedPts(X: Int, Y: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val stompedEnemyPtsData by MemoryByteIndexed(StompedEnemyPtsData)
    //> EnemyStompedPts:
    //> lda StompedEnemyPtsData,y  ;load points data using offset in Y
    A = stompedEnemyPtsData[Y]
    //> jsr SetupFloateyNumber     ;run sub to set floatey number controls
    temp0 = setupFloateyNumber(A, X)
    //> lda Enemy_MovingDir,x
    A = enemyMovingdir[X]
    //> pha                        ;save enemy movement direction to stack
    push(A)
    //> jsr SetStun                ;run sub to kill enemy
    setStun(X)
    //> pla
    A = pull()
    //> sta Enemy_MovingDir,x      ;return enemy movement direction from stack
    enemyMovingdir[X] = A
    //> lda #%00100000
    A = 0x20
    //> sta Enemy_State,x          ;set d5 in enemy state
    enemyState[X] = A
    //> jsr InitVStf               ;nullify vertical speed, physics-related thing,
    temp1 = initVStf(X)
    //> sta Enemy_X_Speed,x        ;and horizontal speed
    enemyXSpeed[X] = temp1
    //> lda #$fd                   ;set player's vertical speed, to give bounce
    A = 0xFD
    //> sta Player_Y_Speed
    playerYSpeed = A
    //> rts
    return
}

// Decompiled from ChkForDemoteKoopa
fun chkForDemoteKoopa(A: Int) {
    //> ChkForDemoteKoopa:
    //> cmp #$09                   ;branch elsewhere if enemy object < $09
    //> bcc HandleStompedShellE
    if (!(A >= 0x09)) {
        //  goto HandleStompedShellE -> handleStompedShellE
        handleStompedShellE(0)
        return
    }
    //  Fall-through tail call to func_11488
    func_11488(A, 0)
    return
}

// Decompiled from @11488
fun func_11488(A: Int, X: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val demotedKoopaXSpdData by MemoryByteIndexed(DemotedKoopaXSpdData)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> and #%00000001             ;demote koopa paratroopas to ordinary troopas
    A = A and 0x01
    //> sta Enemy_ID,x
    enemyId[X] = A
    //> ldy #$00                   ;return enemy to normal state
    Y = 0x00
    //> sty Enemy_State,x
    enemyState[X] = Y
    //> lda #$03                   ;award 400 points to the player
    A = 0x03
    //> jsr SetupFloateyNumber
    temp0 = setupFloateyNumber(A, X)
    //> jsr InitVStf               ;nullify physics-related thing and vertical speed
    temp1 = initVStf(X)
    //> jsr EnemyFacePlayer        ;turn enemy around if necessary
    temp2 = enemyFacePlayer(X)
    //> lda DemotedKoopaXSpdData,y
    A = demotedKoopaXSpdData[temp2]
    //> sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
    enemyXSpeed[X] = A
    //> jmp SBnce                  ;then move onto something else
    sBnce()
    return
}

// Decompiled from HandleStompedShellE
fun handleStompedShellE(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var stompChainCounter by MemoryByte(StompChainCounter)
    var stompTimer by MemoryByte(StompTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val revivalRateData by MemoryByteIndexed(RevivalRateData)
    //> HandleStompedShellE:
    //> lda #$04                   ;set defeated state for enemy
    A = 0x04
    //> sta Enemy_State,x
    enemyState[X] = A
    //> inc StompChainCounter      ;increment the stomp counter
    stompChainCounter = (stompChainCounter + 1) and 0xFF
    //> lda StompChainCounter      ;add whatever is in the stomp counter
    A = stompChainCounter
    //> clc                        ;to whatever is in the stomp timer
    //> adc StompTimer
    temp0 = A + stompTimer
    A = temp0 and 0xFF
    //> jsr SetupFloateyNumber     ;award points accordingly
    temp1 = setupFloateyNumber(A, X)
    //> inc StompTimer             ;increment stomp timer of some sort
    stompTimer = (stompTimer + 1) and 0xFF
    //> ldy PrimaryHardMode        ;check primary hard mode flag
    Y = primaryHardMode
    //> lda RevivalRateData,y      ;load timer setting according to flag
    A = revivalRateData[Y]
    //> sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
    enemyIntervalTimer[X] = A
    //  Fall-through tail call to sBnce
    sBnce()
    return
}

// Decompiled from SBnce
fun sBnce() {
    var A: Int = 0
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    //> SBnce: lda #$fc                   ;set player's vertical speed for bounce
    A = 0xFC
    //> sta Player_Y_Speed         ;and then leave!!!
    playerYSpeed = A
    //> rts
    return
}

// Decompiled from ChkEnemyFaceRight
fun chkEnemyFaceRight(X: Int) {
    var A: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> ChkEnemyFaceRight:
    //> lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
    A = enemyMovingdir[X]
    //> cmp #$01
    //> bne LInj              ;if not, branch
    if (!(A == 0x01)) {
        //  goto LInj -> lInj
        lInj(X)
        return
    } else {
        //> jmp InjurePlayer      ;otherwise go back to hurt player
        injurePlayer()
        return
    }
}

// Decompiled from LInj
fun lInj(X: Int) {
    //> LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
    enemyTurnAround(X)
    //> jmp InjurePlayer      ;go back to hurt player
    injurePlayer()
    return
}

// Decompiled from EnemyFacePlayer
fun enemyFacePlayer(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> EnemyFacePlayer:
    //> ldy #$01               ;set to move right by default
    Y = 0x01
    //> jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
    val flag0: Boolean = playerEnemyDiff(X)
    //> bpl SFcRt              ;if enemy is to the right of player, do not increment
    X = X
    if ((Y and 0x80) != 0) {
        //> iny                    ;otherwise, increment to set to move to the left
        Y = (Y + 1) and 0xFF
    }
    //> SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
    enemyMovingdir[X] = Y
    //> dey                    ;then decrement to use as a proper offset
    Y = (Y - 1) and 0xFF
    //> rts
    return Y
}

// Decompiled from SetupFloateyNumber
fun setupFloateyNumber(A: Int, X: Int): Int {
    var A: Int = A
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val floateynumTimer by MemoryByteIndexed(FloateyNum_Timer)
    val floateynumXPos by MemoryByteIndexed(FloateyNum_X_Pos)
    val floateynumYPos by MemoryByteIndexed(FloateyNum_Y_Pos)
    //> SetupFloateyNumber:
    //> sta FloateyNum_Control,x ;set number of points control for floatey numbers
    floateynumControl[X] = A
    //> lda #$30
    A = 0x30
    //> sta FloateyNum_Timer,x   ;set timer for floatey numbers
    floateynumTimer[X] = A
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> sta FloateyNum_Y_Pos,x   ;set vertical coordinate
    floateynumYPos[X] = A
    //> lda Enemy_Rel_XPos
    A = enemyRelXpos
    //> sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
    floateynumXPos[X] = A
    //  Fall-through tail call to exSFN
    exSFN()
    return A
}

// Decompiled from ExSFN
fun exSFN() {
    //> ExSFN: rts
    return
}

// Decompiled from EnemiesCollision
fun enemiesCollision(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    val clearBitsMask by MemoryByteIndexed(ClearBitsMask)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyCollisionbits by MemoryByteIndexed(Enemy_CollisionBits)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val setBitsMask by MemoryByteIndexed(SetBitsMask)
    //> EnemiesCollision:
    //> lda FrameCounter            ;check counter for d0 set
    A = frameCounter
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> bcc ExSFN                   ;if d0 not set, leave
    X = X
    Y = Y
    if ((orig0 and 0x01) == 0) {
        //> ExSFN: rts
        return X
    } else {
        //> lda AreaType
        A = areaType
        //> beq ExSFN                   ;if water area type, leave
        if (A == 0) {
            //> ExSFN: rts
            return X
        }
    }
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #$15                    ;if enemy object => $15, branch to leave
    //> bcs ExitECRoutine
    if (!(A >= 0x15)) {
        //> cmp #Lakitu                 ;if lakitu, branch to leave
        //> beq ExitECRoutine
        if (A != Lakitu) {
            //> cmp #PiranhaPlant           ;if piranha plant, branch to leave
            //> beq ExitECRoutine
            if (A != PiranhaPlant) {
                //> lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
                A = enemyOffscrBitsMasked[X]
                //> bne ExitECRoutine
                if (A == 0) {
                    //> jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
                    temp0 = getEnemyBoundBoxOfs()
                    //> dex                         ;first enemy we're going to compare, then decrement for second
                    X = (X - 1) and 0xFF
                    //> bmi ExitECRoutine           ;branch to leave if there are no other enemies
                    A = temp0
                    if ((X and 0x80) == 0) {
                        loop0@ do {
                            //> ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
                            memory[0x1] = X.toUByte()
                            //> tya                         ;save first enemy's bounding box offset to stack
                            A = Y
                            //> pha
                            push(A)
                            //> lda Enemy_Flag,x            ;check enemy object enable flag
                            A = enemyFlag[X]
                            //> beq ReadyNextEnemy          ;branch if flag not set
                            if (A != 0) {
                                //> lda Enemy_ID,x
                                A = enemyId[X]
                                //> cmp #$15                    ;check for enemy object => $15
                                //> bcs ReadyNextEnemy          ;branch if true
                                if (!(A >= 0x15)) {
                                    //> cmp #Lakitu
                                    //> beq ReadyNextEnemy          ;branch if enemy object is lakitu
                                    if (A != Lakitu) {
                                        //> cmp #PiranhaPlant
                                        //> beq ReadyNextEnemy          ;branch if enemy object is piranha plant
                                        if (A != PiranhaPlant) {
                                            //> lda EnemyOffscrBitsMasked,x
                                            A = enemyOffscrBitsMasked[X]
                                            //> bne ReadyNextEnemy          ;branch if masked offscreen bits set
                                            if (A == 0) {
                                                //> txa                         ;get second enemy object's bounding box offset
                                                A = X
                                                //> asl                         ;multiply by four, then add four
                                                val orig1: Int = A
                                                A = (orig1 shl 1) and 0xFF
                                                //> asl
                                                val orig2: Int = A
                                                A = (orig2 shl 1) and 0xFF
                                                //> clc
                                                //> adc #$04
                                                temp1 = A + 0x04
                                                A = temp1 and 0xFF
                                                //> tax                         ;use as new contents of X
                                                X = A
                                                //> jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
                                                val flag3: Boolean = sprObjectCollisionCore(X, Y)
                                                //> ldx ObjectOffset            ;use first enemy offset for X
                                                X = objectOffset
                                                //> ldy $01                     ;use second enemy offset for Y
                                                Y = memory[0x1].toInt()
                                                //> bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
                                                if (flag3) {
                                                    //> lda Enemy_State,x
                                                    A = enemyState[X]
                                                    //> ora Enemy_State,y           ;check both enemy states for d7 set
                                                    A = A or enemyState[Y]
                                                    //> and #%10000000
                                                    A = A and 0x80
                                                    //> bne YesEC                   ;branch if at least one of them is set
                                                    if (A == 0) {
                                                        //> lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
                                                        A = enemyCollisionbits[Y]
                                                        //> and SetBitsMask,x           ;check to see if bit connected to second enemy is
                                                        A = A and setBitsMask[X]
                                                        //> bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
                                                        if (A == 0) {
                                                            //> lda Enemy_CollisionBits,y
                                                            A = enemyCollisionbits[Y]
                                                            //> ora SetBitsMask,x           ;if the bit is not set, set it now
                                                            A = A or setBitsMask[X]
                                                            //> sta Enemy_CollisionBits,y
                                                            enemyCollisionbits[Y] = A
                                                        }
                                                    }
                                                    //> YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
                                                    procEnemyCollisions(X, Y)
                                                    //> jmp ReadyNextEnemy          ;move onto next enemy slot
                                                    //> jmp ReadyNextEnemy (not a known function)
                                                } else {
                                                    //> NoEnemyCollision:
                                                    //> lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
                                                    A = enemyCollisionbits[Y]
                                                    //> and ClearBitsMask,x           ;clear bit connected to second enemy
                                                    A = A and clearBitsMask[X]
                                                    //> sta Enemy_CollisionBits,y     ;then move onto next enemy slot
                                                    enemyCollisionbits[Y] = A
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            //> ReadyNextEnemy:
                            //> pla              ;get first enemy's bounding box offset from the stack
                            A = pull()
                            //> tay              ;use as Y again
                            Y = A
                            //> ldx $01          ;get and decrement second enemy's object buffer offset
                            X = memory[0x1].toInt()
                            //> dex
                            X = (X - 1) and 0xFF
                            //> bpl ECLoop       ;loop until all enemy slots have been checked
                            if (!((X and 0x80) != 0)) {
                                //  continue loop (branch back to ECLoop)
                                continue@loop0
                            }
                        } while ((X and 0x80) == 0)
                    }
                }
            }
        }
    }
    //> ExitECRoutine:
    //> ldx ObjectOffset ;get enemy object buffer offset
    X = objectOffset
    //> rts              ;leave
    return X
}

// Decompiled from ProcEnemyCollisions
fun procEnemyCollisions(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val shellChainCounter by MemoryByteIndexed(ShellChainCounter)
    //> ProcEnemyCollisions:
    //> lda Enemy_State,y        ;check both enemy states for d5 set
    A = enemyState[Y]
    //> ora Enemy_State,x
    A = A or enemyState[X]
    //> and #%00100000           ;if d5 is set in either state, or both, branch
    A = A and 0x20
    //> bne ExitProcessEColl     ;to leave and do nothing else at this point
    X = X
    Y = Y
    if (A == 0) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> cmp #$06                 ;if second enemy state < $06, branch elsewhere
        //> bcc ProcSecondEnemyColl
        if (A >= 0x06) {
            //> lda Enemy_ID,x           ;check second enemy identifier for hammer bro
            A = enemyId[X]
            //> cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
            //> beq ExitProcessEColl
            if (A != HammerBro) {
                //> lda Enemy_State,y        ;check first enemy state for d7 set
                A = enemyState[Y]
                //> asl
                val orig0: Int = A
                A = (orig0 shl 1) and 0xFF
                //> bcc ShellCollisions      ;branch if d7 is clear
                if ((orig0 and 0x80) != 0) {
                    //> lda #$06
                    A = 0x06
                    //> jsr SetupFloateyNumber   ;award 1000 points for killing enemy
                    temp0 = setupFloateyNumber(A, X)
                    //> jsr ShellOrBlockDefeat   ;then kill enemy, then load
                    shellOrBlockDefeat(X)
                    //> ldy $01                  ;original offset of second enemy
                    Y = memory[0x1].toInt()
                }
                //> ShellCollisions:
                //> tya                      ;move Y to X
                A = Y
                //> tax
                X = A
                //> jsr ShellOrBlockDefeat   ;kill second enemy
                shellOrBlockDefeat(X)
                //> ldx ObjectOffset
                X = objectOffset
                //> lda ShellChainCounter,x  ;get chain counter for shell
                A = shellChainCounter[X]
                //> clc
                //> adc #$04                 ;add four to get appropriate point offset
                temp1 = A + 0x04
                A = temp1 and 0xFF
                //> ldx $01
                X = memory[0x1].toInt()
                //> jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
                temp2 = setupFloateyNumber(A, X)
                //> ldx ObjectOffset         ;load original offset of first enemy
                X = objectOffset
                //> inc ShellChainCounter,x  ;increment chain counter for additional enemies
                shellChainCounter[X] = (shellChainCounter[X] + 1) and 0xFF
            }
        }
    }
    //> ExitProcessEColl:
    //> rts                      ;leave!!!
    return
    //> ProcSecondEnemyColl:
    //> lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
    A = enemyState[Y]
    //> cmp #$06
    //> bcc MoveEOfs
    if (A >= 0x06) {
        //> lda Enemy_ID,y           ;check first enemy identifier for hammer bro
        A = enemyId[Y]
        //> cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
        //> beq ExitProcessEColl
        if (A == HammerBro) {
        }
        //> jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
        shellOrBlockDefeat(X)
        //> ldy $01
        Y = memory[0x1].toInt()
        //> lda ShellChainCounter,y  ;get chain counter for shell
        A = shellChainCounter[Y]
        //> clc
        //> adc #$04                 ;add four to get appropriate point offset
        temp3 = A + 0x04
        A = temp3 and 0xFF
        //> ldx ObjectOffset
        X = objectOffset
        //> jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
        temp4 = setupFloateyNumber(A, X)
        //> ldx $01                  ;load original offset of second enemy
        X = memory[0x1].toInt()
        //> inc ShellChainCounter,x  ;increment chain counter for additional enemies
        shellChainCounter[X] = (shellChainCounter[X] + 1) and 0xFF
        //> rts                      ;leave!!!
        return
    } else {
        //> MoveEOfs:
        //> tya                      ;move Y ($01) to X
        A = Y
        //> tax
        X = A
        //> jsr EnemyTurnAround      ;do the sub here using value from $01
        enemyTurnAround(X)
        //> ldx ObjectOffset         ;then do it again using value from $08
        X = objectOffset
        //  Fall-through tail call to enemyTurnAround
        enemyTurnAround(X)
        return
    }
}

// Decompiled from EnemyTurnAround
fun enemyTurnAround(X: Int) {
    var A: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> EnemyTurnAround:
    //> lda Enemy_ID,x           ;check for specific enemies
    A = enemyId[X]
    //> cmp #PiranhaPlant
    //> beq ExTA                 ;if piranha plant, leave
    if (A == PiranhaPlant) {
        //  goto ExTA -> exTA
        exTA()
        return
    } else {
        //> cmp #Lakitu
        //> beq ExTA                 ;if lakitu, leave
        if (A == Lakitu) {
            //  goto ExTA -> exTA
            exTA()
            return
        }
    }
    //> cmp #HammerBro
    //> beq ExTA                 ;if hammer bro, leave
    if (A == HammerBro) {
        //  goto ExTA -> exTA
        exTA()
        return
    } else {
        //> cmp #Spiny
        //> beq RXSpd                ;if spiny, turn it around
        if (A == Spiny) {
            //  goto RXSpd -> rXSpd
            rXSpd(X)
            return
        }
    }
    //> cmp #GreenParatroopaJump
    //> beq RXSpd                ;if green paratroopa, turn it around
    if (A == GreenParatroopaJump) {
        //  goto RXSpd -> rXSpd
        rXSpd(X)
        return
    } else {
        //> cmp #$07
        //> bcs ExTA                 ;if any OTHER enemy object => $07, leave
        if (A >= 0x07) {
            //  goto ExTA -> exTA
            exTA()
            return
        }
        //  Fall-through tail call to rXSpd
        rXSpd(X)
        return
    }
}

// Decompiled from RXSpd
fun rXSpd(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
    A = enemyXSpeed[X]
    //> eor #$ff                 ;get two's compliment for horizontal speed
    A = A xor 0xFF
    //> tay
    Y = A
    //> iny
    Y = (Y + 1) and 0xFF
    //> sty Enemy_X_Speed,x      ;store as new horizontal speed
    enemyXSpeed[X] = Y
    //> lda Enemy_MovingDir,x
    A = enemyMovingdir[X]
    //> eor #%00000011           ;invert moving direction and store, then leave
    A = A xor 0x03
    //> sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
    enemyMovingdir[X] = A
    //  Fall-through tail call to exTA
    exTA()
    return
}

// Decompiled from ExTA
fun exTA() {
    //> ExTA:  rts                      ;leave!!!
    return
}

// Decompiled from LargePlatformCollision
fun largePlatformCollision(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var timerControl by MemoryByte(TimerControl)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> LargePlatformCollision:
    //> lda #$ff                     ;save value here
    A = 0xFF
    //> sta PlatformCollisionFlag,x
    platformCollisionFlag[X] = A
    //> lda TimerControl             ;check master timer control
    A = timerControl
    //> bne ExLPC                    ;if set, branch to leave
    if (!(A == 0)) {
        //  goto ExLPC -> exLPC
        exLPC()
        return X
    } else {
        //> lda Enemy_State,x            ;if d7 set in object state,
        A = enemyState[X]
        //> bmi ExLPC                    ;branch to leave
        if ((A and 0x80) != 0) {
            //  goto ExLPC -> exLPC
            exLPC()
            return X
        }
    }
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #$24                     ;check enemy object identifier for
    //> bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
    if (!(A == 0x24)) {
        //  goto ChkForPlayerC_LargeP -> chkforplayercLargep
        chkforplayercLargep(X, Y)
        return X
    } else {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> tax                          ;set state as enemy offset here
        X = A
        //> jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
        val flag0: Boolean = chkforplayercLargep(X, Y)
        //  Fall-through tail call to chkforplayercLargep
        chkforplayercLargep(X, Y)
        return X
    }
}

// Decompiled from ChkForPlayerC_LargeP
fun chkforplayercLargep(X: Int, Y: Int): Boolean {
    var A: Int = 0
    var X: Int = X
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ChkForPlayerC_LargeP:
    //> jsr CheckPlayerVertical      ;figure out if player is below a certain point
    val flag0: Boolean = checkPlayerVertical()
    //> bcs ExLPC                    ;or offscreen, branch to leave if true
    if (flag0) {
        //  goto ExLPC -> exLPC
        exLPC()
        return false
    } else {
        //> txa
        A = X
        //> jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
        val flag1: Boolean = getEnemyBoundBoxOfsArg(A)
        //> lda Enemy_Y_Position,x       ;store vertical coordinate in
        A = enemyYPosition[X]
        //> sta $00                      ;temp variable for now
        memory[0x0] = A.toUByte()
        //> txa                          ;send offset we're on to the stack
        A = X
        //> pha
        push(A)
        //> jsr PlayerCollisionCore      ;do player-to-platform collision detection
        val flag2: Boolean = playerCollisionCore(Y)
        //> pla                          ;retrieve offset from the stack
        A = pull()
        //> tax
        X = A
        //> bcc ExLPC                    ;if no collision, branch to leave
        if (!(flag2)) {
            //  goto ExLPC -> exLPC
            exLPC()
            return false
        }
    }
    //> jsr ProcLPlatCollisions      ;otherwise collision, perform sub
    procLPlatCollisions(X, Y)
    //  Fall-through tail call to exLPC
    exLPC()
    return false
}

// Decompiled from ExLPC
fun exLPC() {
    var X: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
    X = objectOffset
    //> rts
    return
}

// Decompiled from SmallPlatformCollision
fun smallPlatformCollision(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val boundingboxDrYpos by MemoryByteIndexed(BoundingBox_DR_YPos)
    val boundingboxUlYpos by MemoryByteIndexed(BoundingBox_UL_YPos)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> SmallPlatformCollision:
    //> lda TimerControl             ;if master timer control set,
    A = timerControl
    //> bne ExSPC                    ;branch to leave
    X = X
    Y = Y
    if (A == 0) {
        //> sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
        platformCollisionFlag[X] = A
        //> jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
        val flag0: Boolean = checkPlayerVertical()
        //> bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
        if (!flag0) {
            //> lda #$02
            A = 0x02
            //> sta $00                      ;load counter here for 2 bounding boxes
            memory[0x0] = A.toUByte()
            loop0@ while (A == 0) {
                //> lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
                A = boundingboxUlYpos[Y]
                //> cmp #$20                   ;above a specific point
                //> bcc MoveBoundBox           ;if so, branch, don't do collision detection
                if (A >= 0x20) {
                    //> jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
                    val flag1: Boolean = playerCollisionCore(Y)
                    //> bcs ProcSPlatCollisions    ;skip ahead if collision
                    if (!flag1) {
                    } else {
                        break@loop0
                    }
                }
                //> MoveBoundBox:
                //> lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
                A = boundingboxUlYpos[Y]
                //> clc                        ;128 pixels downwards
                //> adc #$80
                temp0 = A + 0x80
                A = temp0 and 0xFF
                //> sta BoundingBox_UL_YPos,y
                boundingboxUlYpos[Y] = A
                //> lda BoundingBox_DR_YPos,y
                A = boundingboxDrYpos[Y]
                //> clc
                //> adc #$80
                temp1 = A + 0x80
                A = temp1 and 0xFF
                //> sta BoundingBox_DR_YPos,y
                boundingboxDrYpos[Y] = A
                //> dec $00                    ;decrement counter we set earlier
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
                if (!(memory[0x0].toInt() == 0)) {
                    //  continue loop (branch back to ChkSmallPlatLoop)
                    continue@loop0
                }
            }
        }
    }
    //> ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
    X = objectOffset
    //> rts
    return X
    //> ProcSPlatCollisions:
    //> ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
    X = objectOffset
    //  Fall-through tail call to procLPlatCollisions
    procLPlatCollisions(X, Y)
    return X
}

// Decompiled from ProcLPlatCollisions
fun procLPlatCollisions(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var playerState by MemoryByte(Player_State)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxDrYpos by MemoryByteIndexed(BoundingBox_DR_YPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val boundingboxUlYpos by MemoryByteIndexed(BoundingBox_UL_YPos)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> ProcLPlatCollisions:
    //> lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
    A = boundingboxDrYpos[Y]
    //> sec                          ;of the player's bounding box from the bottom
    //> sbc BoundingBox_UL_YPos      ;of the platform's bounding box
    temp0 = A - boundingboxUlYpos[0]
    A = temp0 and 0xFF
    //> cmp #$04                     ;if difference too large or negative,
    //> bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
    X = X
    Y = Y
    if (!(A >= 0x04)) {
        //> lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
        A = playerYSpeed
        //> bpl ChkForTopCollision       ;if so, don't mess with it
        if ((A and 0x80) != 0) {
            //> lda #$01                     ;otherwise, set vertical
            A = 0x01
            //> sta Player_Y_Speed           ;speed of player to kill jump
            playerYSpeed = A
        }
    }
    //> ChkForTopCollision:
    //> lda BoundingBox_DR_YPos      ;get difference by subtracting the top
    A = boundingboxDrYpos[0]
    //> sec                          ;of the platform's bounding box from the bottom
    //> sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
    temp1 = A - boundingboxUlYpos[Y]
    A = temp1 and 0xFF
    //> cmp #$06
    //> bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
    if (!(A >= 0x06)) {
        //> lda Player_Y_Speed
        A = playerYSpeed
        //> bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
        if ((A and 0x80) == 0) {
            //> lda $00                      ;get saved bounding box counter from earlier
            A = memory[0x0].toInt()
            //> ldy Enemy_ID,x
            Y = enemyId[X]
            //> cpy #$2b                     ;if either of the two small platform objects are found,
            //> beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
            if (Y != 0x2B) {
                //> cpy #$2c                     ;as contents of collision flag
                //> beq SetCollisionFlag
                if (Y != 0x2C) {
                    //> txa                          ;otherwise use enemy object buffer offset
                    A = X
                }
            }
            //> SetCollisionFlag:
            //> ldx ObjectOffset             ;get enemy object buffer offset
            X = objectOffset
            //> sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
            platformCollisionFlag[X] = A
            //> lda #$00
            A = 0x00
            //> sta Player_State             ;set player state to normal then leave
            playerState = A
            //> rts
            return
        }
    }
    //> PlatformSideCollisions:
    //> lda #$01                   ;set value here to indicate possible horizontal
    A = 0x01
    //> sta $00                    ;collision on left side of platform
    memory[0x0] = A.toUByte()
    //> lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
    A = boundingboxDrXpos[0]
    //> sec                        ;from player's right edge
    //> sbc BoundingBox_UL_XPos,y
    temp2 = A - boundingboxUlXpos[Y]
    A = temp2 and 0xFF
    //> cmp #$08                   ;if difference close enough, skip all of this
    //> bcc SideC
    if (A >= 0x08) {
        //> inc $00                    ;otherwise increment value set here for right side collision
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
        A = boundingboxDrXpos[Y]
        //> clc                        ;from platform's right edge
        //> sbc BoundingBox_UL_XPos
        temp3 = A - boundingboxUlXpos[0] - 1
        A = temp3 and 0xFF
        //> cmp #$09                   ;if difference not close enough, skip subroutine
        //> bcs NoSideC                ;and instead branch to leave (no collision)
        if (A >= 0x09) {
            //  goto NoSideC (internal forward branch)
            //> NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
            X = objectOffset
            //> rts
            return
        }
    }
    //> SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
    impedePlayerMove()
    //> NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
    X = objectOffset
    //> rts
    return
}

// Decompiled from PositionPlayerOnS_Plat
fun positionplayeronsPlat(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val playerPosSPlatData by MemoryByteIndexed(PlayerPosSPlatData)
    //> PositionPlayerOnS_Plat:
    //> tay                        ;use bounding box counter saved in collision flag
    Y = A
    //> lda Enemy_Y_Position,x     ;for offset
    A = enemyYPosition[X]
    //> clc                        ;add positioning data using offset to the vertical
    //> adc PlayerPosSPlatData-1,y ;coordinate
    temp0 = A + playerPosSPlatData[-1 + Y]
    A = temp0 and 0xFF
    //> .db $2c                    ;BIT instruction opcode
    //> PositionPlayerOnVPlat:
    //> lda Enemy_Y_Position,x    ;get vertical coordinate
    //  (skipped by BIT $2C)
    //> ldy GameEngineSubroutine
    Y = gameEngineSubroutine
    //> cpy #$0b                  ;if certain routine being executed on this frame,
    //> beq ExPlPos               ;skip all of this
    X = X
    if (Y != 0x0B) {
        //> ldy Enemy_Y_HighPos,x
        Y = enemyYHighpos[X]
        //> cpy #$01                  ;if vertical high byte offscreen, skip this
        //> bne ExPlPos
        if (Y == 0x01) {
            //> sec                       ;subtract 32 pixels from vertical coordinate
            //> sbc #$20                  ;for the player object's height
            temp1 = A - 0x20
            A = temp1 and 0xFF
            //> sta Player_Y_Position     ;save as player's new vertical coordinate
            playerYPosition = A
            //> tya
            A = Y
            //> sbc #$00                  ;subtract borrow and store as player's
            temp2 = A - if (temp1 >= 0) 0 else 1
            A = temp2 and 0xFF
            //> sta Player_Y_HighPos      ;new vertical high byte
            playerYHighpos = A
            //> lda #$00
            A = 0x00
            //> sta Player_Y_Speed        ;initialize vertical speed and low byte of force
            playerYSpeed = A
            //> sta Player_Y_MoveForce    ;and then leave
            playerYMoveforce = A
        }
    }
    //> ExPlPos: rts
    return
}

// Decompiled from PositionPlayerOnVPlat
fun positionPlayerOnVPlat() {
    // Fall-through tail call to positionplayeronsPlat
    positionplayeronsPlat(0, 0)
    return
}

// Decompiled from CheckPlayerVertical
fun checkPlayerVertical(): Boolean {
    var A: Int = 0
    var Y: Int = 0
    var playerOffscreenbits by MemoryByte(Player_OffscreenBits)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    //> CheckPlayerVertical:
    //> lda Player_OffscreenBits  ;if player object is completely offscreen
    A = playerOffscreenbits
    //> cmp #$f0                  ;vertically, leave this routine
    //> bcs ExCPV
    if (!(A >= 0xF0)) {
        //> ldy Player_Y_HighPos      ;if player high vertical byte is not
        Y = playerYHighpos
        //> dey                       ;within the screen, leave this routine
        Y = (Y - 1) and 0xFF
        //> bne ExCPV
        if (Y == 0) {
            //> lda Player_Y_Position     ;if on the screen, check to see how far down
            A = playerYPosition
            //> cmp #$d0                  ;the player is vertically
        }
    }
    //> ExCPV: rts
    return false
}

// Decompiled from GetEnemyBoundBoxOfs
fun getEnemyBoundBoxOfs(): Int {
    var A: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> GetEnemyBoundBoxOfs:
    //> lda ObjectOffset         ;get enemy object buffer offset
    A = objectOffset
    //  Fall-through tail call to getEnemyBoundBoxOfsArg
    getEnemyBoundBoxOfsArg(A)
    return A
}

// Decompiled from GetEnemyBoundBoxOfsArg
fun getEnemyBoundBoxOfsArg(A: Int): Boolean {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    //> GetEnemyBoundBoxOfsArg:
    //> asl                      ;multiply A by four, then add four
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                      ;to skip player's bounding box
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> clc
    //> adc #$04
    temp0 = A + 0x04
    //> tay                      ;send to Y
    Y = temp0 and 0xFF
    //> lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
    A = enemyOffscreenbits
    //> and #%00001111           ;save low nybble
    A = A and 0x0F
    //> cmp #%00001111           ;check for all bits set
    //> rts
    return A >= 0x0F
}

// Decompiled from PlayerBGCollision
fun playerBGCollision(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp16: Int = 0
    var temp17: Int = 0
    var temp18: Int = 0
    var temp19: Int = 0
    var temp2: Int = 0
    var temp20: Int = 0
    var temp21: Int = 0
    var temp22: Int = 0
    var temp23: Int = 0
    var temp24: Int = 0
    var temp25: Int = 0
    var temp26: Int = 0
    var temp27: Int = 0
    var temp28: Int = 0
    var temp29: Int = 0
    var temp3: Int = 0
    var temp30: Int = 0
    var temp31: Int = 0
    var temp32: Int = 0
    var temp33: Int = 0
    var temp34: Int = 0
    var temp35: Int = 0
    var temp36: Int = 0
    var temp37: Int = 0
    var temp38: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaType by MemoryByte(AreaType)
    var blockBounceTimer by MemoryByte(BlockBounceTimer)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var disableCollisionDet by MemoryByte(DisableCollisionDet)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerSize by MemoryByte(PlayerSize)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerState by MemoryByte(Player_State)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    val blockBufferAdderData by MemoryByteIndexed(BlockBufferAdderData)
    val playerBGUpperExtent by MemoryByteIndexed(PlayerBGUpperExtent)
    //> PlayerBGCollision:
    //> lda DisableCollisionDet   ;if collision detection disabled flag set,
    A = disableCollisionDet
    //> bne ExPBGCol              ;branch to leave
    if (A == 0) {
        //> lda GameEngineSubroutine
        A = gameEngineSubroutine
        //> cmp #$0b                  ;if running routine #11 or $0b
        //> beq ExPBGCol              ;branch to leave
        if (A != 0x0B) {
            //> cmp #$04
            //> bcc ExPBGCol              ;if running routines $00-$03 branch to leave
            if (A >= 0x04) {
                //> lda #$01                  ;load default player state for swimming
                A = 0x01
                //> ldy SwimmingFlag          ;if swimming flag set,
                Y = swimmingFlag
                //> bne SetPSte               ;branch ahead to set default state
                if (Y == 0) {
                    //> lda Player_State          ;if player in normal state,
                    A = playerState
                    //> beq SetFallS              ;branch to set default state for falling
                    if (A != 0) {
                        //> cmp #$03
                        //> bne ChkOnScr              ;if in any other state besides climbing, skip to next part
                        if (!(A == 0x03)) {
                            //  goto ChkOnScr (internal forward branch)
                            //> ChkOnScr: lda Player_Y_HighPos
                            A = playerYHighpos
                            //> cmp #$01                  ;check player's vertical high byte for still on the screen
                            //> bne ExPBGCol              ;branch to leave if not
                            if (!(A == 0x01)) {
                                //  goto ExPBGCol (internal forward branch)
                                //> ExPBGCol: rts                       ;otherwise leave
                                return X
                            }
                            //> lda #$ff
                            A = 0xFF
                            //> sta Player_CollisionBits  ;initialize player's collision flag
                            playerCollisionbits = A
                            //> lda Player_Y_Position
                            A = playerYPosition
                            //> cmp #$cf                  ;check player's vertical coordinate
                            //> bcc ChkCollSize           ;if not too close to the bottom of screen, continue
                            if (!(A >= 0xCF)) {
                                //  goto ChkCollSize (internal forward branch)
                                //> ChkCollSize:
                                //> ldy #$02                    ;load default offset
                                Y = 0x02
                                //> lda CrouchingFlag
                                A = crouchingFlag
                                //> bne GBBAdr                  ;if player crouching, skip ahead
                                if (!(A == 0)) {
                                    //  goto GBBAdr (internal forward branch)
                                    //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                                    A = blockBufferAdderData[Y]
                                    //> sta $eb                     ;store value here
                                    memory[0xEB] = A.toUByte()
                                    //> tay                         ;put value into Y, as offset for block buffer routine
                                    Y = A
                                    //> ldx PlayerSize              ;get player's size as offset
                                    X = playerSize
                                    //> lda CrouchingFlag
                                    A = crouchingFlag
                                    //> beq HeadChk                 ;if player not crouching, branch ahead
                                    if (A == 0) {
                                        //  goto HeadChk (internal forward branch)
                                        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                                        A = playerYPosition
                                        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                                        //> bcc DoFootCheck             ;if player is too high, skip this part
                                        if (!(A >= playerBGUpperExtent[X])) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                                        temp0 = blockbuffercolliHead(Y)
                                        //> beq DoFootCheck             ;player, and branch if nothing above player's head
                                        if (temp0 == 0) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                                        temp1 = checkForCoinMTiles(temp0)
                                        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                                        if (flagC) {
                                            //  goto AwardTouchedCoin -> awardTouchedCoin
                                            awardTouchedCoin()
                                            return X
                                        }
                                        //> ldy Player_Y_Speed          ;check player's vertical speed
                                        Y = playerYSpeed
                                        //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                                        if (!((Y and 0x80) != 0)) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> ldy $04                     ;check lower nybble of vertical coordinate returned
                                        Y = memory[0x4].toInt()
                                        //> cpy #$04                    ;from collision detection routine
                                        //> bcc DoFootCheck             ;if low nybble < 4, branch
                                        if (!(Y >= 0x04)) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                                        val flag0: Boolean = checkForSolidMTiles(temp1, X)
                                        //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                                        if (flag0) {
                                            //  goto SolidOrClimb (internal forward branch)
                                            //> SolidOrClimb:
                                            //> cmp #$26               ;if climbing metatile,
                                            //> beq NYSpd              ;branch ahead and do not play sound
                                            if (temp1 == 0x26) {
                                                //  goto NYSpd (internal forward branch)
                                                //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                                A = 0x01
                                                //> sta Player_Y_Speed     ;jump or swim
                                                playerYSpeed = A
                                                //  Fall-through tail call to doFootCheck
                                                return doFootCheck(X)
                                            }
                                            //> lda #Sfx_Bump
                                            A = Sfx_Bump
                                            //> sta Square1SoundQueue  ;otherwise load bump sound
                                            square1SoundQueue = A
                                            return X
                                        }
                                        //> ldy AreaType                ;otherwise check area type
                                        Y = areaType
                                        //> beq NYSpd                   ;if water level, branch ahead
                                        if (Y == 0) {
                                            //  goto NYSpd (internal forward branch)
                                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                            A = 0x01
                                            //> sta Player_Y_Speed     ;jump or swim
                                            playerYSpeed = A
                                            //  Fall-through tail call to doFootCheck
                                            return doFootCheck(X)
                                        }
                                        //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                                        Y = blockBounceTimer
                                        //> bne NYSpd                   ;branch ahead, do not process collision
                                        if (!(Y == 0)) {
                                            //  goto NYSpd (internal forward branch)
                                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                            A = 0x01
                                            //> sta Player_Y_Speed     ;jump or swim
                                            playerYSpeed = A
                                            //  Fall-through tail call to doFootCheck
                                            return doFootCheck(X)
                                        }
                                        //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                                        temp2 = playerHeadCollision(temp1)
                                        X = temp2
                                        //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                                        return doFootCheck(temp2)
                                    }
                                    //> inx                         ;otherwise increment size as offset
                                    X = (X + 1) and 0xFF
                                    return X
                                }
                                //> lda PlayerSize
                                A = playerSize
                                //> bne GBBAdr                  ;if player small, skip ahead
                                if (!(A == 0)) {
                                    //  goto GBBAdr (internal forward branch)
                                    //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                                    A = blockBufferAdderData[Y]
                                    //> sta $eb                     ;store value here
                                    memory[0xEB] = A.toUByte()
                                    //> tay                         ;put value into Y, as offset for block buffer routine
                                    Y = A
                                    //> ldx PlayerSize              ;get player's size as offset
                                    X = playerSize
                                    //> lda CrouchingFlag
                                    A = crouchingFlag
                                    //> beq HeadChk                 ;if player not crouching, branch ahead
                                    if (A == 0) {
                                        //  goto HeadChk (internal forward branch)
                                        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                                        A = playerYPosition
                                        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                                        //> bcc DoFootCheck             ;if player is too high, skip this part
                                        if (!(A >= playerBGUpperExtent[X])) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                                        temp3 = blockbuffercolliHead(Y)
                                        //> beq DoFootCheck             ;player, and branch if nothing above player's head
                                        if (temp3 == 0) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                                        temp4 = checkForCoinMTiles(temp3)
                                        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                                        if (flagC) {
                                            //  goto AwardTouchedCoin -> awardTouchedCoin
                                            awardTouchedCoin()
                                            return X
                                        }
                                        //> ldy Player_Y_Speed          ;check player's vertical speed
                                        Y = playerYSpeed
                                        //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                                        if (!((Y and 0x80) != 0)) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> ldy $04                     ;check lower nybble of vertical coordinate returned
                                        Y = memory[0x4].toInt()
                                        //> cpy #$04                    ;from collision detection routine
                                        //> bcc DoFootCheck             ;if low nybble < 4, branch
                                        if (!(Y >= 0x04)) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                                        val flag1: Boolean = checkForSolidMTiles(temp4, X)
                                        //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                                        if (flag1) {
                                            //  goto SolidOrClimb (internal forward branch)
                                            //> SolidOrClimb:
                                            //> cmp #$26               ;if climbing metatile,
                                            //> beq NYSpd              ;branch ahead and do not play sound
                                            if (temp4 == 0x26) {
                                                //  goto NYSpd (internal forward branch)
                                                //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                                A = 0x01
                                                //> sta Player_Y_Speed     ;jump or swim
                                                playerYSpeed = A
                                                //  Fall-through tail call to doFootCheck
                                                return doFootCheck(X)
                                            }
                                            //> lda #Sfx_Bump
                                            A = Sfx_Bump
                                            //> sta Square1SoundQueue  ;otherwise load bump sound
                                            square1SoundQueue = A
                                            return X
                                        }
                                        //> ldy AreaType                ;otherwise check area type
                                        Y = areaType
                                        //> beq NYSpd                   ;if water level, branch ahead
                                        if (Y == 0) {
                                            //  goto NYSpd (internal forward branch)
                                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                            A = 0x01
                                            //> sta Player_Y_Speed     ;jump or swim
                                            playerYSpeed = A
                                            //  Fall-through tail call to doFootCheck
                                            return doFootCheck(X)
                                        }
                                        //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                                        Y = blockBounceTimer
                                        //> bne NYSpd                   ;branch ahead, do not process collision
                                        if (!(Y == 0)) {
                                            //  goto NYSpd (internal forward branch)
                                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                            A = 0x01
                                            //> sta Player_Y_Speed     ;jump or swim
                                            playerYSpeed = A
                                            //  Fall-through tail call to doFootCheck
                                            return doFootCheck(X)
                                        }
                                        //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                                        temp5 = playerHeadCollision(temp4)
                                        X = temp5
                                        //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                                        return doFootCheck(temp5)
                                    }
                                    //> inx                         ;otherwise increment size as offset
                                    X = (X + 1) and 0xFF
                                    return X
                                }
                                //> dey                         ;otherwise decrement offset for big player not crouching
                                Y = (Y - 1) and 0xFF
                                //> lda SwimmingFlag
                                A = swimmingFlag
                                //> bne GBBAdr                  ;if swimming flag set, skip ahead
                                if (!(A == 0)) {
                                    //  goto GBBAdr (internal forward branch)
                                    //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                                    A = blockBufferAdderData[Y]
                                    //> sta $eb                     ;store value here
                                    memory[0xEB] = A.toUByte()
                                    //> tay                         ;put value into Y, as offset for block buffer routine
                                    Y = A
                                    //> ldx PlayerSize              ;get player's size as offset
                                    X = playerSize
                                    //> lda CrouchingFlag
                                    A = crouchingFlag
                                    //> beq HeadChk                 ;if player not crouching, branch ahead
                                    if (A == 0) {
                                        //  goto HeadChk (internal forward branch)
                                        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                                        A = playerYPosition
                                        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                                        //> bcc DoFootCheck             ;if player is too high, skip this part
                                        if (!(A >= playerBGUpperExtent[X])) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                                        temp6 = blockbuffercolliHead(Y)
                                        //> beq DoFootCheck             ;player, and branch if nothing above player's head
                                        if (temp6 == 0) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                                        temp7 = checkForCoinMTiles(temp6)
                                        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                                        if (flagC) {
                                            //  goto AwardTouchedCoin -> awardTouchedCoin
                                            awardTouchedCoin()
                                            return X
                                        }
                                        //> ldy Player_Y_Speed          ;check player's vertical speed
                                        Y = playerYSpeed
                                        //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                                        if (!((Y and 0x80) != 0)) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> ldy $04                     ;check lower nybble of vertical coordinate returned
                                        Y = memory[0x4].toInt()
                                        //> cpy #$04                    ;from collision detection routine
                                        //> bcc DoFootCheck             ;if low nybble < 4, branch
                                        if (!(Y >= 0x04)) {
                                            //  goto DoFootCheck -> doFootCheck
                                            doFootCheck(X)
                                            return X
                                        }
                                        //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                                        val flag2: Boolean = checkForSolidMTiles(temp7, X)
                                        //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                                        if (flag2) {
                                            //  goto SolidOrClimb (internal forward branch)
                                            //> SolidOrClimb:
                                            //> cmp #$26               ;if climbing metatile,
                                            //> beq NYSpd              ;branch ahead and do not play sound
                                            if (temp7 == 0x26) {
                                                //  goto NYSpd (internal forward branch)
                                                //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                                A = 0x01
                                                //> sta Player_Y_Speed     ;jump or swim
                                                playerYSpeed = A
                                                //  Fall-through tail call to doFootCheck
                                                return doFootCheck(X)
                                            }
                                            //> lda #Sfx_Bump
                                            A = Sfx_Bump
                                            //> sta Square1SoundQueue  ;otherwise load bump sound
                                            square1SoundQueue = A
                                            return X
                                        }
                                        //> ldy AreaType                ;otherwise check area type
                                        Y = areaType
                                        //> beq NYSpd                   ;if water level, branch ahead
                                        if (Y == 0) {
                                            //  goto NYSpd (internal forward branch)
                                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                            A = 0x01
                                            //> sta Player_Y_Speed     ;jump or swim
                                            playerYSpeed = A
                                            //  Fall-through tail call to doFootCheck
                                            return doFootCheck(X)
                                        }
                                        //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                                        Y = blockBounceTimer
                                        //> bne NYSpd                   ;branch ahead, do not process collision
                                        if (!(Y == 0)) {
                                            //  goto NYSpd (internal forward branch)
                                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                            A = 0x01
                                            //> sta Player_Y_Speed     ;jump or swim
                                            playerYSpeed = A
                                            //  Fall-through tail call to doFootCheck
                                            return doFootCheck(X)
                                        }
                                        //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                                        temp8 = playerHeadCollision(temp7)
                                        X = temp8
                                        //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                                        return doFootCheck(temp8)
                                    }
                                    //> inx                         ;otherwise increment size as offset
                                    X = (X + 1) and 0xFF
                                    return X
                                }
                                //> dey                         ;otherwise decrement offset
                                Y = (Y - 1) and 0xFF
                                return X
                            }
                            return X
                        }
                    }
                    //> SetFallS: lda #$02                  ;load default player state for falling
                    A = 0x02
                }
                //> SetPSte:  sta Player_State          ;set whatever player state is appropriate
                playerState = A
                //> ChkOnScr: lda Player_Y_HighPos
                A = playerYHighpos
                //> cmp #$01                  ;check player's vertical high byte for still on the screen
                //> bne ExPBGCol              ;branch to leave if not
                if (A == 0x01) {
                    //> lda #$ff
                    A = 0xFF
                    //> sta Player_CollisionBits  ;initialize player's collision flag
                    playerCollisionbits = A
                    //> lda Player_Y_Position
                    A = playerYPosition
                    //> cmp #$cf                  ;check player's vertical coordinate
                    //> bcc ChkCollSize           ;if not too close to the bottom of screen, continue
                    if (!(A >= 0xCF)) {
                        //  goto ChkCollSize (internal forward branch)
                        //> ChkCollSize:
                        //> ldy #$02                    ;load default offset
                        Y = 0x02
                        //> lda CrouchingFlag
                        A = crouchingFlag
                        //> bne GBBAdr                  ;if player crouching, skip ahead
                        if (!(A == 0)) {
                            //  goto GBBAdr (internal forward branch)
                            //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                            A = blockBufferAdderData[Y]
                            //> sta $eb                     ;store value here
                            memory[0xEB] = A.toUByte()
                            //> tay                         ;put value into Y, as offset for block buffer routine
                            Y = A
                            //> ldx PlayerSize              ;get player's size as offset
                            X = playerSize
                            //> lda CrouchingFlag
                            A = crouchingFlag
                            //> beq HeadChk                 ;if player not crouching, branch ahead
                            if (A == 0) {
                                //  goto HeadChk (internal forward branch)
                                //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                                A = playerYPosition
                                //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                                //> bcc DoFootCheck             ;if player is too high, skip this part
                                if (!(A >= playerBGUpperExtent[X])) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                                temp9 = blockbuffercolliHead(Y)
                                //> beq DoFootCheck             ;player, and branch if nothing above player's head
                                if (temp9 == 0) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                                temp10 = checkForCoinMTiles(temp9)
                                //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                                if (flagC) {
                                    //  goto AwardTouchedCoin -> awardTouchedCoin
                                    awardTouchedCoin()
                                    return X
                                }
                                //> ldy Player_Y_Speed          ;check player's vertical speed
                                Y = playerYSpeed
                                //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                                if (!((Y and 0x80) != 0)) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> ldy $04                     ;check lower nybble of vertical coordinate returned
                                Y = memory[0x4].toInt()
                                //> cpy #$04                    ;from collision detection routine
                                //> bcc DoFootCheck             ;if low nybble < 4, branch
                                if (!(Y >= 0x04)) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                                val flag3: Boolean = checkForSolidMTiles(temp10, X)
                                //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                                if (flag3) {
                                    //  goto SolidOrClimb (internal forward branch)
                                    //> SolidOrClimb:
                                    //> cmp #$26               ;if climbing metatile,
                                    //> beq NYSpd              ;branch ahead and do not play sound
                                    if (temp10 == 0x26) {
                                        //  goto NYSpd (internal forward branch)
                                        //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                        A = 0x01
                                        //> sta Player_Y_Speed     ;jump or swim
                                        playerYSpeed = A
                                        //  Fall-through tail call to doFootCheck
                                        return doFootCheck(X)
                                    }
                                    //> lda #Sfx_Bump
                                    A = Sfx_Bump
                                    //> sta Square1SoundQueue  ;otherwise load bump sound
                                    square1SoundQueue = A
                                    return X
                                }
                                //> ldy AreaType                ;otherwise check area type
                                Y = areaType
                                //> beq NYSpd                   ;if water level, branch ahead
                                if (Y == 0) {
                                    //  goto NYSpd (internal forward branch)
                                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                    A = 0x01
                                    //> sta Player_Y_Speed     ;jump or swim
                                    playerYSpeed = A
                                    //  Fall-through tail call to doFootCheck
                                    return doFootCheck(X)
                                }
                                //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                                Y = blockBounceTimer
                                //> bne NYSpd                   ;branch ahead, do not process collision
                                if (!(Y == 0)) {
                                    //  goto NYSpd (internal forward branch)
                                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                    A = 0x01
                                    //> sta Player_Y_Speed     ;jump or swim
                                    playerYSpeed = A
                                    //  Fall-through tail call to doFootCheck
                                    return doFootCheck(X)
                                }
                                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                                temp11 = playerHeadCollision(temp10)
                                X = temp11
                                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                                return doFootCheck(temp11)
                            }
                            //> inx                         ;otherwise increment size as offset
                            X = (X + 1) and 0xFF
                            return X
                        }
                        //> lda PlayerSize
                        A = playerSize
                        //> bne GBBAdr                  ;if player small, skip ahead
                        if (!(A == 0)) {
                            //  goto GBBAdr (internal forward branch)
                            //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                            A = blockBufferAdderData[Y]
                            //> sta $eb                     ;store value here
                            memory[0xEB] = A.toUByte()
                            //> tay                         ;put value into Y, as offset for block buffer routine
                            Y = A
                            //> ldx PlayerSize              ;get player's size as offset
                            X = playerSize
                            //> lda CrouchingFlag
                            A = crouchingFlag
                            //> beq HeadChk                 ;if player not crouching, branch ahead
                            if (A == 0) {
                                //  goto HeadChk (internal forward branch)
                                //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                                A = playerYPosition
                                //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                                //> bcc DoFootCheck             ;if player is too high, skip this part
                                if (!(A >= playerBGUpperExtent[X])) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                                temp12 = blockbuffercolliHead(Y)
                                //> beq DoFootCheck             ;player, and branch if nothing above player's head
                                if (temp12 == 0) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                                temp13 = checkForCoinMTiles(temp12)
                                //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                                if (flagC) {
                                    //  goto AwardTouchedCoin -> awardTouchedCoin
                                    awardTouchedCoin()
                                    return X
                                }
                                //> ldy Player_Y_Speed          ;check player's vertical speed
                                Y = playerYSpeed
                                //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                                if (!((Y and 0x80) != 0)) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> ldy $04                     ;check lower nybble of vertical coordinate returned
                                Y = memory[0x4].toInt()
                                //> cpy #$04                    ;from collision detection routine
                                //> bcc DoFootCheck             ;if low nybble < 4, branch
                                if (!(Y >= 0x04)) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                                val flag4: Boolean = checkForSolidMTiles(temp13, X)
                                //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                                if (flag4) {
                                    //  goto SolidOrClimb (internal forward branch)
                                    //> SolidOrClimb:
                                    //> cmp #$26               ;if climbing metatile,
                                    //> beq NYSpd              ;branch ahead and do not play sound
                                    if (temp13 == 0x26) {
                                        //  goto NYSpd (internal forward branch)
                                        //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                        A = 0x01
                                        //> sta Player_Y_Speed     ;jump or swim
                                        playerYSpeed = A
                                        //  Fall-through tail call to doFootCheck
                                        return doFootCheck(X)
                                    }
                                    //> lda #Sfx_Bump
                                    A = Sfx_Bump
                                    //> sta Square1SoundQueue  ;otherwise load bump sound
                                    square1SoundQueue = A
                                    return X
                                }
                                //> ldy AreaType                ;otherwise check area type
                                Y = areaType
                                //> beq NYSpd                   ;if water level, branch ahead
                                if (Y == 0) {
                                    //  goto NYSpd (internal forward branch)
                                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                    A = 0x01
                                    //> sta Player_Y_Speed     ;jump or swim
                                    playerYSpeed = A
                                    //  Fall-through tail call to doFootCheck
                                    return doFootCheck(X)
                                }
                                //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                                Y = blockBounceTimer
                                //> bne NYSpd                   ;branch ahead, do not process collision
                                if (!(Y == 0)) {
                                    //  goto NYSpd (internal forward branch)
                                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                    A = 0x01
                                    //> sta Player_Y_Speed     ;jump or swim
                                    playerYSpeed = A
                                    //  Fall-through tail call to doFootCheck
                                    return doFootCheck(X)
                                }
                                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                                temp14 = playerHeadCollision(temp13)
                                X = temp14
                                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                                return doFootCheck(temp14)
                            }
                            //> inx                         ;otherwise increment size as offset
                            X = (X + 1) and 0xFF
                            return X
                        }
                        //> dey                         ;otherwise decrement offset for big player not crouching
                        Y = (Y - 1) and 0xFF
                        //> lda SwimmingFlag
                        A = swimmingFlag
                        //> bne GBBAdr                  ;if swimming flag set, skip ahead
                        if (!(A == 0)) {
                            //  goto GBBAdr (internal forward branch)
                            //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                            A = blockBufferAdderData[Y]
                            //> sta $eb                     ;store value here
                            memory[0xEB] = A.toUByte()
                            //> tay                         ;put value into Y, as offset for block buffer routine
                            Y = A
                            //> ldx PlayerSize              ;get player's size as offset
                            X = playerSize
                            //> lda CrouchingFlag
                            A = crouchingFlag
                            //> beq HeadChk                 ;if player not crouching, branch ahead
                            if (A == 0) {
                                //  goto HeadChk (internal forward branch)
                                //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                                A = playerYPosition
                                //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                                //> bcc DoFootCheck             ;if player is too high, skip this part
                                if (!(A >= playerBGUpperExtent[X])) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                                temp15 = blockbuffercolliHead(Y)
                                //> beq DoFootCheck             ;player, and branch if nothing above player's head
                                if (temp15 == 0) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                                temp16 = checkForCoinMTiles(temp15)
                                //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                                if (flagC) {
                                    //  goto AwardTouchedCoin -> awardTouchedCoin
                                    awardTouchedCoin()
                                    return X
                                }
                                //> ldy Player_Y_Speed          ;check player's vertical speed
                                Y = playerYSpeed
                                //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                                if (!((Y and 0x80) != 0)) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> ldy $04                     ;check lower nybble of vertical coordinate returned
                                Y = memory[0x4].toInt()
                                //> cpy #$04                    ;from collision detection routine
                                //> bcc DoFootCheck             ;if low nybble < 4, branch
                                if (!(Y >= 0x04)) {
                                    //  goto DoFootCheck -> doFootCheck
                                    doFootCheck(X)
                                    return X
                                }
                                //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                                val flag5: Boolean = checkForSolidMTiles(temp16, X)
                                //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                                if (flag5) {
                                    //  goto SolidOrClimb (internal forward branch)
                                    //> SolidOrClimb:
                                    //> cmp #$26               ;if climbing metatile,
                                    //> beq NYSpd              ;branch ahead and do not play sound
                                    if (temp16 == 0x26) {
                                        //  goto NYSpd (internal forward branch)
                                        //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                        A = 0x01
                                        //> sta Player_Y_Speed     ;jump or swim
                                        playerYSpeed = A
                                        //  Fall-through tail call to doFootCheck
                                        return doFootCheck(X)
                                    }
                                    //> lda #Sfx_Bump
                                    A = Sfx_Bump
                                    //> sta Square1SoundQueue  ;otherwise load bump sound
                                    square1SoundQueue = A
                                    return X
                                }
                                //> ldy AreaType                ;otherwise check area type
                                Y = areaType
                                //> beq NYSpd                   ;if water level, branch ahead
                                if (Y == 0) {
                                    //  goto NYSpd (internal forward branch)
                                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                    A = 0x01
                                    //> sta Player_Y_Speed     ;jump or swim
                                    playerYSpeed = A
                                    //  Fall-through tail call to doFootCheck
                                    return doFootCheck(X)
                                }
                                //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                                Y = blockBounceTimer
                                //> bne NYSpd                   ;branch ahead, do not process collision
                                if (!(Y == 0)) {
                                    //  goto NYSpd (internal forward branch)
                                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                    A = 0x01
                                    //> sta Player_Y_Speed     ;jump or swim
                                    playerYSpeed = A
                                    //  Fall-through tail call to doFootCheck
                                    return doFootCheck(X)
                                }
                                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                                temp17 = playerHeadCollision(temp16)
                                X = temp17
                                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                                return doFootCheck(temp17)
                            }
                            //> inx                         ;otherwise increment size as offset
                            X = (X + 1) and 0xFF
                            return X
                        }
                        //> dey                         ;otherwise decrement offset
                        Y = (Y - 1) and 0xFF
                        return X
                    }
                } else {
                    //> ExPBGCol: rts                       ;otherwise leave
                    return X
                }
                //> ChkCollSize:
                //> ldy #$02                    ;load default offset
                Y = 0x02
                //> lda CrouchingFlag
                A = crouchingFlag
                //> bne GBBAdr                  ;if player crouching, skip ahead
                if (!(A == 0)) {
                    //  goto GBBAdr (internal forward branch)
                    //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                    A = blockBufferAdderData[Y]
                    //> sta $eb                     ;store value here
                    memory[0xEB] = A.toUByte()
                    //> tay                         ;put value into Y, as offset for block buffer routine
                    Y = A
                    //> ldx PlayerSize              ;get player's size as offset
                    X = playerSize
                    //> lda CrouchingFlag
                    A = crouchingFlag
                    //> beq HeadChk                 ;if player not crouching, branch ahead
                    if (A == 0) {
                        //  goto HeadChk (internal forward branch)
                        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                        A = playerYPosition
                        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                        //> bcc DoFootCheck             ;if player is too high, skip this part
                        if (!(A >= playerBGUpperExtent[X])) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                        temp18 = blockbuffercolliHead(Y)
                        //> beq DoFootCheck             ;player, and branch if nothing above player's head
                        if (temp18 == 0) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                        temp19 = checkForCoinMTiles(temp18)
                        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                        if (flagC) {
                            //  goto AwardTouchedCoin -> awardTouchedCoin
                            awardTouchedCoin()
                            return X
                        }
                        //> ldy Player_Y_Speed          ;check player's vertical speed
                        Y = playerYSpeed
                        //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                        if (!((Y and 0x80) != 0)) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> ldy $04                     ;check lower nybble of vertical coordinate returned
                        Y = memory[0x4].toInt()
                        //> cpy #$04                    ;from collision detection routine
                        //> bcc DoFootCheck             ;if low nybble < 4, branch
                        if (!(Y >= 0x04)) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                        val flag6: Boolean = checkForSolidMTiles(temp19, X)
                        //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                        if (flag6) {
                            //  goto SolidOrClimb (internal forward branch)
                            //> SolidOrClimb:
                            //> cmp #$26               ;if climbing metatile,
                            //> beq NYSpd              ;branch ahead and do not play sound
                            if (temp19 == 0x26) {
                                //  goto NYSpd (internal forward branch)
                                //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                A = 0x01
                                //> sta Player_Y_Speed     ;jump or swim
                                playerYSpeed = A
                                //  Fall-through tail call to doFootCheck
                                return doFootCheck(X)
                            }
                            //> lda #Sfx_Bump
                            A = Sfx_Bump
                            //> sta Square1SoundQueue  ;otherwise load bump sound
                            square1SoundQueue = A
                            return X
                        }
                        //> ldy AreaType                ;otherwise check area type
                        Y = areaType
                        //> beq NYSpd                   ;if water level, branch ahead
                        if (Y == 0) {
                            //  goto NYSpd (internal forward branch)
                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                            A = 0x01
                            //> sta Player_Y_Speed     ;jump or swim
                            playerYSpeed = A
                            //  Fall-through tail call to doFootCheck
                            return doFootCheck(X)
                        }
                        //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                        Y = blockBounceTimer
                        //> bne NYSpd                   ;branch ahead, do not process collision
                        if (!(Y == 0)) {
                            //  goto NYSpd (internal forward branch)
                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                            A = 0x01
                            //> sta Player_Y_Speed     ;jump or swim
                            playerYSpeed = A
                            //  Fall-through tail call to doFootCheck
                            return doFootCheck(X)
                        }
                        //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                        temp20 = playerHeadCollision(temp19)
                        X = temp20
                        //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                        return doFootCheck(temp20)
                    }
                    //> inx                         ;otherwise increment size as offset
                    X = (X + 1) and 0xFF
                    return X
                }
                //> lda PlayerSize
                A = playerSize
                //> bne GBBAdr                  ;if player small, skip ahead
                if (!(A == 0)) {
                    //  goto GBBAdr (internal forward branch)
                    //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                    A = blockBufferAdderData[Y]
                    //> sta $eb                     ;store value here
                    memory[0xEB] = A.toUByte()
                    //> tay                         ;put value into Y, as offset for block buffer routine
                    Y = A
                    //> ldx PlayerSize              ;get player's size as offset
                    X = playerSize
                    //> lda CrouchingFlag
                    A = crouchingFlag
                    //> beq HeadChk                 ;if player not crouching, branch ahead
                    if (A == 0) {
                        //  goto HeadChk (internal forward branch)
                        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                        A = playerYPosition
                        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                        //> bcc DoFootCheck             ;if player is too high, skip this part
                        if (!(A >= playerBGUpperExtent[X])) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                        temp21 = blockbuffercolliHead(Y)
                        //> beq DoFootCheck             ;player, and branch if nothing above player's head
                        if (temp21 == 0) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                        temp22 = checkForCoinMTiles(temp21)
                        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                        if (flagC) {
                            //  goto AwardTouchedCoin -> awardTouchedCoin
                            awardTouchedCoin()
                            return X
                        }
                        //> ldy Player_Y_Speed          ;check player's vertical speed
                        Y = playerYSpeed
                        //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                        if (!((Y and 0x80) != 0)) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> ldy $04                     ;check lower nybble of vertical coordinate returned
                        Y = memory[0x4].toInt()
                        //> cpy #$04                    ;from collision detection routine
                        //> bcc DoFootCheck             ;if low nybble < 4, branch
                        if (!(Y >= 0x04)) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                        val flag7: Boolean = checkForSolidMTiles(temp22, X)
                        //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                        if (flag7) {
                            //  goto SolidOrClimb (internal forward branch)
                            //> SolidOrClimb:
                            //> cmp #$26               ;if climbing metatile,
                            //> beq NYSpd              ;branch ahead and do not play sound
                            if (temp22 == 0x26) {
                                //  goto NYSpd (internal forward branch)
                                //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                A = 0x01
                                //> sta Player_Y_Speed     ;jump or swim
                                playerYSpeed = A
                                //  Fall-through tail call to doFootCheck
                                return doFootCheck(X)
                            }
                            //> lda #Sfx_Bump
                            A = Sfx_Bump
                            //> sta Square1SoundQueue  ;otherwise load bump sound
                            square1SoundQueue = A
                            return X
                        }
                        //> ldy AreaType                ;otherwise check area type
                        Y = areaType
                        //> beq NYSpd                   ;if water level, branch ahead
                        if (Y == 0) {
                            //  goto NYSpd (internal forward branch)
                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                            A = 0x01
                            //> sta Player_Y_Speed     ;jump or swim
                            playerYSpeed = A
                            //  Fall-through tail call to doFootCheck
                            return doFootCheck(X)
                        }
                        //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                        Y = blockBounceTimer
                        //> bne NYSpd                   ;branch ahead, do not process collision
                        if (!(Y == 0)) {
                            //  goto NYSpd (internal forward branch)
                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                            A = 0x01
                            //> sta Player_Y_Speed     ;jump or swim
                            playerYSpeed = A
                            //  Fall-through tail call to doFootCheck
                            return doFootCheck(X)
                        }
                        //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                        temp23 = playerHeadCollision(temp22)
                        X = temp23
                        //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                        return doFootCheck(temp23)
                    }
                    //> inx                         ;otherwise increment size as offset
                    X = (X + 1) and 0xFF
                    return X
                }
                //> dey                         ;otherwise decrement offset for big player not crouching
                Y = (Y - 1) and 0xFF
                //> lda SwimmingFlag
                A = swimmingFlag
                //> bne GBBAdr                  ;if swimming flag set, skip ahead
                if (!(A == 0)) {
                    //  goto GBBAdr (internal forward branch)
                    //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
                    A = blockBufferAdderData[Y]
                    //> sta $eb                     ;store value here
                    memory[0xEB] = A.toUByte()
                    //> tay                         ;put value into Y, as offset for block buffer routine
                    Y = A
                    //> ldx PlayerSize              ;get player's size as offset
                    X = playerSize
                    //> lda CrouchingFlag
                    A = crouchingFlag
                    //> beq HeadChk                 ;if player not crouching, branch ahead
                    if (A == 0) {
                        //  goto HeadChk (internal forward branch)
                        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                        A = playerYPosition
                        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                        //> bcc DoFootCheck             ;if player is too high, skip this part
                        if (!(A >= playerBGUpperExtent[X])) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                        temp24 = blockbuffercolliHead(Y)
                        //> beq DoFootCheck             ;player, and branch if nothing above player's head
                        if (temp24 == 0) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                        temp25 = checkForCoinMTiles(temp24)
                        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                        if (flagC) {
                            //  goto AwardTouchedCoin -> awardTouchedCoin
                            awardTouchedCoin()
                            return X
                        }
                        //> ldy Player_Y_Speed          ;check player's vertical speed
                        Y = playerYSpeed
                        //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                        if (!((Y and 0x80) != 0)) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> ldy $04                     ;check lower nybble of vertical coordinate returned
                        Y = memory[0x4].toInt()
                        //> cpy #$04                    ;from collision detection routine
                        //> bcc DoFootCheck             ;if low nybble < 4, branch
                        if (!(Y >= 0x04)) {
                            //  goto DoFootCheck -> doFootCheck
                            doFootCheck(X)
                            return X
                        }
                        //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                        val flag8: Boolean = checkForSolidMTiles(temp25, X)
                        //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                        if (flag8) {
                            //  goto SolidOrClimb (internal forward branch)
                            //> SolidOrClimb:
                            //> cmp #$26               ;if climbing metatile,
                            //> beq NYSpd              ;branch ahead and do not play sound
                            if (temp25 == 0x26) {
                                //  goto NYSpd (internal forward branch)
                                //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                                A = 0x01
                                //> sta Player_Y_Speed     ;jump or swim
                                playerYSpeed = A
                                //  Fall-through tail call to doFootCheck
                                return doFootCheck(X)
                            }
                            //> lda #Sfx_Bump
                            A = Sfx_Bump
                            //> sta Square1SoundQueue  ;otherwise load bump sound
                            square1SoundQueue = A
                            return X
                        }
                        //> ldy AreaType                ;otherwise check area type
                        Y = areaType
                        //> beq NYSpd                   ;if water level, branch ahead
                        if (Y == 0) {
                            //  goto NYSpd (internal forward branch)
                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                            A = 0x01
                            //> sta Player_Y_Speed     ;jump or swim
                            playerYSpeed = A
                            //  Fall-through tail call to doFootCheck
                            return doFootCheck(X)
                        }
                        //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                        Y = blockBounceTimer
                        //> bne NYSpd                   ;branch ahead, do not process collision
                        if (!(Y == 0)) {
                            //  goto NYSpd (internal forward branch)
                            //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                            A = 0x01
                            //> sta Player_Y_Speed     ;jump or swim
                            playerYSpeed = A
                            //  Fall-through tail call to doFootCheck
                            return doFootCheck(X)
                        }
                        //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                        temp26 = playerHeadCollision(temp25)
                        X = temp26
                        //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                        return doFootCheck(temp26)
                    }
                    //> inx                         ;otherwise increment size as offset
                    X = (X + 1) and 0xFF
                    return X
                }
                //> dey                         ;otherwise decrement offset
                Y = (Y - 1) and 0xFF
            } else {
                //> ExPBGCol: rts                       ;otherwise leave
                return X
            }
            //> inx                         ;otherwise increment size as offset
            X = (X + 1) and 0xFF
            //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
            A = playerYPosition
            //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
            //> bcc DoFootCheck             ;if player is too high, skip this part
            if (!(A >= playerBGUpperExtent[X])) {
                //  goto DoFootCheck -> doFootCheck
                doFootCheck(X)
                return X
            }
        } else {
            //> ExPBGCol: rts                       ;otherwise leave
            return X
        }
        //> ChkCollSize:
        //> ldy #$02                    ;load default offset
        Y = 0x02
        //> lda CrouchingFlag
        A = crouchingFlag
        //> bne GBBAdr                  ;if player crouching, skip ahead
        if (!(A == 0)) {
            //  goto GBBAdr (internal forward branch)
            //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
            A = blockBufferAdderData[Y]
            //> sta $eb                     ;store value here
            memory[0xEB] = A.toUByte()
            //> tay                         ;put value into Y, as offset for block buffer routine
            Y = A
            //> ldx PlayerSize              ;get player's size as offset
            X = playerSize
            //> lda CrouchingFlag
            A = crouchingFlag
            //> beq HeadChk                 ;if player not crouching, branch ahead
            if (A == 0) {
                //  goto HeadChk (internal forward branch)
                //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                A = playerYPosition
                //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                //> bcc DoFootCheck             ;if player is too high, skip this part
                if (!(A >= playerBGUpperExtent[X])) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                temp27 = blockbuffercolliHead(Y)
                //> beq DoFootCheck             ;player, and branch if nothing above player's head
                if (temp27 == 0) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                temp28 = checkForCoinMTiles(temp27)
                //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                if (flagC) {
                    //  goto AwardTouchedCoin -> awardTouchedCoin
                    awardTouchedCoin()
                    return X
                }
                //> ldy Player_Y_Speed          ;check player's vertical speed
                Y = playerYSpeed
                //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                if (!((Y and 0x80) != 0)) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> ldy $04                     ;check lower nybble of vertical coordinate returned
                Y = memory[0x4].toInt()
                //> cpy #$04                    ;from collision detection routine
                //> bcc DoFootCheck             ;if low nybble < 4, branch
                if (!(Y >= 0x04)) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                val flag9: Boolean = checkForSolidMTiles(temp28, X)
                //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                if (flag9) {
                    //  goto SolidOrClimb (internal forward branch)
                    //> SolidOrClimb:
                    //> cmp #$26               ;if climbing metatile,
                    //> beq NYSpd              ;branch ahead and do not play sound
                    if (temp28 == 0x26) {
                        //  goto NYSpd (internal forward branch)
                        //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                        A = 0x01
                        //> sta Player_Y_Speed     ;jump or swim
                        playerYSpeed = A
                        //  Fall-through tail call to doFootCheck
                        return doFootCheck(X)
                    }
                    //> lda #Sfx_Bump
                    A = Sfx_Bump
                    //> sta Square1SoundQueue  ;otherwise load bump sound
                    square1SoundQueue = A
                    return X
                }
                //> ldy AreaType                ;otherwise check area type
                Y = areaType
                //> beq NYSpd                   ;if water level, branch ahead
                if (Y == 0) {
                    //  goto NYSpd (internal forward branch)
                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                    A = 0x01
                    //> sta Player_Y_Speed     ;jump or swim
                    playerYSpeed = A
                    //  Fall-through tail call to doFootCheck
                    return doFootCheck(X)
                }
                //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                Y = blockBounceTimer
                //> bne NYSpd                   ;branch ahead, do not process collision
                if (!(Y == 0)) {
                    //  goto NYSpd (internal forward branch)
                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                    A = 0x01
                    //> sta Player_Y_Speed     ;jump or swim
                    playerYSpeed = A
                    //  Fall-through tail call to doFootCheck
                    return doFootCheck(X)
                }
                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                temp29 = playerHeadCollision(temp28)
                X = temp29
                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                return doFootCheck(temp29)
            }
            //> inx                         ;otherwise increment size as offset
            X = (X + 1) and 0xFF
            return X
        }
        //> lda PlayerSize
        A = playerSize
        //> bne GBBAdr                  ;if player small, skip ahead
        if (!(A == 0)) {
            //  goto GBBAdr (internal forward branch)
            //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
            A = blockBufferAdderData[Y]
            //> sta $eb                     ;store value here
            memory[0xEB] = A.toUByte()
            //> tay                         ;put value into Y, as offset for block buffer routine
            Y = A
            //> ldx PlayerSize              ;get player's size as offset
            X = playerSize
            //> lda CrouchingFlag
            A = crouchingFlag
            //> beq HeadChk                 ;if player not crouching, branch ahead
            if (A == 0) {
                //  goto HeadChk (internal forward branch)
                //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                A = playerYPosition
                //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                //> bcc DoFootCheck             ;if player is too high, skip this part
                if (!(A >= playerBGUpperExtent[X])) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                temp30 = blockbuffercolliHead(Y)
                //> beq DoFootCheck             ;player, and branch if nothing above player's head
                if (temp30 == 0) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                temp31 = checkForCoinMTiles(temp30)
                //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                if (flagC) {
                    //  goto AwardTouchedCoin -> awardTouchedCoin
                    awardTouchedCoin()
                    return X
                }
                //> ldy Player_Y_Speed          ;check player's vertical speed
                Y = playerYSpeed
                //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                if (!((Y and 0x80) != 0)) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> ldy $04                     ;check lower nybble of vertical coordinate returned
                Y = memory[0x4].toInt()
                //> cpy #$04                    ;from collision detection routine
                //> bcc DoFootCheck             ;if low nybble < 4, branch
                if (!(Y >= 0x04)) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                val flag10: Boolean = checkForSolidMTiles(temp31, X)
                //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                if (flag10) {
                    //  goto SolidOrClimb (internal forward branch)
                    //> SolidOrClimb:
                    //> cmp #$26               ;if climbing metatile,
                    //> beq NYSpd              ;branch ahead and do not play sound
                    if (temp31 == 0x26) {
                        //  goto NYSpd (internal forward branch)
                        //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                        A = 0x01
                        //> sta Player_Y_Speed     ;jump or swim
                        playerYSpeed = A
                        //  Fall-through tail call to doFootCheck
                        return doFootCheck(X)
                    }
                    //> lda #Sfx_Bump
                    A = Sfx_Bump
                    //> sta Square1SoundQueue  ;otherwise load bump sound
                    square1SoundQueue = A
                    return X
                }
                //> ldy AreaType                ;otherwise check area type
                Y = areaType
                //> beq NYSpd                   ;if water level, branch ahead
                if (Y == 0) {
                    //  goto NYSpd (internal forward branch)
                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                    A = 0x01
                    //> sta Player_Y_Speed     ;jump or swim
                    playerYSpeed = A
                    //  Fall-through tail call to doFootCheck
                    return doFootCheck(X)
                }
                //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                Y = blockBounceTimer
                //> bne NYSpd                   ;branch ahead, do not process collision
                if (!(Y == 0)) {
                    //  goto NYSpd (internal forward branch)
                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                    A = 0x01
                    //> sta Player_Y_Speed     ;jump or swim
                    playerYSpeed = A
                    //  Fall-through tail call to doFootCheck
                    return doFootCheck(X)
                }
                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                temp32 = playerHeadCollision(temp31)
                X = temp32
                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                return doFootCheck(temp32)
            }
            //> inx                         ;otherwise increment size as offset
            X = (X + 1) and 0xFF
            return X
        }
        //> dey                         ;otherwise decrement offset for big player not crouching
        Y = (Y - 1) and 0xFF
        //> lda SwimmingFlag
        A = swimmingFlag
        //> bne GBBAdr                  ;if swimming flag set, skip ahead
        if (!(A == 0)) {
            //  goto GBBAdr (internal forward branch)
            //> GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
            A = blockBufferAdderData[Y]
            //> sta $eb                     ;store value here
            memory[0xEB] = A.toUByte()
            //> tay                         ;put value into Y, as offset for block buffer routine
            Y = A
            //> ldx PlayerSize              ;get player's size as offset
            X = playerSize
            //> lda CrouchingFlag
            A = crouchingFlag
            //> beq HeadChk                 ;if player not crouching, branch ahead
            if (A == 0) {
                //  goto HeadChk (internal forward branch)
                //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
                A = playerYPosition
                //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
                //> bcc DoFootCheck             ;if player is too high, skip this part
                if (!(A >= playerBGUpperExtent[X])) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
                temp33 = blockbuffercolliHead(Y)
                //> beq DoFootCheck             ;player, and branch if nothing above player's head
                if (temp33 == 0) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
                temp34 = checkForCoinMTiles(temp33)
                //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
                if (flagC) {
                    //  goto AwardTouchedCoin -> awardTouchedCoin
                    awardTouchedCoin()
                    return X
                }
                //> ldy Player_Y_Speed          ;check player's vertical speed
                Y = playerYSpeed
                //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
                if (!((Y and 0x80) != 0)) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> ldy $04                     ;check lower nybble of vertical coordinate returned
                Y = memory[0x4].toInt()
                //> cpy #$04                    ;from collision detection routine
                //> bcc DoFootCheck             ;if low nybble < 4, branch
                if (!(Y >= 0x04)) {
                    //  goto DoFootCheck -> doFootCheck
                    doFootCheck(X)
                    return X
                }
                //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
                val flag11: Boolean = checkForSolidMTiles(temp34, X)
                //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
                if (flag11) {
                    //  goto SolidOrClimb (internal forward branch)
                    //> SolidOrClimb:
                    //> cmp #$26               ;if climbing metatile,
                    //> beq NYSpd              ;branch ahead and do not play sound
                    if (temp34 == 0x26) {
                        //  goto NYSpd (internal forward branch)
                        //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                        A = 0x01
                        //> sta Player_Y_Speed     ;jump or swim
                        playerYSpeed = A
                        //  Fall-through tail call to doFootCheck
                        return doFootCheck(X)
                    }
                    //> lda #Sfx_Bump
                    A = Sfx_Bump
                    //> sta Square1SoundQueue  ;otherwise load bump sound
                    square1SoundQueue = A
                    return X
                }
                //> ldy AreaType                ;otherwise check area type
                Y = areaType
                //> beq NYSpd                   ;if water level, branch ahead
                if (Y == 0) {
                    //  goto NYSpd (internal forward branch)
                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                    A = 0x01
                    //> sta Player_Y_Speed     ;jump or swim
                    playerYSpeed = A
                    //  Fall-through tail call to doFootCheck
                    return doFootCheck(X)
                }
                //> ldy BlockBounceTimer        ;if block bounce timer not expired,
                Y = blockBounceTimer
                //> bne NYSpd                   ;branch ahead, do not process collision
                if (!(Y == 0)) {
                    //  goto NYSpd (internal forward branch)
                    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
                    A = 0x01
                    //> sta Player_Y_Speed     ;jump or swim
                    playerYSpeed = A
                    //  Fall-through tail call to doFootCheck
                    return doFootCheck(X)
                }
                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                temp35 = playerHeadCollision(temp34)
                X = temp35
                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                return doFootCheck(temp35)
            }
            //> inx                         ;otherwise increment size as offset
            X = (X + 1) and 0xFF
            return X
        }
        //> dey                         ;otherwise decrement offset
        Y = (Y - 1) and 0xFF
        //> inx                         ;otherwise increment size as offset
        X = (X + 1) and 0xFF
        //> HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
        A = playerYPosition
        //> cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
        //> bcc DoFootCheck             ;if player is too high, skip this part
        if (!(A >= playerBGUpperExtent[X])) {
            //  goto DoFootCheck -> doFootCheck
            doFootCheck(X)
            return X
        }
    } else {
        //> ExPBGCol: rts                       ;otherwise leave
        return X
    }
    //> jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
    temp36 = blockbuffercolliHead(Y)
    //> beq DoFootCheck             ;player, and branch if nothing above player's head
    if (temp36 == 0) {
        //  goto DoFootCheck -> doFootCheck
        doFootCheck(X)
        return X
    } else {
        //> jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
        temp37 = checkForCoinMTiles(temp36)
        //> bcs AwardTouchedCoin        ;if so, branch to some other part of code
        if (flagC) {
            //  goto AwardTouchedCoin -> awardTouchedCoin
            awardTouchedCoin()
            return X
        }
    }
    //> ldy Player_Y_Speed          ;check player's vertical speed
    Y = playerYSpeed
    //> bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
    if (!((Y and 0x80) != 0)) {
        //  goto DoFootCheck -> doFootCheck
        doFootCheck(X)
        return X
    } else {
        //> ldy $04                     ;check lower nybble of vertical coordinate returned
        Y = memory[0x4].toInt()
        //> cpy #$04                    ;from collision detection routine
        //> bcc DoFootCheck             ;if low nybble < 4, branch
        if (!(Y >= 0x04)) {
            //  goto DoFootCheck -> doFootCheck
            doFootCheck(X)
            return X
        }
    }
    //> jsr CheckForSolidMTiles     ;check to see what player's head bumped on
    val flag12: Boolean = checkForSolidMTiles(temp37, X)
    //> bcs SolidOrClimb            ;if player collided with solid metatile, branch
    A = temp37
    if (!flag12) {
        //> ldy AreaType                ;otherwise check area type
        Y = areaType
        //> beq NYSpd                   ;if water level, branch ahead
        if (Y != 0) {
            //> ldy BlockBounceTimer        ;if block bounce timer not expired,
            Y = blockBounceTimer
            //> bne NYSpd                   ;branch ahead, do not process collision
            if (Y == 0) {
                //> jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                temp38 = playerHeadCollision(A)
                X = temp38
                //> jmp DoFootCheck             ;jump ahead to skip these other parts here
                return doFootCheck(temp38)
            }
        }
    }
    //> SolidOrClimb:
    //> cmp #$26               ;if climbing metatile,
    //> beq NYSpd              ;branch ahead and do not play sound
    if (A != 0x26) {
        //> lda #Sfx_Bump
        A = Sfx_Bump
        //> sta Square1SoundQueue  ;otherwise load bump sound
        square1SoundQueue = A
    }
    //> NYSpd: lda #$01               ;set player's vertical speed to nullify
    A = 0x01
    //> sta Player_Y_Speed     ;jump or swim
    playerYSpeed = A
    //  Fall-through tail call to doFootCheck
    return doFootCheck(X)
}

// Decompiled from DoFootCheck
fun doFootCheck(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var exitFlag0: Boolean = false
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var stompChainCounter by MemoryByte(StompChainCounter)
    val areaChangeTimerData by MemoryByteIndexed(AreaChangeTimerData)
    //> DoFootCheck:
    //> ldy $eb                    ;get block buffer adder offset
    Y = memory[0xEB].toInt()
    //> lda Player_Y_Position
    A = playerYPosition
    //> cmp #$cf                   ;check to see how low player is
    //> bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
    X = X
    if (!(A >= 0xCF)) {
        //> jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
        temp0 = blockbuffercolliFeet(Y)
        //> jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
        temp1 = checkForCoinMTiles(temp0)
        //> bcs AwardTouchedCoin       ;if so, branch to some other part of code
        if (flagC) {
            //  goto AwardTouchedCoin -> awardTouchedCoin
            awardTouchedCoin()
            return X
        }
        //> pha                        ;save bottom left metatile to stack
        push(temp1)
        //> jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
        temp2 = blockbuffercolliFeet(Y)
        //> sta $00                    ;save bottom right metatile here
        memory[0x0] = temp2.toUByte()
        //> pla
        A = pull()
        //> sta $01                    ;pull bottom left metatile and save here
        memory[0x1] = A.toUByte()
        //> bne ChkFootMTile           ;if anything here, skip this part
        if (A == 0) {
            //> lda $00                    ;otherwise check for anything in bottom right metatile
            A = memory[0x0].toInt()
            //> beq DoPlayerSideCheck      ;and skip ahead if not
            if (A != 0) {
                //> jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
                temp3 = checkForCoinMTiles(A)
                //> bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
                A = temp3
                if (flagC) {
                    //  Fall-through tail call to awardTouchedCoin
                    return awardTouchedCoin()
                }
            }
        }
        //> ChkFootMTile:
        //> jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
        temp4 = checkForClimbMTiles(A, X)
        //> bcs DoPlayerSideCheck      ;if so, branch
        A = temp4
        if (!flagC) {
            //> ldy Player_Y_Speed         ;check player's vertical speed
            Y = playerYSpeed
            //> bmi DoPlayerSideCheck      ;if player moving upwards, branch
            if ((Y and 0x80) == 0) {
                //> cmp #$c5
                //> bne ContChk                ;if player did not touch axe, skip ahead
                if (A == 0xC5) {
                    //> jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
                    handleAxeMetatile()
                    return X
                }
                //> ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
                val flag0: Boolean = chkInvisibleMTiles(A)
                //> beq DoPlayerSideCheck      ;if either found, branch
                if (A != 0) {
                    //> ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
                    Y = jumpspringAnimCtrl
                    //> bne InitSteP               ;branch ahead
                    if (Y == 0) {
                        //> ldy $04                    ;check lower nybble of vertical coordinate returned
                        Y = memory[0x4].toInt()
                        //> cpy #$05                   ;from collision detection routine
                        //> bcc LandPlyr               ;if lower nybble < 5, branch
                        if (Y >= 0x05) {
                            //> lda Player_MovingDir
                            A = playerMovingdir
                            //> sta $00                    ;use player's moving direction as temp variable
                            memory[0x0] = A.toUByte()
                            //> jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
                            impedePlayerMove()
                            return X
                        }
                        //> LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
                        chkForLandJumpSpring(A)
                        //> lda #$f0
                        A = 0xF0
                        //> and Player_Y_Position      ;mask out lower nybble of player's vertical position
                        A = A and playerYPosition
                        //> sta Player_Y_Position      ;and store as new vertical position to land player properly
                        playerYPosition = A
                        //> jsr HandlePipeEntry        ;do sub to process potential pipe entry
                        handlePipeEntry()
                        //> lda #$00
                        A = 0x00
                        //> sta Player_Y_Speed         ;initialize vertical speed and fractional
                        playerYSpeed = A
                        //> sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
                        playerYMoveforce = A
                        //> sta StompChainCounter      ;initialize enemy stomp counter
                        stompChainCounter = A
                    }
                    //> InitSteP: lda #$00
                    A = 0x00
                    //> sta Player_State           ;set player's state to normal
                    playerState = A
                }
            }
        }
    }
    //> DoPlayerSideCheck:
    //> ldy $eb       ;get block buffer adder offset
    Y = memory[0xEB].toInt()
    //> iny
    Y = (Y + 1) and 0xFF
    //> iny           ;increment offset 2 bytes to use adders for side collisions
    Y = (Y + 1) and 0xFF
    //> lda #$02      ;set value here to be used as counter
    A = 0x02
    //> sta $00
    memory[0x0] = A.toUByte()
    loop0@ do {
        //> SideCheckLoop:
        //> iny                       ;move onto the next one
        Y = (Y + 1) and 0xFF
        //> sty $eb                   ;store it
        memory[0xEB] = Y.toUByte()
        //> lda Player_Y_Position
        A = playerYPosition
        //> cmp #$20                  ;check player's vertical position
        //> bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
        if (A >= 0x20) {
            //> cmp #$e4
            //> bcs ExSCH                 ;branch to leave if player is too far down
            if (!(A >= 0xE4)) {
                //> jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
                temp5 = blockbuffercolliSide(Y)
                //> beq BHalf                 ;branch ahead if nothing found
                A = temp5
                if (temp5 != 0) {
                    //> cmp #$1c                  ;otherwise check for pipe metatiles
                    //> beq BHalf                 ;if collided with sideways pipe (top), branch ahead
                    if (A != 0x1C) {
                        //> cmp #$6b
                        //> beq BHalf                 ;if collided with water pipe (top), branch ahead
                        if (A != 0x6B) {
                            //> jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
                            temp6 = checkForClimbMTiles(A, X)
                            //> bcc CheckSideMTiles       ;if not, branch to alternate section of code
                            if (!(A >= 0x6B)) {
                                //  goto CheckSideMTiles
                                exitFlag0 = true
                                break@loop0
                            }
                        }
                    }
                }
                //> BHalf: ldy $eb                   ;load block adder offset
                Y = memory[0xEB].toInt()
                //> iny                       ;increment it
                Y = (Y + 1) and 0xFF
                //> lda Player_Y_Position     ;get player's vertical position
                A = playerYPosition
                //> cmp #$08
                //> bcc ExSCH                 ;if too high, branch to leave
                if (!(A >= 0x08)) {
                    //  goto ExSCH
                    break@loop0
                }
                //> cmp #$d0
                //> bcs ExSCH                 ;if too low, branch to leave
                if (A >= 0xD0) {
                    //  goto ExSCH
                    break@loop0
                }
                //> jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
                temp7 = blockbuffercolliSide(Y)
                //> bne CheckSideMTiles       ;if something found, branch
                if (!(temp7 == 0)) {
                    //  goto CheckSideMTiles
                    exitFlag0 = true
                    break@loop0
                }
                //> dec $00                   ;otherwise decrement counter
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bne SideCheckLoop         ;run code until both sides of player are checked
                if (!(memory[0x0].toInt() == 0)) {
                    //  continue loop (branch back to SideCheckLoop)
                    continue@loop0
                }
                //> CheckSideMTiles:
                //> jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
                val flag1: Boolean = chkInvisibleMTiles(temp7)
                //> beq ExCSM                  ;branch to leave if either found
                if (temp7 == 0) {
                    //  goto ExCSM -> exCSM
                    exCSM()
                    return X
                }
            } else {
                //> ExSCH: rts                       ;leave
                return X
            }
        }
        //> BHalf: ldy $eb                   ;load block adder offset
        Y = memory[0xEB].toInt()
        //> iny                       ;increment it
        Y = (Y + 1) and 0xFF
        //> lda Player_Y_Position     ;get player's vertical position
        A = playerYPosition
        //> cmp #$08
        //> bcc ExSCH                 ;if too high, branch to leave
        if (A >= 0x08) {
            //> cmp #$d0
            //> bcs ExSCH                 ;if too low, branch to leave
            if (!(A >= 0xD0)) {
                //> jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
                temp8 = blockbuffercolliSide(Y)
                //> bne CheckSideMTiles       ;if something found, branch
                A = temp8
                if (temp8 == 0) {
                    //> dec $00                   ;otherwise decrement counter
                    memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                    //> bne SideCheckLoop         ;run code until both sides of player are checked
                    if (!(memory[0x0].toInt() == 0)) {
                        //  continue loop (branch back to SideCheckLoop)
                        continue@loop0
                    }
                } else {
                    exitFlag0 = true
                    break@loop0
                }
            } else {
                break@loop0
            }
        } else {
            break@loop0
        }
    } while (memory[0x0].toInt() != 0)
    //> ExSCH: rts                       ;leave
    if (exitFlag0) {
        //> CheckSideMTiles:
        //> jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
        val flag2: Boolean = chkInvisibleMTiles(A)
        //> beq ExCSM                  ;branch to leave if either found
        if (A == 0) {
            //  goto ExCSM -> exCSM
            exCSM()
            return X
        } else {
            //> jsr CheckForClimbMTiles    ;check for climbable metatiles
            temp9 = checkForClimbMTiles(A, X)
            //> bcc ContSChk               ;if not found, skip and continue with code
            A = temp9
            if (flag2) {
                //> jmp HandleClimbing         ;otherwise jump to handle climbing
                handleClimbing(A)
                return X
            }
        }
        //> ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
        temp10 = checkForCoinMTiles(A)
        //> bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
        if (flag2) {
            //  goto HandleCoinMetatile -> handleCoinMetatile
            handleCoinMetatile()
            return X
        } else {
            //> jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
            val flag3: Boolean = chkJumpspringMetatiles(temp10)
            //> bcc ChkPBtm                ;if not found, branch ahead to continue cude
            A = temp10
            if (flag3) {
                //> lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
                A = jumpspringAnimCtrl
                //> bne ExCSM                  ;branch to leave if set
                if (!(A == 0)) {
                    //  goto ExCSM -> exCSM
                    exCSM()
                    return X
                }
                //> jmp StopPlayerMove         ;otherwise jump to impede player's movement
                stopPlayerMove()
                return X
            }
        }
        //> ChkPBtm:  ldy Player_State           ;get player's state
        Y = playerState
        //> cpy #$00                   ;check for player's state set to normal
        //> bne StopPlayerMove         ;if not, branch to impede player's movement
        if (!(Y == 0x00)) {
            //  goto StopPlayerMove -> stopPlayerMove
            stopPlayerMove()
            return X
        } else {
            //> ldy PlayerFacingDir        ;get player's facing direction
            Y = playerFacingDir
            //> dey
            Y = (Y - 1) and 0xFF
            //> bne StopPlayerMove         ;if facing left, branch to impede movement
            if (!(Y == 0)) {
                //  goto StopPlayerMove -> stopPlayerMove
                stopPlayerMove()
                return X
            }
        }
        //> cmp #$6c                   ;otherwise check for pipe metatiles
        //> beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
        if (A != 0x6C) {
            //> cmp #$1f                   ;if collided with water pipe (bottom), continue
            //> bne StopPlayerMove         ;otherwise branch to impede player's movement
            if (!(A == 0x1F)) {
                //  goto StopPlayerMove -> stopPlayerMove
                stopPlayerMove()
                return X
            }
        }
        //> PipeDwnS: lda Player_SprAttrib       ;check player's attributes
        A = playerSprattrib
        //> bne PlyrPipe               ;if already set, branch, do not play sound again
        if (A == 0) {
            //> ldy #Sfx_PipeDown_Injury
            Y = Sfx_PipeDown_Injury
            //> sty Square1SoundQueue      ;otherwise load pipedown/injury sound
            square1SoundQueue = Y
        }
        //> PlyrPipe: ora #%00100000
        A = A or 0x20
        //> sta Player_SprAttrib       ;set background priority bit in player attributes
        playerSprattrib = A
        //> lda Player_X_Position
        A = playerXPosition
        //> and #%00001111             ;get lower nybble of player's horizontal coordinate
        A = A and 0x0F
        //> beq ChkGERtn               ;if at zero, branch ahead to skip this part
        if (A != 0) {
            //> ldy #$00                   ;set default offset for timer setting data
            Y = 0x00
            //> lda ScreenLeft_PageLoc     ;load page location for left side of screen
            A = screenleftPageloc
            //> beq SetCATmr               ;if at page zero, use default offset
            if (A != 0) {
                //> iny                        ;otherwise increment offset
                Y = (Y + 1) and 0xFF
            }
            //> SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
            A = areaChangeTimerData[Y]
            //> sta ChangeAreaTimer
            changeAreaTimer = A
        }
        //> ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
        A = gameEngineSubroutine
        //> cmp #$07
        //> beq ExCSM                  ;if running player entrance routine or
        if (A == 0x07) {
            //  goto ExCSM -> exCSM
            exCSM()
            return X
        } else {
            //> cmp #$08                   ;player control routine, go ahead and branch to leave
            //> bne ExCSM
            if (!(A == 0x08)) {
                //  goto ExCSM -> exCSM
                exCSM()
                return X
            }
        }
        //> lda #$02
        A = 0x02
        //> sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
        gameEngineSubroutine = A
        //> rts                        ;and leave
        return X
    }
    return X
}

// Decompiled from AwardTouchedCoin
fun awardTouchedCoin(): Int {
    var X: Int = 0
    //> AwardTouchedCoin:
    //> jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
    return handleCoinMetatile()
}

// Decompiled from StopPlayerMove
fun stopPlayerMove() {
    //> StopPlayerMove:
    //> jsr ImpedePlayerMove      ;stop player's movement
    impedePlayerMove()
    //  Fall-through tail call to exCSM
    exCSM()
    return
}

// Decompiled from ExCSM
fun exCSM() {
    //> ExCSM: rts                       ;leave
    return
}

// Decompiled from HandleCoinMetatile
fun handleCoinMetatile(): Int {
    var X: Int = 0
    var coinTallyFor1Ups by MemoryByte(CoinTallyFor1Ups)
    //> HandleCoinMetatile:
    //> jsr ErACM             ;do sub to erase coin metatile from block buffer
    erACM()
    //> inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
    coinTallyFor1Ups = (coinTallyFor1Ups + 1) and 0xFF
    //> jmp GiveOneCoin       ;update coin amount and tally on the screen
    return giveOneCoin()
}

// Decompiled from HandleAxeMetatile
fun handleAxeMetatile() {
    var A: Int = 0
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> HandleAxeMetatile:
    //> lda #$00
    A = 0x00
    //> sta OperMode_Task   ;reset secondary mode
    opermodeTask = A
    //> lda #$02
    A = 0x02
    //> sta OperMode        ;set primary mode to autoctrl mode
    operMode = A
    //> lda #$18
    A = 0x18
    //> sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
    playerXSpeed = A
    //  Fall-through tail call to erACM
    erACM()
    return
}

// Decompiled from ErACM
fun erACM() {
    var A: Int = 0
    var Y: Int = 0
    //> ErACM: ldy $02             ;load vertical high nybble offset for block buffer
    Y = memory[0x2].toInt()
    //> lda #$00            ;load blank metatile
    A = 0x00
    //> sta ($06),y         ;store to remove old contents from block buffer
    memory[readWord(0x6) + Y] = A.toUByte()
    //> jmp RemoveCoin_Axe  ;update the screen accordingly
    removecoinAxe()
    return
}

// Decompiled from HandleClimbing
fun handleClimbing(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var flagpoleCollisionYPos by MemoryByte(FlagpoleCollisionYPos)
    var flagpoleScore by MemoryByte(FlagpoleScore)
    var flagpoleSoundQueue by MemoryByte(FlagpoleSoundQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var scrollLock by MemoryByte(ScrollLock)
    val flagpoleYPosData by MemoryByteIndexed(FlagpoleYPosData)
    //> HandleClimbing:
    //> ldy $04            ;check low nybble of horizontal coordinate returned from
    Y = memory[0x4].toInt()
    //> cpy #$06           ;collision detection routine against certain values, this
    //> bcc ExHC           ;makes actual physical part of vine or flagpole thinner
    A = A
    if (Y >= 0x06) {
        //> cpy #$0a           ;than 16 pixels
        //> bcc ChkForFlagpole
        if (!(Y >= 0x0A)) {
            //  goto ChkForFlagpole (internal forward branch)
            //> ChkForFlagpole:
            //> cmp #$24               ;check climbing metatiles
            //> beq FlagpoleCollision  ;branch if flagpole ball found
            if (A == 0x24) {
                //  goto FlagpoleCollision (internal forward branch)
                //> FlagpoleCollision:
                //> lda GameEngineSubroutine
                A = gameEngineSubroutine
                //> cmp #$05                  ;check for end-of-level routine running
                //> beq PutPlayerOnVine       ;if running, branch to end of climbing code
                if (A == 0x05) {
                    //  goto PutPlayerOnVine -> putPlayerOnVine
                    putPlayerOnVine()
                    return
                }
                //> lda #$01
                A = 0x01
                //> sta PlayerFacingDir       ;set player's facing direction to right
                playerFacingDir = A
                //> inc ScrollLock            ;set scroll lock flag
                scrollLock = (scrollLock + 1) and 0xFF
                //> lda GameEngineSubroutine
                A = gameEngineSubroutine
                //> cmp #$04                  ;check for flagpole slide routine running
                //> beq RunFR                 ;if running, branch to end of flagpole code here
                if (A == 0x04) {
                    //  goto RunFR (internal forward branch)
                    //> RunFR: lda #$04
                    A = 0x04
                    //> sta GameEngineSubroutine  ;set value to run flagpole slide routine
                    gameEngineSubroutine = A
                    //> jmp PutPlayerOnVine       ;jump to end of climbing code
                    putPlayerOnVine()
                    return
                }
                //> lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
                A = BulletBill_CannonVar
                //> jsr KillEnemies           ;get rid of them
                killEnemies(A)
                //> lda #Silence
                A = Silence
                //> sta EventMusicQueue       ;silence music
                eventMusicQueue = A
                //> lsr
                val orig0: Int = A
                A = orig0 shr 1
                //> sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
                flagpoleSoundQueue = A
                //> ldx #$04                  ;start at end of vertical coordinate data
                X = 0x04
                //> lda Player_Y_Position
                A = playerYPosition
                //> sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
                flagpoleCollisionYPos = A
                return
            }
            //> cmp #$25
            //> bne VineCollision      ;branch to alternate code if flagpole shaft not found
            if (!(A == 0x25)) {
                //  goto VineCollision (internal forward branch)
                //> VineCollision:
                //> cmp #$26                  ;check for climbing metatile used on vines
                //> bne PutPlayerOnVine
                if (!(A == 0x26)) {
                    //  goto PutPlayerOnVine -> putPlayerOnVine
                    putPlayerOnVine()
                    return
                }
                //> lda Player_Y_Position     ;check player's vertical coordinate
                A = playerYPosition
                //> cmp #$20                  ;for being in status bar area
                //> bcs PutPlayerOnVine       ;branch if not that far up
                if (A >= 0x20) {
                    //  goto PutPlayerOnVine -> putPlayerOnVine
                    putPlayerOnVine()
                    return
                }
                //> lda #$01
                A = 0x01
                //> sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
                gameEngineSubroutine = A
                //  Fall-through tail call to putPlayerOnVine
                putPlayerOnVine()
                return
            }
            return
        }
    } else {
        //> ExHC: rts                ;leave if too far left or too far right
        return
    }
    //> cmp #$25
    //> bne VineCollision      ;branch to alternate code if flagpole shaft not found
    if (A == 0x25) {
        //> FlagpoleCollision:
        //> lda GameEngineSubroutine
        A = gameEngineSubroutine
        //> cmp #$05                  ;check for end-of-level routine running
        //> beq PutPlayerOnVine       ;if running, branch to end of climbing code
        if (A == 0x05) {
            //  goto PutPlayerOnVine -> putPlayerOnVine
            putPlayerOnVine()
            return
        }
        //> lda #$01
        A = 0x01
        //> sta PlayerFacingDir       ;set player's facing direction to right
        playerFacingDir = A
        //> inc ScrollLock            ;set scroll lock flag
        scrollLock = (scrollLock + 1) and 0xFF
        //> lda GameEngineSubroutine
        A = gameEngineSubroutine
        //> cmp #$04                  ;check for flagpole slide routine running
        //> beq RunFR                 ;if running, branch to end of flagpole code here
        if (A != 0x04) {
            //> lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
            A = BulletBill_CannonVar
            //> jsr KillEnemies           ;get rid of them
            killEnemies(A)
            //> lda #Silence
            A = Silence
            //> sta EventMusicQueue       ;silence music
            eventMusicQueue = A
            //> lsr
            val orig1: Int = A
            A = orig1 shr 1
            //> sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
            flagpoleSoundQueue = A
            //> ldx #$04                  ;start at end of vertical coordinate data
            X = 0x04
            //> lda Player_Y_Position
            A = playerYPosition
            //> sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
            flagpoleCollisionYPos = A
            loop0@ while ((orig1 and 0x01) == 0) {
                //> dex                       ;otherwise decrement offset to use
                X = (X - 1) and 0xFF
                //> bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
                if (!(X == 0)) {
                    //  continue loop (branch back to ChkFlagpoleYPosLoop)
                    continue@loop0
                }
            }
            //> MtchF: stx FlagpoleScore         ;store offset here to be used later
            flagpoleScore = X
        }
        //> RunFR: lda #$04
        A = 0x04
        //> sta GameEngineSubroutine  ;set value to run flagpole slide routine
        gameEngineSubroutine = A
        //> jmp PutPlayerOnVine       ;jump to end of climbing code
        putPlayerOnVine()
        return
    } else {
        //> VineCollision:
        //> cmp #$26                  ;check for climbing metatile used on vines
        //> bne PutPlayerOnVine
        if (!(A == 0x26)) {
            //  goto PutPlayerOnVine -> putPlayerOnVine
            putPlayerOnVine()
            return
        }
    }
    //> lda Player_Y_Position     ;check player's vertical coordinate
    A = playerYPosition
    //> cmp #$20                  ;for being in status bar area
    //> bcs PutPlayerOnVine       ;branch if not that far up
    if (A >= 0x20) {
        //  goto PutPlayerOnVine -> putPlayerOnVine
        putPlayerOnVine()
        return
    } else {
        //> lda #$01
        A = 0x01
        //> sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
        gameEngineSubroutine = A
        //  Fall-through tail call to putPlayerOnVine
        putPlayerOnVine()
        return
    }
}

// Decompiled from PutPlayerOnVine
fun putPlayerOnVine() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerState by MemoryByte(Player_State)
    var playerXMoveforce by MemoryByte(Player_X_MoveForce)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    val climbPLocAdder by MemoryByteIndexed(ClimbPLocAdder)
    val climbXPosAdder by MemoryByteIndexed(ClimbXPosAdder)
    //> PutPlayerOnVine:
    //> lda #$03                ;set player state to climbing
    A = 0x03
    //> sta Player_State
    playerState = A
    //> lda #$00                ;nullify player's horizontal speed
    A = 0x00
    //> sta Player_X_Speed      ;and fractional horizontal movement force
    playerXSpeed = A
    //> sta Player_X_MoveForce
    playerXMoveforce = A
    //> lda Player_X_Position   ;get player's horizontal coordinate
    A = playerXPosition
    //> sec
    //> sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
    temp0 = A - screenleftXPos
    A = temp0 and 0xFF
    //> cmp #$10
    //> bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
    if (!(A >= 0x10)) {
        //> lda #$02
        A = 0x02
        //> sta PlayerFacingDir     ;otherwise force player to face left
        playerFacingDir = A
    }
    //> SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
    Y = playerFacingDir
    //> lda $06                 ;get low byte of block buffer address
    A = memory[0x6].toInt()
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                     ;move low nybble to high
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> clc
    //> adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
    temp1 = A + climbXPosAdder[-1 + Y]
    A = temp1 and 0xFF
    //> sta Player_X_Position   ;store as player's horizontal coordinate
    playerXPosition = A
    //> lda $06                 ;get low byte of block buffer address again
    A = memory[0x6].toInt()
    //> bne ExPVne              ;if not zero, branch
    if (A == 0) {
        //> lda ScreenRight_PageLoc ;load page location of right side of screen
        A = screenrightPageloc
        //> clc
        //> adc ClimbPLocAdder-1,y  ;add depending on facing location
        temp2 = A + climbPLocAdder[-1 + Y]
        A = temp2 and 0xFF
        //> sta Player_PageLoc      ;store as player's page location
        playerPageloc = A
    }
    //> ExPVne:  rts                     ;finally, we're done!
    return
}

// Decompiled from ChkInvisibleMTiles
fun chkInvisibleMTiles(A: Int): Boolean {
    var A: Int = A
    //> ChkInvisibleMTiles:
    //> cmp #$5f       ;check for hidden coin block
    //> beq ExCInvT    ;branch to leave if found
    A = A
    if (A != 0x5F) {
        //> cmp #$60       ;check for hidden 1-up block
    }
    //> ExCInvT: rts            ;leave with zero flag set if either found
    return false
}

// Decompiled from ChkForLandJumpSpring
fun chkForLandJumpSpring(A: Int) {
    var A: Int = A
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var jumpspringForce by MemoryByte(JumpspringForce)
    var jumpspringTimer by MemoryByte(JumpspringTimer)
    var verticalForce by MemoryByte(VerticalForce)
    //> ChkForLandJumpSpring:
    //> jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
    val flag0: Boolean = chkJumpspringMetatiles(A)
    //> bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
    A = A
    if (flag0) {
        //> lda #$70
        A = 0x70
        //> sta VerticalForce           ;otherwise set vertical movement force for player
        verticalForce = A
        //> lda #$f9
        A = 0xF9
        //> sta JumpspringForce         ;set default jumpspring force
        jumpspringForce = A
        //> lda #$03
        A = 0x03
        //> sta JumpspringTimer         ;set jumpspring timer to be used later
        jumpspringTimer = A
        //> lsr
        val orig1: Int = A
        A = orig1 shr 1
        //> sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
        jumpspringAnimCtrl = A
    }
    //> ExCJSp: rts                         ;and leave
    return
}

// Decompiled from ChkJumpspringMetatiles
fun chkJumpspringMetatiles(A: Int): Boolean {
    var A: Int = A
    //> ChkJumpspringMetatiles:
    //> cmp #$67      ;check for top jumpspring metatile
    //> beq JSFnd     ;branch to set carry if found
    A = A
    if (A != 0x67) {
        //> cmp #$68      ;check for bottom jumpspring metatile
        //> clc           ;clear carry flag
        //> bne NoJSFnd   ;branch to use cleared carry if not found
        if (!(A == 0x68)) {
            //  goto NoJSFnd (internal forward branch)
            //> NoJSFnd: rts           ;leave
            return false
        }
    }
    //> JSFnd:   sec           ;set carry if found
    //> NoJSFnd: rts           ;leave
    return true
}

// Decompiled from HandlePipeEntry
fun handlePipeEntry() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaNumber by MemoryByte(AreaNumber)
    var areaPointer by MemoryByte(AreaPointer)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    var entrancePage by MemoryByte(EntrancePage)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    var levelNumber by MemoryByte(LevelNumber)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerXPosition by MemoryByte(Player_X_Position)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    var worldNumber by MemoryByte(WorldNumber)
    val areaAddrOffsets by MemoryByteIndexed(AreaAddrOffsets)
    val warpZoneNumbers by MemoryByteIndexed(WarpZoneNumbers)
    val worldAddrOffsets by MemoryByteIndexed(WorldAddrOffsets)
    //> HandlePipeEntry:
    //> lda Up_Down_Buttons       ;check saved controller bits from earlier
    A = upDownButtons
    //> and #%00000100            ;for pressing down
    A = A and 0x04
    //> beq ExPipeE               ;if not pressing down, branch to leave
    if (A != 0) {
        //> lda $00
        A = memory[0x0].toInt()
        //> cmp #$11                  ;check right foot metatile for warp pipe right metatile
        //> bne ExPipeE               ;branch to leave if not found
        if (A == 0x11) {
            //> lda $01
            A = memory[0x1].toInt()
            //> cmp #$10                  ;check left foot metatile for warp pipe left metatile
            //> bne ExPipeE               ;branch to leave if not found
            if (A == 0x10) {
                //> lda #$30
                A = 0x30
                //> sta ChangeAreaTimer       ;set timer for change of area
                changeAreaTimer = A
                //> lda #$03
                A = 0x03
                //> sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
                gameEngineSubroutine = A
                //> lda #Sfx_PipeDown_Injury
                A = Sfx_PipeDown_Injury
                //> sta Square1SoundQueue     ;load pipedown/injury sound
                square1SoundQueue = A
                //> lda #%00100000
                A = 0x20
                //> sta Player_SprAttrib      ;set background priority bit in player's attributes
                playerSprattrib = A
                //> lda WarpZoneControl       ;check warp zone control
                A = warpZoneControl
                //> beq ExPipeE               ;branch to leave if none found
                if (A != 0) {
                    //> and #%00000011            ;mask out all but 2 LSB
                    A = A and 0x03
                    //> asl
                    val orig0: Int = A
                    A = (orig0 shl 1) and 0xFF
                    //> asl                       ;multiply by four
                    val orig1: Int = A
                    A = (orig1 shl 1) and 0xFF
                    //> tax                       ;save as offset to warp zone numbers (starts at left pipe)
                    X = A
                    //> lda Player_X_Position     ;get player's horizontal position
                    A = playerXPosition
                    //> cmp #$60
                    //> bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
                    X = X
                    if (A >= 0x60) {
                        //> inx                       ;otherwise increment for middle pipe
                        X = (X + 1) and 0xFF
                        //> cmp #$a0
                        //> bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
                        if (A >= 0xA0) {
                            //> inx                       ;otherwise increment for last pipe
                            X = (X + 1) and 0xFF
                        }
                    }
                    //> GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
                    Y = warpZoneNumbers[X]
                    //> dey                       ;decrement for use as world number
                    Y = (Y - 1) and 0xFF
                    //> sty WorldNumber           ;store as world number and offset
                    worldNumber = Y
                    //> ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
                    X = worldAddrOffsets[Y]
                    //> lda AreaAddrOffsets,x     ;get area offset based on world offset
                    A = areaAddrOffsets[X]
                    //> sta AreaPointer           ;store area offset here to be used to change areas
                    areaPointer = A
                    //> lda #Silence
                    A = Silence
                    //> sta EventMusicQueue       ;silence music
                    eventMusicQueue = A
                    //> lda #$00
                    A = 0x00
                    //> sta EntrancePage          ;initialize starting page number
                    entrancePage = A
                    //> sta AreaNumber            ;initialize area number used for area address offset
                    areaNumber = A
                    //> sta LevelNumber           ;initialize level number used for world display
                    levelNumber = A
                    //> sta AltEntranceControl    ;initialize mode of entry
                    altEntranceControl = A
                    //> inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
                    hidden1UpFlag = (hidden1UpFlag + 1) and 0xFF
                    //> inc FetchNewGameTimerFlag ;set flag to load new game timer
                    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
                }
            }
        }
    }
    //> ExPipeE: rts                       ;leave!!!
    return
}

// Decompiled from ImpedePlayerMove
fun impedePlayerMove() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> ImpedePlayerMove:
    //> lda #$00                  ;initialize value here
    A = 0x00
    //> ldy Player_X_Speed        ;get player's horizontal speed
    Y = playerXSpeed
    //> ldx $00                   ;check value set earlier for
    X = memory[0x0].toInt()
    //> dex                       ;left side collision
    X = (X - 1) and 0xFF
    //> bne RImpd                 ;if right side collision, skip this part
    if (X == 0) {
        //> inx                       ;return value to X
        X = (X + 1) and 0xFF
        //> cpy #$00                  ;if player moving to the left,
        //> bmi ExIPM                 ;branch to invert bit and leave
        if (((Y) and 0xFF and 0x80) != 0) {
            //  goto ExIPM -> exIPM
            exIPM(X)
            return
        }
        //> lda #$ff                  ;otherwise load A with value to be used later
        A = 0xFF
        //> jmp NXSpd                 ;and jump to affect movement
        nXSpd(A, X)
        return
    } else {
        //> RImpd: ldx #$02                  ;return $02 to X
        X = 0x02
        //> cpy #$01                  ;if player moving to the right,
        //> bpl ExIPM                 ;branch to invert bit and leave
        if (!(((Y - 0x01) and 0xFF and 0x80) != 0)) {
            //  goto ExIPM -> exIPM
            exIPM(X)
            return
        }
    }
    //> lda #$01                  ;otherwise load A with value to be used here
    A = 0x01
    //  Fall-through tail call to nXSpd
    nXSpd(A, X)
    return
}

// Decompiled from NXSpd
fun nXSpd(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var sideCollisionTimer by MemoryByte(SideCollisionTimer)
    //> NXSpd: ldy #$10
    Y = 0x10
    //> sty SideCollisionTimer    ;set timer of some sort
    sideCollisionTimer = Y
    //> ldy #$00
    Y = 0x00
    //> sty Player_X_Speed        ;nullify player's horizontal speed
    playerXSpeed = Y
    //> cmp #$00                  ;if value set in A not set to $ff,
    //> bpl PlatF                 ;branch ahead, do not decrement Y
    A = A
    X = X
    if ((A and 0xFF and 0x80) != 0) {
        //> dey                       ;otherwise decrement Y now
        Y = (Y - 1) and 0xFF
    }
    //> PlatF: sty $00                   ;store Y as high bits of horizontal adder
    memory[0x0] = Y.toUByte()
    //> clc
    //> adc Player_X_Position     ;add contents of A to player's horizontal
    temp0 = A + playerXPosition
    A = temp0 and 0xFF
    //> sta Player_X_Position     ;position to move player left or right
    playerXPosition = A
    //> lda Player_PageLoc
    A = playerPageloc
    //> adc $00                   ;add high bits and carry to
    temp1 = A + memory[0x0].toInt() + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta Player_PageLoc        ;page location if necessary
    playerPageloc = A
    //  Fall-through tail call to exIPM
    exIPM(X)
    return
}

// Decompiled from ExIPM
fun exIPM(X: Int) {
    var A: Int = 0
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    //> ExIPM: txa                       ;invert contents of X
    A = X
    //> eor #$ff
    A = A xor 0xFF
    //> and Player_CollisionBits  ;mask out bit that was set here
    A = A and playerCollisionbits
    //> sta Player_CollisionBits  ;store to clear bit
    playerCollisionbits = A
    //> rts
    return
}

// Decompiled from CheckForSolidMTiles
fun checkForSolidMTiles(A: Int, X: Int): Boolean {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    val solidMTileUpperExt by MemoryByteIndexed(SolidMTileUpperExt)
    //> CheckForSolidMTiles:
    //> jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
    val pair0 = getMTileAttrib(A)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
    //> rts
    return temp0 >= solidMTileUpperExt[X]
}

// Decompiled from CheckForClimbMTiles
fun checkForClimbMTiles(A: Int, X: Int): Int {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    val climbMTileUpperExt by MemoryByteIndexed(ClimbMTileUpperExt)
    //> CheckForClimbMTiles:
    //> jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
    val pair0 = getMTileAttrib(A)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
    //> rts
    return temp0
}

// Decompiled from CheckForCoinMTiles
fun checkForCoinMTiles(A: Int): Int {
    var A: Int = A
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    //> CheckForCoinMTiles:
    //> cmp #$c2              ;check for regular coin
    //> beq CoinSd            ;branch if found
    A = A
    if (A != 0xC2) {
        //> cmp #$c3              ;check for underwater coin
        //> beq CoinSd            ;branch if found
        if (A != 0xC3) {
            //> clc                   ;otherwise clear carry and leave
            //> rts
            return A
        }
    }
    //> CoinSd:  lda #Sfx_CoinGrab
    A = Sfx_CoinGrab
    //> sta Square2SoundQueue ;load coin grab sound and leave
    square2SoundQueue = A
    //> rts
    return A
}

// Decompiled from GetMTileAttrib
fun getMTileAttrib(A: Int): Pair<Int, Int> {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    //> GetMTileAttrib:
    //> tay            ;save metatile value into Y
    Y = A
    //> and #%11000000 ;mask out all but 2 MSB
    A = A and 0xC0
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> rol            ;shift and rotate d7-d6 to d1-d0
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFE or if ((orig0 and 0x80) != 0) 1 else 0
    //> rol
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x80) != 0) 1 else 0
    //> tax            ;use as offset for metatile data
    X = A
    //> tya            ;get original metatile value back
    A = Y
    //  Fall-through tail call to exEBG
    exEBG()
    return Pair(A, X)
}

// Decompiled from ExEBG
fun exEBG() {
    //> ExEBG: rts            ;leave
    return
}

// Decompiled from EnemyToBGCollisionDet
fun enemyToBGCollisionDet(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> EnemyToBGCollisionDet:
    //> lda Enemy_State,x        ;check enemy state for d6 set
    A = enemyState[X]
    //> and #%00100000
    A = A and 0x20
    //> bne ExEBG                ;if set, branch to leave
    X = X
    if (A != 0) {
        //> ExEBG: rts            ;leave
        return Pair(X, Y)
    } else {
        //> jsr SubtEnemyYPos        ;otherwise, do a subroutine here
        val flag0: Boolean = subtEnemyYPos(X)
        //> bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
        if (!flag0) {
            //> ExEBG: rts            ;leave
            return Pair(X, Y)
        }
    }
    //> ldy Enemy_ID,x
    Y = enemyId[X]
    //> cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
    //> bne DoIDCheckBGColl
    if (Y == Spiny) {
        //> lda Enemy_Y_Position,x
        A = enemyYPosition[X]
        //> cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
        //> bcc ExEBG
        if (!(A >= 0x25)) {
            //> ExEBG: rts            ;leave
            return Pair(X, Y)
        }
    }
    //> DoIDCheckBGColl:
    //> cpy #GreenParatroopaJump ;check for some other enemy object
    //> bne HBChk                ;branch if not found
    if (Y == GreenParatroopaJump) {
        //> jmp EnemyJump            ;otherwise jump elsewhere
        return enemyJump(X, Y)
    } else {
        //> HBChk: cpy #HammerBro           ;check for hammer bro
        //> bne CInvu                ;branch if not found
        if (Y == HammerBro) {
            //> jmp HammerBroBGColl      ;otherwise jump elsewhere
            return hammerBroBGColl(A, X)
        }
    }
    //> CInvu: cpy #Spiny               ;if enemy object is spiny, branch
    //> beq YesIn
    if (Y != Spiny) {
        //> cpy #PowerUpObject       ;if special power-up object, branch
        //> beq YesIn
        if (Y != PowerUpObject) {
            //> cpy #$07                 ;if enemy object =>$07, branch to leave
            //> bcs ExEBGChk
            if (Y >= 0x07) {
                //  goto ExEBGChk -> exEBGChk
                exEBGChk()
                return Pair(X, Y)
            }
        }
    }
    //> YesIn: jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
    val pair0 = chkUnderEnemy(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> bne HandleEToBGCollision ;if block underneath enemy, branch
    A = temp0
    Y = temp1
    if (temp0 == 0) {
        //> NoEToBGCollision:
        //> jmp ChkForRedKoopa       ;otherwise skip and do something else
        return chkForRedKoopa(X)
    } else {
        //> HandleEToBGCollision:
        //> jsr ChkForNonSolids       ;if something is underneath enemy, find out what
        chkForNonSolids(A)
        //> beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
        if (A == 0) {
            //> NoEToBGCollision:
            //> jmp ChkForRedKoopa       ;otherwise skip and do something else
            return chkForRedKoopa(X)
        }
    }
    //> cmp #$23
    //> bne LandEnemyProperly     ;check for blank metatile $23 and branch if not found
    if (A == 0x23) {
        //> ldy $02                   ;get vertical coordinate used to find block
        Y = memory[0x2].toInt()
        //> lda #$00                  ;store default blank metatile in that spot so we won't
        A = 0x00
        //> sta ($06),y               ;trigger this routine accidentally again
        memory[readWord(0x6) + Y] = A.toUByte()
        //> lda Enemy_ID,x
        A = enemyId[X]
        //> cmp #$15                  ;if enemy object => $15, branch ahead
        //> bcs ChkToStunEnemies
        if (A >= 0x15) {
            //  goto ChkToStunEnemies -> chkToStunEnemies
            chkToStunEnemies(A, X)
            return Pair(X, Y)
        }
        //> cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
        //> bne GiveOEPoints
        if (A == Goomba) {
            //> jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
            killEnemyAboveBlock(X)
        }
        //> GiveOEPoints:
        //> lda #$01                  ;award 100 points for hitting block beneath enemy
        A = 0x01
        //> jsr SetupFloateyNumber
        temp2 = setupFloateyNumber(A, X)
        //  Fall-through tail call to chkToStunEnemies
        chkToStunEnemies(temp2, X)
        return Pair(X, Y)
    } else {
        //> LandEnemyProperly:
        //> lda $04                 ;check lower nybble of vertical coordinate saved earlier
        A = memory[0x4].toInt()
        //> sec
        //> sbc #$08                ;subtract eight pixels
        temp3 = A - 0x08
        A = temp3 and 0xFF
        //> cmp #$05                ;used to determine whether enemy landed from falling
        //> bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
        if (A >= 0x05) {
            //  goto ChkForRedKoopa -> chkForRedKoopa
            chkForRedKoopa(X)
            return Pair(X, Y)
        }
    }
    //> lda Enemy_State,x
    A = enemyState[X]
    //> and #%01000000          ;branch if d6 in enemy state is set
    A = A and 0x40
    //> bne LandEnemyInitState
    if (A == 0) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> asl                     ;branch if d7 in enemy state is not set
        val orig1: Int = A
        A = (orig1 shl 1) and 0xFF
        //> bcc ChkLandedEnemyState
        if ((orig1 and 0x80) != 0) {
            //> SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
            return doEnemySideCheck(X)
        }
        //> ChkLandedEnemyState:
        //> lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
        A = enemyState[X]
        //> beq SChkA
        if (A == 0) {
            //> SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
            return doEnemySideCheck(X)
        }
        //> cmp #$05                  ;if in state used by spiny's egg
        //> beq ProcEnemyDirection    ;then branch elsewhere
        if (A != 0x05) {
            //> cmp #$03                  ;if already in state used by koopas and buzzy beetles
            //> bcs ExSteChk              ;or in higher numbered state, branch to leave
            if (!(A >= 0x03)) {
                //> lda Enemy_State,x         ;load enemy state again (why?)
                A = enemyState[X]
                //> cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
                //> bne ProcEnemyDirection    ;then branch elsewhere
                if (A == 0x02) {
                    //> lda #$10                  ;load default timer here
                    A = 0x10
                    //> ldy Enemy_ID,x            ;check enemy identifier for spiny
                    Y = enemyId[X]
                    //> cpy #Spiny
                    //> bne SetForStn             ;branch if not found
                    if (Y == Spiny) {
                        //> lda #$00                  ;set timer for $00 if spiny
                        A = 0x00
                    }
                    //> SetForStn: sta EnemyIntervalTimer,x  ;set timer here
                    enemyIntervalTimer[X] = A
                    //> lda #$03                  ;set state here, apparently used to render
                    A = 0x03
                    //> sta Enemy_State,x         ;upside-down koopas and buzzy beetles
                    enemyState[X] = A
                    //> jsr EnemyLanding          ;then land it properly
                    enemyLanding(X)
                }
            }
            //> ExSteChk:  rts                       ;then leave
            return Pair(X, Y)
        }
        //> ProcEnemyDirection:
        //> lda Enemy_ID,x            ;check enemy identifier for goomba
        A = enemyId[X]
        //> cmp #Goomba               ;branch if found
        //> beq LandEnemyInitState
        if (A != Goomba) {
            //> cmp #Spiny                ;check for spiny
            //> bne InvtD                 ;branch if not found
            if (A == Spiny) {
                //> lda #$01
                A = 0x01
                //> sta Enemy_MovingDir,x     ;send enemy moving to the right by default
                enemyMovingdir[X] = A
                //> lda #$08
                A = 0x08
                //> sta Enemy_X_Speed,x       ;set horizontal speed accordingly
                enemyXSpeed[X] = A
                //> lda FrameCounter
                A = frameCounter
                //> and #%00000111            ;if timed appropriately, spiny will skip over
                A = A and 0x07
                //> beq LandEnemyInitState    ;trying to face the player
                if (A == 0) {
                    //  goto LandEnemyInitState (internal forward branch)
                    //> LandEnemyInitState:
                    //> jsr EnemyLanding       ;land enemy properly
                    enemyLanding(X)
                    //> lda Enemy_State,x
                    A = enemyState[X]
                    //> and #%10000000         ;if d7 of enemy state is set, branch
                    A = A and 0x80
                    //> bne NMovShellFallBit
                    if (!(A == 0)) {
                        //  goto NMovShellFallBit (internal forward branch)
                        //> NMovShellFallBit:
                        //> lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
                        A = enemyState[X]
                        //> and #%10111111      ;and store, then leave
                        A = A and 0xBF
                        //> sta Enemy_State,x
                        enemyState[X] = A
                        //> rts
                        return Pair(X, Y)
                    }
                    //> lda #$00               ;otherwise initialize enemy state and leave
                    A = 0x00
                    //> sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
                    enemyState[X] = A
                    //> rts
                    return Pair(X, Y)
                }
            }
            //> InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
            Y = 0x01
            //> jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
            val flag2: Boolean = playerEnemyDiff(X)
            //> bpl CNwCDir               ;if enemy to the right of player, branch
            if ((A and 0x80) != 0) {
                //> iny                       ;if to the left, increment by one for enemy to face right (inverted)
                Y = (Y + 1) and 0xFF
            }
            //> CNwCDir: tya
            A = Y
            //> cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
            //> bne LandEnemyInitState
            if (A == enemyMovingdir[X]) {
                //> jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
                val pair1 = chkforbumpHammerbroj(X)
                temp4 = pair1.first
                temp5 = pair1.second
                X = temp5
            }
        }
    }
    //> LandEnemyInitState:
    //> jsr EnemyLanding       ;land enemy properly
    enemyLanding(X)
    //> lda Enemy_State,x
    A = enemyState[X]
    //> and #%10000000         ;if d7 of enemy state is set, branch
    A = A and 0x80
    //> bne NMovShellFallBit
    if (A == 0) {
        //> lda #$00               ;otherwise initialize enemy state and leave
        A = 0x00
        //> sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
        enemyState[X] = A
        //> rts
        return Pair(X, Y)
    } else {
        //> NMovShellFallBit:
        //> lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
        A = enemyState[X]
        //> and #%10111111      ;and store, then leave
        A = A and 0xBF
        //> sta Enemy_State,x
        enemyState[X] = A
        //> rts
        return Pair(X, Y)
    }
}

// Decompiled from ChkToStunEnemies
fun chkToStunEnemies(A: Int, X: Int) {
    var A: Int = A
    var X: Int = X
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> ChkToStunEnemies:
    //> cmp #$09                   ;perform many comparisons on enemy object identifier
    //> bcc SetStun
    if (!(A >= 0x09)) {
        //  goto SetStun -> setStun
        setStun(X)
        return
    } else {
        //> cmp #$11                   ;if the enemy object identifier is equal to the values
        //> bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
        if (A >= 0x11) {
            //  goto SetStun -> setStun
            setStun(X)
            return
        }
    }
    //> cmp #$0a                   ;modified if not any of those values, note that piranha plant will
    //> bcc Demote                 ;always fail this test because A will still have vertical
    A = A
    X = X
    if (A >= 0x0A) {
        //> cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
        //> bcc SetStun                ;are only necessary if branching from $d7a1
        if (!(A >= PiranhaPlant)) {
            //  goto SetStun -> setStun
            setStun(X)
            return
        }
    }
    //> Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
    A = A and 0x01
    //> sta Enemy_ID,x             ;into green or red koopa troopa to demote them
    enemyId[X] = A
    //  Fall-through tail call to setStun
    setStun(X)
    return
}

// Decompiled from SetStun
fun setStun(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var areaType by MemoryByte(AreaType)
    val enemyBGCXSpdData by MemoryByteIndexed(EnemyBGCXSpdData)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> SetStun:  lda Enemy_State,x          ;load enemy state
    A = enemyState[X]
    //> and #%11110000             ;save high nybble
    A = A and 0xF0
    //> ora #%00000010
    A = A or 0x02
    //> sta Enemy_State,x          ;set d1 of enemy state
    enemyState[X] = A
    //> dec Enemy_Y_Position,x
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #Bloober               ;check for bloober object
    //> beq SetWYSpd
    X = X
    if (A != Bloober) {
        //> lda #$fd                   ;set default vertical speed
        A = 0xFD
        //> ldy AreaType
        Y = areaType
        //> bne SetNotW                ;if area type not water, set as speed, otherwise
        if (!(Y == 0)) {
            //  goto SetNotW (internal forward branch)
            //> SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
            enemyYSpeed[X] = A
            //> ldy #$01
            Y = 0x01
            //> jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
            val flag0: Boolean = playerEnemyDiff(X)
            //> bpl ChkBBill               ;branch if enemy is to the right of player
            if (!((A and 0x80) != 0)) {
                //  goto ChkBBill (internal forward branch)
                //> ChkBBill: lda Enemy_ID,x
                A = enemyId[X]
                //> cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
                //> beq NoCDirF
                if (A == BulletBill_CannonVar) {
                    //  goto NoCDirF (internal forward branch)
                    //> NoCDirF:  dey                        ;decrement and use as offset
                    Y = (Y - 1) and 0xFF
                    //> lda EnemyBGCXSpdData,y     ;get proper horizontal speed
                    A = enemyBGCXSpdData[Y]
                    //> sta Enemy_X_Speed,x        ;and store, then leave
                    enemyXSpeed[X] = A
                    //  Fall-through tail call to exEBGChk
                    exEBGChk()
                    return
                }
                //> cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
                //> beq NoCDirF                ;branch if either found, direction does not change
                if (A == BulletBill_FrenzyVar) {
                    //  goto NoCDirF (internal forward branch)
                    //> NoCDirF:  dey                        ;decrement and use as offset
                    Y = (Y - 1) and 0xFF
                    //> lda EnemyBGCXSpdData,y     ;get proper horizontal speed
                    A = enemyBGCXSpdData[Y]
                    //> sta Enemy_X_Speed,x        ;and store, then leave
                    enemyXSpeed[X] = A
                    //  Fall-through tail call to exEBGChk
                    exEBGChk()
                    return
                }
                //> sty Enemy_MovingDir,x      ;store as moving direction
                enemyMovingdir[X] = Y
                return
            }
            //> iny                        ;increment Y if not
            Y = (Y + 1) and 0xFF
            return
        }
    }
    //> SetWYSpd: lda #$ff                   ;change the vertical speed
    A = 0xFF
    //> SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
    enemyYSpeed[X] = A
    //> ldy #$01
    Y = 0x01
    //> jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
    val flag1: Boolean = playerEnemyDiff(X)
    //> bpl ChkBBill               ;branch if enemy is to the right of player
    if ((A and 0x80) != 0) {
        //> iny                        ;increment Y if not
        Y = (Y + 1) and 0xFF
    }
    //> ChkBBill: lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
    //> beq NoCDirF
    if (A != BulletBill_CannonVar) {
        //> cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
        //> beq NoCDirF                ;branch if either found, direction does not change
        if (A != BulletBill_FrenzyVar) {
            //> sty Enemy_MovingDir,x      ;store as moving direction
            enemyMovingdir[X] = Y
        }
    }
    //> NoCDirF:  dey                        ;decrement and use as offset
    Y = (Y - 1) and 0xFF
    //> lda EnemyBGCXSpdData,y     ;get proper horizontal speed
    A = enemyBGCXSpdData[Y]
    //> sta Enemy_X_Speed,x        ;and store, then leave
    enemyXSpeed[X] = A
    //  Fall-through tail call to exEBGChk
    exEBGChk()
    return
}

// Decompiled from ExEBGChk
fun exEBGChk() {
    //> ExEBGChk: rts
    return
}

// Decompiled from ChkForRedKoopa
fun chkForRedKoopa(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    val enemyBGCStateData by MemoryByteIndexed(EnemyBGCStateData)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> ChkForRedKoopa:
    //> lda Enemy_ID,x            ;check for red koopa troopa $03
    A = enemyId[X]
    //> cmp #RedKoopa
    //> bne Chk2MSBSt             ;branch if not found
    X = X
    if (A == RedKoopa) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
        if (A == 0) {
            //  goto ChkForBump_HammerBroJ -> chkforbumpHammerbroj
            chkforbumpHammerbroj(X)
            return Pair(X, Y)
        }
    }
    //> Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
    A = enemyState[X]
    //> tay
    Y = A
    //> asl                       ;check for d7 set
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> bcc GetSteFromD           ;branch if not set
    Y = Y
    if ((orig0 and 0x80) != 0) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> ora #%01000000            ;set d6
        A = A or 0x40
        //> jmp SetD6Ste              ;jump ahead of this part
        return setD6Ste(A, X)
    } else {
        //> GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
        A = enemyBGCStateData[Y]
        //  Fall-through tail call to setD6Ste
        return setD6Ste(A, X)
    }
}

// Decompiled from SetD6Ste
fun setD6Ste(A: Int, X: Int): Pair<Int, Int> {
    var Y: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> SetD6Ste:    sta Enemy_State,x         ;set as new state
    enemyState[X] = A
    //> ;--------------------------------
    //> ;$00 - used to store bitmask (not used but initialized here)
    //> ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
    //  Fall-through tail call to doEnemySideCheck
    return doEnemySideCheck(X)
}

// Decompiled from DoEnemySideCheck
fun doEnemySideCheck(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var exitFlag0: Boolean = false
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> DoEnemySideCheck:
    //> lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
    A = enemyYPosition[X]
    //> cmp #$20                   ;because there's nothing there that impedes movement
    //> bcc ExESdeC
    X = X
    if (A >= 0x20) {
        //> ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
        Y = 0x16
        //> lda #$02                   ;set value here in what is also used as
        A = 0x02
        //> sta $eb                    ;OAM data offset
        memory[0xEB] = A.toUByte()
        loop0@ do {
            //> SdeCLoop: lda $eb                    ;check value
            A = memory[0xEB].toInt()
            //> cmp Enemy_MovingDir,x      ;compare value against moving direction
            //> bne NextSdeC               ;branch if different and do not seek block there
            if (A == enemyMovingdir[X]) {
                //> lda #$01                   ;set flag in A for save horizontal coordinate
                A = 0x01
                //> jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
                val pair0 = blockbufferchkEnemy(A, X, Y)
                temp0 = pair0.first
                temp1 = pair0.second
                X = temp1
                //> beq NextSdeC               ;if nothing found, branch
                A = temp0
                Y = temp1
                if (temp0 != 0) {
                    //> jsr ChkForNonSolids        ;check for non-solid blocks
                    chkForNonSolids(A)
                    //> bne ChkForBump_HammerBroJ  ;branch if not found
                    if (!(A == 0)) {
                        //  goto ChkForBump_HammerBroJ
                        exitFlag0 = true
                        break@loop0
                    }
                }
            }
            //> NextSdeC: dec $eb                    ;move to the next direction
            memory[0xEB] = ((memory[0xEB].toInt() - 1) and 0xFF).toUByte()
            //> iny
            Y = (Y + 1) and 0xFF
            //> cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
            //> bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
            if (!(Y >= 0x18)) {
                //  continue loop (branch back to SdeCLoop)
                continue@loop0
            }
        } while (!(Y >= 0x18))
    }
    //> ExESdeC:  rts
    return Pair(X, Y)
}

// Decompiled from ChkForBump_HammerBroJ
fun chkforbumpHammerbroj(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> ChkForBump_HammerBroJ:
    //> cpx #$05               ;check if we're on the special use slot
    //> beq NoBump             ;and if so, branch ahead and do not play sound
    X = X
    if (X != 0x05) {
        //> lda Enemy_State,x      ;if enemy state d7 not set, branch
        A = enemyState[X]
        //> asl                    ;ahead and do not play sound
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> bcc NoBump
        if ((orig0 and 0x80) != 0) {
            //> lda #Sfx_Bump          ;otherwise, play bump sound
            A = Sfx_Bump
            //> sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
            square1SoundQueue = A
        }
    }
    //> NoBump: lda Enemy_ID,x         ;check for hammer bro
    A = enemyId[X]
    //> cmp #$05
    //> bne InvEnemyDir        ;branch if not found
    if (A == 0x05) {
        //> lda #$00
        A = 0x00
        //> sta $00                ;initialize value here for bitmask
        memory[0x0] = A.toUByte()
        //> ldy #$fa               ;load default vertical speed for jumping
        Y = 0xFA
        //> jmp SetHJ              ;jump to code that makes hammer bro jump
        return setHJ(X, Y)
    } else {
        //> InvEnemyDir:
        //> jmp RXSpd     ;jump to turn the enemy around
        rXSpd(X)
        return Pair(A, Y)
    }
}

// Decompiled from PlayerEnemyDiff
fun playerEnemyDiff(X: Int): Boolean {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> PlayerEnemyDiff:
    //> lda Enemy_X_Position,x  ;get distance between enemy object's
    A = enemyXPosition[X]
    //> sec                     ;horizontal coordinate and the player's
    //> sbc Player_X_Position   ;horizontal coordinate
    temp0 = A - playerXPosition
    A = temp0 and 0xFF
    //> sta $00                 ;and store here
    memory[0x0] = A.toUByte()
    //> lda Enemy_PageLoc,x
    A = enemyPageloc[X]
    //> sbc Player_PageLoc      ;subtract borrow, then leave
    temp1 = A - playerPageloc - if (temp0 >= 0) 0 else 1
    A = temp1 and 0xFF
    //> rts
    return temp1 >= 0
}

// Decompiled from EnemyLanding
fun enemyLanding(X: Int) {
    var A: Int = 0
    var temp0: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> EnemyLanding:
    //> jsr InitVStf            ;do something here to vertical speed and something else
    temp0 = initVStf(X)
    //> lda Enemy_Y_Position,x
    A = enemyYPosition[X]
    //> and #%11110000          ;save high nybble of vertical coordinate, and
    A = A and 0xF0
    //> ora #%00001000          ;set d3, then store, probably used to set enemy object
    A = A or 0x08
    //> sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
    enemyYPosition[X] = A
    //> rts
    return
}

// Decompiled from SubtEnemyYPos
fun subtEnemyYPos(X: Int): Boolean {
    var A: Int = 0
    var temp0: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> SubtEnemyYPos:
    //> lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
    A = enemyYPosition[X]
    //> clc                     ;vertical coordinate
    //> adc #$3e
    temp0 = A + 0x3E
    A = temp0 and 0xFF
    //> cmp #$44                ;compare against a certain range
    //> rts                     ;and leave with flags set for conditional branch
    return A >= 0x44
}

// Decompiled from EnemyJump
fun enemyJump(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> EnemyJump:
    //> jsr SubtEnemyYPos     ;do a sub here
    val flag0: Boolean = subtEnemyYPos(X)
    //> bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
    X = X
    Y = Y
    if (flag0) {
        //> lda Enemy_Y_Speed,x
        A = enemyYSpeed[X]
        //> clc                   ;add two to vertical speed
        //> adc #$02
        temp0 = A + 0x02
        A = temp0 and 0xFF
        //> cmp #$03              ;if green paratroopa not falling, branch ahead
        //> bcc DoSide
        if (A >= 0x03) {
            //> jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
            val pair0 = chkUnderEnemy(X)
            temp1 = pair0.first
            temp2 = pair0.second
            X = temp2
            //> beq DoSide            ;standing on anything, then branch to same place if not
            A = temp1
            Y = temp2
            if (temp1 != 0) {
                //> jsr ChkForNonSolids   ;check for non-solid blocks
                chkForNonSolids(A)
                //> beq DoSide            ;branch if found
                if (A != 0) {
                    //> jsr EnemyLanding      ;change vertical coordinate and speed
                    enemyLanding(X)
                    //> lda #$fd
                    A = 0xFD
                    //> sta Enemy_Y_Speed,x   ;make the paratroopa jump again
                    enemyYSpeed[X] = A
                }
            }
        }
    }
    //> DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
    return doEnemySideCheck(X)
}

// Decompiled from HammerBroBGColl
fun hammerBroBGColl(A: Int, X: Int): Pair<Int, Int> {
    var A: Int = A
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> HammerBroBGColl:
    //> jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
    val pair0 = chkUnderEnemy(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> beq NoUnderHammerBro
    A = temp0
    Y = temp1
    if (temp0 != 0) {
        //> cmp #$23             ;check for blank metatile $23 and branch if not found
        //> bne UnderHammerBro
        if (A == 0x23) {
            //  Fall-through tail call to killEnemyAboveBlock
            killEnemyAboveBlock(X)
            return Pair(X, Y)
        }
        //> UnderHammerBro:
        //> lda EnemyFrameTimer,x ;check timer used by hammer bro
        A = enemyFrameTimer[X]
        //> bne NoUnderHammerBro  ;branch if not expired
        if (A == 0) {
            //> lda Enemy_State,x
            A = enemyState[X]
            //> and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
            A = A and 0x88
            //> sta Enemy_State,x     ;and store
            enemyState[X] = A
            //> jsr EnemyLanding      ;modify vertical coordinate, speed and something else
            enemyLanding(X)
            //> jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
            return doEnemySideCheck(X)
        }
    }
    //> NoUnderHammerBro:
    //> lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
    A = enemyState[X]
    //> ora #$01           ;in the enemy state to indicate jumping or falling, then leave
    A = A or 0x01
    //> sta Enemy_State,x
    enemyState[X] = A
    //> rts
    return Pair(X, Y)
}

// Decompiled from KillEnemyAboveBlock
fun killEnemyAboveBlock(X: Int) {
    var A: Int = 0
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> KillEnemyAboveBlock:
    //> jsr ShellOrBlockDefeat  ;do this sub to kill enemy
    shellOrBlockDefeat(X)
    //> lda #$fc                ;alter vertical speed of enemy and leave
    A = 0xFC
    //> sta Enemy_Y_Speed,x
    enemyYSpeed[X] = A
    //> rts
    return
}

// Decompiled from ChkUnderEnemy
fun chkUnderEnemy(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    //> ChkUnderEnemy:
    //> lda #$00                  ;set flag in A for save vertical coordinate
    A = 0x00
    //> ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
    Y = 0x15
    //> jmp BlockBufferChk_Enemy  ;hop to it!
    return blockbufferchkEnemy(A, X, Y)
}

// Decompiled from ChkForNonSolids
fun chkForNonSolids(A: Int) {
    var A: Int = A
    //> ChkForNonSolids:
    //> cmp #$26       ;blank metatile used for vines?
    //> beq NSFnd
    A = A
    if (A != 0x26) {
        //> cmp #$c2       ;regular coin?
        //> beq NSFnd
        if (A != 0xC2) {
            //> cmp #$c3       ;underwater coin?
            //> beq NSFnd
            if (A != 0xC3) {
                //> cmp #$5f       ;hidden coin block?
                //> beq NSFnd
                if (A != 0x5F) {
                    //> cmp #$60       ;hidden 1-up block?
                }
            }
        }
    }
    //> NSFnd: rts
    return
}

// Decompiled from FireballBGCollision
fun fireballBGCollision(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val fireballBouncingFlag by MemoryByteIndexed(FireballBouncingFlag)
    val fireballState by MemoryByteIndexed(Fireball_State)
    val fireballYPosition by MemoryByteIndexed(Fireball_Y_Position)
    val fireballYSpeed by MemoryByteIndexed(Fireball_Y_Speed)
    //> FireballBGCollision:
    //> lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
    A = fireballYPosition[X]
    //> cmp #$18
    //> bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
    X = X
    if (A >= 0x18) {
        //> jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
        val pair0 = blockbufferchkFball(X)
        temp0 = pair0.first
        temp1 = pair0.second
        X = temp1
        //> beq ClearBounceFlag         ;if nothing underneath fireball, branch
        A = temp0
        Y = temp1
        if (temp0 != 0) {
            //> jsr ChkForNonSolids         ;check for non-solid metatiles
            chkForNonSolids(A)
            //> beq ClearBounceFlag         ;branch if any found
            if (A != 0) {
                //> lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
                A = fireballYSpeed[X]
                //> bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
                if ((A and 0x80) == 0) {
                    //> lda FireballBouncingFlag,x  ;if bouncing flag already set,
                    A = fireballBouncingFlag[X]
                    //> bne InitFireballExplode     ;branch to set exploding bit in fireball's state
                    if (A == 0) {
                        //> lda #$fd
                        A = 0xFD
                        //> sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
                        fireballYSpeed[X] = A
                        //> lda #$01
                        A = 0x01
                        //> sta FireballBouncingFlag,x  ;set bouncing flag
                        fireballBouncingFlag[X] = A
                        //> lda Fireball_Y_Position,x
                        A = fireballYPosition[X]
                        //> and #$f8                    ;modify vertical coordinate to land it properly
                        A = A and 0xF8
                        //> sta Fireball_Y_Position,x   ;store as new vertical coordinate
                        fireballYPosition[X] = A
                        //> rts                         ;leave
                        return X
                    }
                }
            }
        }
    }
    //> ClearBounceFlag:
    //> lda #$00
    A = 0x00
    //> sta FireballBouncingFlag,x  ;clear bouncing flag by default
    fireballBouncingFlag[X] = A
    //> rts                         ;leave
    return X
    //> InitFireballExplode:
    //> lda #$80
    A = 0x80
    //> sta Fireball_State,x        ;set exploding flag in fireball's state
    fireballState[X] = A
    //> lda #Sfx_Bump
    A = Sfx_Bump
    //> sta Square1SoundQueue       ;load bump sound
    square1SoundQueue = A
    //> rts                         ;leave
    return X
}

// Decompiled from GetFireballBoundBox
fun getFireballBoundBox(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> GetFireballBoundBox:
    //> txa         ;add seven bytes to offset
    A = X
    //> clc         ;to use in routines as offset for fireball
    //> adc #$07
    temp0 = A + 0x07
    //> tax
    X = temp0 and 0xFF
    //> ldy #$02    ;set offset for relative coordinates
    Y = 0x02
    //> bne FBallB  ;unconditional branch
    if (!(Y == 0)) {
        //  goto FBallB -> fBallB
        fBallB(X, Y)
        return X
    } else {
        //  Fall-through tail call to getMiscBoundBox
        return getMiscBoundBox(X)
    }
}

// Decompiled from GetMiscBoundBox
fun getMiscBoundBox(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> GetMiscBoundBox:
    //> txa                       ;add nine bytes to offset
    A = X
    //> clc                       ;to use in routines as offset for misc object
    //> adc #$09
    temp0 = A + 0x09
    //> tax
    X = temp0 and 0xFF
    //> ldy #$06                  ;set offset for relative coordinates
    Y = 0x06
    //  Fall-through tail call to fBallB
    return fBallB(X, Y)
}

// Decompiled from FBallB
fun fBallB(X: Int, Y: Int): Int {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    //> FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
    val pair0 = boundingBoxCore(X, Y)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp0
    //> jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
    return checkRightScreenBBox(temp0, temp1)
}

// Decompiled from GetEnemyBoundBox
fun getEnemyBoundBox(X: Int): Pair<Int, Int> {
    var Y: Int = 0
    //> GetEnemyBoundBox:
    //> ldy #$48                 ;store bitmask here for now
    Y = 0x48
    //> sty $00
    memory[0x0] = Y.toUByte()
    //> ldy #$44                 ;store another bitmask here for now and jump
    Y = 0x44
    //> jmp GetMaskedOffScrBits
    return getMaskedOffScrBits(X, Y)
}

// Decompiled from SmallPlatformBoundBox
fun smallPlatformBoundBox(X: Int): Pair<Int, Int> {
    var Y: Int = 0
    //> SmallPlatformBoundBox:
    //> ldy #$08                 ;store bitmask here for now
    Y = 0x08
    //> sty $00
    memory[0x0] = Y.toUByte()
    //> ldy #$04                 ;store another bitmask here for now
    Y = 0x04
    //  Fall-through tail call to getMaskedOffScrBits
    return getMaskedOffScrBits(X, Y)
}

// Decompiled from GetMaskedOffScrBits
fun getMaskedOffScrBits(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> GetMaskedOffScrBits:
    //> lda Enemy_X_Position,x      ;get enemy object position relative
    A = enemyXPosition[X]
    //> sec                         ;to the left side of the screen
    //> sbc ScreenLeft_X_Pos
    temp0 = A - screenleftXPos
    A = temp0 and 0xFF
    //> sta $01                     ;store here
    memory[0x1] = A.toUByte()
    //> lda Enemy_PageLoc,x         ;subtract borrow from current page location
    A = enemyPageloc[X]
    //> sbc ScreenLeft_PageLoc      ;of left side
    temp1 = A - screenleftPageloc - if (temp0 >= 0) 0 else 1
    A = temp1 and 0xFF
    //> bmi CMBits                  ;if enemy object is beyond left edge, branch
    X = X
    Y = Y
    if ((temp1 and 0xFF and 0x80) == 0) {
        //> ora $01
        A = A or memory[0x1].toInt()
        //> beq CMBits                  ;if precisely at the left edge, branch
        if (A != 0) {
            //> ldy $00                     ;if to the right of left edge, use value in $00 for A
            Y = memory[0x0].toInt()
        }
    }
    //> CMBits: tya                         ;otherwise use contents of Y
    A = Y
    //> and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
    A = A and enemyOffscreenbits
    //> sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
    enemyOffscrBitsMasked[X] = A
    //> bne MoveBoundBoxOffscreen   ;if anything set here, branch
    if (!(A == 0)) {
        //  goto MoveBoundBoxOffscreen -> moveBoundBoxOffscreen
        moveBoundBoxOffscreen(X)
        return Pair(X, Y)
    } else {
        //> jmp SetupEOffsetFBBox       ;otherwise, do something else
        return setupEOffsetFBBox(X)
    }
}

// Decompiled from LargePlatformBoundBox
fun largePlatformBoundBox(A: Int, X: Int): Pair<Int, Int> {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    //> LargePlatformBoundBox:
    //> inx                        ;increment X to get the proper offset
    X = (X + 1) and 0xFF
    //> jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
    val pair0 = getXOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> dex                        ;decrement to return to original offset
    X = (X - 1) and 0xFF
    //> cmp #$fe                   ;if completely offscreen, branch to put entire bounding
    //> bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
    if (temp0 >= 0xFE) {
        //  goto MoveBoundBoxOffscreen -> moveBoundBoxOffscreen
        moveBoundBoxOffscreen(X)
        return Pair(X, Y)
    } else {
        //  Fall-through tail call to setupEOffsetFBBox
        return setupEOffsetFBBox(X)
    }
}

// Decompiled from SetupEOffsetFBBox
fun setupEOffsetFBBox(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    //> SetupEOffsetFBBox:
    //> txa                        ;add 1 to offset to properly address
    A = X
    //> clc                        ;the enemy object memory locations
    //> adc #$01
    temp0 = A + 0x01
    //> tax
    X = temp0 and 0xFF
    //> ldy #$01                   ;load 1 as offset here, same reason
    Y = 0x01
    //> jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
    val pair0 = boundingBoxCore(X, Y)
    temp1 = pair0.first
    temp2 = pair0.second
    X = temp1
    //> jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
    checkRightScreenBBox(temp1, temp2)
    return Pair(X, Y)
}

// Decompiled from MoveBoundBoxOffscreen
fun moveBoundBoxOffscreen(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    val enemyBoundingBoxCoord by MemoryByteIndexed(EnemyBoundingBoxCoord)
    //> MoveBoundBoxOffscreen:
    //> txa                            ;multiply offset by 4
    A = X
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> tay                            ;use as offset here
    Y = A
    //> lda #$ff
    A = 0xFF
    //> sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
    enemyBoundingBoxCoord[Y] = A
    //> sta EnemyBoundingBoxCoord+1,y
    enemyBoundingBoxCoord[1 + Y] = A
    //> sta EnemyBoundingBoxCoord+2,y
    enemyBoundingBoxCoord[2 + Y] = A
    //> sta EnemyBoundingBoxCoord+3,y
    enemyBoundingBoxCoord[3 + Y] = A
    //> rts
    return
}

// Decompiled from BoundingBoxCore
fun boundingBoxCore(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val boundBoxCtrlData by MemoryByteIndexed(BoundBoxCtrlData)
    val boundingboxLrCorner by MemoryByteIndexed(BoundingBox_LR_Corner)
    val boundingboxUlCorner by MemoryByteIndexed(BoundingBox_UL_Corner)
    val sprobjBoundboxctrl by MemoryByteIndexed(SprObj_BoundBoxCtrl)
    val sprobjectRelXpos by MemoryByteIndexed(SprObject_Rel_XPos)
    val sprobjectRelYpos by MemoryByteIndexed(SprObject_Rel_YPos)
    //> BoundingBoxCore:
    //> stx $00                     ;save offset here
    memory[0x0] = X.toUByte()
    //> lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
    A = sprobjectRelYpos[Y]
    //> sta $02                     ;vertically and horizontally, respectively
    memory[0x2] = A.toUByte()
    //> lda SprObject_Rel_XPos,y
    A = sprobjectRelXpos[Y]
    //> sta $01
    memory[0x1] = A.toUByte()
    //> txa                         ;multiply offset by four and save to stack
    A = X
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> pha
    push(A)
    //> tay                         ;use as offset for Y, X is left alone
    Y = A
    //> lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
    A = sprobjBoundboxctrl[X]
    //> asl                         ;multiply that by four and use as X
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> tax
    X = A
    //> lda $01                     ;add the first number in the bounding box data to the
    A = memory[0x1].toInt()
    //> clc                         ;relative horizontal coordinate using enemy object offset
    //> adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
    temp0 = A + boundBoxCtrlData[X]
    A = temp0 and 0xFF
    //> sta BoundingBox_UL_Corner,y ;store here
    boundingboxUlCorner[Y] = A
    //> lda $01
    A = memory[0x1].toInt()
    //> clc
    //> adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
    temp1 = A + boundBoxCtrlData[2 + X]
    A = temp1 and 0xFF
    //> sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
    boundingboxLrCorner[Y] = A
    //> inx                         ;increment both offsets
    X = (X + 1) and 0xFF
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda $02                     ;add the second number to the relative vertical coordinate
    A = memory[0x2].toInt()
    //> clc                         ;using incremented offset and store using the other
    //> adc BoundBoxCtrlData,x      ;incremented offset
    temp2 = A + boundBoxCtrlData[X]
    A = temp2 and 0xFF
    //> sta BoundingBox_UL_Corner,y
    boundingboxUlCorner[Y] = A
    //> lda $02
    A = memory[0x2].toInt()
    //> clc
    //> adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
    temp3 = A + boundBoxCtrlData[2 + X]
    A = temp3 and 0xFF
    //> sta BoundingBox_LR_Corner,y ;and store
    boundingboxLrCorner[Y] = A
    //> pla                         ;get original offset loaded into $00 * y from stack
    A = pull()
    //> tay                         ;use as Y
    Y = A
    //> ldx $00                     ;get original offset and use as X again
    X = memory[0x0].toInt()
    //> rts
    return Pair(X, Y)
}

// Decompiled from CheckRightScreenBBox
fun checkRightScreenBBox(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    //> CheckRightScreenBBox:
    //> lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
    A = screenleftXPos
    //> clc                        ;and store as horizontal coordinate of middle
    //> adc #$80
    temp0 = A + 0x80
    A = temp0 and 0xFF
    //> sta $02
    memory[0x2] = A.toUByte()
    //> lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
    A = screenleftPageloc
    //> adc #$00                   ;and store as page location of middle
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> sta $01
    memory[0x1] = A.toUByte()
    //> lda SprObject_X_Position,x ;get horizontal coordinate
    A = sprobjectXPosition[X]
    //> cmp $02                    ;compare against middle horizontal coordinate
    //> lda SprObject_PageLoc,x    ;get page location
    A = sprobjectPageloc[X]
    //> sbc $01                    ;subtract from middle page location
    temp2 = A - memory[0x1].toInt() - if (A >= memory[0x2].toInt()) 0 else 1
    A = temp2 and 0xFF
    //> bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
    X = X
    Y = Y
    if (temp2 >= 0) {
        //> lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
        A = boundingboxDrXpos[Y]
        //> bmi NoOfs                  ;coordinates, branch if still on the screen
        if ((A and 0x80) == 0) {
            //> lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
            A = 0xFF
            //> ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
            X = boundingboxUlXpos[Y]
            //> bmi SORte                  ;coordinates, and branch if still on the screen
            if ((X and 0x80) == 0) {
                //> sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[Y] = A
            }
            //> SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
            boundingboxDrXpos[Y] = A
        }
        //> NoOfs: ldx ObjectOffset           ;get object offset and leave
        X = objectOffset
        //> rts
        return X
    } else {
        //> CheckLeftScreenBBox:
        //> lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
        A = boundingboxUlXpos[Y]
        //> bpl NoOfs2                 ;coordinates, and branch if still on the screen
        if ((A and 0x80) != 0) {
            //> cmp #$a0                   ;check to see if left-side edge is in the middle of the
            //> bcc NoOfs2                 ;screen or really offscreen, and branch if still on
            if (A >= 0xA0) {
                //> lda #$00
                A = 0x00
                //> ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
                X = boundingboxDrXpos[Y]
                //> bpl SOLft                  ;coordinates, branch if still onscreen
                if ((X and 0x80) != 0) {
                    //> sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
                    boundingboxDrXpos[Y] = A
                }
                //> SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[Y] = A
            }
        }
    }
    //> NoOfs2: ldx ObjectOffset           ;get object offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from PlayerCollisionCore
fun playerCollisionCore(Y: Int): Boolean {
    var X: Int = 0
    //> PlayerCollisionCore:
    //> ldx #$00     ;initialize X to use player's bounding box for comparison
    X = 0x00
    //  Fall-through tail call to sprObjectCollisionCore
    sprObjectCollisionCore(X, Y)
    return false
}

// Decompiled from SprObjectCollisionCore
fun sprObjectCollisionCore(X: Int, Y: Int): Boolean {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    val boundingboxLrCorner by MemoryByteIndexed(BoundingBox_LR_Corner)
    val boundingboxUlCorner by MemoryByteIndexed(BoundingBox_UL_Corner)
    //> SprObjectCollisionCore:
    //> sty $06      ;save contents of Y here
    memory[0x6] = Y.toUByte()
    //> lda #$01
    A = 0x01
    //> sta $07      ;save value 1 here as counter, compare horizontal coordinates first
    memory[0x7] = A.toUByte()
    X = X
    Y = Y
    loop0@ do {
        //> CollisionCoreLoop:
        //> lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
        A = boundingboxUlCorner[Y]
        //> cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
        //> bcs FirstBoxGreater          ;if first left/top => second, branch
        if (!(A >= boundingboxUlCorner[X])) {
            //> cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
            //> bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
            if (A >= boundingboxLrCorner[X]) {
                //> beq CollisionFound           ;if somehow equal, collision, thus branch
                if (A != boundingboxLrCorner[X]) {
                    //> lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
                    A = boundingboxLrCorner[Y]
                    //> cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
                    //> bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
                    if (A >= boundingboxUlCorner[Y]) {
                        //> cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
                        //> bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
                        if (!(A >= boundingboxUlCorner[X])) {
                            //> ldy $06                      ;otherwise return with carry clear and Y = $0006
                            Y = memory[0x6].toInt()
                            //> rts                          ;note horizontal wrapping never occurs
                            return A >= boundingboxUlCorner[X]
                        }
                    }
                }
            }
            //> SecondBoxVerticalChk:
            //> lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
            A = boundingboxLrCorner[X]
            //> cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
            //> bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
            if (A >= boundingboxUlCorner[X]) {
                //> lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
                A = boundingboxLrCorner[Y]
                //> cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
                //> bcs CollisionFound           ;if equal or greater, collision, thus branch
                if (!(A >= boundingboxUlCorner[X])) {
                    //> ldy $06                      ;otherwise return with carry clear and Y = $0006
                    Y = memory[0x6].toInt()
                    //> rts
                    return A >= boundingboxUlCorner[X]
                }
            }
        }
        //> FirstBoxGreater:
        //> cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
        //> beq CollisionFound           ;if first coordinate = second, collision, thus branch
        if (A != boundingboxUlCorner[X]) {
            //> cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
            //> bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
            if (A >= boundingboxLrCorner[X]) {
                //> beq CollisionFound           ;then collision, thus branch
                if (A != boundingboxLrCorner[X]) {
                    //> cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
                    //> bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
                    if (A >= boundingboxLrCorner[Y]) {
                        //> beq NoCollisionFound
                        if (A != boundingboxLrCorner[Y]) {
                            //> lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
                            A = boundingboxLrCorner[Y]
                            //> cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
                            //> bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
                            if (!(A >= boundingboxUlCorner[X])) {
                            }
                        } else {
                            break@loop0
                        }
                    } else {
                        break@loop0
                    }
                    //> NoCollisionFound:
                    //> clc          ;clear carry, then load value set earlier, then leave
                    //> ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
                    Y = memory[0x6].toInt()
                    //> rts          ;not bother checking vertical ones, because what's the point?
                    return false
                }
            }
        }
        //> CollisionFound:
        //> inx                    ;increment offsets on both objects to check
        X = (X + 1) and 0xFF
        //> iny                    ;the vertical coordinates
        Y = (Y + 1) and 0xFF
        //> dec $07                ;decrement counter to reflect this
        memory[0x7] = ((memory[0x7].toInt() - 1) and 0xFF).toUByte()
        //> bpl CollisionCoreLoop  ;if counter not expired, branch to loop
        if (!((memory[0x7].toInt() and 0x80) != 0)) {
            //  continue loop (branch back to CollisionCoreLoop)
            continue@loop0
        }
    } while ((memory[0x7].toInt() and 0x80) == 0)
    //> sec                    ;otherwise we already did both sets, therefore collision, so set carry
    //> ldy $06                ;load original value set here earlier, then leave
    Y = memory[0x6].toInt()
    //> rts
    return true
}

// Decompiled from BlockBufferChk_Enemy
fun blockbufferchkEnemy(A: Int, X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = A
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    //> BlockBufferChk_Enemy:
    //> pha        ;save contents of A to stack
    push(A)
    //> txa
    A = X
    //> clc        ;add 1 to X to run sub with enemy offset in mind
    //> adc #$01
    temp0 = A + 0x01
    //> tax
    X = temp0 and 0xFF
    //> pla        ;pull A from stack and jump elsewhere
    temp1 = pull()
    //> jmp BBChk_E
    return bbchkE(temp1, X, Y)
}

// Decompiled from BlockBufferChk_FBall
fun blockbufferchkFball(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> BlockBufferChk_FBall:
    //> ldy #$1a                  ;set offset for block buffer adder data
    Y = 0x1A
    //> txa
    A = X
    //> clc
    //> adc #$07                  ;add seven bytes to use
    temp0 = A + 0x07
    //> tax
    X = temp0 and 0xFF
    //  Fall-through tail call to resJmpM
    return resJmpM(X, Y)
}

// Decompiled from ResJmpM
fun resJmpM(X: Int, Y: Int): Pair<Int, Int> {
    var A: Int = 0
    //> ResJmpM: lda #$00                  ;set A to return vertical coordinate
    A = 0x00
    //  Fall-through tail call to bbchkE
    return bbchkE(A, X, Y)
}

// Decompiled from BBChk_E
fun bbchkE(A: Int, X: Int, Y: Int): Pair<Int, Int> {
    var X: Int = X
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
    temp0 = blockBufferCollision(A, X, Y)
    //> ldx ObjectOffset          ;get object offset
    X = objectOffset
    //> cmp #$00                  ;check to see if object bumped into anything
    //> rts
    return Pair(temp0, X)
}

// Decompiled from BlockBufferColli_Feet
fun blockbuffercolliFeet(Y: Int): Int {
    var A: Int = 0
    var Y: Int = Y
    //> BlockBufferColli_Feet:
    //> iny            ;if branched here, increment to next set of adders
    Y = (Y + 1) and 0xFF
    //  Fall-through tail call to blockbuffercolliHead
    return blockbuffercolliHead(Y)
}

// Decompiled from BlockBufferColli_Head
fun blockbuffercolliHead(Y: Int): Int {
    var A: Int = 0
    var X: Int = 0
    //> BlockBufferColli_Head:
    //> lda #$00       ;set flag to return vertical coordinate
    A = 0x00
    //> .db $2c        ;BIT instruction opcode
    //> BlockBufferColli_Side:
    //> lda #$01       ;set flag to return horizontal coordinate
    //  (skipped by BIT $2C)
    //> ldx #$00       ;set offset for player object
    X = 0x00
    //  Fall-through tail call to blockBufferCollision
    return blockBufferCollision(A, X, Y)
}

// Decompiled from BlockBufferColli_Side
fun blockbuffercolliSide(Y: Int): Int {
    return blockBufferCollision(0x01, 0x00, Y)
}

// Decompiled from BlockBufferCollision
fun blockBufferCollision(A: Int, X: Int, Y: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val blockbufferXAdder by MemoryByteIndexed(BlockBuffer_X_Adder)
    val blockbufferYAdder by MemoryByteIndexed(BlockBuffer_Y_Adder)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    //> BlockBufferCollision:
    //> pha                         ;save contents of A to stack
    push(A)
    //> sty $04                     ;save contents of Y here
    memory[0x4] = Y.toUByte()
    //> lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
    A = blockbufferXAdder[Y]
    //> clc                         ;of object to value obtained using Y as offset
    //> adc SprObject_X_Position,x
    temp0 = A + sprobjectXPosition[X]
    A = temp0 and 0xFF
    //> sta $05                     ;store here
    memory[0x5] = A.toUByte()
    //> lda SprObject_PageLoc,x
    A = sprobjectPageloc[X]
    //> adc #$00                    ;add carry to page location
    temp1 = A + if (temp0 > 0xFF) 1 else 0
    A = temp1 and 0xFF
    //> and #$01                    ;get LSB, mask out all other bits
    A = A and 0x01
    //> lsr                         ;move to carry
    val orig0: Int = A
    A = orig0 shr 1
    //> ora $05                     ;get stored value
    A = A or memory[0x5].toInt()
    //> ror                         ;rotate carry to MSB of A
    val orig1: Int = A
    A = orig1 shr 1 or if ((orig0 and 0x01) != 0) 0x80 else 0
    //> lsr                         ;and effectively move high nybble to
    val orig2: Int = A
    A = orig2 shr 1
    //> lsr                         ;lower, LSB which became MSB will be
    val orig3: Int = A
    A = orig3 shr 1
    //> lsr                         ;d4 at this point
    val orig4: Int = A
    A = orig4 shr 1
    //> jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
    getBlockBufferAddr(A)
    //> ldy $04                     ;get old contents of Y
    Y = memory[0x4].toInt()
    //> lda SprObject_Y_Position,x  ;get vertical coordinate of object
    A = sprobjectYPosition[X]
    //> clc
    //> adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
    temp2 = A + blockbufferYAdder[Y]
    A = temp2 and 0xFF
    //> and #%11110000              ;mask out low nybble
    A = A and 0xF0
    //> sec
    //> sbc #$20                    ;subtract 32 pixels for the status bar
    temp3 = A - 0x20
    A = temp3 and 0xFF
    //> sta $02                     ;store result here
    memory[0x2] = A.toUByte()
    //> tay                         ;use as offset for block buffer
    Y = A
    //> lda ($06),y                 ;check current content of block buffer
    A = memory[readWord(0x6) + Y].toInt()
    //> sta $03                     ;and store here
    memory[0x3] = A.toUByte()
    //> ldy $04                     ;get old contents of Y again
    Y = memory[0x4].toInt()
    //> pla                         ;pull A from stack
    A = pull()
    //> bne RetXC                   ;if A = 1, branch
    X = X
    if (A == 0) {
        //> lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
        A = sprobjectYPosition[X]
        //> jmp RetYC                   ;and jump
        return retYC(A)
    } else {
        //> RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
        A = sprobjectXPosition[X]
        //  Fall-through tail call to retYC
        return retYC(A)
    }
}

// Decompiled from RetYC
fun retYC(A: Int): Int {
    var A: Int = A
    //> RetYC: and #%00001111              ;and mask out high nybble
    A = A and 0x0F
    //> sta $04                     ;store masked out result here
    memory[0x4] = A.toUByte()
    //> lda $03                     ;get saved content of block buffer
    A = memory[0x3].toInt()
    //> rts                         ;and leave
    return A
}

// Decompiled from DrawVine
fun drawVine(Y: Int): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var vinestartYPosition by MemoryByte(VineStart_Y_Position)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    val vineObjOffset by MemoryByteIndexed(VineObjOffset)
    val vineYPosAdder by MemoryByteIndexed(VineYPosAdder)
    //> DrawVine:
    //> sty $00                    ;save offset here
    memory[0x0] = Y.toUByte()
    //> lda Enemy_Rel_YPos         ;get relative vertical coordinate
    A = enemyRelYpos
    //> clc
    //> adc VineYPosAdder,y        ;add value using offset in Y to get value
    temp0 = A + vineYPosAdder[Y]
    A = temp0 and 0xFF
    //> ldx VineObjOffset,y        ;get offset to vine
    X = vineObjOffset[Y]
    //> ldy Enemy_SprDataOffset,x  ;get sprite data offset
    Y = enemySprdataoffset[X]
    //> sty $02                    ;store sprite data offset here
    memory[0x2] = Y.toUByte()
    //> jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
    temp1 = sixSpriteStacker(A, Y)
    //> lda Enemy_Rel_XPos         ;get relative horizontal coordinate
    A = enemyRelXpos
    //> sta Sprite_X_Position,y    ;store in first, third and fifth sprites
    spriteXPosition[temp1] = A
    //> sta Sprite_X_Position+8,y
    spriteXPosition[8 + temp1] = A
    //> sta Sprite_X_Position+16,y
    spriteXPosition[16 + temp1] = A
    //> clc
    //> adc #$06                   ;add six pixels to second, fourth and sixth sprites
    temp2 = A + 0x06
    A = temp2 and 0xFF
    //> sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
    spriteXPosition[4 + temp1] = A
    //> sta Sprite_X_Position+12,y ;our vertical stack of sprites
    spriteXPosition[12 + temp1] = A
    //> sta Sprite_X_Position+20,y
    spriteXPosition[20 + temp1] = A
    //> lda #%00100001             ;set bg priority and palette attribute bits
    A = 0x21
    //> sta Sprite_Attributes,y    ;set in first, third and fifth sprites
    spriteAttributes[temp1] = A
    //> sta Sprite_Attributes+8,y
    spriteAttributes[8 + temp1] = A
    //> sta Sprite_Attributes+16,y
    spriteAttributes[16 + temp1] = A
    //> ora #%01000000             ;additionally, set horizontal flip bit
    A = A or 0x40
    //> sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
    spriteAttributes[4 + temp1] = A
    //> sta Sprite_Attributes+12,y
    spriteAttributes[12 + temp1] = A
    //> sta Sprite_Attributes+20,y
    spriteAttributes[20 + temp1] = A
    //> ldx #$05                   ;set tiles for six sprites
    X = 0x05
    Y = temp1
    loop0@ do {
        //> VineTL:  lda #$e1                   ;set tile number for sprite
        A = 0xE1
        //> sta Sprite_Tilenumber,y
        spriteTilenumber[Y] = A
        //> iny                        ;move offset to next sprite data
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> dex                        ;move onto next sprite
        X = (X - 1) and 0xFF
        //> bpl VineTL                 ;loop until all sprites are done
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to VineTL)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> ldy $02                    ;get original offset
    Y = memory[0x2].toInt()
    //> lda $00                    ;get offset to vine adding data
    A = memory[0x0].toInt()
    //> bne SkpVTop                ;if offset not zero, skip this part
    if (A == 0) {
        //> lda #$e0
        A = 0xE0
        //> sta Sprite_Tilenumber,y    ;set other tile number for top of vine
        spriteTilenumber[Y] = A
    }
    //> SkpVTop: ldx #$00                   ;start with the first sprite again
    X = 0x00
    loop1@ do {
        //> ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
        A = vinestartYPosition
        //> sec
        //> sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
        temp3 = A - spriteYPosition[Y]
        A = temp3 and 0xFF
        //> cmp #$64                   ;if two coordinates are less than 100/$64 pixels
        //> bcc NextVSp                ;apart, skip this to leave sprite alone
        if (A >= 0x64) {
            //> lda #$f8
            A = 0xF8
            //> sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
            spriteYPosition[Y] = A
        }
        //> NextVSp: iny                        ;move offset to next OAM data
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> inx                        ;move onto next sprite
        X = (X + 1) and 0xFF
        //> cpx #$06                   ;do this until all sprites are checked
        //> bne ChkFTop
        if (!(X == 0x06)) {
            //  continue loop (branch back to ChkFTop)
            continue@loop1
        }
    } while (X != 0x06)
    //> ldy $00                    ;return offset set earlier
    Y = memory[0x0].toInt()
    //> rts
    return Y
}

// Decompiled from SixSpriteStacker
fun sixSpriteStacker(A: Int, Y: Int): Int {
    var X: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> SixSpriteStacker:
    //> ldx #$06           ;do six sprites
    X = 0x06
    Y = Y
    loop0@ do {
        //> StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
        spriteData[Y] = A
        //> clc
        //> adc #$08           ;add eight pixels
        temp0 = A + 0x08
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                ;move offset four bytes forward
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> dex                ;do another sprite
        X = (X - 1) and 0xFF
        //> bne StkLp          ;do this until all sprites are done
        if (!(X == 0)) {
            //  continue loop (branch back to StkLp)
            continue@loop0
        }
    } while (X != 0)
    //> ldy $02            ;get saved OAM data offset and leave
    Y = memory[0x2].toInt()
    //> rts
    return Y
}

// Decompiled from DrawHammer
fun drawHammer(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var miscOffscreenbits by MemoryByte(Misc_OffscreenBits)
    var miscRelXpos by MemoryByte(Misc_Rel_XPos)
    var miscRelYpos by MemoryByte(Misc_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val firstSprTilenum by MemoryByteIndexed(FirstSprTilenum)
    val firstSprXPos by MemoryByteIndexed(FirstSprXPos)
    val firstSprYPos by MemoryByteIndexed(FirstSprYPos)
    val hammerSprAttrib by MemoryByteIndexed(HammerSprAttrib)
    val miscSprdataoffset by MemoryByteIndexed(Misc_SprDataOffset)
    val miscState by MemoryByteIndexed(Misc_State)
    val secondSprTilenum by MemoryByteIndexed(SecondSprTilenum)
    val secondSprXPos by MemoryByteIndexed(SecondSprXPos)
    val secondSprYPos by MemoryByteIndexed(SecondSprYPos)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawHammer:
    //> ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
    Y = miscSprdataoffset[X]
    //> lda TimerControl
    A = timerControl
    //> bne ForceHPose              ;if master timer control set, skip this part
    X = X
    if (A == 0) {
        //> lda Misc_State,x            ;otherwise get hammer's state
        A = miscState[X]
        //> and #%01111111              ;mask out d7
        A = A and 0x7F
        //> cmp #$01                    ;check to see if set to 1 yet
        //> beq GetHPose                ;if so, branch
        if (A == 0x01) {
            //  goto GetHPose (internal forward branch)
            //> GetHPose:   lda FrameCounter            ;get frame counter
            A = frameCounter
            //> lsr                         ;move d3-d2 to d1-d0
            val orig0: Int = A
            A = orig0 shr 1
            //> lsr
            val orig1: Int = A
            A = orig1 shr 1
            //> and #%00000011              ;mask out all but d1-d0 (changes every four frames)
            A = A and 0x03
            //> tax                         ;use as timing offset
            X = A
            return
        }
    }
    //> ForceHPose: ldx #$00                    ;reset offset here
    X = 0x00
    //> beq RenderH                 ;do unconditional branch to rendering part
    if (X != 0) {
        //> GetHPose:   lda FrameCounter            ;get frame counter
        A = frameCounter
        //> lsr                         ;move d3-d2 to d1-d0
        val orig2: Int = A
        A = orig2 shr 1
        //> lsr
        val orig3: Int = A
        A = orig3 shr 1
        //> and #%00000011              ;mask out all but d1-d0 (changes every four frames)
        A = A and 0x03
        //> tax                         ;use as timing offset
        X = A
    }
    //> RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
    A = miscRelYpos
    //> clc
    //> adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
    temp0 = A + firstSprYPos[X]
    A = temp0 and 0xFF
    //> sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
    spriteYPosition[Y] = A
    //> clc
    //> adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
    temp1 = A + secondSprYPos[X]
    A = temp1 and 0xFF
    //> sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
    spriteYPosition[4 + Y] = A
    //> lda Misc_Rel_XPos           ;get relative horizontal coordinate
    A = miscRelXpos
    //> clc
    //> adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
    temp2 = A + firstSprXPos[X]
    A = temp2 and 0xFF
    //> sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
    spriteXPosition[Y] = A
    //> clc
    //> adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
    temp3 = A + secondSprXPos[X]
    A = temp3 and 0xFF
    //> sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
    spriteXPosition[4 + Y] = A
    //> lda FirstSprTilenum,x
    A = firstSprTilenum[X]
    //> sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
    spriteTilenumber[Y] = A
    //> lda SecondSprTilenum,x
    A = secondSprTilenum[X]
    //> sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
    spriteTilenumber[4 + Y] = A
    //> lda HammerSprAttrib,x
    A = hammerSprAttrib[X]
    //> sta Sprite_Attributes,y     ;get and store attribute bytes for both
    spriteAttributes[Y] = A
    //> sta Sprite_Attributes+4,y   ;note in this case they use the same data
    spriteAttributes[4 + Y] = A
    //> ldx ObjectOffset            ;get misc object offset
    X = objectOffset
    //> lda Misc_OffscreenBits
    A = miscOffscreenbits
    //> and #%11111100              ;check offscreen bits
    A = A and 0xFC
    //> beq NoHOffscr               ;if all bits clear, leave object alone
    if (A != 0) {
        //> lda #$00
        A = 0x00
        //> sta Misc_State,x            ;otherwise nullify misc object state
        miscState[X] = A
        //> lda #$f8
        A = 0xF8
        //> jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
        dumpTwoSpr(A, Y)
    }
    //> NoHOffscr:  rts                         ;leave
    return
}

// Decompiled from FlagpoleGfxHandler
fun flagpoleGfxHandler(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var flagpoleCollisionYPos by MemoryByte(FlagpoleCollisionYPos)
    var flagpolefnumYPos by MemoryByte(FlagpoleFNum_Y_Pos)
    var flagpoleScore by MemoryByte(FlagpoleScore)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flagpoleScoreNumTiles by MemoryByteIndexed(FlagpoleScoreNumTiles)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> FlagpoleGfxHandler:
    //> ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
    Y = enemySprdataoffset[X]
    //> lda Enemy_Rel_XPos             ;get relative horizontal coordinate
    A = enemyRelXpos
    //> sta Sprite_X_Position,y        ;store as X coordinate for first sprite
    spriteXPosition[Y] = A
    //> clc
    //> adc #$08                       ;add eight pixels and store
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
    spriteXPosition[4 + Y] = A
    //> sta Sprite_X_Position+8,y
    spriteXPosition[8 + Y] = A
    //> clc
    //> adc #$0c                       ;add twelve more pixels and
    temp1 = A + 0x0C
    A = temp1 and 0xFF
    //> sta $05                        ;store here to be used later by floatey number
    memory[0x5] = A.toUByte()
    //> lda Enemy_Y_Position,x         ;get vertical coordinate
    A = enemyYPosition[X]
    //> jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
    dumpTwoSpr(A, Y)
    //> adc #$08                       ;add eight pixels
    temp2 = A + 0x08
    A = temp2 and 0xFF
    //> sta Sprite_Y_Position+8,y      ;and store into third sprite
    spriteYPosition[8 + Y] = A
    //> lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
    A = flagpolefnumYPos
    //> sta $02                        ;store it here
    memory[0x2] = A.toUByte()
    //> lda #$01
    A = 0x01
    //> sta $03                        ;set value for flip which will not be used, and
    memory[0x3] = A.toUByte()
    //> sta $04                        ;attribute byte for floatey number
    memory[0x4] = A.toUByte()
    //> sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
    spriteAttributes[Y] = A
    //> sta Sprite_Attributes+4,y
    spriteAttributes[4 + Y] = A
    //> sta Sprite_Attributes+8,y
    spriteAttributes[8 + Y] = A
    //> lda #$7e
    A = 0x7E
    //> sta Sprite_Tilenumber,y        ;put triangle shaped tile
    spriteTilenumber[Y] = A
    //> sta Sprite_Tilenumber+8,y      ;into first and third sprites
    spriteTilenumber[8 + Y] = A
    //> lda #$7f
    A = 0x7F
    //> sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
    spriteTilenumber[4 + Y] = A
    //> lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
    A = flagpoleCollisionYPos
    //> beq ChkFlagOffscreen           ;if zero, branch ahead
    X = X
    if (A != 0) {
        //> tya
        A = Y
        //> clc                            ;add 12 bytes to sprite data offset
        //> adc #$0c
        temp3 = A + 0x0C
        A = temp3 and 0xFF
        //> tay                            ;put back in Y
        Y = A
        //> lda FlagpoleScore              ;get offset used to award points for touching flagpole
        A = flagpoleScore
        //> asl                            ;multiply by 2 to get proper offset here
        val orig0: Int = A
        A = (orig0 shl 1) and 0xFF
        //> tax
        X = A
        //> lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
        A = flagpoleScoreNumTiles[X]
        //> sta $00
        memory[0x0] = A.toUByte()
        //> lda FlagpoleScoreNumTiles+1,x
        A = flagpoleScoreNumTiles[1 + X]
        //> jsr DrawOneSpriteRow           ;use it to render floatey number
        temp4 = drawOneSpriteRow(A, X, Y)
        X = temp4
    }
    //> ChkFlagOffscreen:
    //> ldx ObjectOffset               ;get object offset for flag
    X = objectOffset
    //> ldy Enemy_SprDataOffset,x      ;get OAM data offset
    Y = enemySprdataoffset[X]
    //> lda Enemy_OffscreenBits        ;get offscreen bits
    A = enemyOffscreenbits
    //> and #%00001110                 ;mask out all but d3-d1
    A = A and 0x0E
    //> beq ExitDumpSpr                ;if none of these bits set, branch to leave
    if (A == 0) {
        //  goto ExitDumpSpr -> exitDumpSpr
        exitDumpSpr()
        return
    } else {
        //> ;-------------------------------------------------------------------------------------
        //  Fall-through tail call to moveSixSpritesOffscreen
        moveSixSpritesOffscreen(Y)
        return
    }
}

// Decompiled from MoveSixSpritesOffscreen
fun moveSixSpritesOffscreen(Y: Int) {
    var A: Int = 0
    //> MoveSixSpritesOffscreen:
    //> lda #$f8                  ;set offscreen coordinate if jumping here
    A = 0xF8
    //  Fall-through tail call to dumpSixSpr
    dumpSixSpr(A, Y)
    return
}

// Decompiled from DumpSixSpr
fun dumpSixSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpSixSpr:
    //> sta Sprite_Data+20,y      ;dump A contents
    spriteData[20 + Y] = A
    //> sta Sprite_Data+16,y      ;into third row sprites
    spriteData[16 + Y] = A
    //  Fall-through tail call to dumpFourSpr
    dumpFourSpr(A, Y)
    return
}

// Decompiled from DumpFourSpr
fun dumpFourSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpFourSpr:
    //> sta Sprite_Data+12,y      ;into second row sprites
    spriteData[12 + Y] = A
    //  Fall-through tail call to dumpThreeSpr
    dumpThreeSpr(A, Y)
    return
}

// Decompiled from DumpThreeSpr
fun dumpThreeSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpThreeSpr:
    //> sta Sprite_Data+8,y
    spriteData[8 + Y] = A
    //  Fall-through tail call to dumpTwoSpr
    dumpTwoSpr(A, Y)
    return
}

// Decompiled from DumpTwoSpr
fun dumpTwoSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpTwoSpr:
    //> sta Sprite_Data+4,y       ;and into first row sprites
    spriteData[4 + Y] = A
    //> sta Sprite_Data,y
    spriteData[Y] = A
    //  Fall-through tail call to exitDumpSpr
    exitDumpSpr()
    return
}

// Decompiled from ExitDumpSpr
fun exitDumpSpr() {
    //> ExitDumpSpr:
    //> rts
    return
}

// Decompiled from DrawLargePlatform
fun drawLargePlatform(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var objectOffset by MemoryByte(ObjectOffset)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawLargePlatform:
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    Y = enemySprdataoffset[X]
    //> sty $02                     ;store here
    memory[0x2] = Y.toUByte()
    //> iny                         ;add 3 to it for offset
    Y = (Y + 1) and 0xFF
    //> iny                         ;to X coordinate
    Y = (Y + 1) and 0xFF
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda Enemy_Rel_XPos          ;get horizontal relative coordinate
    A = enemyRelXpos
    //> jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
    temp0 = sixSpriteStacker(A, Y)
    //> ldx ObjectOffset
    X = objectOffset
    //> lda Enemy_Y_Position,x      ;get vertical coordinate
    A = enemyYPosition[X]
    //> jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
    dumpFourSpr(A, temp0)
    //> ldy AreaType
    Y = areaType
    //> cpy #$03                    ;check for castle-type level
    //> beq ShrinkPlatform
    if (Y != 0x03) {
        //> ldy SecondaryHardMode       ;check for secondary hard mode flag set
        Y = secondaryHardMode
        //> beq SetLast2Platform        ;branch if not set elsewhere
        if (Y != 0) {
        }
    }
    //> ShrinkPlatform:
    //> lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
    A = 0xF8
    //> SetLast2Platform:
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    Y = enemySprdataoffset[X]
    //> sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
    spriteYPosition[16 + Y] = A
    //> sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
    spriteYPosition[20 + Y] = A
    //> lda #$5b                    ;load default tile for platform (girder)
    A = 0x5B
    //> ldx CloudTypeOverride
    X = cloudTypeOverride
    //> beq SetPlatformTilenum      ;if cloud level override flag not set, use
    if (X != 0) {
        //> lda #$75                    ;otherwise load other tile for platform (puff)
        A = 0x75
    }
    //> SetPlatformTilenum:
    //> ldx ObjectOffset            ;get enemy object buffer offset
    X = objectOffset
    //> iny                         ;increment Y for tile offset
    Y = (Y + 1) and 0xFF
    //> jsr DumpSixSpr              ;dump tile number into all six sprites
    dumpSixSpr(A, Y)
    //> lda #$02                    ;set palette controls
    A = 0x02
    //> iny                         ;increment Y for sprite attributes
    Y = (Y + 1) and 0xFF
    //> jsr DumpSixSpr              ;dump attributes into all six sprites
    dumpSixSpr(A, Y)
    //> inx                         ;increment X for enemy objects
    X = (X + 1) and 0xFF
    //> jsr GetXOffscreenBits       ;get offscreen bits again
    val pair0 = getXOffscreenBits(X)
    temp1 = pair0.first
    temp2 = pair0.second
    X = temp2
    //> dex
    X = (X - 1) and 0xFF
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    Y = enemySprdataoffset[X]
    //> asl                         ;rotate d7 into carry, save remaining
    val orig0: Int = temp1
    temp1 = (orig0 shl 1) and 0xFF
    //> pha                         ;bits to the stack
    push(temp1)
    //> bcc SChk2
    A = temp1
    if ((orig0 and 0x80) != 0) {
        //> lda #$f8                    ;if d7 was set, move first sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position,y
        spriteYPosition[Y] = A
    }
    //> SChk2:  pla                         ;get bits from stack
    A = pull()
    //> asl                         ;rotate d6 into carry
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(A)
    //> bcc SChk3
    if ((orig1 and 0x80) != 0) {
        //> lda #$f8                    ;if d6 was set, move second sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position+4,y
        spriteYPosition[4 + Y] = A
    }
    //> SChk3:  pla                         ;get bits from stack
    A = pull()
    //> asl                         ;rotate d5 into carry
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(A)
    //> bcc SChk4
    if ((orig2 and 0x80) != 0) {
        //> lda #$f8                    ;if d5 was set, move third sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position+8,y
        spriteYPosition[8 + Y] = A
    }
    //> SChk4:  pla                         ;get bits from stack
    A = pull()
    //> asl                         ;rotate d4 into carry
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(A)
    //> bcc SChk5
    if ((orig3 and 0x80) != 0) {
        //> lda #$f8                    ;if d4 was set, move fourth sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position+12,y
        spriteYPosition[12 + Y] = A
    }
    //> SChk5:  pla                         ;get bits from stack
    A = pull()
    //> asl                         ;rotate d3 into carry
    val orig4: Int = A
    A = (orig4 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(A)
    //> bcc SChk6
    if ((orig4 and 0x80) != 0) {
        //> lda #$f8                    ;if d3 was set, move fifth sprite offscreen
        A = 0xF8
        //> sta Sprite_Y_Position+16,y
        spriteYPosition[16 + Y] = A
    }
    //> SChk6:  pla                         ;get bits from stack
    A = pull()
    //> asl                         ;rotate d2 into carry
    val orig5: Int = A
    A = (orig5 shl 1) and 0xFF
    //> bcc SLChk                   ;save to stack
    if ((orig5 and 0x80) != 0) {
        //> lda #$f8
        A = 0xF8
        //> sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
        spriteYPosition[20 + Y] = A
    }
    //> SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
    A = enemyOffscreenbits
    //> asl                         ;and if d7 is not set, skip sub
    val orig6: Int = A
    A = (orig6 shl 1) and 0xFF
    //> bcc ExDLPl
    if ((orig6 and 0x80) != 0) {
        //> jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
        moveSixSpritesOffscreen(Y)
    }
    //> ExDLPl: rts
    return X
}

// Decompiled from JCoinGfxHandler
fun jCoinGfxHandler(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var miscRelXpos by MemoryByte(Misc_Rel_XPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val jumpingCoinTiles by MemoryByteIndexed(JumpingCoinTiles)
    val miscSprdataoffset by MemoryByteIndexed(Misc_SprDataOffset)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> JCoinGfxHandler:
    //> ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
    Y = miscSprdataoffset[X]
    //> lda Misc_State,x            ;get state of misc object
    A = miscState[X]
    //> cmp #$02                    ;if 2 or greater,
    //> bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
    //> DrawFloateyNumber_Coin:
    //> lda FrameCounter          ;get frame counter
    A = frameCounter
    //> lsr                       ;divide by 2
    val orig0: Int = A
    A = orig0 shr 1
    //> bcs NotRsNum              ;branch if d0 not set to raise number every other frame
    X = X
    if ((orig0 and 0x01) == 0) {
        //> dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
        miscYPosition[X] = (miscYPosition[X] - 1) and 0xFF
    }
    //> NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
    A = miscYPosition[X]
    //> jsr DumpTwoSpr            ;dump into both sprites
    dumpTwoSpr(A, Y)
    //> lda Misc_Rel_XPos         ;get relative horizontal coordinate
    A = miscRelXpos
    //> sta Sprite_X_Position,y   ;store as X coordinate for first sprite
    spriteXPosition[Y] = A
    //> clc
    //> adc #$08                  ;add eight pixels
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
    spriteXPosition[4 + Y] = A
    //> lda #$02
    A = 0x02
    //> sta Sprite_Attributes,y   ;store attribute byte in both sprites
    spriteAttributes[Y] = A
    //> sta Sprite_Attributes+4,y
    spriteAttributes[4 + Y] = A
    //> lda #$f7
    A = 0xF7
    //> sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
    spriteTilenumber[Y] = A
    //> lda #$fb                  ;that resemble "200"
    A = 0xFB
    //> sta Sprite_Tilenumber+4,y
    spriteTilenumber[4 + Y] = A
    //> jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
    exJCGfx()
    return X
    //> lda Misc_Y_Position,x       ;store vertical coordinate as
    A = miscYPosition[X]
    //> sta Sprite_Y_Position,y     ;Y coordinate for first sprite
    spriteYPosition[Y] = A
    //> clc
    //> adc #$08                    ;add eight pixels
    temp1 = A + 0x08
    A = temp1 and 0xFF
    //> sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
    spriteYPosition[4 + Y] = A
    //> lda Misc_Rel_XPos           ;get relative horizontal coordinate
    A = miscRelXpos
    //> sta Sprite_X_Position,y
    spriteXPosition[Y] = A
    //> sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
    spriteXPosition[4 + Y] = A
    //> lda FrameCounter            ;get frame counter
    A = frameCounter
    //> lsr                         ;divide by 2 to alter every other frame
    val orig1: Int = A
    A = orig1 shr 1
    //> and #%00000011              ;mask out d2-d1
    A = A and 0x03
    //> tax                         ;use as graphical offset
    X = A
    //> lda JumpingCoinTiles,x      ;load tile number
    A = jumpingCoinTiles[X]
    //> iny                         ;increment OAM data offset to write tile numbers
    Y = (Y + 1) and 0xFF
    //> jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
    dumpTwoSpr(A, Y)
    //> dey                         ;decrement to get old offset
    Y = (Y - 1) and 0xFF
    //> lda #$02
    A = 0x02
    //> sta Sprite_Attributes,y     ;set attribute byte in first sprite
    spriteAttributes[Y] = A
    //> lda #$82
    A = 0x82
    //> sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
    spriteAttributes[4 + Y] = A
    //> ldx ObjectOffset            ;get misc object offset
    X = objectOffset
    //  Fall-through tail call to exJCGfx
    exJCGfx()
    return X
}

// Decompiled from ExJCGfx
fun exJCGfx() {
    //> ExJCGfx: rts                         ;leave
    return
}

// Decompiled from DrawPowerUp
fun drawPowerUp() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var frameCounter by MemoryByte(FrameCounter)
    var powerUpType by MemoryByte(PowerUpType)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val powerUpAttributes by MemoryByteIndexed(PowerUpAttributes)
    val powerUpGfxTable by MemoryByteIndexed(PowerUpGfxTable)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    //> DrawPowerUp:
    //> ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
    Y = enemySprdataoffset[5]
    //> lda Enemy_Rel_YPos         ;get relative vertical coordinate
    A = enemyRelYpos
    //> clc
    //> adc #$08                   ;add eight pixels
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> sta $02                    ;store result here
    memory[0x2] = A.toUByte()
    //> lda Enemy_Rel_XPos         ;get relative horizontal coordinate
    A = enemyRelXpos
    //> sta $05                    ;store here
    memory[0x5] = A.toUByte()
    //> ldx PowerUpType            ;get power-up type
    X = powerUpType
    //> lda PowerUpAttributes,x    ;get attribute data for power-up type
    A = powerUpAttributes[X]
    //> ora Enemy_SprAttrib+5      ;add background priority bit if set
    A = A or enemySprattrib[5]
    //> sta $04                    ;store attributes here
    memory[0x4] = A.toUByte()
    //> txa
    A = X
    //> pha                        ;save power-up type to the stack
    push(A)
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                        ;multiply by four to get proper offset
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> tax                        ;use as X
    X = A
    //> lda #$01
    A = 0x01
    //> sta $07                    ;set counter here to draw two rows of sprite object
    memory[0x7] = A.toUByte()
    //> sta $03                    ;init d1 of flip control
    memory[0x3] = A.toUByte()
    loop0@ do {
        //> PUpDrawLoop:
        //> lda PowerUpGfxTable,x      ;load left tile of power-up object
        A = powerUpGfxTable[X]
        //> sta $00
        memory[0x0] = A.toUByte()
        //> lda PowerUpGfxTable+1,x    ;load right tile
        A = powerUpGfxTable[1 + X]
        //> jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
        temp1 = drawOneSpriteRow(A, X, Y)
        X = temp1
        //> dec $07                    ;decrement counter
        memory[0x7] = ((memory[0x7].toInt() - 1) and 0xFF).toUByte()
        //> bpl PUpDrawLoop            ;branch until two rows are drawn
        if (!((memory[0x7].toInt() and 0x80) != 0)) {
            //  continue loop (branch back to PUpDrawLoop)
            continue@loop0
        }
    } while ((memory[0x7].toInt() and 0x80) == 0)
    //> ldy Enemy_SprDataOffset+5  ;get sprite data offset again
    Y = enemySprdataoffset[5]
    //> pla                        ;pull saved power-up type from the stack
    A = pull()
    //> beq PUpOfs                 ;if regular mushroom, branch, do not change colors or flip
    X = temp1
    if (A != 0) {
        //> cmp #$03
        //> beq PUpOfs                 ;if 1-up mushroom, branch, do not change colors or flip
        if (A != 0x03) {
            //> sta $00                    ;store power-up type here now
            memory[0x0] = A.toUByte()
            //> lda FrameCounter           ;get frame counter
            A = frameCounter
            //> lsr                        ;divide by 2 to change colors every two frames
            val orig2: Int = A
            A = orig2 shr 1
            //> and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
            A = A and 0x03
            //> ora Enemy_SprAttrib+5      ;add background priority bit if any set
            A = A or enemySprattrib[5]
            //> sta Sprite_Attributes,y    ;set as new palette bits for top left and
            spriteAttributes[Y] = A
            //> sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
            spriteAttributes[4 + Y] = A
            //> ldx $00
            X = memory[0x0].toInt()
            //> dex                        ;check power-up type for fire flower
            X = (X - 1) and 0xFF
            //> beq FlipPUpRightSide       ;if found, skip this part
            if (X != 0) {
                //> sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
                spriteAttributes[8 + Y] = A
                //> sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
                spriteAttributes[12 + Y] = A
            }
            //> FlipPUpRightSide:
            //> lda Sprite_Attributes+4,y
            A = spriteAttributes[4 + Y]
            //> ora #%01000000             ;set horizontal flip bit for top right sprite
            A = A or 0x40
            //> sta Sprite_Attributes+4,y
            spriteAttributes[4 + Y] = A
            //> lda Sprite_Attributes+12,y
            A = spriteAttributes[12 + Y]
            //> ora #%01000000             ;set horizontal flip bit for bottom right sprite
            A = A or 0x40
            //> sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
            spriteAttributes[12 + Y] = A
        }
    }
    //> PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
    sprObjectOffscrChk()
    return
}

// Decompiled from EnemyGfxHandler
fun enemyGfxHandler(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var frameCounter by MemoryByte(FrameCounter)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    var verticalFlipFlag by MemoryByte(VerticalFlipFlag)
    val enemyAttributeData by MemoryByteIndexed(EnemyAttributeData)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyGfxTableOffsets by MemoryByteIndexed(EnemyGfxTableOffsets)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val jumpspringFrameOffsets by MemoryByteIndexed(JumpspringFrameOffsets)
    val piranhaplantYSpeed by MemoryByteIndexed(PiranhaPlant_Y_Speed)
    //> EnemyGfxHandler:
    //> lda Enemy_Y_Position,x      ;get enemy object vertical position
    A = enemyYPosition[X]
    //> sta $02
    memory[0x2] = A.toUByte()
    //> lda Enemy_Rel_XPos          ;get enemy object horizontal position
    A = enemyRelXpos
    //> sta $05                     ;relative to screen
    memory[0x5] = A.toUByte()
    //> ldy Enemy_SprDataOffset,x
    Y = enemySprdataoffset[X]
    //> sty $eb                     ;get sprite data offset
    memory[0xEB] = Y.toUByte()
    //> lda #$00
    A = 0x00
    //> sta VerticalFlipFlag        ;initialize vertical flip flag by default
    verticalFlipFlag = A
    //> lda Enemy_MovingDir,x
    A = enemyMovingdir[X]
    //> sta $03                     ;get enemy object moving direction
    memory[0x3] = A.toUByte()
    //> lda Enemy_SprAttrib,x
    A = enemySprattrib[X]
    //> sta $04                     ;get enemy object sprite attributes
    memory[0x4] = A.toUByte()
    //> lda Enemy_ID,x
    A = enemyId[X]
    //> cmp #PiranhaPlant           ;is enemy object piranha plant?
    //> bne CheckForRetainerObj     ;if not, branch
    X = X
    if (A == PiranhaPlant) {
        //> ldy PiranhaPlant_Y_Speed,x
        Y = piranhaplantYSpeed[X]
        //> bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
        if ((Y and 0x80) == 0) {
            //> ldy EnemyFrameTimer,x
            Y = enemyFrameTimer[X]
            //> beq CheckForRetainerObj     ;if timer for movement expired, branch
            if (Y != 0) {
                //> rts                         ;if all conditions fail, leave
                return Pair(X, Y)
            }
        }
    }
    //> CheckForRetainerObj:
    //> lda Enemy_State,x           ;store enemy state
    A = enemyState[X]
    //> sta $ed
    memory[0xED] = A.toUByte()
    //> and #%00011111              ;nullify all but 5 LSB and use as Y
    A = A and 0x1F
    //> tay
    Y = A
    //> lda Enemy_ID,x              ;check for mushroom retainer/princess object
    A = enemyId[X]
    //> cmp #RetainerObject
    //> bne CheckForBulletBillCV    ;if not found, branch
    if (A == RetainerObject) {
        //> ldy #$00                    ;if found, nullify saved state in Y
        Y = 0x00
        //> lda #$01                    ;set value that will not be used
        A = 0x01
        //> sta $03
        memory[0x3] = A.toUByte()
        //> lda #$15                    ;set value $15 as code for mushroom retainer/princess object
        A = 0x15
    }
    //> CheckForBulletBillCV:
    //> cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
    //> bne CheckForJumpspring      ;if not found, branch again
    if (A == BulletBill_CannonVar) {
        //> dec $02                     ;decrement saved vertical position
        memory[0x2] = ((memory[0x2].toInt() - 1) and 0xFF).toUByte()
        //> lda #$03
        A = 0x03
        //> ldy EnemyFrameTimer,x       ;get timer for enemy object
        Y = enemyFrameTimer[X]
        //> beq SBBAt                   ;if expired, do not set priority bit
        if (Y != 0) {
            //> ora #%00100000              ;otherwise do so
            A = A or 0x20
        }
        //> SBBAt: sta $04                     ;set new sprite attributes
        memory[0x4] = A.toUByte()
        //> ldy #$00                    ;nullify saved enemy state both in Y and in
        Y = 0x00
        //> sty $ed                     ;memory location here
        memory[0xED] = Y.toUByte()
        //> lda #$08                    ;set specific value to unconditionally branch once
        A = 0x08
    }
    //> CheckForJumpspring:
    //> cmp #JumpspringObject        ;check for jumpspring object
    //> bne CheckForPodoboo
    if (A == JumpspringObject) {
        //> ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
        Y = 0x03
        //> ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
        X = jumpspringAnimCtrl
        //> lda JumpspringFrameOffsets,x ;load data using frame number as offset
        A = jumpspringFrameOffsets[X]
    }
    //> CheckForPodoboo:
    //> sta $ef                 ;store saved enemy object value here
    memory[0xEF] = A.toUByte()
    //> sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
    memory[0xEC] = Y.toUByte()
    //> ldx ObjectOffset        ;get enemy object offset
    X = objectOffset
    //> cmp #$0c                ;check for podoboo object
    //> bne CheckBowserGfxFlag  ;branch if not found
    if (A == 0x0C) {
        //> lda Enemy_Y_Speed,x     ;if moving upwards, branch
        A = enemyYSpeed[X]
        //> bmi CheckBowserGfxFlag
        if ((A and 0x80) == 0) {
            //> inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
            verticalFlipFlag = (verticalFlipFlag + 1) and 0xFF
        }
    }
    //> CheckBowserGfxFlag:
    //> lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
    A = bowserGfxFlag
    //> beq CheckForGoomba
    if (A != 0) {
        //> ldy #$16            ;if set to 1, draw bowser's front
        Y = 0x16
        //> cmp #$01
        //> beq SBwsrGfxOfs
        if (A != 0x01) {
            //> iny                 ;otherwise draw bowser's rear
            Y = (Y + 1) and 0xFF
        }
        //> SBwsrGfxOfs: sty $ef
        memory[0xEF] = Y.toUByte()
    }
    //> CheckForGoomba:
    //> ldy $ef               ;check value for goomba object
    Y = memory[0xEF].toInt()
    //> cpy #Goomba
    //> bne CheckBowserFront  ;branch if not found
    if (Y == Goomba) {
        //> lda Enemy_State,x
        A = enemyState[X]
        //> cmp #$02              ;check for defeated state
        //> bcc GmbaAnim          ;if not defeated, go ahead and animate
        if (A >= 0x02) {
            //> ldx #$04              ;if defeated, write new value here
            X = 0x04
            //> stx $ec
            memory[0xEC] = X.toUByte()
        }
        //> GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
        A = A and 0x20
        //> ora TimerControl      ;or timer disable flag set
        A = A or timerControl
        //> bne CheckBowserFront  ;if either condition true, do not animate goomba
        if (A == 0) {
            //> lda FrameCounter
            A = frameCounter
            //> and #%00001000        ;check for every eighth frame
            A = A and 0x08
            //> bne CheckBowserFront
            if (A == 0) {
                //> lda $03
                A = memory[0x3].toInt()
                //> eor #%00000011        ;invert bits to flip horizontally every eight frames
                A = A xor 0x03
                //> sta $03               ;leave alone otherwise
                memory[0x3] = A.toUByte()
            }
        }
    }
    //> CheckBowserFront:
    //> lda EnemyAttributeData,y    ;load sprite attribute using enemy object
    A = enemyAttributeData[Y]
    //> ora $04                     ;as offset, and add to bits already loaded
    A = A or memory[0x4].toInt()
    //> sta $04
    memory[0x4] = A.toUByte()
    //> lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
    A = enemyGfxTableOffsets[Y]
    //> tax                         ;save as X
    X = A
    //> ldy $ec                     ;get previously saved value
    Y = memory[0xEC].toInt()
    //> lda BowserGfxFlag
    A = bowserGfxFlag
    //> beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
    if (A != 0) {
        //> cmp #$01
        //> bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
        if (A == 0x01) {
            //> lda BowserBodyControls      ;check bowser's body control bits
            A = bowserBodyControls
            //> bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
            if ((A and 0x80) != 0) {
                //> ldx #$de                    ;otherwise load offset for second frame
                X = 0xDE
            }
            //> ChkFrontSte: lda $ed                     ;check saved enemy state
            A = memory[0xED].toInt()
            //> and #%00100000              ;if bowser not defeated, do not set flag
            A = A and 0x20
            //> beq DrawBowser
            if (A == 0) {
                //  goto DrawBowser -> drawBowser
                drawBowser(X)
                return Pair(X, Y)
            }
            //  Fall-through tail call to flipBowserOver
            flipBowserOver(X)
            return Pair(X, Y)
        }
        //> CheckBowserRear:
        //> lda BowserBodyControls  ;check bowser's body control bits
        A = bowserBodyControls
        //> and #$01
        A = A and 0x01
        //> beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
        if (A != 0) {
            //> ldx #$e4                ;otherwise load offset for second frame
            X = 0xE4
        }
        //> ChkRearSte: lda $ed                 ;check saved enemy state
        A = memory[0xED].toInt()
        //> and #%00100000          ;if bowser not defeated, do not set flag
        A = A and 0x20
        //> beq DrawBowser
        if (A == 0) {
            //> DrawBowser:
            //> jmp DrawEnemyObject   ;draw bowser's graphics now
            drawEnemyObject(X)
            return Pair(X, Y)
        }
        //> lda $02                 ;subtract 16 pixels from
        A = memory[0x2].toInt()
        //> sec                     ;saved vertical coordinate
        //> sbc #$10
        temp0 = A - 0x10
        A = temp0 and 0xFF
        //> sta $02
        memory[0x2] = A.toUByte()
        //> jmp FlipBowserOver      ;jump to set vertical flip flag
        flipBowserOver(X)
        return Pair(X, Y)
    } else {
        //> CheckForSpiny:
        //> cpx #$24               ;check if value loaded is for spiny
        //> bne CheckForLakitu     ;if not found, branch
        if (X == 0x24) {
            //> cpy #$05               ;if enemy state set to $05, do this,
            //> bne NotEgg             ;otherwise branch
            if (Y == 0x05) {
                //> ldx #$30               ;set to spiny egg offset
                X = 0x30
                //> lda #$02
                A = 0x02
                //> sta $03                ;set enemy direction to reverse sprites horizontally
                memory[0x3] = A.toUByte()
                //> lda #$05
                A = 0x05
                //> sta $ec                ;set enemy state
                memory[0xEC] = A.toUByte()
            }
            //> NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
            return checkForHammerBro(X)
        }
    }
    //> CheckForLakitu:
    //> cpx #$90                  ;check value for lakitu's offset loaded
    //> bne CheckUpsideDownShell  ;branch if not loaded
    if (X == 0x90) {
        //> lda $ed
        A = memory[0xED].toInt()
        //> and #%00100000            ;check for d5 set in enemy state
        A = A and 0x20
        //> bne NoLAFr                ;branch if set
        if (A == 0) {
            //> lda FrenzyEnemyTimer
            A = frenzyEnemyTimer
            //> cmp #$10                  ;check timer to see if we've reached a certain range
            //> bcs NoLAFr                ;branch if not
            if (!(A >= 0x10)) {
                //> ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
                X = 0x96
            }
        }
        //> NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
        checkDefeatedState(X)
        return Pair(X, Y)
    } else {
        //> CheckUpsideDownShell:
        //> lda $ef                    ;check for enemy object => $04
        A = memory[0xEF].toInt()
        //> cmp #$04
        //> bcs CheckRightSideUpShell  ;branch if true
        if (!(A >= 0x04)) {
            //> cpy #$02
            //> bcc CheckRightSideUpShell  ;branch if enemy state < $02
            if (Y >= 0x02) {
                //> ldx #$5a                   ;set for upside-down koopa shell by default
                X = 0x5A
                //> ldy $ef
                Y = memory[0xEF].toInt()
                //> cpy #BuzzyBeetle           ;check for buzzy beetle object
                //> bne CheckRightSideUpShell
                if (Y == BuzzyBeetle) {
                    //> ldx #$7e                   ;set for upside-down buzzy beetle shell if found
                    X = 0x7E
                    //> inc $02                    ;increment vertical position by one pixel
                    memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
                }
            }
        }
    }
    //> CheckRightSideUpShell:
    //> lda $ec                ;check for value set here
    A = memory[0xEC].toInt()
    //> cmp #$04               ;if enemy state < $02, do not change to shell, if
    //> bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
    if (!(A == 0x04)) {
        //  goto CheckForHammerBro -> checkForHammerBro
        checkForHammerBro(X)
        return Pair(X, Y)
    } else {
        //> ldx #$72               ;set right-side up buzzy beetle shell by default
        X = 0x72
        //> inc $02                ;increment saved vertical position by one pixel
        memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
        //> ldy $ef
        Y = memory[0xEF].toInt()
        //> cpy #BuzzyBeetle       ;check for buzzy beetle object
        //> beq CheckForDefdGoomba ;branch if found
        if (Y != BuzzyBeetle) {
            //> ldx #$66               ;change to right-side up koopa shell if not found
            X = 0x66
            //> inc $02                ;and increment saved vertical position again
            memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
        }
    }
    //> CheckForDefdGoomba:
    //> cpy #Goomba            ;check for goomba object (necessary if previously
    //> bne CheckForHammerBro  ;failed buzzy beetle object test)
    if (!(Y == Goomba)) {
        //  goto CheckForHammerBro -> checkForHammerBro
        checkForHammerBro(X)
        return Pair(X, Y)
    } else {
        //> ldx #$54               ;load for regular goomba
        X = 0x54
        //> lda $ed                ;note that this only gets performed if enemy state => $02
        A = memory[0xED].toInt()
        //> and #%00100000         ;check saved enemy state for d5 set
        A = A and 0x20
        //> bne CheckForHammerBro  ;branch if set
        if (!(A == 0)) {
            //  goto CheckForHammerBro -> checkForHammerBro
            checkForHammerBro(X)
            return Pair(X, Y)
        }
    }
    //> ldx #$8a               ;load offset for defeated goomba
    X = 0x8A
    //> dec $02                ;set different value and decrement saved vertical position
    memory[0x2] = ((memory[0x2].toInt() - 1) and 0xFF).toUByte()
    //  Fall-through tail call to checkForHammerBro
    return checkForHammerBro(X)
}

// Decompiled from FlipBowserOver
fun flipBowserOver(X: Int) {
    var verticalFlipFlag by MemoryByte(VerticalFlipFlag)
    //> FlipBowserOver:
    //> stx VerticalFlipFlag  ;set vertical flip flag to nonzero
    verticalFlipFlag = X
    //  Fall-through tail call to drawBowser
    drawBowser(X)
    return
}

// Decompiled from DrawBowser
fun drawBowser(X: Int) {
    //> DrawBowser:
    //> jmp DrawEnemyObject   ;draw bowser's graphics now
    drawEnemyObject(X)
    return
}

// Decompiled from CheckForHammerBro
fun checkForHammerBro(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var worldNumber by MemoryByte(WorldNumber)
    val enemyAnimTimingBMask by MemoryByteIndexed(EnemyAnimTimingBMask)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    //> CheckForHammerBro:
    //> ldy ObjectOffset
    Y = objectOffset
    //> lda $ef                  ;check for hammer bro object
    A = memory[0xEF].toInt()
    //> cmp #HammerBro
    //> bne CheckForBloober      ;branch if not found
    X = X
    if (A == HammerBro) {
        //> lda $ed
        A = memory[0xED].toInt()
        //> beq CheckToAnimateEnemy  ;branch if not in normal enemy state
        if (A != 0) {
            //> and #%00001000
            A = A and 0x08
            //> beq CheckDefeatedState   ;if d3 not set, branch further away
            if (A == 0) {
                //  goto CheckDefeatedState -> checkDefeatedState
                checkDefeatedState(X)
                return Pair(X, Y)
            }
            //> ldx #$b4                 ;otherwise load offset for different frame
            X = 0xB4
            //> bne CheckToAnimateEnemy  ;unconditional branch
            if (X == 0) {
            }
        }
    }
    //> CheckForBloober:
    //> cpx #$48                 ;check for cheep-cheep offset loaded
    //> beq CheckToAnimateEnemy  ;branch if found
    if (X != 0x48) {
        //> lda EnemyIntervalTimer,y
        A = enemyIntervalTimer[Y]
        //> cmp #$05
        //> bcs CheckDefeatedState   ;branch if some timer is above a certain point
        if (A >= 0x05) {
            //  goto CheckDefeatedState -> checkDefeatedState
            checkDefeatedState(X)
            return Pair(X, Y)
        }
        //> cpx #$3c                 ;check for bloober offset loaded
        //> bne CheckToAnimateEnemy  ;branch if not found this time
        if (X == 0x3C) {
            //> cmp #$01
            //> beq CheckDefeatedState   ;branch if timer is set to certain point
            if (A == 0x01) {
                //  goto CheckDefeatedState -> checkDefeatedState
                checkDefeatedState(X)
                return Pair(X, Y)
            }
            //> inc $02                  ;increment saved vertical coordinate three pixels
            memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
            //> inc $02
            memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
            //> inc $02
            memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
            //> jmp CheckAnimationStop   ;and do something else
            return checkAnimationStop(X)
        }
    }
    //> CheckToAnimateEnemy:
    //> lda $ef                  ;check for specific enemy objects
    A = memory[0xEF].toInt()
    //> cmp #Goomba
    //> beq CheckDefeatedState   ;branch if goomba
    if (A == Goomba) {
        //  goto CheckDefeatedState -> checkDefeatedState
        checkDefeatedState(X)
        return Pair(X, Y)
    } else {
        //> cmp #$08
        //> beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
        if (A == 0x08) {
            //  goto CheckDefeatedState -> checkDefeatedState
            checkDefeatedState(X)
            return Pair(X, Y)
        }
    }
    //> cmp #Podoboo
    //> beq CheckDefeatedState   ;branch if podoboo
    if (A == Podoboo) {
        //  goto CheckDefeatedState -> checkDefeatedState
        checkDefeatedState(X)
        return Pair(X, Y)
    } else {
        //> cmp #$18                 ;branch if => $18
        //> bcs CheckDefeatedState
        if (A >= 0x18) {
            //  goto CheckDefeatedState -> checkDefeatedState
            checkDefeatedState(X)
            return Pair(X, Y)
        }
    }
    //> ldy #$00
    Y = 0x00
    //> cmp #$15                 ;check for mushroom retainer/princess object
    //> bne CheckForSecondFrame  ;which uses different code here, branch if not found
    if (A == 0x15) {
        //> iny                      ;residual instruction
        Y = (Y + 1) and 0xFF
        //> lda WorldNumber          ;are we on world 8?
        A = worldNumber
        //> cmp #World8
        //> bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
        if (A >= World8) {
            //  goto CheckDefeatedState -> checkDefeatedState
            checkDefeatedState(X)
            return Pair(X, Y)
        }
        //> ldx #$a2                 ;otherwise, set for mushroom retainer object instead
        X = 0xA2
        //> lda #$03                 ;set alternate state here
        A = 0x03
        //> sta $ec
        memory[0xEC] = A.toUByte()
        //> bne CheckDefeatedState   ;unconditional branch
        if (!(A == 0)) {
            //  goto CheckDefeatedState -> checkDefeatedState
            checkDefeatedState(X)
            return Pair(X, Y)
        }
    }
    //> CheckForSecondFrame:
    //> lda FrameCounter            ;load frame counter
    A = frameCounter
    //> and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
    A = A and enemyAnimTimingBMask[Y]
    //> bne CheckDefeatedState      ;branch if timing is off
    if (!(A == 0)) {
        //  goto CheckDefeatedState -> checkDefeatedState
        checkDefeatedState(X)
        return Pair(X, Y)
    } else {
        //  Fall-through tail call to checkAnimationStop
        return checkAnimationStop(X)
    }
}

// Decompiled from CheckAnimationStop
fun checkAnimationStop(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> CheckAnimationStop:
    //> lda $ed                 ;check saved enemy state
    A = memory[0xED].toInt()
    //> and #%10100000          ;for d7 or d5, or check for timers stopped
    A = A and 0xA0
    //> ora TimerControl
    A = A or timerControl
    //> bne CheckDefeatedState  ;if either condition true, branch
    if (!(A == 0)) {
        //  goto CheckDefeatedState -> checkDefeatedState
        checkDefeatedState(X)
        return Pair(X, Y)
    } else {
        //> txa
        A = X
        //> clc
        //> adc #$06                ;add $06 to current enemy offset
        temp0 = A + 0x06
        A = temp0 and 0xFF
        //> tax                     ;to animate various enemy objects
        X = A
        //  Fall-through tail call to checkDefeatedState
        checkDefeatedState(X)
        return Pair(X, Y)
    }
}

// Decompiled from CheckDefeatedState
fun checkDefeatedState(X: Int): Int {
    var A: Int = 0
    var Y: Int = 0
    var verticalFlipFlag by MemoryByte(VerticalFlipFlag)
    //> CheckDefeatedState:
    //> lda $ed               ;check saved enemy state
    A = memory[0xED].toInt()
    //> and #%00100000        ;for d5 set
    A = A and 0x20
    //> beq DrawEnemyObject   ;branch if not set
    if (A == 0) {
        //  goto DrawEnemyObject -> drawEnemyObject
        drawEnemyObject(X)
        return Y
    } else {
        //> lda $ef
        A = memory[0xEF].toInt()
        //> cmp #$04              ;check for saved enemy object => $04
        //> bcc DrawEnemyObject   ;branch if less
        if (!(A >= 0x04)) {
            //  goto DrawEnemyObject -> drawEnemyObject
            drawEnemyObject(X)
            return Y
        }
    }
    //> ldy #$01
    Y = 0x01
    //> sty VerticalFlipFlag  ;set vertical flip flag
    verticalFlipFlag = Y
    //> dey
    Y = (Y - 1) and 0xFF
    //> sty $ec               ;init saved value here
    memory[0xEC] = Y.toUByte()
    //  Fall-through tail call to drawEnemyObject
    drawEnemyObject(X)
    return Y
}

// Decompiled from DrawEnemyObject
fun drawEnemyObject(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    var verticalFlipFlag by MemoryByte(VerticalFlipFlag)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    //> DrawEnemyObject:
    //> ldy $eb                    ;load sprite data offset
    Y = memory[0xEB].toInt()
    //> jsr DrawEnemyObjRow        ;draw six tiles of data
    temp0 = drawEnemyObjRow(X, Y)
    X = temp0
    //> jsr DrawEnemyObjRow        ;into sprite data
    temp1 = drawEnemyObjRow(temp0, Y)
    X = temp1
    //> jsr DrawEnemyObjRow
    temp2 = drawEnemyObjRow(temp1, Y)
    X = temp2
    //> ldx ObjectOffset           ;get enemy object offset
    X = objectOffset
    //> ldy Enemy_SprDataOffset,x  ;get sprite data offset
    Y = enemySprdataoffset[X]
    //> lda $ef
    A = memory[0xEF].toInt()
    //> cmp #$08                   ;get saved enemy object and check
    //> bne CheckForVerticalFlip   ;for bullet bill, branch if not found
    if (A == 0x08) {
        //> SkipToOffScrChk:
        //> jmp SprObjectOffscrChk     ;jump if found
        sprObjectOffscrChk()
        return
    } else {
        //> CheckForVerticalFlip:
        //> lda VerticalFlipFlag       ;check if vertical flip flag is set here
        A = verticalFlipFlag
        //> beq CheckForESymmetry      ;branch if not
        if (A != 0) {
            //> lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
            A = spriteAttributes[Y]
            //> ora #%10000000             ;set bit for vertical flip
            A = A or 0x80
            //> iny
            Y = (Y + 1) and 0xFF
            //> iny                        ;increment two bytes so that we store the vertical flip
            Y = (Y + 1) and 0xFF
            //> jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
            dumpSixSpr(A, Y)
            //> dey
            Y = (Y - 1) and 0xFF
            //> dey                        ;now go back to the Y coordinate offset
            Y = (Y - 1) and 0xFF
            //> tya
            A = Y
            //> tax                        ;give offset to X
            X = A
            //> lda $ef
            A = memory[0xEF].toInt()
            //> cmp #HammerBro             ;check saved enemy object for hammer bro
            //> beq FlipEnemyVertically
            if (A != HammerBro) {
                //> cmp #Lakitu                ;check saved enemy object for lakitu
                //> beq FlipEnemyVertically    ;branch for hammer bro or lakitu
                if (A != Lakitu) {
                    //> cmp #$15
                    //> bcs FlipEnemyVertically    ;also branch if enemy object => $15
                    if (!(A >= 0x15)) {
                        //> txa
                        A = X
                        //> clc
                        //> adc #$08                   ;if not selected objects or => $15, set
                        temp3 = A + 0x08
                        A = temp3 and 0xFF
                        //> tax                        ;offset in X for next row
                        X = A
                    }
                }
            }
            //> FlipEnemyVertically:
            //> lda Sprite_Tilenumber,x     ;load first or second row tiles
            A = spriteTilenumber[X]
            //> pha                         ;and save tiles to the stack
            push(A)
            //> lda Sprite_Tilenumber+4,x
            A = spriteTilenumber[4 + X]
            //> pha
            push(A)
            //> lda Sprite_Tilenumber+16,y  ;exchange third row tiles
            A = spriteTilenumber[16 + Y]
            //> sta Sprite_Tilenumber,x     ;with first or second row tiles
            spriteTilenumber[X] = A
            //> lda Sprite_Tilenumber+20,y
            A = spriteTilenumber[20 + Y]
            //> sta Sprite_Tilenumber+4,x
            spriteTilenumber[4 + X] = A
            //> pla                         ;pull first or second row tiles from stack
            A = pull()
            //> sta Sprite_Tilenumber+20,y  ;and save in third row
            spriteTilenumber[20 + Y] = A
            //> pla
            A = pull()
            //> sta Sprite_Tilenumber+16,y
            spriteTilenumber[16 + Y] = A
        }
    }
    //> CheckForESymmetry:
    //> lda BowserGfxFlag           ;are we drawing bowser at all?
    A = bowserGfxFlag
    //> bne SkipToOffScrChk         ;branch if so
    if (A != 0) {
        //> SkipToOffScrChk:
        //> jmp SprObjectOffscrChk     ;jump if found
        sprObjectOffscrChk()
        return
    } else {
        //> lda $ef
        A = memory[0xEF].toInt()
        //> ldx $ec                     ;get alternate enemy state
        X = memory[0xEC].toInt()
        //> cmp #$05                    ;check for hammer bro object
        //> bne ContES
        if (A == 0x05) {
            //> jmp SprObjectOffscrChk      ;jump if found
            sprObjectOffscrChk()
            return
        }
    }
    //> ContES: cmp #Bloober                ;check for bloober object
    //> beq MirrorEnemyGfx
    if (A != Bloober) {
        //> cmp #PiranhaPlant           ;check for piranha plant object
        //> beq MirrorEnemyGfx
        if (A != PiranhaPlant) {
            //> cmp #Podoboo                ;check for podoboo object
            //> beq MirrorEnemyGfx          ;branch if either of three are found
            if (A != Podoboo) {
                //> cmp #Spiny                  ;check for spiny object
                //> bne ESRtnr                  ;branch closer if not found
                if (A == Spiny) {
                    //> cpx #$05                    ;check spiny's state
                    //> bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
                    if (!(X == 0x05)) {
                        //  goto CheckToMirrorLakitu (internal forward branch)
                        //> CheckToMirrorLakitu:
                        //> lda $ef                     ;check for lakitu enemy object
                        A = memory[0xEF].toInt()
                        //> cmp #Lakitu
                        //> bne CheckToMirrorJSpring    ;branch if not found
                        if (!(A == Lakitu)) {
                            //  goto CheckToMirrorJSpring (internal forward branch)
                            //> CheckToMirrorJSpring:
                            //> lda $ef                     ;check for jumpspring object (any frame)
                            A = memory[0xEF].toInt()
                            //> cmp #$18
                            //> bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
                            if (!(A >= 0x18)) {
                                //  goto SprObjectOffscrChk -> sprObjectOffscrChk
                                sprObjectOffscrChk()
                                return
                            }
                            //> lda #$82
                            A = 0x82
                            //> sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
                            spriteAttributes[8 + Y] = A
                            //> sta Sprite_Attributes+16,y  ;second and third row left sprites
                            spriteAttributes[16 + Y] = A
                            //> ora #%01000000
                            A = A or 0x40
                            //> sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
                            spriteAttributes[12 + Y] = A
                            //> sta Sprite_Attributes+20,y  ;for second and third row right sprites
                            spriteAttributes[20 + Y] = A
                            //  Fall-through tail call to sprObjectOffscrChk
                            sprObjectOffscrChk()
                            return
                        }
                        //> lda VerticalFlipFlag
                        A = verticalFlipFlag
                        //> bne NVFLak                  ;branch if vertical flip flag not set
                        if (!(A == 0)) {
                            //  goto NVFLak (internal forward branch)
                            //> NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
                            A = spriteAttributes[Y]
                            //> and #%10000001
                            A = A and 0x81
                            //> sta Sprite_Attributes,y     ;save vertical flip and palette bits
                            spriteAttributes[Y] = A
                            //> lda Sprite_Attributes+4,y   ;get first row right sprite attributes
                            A = spriteAttributes[4 + Y]
                            //> ora #%01000001              ;set horizontal flip and palette bits
                            A = A or 0x41
                            //> sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
                            spriteAttributes[4 + Y] = A
                            return
                        }
                        //> lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
                        A = spriteAttributes[16 + Y]
                        //> and #%10000001              ;in third row left sprite
                        A = A and 0x81
                        //> sta Sprite_Attributes+16,y
                        spriteAttributes[16 + Y] = A
                        //> lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
                        A = spriteAttributes[20 + Y]
                        //> ora #%01000001              ;in third row right sprite
                        A = A or 0x41
                        //> sta Sprite_Attributes+20,y
                        spriteAttributes[20 + Y] = A
                        //> ldx FrenzyEnemyTimer        ;check timer
                        X = frenzyEnemyTimer
                        //> cpx #$10
                        //> bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
                        if (X >= 0x10) {
                            //  goto SprObjectOffscrChk -> sprObjectOffscrChk
                            sprObjectOffscrChk()
                            return
                        }
                        //> sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
                        spriteAttributes[12 + Y] = A
                        //> and #%10000001
                        A = A and 0x81
                        //> sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
                        spriteAttributes[8 + Y] = A
                        //> bcc SprObjectOffscrChk      ;unconditional branch
                        if (!(X >= 0x10)) {
                            //  goto SprObjectOffscrChk -> sprObjectOffscrChk
                            sprObjectOffscrChk()
                            return
                        }
                        return
                    }
                }
                //> ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
                //> bne SpnySC
                if (A == 0x15) {
                    //> lda #$42                    ;set horizontal flip on bottom right sprite
                    A = 0x42
                    //> sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
                    spriteAttributes[20 + Y] = A
                }
                //> SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
                //> bcc CheckToMirrorLakitu
                if (X >= 0x02) {
                }
            }
        }
    }
    //> MirrorEnemyGfx:
    //> lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
    A = bowserGfxFlag
    //> bne CheckToMirrorLakitu
    if (A == 0) {
        //> lda Sprite_Attributes,y     ;load attribute bits of first sprite
        A = spriteAttributes[Y]
        //> and #%10100011
        A = A and 0xA3
        //> sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
        spriteAttributes[Y] = A
        //> sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
        spriteAttributes[8 + Y] = A
        //> sta Sprite_Attributes+16,y
        spriteAttributes[16 + Y] = A
        //> ora #%01000000              ;set horizontal flip
        A = A or 0x40
        //> cpx #$05                    ;check for state used by spiny's egg
        //> bne EggExc                  ;if alternate state not set to $05, branch
        if (X == 0x05) {
            //> ora #%10000000              ;otherwise set vertical flip
            A = A or 0x80
        }
        //> EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
        spriteAttributes[4 + Y] = A
        //> sta Sprite_Attributes+12,y  ;of enemy object sprite data
        spriteAttributes[12 + Y] = A
        //> sta Sprite_Attributes+20,y
        spriteAttributes[20 + Y] = A
        //> cpx #$04                    ;check alternate enemy state
        //> bne CheckToMirrorLakitu     ;branch if not $04
        if (X == 0x04) {
            //> lda Sprite_Attributes+8,y   ;get second row left sprite attributes
            A = spriteAttributes[8 + Y]
            //> ora #%10000000
            A = A or 0x80
            //> sta Sprite_Attributes+8,y   ;store bits with vertical flip in
            spriteAttributes[8 + Y] = A
            //> sta Sprite_Attributes+16,y  ;second and third row left sprites
            spriteAttributes[16 + Y] = A
            //> ora #%01000000
            A = A or 0x40
            //> sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
            spriteAttributes[12 + Y] = A
            //> sta Sprite_Attributes+20,y  ;second and third row right sprites
            spriteAttributes[20 + Y] = A
        }
    }
    //> CheckToMirrorLakitu:
    //> lda $ef                     ;check for lakitu enemy object
    A = memory[0xEF].toInt()
    //> cmp #Lakitu
    //> bne CheckToMirrorJSpring    ;branch if not found
    if (A == Lakitu) {
        //> lda VerticalFlipFlag
        A = verticalFlipFlag
        //> bne NVFLak                  ;branch if vertical flip flag not set
        if (A == 0) {
            //> lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
            A = spriteAttributes[16 + Y]
            //> and #%10000001              ;in third row left sprite
            A = A and 0x81
            //> sta Sprite_Attributes+16,y
            spriteAttributes[16 + Y] = A
            //> lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
            A = spriteAttributes[20 + Y]
            //> ora #%01000001              ;in third row right sprite
            A = A or 0x41
            //> sta Sprite_Attributes+20,y
            spriteAttributes[20 + Y] = A
            //> ldx FrenzyEnemyTimer        ;check timer
            X = frenzyEnemyTimer
            //> cpx #$10
            //> bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
            if (X >= 0x10) {
                //  goto SprObjectOffscrChk -> sprObjectOffscrChk
                sprObjectOffscrChk()
                return
            }
            //> sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
            spriteAttributes[12 + Y] = A
            //> and #%10000001
            A = A and 0x81
            //> sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
            spriteAttributes[8 + Y] = A
            //> bcc SprObjectOffscrChk      ;unconditional branch
            if (!(X >= 0x10)) {
                //  goto SprObjectOffscrChk -> sprObjectOffscrChk
                sprObjectOffscrChk()
                return
            }
        }
        //> NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
        A = spriteAttributes[Y]
        //> and #%10000001
        A = A and 0x81
        //> sta Sprite_Attributes,y     ;save vertical flip and palette bits
        spriteAttributes[Y] = A
        //> lda Sprite_Attributes+4,y   ;get first row right sprite attributes
        A = spriteAttributes[4 + Y]
        //> ora #%01000001              ;set horizontal flip and palette bits
        A = A or 0x41
        //> sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
        spriteAttributes[4 + Y] = A
    }
    //> CheckToMirrorJSpring:
    //> lda $ef                     ;check for jumpspring object (any frame)
    A = memory[0xEF].toInt()
    //> cmp #$18
    //> bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
    if (!(A >= 0x18)) {
        //  goto SprObjectOffscrChk -> sprObjectOffscrChk
        sprObjectOffscrChk()
        return
    } else {
        //> lda #$82
        A = 0x82
        //> sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
        spriteAttributes[8 + Y] = A
        //> sta Sprite_Attributes+16,y  ;second and third row left sprites
        spriteAttributes[16 + Y] = A
        //> ora #%01000000
        A = A or 0x40
        //> sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
        spriteAttributes[12 + Y] = A
        //> sta Sprite_Attributes+20,y  ;for second and third row right sprites
        spriteAttributes[20 + Y] = A
        //  Fall-through tail call to sprObjectOffscrChk
        sprObjectOffscrChk()
        return
    }
}

// Decompiled from SprObjectOffscrChk
fun sprObjectOffscrChk() {
    var A: Int = 0
    var X: Int = 0
    var temp0: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    //> SprObjectOffscrChk:
    //> ldx ObjectOffset          ;get enemy buffer offset
    X = objectOffset
    //> lda Enemy_OffscreenBits   ;check offscreen information
    A = enemyOffscreenbits
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr                       ;shift three times to the right
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr                       ;which puts d2 into carry
    val orig2: Int = A
    A = orig2 shr 1
    //> pha                       ;save to stack
    push(A)
    //> bcc LcChk                 ;branch if not set
    if ((orig2 and 0x01) != 0) {
        //> lda #$04                  ;set for right column sprites
        A = 0x04
        //> jsr MoveESprColOffscreen  ;and move them offscreen
        moveESprColOffscreen(A, X)
    }
    //> LcChk:   pla                       ;get from stack
    A = pull()
    //> lsr                       ;move d3 to carry
    val orig3: Int = A
    A = orig3 shr 1
    //> pha                       ;save to stack
    push(A)
    //> bcc Row3C                 ;branch if not set
    if ((orig3 and 0x01) != 0) {
        //> lda #$00                  ;set for left column sprites,
        A = 0x00
        //> jsr MoveESprColOffscreen  ;move them offscreen
        moveESprColOffscreen(A, X)
    }
    //> Row3C:   pla                       ;get from stack again
    A = pull()
    //> lsr                       ;move d5 to carry this time
    val orig4: Int = A
    A = orig4 shr 1
    //> lsr
    val orig5: Int = A
    A = orig5 shr 1
    //> pha                       ;save to stack again
    push(A)
    //> bcc Row23C                ;branch if carry not set
    if ((orig5 and 0x01) != 0) {
        //> lda #$10                  ;set for third row of sprites
        A = 0x10
        //> jsr MoveESprRowOffscreen  ;and move them offscreen
        moveESprRowOffscreen(A, X)
    }
    //> Row23C:  pla                       ;get from stack
    A = pull()
    //> lsr                       ;move d6 into carry
    val orig6: Int = A
    A = orig6 shr 1
    //> pha                       ;save to stack
    push(A)
    //> bcc AllRowC
    if ((orig6 and 0x01) != 0) {
        //> lda #$08                  ;set for second and third rows
        A = 0x08
        //> jsr MoveESprRowOffscreen  ;move them offscreen
        moveESprRowOffscreen(A, X)
    }
    //> AllRowC: pla                       ;get from stack once more
    A = pull()
    //> lsr                       ;move d7 into carry
    val orig7: Int = A
    A = orig7 shr 1
    //> bcc ExEGHandler
    if ((orig7 and 0x01) != 0) {
        //> jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
        moveESprRowOffscreen(A, X)
        //> lda Enemy_ID,x
        A = enemyId[X]
        //> cmp #Podoboo              ;check enemy identifier for podoboo
        //> beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
        if (A != Podoboo) {
            //> lda Enemy_Y_HighPos,x     ;check high byte of vertical position
            A = enemyYHighpos[X]
            //> cmp #$02                  ;if not yet past the bottom of the screen, branch
            //> bne ExEGHandler
            if (A == 0x02) {
                //> jsr EraseEnemyObject      ;what it says
                temp0 = eraseEnemyObject(X)
            }
        }
    }
    //> ExEGHandler:
    //> rts
    return
}

// Decompiled from DrawEnemyObjRow
fun drawEnemyObjRow(X: Int, Y: Int): Int {
    var A: Int = 0
    val enemyGraphicsTable by MemoryByteIndexed(EnemyGraphicsTable)
    //> DrawEnemyObjRow:
    //> lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
    A = enemyGraphicsTable[X]
    //> sta $00
    memory[0x0] = A.toUByte()
    //> lda EnemyGraphicsTable+1,x
    A = enemyGraphicsTable[1 + X]
    //  Fall-through tail call to drawOneSpriteRow
    return drawOneSpriteRow(A, X, Y)
}

// Decompiled from DrawOneSpriteRow
fun drawOneSpriteRow(A: Int, X: Int, Y: Int): Int {
    //> DrawOneSpriteRow:
    //> sta $01
    memory[0x1] = A.toUByte()
    //> jmp DrawSpriteObject        ;draw them
    return drawSpriteObject(X, Y)
}

// Decompiled from MoveESprRowOffscreen
fun moveESprRowOffscreen(A: Int, X: Int) {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    //> MoveESprRowOffscreen:
    //> clc                         ;add A to enemy object OAM data offset
    //> adc Enemy_SprDataOffset,x
    temp0 = A + enemySprdataoffset[X]
    //> tay                         ;use as offset
    Y = temp0 and 0xFF
    //> lda #$f8
    A = 0xF8
    //> jmp DumpTwoSpr              ;move first row of sprites offscreen
    dumpTwoSpr(A, Y)
    return
}

// Decompiled from MoveESprColOffscreen
fun moveESprColOffscreen(A: Int, X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> MoveESprColOffscreen:
    //> clc                         ;add A to enemy object OAM data offset
    //> adc Enemy_SprDataOffset,x
    temp0 = A + enemySprdataoffset[X]
    //> tay                         ;use as offset
    Y = temp0 and 0xFF
    //> jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
    temp1 = moveColOffscreen(Y)
    //> sta Sprite_Data+16,y        ;move third row sprite in column offscreen
    spriteData[16 + Y] = temp1
    //> rts
    return
}

// Decompiled from DrawBlock
fun drawBlock(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    var blockOffscreenbits by MemoryByte(Block_OffscreenBits)
    var blockRelXpos by MemoryByte(Block_Rel_XPos)
    var blockRelYpos by MemoryByte(Block_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val blockMetatile by MemoryByteIndexed(Block_Metatile)
    val blockSprdataoffset by MemoryByteIndexed(Block_SprDataOffset)
    val defaultBlockObjTiles by MemoryByteIndexed(DefaultBlockObjTiles)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawBlock:
    //> lda Block_Rel_YPos            ;get relative vertical coordinate of block object
    A = blockRelYpos
    //> sta $02                       ;store here
    memory[0x2] = A.toUByte()
    //> lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
    A = blockRelXpos
    //> sta $05                       ;store here
    memory[0x5] = A.toUByte()
    //> lda #$03
    A = 0x03
    //> sta $04                       ;set attribute byte here
    memory[0x4] = A.toUByte()
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> sta $03                       ;set horizontal flip bit here (will not be used)
    memory[0x3] = A.toUByte()
    //> ldy Block_SprDataOffset,x     ;get sprite data offset
    Y = blockSprdataoffset[X]
    //> ldx #$00                      ;reset X for use as offset to tile data
    X = 0x00
    loop0@ do {
        //> DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
        A = defaultBlockObjTiles[X]
        //> sta $00                       ;set here
        memory[0x0] = A.toUByte()
        //> lda DefaultBlockObjTiles+1,x  ;get right tile number
        A = defaultBlockObjTiles[1 + X]
        //> jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
        temp0 = drawOneSpriteRow(A, X, Y)
        X = temp0
        //> cpx #$04                      ;check incremented offset
        //> bne DBlkLoop                  ;and loop back until all four sprites are done
        if (!(temp0 == 0x04)) {
            //  continue loop (branch back to DBlkLoop)
            continue@loop0
        }
    } while (temp0 != 0x04)
    //> ldx ObjectOffset              ;get block object offset
    X = objectOffset
    //> ldy Block_SprDataOffset,x     ;get sprite data offset
    Y = blockSprdataoffset[X]
    //> lda AreaType
    A = areaType
    //> cmp #$01                      ;check for ground level type area
    //> beq ChkRep                    ;if found, branch to next part
    if (A != 0x01) {
        //> lda #$86
        A = 0x86
        //> sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
        spriteTilenumber[Y] = A
        //> sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
        spriteTilenumber[4 + Y] = A
    }
    //> ChkRep:    lda Block_Metatile,x          ;check replacement metatile
    A = blockMetatile[X]
    //> cmp #$c4                      ;if not used block metatile, then
    //> bne BlkOffscr                 ;branch ahead to use current graphics
    if (A == 0xC4) {
        //> lda #$87                      ;set A for used block tile
        A = 0x87
        //> iny                           ;increment Y to write to tile bytes
        Y = (Y + 1) and 0xFF
        //> jsr DumpFourSpr               ;do sub to dump into all four sprites
        dumpFourSpr(A, Y)
        //> dey                           ;return Y to original offset
        Y = (Y - 1) and 0xFF
        //> lda #$03                      ;set palette bits
        A = 0x03
        //> ldx AreaType
        X = areaType
        //> dex                           ;check for ground level type area again
        X = (X - 1) and 0xFF
        //> beq SetBFlip                  ;if found, use current palette bits
        if (X != 0) {
            //> lsr                           ;otherwise set to $01
            val orig1: Int = A
            A = orig1 shr 1
        }
        //> SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
        X = objectOffset
        //> sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
        spriteAttributes[Y] = A
        //> ora #%01000000
        A = A or 0x40
        //> sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
        spriteAttributes[4 + Y] = A
        //> ora #%10000000
        A = A or 0x80
        //> sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
        spriteAttributes[12 + Y] = A
        //> and #%10000011
        A = A and 0x83
        //> sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
        spriteAttributes[8 + Y] = A
    }
    //> BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
    A = blockOffscreenbits
    //> pha                           ;save to stack
    push(A)
    //> and #%00000100                ;check to see if d2 in offscreen bits are set
    A = A and 0x04
    //> beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
    if (A != 0) {
        //> lda #$f8                      ;move offscreen two OAMs
        A = 0xF8
        //> sta Sprite_Y_Position+4,y     ;on the right side
        spriteYPosition[4 + Y] = A
        //> sta Sprite_Y_Position+12,y
        spriteYPosition[12 + Y] = A
    }
    //> PullOfsB:  pla                           ;pull offscreen bits from stack
    A = pull()
    //  Fall-through tail call to chkLeftCo
    chkLeftCo(A, Y)
    return Pair(A, X)
}

// Decompiled from ChkLeftCo
fun chkLeftCo(A: Int, Y: Int): Int {
    var A: Int = A
    //> ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
    A = A and 0x08
    //> beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
    if (A == 0) {
        //  goto ExDBlk -> exDBlk
        exDBlk()
        return A
    } else {
        //  Fall-through tail call to moveColOffscreen
        return moveColOffscreen(Y)
    }
}

// Decompiled from MoveColOffscreen
fun moveColOffscreen(Y: Int): Int {
    var A: Int = 0
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> MoveColOffscreen:
    //> lda #$f8                   ;move offscreen two OAMs
    A = 0xF8
    //> sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
    spriteYPosition[Y] = A
    //> sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
    spriteYPosition[8 + Y] = A
    //  Fall-through tail call to exDBlk
    exDBlk()
    return A
}

// Decompiled from ExDBlk
fun exDBlk() {
    //> ExDBlk: rts
    return
}

// Decompiled from DrawBrickChunks
fun drawBrickChunks(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var blockOffscreenbits by MemoryByte(Block_OffscreenBits)
    var frameCounter by MemoryByte(FrameCounter)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val blockOrigXpos by MemoryByteIndexed(Block_Orig_XPos)
    val blockRelXpos by MemoryByteIndexed(Block_Rel_XPos)
    val blockRelYpos by MemoryByteIndexed(Block_Rel_YPos)
    val blockSprdataoffset by MemoryByteIndexed(Block_SprDataOffset)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawBrickChunks:
    //> lda #$02                   ;set palette bits here
    A = 0x02
    //> sta $00
    memory[0x0] = A.toUByte()
    //> lda #$75                   ;set tile number for ball (something residual, likely)
    A = 0x75
    //> ldy GameEngineSubroutine
    Y = gameEngineSubroutine
    //> cpy #$05                   ;if end-of-level routine running,
    //> beq DChunks                ;use palette and tile number assigned
    X = X
    if (Y != 0x05) {
        //> lda #$03                   ;otherwise set different palette bits
        A = 0x03
        //> sta $00
        memory[0x0] = A.toUByte()
        //> lda #$84                   ;and set tile number for brick chunks
        A = 0x84
    }
    //> DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
    Y = blockSprdataoffset[X]
    //> iny                        ;increment to start with tile bytes in OAM
    Y = (Y + 1) and 0xFF
    //> jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
    dumpFourSpr(A, Y)
    //> lda FrameCounter           ;get frame counter
    A = frameCounter
    //> asl
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl                        ;move low nybble to high
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFF
    //> and #$c0                   ;get what was originally d3-d2 of low nybble
    A = A and 0xC0
    //> ora $00                    ;add palette bits
    A = A or memory[0x0].toInt()
    //> iny                        ;increment offset for attribute bytes
    Y = (Y + 1) and 0xFF
    //> jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
    dumpFourSpr(A, Y)
    //> dey
    Y = (Y - 1) and 0xFF
    //> dey                        ;decrement offset to Y coordinate
    Y = (Y - 1) and 0xFF
    //> lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
    A = blockRelYpos[0]
    //> jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
    dumpTwoSpr(A, Y)
    //> lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
    A = blockRelXpos[0]
    //> sta Sprite_X_Position,y    ;save into X coordinate of first sprite
    spriteXPosition[Y] = A
    //> lda Block_Orig_XPos,x      ;get original horizontal coordinate
    A = blockOrigXpos[X]
    //> sec
    //> sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
    temp0 = A - screenleftXPos
    A = temp0 and 0xFF
    //> sta $00                    ;store result as relative horizontal coordinate of original
    memory[0x0] = A.toUByte()
    //> sec
    //> sbc Block_Rel_XPos         ;get difference of relative positions of original - current
    temp1 = A - blockRelXpos[0]
    A = temp1 and 0xFF
    //> adc $00                    ;add original relative position to result
    temp2 = A + memory[0x0].toInt() + if (temp1 >= 0) 1 else 0
    A = temp2 and 0xFF
    //> adc #$06                   ;plus 6 pixels to position second brick chunk correctly
    temp3 = A + 0x06 + if (temp2 > 0xFF) 1 else 0
    A = temp3 and 0xFF
    //> sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
    spriteXPosition[4 + Y] = A
    //> lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
    A = blockRelYpos[1]
    //> sta Sprite_Y_Position+8,y
    spriteYPosition[8 + Y] = A
    //> sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
    spriteYPosition[12 + Y] = A
    //> lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
    A = blockRelXpos[1]
    //> sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
    spriteXPosition[8 + Y] = A
    //> lda $00                    ;use original relative horizontal position
    A = memory[0x0].toInt()
    //> sec
    //> sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
    temp4 = A - blockRelXpos[1]
    A = temp4 and 0xFF
    //> adc $00                    ;add original relative position to result
    temp5 = A + memory[0x0].toInt() + if (temp4 >= 0) 1 else 0
    A = temp5 and 0xFF
    //> adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
    temp6 = A + 0x06 + if (temp5 > 0xFF) 1 else 0
    A = temp6 and 0xFF
    //> sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
    spriteXPosition[12 + Y] = A
    //> lda Block_OffscreenBits    ;get offscreen bits for block object
    A = blockOffscreenbits
    //> jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
    temp7 = chkLeftCo(A, Y)
    //> lda Block_OffscreenBits    ;get offscreen bits again
    A = blockOffscreenbits
    //> asl                        ;shift d7 into carry
    val orig4: Int = A
    A = (orig4 shl 1) and 0xFF
    //> bcc ChnkOfs                ;if d7 not set, branch to last part
    if ((orig4 and 0x80) != 0) {
        //> lda #$f8
        A = 0xF8
        //> jsr DumpTwoSpr             ;otherwise move top sprites offscreen
        dumpTwoSpr(A, Y)
    }
    //> ChnkOfs: lda $00                    ;if relative position on left side of screen,
    A = memory[0x0].toInt()
    //> bpl ExBCDr                 ;go ahead and leave
    if ((A and 0x80) != 0) {
        //> lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
        A = spriteXPosition[Y]
        //> cmp Sprite_X_Position+4,y  ;to right-side X coordinate
        //> bcc ExBCDr                 ;branch to leave if less
        if (A >= spriteXPosition[4 + Y]) {
            //> lda #$f8                   ;otherwise move right half of sprites offscreen
            A = 0xF8
            //> sta Sprite_Y_Position+4,y
            spriteYPosition[4 + Y] = A
            //> sta Sprite_Y_Position+12,y
            spriteYPosition[12 + Y] = A
        }
    }
    //> ExBCDr:  rts                        ;leave
    return
}

// Decompiled from DrawFireball
fun drawFireball(X: Int) {
    var A: Int = 0
    var Y: Int = 0
    var fireballRelXpos by MemoryByte(Fireball_Rel_XPos)
    var fireballRelYpos by MemoryByte(Fireball_Rel_YPos)
    val fballSprdataoffset by MemoryByteIndexed(FBall_SprDataOffset)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawFireball:
    //> ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
    Y = fballSprdataoffset[X]
    //> lda Fireball_Rel_YPos      ;get relative vertical coordinate
    A = fireballRelYpos
    //> sta Sprite_Y_Position,y    ;store as sprite Y coordinate
    spriteYPosition[Y] = A
    //> lda Fireball_Rel_XPos      ;get relative horizontal coordinate
    A = fireballRelXpos
    //> sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
    spriteXPosition[Y] = A
    //  Fall-through tail call to drawFirebar
    drawFirebar(Y)
    return
}

// Decompiled from DrawFirebar
fun drawFirebar(Y: Int) {
    var A: Int = 0
    var Y: Int = Y
    var frameCounter by MemoryByte(FrameCounter)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    //> DrawFirebar:
    //> lda FrameCounter         ;get frame counter
    A = frameCounter
    //> lsr                      ;divide by four
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr
    val orig1: Int = A
    A = orig1 shr 1
    //> pha                      ;save result to stack
    push(A)
    //> and #$01                 ;mask out all but last bit
    A = A and 0x01
    //> eor #$64                 ;set either tile $64 or $65 as fireball tile
    A = A xor 0x64
    //> sta Sprite_Tilenumber,y  ;thus tile changes every four frames
    spriteTilenumber[Y] = A
    //> pla                      ;get from stack
    A = pull()
    //> lsr                      ;divide by four again
    val orig2: Int = A
    A = orig2 shr 1
    //> lsr
    val orig3: Int = A
    A = orig3 shr 1
    //> lda #$02                 ;load value $02 to set palette in attrib byte
    A = 0x02
    //> bcc FireA                ;if last bit shifted out was not set, skip this
    Y = Y
    if ((orig3 and 0x01) != 0) {
        //> ora #%11000000           ;otherwise flip both ways every eight frames
        A = A or 0xC0
    }
    //> FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
    spriteAttributes[Y] = A
    //> rts
    return
}

// Decompiled from DrawExplosion_Fireball
fun drawexplosionFireball(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    val altSprdataoffset by MemoryByteIndexed(Alt_SprDataOffset)
    val fireballState by MemoryByteIndexed(Fireball_State)
    //> DrawExplosion_Fireball:
    //> ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
    Y = altSprdataoffset[X]
    //> lda Fireball_State,x     ;load fireball state
    A = fireballState[X]
    //> inc Fireball_State,x     ;increment state for next frame
    fireballState[X] = (fireballState[X] + 1) and 0xFF
    //> lsr                      ;divide by 2
    val orig0: Int = A
    A = orig0 shr 1
    //> and #%00000111           ;mask out all but d3-d1
    A = A and 0x07
    //> cmp #$03                 ;check to see if time to kill fireball
    //> bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
    X = X
    if (!(A >= 0x03)) {
        //  Fall-through tail call to drawexplosionFireworks
        drawexplosionFireworks(A, Y)
        return
    } else {
        //> KillFireBall:
        //> lda #$00                    ;clear fireball state to kill it
        A = 0x00
        //> sta Fireball_State,x
        fireballState[X] = A
        //> rts
        return
    }
}

// Decompiled from DrawExplosion_Fireworks
fun drawexplosionFireworks(A: Int, Y: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var fireballRelXpos by MemoryByte(Fireball_Rel_XPos)
    var fireballRelYpos by MemoryByte(Fireball_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val explosionTiles by MemoryByteIndexed(ExplosionTiles)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawExplosion_Fireworks:
    //> tax                         ;use whatever's in A for offset
    X = A
    //> lda ExplosionTiles,x        ;get tile number using offset
    A = explosionTiles[X]
    //> iny                         ;increment Y (contains sprite data offset)
    Y = (Y + 1) and 0xFF
    //> jsr DumpFourSpr             ;and dump into tile number part of sprite data
    dumpFourSpr(A, Y)
    //> dey                         ;decrement Y so we have the proper offset again
    Y = (Y - 1) and 0xFF
    //> ldx ObjectOffset            ;return enemy object buffer offset to X
    X = objectOffset
    //> lda Fireball_Rel_YPos       ;get relative vertical coordinate
    A = fireballRelYpos
    //> sec                         ;subtract four pixels vertically
    //> sbc #$04                    ;for first and third sprites
    temp0 = A - 0x04
    A = temp0 and 0xFF
    //> sta Sprite_Y_Position,y
    spriteYPosition[Y] = A
    //> sta Sprite_Y_Position+8,y
    spriteYPosition[8 + Y] = A
    //> clc                         ;add eight pixels vertically
    //> adc #$08                    ;for second and fourth sprites
    temp1 = A + 0x08
    A = temp1 and 0xFF
    //> sta Sprite_Y_Position+4,y
    spriteYPosition[4 + Y] = A
    //> sta Sprite_Y_Position+12,y
    spriteYPosition[12 + Y] = A
    //> lda Fireball_Rel_XPos       ;get relative horizontal coordinate
    A = fireballRelXpos
    //> sec                         ;subtract four pixels horizontally
    //> sbc #$04                    ;for first and second sprites
    temp2 = A - 0x04
    A = temp2 and 0xFF
    //> sta Sprite_X_Position,y
    spriteXPosition[Y] = A
    //> sta Sprite_X_Position+4,y
    spriteXPosition[4 + Y] = A
    //> clc                         ;add eight pixels horizontally
    //> adc #$08                    ;for third and fourth sprites
    temp3 = A + 0x08
    A = temp3 and 0xFF
    //> sta Sprite_X_Position+8,y
    spriteXPosition[8 + Y] = A
    //> sta Sprite_X_Position+12,y
    spriteXPosition[12 + Y] = A
    //> lda #$02                    ;set palette attributes for all sprites, but
    A = 0x02
    //> sta Sprite_Attributes,y     ;set no flip at all for first sprite
    spriteAttributes[Y] = A
    //> lda #$82
    A = 0x82
    //> sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
    spriteAttributes[4 + Y] = A
    //> lda #$42
    A = 0x42
    //> sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
    spriteAttributes[8 + Y] = A
    //> lda #$c2
    A = 0xC2
    //> sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
    spriteAttributes[12 + Y] = A
    //> rts                         ;we are done
    return
}

// Decompiled from DrawSmallPlatform
fun drawSmallPlatform(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawSmallPlatform:
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    Y = enemySprdataoffset[X]
    //> lda #$5b                    ;load tile number for small platforms
    A = 0x5B
    //> iny                         ;increment offset for tile numbers
    Y = (Y + 1) and 0xFF
    //> jsr DumpSixSpr              ;dump tile number into all six sprites
    dumpSixSpr(A, Y)
    //> iny                         ;increment offset for attributes
    Y = (Y + 1) and 0xFF
    //> lda #$02                    ;load palette controls
    A = 0x02
    //> jsr DumpSixSpr              ;dump attributes into all six sprites
    dumpSixSpr(A, Y)
    //> dey                         ;decrement for original offset
    Y = (Y - 1) and 0xFF
    //> dey
    Y = (Y - 1) and 0xFF
    //> lda Enemy_Rel_XPos          ;get relative horizontal coordinate
    A = enemyRelXpos
    //> sta Sprite_X_Position,y
    spriteXPosition[Y] = A
    //> sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
    spriteXPosition[12 + Y] = A
    //> clc
    //> adc #$08                    ;add eight pixels
    temp0 = A + 0x08
    A = temp0 and 0xFF
    //> sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
    spriteXPosition[4 + Y] = A
    //> sta Sprite_X_Position+16,y
    spriteXPosition[16 + Y] = A
    //> clc
    //> adc #$08                    ;add eight more pixels
    temp1 = A + 0x08
    A = temp1 and 0xFF
    //> sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
    spriteXPosition[8 + Y] = A
    //> sta Sprite_X_Position+20,y
    spriteXPosition[20 + Y] = A
    //> lda Enemy_Y_Position,x      ;get vertical coordinate
    A = enemyYPosition[X]
    //> tax
    X = A
    //> pha                         ;save to stack
    push(A)
    //> cpx #$20                    ;if vertical coordinate below status bar,
    //> bcs TopSP                   ;do not mess with it
    X = X
    if (!(X >= 0x20)) {
        //> lda #$f8                    ;otherwise move first three sprites offscreen
        A = 0xF8
    }
    //> TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
    dumpThreeSpr(A, Y)
    //> pla                         ;pull from stack
    A = pull()
    //> clc
    //> adc #$80                    ;add 128 pixels
    temp2 = A + 0x80
    A = temp2 and 0xFF
    //> tax
    X = A
    //> cpx #$20                    ;if below status bar (taking wrap into account)
    //> bcs BotSP                   ;then do not change altered coordinate
    if (!(X >= 0x20)) {
        //> lda #$f8                    ;otherwise move last three sprites offscreen
        A = 0xF8
    }
    //> BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
    spriteYPosition[12 + Y] = A
    //> sta Sprite_Y_Position+16,y  ;into Y coordinates
    spriteYPosition[16 + Y] = A
    //> sta Sprite_Y_Position+20,y
    spriteYPosition[20 + Y] = A
    //> lda Enemy_OffscreenBits     ;get offscreen bits
    A = enemyOffscreenbits
    //> pha                         ;save to stack
    push(A)
    //> and #%00001000              ;check d3
    A = A and 0x08
    //> beq SOfs
    if (A != 0) {
        //> lda #$f8                    ;if d3 was set, move first and
        A = 0xF8
        //> sta Sprite_Y_Position,y     ;fourth sprites offscreen
        spriteYPosition[Y] = A
        //> sta Sprite_Y_Position+12,y
        spriteYPosition[12 + Y] = A
    }
    //> SOfs:  pla                         ;move out and back into stack
    A = pull()
    //> pha
    push(A)
    //> and #%00000100              ;check d2
    A = A and 0x04
    //> beq SOfs2
    if (A != 0) {
        //> lda #$f8                    ;if d2 was set, move second and
        A = 0xF8
        //> sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
        spriteYPosition[4 + Y] = A
        //> sta Sprite_Y_Position+16,y
        spriteYPosition[16 + Y] = A
    }
    //> SOfs2: pla                         ;get from stack
    A = pull()
    //> and #%00000010              ;check d1
    A = A and 0x02
    //> beq ExSPl
    if (A != 0) {
        //> lda #$f8                    ;if d1 was set, move third and
        A = 0xF8
        //> sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
        spriteYPosition[8 + Y] = A
        //> sta Sprite_Y_Position+20,y
        spriteYPosition[20 + Y] = A
    }
    //> ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from DrawBubble
fun drawBubble(X: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var bubbleOffscreenbits by MemoryByte(Bubble_OffscreenBits)
    var bubbleRelXpos by MemoryByte(Bubble_Rel_XPos)
    var bubbleRelYpos by MemoryByte(Bubble_Rel_YPos)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    val bubbleSprdataoffset by MemoryByteIndexed(Bubble_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawBubble:
    //> ldy Player_Y_HighPos        ;if player's vertical high position
    Y = playerYHighpos
    //> dey                         ;not within screen, skip all of this
    Y = (Y - 1) and 0xFF
    //> bne ExDBub
    X = X
    if (Y == 0) {
        //> lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
        A = bubbleOffscreenbits
        //> and #%00001000
        A = A and 0x08
        //> bne ExDBub                  ;if bit set, branch to leave
        if (A == 0) {
            //> ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
            Y = bubbleSprdataoffset[X]
            //> lda Bubble_Rel_XPos         ;get relative horizontal coordinate
            A = bubbleRelXpos
            //> sta Sprite_X_Position,y     ;store as X coordinate here
            spriteXPosition[Y] = A
            //> lda Bubble_Rel_YPos         ;get relative vertical coordinate
            A = bubbleRelYpos
            //> sta Sprite_Y_Position,y     ;store as Y coordinate here
            spriteYPosition[Y] = A
            //> lda #$74
            A = 0x74
            //> sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
            spriteTilenumber[Y] = A
            //> lda #$02
            A = 0x02
            //> sta Sprite_Attributes,y     ;set attribute byte
            spriteAttributes[Y] = A
        }
    }
    //> ExDBub: rts                         ;leave
    return
}

// Decompiled from PlayerGfxHandler
fun playerGfxHandler() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var injuryTimer by MemoryByte(InjuryTimer)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerSize by MemoryByte(PlayerSize)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    var playerState by MemoryByte(Player_State)
    var swimTileRepOffset by MemoryByte(SwimTileRepOffset)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val swimKickTileNum by MemoryByteIndexed(SwimKickTileNum)
    //> PlayerGfxHandler:
    //> lda InjuryTimer             ;if player's injured invincibility timer
    A = injuryTimer
    //> beq CntPl                   ;not set, skip checkpoint and continue code
    if (A != 0) {
        //> lda FrameCounter
        A = frameCounter
        //> lsr                         ;otherwise check frame counter and branch
        val orig0: Int = A
        A = orig0 shr 1
        //> bcs ExPGH                   ;to leave on every other frame (when d0 is set)
        if ((orig0 and 0x01) != 0) {
            //  goto ExPGH (internal forward branch)
            //> ExPGH:  rts                         ;then leave
            return
        }
    }
    //> CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
    A = gameEngineSubroutine
    //> cmp #$0b                    ;branch ahead to some other part
    //> beq PlayerKilled
    if (A != 0x0B) {
        //> lda PlayerChangeSizeFlag    ;if grow/shrink flag set
        A = playerChangeSizeFlag
        //> bne DoChangeSize            ;then branch to some other code
        if (A == 0) {
            //> ldy SwimmingFlag            ;if swimming flag set, branch to
            Y = swimmingFlag
            //> beq FindPlayerAction        ;different part, do not return
            if (Y == 0) {
                //  goto FindPlayerAction -> findPlayerAction
                findPlayerAction(A)
                return
            }
            //> lda Player_State
            A = playerState
            //> cmp #$00                    ;if player status normal,
            //> beq FindPlayerAction        ;branch and do not return
            if (A == 0x00) {
                //  goto FindPlayerAction -> findPlayerAction
                findPlayerAction(A)
                return
            }
            //> jsr FindPlayerAction        ;otherwise jump and return
            findPlayerAction(A)
            //> lda FrameCounter
            A = frameCounter
            //> and #%00000100              ;check frame counter for d2 set (8 frames every
            A = A and 0x04
            //> bne ExPGH                   ;eighth frame), and branch if set to leave
            if (A == 0) {
                //> tax                         ;initialize X to zero
                X = A
                //> ldy Player_SprDataOffset    ;get player sprite data offset
                Y = playerSprdataoffset
                //> lda PlayerFacingDir         ;get player's facing direction
                A = playerFacingDir
                //> lsr
                val orig1: Int = A
                A = orig1 shr 1
                //> bcs SwimKT                  ;if player facing to the right, use current offset
                X = X
                if ((orig1 and 0x01) == 0) {
                    //> iny
                    Y = (Y + 1) and 0xFF
                    //> iny                         ;otherwise move to next OAM data
                    Y = (Y + 1) and 0xFF
                    //> iny
                    Y = (Y + 1) and 0xFF
                    //> iny
                    Y = (Y + 1) and 0xFF
                }
                //> SwimKT: lda PlayerSize              ;check player's size
                A = playerSize
                //> beq BigKTS                  ;if big, use first tile
                if (A != 0) {
                    //> lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
                    A = spriteTilenumber[24 + Y]
                    //> cmp SwimTileRepOffset       ;against tile number in player graphics table
                    //> beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
                    if (A != swimTileRepOffset) {
                        //> inx                         ;otherwise increment X for second tile
                        X = (X + 1) and 0xFF
                    }
                }
                //> BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
                A = swimKickTileNum[X]
                //> sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
                spriteTilenumber[24 + Y] = A
            }
            //> ExPGH:  rts                         ;then leave
            return
        } else {
            //> DoChangeSize:
            //> jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
            temp0 = handleChangeSize()
            //> jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
            playerGfxProcessing(temp0)
            return
        }
    }
    //> PlayerKilled:
    //> ldy #$0e                      ;load offset for player killed
    Y = 0x0E
    //> lda PlayerGfxTblOffsets,y     ;get offset to graphics table
    A = playerGfxTblOffsets[Y]
    //  Fall-through tail call to playerGfxProcessing
    playerGfxProcessing(A)
    return
}

// Decompiled from FindPlayerAction
fun findPlayerAction(A: Int) {
    var temp0: Int = 0
    //> FindPlayerAction:
    //> jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
    temp0 = processPlayerAction()
    //> jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
    playerGfxProcessing(temp0)
    return
}

// Decompiled from PlayerGfxProcessing
fun playerGfxProcessing(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var fireballThrowingTimer by MemoryByte(FireballThrowingTimer)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerOffscreenbits by MemoryByte(Player_OffscreenBits)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> PlayerGfxProcessing:
    //> sta PlayerGfxOffset           ;store offset to graphics table here
    playerGfxOffset = A
    //> lda #$04
    A = 0x04
    //> jsr RenderPlayerSub           ;draw player based on offset loaded
    renderPlayerSub(A)
    //> jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
    chkForPlayerAttrib()
    //> lda FireballThrowingTimer
    A = fireballThrowingTimer
    //> beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
    if (A != 0) {
        //> ldy #$00                      ;set value to initialize by default
        Y = 0x00
        //> lda PlayerAnimTimer           ;get animation frame timer
        A = playerAnimTimer
        //> cmp FireballThrowingTimer     ;compare to fireball throw timer
        //> sty FireballThrowingTimer     ;initialize fireball throw timer
        fireballThrowingTimer = Y
        //> bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
        if (!(A >= fireballThrowingTimer)) {
            //> sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
            fireballThrowingTimer = A
            //> ldy #$07                      ;load offset for throwing
            Y = 0x07
            //> lda PlayerGfxTblOffsets,y     ;get offset to graphics table
            A = playerGfxTblOffsets[Y]
            //> sta PlayerGfxOffset           ;store it for use later
            playerGfxOffset = A
            //> ldy #$04                      ;set to update four sprite rows by default
            Y = 0x04
            //> lda Player_X_Speed
            A = playerXSpeed
            //> ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
            A = A or leftRightButtons
            //> beq SUpdR                     ;if no speed or button press, branch using set value in Y
            if (A != 0) {
                //> dey                           ;otherwise set to update only three sprite rows
                Y = (Y - 1) and 0xFF
            }
            //> SUpdR: tya                           ;save in A for use
            A = Y
            //> jsr RenderPlayerSub           ;in sub, draw player object again
            renderPlayerSub(A)
        }
    }
    //> PlayerOffscreenChk:
    //> lda Player_OffscreenBits      ;get player's offscreen bits
    A = playerOffscreenbits
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr                           ;move vertical bits to low nybble
    val orig1: Int = A
    A = orig1 shr 1
    //> lsr
    val orig2: Int = A
    A = orig2 shr 1
    //> lsr
    val orig3: Int = A
    A = orig3 shr 1
    //> sta $00                       ;store here
    memory[0x0] = A.toUByte()
    //> ldx #$03                      ;check all four rows of player sprites
    X = 0x03
    //> lda Player_SprDataOffset      ;get player's sprite data offset
    A = playerSprdataoffset
    //> clc
    //> adc #$18                      ;add 24 bytes to start at bottom row
    temp0 = A + 0x18
    A = temp0 and 0xFF
    //> tay                           ;set as offset here
    Y = A
    loop0@ do {
        //> PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
        A = 0xF8
        //> lsr $00                       ;shift bit into carry
        memory[0x0] = ((memory[0x0].toInt() shr 1) and 0xFF).toUByte()
        //> bcc NPROffscr                 ;if bit not set, skip, do not move sprites
        if ((memory[0x0].toInt() and 0x01) != 0) {
            //> jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
            dumpTwoSpr(A, Y)
        }
        //> NPROffscr: tya
        A = Y
        //> sec                           ;subtract eight bytes to do
        //> sbc #$08                      ;next row up
        temp1 = A - 0x08
        A = temp1 and 0xFF
        //> tay
        Y = A
        //> dex                           ;decrement row counter
        X = (X - 1) and 0xFF
        //> bpl PROfsLoop                 ;do this until all sprite rows are checked
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to PROfsLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> rts                           ;then we are done!
    return
}

// Decompiled from DrawPlayer_Intermediate
fun drawplayerIntermediate() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    val intermediatePlayerData by MemoryByteIndexed(IntermediatePlayerData)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    //> DrawPlayer_Intermediate:
    //> ldx #$05                       ;store data into zero page memory
    X = 0x05
    loop0@ do {
        //> PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
        A = intermediatePlayerData[X]
        //> sta $02,x                      ;appears on world/lives display
        memory[0x2 + X] = A.toUByte()
        //> dex
        X = (X - 1) and 0xFF
        //> bpl PIntLoop                   ;do this until all data is loaded
        if (!((X and 0x80) != 0)) {
            //  continue loop (branch back to PIntLoop)
            continue@loop0
        }
    } while ((X and 0x80) == 0)
    //> ldx #$b8                       ;load offset for small standing
    X = 0xB8
    //> ldy #$04                       ;load sprite data offset
    Y = 0x04
    //> jsr DrawPlayerLoop             ;draw player accordingly
    drawPlayerLoop(X, Y)
    //> lda Sprite_Attributes+36       ;get empty sprite attributes
    A = spriteAttributes[36]
    //> ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
    A = A or 0x40
    //> sta Sprite_Attributes+32       ;store and leave
    spriteAttributes[32] = A
    //> rts
    return
}

// Decompiled from RenderPlayerSub
fun renderPlayerSub(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerPosForscroll by MemoryByte(Player_Pos_ForScroll)
    var playerRelXpos by MemoryByte(Player_Rel_XPos)
    var playerRelYpos by MemoryByte(Player_Rel_YPos)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    //> RenderPlayerSub:
    //> sta $07                      ;store number of rows of sprites to draw
    memory[0x7] = A.toUByte()
    //> lda Player_Rel_XPos
    A = playerRelXpos
    //> sta Player_Pos_ForScroll     ;store player's relative horizontal position
    playerPosForscroll = A
    //> sta $05                      ;store it here also
    memory[0x5] = A.toUByte()
    //> lda Player_Rel_YPos
    A = playerRelYpos
    //> sta $02                      ;store player's vertical position
    memory[0x2] = A.toUByte()
    //> lda PlayerFacingDir
    A = playerFacingDir
    //> sta $03                      ;store player's facing direction
    memory[0x3] = A.toUByte()
    //> lda Player_SprAttrib
    A = playerSprattrib
    //> sta $04                      ;store player's sprite attributes
    memory[0x4] = A.toUByte()
    //> ldx PlayerGfxOffset          ;load graphics table offset
    X = playerGfxOffset
    //> ldy Player_SprDataOffset     ;get player's sprite data offset
    Y = playerSprdataoffset
    //  Fall-through tail call to drawPlayerLoop
    drawPlayerLoop(X, Y)
    return
}

// Decompiled from DrawPlayerLoop
fun drawPlayerLoop(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    val playerGraphicsTable by MemoryByteIndexed(PlayerGraphicsTable)
    X = X
    Y = Y
    loop0@ do {
        //> DrawPlayerLoop:
        //> lda PlayerGraphicsTable,x    ;load player's left side
        A = playerGraphicsTable[X]
        //> sta $00
        memory[0x0] = A.toUByte()
        //> lda PlayerGraphicsTable+1,x  ;now load right side
        A = playerGraphicsTable[1 + X]
        //> jsr DrawOneSpriteRow
        temp0 = drawOneSpriteRow(A, X, Y)
        X = temp0
        //> dec $07                      ;decrement rows of sprites to draw
        memory[0x7] = ((memory[0x7].toInt() - 1) and 0xFF).toUByte()
        //> bne DrawPlayerLoop           ;do this until all rows are drawn
        if (!(memory[0x7].toInt() == 0)) {
            //  continue loop (branch back to DrawPlayerLoop)
            continue@loop0
        }
    } while (memory[0x7].toInt() != 0)
    //> rts
    return
}

// Decompiled from ProcessPlayerAction
fun processPlayerAction(): Int {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerState by MemoryByte(Player_State)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> ProcessPlayerAction:
    //> lda Player_State      ;get player's state
    A = playerState
    //> cmp #$03
    //> beq ActionClimbing    ;if climbing, branch here
    if (A != 0x03) {
        //> cmp #$02
        //> beq ActionFalling     ;if falling, branch here
        if (A != 0x02) {
            //> cmp #$01
            //> bne ProcOnGroundActs  ;if not jumping, branch here
            if (A == 0x01) {
                //> lda SwimmingFlag
                A = swimmingFlag
                //> bne ActionSwimming    ;if swimming flag set, branch elsewhere
                if (A == 0) {
                    //> ldy #$06              ;load offset for crouching
                    Y = 0x06
                    //> lda CrouchingFlag     ;get crouching flag
                    A = crouchingFlag
                    //> bne NonAnimatedActs   ;if set, branch to get offset for graphics table
                    if (!(A == 0)) {
                        //  goto NonAnimatedActs -> nonAnimatedActs
                        nonAnimatedActs(Y)
                        return A
                    }
                    //> ldy #$00              ;otherwise load offset for jumping
                    Y = 0x00
                    //> jmp NonAnimatedActs   ;go to get offset to graphics table
                    return nonAnimatedActs(Y)
                }
            }
            //> ProcOnGroundActs:
            //> ldy #$06                   ;load offset for crouching
            Y = 0x06
            //> lda CrouchingFlag          ;get crouching flag
            A = crouchingFlag
            //> bne NonAnimatedActs        ;if set, branch to get offset for graphics table
            if (!(A == 0)) {
                //  goto NonAnimatedActs -> nonAnimatedActs
                nonAnimatedActs(Y)
                return A
            }
            //> ldy #$02                   ;load offset for standing
            Y = 0x02
            //> lda Player_X_Speed         ;check player's horizontal speed
            A = playerXSpeed
            //> ora Left_Right_Buttons     ;and left/right controller bits
            A = A or leftRightButtons
            //> beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
            if (A == 0) {
                //  goto NonAnimatedActs -> nonAnimatedActs
                nonAnimatedActs(Y)
                return A
            }
            //> lda Player_XSpeedAbsolute  ;load walking/running speed
            A = playerXspeedabsolute
            //> cmp #$09
            //> bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
            if (A >= 0x09) {
                //> lda Player_MovingDir       ;otherwise check to see if moving direction
                A = playerMovingdir
                //> and PlayerFacingDir        ;and facing direction are the same
                A = A and playerFacingDir
                //> bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
                if (A == 0) {
                    //> iny                        ;otherwise increment to skid offset ($03)
                    Y = (Y + 1) and 0xFF
                    //  Fall-through tail call to nonAnimatedActs
                    return nonAnimatedActs(Y)
                }
            }
        } else {
            //> ActionFalling:
            //> ldy #$04                  ;load offset for walking/running
            Y = 0x04
            //> jsr GetGfxOffsetAdder     ;get offset to graphics table
            temp0 = getGfxOffsetAdder(Y)
            //> jmp GetCurrentAnimOffset  ;execute instructions for falling state
            return getCurrentAnimOffset(temp0)
            //> ActionWalkRun:
            //> ldy #$04               ;load offset for walking/running
            Y = 0x04
            //> jsr GetGfxOffsetAdder  ;get offset to graphics table
            temp1 = getGfxOffsetAdder(Y)
            //> jmp FourFrameExtent    ;execute instructions for normal state
            return fourFrameExtent(temp1)
        }
    }
    //> ActionClimbing:
    //> ldy #$05               ;load offset for climbing
    Y = 0x05
    //> lda Player_Y_Speed     ;check player's vertical speed
    A = playerYSpeed
    //> beq NonAnimatedActs    ;if no speed, branch, use offset as-is
    if (A == 0) {
        //> NonAnimatedActs:
        //> jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
        temp2 = getGfxOffsetAdder(Y)
        //> lda #$00
        A = 0x00
        //> sta PlayerAnimCtrl         ;initialize animation frame control
        playerAnimCtrl = A
        //> lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
        A = playerGfxTblOffsets[temp2]
        //> rts
        return A
    } else {
        //> jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
        temp3 = getGfxOffsetAdder(Y)
        //> jmp ThreeFrameExtent   ;then skip ahead to more code
        return threeFrameExtent(temp3)
    }
}

// Decompiled from NonAnimatedActs
fun nonAnimatedActs(Y: Int): Int {
    var A: Int = 0
    var temp0: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> NonAnimatedActs:
    //> jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
    temp0 = getGfxOffsetAdder(Y)
    //> lda #$00
    A = 0x00
    //> sta PlayerAnimCtrl         ;initialize animation frame control
    playerAnimCtrl = A
    //> lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
    A = playerGfxTblOffsets[temp0]
    //> rts
    return A
}

// Decompiled from GetCurrentAnimOffset
fun getCurrentAnimOffset(Y: Int): Int {
    var A: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    //> GetCurrentAnimOffset:
    //> lda PlayerAnimCtrl         ;get animation frame control
    A = playerAnimCtrl
    //> jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
    return getOffsetFromAnimCtrl(A, Y)
}

// Decompiled from FourFrameExtent
fun fourFrameExtent(Y: Int): Int {
    var A: Int = 0
    //> FourFrameExtent:
    //> lda #$03              ;load upper extent for frame control
    A = 0x03
    //> jmp AnimationControl  ;jump to get offset and animate player object
    return animationControl(A, Y)
}

// Decompiled from ThreeFrameExtent
fun threeFrameExtent(Y: Int): Int {
    var A: Int = 0
    //> ThreeFrameExtent:
    //> lda #$02              ;load upper extent for frame control for climbing
    A = 0x02
    //  Fall-through tail call to animationControl
    return animationControl(A, Y)
}

// Decompiled from AnimationControl
fun animationControl(A: Int, Y: Int): Int {
    var A: Int = A
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    //> AnimationControl:
    //> sta $00                   ;store upper extent here
    memory[0x0] = A.toUByte()
    //> jsr GetCurrentAnimOffset  ;get proper offset to graphics table
    temp0 = getCurrentAnimOffset(Y)
    //> pha                       ;save offset to stack
    push(temp0)
    //> lda PlayerAnimTimer       ;load animation frame timer
    A = playerAnimTimer
    //> bne ExAnimC               ;branch if not expired
    Y = Y
    if (A == 0) {
        //> lda PlayerAnimTimerSet    ;get animation frame timer amount
        A = playerAnimTimerSet
        //> sta PlayerAnimTimer       ;and set timer accordingly
        playerAnimTimer = A
        //> lda PlayerAnimCtrl
        A = playerAnimCtrl
        //> clc                       ;add one to animation frame control
        //> adc #$01
        temp1 = A + 0x01
        A = temp1 and 0xFF
        //> cmp $00                   ;compare to upper extent
        //> bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
        if (A >= memory[0x0].toInt()) {
            //> lda #$00                  ;otherwise initialize frame control
            A = 0x00
        }
        //> SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
        playerAnimCtrl = A
    }
    //> ExAnimC:  pla                       ;get offset to graphics table from stack and leave
    A = pull()
    //> rts
    return A
}

// Decompiled from GetGfxOffsetAdder
fun getGfxOffsetAdder(Y: Int): Int {
    var A: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var playerSize by MemoryByte(PlayerSize)
    //> GetGfxOffsetAdder:
    //> lda PlayerSize  ;get player's size
    A = playerSize
    //> beq SzOfs       ;if player big, use current offset as-is
    Y = Y
    if (A != 0) {
        //> tya             ;for big player
        A = Y
        //> clc             ;otherwise add eight bytes to offset
        //> adc #$08        ;for small player
        temp0 = A + 0x08
        A = temp0 and 0xFF
        //> tay
        Y = A
    }
    //> SzOfs:  rts             ;go back
    return Y
}

// Decompiled from HandleChangeSize
fun handleChangeSize(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    val changeSizeOffsetAdder by MemoryByteIndexed(ChangeSizeOffsetAdder)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> HandleChangeSize:
    //> ldy PlayerAnimCtrl           ;get animation frame control
    Y = playerAnimCtrl
    //> lda FrameCounter
    A = frameCounter
    //> and #%00000011               ;get frame counter and execute this code every
    A = A and 0x03
    //> bne GorSLog                  ;fourth frame, otherwise branch ahead
    if (A == 0) {
        //> iny                          ;increment frame control
        Y = (Y + 1) and 0xFF
        //> cpy #$0a                     ;check for preset upper extent
        //> bcc CSzNext                  ;if not there yet, skip ahead to use
        if (Y >= 0x0A) {
            //> ldy #$00                     ;otherwise initialize both grow/shrink flag
            Y = 0x00
            //> sty PlayerChangeSizeFlag     ;and animation frame control
            playerChangeSizeFlag = Y
        }
        //> CSzNext: sty PlayerAnimCtrl           ;store proper frame control
        playerAnimCtrl = Y
    }
    //> GorSLog: lda PlayerSize               ;get player's size
    A = playerSize
    //> bne ShrinkPlayer             ;if player small, skip ahead to next part
    if (A == 0) {
        //> lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
        A = changeSizeOffsetAdder[Y]
        //> ldy #$0f                     ;load offset for player growing
        Y = 0x0F
        //  Fall-through tail call to getOffsetFromAnimCtrl
        return getOffsetFromAnimCtrl(A, Y)
    } else {
        //> ShrinkPlayer:
        //> tya                          ;add ten bytes to frame control as offset
        A = Y
        //> clc
        //> adc #$0a                     ;this thing apparently uses two of the swimming frames
        temp0 = A + 0x0A
        A = temp0 and 0xFF
        //> tax                          ;to draw the player shrinking
        X = A
        //> ldy #$09                     ;load offset for small player swimming
        Y = 0x09
        //> lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
        A = changeSizeOffsetAdder[X]
        //> bne ShrPlF                   ;and branch to use offset if nonzero
        X = X
        if (A == 0) {
            //> ldy #$01                     ;otherwise load offset for big player swimming
            Y = 0x01
        }
    }
    //> ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
    A = playerGfxTblOffsets[Y]
    //> rts                          ;and leave
    return A
}

// Decompiled from GetOffsetFromAnimCtrl
fun getOffsetFromAnimCtrl(A: Int, Y: Int): Int {
    var A: Int = A
    var temp0: Int = 0
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> GetOffsetFromAnimCtrl:
    //> asl                        ;multiply animation frame control
    val orig0: Int = A
    A = (orig0 shl 1) and 0xFF
    //> asl                        ;by eight to get proper amount
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFF
    //> asl                        ;to add to our offset
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFF
    //> adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
    temp0 = A + playerGfxTblOffsets[Y] + if ((orig2 and 0x80) != 0) 1 else 0
    //> rts                        ;and return with result in A
    return temp0 and 0xFF
}

// Decompiled from ChkForPlayerAttrib
fun chkForPlayerAttrib() {
    var A: Int = 0
    var Y: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    //> ChkForPlayerAttrib:
    //> ldy Player_SprDataOffset    ;get sprite data offset
    Y = playerSprdataoffset
    //> lda GameEngineSubroutine
    A = gameEngineSubroutine
    //> cmp #$0b                    ;if executing specific game engine routine,
    //> beq KilledAtt               ;branch to change third and fourth row OAM attributes
    if (A != 0x0B) {
        //> lda PlayerGfxOffset         ;get graphics table offset
        A = playerGfxOffset
        //> cmp #$50
        //> beq C_S_IGAtt               ;if crouch offset, either standing offset,
        if (A != 0x50) {
            //> cmp #$b8                    ;or intermediate growing offset,
            //> beq C_S_IGAtt               ;go ahead and execute code to change
            if (A != 0xB8) {
                //> cmp #$c0                    ;fourth row OAM attributes only
                //> beq C_S_IGAtt
                if (A != 0xC0) {
                    //> cmp #$c8
                    //> bne ExPlyrAt                ;if none of these, branch to leave
                    if (!(A == 0xC8)) {
                        //  goto ExPlyrAt (internal forward branch)
                        //> ExPlyrAt:  rts                         ;leave
                        return
                    }
                }
            }
        }
    }
    //> KilledAtt: lda Sprite_Attributes+16,y
    A = spriteAttributes[16 + Y]
    //> and #%00111111              ;mask out horizontal and vertical flip bits
    A = A and 0x3F
    //> sta Sprite_Attributes+16,y  ;for third row sprites and save
    spriteAttributes[16 + Y] = A
    //> lda Sprite_Attributes+20,y
    A = spriteAttributes[20 + Y]
    //> and #%00111111
    A = A and 0x3F
    //> ora #%01000000              ;set horizontal flip bit for second
    A = A or 0x40
    //> sta Sprite_Attributes+20,y  ;sprite in the third row
    spriteAttributes[20 + Y] = A
    //> C_S_IGAtt: lda Sprite_Attributes+24,y
    A = spriteAttributes[24 + Y]
    //> and #%00111111              ;mask out horizontal and vertical flip bits
    A = A and 0x3F
    //> sta Sprite_Attributes+24,y  ;for fourth row sprites and save
    spriteAttributes[24 + Y] = A
    //> lda Sprite_Attributes+28,y
    A = spriteAttributes[28 + Y]
    //> and #%00111111
    A = A and 0x3F
    //> ora #%01000000              ;set horizontal flip bit for second
    A = A or 0x40
    //> sta Sprite_Attributes+28,y  ;sprite in the fourth row
    spriteAttributes[28 + Y] = A
    //> ExPlyrAt:  rts                         ;leave
    return
}

// Decompiled from RelativePlayerPosition
fun relativePlayerPosition(): Int {
    var X: Int = 0
    var Y: Int = 0
    //> RelativePlayerPosition:
    //> ldx #$00      ;set offsets for relative cooordinates
    X = 0x00
    //> ldy #$00      ;routine to correspond to player object
    Y = 0x00
    //> jmp RelWOfs   ;get the coordinates
    return relWOfs(X, Y)
}

// Decompiled from RelativeBubblePosition
fun relativeBubblePosition(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> RelativeBubblePosition:
    //> ldy #$01                ;set for air bubble offsets
    Y = 0x01
    //> jsr GetProperObjOffset  ;modify X to get proper air bubble offset
    temp0 = getProperObjOffset(X, Y)
    X = temp0
    //> ldy #$03
    Y = 0x03
    //> jmp RelWOfs             ;get the coordinates
    return relWOfs(temp0, Y)
}

// Decompiled from RelativeFireballPosition
fun relativeFireballPosition(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> RelativeFireballPosition:
    //> ldy #$00                    ;set for fireball offsets
    Y = 0x00
    //> jsr GetProperObjOffset      ;modify X to get proper fireball offset
    temp0 = getProperObjOffset(X, Y)
    X = temp0
    //> ldy #$02
    Y = 0x02
    //  Fall-through tail call to relWOfs
    return relWOfs(temp0, Y)
}

// Decompiled from RelWOfs
fun relWOfs(X: Int, Y: Int): Int {
    var X: Int = X
    var objectOffset by MemoryByte(ObjectOffset)
    //> RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
    getObjRelativePosition(X, Y)
    //> ldx ObjectOffset            ;return original offset
    X = objectOffset
    //> rts                         ;leave
    return X
}

// Decompiled from RelativeMiscPosition
fun relativeMiscPosition(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> RelativeMiscPosition:
    //> ldy #$02                ;set for misc object offsets
    Y = 0x02
    //> jsr GetProperObjOffset  ;modify X to get proper misc object offset
    temp0 = getProperObjOffset(X, Y)
    X = temp0
    //> ldy #$06
    Y = 0x06
    //> jmp RelWOfs             ;get the coordinates
    return relWOfs(temp0, Y)
}

// Decompiled from RelativeEnemyPosition
fun relativeEnemyPosition(X: Int): Int {
    var A: Int = 0
    var Y: Int = 0
    //> RelativeEnemyPosition:
    //> lda #$01                     ;get coordinates of enemy object
    A = 0x01
    //> ldy #$01                     ;relative to the screen
    Y = 0x01
    //> jmp VariableObjOfsRelPos
    return variableObjOfsRelPos(A, X, Y)
}

// Decompiled from RelativeBlockPosition
fun relativeBlockPosition(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> RelativeBlockPosition:
    //> lda #$09                     ;get coordinates of one block object
    A = 0x09
    //> ldy #$04                     ;relative to the screen
    Y = 0x04
    //> jsr VariableObjOfsRelPos
    temp0 = variableObjOfsRelPos(A, X, Y)
    X = temp0
    //> inx                          ;adjust offset for other block object if any
    temp0 = (temp0 + 1) and 0xFF
    //> inx
    temp0 = (temp0 + 1) and 0xFF
    //> lda #$09
    A = 0x09
    //> iny                          ;adjust other and get coordinates for other one
    Y = (Y + 1) and 0xFF
    //  Fall-through tail call to variableObjOfsRelPos
    return variableObjOfsRelPos(A, temp0, Y)
}

// Decompiled from VariableObjOfsRelPos
fun variableObjOfsRelPos(A: Int, X: Int, Y: Int): Int {
    var X: Int = X
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> VariableObjOfsRelPos:
    //> stx $00                     ;store value to add to A here
    memory[0x0] = X.toUByte()
    //> clc
    //> adc $00                     ;add A to value stored
    temp0 = A + memory[0x0].toInt()
    //> tax                         ;use as enemy offset
    X = temp0 and 0xFF
    //> jsr GetObjRelativePosition
    getObjRelativePosition(X, Y)
    //> ldx ObjectOffset            ;reload old object offset and leave
    X = objectOffset
    //> rts
    return X
}

// Decompiled from GetObjRelativePosition
fun getObjRelativePosition(X: Int, Y: Int) {
    var A: Int = 0
    var temp0: Int = 0
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val sprobjectRelXpos by MemoryByteIndexed(SprObject_Rel_XPos)
    val sprobjectRelYpos by MemoryByteIndexed(SprObject_Rel_YPos)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    //> GetObjRelativePosition:
    //> lda SprObject_Y_Position,x  ;load vertical coordinate low
    A = sprobjectYPosition[X]
    //> sta SprObject_Rel_YPos,y    ;store here
    sprobjectRelYpos[Y] = A
    //> lda SprObject_X_Position,x  ;load horizontal coordinate
    A = sprobjectXPosition[X]
    //> sec                         ;subtract left edge coordinate
    //> sbc ScreenLeft_X_Pos
    temp0 = A - screenleftXPos
    A = temp0 and 0xFF
    //> sta SprObject_Rel_XPos,y    ;store result here
    sprobjectRelXpos[Y] = A
    //> rts
    return
}

// Decompiled from GetPlayerOffscreenBits
fun getPlayerOffscreenBits(): Int {
    var X: Int = 0
    var Y: Int = 0
    //> GetPlayerOffscreenBits:
    //> ldx #$00                 ;set offsets for player-specific variables
    X = 0x00
    //> ldy #$00                 ;and get offscreen information about player
    Y = 0x00
    //> jmp GetOffScreenBitsSet
    return getOffScreenBitsSet(X, Y)
}

// Decompiled from GetFireballOffscreenBits
fun getFireballOffscreenBits(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> GetFireballOffscreenBits:
    //> ldy #$00                 ;set for fireball offsets
    Y = 0x00
    //> jsr GetProperObjOffset   ;modify X to get proper fireball offset
    temp0 = getProperObjOffset(X, Y)
    X = temp0
    //> ldy #$02                 ;set other offset for fireball's offscreen bits
    Y = 0x02
    //> jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
    return getOffScreenBitsSet(temp0, Y)
}

// Decompiled from GetBubbleOffscreenBits
fun getBubbleOffscreenBits(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> GetBubbleOffscreenBits:
    //> ldy #$01                 ;set for air bubble offsets
    Y = 0x01
    //> jsr GetProperObjOffset   ;modify X to get proper air bubble offset
    temp0 = getProperObjOffset(X, Y)
    X = temp0
    //> ldy #$03                 ;set other offset for airbubble's offscreen bits
    Y = 0x03
    //> jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
    return getOffScreenBitsSet(temp0, Y)
}

// Decompiled from GetMiscOffscreenBits
fun getMiscOffscreenBits(X: Int): Int {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    //> GetMiscOffscreenBits:
    //> ldy #$02                 ;set for misc object offsets
    Y = 0x02
    //> jsr GetProperObjOffset   ;modify X to get proper misc object offset
    temp0 = getProperObjOffset(X, Y)
    X = temp0
    //> ldy #$06                 ;set other offset for misc object's offscreen bits
    Y = 0x06
    //> jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
    return getOffScreenBitsSet(temp0, Y)
}

// Decompiled from GetProperObjOffset
fun getProperObjOffset(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var temp0: Int = 0
    val objOffsetData by MemoryByteIndexed(ObjOffsetData)
    //> GetProperObjOffset:
    //> txa                  ;move offset to A
    A = X
    //> clc
    //> adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
    temp0 = A + objOffsetData[Y]
    //> tax                  ;put back in X and leave
    X = temp0 and 0xFF
    //> rts
    return X
}

// Decompiled from GetEnemyOffscreenBits
fun getEnemyOffscreenBits(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var Y: Int = 0
    //> GetEnemyOffscreenBits:
    //> lda #$01                 ;set A to add 1 byte in order to get enemy offset
    A = 0x01
    //> ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
    Y = 0x01
    //> jmp SetOffscrBitsOffset
    setOffscrBitsOffset(A, X, Y)
    return Pair(X, Y)
}

// Decompiled from GetBlockOffscreenBits
fun getBlockOffscreenBits(X: Int): Int {
    var A: Int = 0
    var Y: Int = 0
    //> GetBlockOffscreenBits:
    //> lda #$09       ;set A to add 9 bytes in order to get block obj offset
    A = 0x09
    //> ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
    Y = 0x04
    //  Fall-through tail call to setOffscrBitsOffset
    return setOffscrBitsOffset(A, X, Y)
}

// Decompiled from SetOffscrBitsOffset
fun setOffscrBitsOffset(A: Int, X: Int, Y: Int): Int {
    var X: Int = X
    var temp0: Int = 0
    //> SetOffscrBitsOffset:
    //> stx $00
    memory[0x0] = X.toUByte()
    //> clc           ;add contents of X to A to get
    //> adc $00       ;appropriate offset, then give back to X
    temp0 = A + memory[0x0].toInt()
    //> tax
    X = temp0 and 0xFF
    //  Fall-through tail call to getOffScreenBitsSet
    return getOffScreenBitsSet(X, Y)
}

// Decompiled from GetOffScreenBitsSet
fun getOffScreenBitsSet(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    A = Y
    //> pha
    push(A)
    //> jsr RunOffscrBitsSubs
    temp0 = runOffscrBitsSubs(A, X)
    //> asl                         ;move low nybble to high nybble
    val orig0: Int = temp0
    temp0 = (orig0 shl 1) and 0xFF
    //> asl
    val orig1: Int = temp0
    temp0 = (orig1 shl 1) and 0xFF
    //> asl
    val orig2: Int = temp0
    temp0 = (orig2 shl 1) and 0xFF
    //> asl
    val orig3: Int = temp0
    temp0 = (orig3 shl 1) and 0xFF
    //> ora $00                     ;mask together with previously saved low nybble
    temp0 = temp0 or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp0.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp1 = pull()
    //> tay
    Y = temp1
    //> lda $00                     ;get value here and store elsewhere
    A = memory[0x0].toInt()
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[Y] = A
    //> ldx ObjectOffset
    X = objectOffset
    //> rts
    return X
}

// Decompiled from RunOffscrBitsSubs
fun runOffscrBitsSubs(A: Int, X: Int): Int {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    //> RunOffscrBitsSubs:
    //> jsr GetXOffscreenBits  ;do subroutine here
    val pair0 = getXOffscreenBits(X)
    temp0 = pair0.first
    temp1 = pair0.second
    X = temp1
    //> lsr                    ;move high nybble to low
    val orig0: Int = temp0
    temp0 = orig0 shr 1
    //> lsr
    val orig1: Int = temp0
    temp0 = orig1 shr 1
    //> lsr
    val orig2: Int = temp0
    temp0 = orig2 shr 1
    //> lsr
    val orig3: Int = temp0
    temp0 = orig3 shr 1
    //> sta $00                ;store here
    memory[0x0] = temp0.toUByte()
    //> jmp GetYOffscreenBits
    return getYOffscreenBits(X)
}

// Decompiled from GetXOffscreenBits
fun getXOffscreenBits(X: Int): Pair<Int, Int> {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val defaultXOnscreenOfs by MemoryByteIndexed(DefaultXOnscreenOfs)
    val screenedgePageloc by MemoryByteIndexed(ScreenEdge_PageLoc)
    val screenedgeXPos by MemoryByteIndexed(ScreenEdge_X_Pos)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val xOffscreenBitsData by MemoryByteIndexed(XOffscreenBitsData)
    //> GetXOffscreenBits:
    //> stx $04                     ;save position in buffer to here
    memory[0x4] = X.toUByte()
    //> ldy #$01                    ;start with right side of screen
    Y = 0x01
    X = X
    loop0@ do {
        //> XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
        A = screenedgeXPos[Y]
        //> sec                         ;get difference between pixel coordinate of edge
        //> sbc SprObject_X_Position,x  ;and pixel coordinate of object position
        temp0 = A - sprobjectXPosition[X]
        A = temp0 and 0xFF
        //> sta $07                     ;store here
        memory[0x7] = A.toUByte()
        //> lda ScreenEdge_PageLoc,y    ;get page location of edge
        A = screenedgePageloc[Y]
        //> sbc SprObject_PageLoc,x     ;subtract from page location of object position
        temp1 = A - sprobjectPageloc[X] - if (temp0 >= 0) 0 else 1
        A = temp1 and 0xFF
        //> ldx DefaultXOnscreenOfs,y   ;load offset value here
        X = defaultXOnscreenOfs[Y]
        //> cmp #$00
        //> bmi XLdBData                ;if beyond right edge or in front of left edge, branch
        if ((A and 0xFF and 0x80) == 0) {
            //> ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
            X = defaultXOnscreenOfs[1 + Y]
            //> cmp #$01
            //> bpl XLdBData                ;if one page or more to the left of either edge, branch
            if (((A - 0x01) and 0xFF and 0x80) != 0) {
                //> lda #$38                    ;if no branching, load value here and store
                A = 0x38
                //> sta $06
                memory[0x6] = A.toUByte()
                //> lda #$08                    ;load some other value and execute subroutine
                A = 0x08
                //> jsr DividePDiff
                temp2 = dividePDiff(A, X, Y)
                X = temp2
            }
        }
        //> XLdBData: lda XOffscreenBitsData,x    ;get bits here
        A = xOffscreenBitsData[X]
        //> ldx $04                     ;reobtain position in buffer
        X = memory[0x4].toInt()
        //> cmp #$00                    ;if bits not zero, branch to leave
        //> bne ExXOfsBS
        if (A == 0x00) {
            //> dey                         ;otherwise, do left side of screen now
            Y = (Y - 1) and 0xFF
            //> bpl XOfsLoop                ;branch if not already done with left side
            if (!((Y and 0x80) != 0)) {
                //  continue loop (branch back to XOfsLoop)
                continue@loop0
            }
        } else {
            break@loop0
        }
    } while ((Y and 0x80) == 0)
    //> ExXOfsBS: rts
    return Pair(A, X)
}

// Decompiled from GetYOffscreenBits
fun getYOffscreenBits(X: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val defaultYOnscreenOfs by MemoryByteIndexed(DefaultYOnscreenOfs)
    val highPosUnitData by MemoryByteIndexed(HighPosUnitData)
    val sprobjectYHighpos by MemoryByteIndexed(SprObject_Y_HighPos)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    val yOffscreenBitsData by MemoryByteIndexed(YOffscreenBitsData)
    //> GetYOffscreenBits:
    //> stx $04                      ;save position in buffer to here
    memory[0x4] = X.toUByte()
    //> ldy #$01                     ;start with top of screen
    Y = 0x01
    X = X
    loop0@ do {
        //> YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
        A = highPosUnitData[Y]
        //> sec
        //> sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
        temp0 = A - sprobjectYPosition[X]
        A = temp0 and 0xFF
        //> sta $07                      ;store here
        memory[0x7] = A.toUByte()
        //> lda #$01                     ;subtract one from vertical high byte of object
        A = 0x01
        //> sbc SprObject_Y_HighPos,x
        temp1 = A - sprobjectYHighpos[X] - if (temp0 >= 0) 0 else 1
        A = temp1 and 0xFF
        //> ldx DefaultYOnscreenOfs,y    ;load offset value here
        X = defaultYOnscreenOfs[Y]
        //> cmp #$00
        //> bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
        if ((A and 0xFF and 0x80) == 0) {
            //> ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
            X = defaultYOnscreenOfs[1 + Y]
            //> cmp #$01
            //> bpl YLdBData                 ;if one vertical unit or more above the screen, branch
            if (((A - 0x01) and 0xFF and 0x80) != 0) {
                //> lda #$20                     ;if no branching, load value here and store
                A = 0x20
                //> sta $06
                memory[0x6] = A.toUByte()
                //> lda #$04                     ;load some other value and execute subroutine
                A = 0x04
                //> jsr DividePDiff
                temp2 = dividePDiff(A, X, Y)
                X = temp2
            }
        }
        //> YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
        A = yOffscreenBitsData[X]
        //> ldx $04                      ;reobtain position in buffer
        X = memory[0x4].toInt()
        //> cmp #$00
        //> bne ExYOfsBS                 ;if bits not zero, branch to leave
        if (A == 0x00) {
            //> dey                          ;otherwise, do bottom of the screen now
            Y = (Y - 1) and 0xFF
            //> bpl YOfsLoop
            if (!((Y and 0x80) != 0)) {
                //  continue loop (branch back to YOfsLoop)
                continue@loop0
            }
        } else {
            break@loop0
        }
    } while ((Y and 0x80) == 0)
    //> ExYOfsBS: rts
    return A
}

// Decompiled from DividePDiff
fun dividePDiff(A: Int, X: Int, Y: Int): Int {
    var A: Int = A
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    //> DividePDiff:
    //> sta $05       ;store current value in A here
    memory[0x5] = A.toUByte()
    //> lda $07       ;get pixel difference
    A = memory[0x7].toInt()
    //> cmp $06       ;compare to preset value
    //> bcs ExDivPD   ;if pixel difference >= preset value, branch
    X = X
    Y = Y
    if (!(A >= memory[0x6].toInt())) {
        //> lsr           ;divide by eight
        val orig0: Int = A
        A = orig0 shr 1
        //> lsr
        val orig1: Int = A
        A = orig1 shr 1
        //> lsr
        val orig2: Int = A
        A = orig2 shr 1
        //> and #$07      ;mask out all but 3 LSB
        A = A and 0x07
        //> cpy #$01      ;right side of the screen or top?
        //> bcs SetOscrO  ;if so, branch, use difference / 8 as offset
        if (!(Y >= 0x01)) {
            //> adc $05       ;if not, add value to difference / 8
            temp0 = A + memory[0x5].toInt() + if (Y >= 0x01) 1 else 0
            A = temp0 and 0xFF
        }
        //> SetOscrO: tax           ;use as offset
        X = A
    }
    //> ExDivPD:  rts           ;leave
    return X
}

// Decompiled from DrawSpriteObject
fun drawSpriteObject(X: Int, Y: Int): Int {
    var A: Int = 0
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawSpriteObject:
    //> lda $03                    ;get saved flip control bits
    A = memory[0x3].toInt()
    //> lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> lsr                        ;move d1 into carry
    val orig1: Int = A
    A = orig1 shr 1
    //> lda $00
    A = memory[0x0].toInt()
    //> bcc NoHFlip                ;if d1 not set, branch
    X = X
    Y = Y
    if ((orig1 and 0x01) != 0) {
        //> sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
        spriteTilenumber[4 + Y] = A
        //> lda $01                    ;and second into first sprite
        A = memory[0x1].toInt()
        //> sta Sprite_Tilenumber,y
        spriteTilenumber[Y] = A
        //> lda #$40                   ;activate horizontal flip OAM attribute
        A = 0x40
        //> bne SetHFAt                ;and unconditionally branch
        if (!(A == 0)) {
            //  goto SetHFAt (internal forward branch)
            //> SetHFAt: ora $04                    ;add other OAM attributes if necessary
            A = A or memory[0x4].toInt()
            //> sta Sprite_Attributes,y    ;store sprite attributes
            spriteAttributes[Y] = A
            //> sta Sprite_Attributes+4,y
            spriteAttributes[4 + Y] = A
            //> lda $02                    ;now the y coordinates
            A = memory[0x2].toInt()
            //> sta Sprite_Y_Position,y    ;note because they are
            spriteYPosition[Y] = A
            //> sta Sprite_Y_Position+4,y  ;side by side, they are the same
            spriteYPosition[4 + Y] = A
            //> lda $05
            A = memory[0x5].toInt()
            //> sta Sprite_X_Position,y    ;store x coordinate, then
            spriteXPosition[Y] = A
            //> clc                        ;add 8 pixels and store another to
            //> adc #$08                   ;put them side by side
            temp0 = A + 0x08
            A = temp0 and 0xFF
            //> sta Sprite_X_Position+4,y
            spriteXPosition[4 + Y] = A
            //> lda $02                    ;add eight pixels to the next y
            A = memory[0x2].toInt()
            //> clc                        ;coordinate
            //> adc #$08
            temp1 = A + 0x08
            A = temp1 and 0xFF
            //> sta $02
            memory[0x2] = A.toUByte()
            //> tya                        ;add eight to the offset in Y to
            A = Y
            //> clc                        ;move to the next two sprites
            //> adc #$08
            temp2 = A + 0x08
            A = temp2 and 0xFF
            //> tay
            Y = A
            //> inx                        ;increment offset to return it to the
            X = (X + 1) and 0xFF
            //> inx                        ;routine that called this subroutine
            X = (X + 1) and 0xFF
            //> rts
            return X
        }
    }
    //> NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
    spriteTilenumber[Y] = A
    //> lda $01                    ;and second into second sprite
    A = memory[0x1].toInt()
    //> sta Sprite_Tilenumber+4,y
    spriteTilenumber[4 + Y] = A
    //> lda #$00                   ;clear bit for horizontal flip
    A = 0x00
    //> SetHFAt: ora $04                    ;add other OAM attributes if necessary
    A = A or memory[0x4].toInt()
    //> sta Sprite_Attributes,y    ;store sprite attributes
    spriteAttributes[Y] = A
    //> sta Sprite_Attributes+4,y
    spriteAttributes[4 + Y] = A
    //> lda $02                    ;now the y coordinates
    A = memory[0x2].toInt()
    //> sta Sprite_Y_Position,y    ;note because they are
    spriteYPosition[Y] = A
    //> sta Sprite_Y_Position+4,y  ;side by side, they are the same
    spriteYPosition[4 + Y] = A
    //> lda $05
    A = memory[0x5].toInt()
    //> sta Sprite_X_Position,y    ;store x coordinate, then
    spriteXPosition[Y] = A
    //> clc                        ;add 8 pixels and store another to
    //> adc #$08                   ;put them side by side
    temp3 = A + 0x08
    A = temp3 and 0xFF
    //> sta Sprite_X_Position+4,y
    spriteXPosition[4 + Y] = A
    //> lda $02                    ;add eight pixels to the next y
    A = memory[0x2].toInt()
    //> clc                        ;coordinate
    //> adc #$08
    temp4 = A + 0x08
    A = temp4 and 0xFF
    //> sta $02
    memory[0x2] = A.toUByte()
    //> tya                        ;add eight to the offset in Y to
    A = Y
    //> clc                        ;move to the next two sprites
    //> adc #$08
    temp5 = A + 0x08
    A = temp5 and 0xFF
    //> tay
    Y = A
    //> inx                        ;increment offset to return it to the
    X = (X + 1) and 0xFF
    //> inx                        ;routine that called this subroutine
    X = (X + 1) and 0xFF
    //> rts
    return X
}

// Decompiled from SoundEngine
fun soundEngine() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var dacCounter by MemoryByte(DAC_Counter)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var joypadPort2 by MemoryByte(JOYPAD_PORT2)
    var noiseSoundBuffer by MemoryByte(NoiseSoundBuffer)
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var operMode by MemoryByte(OperMode)
    var pauseModeFlag by MemoryByte(PauseModeFlag)
    var pauseSoundBuffer by MemoryByte(PauseSoundBuffer)
    var pauseSoundQueue by MemoryByte(PauseSoundQueue)
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    var square1SoundBuffer by MemoryByte(Square1SoundBuffer)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val sndDeltaReg by MemoryByteIndexed(SND_DELTA_REG)
    //> SoundEngine:
    //> lda OperMode              ;are we in title screen mode?
    A = operMode
    //> bne SndOn
    if (A == 0) {
        //> sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
        sndMasterctrlReg = A
        //> rts
        return
    } else {
        //> SndOn:   lda #$ff
        A = 0xFF
        //> sta JOYPAD_PORT2          ;disable irqs and set frame counter mode???
        joypadPort2 = A
        //> lda #$0f
        A = 0x0F
        //> sta SND_MASTERCTRL_REG    ;enable first four channels
        sndMasterctrlReg = A
        //> lda PauseModeFlag         ;is sound already in pause mode?
        A = pauseModeFlag
        //> bne InPause
        if (A == 0) {
            //> lda PauseSoundQueue       ;if not, check pause sfx queue
            A = pauseSoundQueue
            //> cmp #$01
            //> bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
            if (!(A == 0x01)) {
                //  goto RunSoundSubroutines (internal forward branch)
                //> RunSoundSubroutines:
                //> jsr Square1SfxHandler  ;play sfx on square channel 1
                square1SfxHandler()
                //> jsr Square2SfxHandler  ; ''  ''  '' square channel 2
                square2SfxHandler()
                //> jsr NoiseSfxHandler    ; ''  ''  '' noise channel
                noiseSfxHandler()
                //> jsr MusicHandler       ;play music on all channels
                musicHandler()
                //> lda #$00               ;clear the music queues
                A = 0x00
                //> sta AreaMusicQueue
                areaMusicQueue = A
                //> sta EventMusicQueue
                eventMusicQueue = A
                return
            }
        }
    }
    //> InPause: lda PauseSoundBuffer      ;check pause sfx buffer
    A = pauseSoundBuffer
    //> bne ContPau
    if (A == 0) {
        //> lda PauseSoundQueue       ;check pause queue
        A = pauseSoundQueue
        //> beq SkipSoundSubroutines
        if (A != 0) {
            //> sta PauseSoundBuffer      ;if queue full, store in buffer and activate
            pauseSoundBuffer = A
            //> sta PauseModeFlag         ;pause mode to interrupt game sounds
            pauseModeFlag = A
            //> lda #$00                  ;disable sound and clear sfx buffers
            A = 0x00
            //> sta SND_MASTERCTRL_REG
            sndMasterctrlReg = A
            //> sta Square1SoundBuffer
            square1SoundBuffer = A
            //> sta Square2SoundBuffer
            square2SoundBuffer = A
            //> sta NoiseSoundBuffer
            noiseSoundBuffer = A
            //> lda #$0f
            A = 0x0F
            //> sta SND_MASTERCTRL_REG    ;enable sound again
            sndMasterctrlReg = A
            //> lda #$2a                  ;store length of sound in pause counter
            A = 0x2A
            //> sta Squ1_SfxLenCounter
            squ1Sfxlencounter = A
            //> PTone1F: lda #$44                  ;play first tone
            A = 0x44
            //> bne PTRegC                ;unconditional branch
            if (!(A == 0)) {
                //  goto PTRegC (internal forward branch)
                //> PTRegC:  ldx #$84
                X = 0x84
                //> ldy #$7f
                Y = 0x7F
                //> jsr PlaySqu1Sfx
                playSqu1Sfx(A, X, Y)
                return
            }
        }
    }
    //> ContPau: lda Squ1_SfxLenCounter    ;check pause length left
    A = squ1Sfxlencounter
    //> cmp #$24                  ;time to play second?
    //> beq PTone2F
    if (A != 0x24) {
        loop0@ do {
            //> PTone1F: lda #$44                  ;play first tone
            A = 0x44
            //> bne PTRegC                ;unconditional branch
            if (!(A == 0)) {
                //  goto PTRegC (internal forward branch)
                //> PTRegC:  ldx #$84
                X = 0x84
                //> ldy #$7f
                Y = 0x7F
                //> jsr PlaySqu1Sfx
                playSqu1Sfx(A, X, Y)
                return
            }
            //> cmp #$1e                  ;time to play first again?
            //> beq PTone1F
            if (A == 0x1E) {
                //  continue loop (branch back to PTone1F)
                continue@loop0
            }
        } while (A == 0x1E)
        //> cmp #$18                  ;time to play second again?
        //> bne DecPauC               ;only load regs during times, otherwise skip
        if (!(A == 0x18)) {
            //  goto DecPauC (internal forward branch)
            //> DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
            squ1Sfxlencounter = (squ1Sfxlencounter - 1) and 0xFF
            //> bne SkipSoundSubroutines
            if (!(squ1Sfxlencounter == 0)) {
                //  goto SkipSoundSubroutines (internal forward branch)
                //> SkipSoundSubroutines:
                //> lda #$00               ;clear the sound effects queues
                A = 0x00
                //> sta Square1SoundQueue
                square1SoundQueue = A
                //> sta Square2SoundQueue
                square2SoundQueue = A
                //> sta NoiseSoundQueue
                noiseSoundQueue = A
                //> sta PauseSoundQueue
                pauseSoundQueue = A
                //> ldy DAC_Counter        ;load some sort of counter
                Y = dacCounter
                //> lda AreaMusicBuffer
                A = areaMusicBuffer
                //> and #%00000011         ;check for specific music
                A = A and 0x03
                //> beq NoIncDAC
                if (A == 0) {
                    //  goto NoIncDAC (internal forward branch)
                    //> NoIncDAC: tya
                    A = Y
                    //> beq StrWave            ;if we are at zero, do not decrement
                    if (A == 0) {
                        //  goto StrWave (internal forward branch)
                        //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
                        sndDeltaReg[1] = Y
                        //> rts                    ;we are done here
                        return
                    }
                    //> dec DAC_Counter        ;decrement counter
                    dacCounter = (dacCounter - 1) and 0xFF
                    return
                }
                //> inc DAC_Counter        ;increment and check counter
                dacCounter = (dacCounter + 1) and 0xFF
                //> cpy #$30
                //> bcc StrWave            ;if not there yet, just store it
                if (!(Y >= 0x30)) {
                    //  goto StrWave (internal forward branch)
                    //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
                    sndDeltaReg[1] = Y
                    //> rts                    ;we are done here
                    return
                }
                return
            }
            //> lda #$00                  ;disable sound if in pause mode and
            A = 0x00
            //> sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
            sndMasterctrlReg = A
            //> lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
            A = pauseSoundBuffer
            //> cmp #$02                  ;if we need to be playing sound again
            //> bne SkipPIn
            if (!(A == 0x02)) {
                //  goto SkipPIn (internal forward branch)
                //> SkipPIn: lda #$00                  ;clear pause sfx buffer
                A = 0x00
                //> sta PauseSoundBuffer
                pauseSoundBuffer = A
                //> beq SkipSoundSubroutines
                if (A == 0) {
                    //  goto SkipSoundSubroutines (internal forward branch)
                    //> SkipSoundSubroutines:
                    //> lda #$00               ;clear the sound effects queues
                    A = 0x00
                    //> sta Square1SoundQueue
                    square1SoundQueue = A
                    //> sta Square2SoundQueue
                    square2SoundQueue = A
                    //> sta NoiseSoundQueue
                    noiseSoundQueue = A
                    //> sta PauseSoundQueue
                    pauseSoundQueue = A
                    //> ldy DAC_Counter        ;load some sort of counter
                    Y = dacCounter
                    //> lda AreaMusicBuffer
                    A = areaMusicBuffer
                    //> and #%00000011         ;check for specific music
                    A = A and 0x03
                    //> beq NoIncDAC
                    if (A == 0) {
                        //  goto NoIncDAC (internal forward branch)
                        //> NoIncDAC: tya
                        A = Y
                        //> beq StrWave            ;if we are at zero, do not decrement
                        if (A == 0) {
                            //  goto StrWave (internal forward branch)
                            //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
                            sndDeltaReg[1] = Y
                            //> rts                    ;we are done here
                            return
                        }
                        //> dec DAC_Counter        ;decrement counter
                        dacCounter = (dacCounter - 1) and 0xFF
                        return
                    }
                    //> inc DAC_Counter        ;increment and check counter
                    dacCounter = (dacCounter + 1) and 0xFF
                    //> cpy #$30
                    //> bcc StrWave            ;if not there yet, just store it
                    if (!(Y >= 0x30)) {
                        //  goto StrWave (internal forward branch)
                        //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
                        sndDeltaReg[1] = Y
                        //> rts                    ;we are done here
                        return
                    }
                    return
                }
                return
            }
            //> lda #$00                  ;clear pause mode to allow game sounds again
            A = 0x00
            //> sta PauseModeFlag
            pauseModeFlag = A
            return
        }
    }
    //> PTone2F: lda #$64                  ;store reg contents and play the pause sfx
    A = 0x64
    //> PTRegC:  ldx #$84
    X = 0x84
    //> ldy #$7f
    Y = 0x7F
    //> jsr PlaySqu1Sfx
    playSqu1Sfx(A, X, Y)
    //> DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
    squ1Sfxlencounter = (squ1Sfxlencounter - 1) and 0xFF
    //> bne SkipSoundSubroutines
    if (squ1Sfxlencounter == 0) {
        //> lda #$00                  ;disable sound if in pause mode and
        A = 0x00
        //> sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
        sndMasterctrlReg = A
        //> lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
        A = pauseSoundBuffer
        //> cmp #$02                  ;if we need to be playing sound again
        //> bne SkipPIn
        if (A == 0x02) {
            //> lda #$00                  ;clear pause mode to allow game sounds again
            A = 0x00
            //> sta PauseModeFlag
            pauseModeFlag = A
        }
        //> SkipPIn: lda #$00                  ;clear pause sfx buffer
        A = 0x00
        //> sta PauseSoundBuffer
        pauseSoundBuffer = A
        //> beq SkipSoundSubroutines
        if (A != 0) {
            //> RunSoundSubroutines:
            //> jsr Square1SfxHandler  ;play sfx on square channel 1
            square1SfxHandler()
            //> jsr Square2SfxHandler  ; ''  ''  '' square channel 2
            square2SfxHandler()
            //> jsr NoiseSfxHandler    ; ''  ''  '' noise channel
            noiseSfxHandler()
            //> jsr MusicHandler       ;play music on all channels
            musicHandler()
            //> lda #$00               ;clear the music queues
            A = 0x00
            //> sta AreaMusicQueue
            areaMusicQueue = A
            //> sta EventMusicQueue
            eventMusicQueue = A
        }
    }
    //> SkipSoundSubroutines:
    //> lda #$00               ;clear the sound effects queues
    A = 0x00
    //> sta Square1SoundQueue
    square1SoundQueue = A
    //> sta Square2SoundQueue
    square2SoundQueue = A
    //> sta NoiseSoundQueue
    noiseSoundQueue = A
    //> sta PauseSoundQueue
    pauseSoundQueue = A
    //> ldy DAC_Counter        ;load some sort of counter
    Y = dacCounter
    //> lda AreaMusicBuffer
    A = areaMusicBuffer
    //> and #%00000011         ;check for specific music
    A = A and 0x03
    //> beq NoIncDAC
    if (A != 0) {
        //> inc DAC_Counter        ;increment and check counter
        dacCounter = (dacCounter + 1) and 0xFF
        //> cpy #$30
        //> bcc StrWave            ;if not there yet, just store it
        if (!(Y >= 0x30)) {
            //  goto StrWave (internal forward branch)
            //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
            sndDeltaReg[1] = Y
            //> rts                    ;we are done here
            return
        }
    }
    //> NoIncDAC: tya
    A = Y
    //> beq StrWave            ;if we are at zero, do not decrement
    if (A != 0) {
        //> dec DAC_Counter        ;decrement counter
        dacCounter = (dacCounter - 1) and 0xFF
    }
    //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
    sndDeltaReg[1] = Y
    //> rts                    ;we are done here
    return
}

// Decompiled from Dump_Squ1_Regs
fun dumpSqu1Regs(X: Int, Y: Int) {
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    //> Dump_Squ1_Regs:
    //> sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
    sndSquare1Reg[1] = Y
    //> stx SND_SQUARE1_REG
    sndSquare1Reg[0] = X
    //> rts
    return
}

// Decompiled from PlaySqu1Sfx
fun playSqu1Sfx(A: Int, X: Int, Y: Int) {
    //> PlaySqu1Sfx:
    //> jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
    dumpSqu1Regs(X, Y)
    //  Fall-through tail call to setfreqSqu1
    setfreqSqu1(A)
    return
}

// Decompiled from SetFreq_Squ1
fun setfreqSqu1(A: Int) {
    var X: Int = 0
    //> SetFreq_Squ1:
    //> ldx #$00               ;set frequency reg offset for square 1 sound channel
    X = 0x00
    //  Fall-through tail call to dumpFreqRegs
    dumpFreqRegs(A)
    return
}

// Decompiled from Dump_Freq_Regs
fun dumpFreqRegs(A: Int) {
    var A: Int = A
    var Y: Int = 0
    val freqRegLookupTbl by MemoryByteIndexed(FreqRegLookupTbl)
    //> Dump_Freq_Regs:
    //> tay
    Y = A
    //> lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
    A = freqRegLookupTbl[1 + Y]
    //> beq NoTone                ;if zero, then do not load
    if (A == 0) {
        //  goto NoTone -> noTone
        noTone()
        return
    }
    //  Fall-through tail call to func_15149
    func_15149(A, 0, Y)
    return
}

// Decompiled from @15149
fun func_15149(A: Int, X: Int, Y: Int) {
    var A: Int = A
    val freqRegLookupTbl by MemoryByteIndexed(FreqRegLookupTbl)
    val sndRegister by MemoryByteIndexed(SND_REGISTER)
    //> sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
    sndRegister[2 + X] = A
    //> lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
    A = freqRegLookupTbl[Y]
    //> ora #%00001000            ;length counter
    A = A or 0x08
    //> sta SND_REGISTER+3,x
    sndRegister[3 + X] = A
    //  Fall-through tail call to noTone
    noTone()
    return
}

// Decompiled from NoTone
fun noTone() {
    //> NoTone: rts
    return
}

// Decompiled from Dump_Sq2_Regs
fun dumpSq2Regs(X: Int, Y: Int) {
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    //> Dump_Sq2_Regs:
    //> stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
    sndSquare2Reg[0] = X
    //> sty SND_SQUARE2_REG+1
    sndSquare2Reg[1] = Y
    //> rts
    return
}

// Decompiled from PlaySqu2Sfx
fun playSqu2Sfx(X: Int, Y: Int) {
    //> PlaySqu2Sfx:
    //> jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
    dumpSq2Regs(X, Y)
    //  Fall-through tail call to setfreqSqu2
    setfreqSqu2()
    return
}

// Decompiled from SetFreq_Squ2
fun setfreqSqu2() {
    var X: Int = 0
    //> SetFreq_Squ2:
    //> ldx #$04               ;set frequency reg offset for square 2 sound channel
    X = 0x04
    //> bne Dump_Freq_Regs     ;unconditional branch
    if (!(X == 0)) {
        //  goto Dump_Freq_Regs -> dumpFreqRegs
        dumpFreqRegs(0)
        return
    } else {
        //  Fall-through tail call to setfreqTri
        setfreqTri()
        return
    }
}

// Decompiled from SetFreq_Tri
fun setfreqTri() {
    var X: Int = 0
    //> SetFreq_Tri:
    //> ldx #$08               ;set frequency reg offset for triangle sound channel
    X = 0x08
    //> bne Dump_Freq_Regs     ;unconditional branch
    if (!(X == 0)) {
        //  goto Dump_Freq_Regs -> dumpFreqRegs
        dumpFreqRegs(0)
        return
    } else {
        //> ;--------------------------------
    }
    //> SwimStompEnvelopeData:
    //> .db $9f, $9b, $98, $96, $95, $94, $92, $90
    //> .db $90, $9a, $97, $95, $93, $92
    //  Fall-through tail call to playFlagpoleSlide
    playFlagpoleSlide()
    return
}

// Decompiled from PlayFlagpoleSlide
fun playFlagpoleSlide() {
    var A: Int = 0
    var X: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> PlayFlagpoleSlide:
    //> lda #$40               ;store length of flagpole sound
    A = 0x40
    //> sta Squ1_SfxLenCounter
    squ1Sfxlencounter = A
    //> lda #$62               ;load part of reg contents for flagpole sound
    A = 0x62
    //> jsr SetFreq_Squ1
    setfreqSqu1(A)
    //> ldx #$99               ;now load the rest
    X = 0x99
    //> bne FPS2nd
    if (!(X == 0)) {
        //  goto FPS2nd -> fPS2nd
        fPS2nd(X)
        return
    }
    //  Fall-through tail call to func_15184
    func_15184()
    return
}

// Decompiled from @15184
fun func_15184() {
    //  Fall-through tail call to playSmallJump
    playSmallJump()
    return
}

// Decompiled from PlaySmallJump
fun playSmallJump() {
    var A: Int = 0
    //> PlaySmallJump:
    //> lda #$26               ;branch here for small mario jumping sound
    A = 0x26
    //> bne JumpRegContents
    if (!(A == 0)) {
        //  goto JumpRegContents -> jumpRegContents
        jumpRegContents(A)
        return
    }
    //  Fall-through tail call to func_15188
    func_15188()
    return
}

// Decompiled from @15188
fun func_15188() {
    //  Fall-through tail call to playBigJump
    playBigJump()
    return
}

// Decompiled from PlayBigJump
fun playBigJump() {
    var A: Int = 0
    //> PlayBigJump:
    //> lda #$18               ;branch here for big mario jumping sound
    A = 0x18
    //  Fall-through tail call to jumpRegContents
    jumpRegContents(A)
    return
}

// Decompiled from JumpRegContents
fun jumpRegContents(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> JumpRegContents:
    //> ldx #$82               ;note that small and big jump borrow each others' reg contents
    X = 0x82
    //> ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
    Y = 0xA7
    //> jsr PlaySqu1Sfx
    playSqu1Sfx(A, X, Y)
    //> lda #$28               ;store length of sfx for both jumping sounds
    A = 0x28
    //> sta Squ1_SfxLenCounter ;then continue on here
    squ1Sfxlencounter = A
    //  Fall-through tail call to continueSndJump
    continueSndJump()
    return
}

// Decompiled from ContinueSndJump
fun continueSndJump() {
    var A: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> ContinueSndJump:
    //> lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
    A = squ1Sfxlencounter
    //> cmp #$25               ;check for time to play second part yet
    //> bne N2Prt
    if (!(A == 0x25)) {
        //  goto N2Prt -> n2Prt
        n2Prt(A)
        return
    }
    //  Fall-through tail call to func_15203
    func_15203(A)
    return
}

// Decompiled from @15203
fun func_15203(A: Int) {
    var X: Int = 0
    var Y: Int = 0
    //> ldx #$5f               ;load second part
    X = 0x5F
    //> ldy #$f6
    Y = 0xF6
    //> bne DmpJpFPS           ;unconditional branch
    if (!(Y == 0)) {
        //  goto DmpJpFPS -> dmpJpFPS
        dmpJpFPS(X, Y)
        return
    }
    //  Fall-through tail call to n2Prt
    n2Prt(A)
    return
}

// Decompiled from N2Prt
fun n2Prt(A: Int) {
    //> N2Prt:    cmp #$20               ;check for third part
    //> bne DecJpFPS
    if (!(A == 0x20)) {
        //  goto DecJpFPS -> decJpFPS
        decJpFPS()
        return
    }
    //  Fall-through tail call to func_15208
    func_15208()
    return
}

// Decompiled from @15208
fun func_15208() {
    var X: Int = 0
    //> ldx #$48               ;load third part
    X = 0x48
    //  Fall-through tail call to fPS2nd
    fPS2nd(X)
    return
}

// Decompiled from FPS2nd
fun fPS2nd(X: Int) {
    var Y: Int = 0
    //> FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
    Y = 0xBC
    //  Fall-through tail call to dmpJpFPS
    dmpJpFPS(X, Y)
    return
}

// Decompiled from DmpJpFPS
fun dmpJpFPS(X: Int, Y: Int) {
    var A: Int = 0
    //> DmpJpFPS: jsr Dump_Squ1_Regs
    dumpSqu1Regs(X, Y)
    //> bne DecJpFPS           ;unconditional branch outta here
    if (!(A == 0)) {
        //  goto DecJpFPS -> decJpFPS
        decJpFPS()
        return
    }
    //  Fall-through tail call to func_15212
    func_15212()
    return
}

// Decompiled from @15212
fun func_15212() {
    //  Fall-through tail call to playFireballThrow
    playFireballThrow()
    return
}

// Decompiled from PlayFireballThrow
fun playFireballThrow() {
    var A: Int = 0
    var Y: Int = 0
    //> PlayFireballThrow:
    //> lda #$05
    A = 0x05
    //> ldy #$99                 ;load reg contents for fireball throw sound
    Y = 0x99
    //> bne Fthrow               ;unconditional branch
    if (!(Y == 0)) {
        //  goto Fthrow -> fthrow
        fthrow(A, Y)
        return
    }
    //  Fall-through tail call to func_15217
    func_15217()
    return
}

// Decompiled from @15217
fun func_15217() {
    //  Fall-through tail call to playBump
    playBump()
    return
}

// Decompiled from PlayBump
fun playBump() {
    var A: Int = 0
    var Y: Int = 0
    //> PlayBump:
    //> lda #$0a                ;load length of sfx and reg contents for bump sound
    A = 0x0A
    //> ldy #$93
    Y = 0x93
    //  Fall-through tail call to fthrow
    fthrow(A, Y)
    return
}

// Decompiled from Fthrow
fun fthrow(A: Int, Y: Int) {
    var A: Int = A
    var X: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
    X = 0x9E
    //> sta Squ1_SfxLenCounter
    squ1Sfxlencounter = A
    //> lda #$0c                ;load offset for bump sound
    A = 0x0C
    //> jsr PlaySqu1Sfx
    playSqu1Sfx(A, X, Y)
    //  Fall-through tail call to continueBumpThrow
    continueBumpThrow()
    return
}

// Decompiled from ContinueBumpThrow
fun continueBumpThrow() {
    var A: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> ContinueBumpThrow:
    //> lda Squ1_SfxLenCounter  ;check for second part of bump sound
    A = squ1Sfxlencounter
    //> cmp #$06
    //> bne DecJpFPS
    if (!(A == 0x06)) {
        //  goto DecJpFPS -> decJpFPS
        decJpFPS()
        return
    }
    //  Fall-through tail call to func_15230
    func_15230()
    return
}

// Decompiled from @15230
fun func_15230() {
    var A: Int = 0
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    //> lda #$bb                ;load second part directly
    A = 0xBB
    //> sta SND_SQUARE1_REG+1
    sndSquare1Reg[1] = A
    //  Fall-through tail call to decJpFPS
    decJpFPS()
    return
}

// Decompiled from DecJpFPS
fun decJpFPS() {
    var A: Int = 0
    //> DecJpFPS: bne BranchToDecLength1  ;unconditional branch
    if (!(A == 0)) {
        //  goto BranchToDecLength1 -> branchToDecLength1
        branchToDecLength1()
        return
    }
    //  Fall-through tail call to func_15233
    func_15233()
    return
}

// Decompiled from @15233
fun func_15233() {
    //  Fall-through tail call to square1SfxHandler
    square1SfxHandler()
    return
}

// Decompiled from Square1SfxHandler
fun square1SfxHandler() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    var square1SoundBuffer by MemoryByte(Square1SoundBuffer)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    val swimStompEnvelopeData by MemoryByteIndexed(SwimStompEnvelopeData)
    //> Square1SfxHandler:
    //> ldy Square1SoundQueue   ;check for sfx in queue
    Y = square1SoundQueue
    //> beq CheckSfx1Buffer
    if (Y != 0) {
        //> sty Square1SoundBuffer  ;if found, put in buffer
        square1SoundBuffer = Y
        //> bmi PlaySmallJump       ;small jump
        if ((Y and 0x80) != 0) {
            //  goto PlaySmallJump -> playSmallJump
            playSmallJump()
            return
        }
        //> lsr Square1SoundQueue
        val orig0: Int = square1SoundQueue
        val carryFromLsr1: Boolean = (orig0 and 0x01) != 0
        square1SoundQueue = orig0 shr 1
        //> bcs PlayBigJump         ;big jump
        if (carryFromLsr1) {
            //  goto PlayBigJump -> playBigJump
            playBigJump()
            return
        }
        //> lsr Square1SoundQueue
        val orig2: Int = square1SoundQueue
        val carryFromLsr3: Boolean = (orig2 and 0x01) != 0
        square1SoundQueue = orig2 shr 1
        //> bcs PlayBump            ;bump
        if (carryFromLsr3) {
            //  goto PlayBump -> playBump
            playBump()
            return
        }
        //> lsr Square1SoundQueue
        val orig4: Int = square1SoundQueue
        val carryFromLsr5: Boolean = (orig4 and 0x01) != 0
        square1SoundQueue = orig4 shr 1
        //> bcs PlaySwimStomp       ;swim/stomp
        if (!carryFromLsr5) {
            //> lsr Square1SoundQueue
            val orig6: Int = square1SoundQueue
            val carryFromLsr7: Boolean = (orig6 and 0x01) != 0
            square1SoundQueue = orig6 shr 1
            //> bcs PlaySmackEnemy      ;smack enemy
            if (carryFromLsr7) {
                //  goto PlaySmackEnemy -> playSmackEnemy
                playSmackEnemy()
                return
            }
            //> lsr Square1SoundQueue
            val orig8: Int = square1SoundQueue
            val carryFromLsr9: Boolean = (orig8 and 0x01) != 0
            square1SoundQueue = orig8 shr 1
            //> bcs PlayPipeDownInj     ;pipedown/injury
            if (!carryFromLsr9) {
                //> lsr Square1SoundQueue
                val orig10: Int = square1SoundQueue
                val carryFromLsr11: Boolean = (orig10 and 0x01) != 0
                square1SoundQueue = orig10 shr 1
                //> bcs PlayFireballThrow   ;fireball throw
                if (carryFromLsr11) {
                    //  goto PlayFireballThrow -> playFireballThrow
                    playFireballThrow()
                    return
                }
                //> lsr Square1SoundQueue
                val orig12: Int = square1SoundQueue
                val carryFromLsr13: Boolean = (orig12 and 0x01) != 0
                square1SoundQueue = orig12 shr 1
                //> bcs PlayFlagpoleSlide   ;slide flagpole
                if (carryFromLsr13) {
                    //  goto PlayFlagpoleSlide -> playFlagpoleSlide
                    playFlagpoleSlide()
                    return
                }
            }
        }
    }
    //> CheckSfx1Buffer:
    //> lda Square1SoundBuffer   ;check for sfx in buffer
    A = square1SoundBuffer
    //> beq ExS1H                ;if not found, exit sub
    if (A != 0) {
        //> bmi ContinueSndJump      ;small mario jump
        if ((A and 0x80) != 0) {
            //  goto ContinueSndJump -> continueSndJump
            continueSndJump()
            return
        }
        //> lsr
        val orig14: Int = A
        A = orig14 shr 1
        //> bcs ContinueSndJump      ;big mario jump
        if ((orig14 and 0x01) != 0) {
            //  goto ContinueSndJump -> continueSndJump
            continueSndJump()
            return
        }
        //> lsr
        val orig15: Int = A
        A = orig15 shr 1
        //> bcs ContinueBumpThrow    ;bump
        if ((orig15 and 0x01) != 0) {
            //  goto ContinueBumpThrow -> continueBumpThrow
            continueBumpThrow()
            return
        }
        //> lsr
        val orig16: Int = A
        A = orig16 shr 1
        //> bcs ContinueSwimStomp    ;swim/stomp
        if ((orig16 and 0x01) == 0) {
            //> lsr
            val orig17: Int = A
            A = orig17 shr 1
            //> bcs ContinueSmackEnemy   ;smack enemy
            if ((orig17 and 0x01) != 0) {
                //  goto ContinueSmackEnemy -> continueSmackEnemy
                continueSmackEnemy()
                return
            }
            //> lsr
            val orig18: Int = A
            A = orig18 shr 1
            //> bcs ContinuePipeDownInj  ;pipedown/injury
            if ((orig18 and 0x01) == 0) {
                //> lsr
                val orig19: Int = A
                A = orig19 shr 1
                //> bcs ContinueBumpThrow    ;fireball throw
                if ((orig19 and 0x01) != 0) {
                    //  goto ContinueBumpThrow -> continueBumpThrow
                    continueBumpThrow()
                    return
                }
                //> lsr
                val orig20: Int = A
                A = orig20 shr 1
                //> bcs DecrementSfx1Length  ;slide flagpole
                if ((orig20 and 0x01) != 0) {
                    //  goto DecrementSfx1Length -> decrementSfx1Length
                    decrementSfx1Length()
                    return
                }
            }
        }
    }
    //> ExS1H: rts
    return
    //> PlaySwimStomp:
    //> lda #$0e               ;store length of swim/stomp sound
    A = 0x0E
    //> sta Squ1_SfxLenCounter
    squ1Sfxlencounter = A
    //> ldy #$9c               ;store reg contents for swim/stomp sound
    Y = 0x9C
    //> ldx #$9e
    X = 0x9E
    //> lda #$26
    A = 0x26
    //> jsr PlaySqu1Sfx
    playSqu1Sfx(A, X, Y)
    //> ContinueSwimStomp:
    //> ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
    Y = squ1Sfxlencounter
    //> lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
    A = swimStompEnvelopeData[-1 + Y]
    //> sta SND_SQUARE1_REG           ;envelope
    sndSquare1Reg[0] = A
    //> cpy #$06
    //> bne BranchToDecLength1
    if (!(Y == 0x06)) {
        //  goto BranchToDecLength1 -> branchToDecLength1
        branchToDecLength1()
        return
    } else {
        //> lda #$9e                      ;when the length counts down to a certain point, put this
        A = 0x9E
        //> sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
        sndSquare1Reg[2] = A
        //  Fall-through tail call to branchToDecLength1
        branchToDecLength1()
        return
    }
}

// Decompiled from BranchToDecLength1
fun branchToDecLength1() {
    var A: Int = 0
    //> BranchToDecLength1:
    //> bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
    if (!(A == 0)) {
        //  goto DecrementSfx1Length -> decrementSfx1Length
        decrementSfx1Length()
        return
    }
    //  Fall-through tail call to func_15294
    func_15294()
    return
}

// Decompiled from @15294
fun func_15294() {
    //  Fall-through tail call to playSmackEnemy
    playSmackEnemy()
    return
}

// Decompiled from PlaySmackEnemy
fun playSmackEnemy() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> PlaySmackEnemy:
    //> lda #$0e                 ;store length of smack enemy sound
    A = 0x0E
    //> ldy #$cb
    Y = 0xCB
    //> ldx #$9f
    X = 0x9F
    //> sta Squ1_SfxLenCounter
    squ1Sfxlencounter = A
    //> lda #$28                 ;store reg contents for smack enemy sound
    A = 0x28
    //> jsr PlaySqu1Sfx
    playSqu1Sfx(A, X, Y)
    //> bne DecrementSfx1Length  ;unconditional branch
    if (!(A == 0)) {
        //  goto DecrementSfx1Length -> decrementSfx1Length
        decrementSfx1Length()
        return
    }
    //  Fall-through tail call to func_15303
    func_15303()
    return
}

// Decompiled from @15303
fun func_15303() {
    //  Fall-through tail call to continueSmackEnemy
    continueSmackEnemy()
    return
}

// Decompiled from ContinueSmackEnemy
fun continueSmackEnemy() {
    var Y: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> ContinueSmackEnemy:
    //> ldy Squ1_SfxLenCounter  ;check about halfway through
    Y = squ1Sfxlencounter
    //> cpy #$08
    //> bne SmSpc
    if (!(Y == 0x08)) {
        //  goto SmSpc -> smSpc
        smSpc()
        return
    }
    //  Fall-through tail call to func_15308
    func_15308()
    return
}

// Decompiled from @15308
fun func_15308() {
    var A: Int = 0
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    //> lda #$a0                ;if we're at the about-halfway point, make the second tone
    A = 0xA0
    //> sta SND_SQUARE1_REG+2   ;in the smack enemy sound
    sndSquare1Reg[2] = A
    //> lda #$9f
    A = 0x9F
    //> bne SmTick
    if (!(A == 0)) {
        //  goto SmTick -> smTick
        smTick(A)
        return
    }
    //  Fall-through tail call to smSpc
    smSpc()
    return
}

// Decompiled from SmSpc
fun smSpc() {
    var A: Int = 0
    //> SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
    A = 0x90
    //  Fall-through tail call to smTick
    smTick(A)
    return
}

// Decompiled from SmTick
fun smTick(A: Int) {
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    //> SmTick: sta SND_SQUARE1_REG
    sndSquare1Reg[0] = A
    //  Fall-through tail call to decrementSfx1Length
    decrementSfx1Length()
    return
}

// Decompiled from DecrementSfx1Length
fun decrementSfx1Length() {
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    //> DecrementSfx1Length:
    //> dec Squ1_SfxLenCounter    ;decrement length of sfx
    squ1Sfxlencounter = (squ1Sfxlencounter - 1) and 0xFF
    //> bne ExSfx1
    if (!(squ1Sfxlencounter == 0)) {
        //  goto ExSfx1 -> exSfx1
        exSfx1()
        return
    } else {
        //  Fall-through tail call to stopSquare1Sfx
        stopSquare1Sfx()
        return
    }
}

// Decompiled from StopSquare1Sfx
fun stopSquare1Sfx() {
    var X: Int = 0
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    //> StopSquare1Sfx:
    //> ldx #$00                ;if end of sfx reached, clear buffer
    X = 0x00
    //> stx $f1                 ;and stop making the sfx
    memory[0xF1] = X.toUByte()
    //> ldx #$0e
    X = 0x0E
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = X
    //> ldx #$0f
    X = 0x0F
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = X
    //  Fall-through tail call to exSfx1
    exSfx1()
    return
}

// Decompiled from ExSfx1
fun exSfx1() {
    //> ExSfx1: rts
    return
}

// Decompiled from ContinueCGrabTTick
fun continueCGrabTTick() {
    var A: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    //> ContinueCGrabTTick:
    //> lda Squ2_SfxLenCounter  ;check for time to play second tone yet
    A = squ2Sfxlencounter
    //> cmp #$30                ;timer tick sound also executes this, not sure why
    //> bne N2Tone
    if (A == 0x30) {
        //> lda #$54                ;if so, load the tone directly into the reg
        A = 0x54
        //> sta SND_SQUARE2_REG+2
        sndSquare2Reg[2] = A
    }
    //> N2Tone: bne DecrementSfx2Length
    if (!(A == 0)) {
        //  goto DecrementSfx2Length -> decrementSfx2Length
        decrementSfx2Length()
        return
    } else {
        //  Fall-through tail call to playBlast
        playBlast()
        return
    }
}

// Decompiled from PlayBlast
fun playBlast() {
    var A: Int = 0
    var Y: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> PlayBlast:
    //> lda #$20                ;load length of fireworks/gunfire sound
    A = 0x20
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = A
    //> ldy #$94                ;load reg contents of fireworks/gunfire sound
    Y = 0x94
    //> lda #$5e
    A = 0x5E
    //> bne SBlasJ
    if (!(A == 0)) {
        //  goto SBlasJ -> sBlasJ
        sBlasJ()
        return
    }
    //  Fall-through tail call to func_15394
    func_15394()
    return
}

// Decompiled from @15394
fun func_15394() {
    //  Fall-through tail call to continueBlast
    continueBlast()
    return
}

// Decompiled from ContinueBlast
fun continueBlast() {
    var A: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> ContinueBlast:
    //> lda Squ2_SfxLenCounter  ;check for time to play second part
    A = squ2Sfxlencounter
    //> cmp #$18
    //> bne DecrementSfx2Length
    if (!(A == 0x18)) {
        //  goto DecrementSfx2Length -> decrementSfx2Length
        decrementSfx2Length()
        return
    }
    //  Fall-through tail call to func_15399
    func_15399()
    return
}

// Decompiled from @15399
fun func_15399() {
    var A: Int = 0
    var Y: Int = 0
    //> ldy #$93                ;load second part reg contents then
    Y = 0x93
    //> lda #$18
    A = 0x18
    //  Fall-through tail call to sBlasJ
    sBlasJ()
    return
}

// Decompiled from SBlasJ
fun sBlasJ() {
    var A: Int = 0
    //> SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
    if (!(A == 0)) {
        //  goto BlstSJp -> blstSJp
        blstSJp()
        return
    }
    //  Fall-through tail call to func_15402
    func_15402()
    return
}

// Decompiled from @15402
fun func_15402() {
    //  Fall-through tail call to playPowerUpGrab
    playPowerUpGrab()
    return
}

// Decompiled from PlayPowerUpGrab
fun playPowerUpGrab() {
    var A: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> PlayPowerUpGrab:
    //> lda #$36                    ;load length of power-up grab sound
    A = 0x36
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = A
    //  Fall-through tail call to continuePowerUpGrab
    continuePowerUpGrab()
    return
}

// Decompiled from ContinuePowerUpGrab
fun continuePowerUpGrab() {
    var A: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> ContinuePowerUpGrab:
    //> lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
    A = squ2Sfxlencounter
    //> lsr                         ;divide by 2
    val orig0: Int = A
    A = orig0 shr 1
    //> bcs DecrementSfx2Length     ;alter frequency every other frame
    if ((orig0 and 0x01) != 0) {
        //  goto DecrementSfx2Length -> decrementSfx2Length
        decrementSfx2Length()
        return
    }
    //  Fall-through tail call to func_15411
    func_15411(A)
    return
}

// Decompiled from @15411
fun func_15411(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    val powerUpGrabFreqData by MemoryByteIndexed(PowerUpGrabFreqData)
    //> tay
    Y = A
    //> lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
    A = powerUpGrabFreqData[-1 + Y]
    //> ldx #$5d                    ;store reg contents of power-up grab sound
    X = 0x5D
    //> ldy #$7f
    Y = 0x7F
    //  Fall-through tail call to loadSqu2Regs
    loadSqu2Regs(X, Y)
    return
}

// Decompiled from LoadSqu2Regs
fun loadSqu2Regs(X: Int, Y: Int) {
    //> LoadSqu2Regs:
    //> jsr PlaySqu2Sfx
    playSqu2Sfx(X, Y)
    //  Fall-through tail call to decrementSfx2Length
    decrementSfx2Length()
    return
}

// Decompiled from DecrementSfx2Length
fun decrementSfx2Length() {
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> DecrementSfx2Length:
    //> dec Squ2_SfxLenCounter   ;decrement length of sfx
    squ2Sfxlencounter = (squ2Sfxlencounter - 1) and 0xFF
    //> bne ExSfx2
    if (!(squ2Sfxlencounter == 0)) {
        //  goto ExSfx2 -> exSfx2
        exSfx2()
        return
    } else {
        //  Fall-through tail call to emptySfx2Buffer
        emptySfx2Buffer()
        return
    }
}

// Decompiled from EmptySfx2Buffer
fun emptySfx2Buffer() {
    var X: Int = 0
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    //> EmptySfx2Buffer:
    //> ldx #$00                ;initialize square 2's sound effects buffer
    X = 0x00
    //> stx Square2SoundBuffer
    square2SoundBuffer = X
    //  Fall-through tail call to stopSquare2Sfx
    stopSquare2Sfx()
    return
}

// Decompiled from StopSquare2Sfx
fun stopSquare2Sfx() {
    var X: Int = 0
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    //> StopSquare2Sfx:
    //> ldx #$0d                ;stop playing the sfx
    X = 0x0D
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = X
    //> ldx #$0f
    X = 0x0F
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = X
    //  Fall-through tail call to exSfx2
    exSfx2()
    return
}

// Decompiled from ExSfx2
fun exSfx2() {
    //> ExSfx2: rts
    return
}

// Decompiled from Square2SfxHandler
fun square2SfxHandler() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    //> Square2SfxHandler:
    //> lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
    A = square2SoundBuffer
    //> and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
    A = A and Sfx_ExtraLife
    //> bne ContinueExtraLife
    if (!(A == 0)) {
        //  goto ContinueExtraLife -> continueExtraLife
        continueExtraLife()
        return
    } else {
        //> PlayCoinGrab:
        //> lda #$35             ;load length of coin grab sound
        A = 0x35
        //> ldx #$8d             ;and part of reg contents
        X = 0x8D
        //> bne CGrab_TTickRegL
        if (X == 0) {
            //> PlayTimerTick:
            //> lda #$06             ;load length of timer tick sound
            A = 0x06
            //> ldx #$98             ;and part of reg contents
            X = 0x98
        }
    }
    //> CGrab_TTickRegL:
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = A
    //> ldy #$7f                ;load the rest of reg contents
    Y = 0x7F
    //> lda #$42                ;of coin grab and timer tick sound
    A = 0x42
    //> jsr PlaySqu2Sfx
    playSqu2Sfx(X, Y)
    //  Fall-through tail call to continueCGrabTTick
    continueCGrabTTick()
    return
    //> ldy Square2SoundQueue  ;check for sfx in queue
    Y = square2SoundQueue
    //> beq CheckSfx2Buffer
    if (Y != 0) {
        //> sty Square2SoundBuffer ;if found, put in buffer and check for the following
        square2SoundBuffer = Y
        //> bmi PlayBowserFall     ;bowser fall
        if ((Y and 0x80) == 0) {
            loop0@ do {
                //> lsr Square2SoundQueue
                val orig0: Int = square2SoundQueue
                val carryFromLsr1: Boolean = (orig0 and 0x01) != 0
                square2SoundQueue = orig0 shr 1
                //> bcs PlayCoinGrab       ;coin grab
                if (carryFromLsr1) {
                    //  continue loop (branch back to PlayCoinGrab)
                    continue@loop0
                }
            } while (carryFromLsr1)
            //> lsr Square2SoundQueue
            val orig2: Int = square2SoundQueue
            val carryFromLsr3: Boolean = (orig2 and 0x01) != 0
            square2SoundQueue = orig2 shr 1
            //> bcs PlayGrowPowerUp    ;power-up reveal
            if (carryFromLsr3) {
                //  goto PlayGrowPowerUp -> playGrowPowerUp
                playGrowPowerUp()
                return
            }
            //> lsr Square2SoundQueue
            val orig4: Int = square2SoundQueue
            val carryFromLsr5: Boolean = (orig4 and 0x01) != 0
            square2SoundQueue = orig4 shr 1
            //> bcs PlayGrowVine       ;vine grow
            if (carryFromLsr5) {
                //  goto PlayGrowVine -> playGrowVine
                playGrowVine()
                return
            }
            //> lsr Square2SoundQueue
            val orig6: Int = square2SoundQueue
            val carryFromLsr7: Boolean = (orig6 and 0x01) != 0
            square2SoundQueue = orig6 shr 1
            //> bcs PlayBlast          ;fireworks/gunfire
            if (carryFromLsr7) {
                //  goto PlayBlast -> playBlast
                playBlast()
                return
            }
            loop1@ do {
                //> lsr Square2SoundQueue
                val orig8: Int = square2SoundQueue
                val carryFromLsr9: Boolean = (orig8 and 0x01) != 0
                square2SoundQueue = orig8 shr 1
                //> bcs PlayTimerTick      ;timer tick
                if (carryFromLsr9) {
                    //  continue loop (branch back to PlayTimerTick)
                    continue@loop1
                }
            } while (carryFromLsr9)
            //> lsr Square2SoundQueue
            val orig10: Int = square2SoundQueue
            val carryFromLsr11: Boolean = (orig10 and 0x01) != 0
            square2SoundQueue = orig10 shr 1
            //> bcs PlayPowerUpGrab    ;power-up grab
            if (carryFromLsr11) {
                //  goto PlayPowerUpGrab -> playPowerUpGrab
                playPowerUpGrab()
                return
            }
            //> lsr Square2SoundQueue
            val orig12: Int = square2SoundQueue
            val carryFromLsr13: Boolean = (orig12 and 0x01) != 0
            square2SoundQueue = orig12 shr 1
            //> bcs PlayExtraLife      ;1-up
            if (carryFromLsr13) {
                //  goto PlayExtraLife -> playExtraLife
                playExtraLife()
                return
            }
        }
    }
    //> CheckSfx2Buffer:
    //> lda Square2SoundBuffer   ;check for sfx in buffer
    A = square2SoundBuffer
    //> beq ExS2H                ;if not found, exit sub
    if (A != 0) {
        //> bmi ContinueBowserFall   ;bowser fall
        if ((A and 0x80) != 0) {
            //  goto ContinueBowserFall -> continueBowserFall
            continueBowserFall()
            return
        }
        //> lsr
        val orig14: Int = A
        A = orig14 shr 1
        //> bcs Cont_CGrab_TTick     ;coin grab
        if ((orig14 and 0x01) == 0) {
            //> lsr
            val orig15: Int = A
            A = orig15 shr 1
            //> bcs ContinueGrowItems    ;power-up reveal
            if ((orig15 and 0x01) != 0) {
                //  goto ContinueGrowItems -> continueGrowItems
                continueGrowItems()
                return
            }
            //> lsr
            val orig16: Int = A
            A = orig16 shr 1
            //> bcs ContinueGrowItems    ;vine grow
            if ((orig16 and 0x01) != 0) {
                //  goto ContinueGrowItems -> continueGrowItems
                continueGrowItems()
                return
            }
            //> lsr
            val orig17: Int = A
            A = orig17 shr 1
            //> bcs ContinueBlast        ;fireworks/gunfire
            if ((orig17 and 0x01) != 0) {
                //  goto ContinueBlast -> continueBlast
                continueBlast()
                return
            }
            //> lsr
            val orig18: Int = A
            A = orig18 shr 1
            //> bcs Cont_CGrab_TTick     ;timer tick
            if ((orig18 and 0x01) == 0) {
                //> lsr
                val orig19: Int = A
                A = orig19 shr 1
                //> bcs ContinuePowerUpGrab  ;power-up grab
                if ((orig19 and 0x01) != 0) {
                    //  goto ContinuePowerUpGrab -> continuePowerUpGrab
                    continuePowerUpGrab()
                    return
                }
                //> lsr
                val orig20: Int = A
                A = orig20 shr 1
                //> bcs ContinueExtraLife    ;1-up
                if ((orig20 and 0x01) != 0) {
                    //  goto ContinueExtraLife -> continueExtraLife
                    continueExtraLife()
                    return
                }
            }
        }
    }
    //> ExS2H:  rts
    return
    //> Cont_CGrab_TTick:
    //> jmp ContinueCGrabTTick
    continueCGrabTTick()
    return
    //> PlayBowserFall:
    //> lda #$38                ;load length of bowser defeat sound
    A = 0x38
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = A
    //> ldy #$c4                ;load contents of reg for bowser defeat sound
    Y = 0xC4
    //> lda #$18
    A = 0x18
    //  Fall-through tail call to blstSJp
    blstSJp()
    return
}

// Decompiled from JumpToDecLength2
fun jumpToDecLength2() {
    //> JumpToDecLength2:
    //> jmp DecrementSfx2Length
    decrementSfx2Length()
    return
}

// Decompiled from BlstSJp
fun blstSJp() {
    var A: Int = 0
    //> BlstSJp: bne PBFRegs
    if (!(A == 0)) {
        //  goto PBFRegs -> pBFRegs
        pBFRegs()
        return
    }
    //  Fall-through tail call to func_15489
    func_15489()
    return
}

// Decompiled from @15489
fun func_15489() {
    //  Fall-through tail call to continueBowserFall
    continueBowserFall()
    return
}

// Decompiled from ContinueBowserFall
fun continueBowserFall() {
    var A: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> ContinueBowserFall:
    //> lda Squ2_SfxLenCounter   ;check for almost near the end
    A = squ2Sfxlencounter
    //> cmp #$08
    //> bne DecrementSfx2Length
    if (!(A == 0x08)) {
        //  goto DecrementSfx2Length -> decrementSfx2Length
        decrementSfx2Length()
        return
    }
    //  Fall-through tail call to func_15494
    func_15494()
    return
}

// Decompiled from @15494
fun func_15494() {
    var A: Int = 0
    var Y: Int = 0
    //> ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
    Y = 0xA4
    //> lda #$5a
    A = 0x5A
    //  Fall-through tail call to pBFRegs
    pBFRegs()
    return
}

// Decompiled from PBFRegs
fun pBFRegs() {
    var X: Int = 0
    //> PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
    X = 0x9F
    //  Fall-through tail call to elLregs
    elLregs()
    return
}

// Decompiled from EL_LRegs
fun elLregs() {
    var A: Int = 0
    //> EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
    if (!(A == 0)) {
        //  goto LoadSqu2Regs -> loadSqu2Regs
        loadSqu2Regs(0, 0)
        return
    }
    //  Fall-through tail call to func_15498
    func_15498()
    return
}

// Decompiled from @15498
fun func_15498() {
    //  Fall-through tail call to playExtraLife
    playExtraLife()
    return
}

// Decompiled from PlayExtraLife
fun playExtraLife() {
    var A: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> PlayExtraLife:
    //> lda #$30                  ;load length of 1-up sound
    A = 0x30
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = A
    //  Fall-through tail call to continueExtraLife
    continueExtraLife()
    return
}

// Decompiled from ContinueExtraLife
fun continueExtraLife() {
    var A: Int = 0
    var X: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> ContinueExtraLife:
    //> lda Squ2_SfxLenCounter
    A = squ2Sfxlencounter
    //> ldx #$03                  ;load new tones only every eight frames
    X = 0x03
    //  Fall-through tail call to divLLoop
    divLLoop(A)
    return
}

// Decompiled from DivLLoop
fun divLLoop(A: Int) {
    var A: Int = A
    //> DivLLoop: lsr
    val orig0: Int = A
    A = orig0 shr 1
    //> bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
    //  Fall-through tail call to func_15508
    func_15508(0)
    return
    A = A
    if ((orig0 and 0x01) != 0) {
        //> JumpToDecLength2:
        //> jmp DecrementSfx2Length
        decrementSfx2Length()
        return
    }
    // Fall-through tail call to func_15508
    func_15508(0)
    return
}

// Decompiled from @15508
fun func_15508(X: Int) {
    var X: Int = X
    //> dex
    X = (X - 1) and 0xFF
    //> bne DivLLoop              ;do this until all bits checked, if none set, continue
    if (!(X == 0)) {
        //  goto DivLLoop -> divLLoop
        divLLoop(0)
        return
    }
    //  Fall-through tail call to func_15510
    func_15510(0)
    return
}

// Decompiled from @15510
fun func_15510(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    val extraLifeFreqData by MemoryByteIndexed(ExtraLifeFreqData)
    //> tay
    Y = A
    //> lda ExtraLifeFreqData-1,y ;load our reg contents
    A = extraLifeFreqData[-1 + Y]
    //> ldx #$82
    X = 0x82
    //> ldy #$7f
    Y = 0x7F
    //> bne EL_LRegs              ;unconditional branch
    if (!(Y == 0)) {
        //  goto EL_LRegs -> elLregs
        elLregs()
        return
    }
    //  Fall-through tail call to func_15515
    func_15515()
    return
}

// Decompiled from @15515
fun func_15515() {
    //  Fall-through tail call to playGrowPowerUp
    playGrowPowerUp()
    return
}

// Decompiled from PlayGrowPowerUp
fun playGrowPowerUp() {
    var A: Int = 0
    //> PlayGrowPowerUp:
    //> lda #$10                ;load length of power-up reveal sound
    A = 0x10
    //> bne GrowItemRegs
    if (!(A == 0)) {
        //  goto GrowItemRegs -> growItemRegs
        growItemRegs(A)
        return
    }
    //  Fall-through tail call to func_15519
    func_15519()
    return
}

// Decompiled from @15519
fun func_15519() {
    //  Fall-through tail call to playGrowVine
    playGrowVine()
    return
}

// Decompiled from PlayGrowVine
fun playGrowVine() {
    var A: Int = 0
    //> PlayGrowVine:
    //> lda #$20                ;load length of vine grow sound
    A = 0x20
    //  Fall-through tail call to growItemRegs
    growItemRegs(A)
    return
}

// Decompiled from GrowItemRegs
fun growItemRegs(A: Int) {
    var A: Int = A
    var sfxSecondarycounter by MemoryByte(Sfx_SecondaryCounter)
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    //> GrowItemRegs:
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = A
    //> lda #$7f                  ;load contents of reg for both sounds directly
    A = 0x7F
    //> sta SND_SQUARE2_REG+1
    sndSquare2Reg[1] = A
    //> lda #$00                  ;start secondary counter for both sounds
    A = 0x00
    //> sta Sfx_SecondaryCounter
    sfxSecondarycounter = A
    //  Fall-through tail call to continueGrowItems
    continueGrowItems()
    return
}

// Decompiled from ContinueGrowItems
fun continueGrowItems() {
    var A: Int = 0
    var Y: Int = 0
    var sfxSecondarycounter by MemoryByte(Sfx_SecondaryCounter)
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    //> ContinueGrowItems:
    //> inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
    sfxSecondarycounter = (sfxSecondarycounter + 1) and 0xFF
    //> lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
    A = sfxSecondarycounter
    //> lsr                       ;divide by 2 to get the offset
    val orig0: Int = A
    A = orig0 shr 1
    //> tay
    Y = A
    //> cpy Squ2_SfxLenCounter    ;have we reached the end yet?
    //> beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
    if (Y == squ2Sfxlencounter) {
        //  goto StopGrowItems -> stopGrowItems
        stopGrowItems()
        return
    }
    //  Fall-through tail call to func_15537
    func_15537(Y)
    return
}

// Decompiled from @15537
fun func_15537(Y: Int) {
    var A: Int = 0
    val pupVgrowFreqdata by MemoryByteIndexed(PUp_VGrow_FreqData)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    //> lda #$9d                  ;load contents of other reg directly
    A = 0x9D
    //> sta SND_SQUARE2_REG
    sndSquare2Reg[0] = A
    //> lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
    A = pupVgrowFreqdata[Y]
    //> jsr SetFreq_Squ2
    setfreqSqu2()
    //> rts
    return
}

// Decompiled from StopGrowItems
fun stopGrowItems() {
    //> StopGrowItems:
    //> jmp EmptySfx2Buffer       ;branch to stop playing sounds
    emptySfx2Buffer()
    return
}

// Decompiled from NoiseSfxHandler
fun noiseSfxHandler() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var noiseSoundBuffer by MemoryByte(NoiseSoundBuffer)
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var noiseSfxlencounter by MemoryByte(Noise_SfxLenCounter)
    val bowserFlameEnvData by MemoryByteIndexed(BowserFlameEnvData)
    val brickShatterEnvData by MemoryByteIndexed(BrickShatterEnvData)
    val brickShatterFreqData by MemoryByteIndexed(BrickShatterFreqData)
    val sndNoiseReg by MemoryByteIndexed(SND_NOISE_REG)
    //> NoiseSfxHandler:
    //> ldy NoiseSoundQueue   ;check for sfx in queue
    Y = noiseSoundQueue
    //> beq CheckNoiseBuffer
    if (Y == 0) {
        //  goto CheckNoiseBuffer (internal forward branch)
        //> CheckNoiseBuffer:
        //> lda NoiseSoundBuffer      ;check for sfx in buffer
        A = noiseSoundBuffer
        //> beq ExNH                  ;if not found, exit sub
        if (A == 0) {
            //  goto ExNH (internal forward branch)
            //> ExNH:   rts
            return
        }
        //> lsr
        val orig0: Int = A
        A = orig0 shr 1
        //> bcs ContinueBrickShatter  ;brick shatter
        //> lsr
        val orig1: Int = A
        A = orig1 shr 1
        //> bcs ContinueBowserFlame   ;bowser flame
        if ((orig1 and 0x01) != 0) {
            //  goto ContinueBowserFlame (internal forward branch)
            //> ContinueBowserFlame:
            //> lda Noise_SfxLenCounter
            A = noiseSfxlencounter
            //> lsr
            val orig2: Int = A
            A = orig2 shr 1
            //> tay
            Y = A
            //> ldx #$0f                    ;load reg contents of bowser flame sound
            X = 0x0F
            //> lda BowserFlameEnvData-1,y
            A = bowserFlameEnvData[-1 + Y]
            //> bne PlayNoiseSfx            ;unconditional branch here
            //> ;--------------------------------
            //  Fall-through tail call to continueMusic
            continueMusic()
            return
        }
        return
    } else {
        loop0@ while (flagC) {
            //> PlayBrickShatter:
            //> lda #$20                 ;load length of brick shatter sound
            A = 0x20
            //> sta Noise_SfxLenCounter
            noiseSfxlencounter = A
            //> ContinueBrickShatter:
            //> lda Noise_SfxLenCounter
            A = noiseSfxlencounter
            //> lsr                         ;divide by 2 and check for bit set to use offset
            val orig3: Int = A
            A = orig3 shr 1
            //> bcc DecrementSfx3Length
            if (!((orig3 and 0x01) != 0)) {
                //  goto DecrementSfx3Length (internal forward branch)
                //> DecrementSfx3Length:
                //> dec Noise_SfxLenCounter  ;decrement length of sfx
                noiseSfxlencounter = (noiseSfxlencounter - 1) and 0xFF
                //> bne ExSfx3
                if (!(noiseSfxlencounter == 0)) {
                    //  goto ExSfx3 (internal forward branch)
                    //> ExSfx3: rts
                    return
                }
                //> lda #$f0                 ;if done, stop playing the sfx
                A = 0xF0
                //> sta SND_NOISE_REG
                sndNoiseReg[0] = A
                //> lda #$00
                A = 0x00
                //> sta NoiseSoundBuffer
                noiseSoundBuffer = A
                return
            }
            //> tay
            Y = A
            //> ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
            X = brickShatterFreqData[Y]
            //> lda BrickShatterEnvData,y
            A = brickShatterEnvData[Y]
            //> PlayNoiseSfx:
            //> sta SND_NOISE_REG        ;play the sfx
            sndNoiseReg[0] = A
            //> stx SND_NOISE_REG+2
            sndNoiseReg[2] = X
            //> lda #$18
            A = 0x18
            //> sta SND_NOISE_REG+3
            sndNoiseReg[3] = A
            //> lda #$f0                 ;if done, stop playing the sfx
            A = 0xF0
            //> sta SND_NOISE_REG
            sndNoiseReg[0] = A
            //> lda #$00
            A = 0x00
            //> sta NoiseSoundBuffer
            noiseSoundBuffer = A
            //> ExSfx3: rts
            return
            //> sty NoiseSoundBuffer  ;if found, put in buffer
            noiseSoundBuffer = Y
            //> lsr NoiseSoundQueue
            val orig4: Int = noiseSoundQueue
            val carryFromLsr5: Boolean = (orig4 and 0x01) != 0
            noiseSoundQueue = orig4 shr 1
            //> bcs PlayBrickShatter  ;brick shatter
            if (carryFromLsr5) {
                //  continue loop (branch back to PlayBrickShatter)
                continue@loop0
            }
        }
    }
    //> lsr NoiseSoundQueue
    val orig6: Int = noiseSoundQueue
    val carryFromLsr7: Boolean = (orig6 and 0x01) != 0
    noiseSoundQueue = orig6 shr 1
    //> bcs PlayBowserFlame   ;bowser flame
    if (!carryFromLsr7) {
        if (orig6 shr 1 != 0) {
            //> lsr
            val orig8: Int = A
            A = orig8 shr 1
            //> bcs ContinueBrickShatter  ;brick shatter
            //> lsr
            val orig9: Int = A
            A = orig9 shr 1
            //> bcs ContinueBowserFlame   ;bowser flame
            if ((orig9 and 0x01) != 0) {
                //  goto ContinueBowserFlame (internal forward branch)
                //> ContinueBowserFlame:
                //> lda Noise_SfxLenCounter
                A = noiseSfxlencounter
                //> lsr
                val orig10: Int = A
                A = orig10 shr 1
                //> tay
                Y = A
                //> ldx #$0f                    ;load reg contents of bowser flame sound
                X = 0x0F
                //> lda BowserFlameEnvData-1,y
                A = bowserFlameEnvData[-1 + Y]
                //> bne PlayNoiseSfx            ;unconditional branch here
                //> ;--------------------------------
                //  Fall-through tail call to continueMusic
                continueMusic()
                return
            }
            //> PlayBowserFlame:
            //> lda #$40                    ;load length of bowser flame sound
            A = 0x40
            //> sta Noise_SfxLenCounter
            noiseSfxlencounter = A
        } else {
            //> ExNH:   rts
            return
        }
    }
    //> ;--------------------------------
    //  Fall-through tail call to continueMusic
    continueMusic()
    return
}

// Decompiled from ContinueMusic
fun continueMusic() {
    //> ContinueMusic:
    //> jmp HandleSquare2Music  ;if we have music, start with square 2 channel
    handleSquare2Music()
    return
}

// Decompiled from MusicHandler
fun musicHandler() {
    var A: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    //> MusicHandler:
    //> lda EventMusicQueue     ;check event music queue
    A = eventMusicQueue
    //> bne LoadEventMusic
    if (!(A == 0)) {
        //  goto LoadEventMusic -> loadEventMusic
        loadEventMusic(A)
        return
    } else {
        //> lda AreaMusicQueue      ;check area music queue
        A = areaMusicQueue
        //> bne LoadAreaMusic
        if (!(A == 0)) {
            //  goto LoadAreaMusic -> loadAreaMusic
            loadAreaMusic(A)
            return
        }
    }
    //> lda EventMusicBuffer    ;check both buffers
    A = eventMusicBuffer
    //> ora AreaMusicBuffer
    A = A or areaMusicBuffer
    //> bne ContinueMusic
    if (A != 0) {
        //> ContinueMusic:
        //> jmp HandleSquare2Music  ;if we have music, start with square 2 channel
        handleSquare2Music()
        return
    } else {
        //> rts                     ;no music, then leave
        return
    }
}

// Decompiled from LoadEventMusic
fun loadEventMusic(A: Int) {
    var A: Int = A
    var X: Int = 0
    var Y: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var areamusicbufferAlt by MemoryByte(AreaMusicBuffer_Alt)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var noteLengthTblAdder by MemoryByte(NoteLengthTblAdder)
    //> LoadEventMusic:
    //> sta EventMusicBuffer      ;copy event music queue contents to buffer
    eventMusicBuffer = A
    //> cmp #DeathMusic           ;is it death music?
    //> bne NoStopSfx             ;if not, jump elsewhere
    A = A
    if (A == DeathMusic) {
        //> jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
        stopSquare1Sfx()
        //> jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
        stopSquare2Sfx()
    }
    //> NoStopSfx: ldx AreaMusicBuffer
    X = areaMusicBuffer
    //> stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
    areamusicbufferAlt = X
    //> ldy #$00
    Y = 0x00
    //> sty NoteLengthTblAdder    ;default value for additional length byte offset
    noteLengthTblAdder = Y
    //> sty AreaMusicBuffer       ;clear area music buffer
    areaMusicBuffer = Y
    //> cmp #TimeRunningOutMusic  ;is it time running out music?
    //> bne FindEventMusicHeader
    if (!(A == TimeRunningOutMusic)) {
        //  goto FindEventMusicHeader -> findEventMusicHeader
        findEventMusicHeader(A, Y)
        return
    } else {
        //> ldx #$08                  ;load offset to be added to length byte of header
        X = 0x08
        //> stx NoteLengthTblAdder
        noteLengthTblAdder = X
        //> bne FindEventMusicHeader  ;unconditional branch
        if (!(X == 0)) {
            //  goto FindEventMusicHeader -> findEventMusicHeader
            findEventMusicHeader(A, Y)
            return
        }
    }
    //  Fall-through tail call to loadAreaMusic
    loadAreaMusic(A)
    return
}

// Decompiled from LoadAreaMusic
fun loadAreaMusic(A: Int) {
    //> LoadAreaMusic:
    //> cmp #$04                  ;is it underground music?
    //> bne NoStop1               ;no, do not stop square 1 sfx
    if (!(A == 0x04)) {
        //  goto NoStop1 -> noStop1
        noStop1(A)
        return
    }
    //  Fall-through tail call to func_15644
    func_15644(A)
    return
}

// Decompiled from @15644
fun func_15644(A: Int) {
    //> jsr StopSquare1Sfx
    stopSquare1Sfx()
    //  Fall-through tail call to noStop1
    noStop1(A)
    return
}

// Decompiled from NoStop1
fun noStop1(A: Int) {
    var Y: Int = 0
    //> NoStop1: ldy #$10                  ;start counter used only by ground level music
    Y = 0x10
    //  Fall-through tail call to gMLoopB
    gMLoopB(A, Y)
    return
}

// Decompiled from GMLoopB
fun gMLoopB(A: Int, Y: Int) {
    var groundMusicHeaderOfs by MemoryByte(GroundMusicHeaderOfs)
    //> GMLoopB: sty GroundMusicHeaderOfs
    groundMusicHeaderOfs = Y
    //  Fall-through tail call to handleAreaMusicLoopB
    handleAreaMusicLoopB(A)
    return
}

// Decompiled from HandleAreaMusicLoopB
fun handleAreaMusicLoopB(A: Int) {
    var A: Int = A
    var Y: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var groundMusicHeaderOfs by MemoryByte(GroundMusicHeaderOfs)
    var musicoffsetSquare2 by MemoryByte(MusicOffset_Square2)
    //> HandleAreaMusicLoopB:
    //> ldy #$00                  ;clear event music buffer
    Y = 0x00
    //> sty EventMusicBuffer
    eventMusicBuffer = Y
    //> sta AreaMusicBuffer       ;copy area music queue contents to buffer
    areaMusicBuffer = A
    //> cmp #$01                  ;is it ground level music?
    //> bne FindAreaMusicHeader
    A = A
    if (A == 0x01) {
        //> inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
        groundMusicHeaderOfs = (groundMusicHeaderOfs + 1) and 0xFF
        //> ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
        Y = groundMusicHeaderOfs
        //> cpy #$32
        //> bne LoadHeader            ;branch ahead with alternate offset
        if (!(Y == 0x32)) {
            //  goto LoadHeader -> loadHeader
            loadHeader(Y)
            return
        }
        //> ldy #$11
        Y = 0x11
        //> bne GMLoopB               ;unconditional branch
        if (!(Y == 0)) {
            //  goto GMLoopB -> gMLoopB
            gMLoopB(A, Y)
            return
        }
    }
    //> FindAreaMusicHeader:
    //> ldy #$08                   ;load Y for offset of area music
    Y = 0x08
    //> sty MusicOffset_Square2    ;residual instruction here
    musicoffsetSquare2 = Y
    //  Fall-through tail call to findEventMusicHeader
    findEventMusicHeader(A, Y)
    return
}

// Decompiled from FindEventMusicHeader
fun findEventMusicHeader(A: Int, Y: Int) {
    var A: Int = A
    var Y: Int = Y
    Y = Y
    loop0@ do {
        //> FindEventMusicHeader:
        //> iny                       ;increment Y pointer based on previously loaded queue contents
        Y = (Y + 1) and 0xFF
        //> lsr                       ;bit shift and increment until we find a set bit for music
        val orig0: Int = A
        A = orig0 shr 1
        //> bcc FindEventMusicHeader
        if (!((orig0 and 0x01) != 0)) {
            //  continue loop (branch back to FindEventMusicHeader)
            continue@loop0
        }
        //  Fall-through tail call to func_15669
        func_15669(Y)
        return
    } while ((orig0 and 0x01) == 0)
    // Fall-through tail call to func_15669
    func_15669(Y)
    return
}

// Decompiled from @15669
fun func_15669(Y: Int) {
    //  Fall-through tail call to loadHeader
    loadHeader(Y)
    return
}

// Decompiled from LoadHeader
fun loadHeader(Y: Int) {
    var A: Int = 0
    var Y: Int = Y
    var altRegContentFlag by MemoryByte(AltRegContentFlag)
    var musicDataHigh by MemoryByte(MusicDataHigh)
    var musicDataLow by MemoryByte(MusicDataLow)
    var musicoffsetNoise by MemoryByte(MusicOffset_Noise)
    var musicoffsetSquare1 by MemoryByte(MusicOffset_Square1)
    var musicoffsetSquare2 by MemoryByte(MusicOffset_Square2)
    var musicoffsetTriangle by MemoryByte(MusicOffset_Triangle)
    var noiseDataLoopbackOfs by MemoryByte(NoiseDataLoopbackOfs)
    var noiseBeatlencounter by MemoryByte(Noise_BeatLenCounter)
    var noteLenLookupTblOfs by MemoryByte(NoteLenLookupTblOfs)
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    var squ1Notelencounter by MemoryByte(Squ1_NoteLenCounter)
    var squ2Notelencounter by MemoryByte(Squ2_NoteLenCounter)
    var triNotelencounter by MemoryByte(Tri_NoteLenCounter)
    val musicHeaderData by MemoryByteIndexed(MusicHeaderData)
    val musicHeaderOffsetData by MemoryByteIndexed(MusicHeaderOffsetData)
    //> LoadHeader:
    //> lda MusicHeaderOffsetData,y  ;load offset for header
    A = musicHeaderOffsetData[Y]
    //> tay
    Y = A
    //> lda MusicHeaderData,y        ;now load the header
    A = musicHeaderData[Y]
    //> sta NoteLenLookupTblOfs
    noteLenLookupTblOfs = A
    //> lda MusicHeaderData+1,y
    A = musicHeaderData[1 + Y]
    //> sta MusicDataLow
    musicDataLow = A
    //> lda MusicHeaderData+2,y
    A = musicHeaderData[2 + Y]
    //> sta MusicDataHigh
    musicDataHigh = A
    //> lda MusicHeaderData+3,y
    A = musicHeaderData[3 + Y]
    //> sta MusicOffset_Triangle
    musicoffsetTriangle = A
    //> lda MusicHeaderData+4,y
    A = musicHeaderData[4 + Y]
    //> sta MusicOffset_Square1
    musicoffsetSquare1 = A
    //> lda MusicHeaderData+5,y
    A = musicHeaderData[5 + Y]
    //> sta MusicOffset_Noise
    musicoffsetNoise = A
    //> sta NoiseDataLoopbackOfs
    noiseDataLoopbackOfs = A
    //> lda #$01                     ;initialize music note counters
    A = 0x01
    //> sta Squ2_NoteLenCounter
    squ2Notelencounter = A
    //> sta Squ1_NoteLenCounter
    squ1Notelencounter = A
    //> sta Tri_NoteLenCounter
    triNotelencounter = A
    //> sta Noise_BeatLenCounter
    noiseBeatlencounter = A
    //> lda #$00                     ;initialize music data offset for square 2
    A = 0x00
    //> sta MusicOffset_Square2
    musicoffsetSquare2 = A
    //> sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
    altRegContentFlag = A
    //> lda #$0b                     ;disable triangle channel and reenable it
    A = 0x0B
    //> sta SND_MASTERCTRL_REG
    sndMasterctrlReg = A
    //> lda #$0f
    A = 0x0F
    //> sta SND_MASTERCTRL_REG
    sndMasterctrlReg = A
    //  Fall-through tail call to handleSquare2Music
    handleSquare2Music()
    return
}

// Decompiled from HandleSquare2Music
fun handleSquare2Music() {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var altRegContentFlag by MemoryByte(AltRegContentFlag)
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var areamusicbufferAlt by MemoryByte(AreaMusicBuffer_Alt)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var musicoffsetNoise by MemoryByte(MusicOffset_Noise)
    var musicoffsetSquare1 by MemoryByte(MusicOffset_Square1)
    var musicoffsetSquare2 by MemoryByte(MusicOffset_Square2)
    var musicoffsetTriangle by MemoryByte(MusicOffset_Triangle)
    var noiseDataLoopbackOfs by MemoryByte(NoiseDataLoopbackOfs)
    var noiseBeatlencounter by MemoryByte(Noise_BeatLenCounter)
    var squ1Envelopedatactrl by MemoryByte(Squ1_EnvelopeDataCtrl)
    var squ1Notelencounter by MemoryByte(Squ1_NoteLenCounter)
    var squ2Envelopedatactrl by MemoryByte(Squ2_EnvelopeDataCtrl)
    var squ2Notelenbuffer by MemoryByte(Squ2_NoteLenBuffer)
    var squ2Notelencounter by MemoryByte(Squ2_NoteLenCounter)
    var square1SoundBuffer by MemoryByte(Square1SoundBuffer)
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    var triNotelenbuffer by MemoryByte(Tri_NoteLenBuffer)
    var triNotelencounter by MemoryByte(Tri_NoteLenCounter)
    val sndNoiseReg by MemoryByteIndexed(SND_NOISE_REG)
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    val sndTriangleReg by MemoryByteIndexed(SND_TRIANGLE_REG)
    //> HandleSquare2Music:
    //> dec Squ2_NoteLenCounter  ;decrement square 2 note length
    squ2Notelencounter = (squ2Notelencounter - 1) and 0xFF
    //> bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
    if (squ2Notelencounter == 0) {
        //> ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
        Y = musicoffsetSquare2
        //> inc MusicOffset_Square2
        musicoffsetSquare2 = (musicoffsetSquare2 + 1) and 0xFF
        //> lda (MusicData),y
        A = memory[readWord(MusicData) + Y].toInt()
        //> beq EndOfMusicData       ;if zero, the data is a null terminator
        if (A != 0) {
            //> bpl Squ2NoteHandler      ;if non-negative, data is a note
            if ((A and 0x80) != 0) {
                //> bne Squ2LengthHandler    ;otherwise it is length data
                if (A == 0) {
                }
            }
        }
        //> EndOfMusicData:
        //> lda EventMusicBuffer     ;check secondary buffer for time running out music
        A = eventMusicBuffer
        //> cmp #TimeRunningOutMusic
        //> bne NotTRO
        if (A == TimeRunningOutMusic) {
            //> lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
            A = areamusicbufferAlt
            //> bne MusicLoopBack        ;and start playing the song again if there is one
            if (!(A == 0)) {
                //  goto MusicLoopBack (internal forward branch)
                //> MusicLoopBack:
                //> jmp HandleAreaMusicLoopB
                handleAreaMusicLoopB(A)
                return
            }
        }
        //> NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
        A = A and VictoryMusic
        //> bne VictoryMLoopBack
        if (A == 0) {
            //> lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
            A = areaMusicBuffer
            //> and #%01011111
            A = A and 0x5F
            //> bne MusicLoopBack        ;if any area music except pipe intro, music loops
            if (A == 0) {
                //> lda #$00                 ;clear primary and secondary buffers and initialize
                A = 0x00
                //> sta AreaMusicBuffer      ;control regs of square and triangle channels
                areaMusicBuffer = A
                //> sta EventMusicBuffer
                eventMusicBuffer = A
                //> sta SND_TRIANGLE_REG
                sndTriangleReg[0] = A
                //> lda #$90
                A = 0x90
                //> sta SND_SQUARE1_REG
                sndSquare1Reg[0] = A
                //> sta SND_SQUARE2_REG
                sndSquare2Reg[0] = A
                //> rts
                return
            }
            //> MusicLoopBack:
            //> jmp HandleAreaMusicLoopB
            handleAreaMusicLoopB(A)
            return
        } else {
            //> VictoryMLoopBack:
            //> jmp LoadEventMusic
            loadEventMusic(A)
            return
        }
        //> Squ2LengthHandler:
        //> jsr ProcessLengthData    ;store length of note
        temp0 = processLengthData(A)
        //> sta Squ2_NoteLenBuffer
        squ2Notelenbuffer = temp0
        //> ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
        Y = musicoffsetSquare2
        //> inc MusicOffset_Square2
        musicoffsetSquare2 = (musicoffsetSquare2 + 1) and 0xFF
        //> lda (MusicData),y
        A = memory[readWord(MusicData) + Y].toInt()
        //> Squ2NoteHandler:
        //> ldx Square2SoundBuffer     ;is there a sound playing on this channel?
        X = square2SoundBuffer
        //> bne SkipFqL1
        if (X == 0) {
            //> jsr SetFreq_Squ2           ;no, then play the note
            setfreqSqu2()
            //> beq Rest                   ;check to see if note is rest
            if (A != 0) {
                //> jsr LoadControlRegs        ;if not, load control regs for square 2
                temp1 = loadControlRegs()
            }
            //> Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
            squ2Envelopedatactrl = A
            //> jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
            dumpSq2Regs(X, Y)
        }
        //> SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
        A = squ2Notelenbuffer
        //> sta Squ2_NoteLenCounter
        squ2Notelencounter = A
    }
    //> MiscSqu2MusicTasks:
    //> lda Square2SoundBuffer     ;is there a sound playing on square 2?
    A = square2SoundBuffer
    //> bne HandleSquare1Music
    if (A == 0) {
        //> lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
        A = eventMusicBuffer
        //> and #%10010001             ;note that regs for death music or d4 are loaded by default
        A = A and 0x91
        //> bne HandleSquare1Music
        if (A == 0) {
            //> ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
            Y = squ2Envelopedatactrl
            //> beq NoDecEnv1
            if (Y != 0) {
                //> dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
                squ2Envelopedatactrl = (squ2Envelopedatactrl - 1) and 0xFF
            }
            //> NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
            temp2 = loadEnvelopeData(Y)
            //> sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
            sndSquare2Reg[0] = temp2
            //> ldx #$7f                   ;death music or d4 set on secondary buffer
            X = 0x7F
            //> stx SND_SQUARE2_REG+1
            sndSquare2Reg[1] = X
        }
    }
    //> HandleSquare1Music:
    //> ldy MusicOffset_Square1    ;is there a nonzero offset here?
    Y = musicoffsetSquare1
    //> beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
    if (Y != 0) {
        //> dec Squ1_NoteLenCounter    ;decrement square 1 note length
        squ1Notelencounter = (squ1Notelencounter - 1) and 0xFF
        //> bne MiscSqu1MusicTasks     ;is it time for more data?
        if (squ1Notelencounter == 0) {
            loop0@ while (squ1Notelencounter == 0) {
                //> lda #$83
                A = 0x83
                //> sta SND_SQUARE1_REG        ;store some data into control regs for square 1
                sndSquare1Reg[0] = A
                //> lda #$94                   ;and fetch another byte of data, used to give
                A = 0x94
                //> sta SND_SQUARE1_REG+1      ;death music its unique sound
                sndSquare1Reg[1] = A
                //> sta AltRegContentFlag
                altRegContentFlag = A
                //> bne FetchSqu1MusicData     ;unconditional branch
                if (!(A == 0)) {
                    //  continue loop (branch back to FetchSqu1MusicData)
                    continue@loop0
                }
            }
            //> Squ1NoteHandler:
            //> jsr AlternateLengthHandler
            val pair0 = alternateLengthHandler(A)
            temp3 = pair0.first
            temp4 = pair0.second
            X = temp4
            //> sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
            squ1Notelencounter = temp3
            //> ldy Square1SoundBuffer     ;is there a sound playing on square 1?
            Y = square1SoundBuffer
            //> bne HandleTriangleMusic
            A = temp3
            if (Y == 0) {
                //> txa
                A = X
                //> and #%00111110             ;change saved data to appropriate note format
                A = A and 0x3E
                //> jsr SetFreq_Squ1           ;play the note
                setfreqSqu1(A)
                //> beq SkipCtrlL
                if (A != 0) {
                    //> jsr LoadControlRegs
                    temp5 = loadControlRegs()
                }
                //> SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
                squ1Envelopedatactrl = A
                //> jsr Dump_Squ1_Regs
                dumpSqu1Regs(X, Y)
            }
        }
        //> MiscSqu1MusicTasks:
        //> lda Square1SoundBuffer     ;is there a sound playing on square 1?
        A = square1SoundBuffer
        //> bne HandleTriangleMusic
        if (A == 0) {
            //> lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
            A = eventMusicBuffer
            //> and #%10010001
            A = A and 0x91
            //> bne DeathMAltReg
            if (A == 0) {
                //> ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
                Y = squ1Envelopedatactrl
                //> beq NoDecEnv2
                if (Y != 0) {
                    //> dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
                    squ1Envelopedatactrl = (squ1Envelopedatactrl - 1) and 0xFF
                }
                //> NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
                temp6 = loadEnvelopeData(Y)
                //> sta SND_SQUARE1_REG        ;based on offset set by first load
                sndSquare1Reg[0] = temp6
            }
            //> DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
            A = altRegContentFlag
            //> bne DoAltLoad
            if (A == 0) {
                //> lda #$7f                   ;load this value if zero, the alternate value
                A = 0x7F
            }
            //> DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
            sndSquare1Reg[1] = A
        }
    }
    //> HandleTriangleMusic:
    //> lda MusicOffset_Triangle
    A = musicoffsetTriangle
    //> dec Tri_NoteLenCounter    ;decrement triangle note length
    triNotelencounter = (triNotelencounter - 1) and 0xFF
    //> bne HandleNoiseMusic      ;is it time for more data?
    if (triNotelencounter == 0) {
        //> ldy MusicOffset_Triangle  ;increment square 1 music offset and fetch data
        Y = musicoffsetTriangle
        //> inc MusicOffset_Triangle
        musicoffsetTriangle = (musicoffsetTriangle + 1) and 0xFF
        //> lda (MusicData),y
        A = memory[readWord(MusicData) + Y].toInt()
        //> beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise
        if (A != 0) {
            //> bpl TriNoteHandler        ;if non-negative, data is note
            if ((A and 0x80) != 0) {
                //> jsr ProcessLengthData     ;otherwise, it is length data
                temp7 = processLengthData(A)
                //> sta Tri_NoteLenBuffer     ;save contents of A
                triNotelenbuffer = temp7
                //> lda #$1f
                A = 0x1F
                //> sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
                sndTriangleReg[0] = A
                //> ldy MusicOffset_Triangle  ;fetch another byte
                Y = musicoffsetTriangle
                //> inc MusicOffset_Triangle
                musicoffsetTriangle = (musicoffsetTriangle + 1) and 0xFF
                //> lda (MusicData),y
                A = memory[readWord(MusicData) + Y].toInt()
                //> beq LoadTriCtrlReg        ;check once more for nonzero data
                if (A != 0) {
                }
            }
            //> TriNoteHandler:
            //> jsr SetFreq_Tri
            setfreqTri()
            //> ldx Tri_NoteLenBuffer   ;save length in triangle note counter
            X = triNotelenbuffer
            //> stx Tri_NoteLenCounter
            triNotelencounter = X
            //> lda EventMusicBuffer
            A = eventMusicBuffer
            //> and #%01101110          ;check for death music or d4 set on secondary buffer
            A = A and 0x6E
            //> bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
            if (A == 0) {
                //> lda AreaMusicBuffer     ;check primary buffer for water or castle level music
                A = areaMusicBuffer
                //> and #%00001010
                A = A and 0x0A
                //> beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
                if (A == 0) {
                    //  goto HandleNoiseMusic (internal forward branch)
                    //> HandleNoiseMusic:
                    //> lda AreaMusicBuffer       ;check if playing underground or castle music
                    A = areaMusicBuffer
                    //> and #%11110011
                    A = A and 0xF3
                    //> beq ExitMusicHandler      ;if so, skip the noise routine
                    if (A == 0) {
                        //  goto ExitMusicHandler (internal forward branch)
                        //> ExitMusicHandler:
                        //> rts
                        return
                    }
                    //> dec Noise_BeatLenCounter  ;decrement noise beat length
                    noiseBeatlencounter = (noiseBeatlencounter - 1) and 0xFF
                    //> bne ExitMusicHandler      ;is it time for more data?
                    if (!(noiseBeatlencounter == 0)) {
                        //  goto ExitMusicHandler (internal forward branch)
                        //> ExitMusicHandler:
                        //> rts
                        return
                    }
                    return
                }
            }
            //> NotDOrD4: txa                     ;if playing water or castle music or any secondary
            A = X
            //> cmp #$12                ;besides death music or d4 set, check length of note
            //> bcs LongN
            if (!(A >= 0x12)) {
                //> lda EventMusicBuffer    ;check for win castle music again if not playing a long note
                A = eventMusicBuffer
                //> and #EndOfCastleMusic
                A = A and EndOfCastleMusic
                //> beq MediN
                if (A != 0) {
                    //> lda #$0f                ;load value $0f if playing the win castle music and playing a short
                    A = 0x0F
                    //> bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
                    if (!(A == 0)) {
                        //  goto LoadTriCtrlReg (internal forward branch)
                        //> LoadTriCtrlReg:
                        //> sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
                        sndTriangleReg[0] = A
                        return
                    }
                }
                //> MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
                A = 0x1F
                //> bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
                if (!(A == 0)) {
                    //  goto LoadTriCtrlReg (internal forward branch)
                    //> LoadTriCtrlReg:
                    //> sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
                    sndTriangleReg[0] = A
                    return
                }
            }
            //> LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
            A = 0xFF
        }
        //> LoadTriCtrlReg:
        //> sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
        sndTriangleReg[0] = A
    }
    //> HandleNoiseMusic:
    //> lda AreaMusicBuffer       ;check if playing underground or castle music
    A = areaMusicBuffer
    //> and #%11110011
    A = A and 0xF3
    //> beq ExitMusicHandler      ;if so, skip the noise routine
    if (A != 0) {
        //> dec Noise_BeatLenCounter  ;decrement noise beat length
        noiseBeatlencounter = (noiseBeatlencounter - 1) and 0xFF
        //> bne ExitMusicHandler      ;is it time for more data?
        if (noiseBeatlencounter == 0) {
            loop1@ while (noiseBeatlencounter == 0) {
                //> lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
                A = noiseDataLoopbackOfs
                //> sta MusicOffset_Noise       ;and loopback next time around
                musicoffsetNoise = A
                //> bne FetchNoiseBeatData      ;unconditional branch
                if (!(A == 0)) {
                    //  continue loop (branch back to FetchNoiseBeatData)
                    continue@loop1
                }
            }
            //> NoiseBeatHandler:
            //> jsr AlternateLengthHandler
            val pair1 = alternateLengthHandler(A)
            temp8 = pair1.first
            temp9 = pair1.second
            X = temp9
            //> sta Noise_BeatLenCounter    ;store length in noise beat counter
            noiseBeatlencounter = temp8
            //> txa
            A = X
            //> and #%00111110              ;reload data and erase length bits
            A = A and 0x3E
            //> beq SilentBeat              ;if no beat data, silence
            Y = temp9
            if (A != 0) {
                //> cmp #$30                    ;check the beat data and play the appropriate
                //> beq LongBeat                ;noise accordingly
                if (A != 0x30) {
                    //> cmp #$20
                    //> beq StrongBeat
                    if (A != 0x20) {
                        //> and #%00010000
                        A = A and 0x10
                        //> beq SilentBeat
                        if (A != 0) {
                            //> lda #$1c        ;short beat data
                            A = 0x1C
                            //> ldx #$03
                            X = 0x03
                            //> ldy #$18
                            Y = 0x18
                            //> bne PlayBeat
                            if (Y == 0) {
                            }
                        }
                    }
                    //> StrongBeat:
                    //> lda #$1c        ;strong beat data
                    A = 0x1C
                    //> ldx #$0c
                    X = 0x0C
                    //> ldy #$18
                    Y = 0x18
                    //> bne PlayBeat
                    if (Y == 0) {
                    }
                }
                //> LongBeat:
                //> lda #$1c        ;long beat data
                A = 0x1C
                //> ldx #$03
                X = 0x03
                //> ldy #$58
                Y = 0x58
                //> bne PlayBeat
                if (Y == 0) {
                }
            }
            //> SilentBeat:
            //> lda #$10        ;silence
            A = 0x10
            //> PlayBeat:
            //> sta SND_NOISE_REG    ;load beat data into noise regs
            sndNoiseReg[0] = A
            //> stx SND_NOISE_REG+2
            sndNoiseReg[2] = X
            //> sty SND_NOISE_REG+3
            sndNoiseReg[3] = Y
        }
    }
    //> ExitMusicHandler:
    //> rts
    return
}

// Decompiled from AlternateLengthHandler
fun alternateLengthHandler(A: Int): Pair<Int, Int> {
    var A: Int = A
    var X: Int = 0
    //> AlternateLengthHandler:
    //> tax            ;save a copy of original byte into X
    X = A
    //> ror            ;save LSB from original byte into carry
    val orig0: Int = A
    A = orig0 shr 1 or if (flagC) 0x80 else 0
    //> txa            ;reload original byte and rotate three times
    A = X
    //> rol            ;turning xx00000x into 00000xxx, with the
    val orig1: Int = A
    A = (orig1 shl 1) and 0xFE or if ((orig0 and 0x01) != 0) 1 else 0
    //> rol            ;bit in carry as the MSB here
    val orig2: Int = A
    A = (orig2 shl 1) and 0xFE or if ((orig1 and 0x80) != 0) 1 else 0
    //> rol
    val orig3: Int = A
    A = (orig3 shl 1) and 0xFE or if ((orig2 and 0x80) != 0) 1 else 0
    //  Fall-through tail call to processLengthData
    processLengthData(A)
    return Pair(A, X)
}

// Decompiled from ProcessLengthData
fun processLengthData(A: Int): Int {
    var A: Int = A
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var noteLengthTblAdder by MemoryByte(NoteLengthTblAdder)
    val musicLengthLookupTbl by MemoryByteIndexed(MusicLengthLookupTbl)
    //> ProcessLengthData:
    //> and #%00000111              ;clear all but the three LSBs
    A = A and 0x07
    //> clc
    //> adc $f0                     ;add offset loaded from first header byte
    temp0 = A + memory[0xF0].toInt()
    //> adc NoteLengthTblAdder      ;add extra if time running out music
    temp1 = (temp0 and 0xFF) + noteLengthTblAdder + if (temp0 > 0xFF) 1 else 0
    //> tay
    Y = temp1 and 0xFF
    //> lda MusicLengthLookupTbl,y  ;load length
    A = musicLengthLookupTbl[Y]
    //> rts
    return A
}

// Decompiled from LoadControlRegs
fun loadControlRegs(): Int {
    var A: Int = 0
    var X: Int = 0
    var Y: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    //> LoadControlRegs:
    //> lda EventMusicBuffer  ;check secondary buffer for win castle music
    A = eventMusicBuffer
    //> and #EndOfCastleMusic
    A = A and EndOfCastleMusic
    //> beq NotECstlM
    if (A != 0) {
        //> lda #$04              ;this value is only used for win castle music
        A = 0x04
        //> bne AllMus            ;unconditional branch
        if (!(A == 0)) {
            //  goto AllMus (internal forward branch)
            //> AllMus:    ldx #$82              ;load contents of other sound regs for square 2
            X = 0x82
            //> ldy #$7f
            Y = 0x7F
            //> rts
            return A
        }
    }
    //> NotECstlM: lda AreaMusicBuffer
    A = areaMusicBuffer
    //> and #%01111101        ;check primary buffer for water music
    A = A and 0x7D
    //> beq WaterMus
    if (A != 0) {
        //> lda #$08              ;this is the default value for all other music
        A = 0x08
        //> bne AllMus
        if (!(A == 0)) {
            //  goto AllMus (internal forward branch)
            //> AllMus:    ldx #$82              ;load contents of other sound regs for square 2
            X = 0x82
            //> ldy #$7f
            Y = 0x7F
            //> rts
            return A
        }
    }
    //> WaterMus:  lda #$28              ;this value is used for water music and all other event music
    A = 0x28
    //> AllMus:    ldx #$82              ;load contents of other sound regs for square 2
    X = 0x82
    //> ldy #$7f
    Y = 0x7F
    //> rts
    return A
}

// Decompiled from LoadEnvelopeData
fun loadEnvelopeData(Y: Int): Int {
    var A: Int = 0
    var Y: Int = Y
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    val areaMusicEnvData by MemoryByteIndexed(AreaMusicEnvData)
    val endOfCastleMusicEnvData by MemoryByteIndexed(EndOfCastleMusicEnvData)
    val waterEventMusEnvData by MemoryByteIndexed(WaterEventMusEnvData)
    //> LoadEnvelopeData:
    //> lda EventMusicBuffer           ;check secondary buffer for win castle music
    A = eventMusicBuffer
    //> and #EndOfCastleMusic
    A = A and EndOfCastleMusic
    //> beq LoadUsualEnvData
    Y = Y
    if (A != 0) {
        //> lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
        A = endOfCastleMusicEnvData[Y]
        //> rts
        return A
    } else {
        //> LoadUsualEnvData:
        //> lda AreaMusicBuffer            ;check primary buffer for water music
        A = areaMusicBuffer
        //> and #%01111101
        A = A and 0x7D
        //> beq LoadWaterEventMusEnvData
        if (A != 0) {
            //> lda AreaMusicEnvData,y         ;load default data from offset for all other music
            A = areaMusicEnvData[Y]
            //> rts
            return A
        } else {
            //> LoadWaterEventMusEnvData:
            //> lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
            A = waterEventMusEnvData[Y]
            //> rts
            return A
        }
    }
    return A
}


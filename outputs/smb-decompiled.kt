@file:OptIn(ExperimentalUnsignedTypes::class)

package com.ivieleague.decompiler6502tokotlin.smb

import com.ivieleague.decompiler6502tokotlin.hand.*

// Decompiled Super Mario Bros. NES ROM
// Generated from smbdism.asm

// Decompiled from @0
fun func_0() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var operMode by MemoryByte(OperMode)
    var ppuCtrlReg1 by MemoryByte(PPU_CTRL_REG1)
    var ppuCtrlReg2 by MemoryByte(PPU_CTRL_REG2)
    var pseudoRandomBitReg by MemoryByte(PseudoRandomBitReg)
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    var warmBootValidation by MemoryByte(WarmBootValidation)
    val ppuStatus by MemoryByteIndexed(PPU_STATUS)
    val sndDeltaReg by MemoryByteIndexed(SND_DELTA_REG)
    val topScoreDisplay by MemoryByteIndexed(TopScoreDisplay)
    //> ;SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
    //> ;by doppelganger (doppelheathen@gmail.com)
    //> ;This file is provided for your own use as-is.  It will require the character rom data
    //> ;and an iNES file header to get it to work.
    //> ;There are so many people I have to thank for this, that taking all the credit for
    //> ;myself would be an unforgivable act of arrogance. Without their help this would
    //> ;probably not be possible.  So I thank all the peeps in the nesdev scene whose insight into
    //> ;the 6502 and the NES helped me learn how it works (you guys know who you are, there's no
    //> ;way I could have done this without your help), as well as the authors of x816 and SMB
    //> ;Utility, and the reverse-engineers who did the original Super Mario Bros. Hacking Project,
    //> ;which I compared notes with but did not copy from.  Last but certainly not least, I thank
    //> ;Nintendo for creating this game and the NES, without which this disassembly would
    //> ;only be theory.
    //> ;Assembles with x816.
    //> ;-------------------------------------------------------------------------------------
    //> ;DEFINES
    //> ;NES specific hardware defines
    //> PPU_CTRL_REG1         = $2000
    //> PPU_CTRL_REG2         = $2001
    //> PPU_STATUS            = $2002
    //> PPU_SPR_ADDR          = $2003
    //> PPU_SPR_DATA          = $2004
    //> PPU_SCROLL_REG        = $2005
    //> PPU_ADDRESS           = $2006
    //> PPU_DATA              = $2007
    //> SND_REGISTER          = $4000
    //> SND_SQUARE1_REG       = $4000
    //> SND_SQUARE2_REG       = $4004
    //> SND_TRIANGLE_REG      = $4008
    //> SND_NOISE_REG         = $400c
    //> SND_DELTA_REG         = $4010
    //> SND_MASTERCTRL_REG    = $4015
    //> SPR_DMA               = $4014
    //> JOYPAD_PORT           = $4016
    //> JOYPAD_PORT1          = $4016
    //> JOYPAD_PORT2          = $4017
    //> ; GAME SPECIFIC DEFINES
    //> ObjectOffset          = $08
    //> FrameCounter          = $09
    //> SavedJoypadBits       = $06fc
    //> SavedJoypad1Bits      = $06fc
    //> SavedJoypad2Bits      = $06fd
    //> JoypadBitMask         = $074a
    //> JoypadOverride        = $0758
    //> A_B_Buttons           = $0a
    //> PreviousA_B_Buttons   = $0d
    //> Up_Down_Buttons       = $0b
    //> Left_Right_Buttons    = $0c
    //> GameEngineSubroutine  = $0e
    //> Mirror_PPU_CTRL_REG1  = $0778
    //> Mirror_PPU_CTRL_REG2  = $0779
    //> OperMode              = $0770
    //> OperMode_Task         = $0772
    //> ScreenRoutineTask     = $073c
    //> GamePauseStatus       = $0776
    //> GamePauseTimer        = $0777
    //> DemoAction            = $0717
    //> DemoActionTimer       = $0718
    //> TimerControl          = $0747
    //> IntervalTimerControl  = $077f
    //> Timers                = $0780
    //> SelectTimer           = $0780
    //> PlayerAnimTimer       = $0781
    //> JumpSwimTimer         = $0782
    //> RunningTimer          = $0783
    //> BlockBounceTimer      = $0784
    //> SideCollisionTimer    = $0785
    //> JumpspringTimer       = $0786
    //> GameTimerCtrlTimer    = $0787
    //> ClimbSideTimer        = $0789
    //> EnemyFrameTimer       = $078a
    //> FrenzyEnemyTimer      = $078f
    //> BowserFireBreathTimer = $0790
    //> StompTimer            = $0791
    //> AirBubbleTimer        = $0792
    //> ScrollIntervalTimer   = $0795
    //> EnemyIntervalTimer    = $0796
    //> BrickCoinTimer        = $079d
    //> InjuryTimer           = $079e
    //> StarInvincibleTimer   = $079f
    //> ScreenTimer           = $07a0
    //> WorldEndTimer         = $07a1
    //> DemoTimer             = $07a2
    //> Sprite_Data           = $0200
    //> Sprite_Y_Position     = $0200
    //> Sprite_Tilenumber     = $0201
    //> Sprite_Attributes     = $0202
    //> Sprite_X_Position     = $0203
    //> ScreenEdge_PageLoc    = $071a
    //> ScreenEdge_X_Pos      = $071c
    //> ScreenLeft_PageLoc    = $071a
    //> ScreenRight_PageLoc   = $071b
    //> ScreenLeft_X_Pos      = $071c
    //> ScreenRight_X_Pos     = $071d
    //> PlayerFacingDir       = $33
    //> DestinationPageLoc    = $34
    //> VictoryWalkControl    = $35
    //> ScrollFractional      = $0768
    //> PrimaryMsgCounter     = $0719
    //> SecondaryMsgCounter   = $0749
    //> HorizontalScroll      = $073f
    //> VerticalScroll        = $0740
    //> ScrollLock            = $0723
    //> ScrollThirtyTwo       = $073d
    //> Player_X_Scroll       = $06ff
    //> Player_Pos_ForScroll  = $0755
    //> ScrollAmount          = $0775
    //> AreaData              = $e7
    //> AreaDataLow           = $e7
    //> AreaDataHigh          = $e8
    //> EnemyData             = $e9
    //> EnemyDataLow          = $e9
    //> EnemyDataHigh         = $ea
    //> AreaParserTaskNum     = $071f
    //> ColumnSets            = $071e
    //> CurrentPageLoc        = $0725
    //> CurrentColumnPos      = $0726
    //> BackloadingFlag       = $0728
    //> BehindAreaParserFlag  = $0729
    //> AreaObjectPageLoc     = $072a
    //> AreaObjectPageSel     = $072b
    //> AreaDataOffset        = $072c
    //> AreaObjOffsetBuffer   = $072d
    //> AreaObjectLength      = $0730
    //> StaircaseControl      = $0734
    //> AreaObjectHeight      = $0735
    //> MushroomLedgeHalfLen  = $0736
    //> EnemyDataOffset       = $0739
    //> EnemyObjectPageLoc    = $073a
    //> EnemyObjectPageSel    = $073b
    //> MetatileBuffer        = $06a1
    //> BlockBufferColumnPos  = $06a0
    //> CurrentNTAddr_Low     = $0721
    //> CurrentNTAddr_High    = $0720
    //> AttributeBuffer       = $03f9
    //> LoopCommand           = $0745
    //> DisplayDigits         = $07d7
    //> TopScoreDisplay       = $07d7
    //> ScoreAndCoinDisplay   = $07dd
    //> PlayerScoreDisplay    = $07dd
    //> GameTimerDisplay      = $07f8
    //> DigitModifier         = $0134
    //> VerticalFlipFlag      = $0109
    //> FloateyNum_Control    = $0110
    //> ShellChainCounter     = $0125
    //> FloateyNum_Timer      = $012c
    //> FloateyNum_X_Pos      = $0117
    //> FloateyNum_Y_Pos      = $011e
    //> FlagpoleFNum_Y_Pos    = $010d
    //> FlagpoleFNum_YMFDummy = $010e
    //> FlagpoleScore         = $010f
    //> FlagpoleCollisionYPos = $070f
    //> StompChainCounter     = $0484
    //> VRAM_Buffer1_Offset   = $0300
    //> VRAM_Buffer1          = $0301
    //> VRAM_Buffer2_Offset   = $0340
    //> VRAM_Buffer2          = $0341
    //> VRAM_Buffer_AddrCtrl  = $0773
    //> Sprite0HitDetectFlag  = $0722
    //> DisableScreenFlag     = $0774
    //> DisableIntermediate   = $0769
    //> ColorRotateOffset     = $06d4
    //> TerrainControl        = $0727
    //> AreaStyle             = $0733
    //> ForegroundScenery     = $0741
    //> BackgroundScenery     = $0742
    //> CloudTypeOverride     = $0743
    //> BackgroundColorCtrl   = $0744
    //> AreaType              = $074e
    //> AreaAddrsLOffset      = $074f
    //> AreaPointer           = $0750
    //> PlayerEntranceCtrl    = $0710
    //> GameTimerSetting      = $0715
    //> AltEntranceControl    = $0752
    //> EntrancePage          = $0751
    //> NumberOfPlayers       = $077a
    //> WarpZoneControl       = $06d6
    //> ChangeAreaTimer       = $06de
    //> MultiLoopCorrectCntr  = $06d9
    //> MultiLoopPassCntr     = $06da
    //> FetchNewGameTimerFlag = $0757
    //> GameTimerExpiredFlag  = $0759
    //> PrimaryHardMode       = $076a
    //> SecondaryHardMode     = $06cc
    //> WorldSelectNumber     = $076b
    //> WorldSelectEnableFlag = $07fc
    //> ContinueWorld         = $07fd
    //> CurrentPlayer         = $0753
    //> PlayerSize            = $0754
    //> PlayerStatus          = $0756
    //> OnscreenPlayerInfo    = $075a
    //> NumberofLives         = $075a ;used by current player
    //> HalfwayPage           = $075b
    //> LevelNumber           = $075c ;the actual dash number
    //> Hidden1UpFlag         = $075d
    //> CoinTally             = $075e
    //> WorldNumber           = $075f
    //> AreaNumber            = $0760 ;internal number used to find areas
    //> CoinTallyFor1Ups      = $0748
    //> OffscreenPlayerInfo   = $0761
    //> OffScr_NumberofLives  = $0761 ;used by offscreen player
    //> OffScr_HalfwayPage    = $0762
    //> OffScr_LevelNumber    = $0763
    //> OffScr_Hidden1UpFlag  = $0764
    //> OffScr_CoinTally      = $0765
    //> OffScr_WorldNumber    = $0766
    //> OffScr_AreaNumber     = $0767
    //> BalPlatformAlignment  = $03a0
    //> Platform_X_Scroll     = $03a1
    //> PlatformCollisionFlag = $03a2
    //> YPlatformTopYPos      = $0401
    //> YPlatformCenterYPos   = $58
    //> BrickCoinTimerFlag    = $06bc
    //> StarFlagTaskControl   = $0746
    //> PseudoRandomBitReg    = $07a7
    //> WarmBootValidation    = $07ff
    //> SprShuffleAmtOffset   = $06e0
    //> SprShuffleAmt         = $06e1
    //> SprDataOffset         = $06e4
    //> Player_SprDataOffset  = $06e4
    //> Enemy_SprDataOffset   = $06e5
    //> Block_SprDataOffset   = $06ec
    //> Alt_SprDataOffset     = $06ec
    //> Bubble_SprDataOffset  = $06ee
    //> FBall_SprDataOffset   = $06f1
    //> Misc_SprDataOffset    = $06f3
    //> SprDataOffset_Ctrl    = $03ee
    //> Player_State          = $1d
    //> Enemy_State           = $1e
    //> Fireball_State        = $24
    //> Block_State           = $26
    //> Misc_State            = $2a
    //> Player_MovingDir      = $45
    //> Enemy_MovingDir       = $46
    //> SprObject_X_Speed     = $57
    //> Player_X_Speed        = $57
    //> Enemy_X_Speed         = $58
    //> Fireball_X_Speed      = $5e
    //> Block_X_Speed         = $60
    //> Misc_X_Speed          = $64
    //> Jumpspring_FixedYPos  = $58
    //> JumpspringAnimCtrl    = $070e
    //> JumpspringForce       = $06db
    //> SprObject_PageLoc     = $6d
    //> Player_PageLoc        = $6d
    //> Enemy_PageLoc         = $6e
    //> Fireball_PageLoc      = $74
    //> Block_PageLoc         = $76
    //> Misc_PageLoc          = $7a
    //> Bubble_PageLoc        = $83
    //> SprObject_X_Position  = $86
    //> Player_X_Position     = $86
    //> Enemy_X_Position      = $87
    //> Fireball_X_Position   = $8d
    //> Block_X_Position      = $8f
    //> Misc_X_Position       = $93
    //> Bubble_X_Position     = $9c
    //> SprObject_Y_Speed     = $9f
    //> Player_Y_Speed        = $9f
    //> Enemy_Y_Speed         = $a0
    //> Fireball_Y_Speed      = $a6
    //> Block_Y_Speed         = $a8
    //> Misc_Y_Speed          = $ac
    //> SprObject_Y_HighPos   = $b5
    //> Player_Y_HighPos      = $b5
    //> Enemy_Y_HighPos       = $b6
    //> Fireball_Y_HighPos    = $bc
    //> Block_Y_HighPos       = $be
    //> Misc_Y_HighPos        = $c2
    //> Bubble_Y_HighPos      = $cb
    //> SprObject_Y_Position  = $ce
    //> Player_Y_Position     = $ce
    //> Enemy_Y_Position      = $cf
    //> Fireball_Y_Position   = $d5
    //> Block_Y_Position      = $d7
    //> Misc_Y_Position       = $db
    //> Bubble_Y_Position     = $e4
    //> SprObject_Rel_XPos    = $03ad
    //> Player_Rel_XPos       = $03ad
    //> Enemy_Rel_XPos        = $03ae
    //> Fireball_Rel_XPos     = $03af
    //> Bubble_Rel_XPos       = $03b0
    //> Block_Rel_XPos        = $03b1
    //> Misc_Rel_XPos         = $03b3
    //> SprObject_Rel_YPos    = $03b8
    //> Player_Rel_YPos       = $03b8
    //> Enemy_Rel_YPos        = $03b9
    //> Fireball_Rel_YPos     = $03ba
    //> Bubble_Rel_YPos       = $03bb
    //> Block_Rel_YPos        = $03bc
    //> Misc_Rel_YPos         = $03be
    //> SprObject_SprAttrib   = $03c4
    //> Player_SprAttrib      = $03c4
    //> Enemy_SprAttrib       = $03c5
    //> SprObject_X_MoveForce = $0400
    //> Enemy_X_MoveForce     = $0401
    //> SprObject_YMF_Dummy   = $0416
    //> Player_YMF_Dummy      = $0416
    //> Enemy_YMF_Dummy       = $0417
    //> Bubble_YMF_Dummy      = $042c
    //> SprObject_Y_MoveForce = $0433
    //> Player_Y_MoveForce    = $0433
    //> Enemy_Y_MoveForce     = $0434
    //> Block_Y_MoveForce     = $043c
    //> DisableCollisionDet   = $0716
    //> Player_CollisionBits  = $0490
    //> Enemy_CollisionBits   = $0491
    //> SprObj_BoundBoxCtrl   = $0499
    //> Player_BoundBoxCtrl   = $0499
    //> Enemy_BoundBoxCtrl    = $049a
    //> Fireball_BoundBoxCtrl = $04a0
    //> Misc_BoundBoxCtrl     = $04a2
    //> EnemyFrenzyBuffer     = $06cb
    //> EnemyFrenzyQueue      = $06cd
    //> Enemy_Flag            = $0f
    //> Enemy_ID              = $16
    //> PlayerGfxOffset       = $06d5
    //> Player_XSpeedAbsolute = $0700
    //> FrictionAdderHigh     = $0701
    //> FrictionAdderLow      = $0702
    //> RunningSpeed          = $0703
    //> SwimmingFlag          = $0704
    //> Player_X_MoveForce    = $0705
    //> DiffToHaltJump        = $0706
    //> JumpOrigin_Y_HighPos  = $0707
    //> JumpOrigin_Y_Position = $0708
    //> VerticalForce         = $0709
    //> VerticalForceDown     = $070a
    //> PlayerChangeSizeFlag  = $070b
    //> PlayerAnimTimerSet    = $070c
    //> PlayerAnimCtrl        = $070d
    //> DeathMusicLoaded      = $0712
    //> FlagpoleSoundQueue    = $0713
    //> CrouchingFlag         = $0714
    //> MaximumLeftSpeed      = $0450
    //> MaximumRightSpeed     = $0456
    //> SprObject_OffscrBits  = $03d0
    //> Player_OffscreenBits  = $03d0
    //> Enemy_OffscreenBits   = $03d1
    //> FBall_OffscreenBits   = $03d2
    //> Bubble_OffscreenBits  = $03d3
    //> Block_OffscreenBits   = $03d4
    //> Misc_OffscreenBits    = $03d6
    //> EnemyOffscrBitsMasked = $03d8
    //> Cannon_Offset         = $046a
    //> Cannon_PageLoc        = $046b
    //> Cannon_X_Position     = $0471
    //> Cannon_Y_Position     = $0477
    //> Cannon_Timer          = $047d
    //> Whirlpool_Offset      = $046a
    //> Whirlpool_PageLoc     = $046b
    //> Whirlpool_LeftExtent  = $0471
    //> Whirlpool_Length      = $0477
    //> Whirlpool_Flag        = $047d
    //> VineFlagOffset        = $0398
    //> VineHeight            = $0399
    //> VineObjOffset         = $039a
    //> VineStart_Y_Position  = $039d
    //> Block_Orig_YPos       = $03e4
    //> Block_BBuf_Low        = $03e6
    //> Block_Metatile        = $03e8
    //> Block_PageLoc2        = $03ea
    //> Block_RepFlag         = $03ec
    //> Block_ResidualCounter = $03f0
    //> Block_Orig_XPos       = $03f1
    //> BoundingBox_UL_XPos   = $04ac
    //> BoundingBox_UL_YPos   = $04ad
    //> BoundingBox_DR_XPos   = $04ae
    //> BoundingBox_DR_YPos   = $04af
    //> BoundingBox_UL_Corner = $04ac
    //> BoundingBox_LR_Corner = $04ae
    //> EnemyBoundingBoxCoord = $04b0
    //> PowerUpType           = $39
    //> FireballBouncingFlag  = $3a
    //> FireballCounter       = $06ce
    //> FireballThrowingTimer = $0711
    //> HammerEnemyOffset     = $06ae
    //> JumpCoinMiscOffset    = $06b7
    //> Block_Buffer_1        = $0500
    //> Block_Buffer_2        = $05d0
    //> HammerThrowingTimer   = $03a2
    //> HammerBroJumpTimer    = $3c
    //> Misc_Collision_Flag   = $06be
    //> RedPTroopaOrigXPos    = $0401
    //> RedPTroopaCenterYPos  = $58
    //> XMovePrimaryCounter   = $a0
    //> XMoveSecondaryCounter = $58
    //> CheepCheepMoveMFlag   = $58
    //> CheepCheepOrigYPos    = $0434
    //> BitMFilter            = $06dd
    //> LakituReappearTimer   = $06d1
    //> LakituMoveSpeed       = $58
    //> LakituMoveDirection   = $a0
    //> FirebarSpinState_Low  = $58
    //> FirebarSpinState_High = $a0
    //> FirebarSpinSpeed      = $0388
    //> FirebarSpinDirection  = $34
    //> DuplicateObj_Offset   = $06cf
    //> NumberofGroupEnemies  = $06d3
    //> BlooperMoveCounter    = $a0
    //> BlooperMoveSpeed      = $58
    //> BowserBodyControls    = $0363
    //> BowserFeetCounter     = $0364
    //> BowserMovementSpeed   = $0365
    //> BowserOrigXPos        = $0366
    //> BowserFlameTimerCtrl  = $0367
    //> BowserFront_Offset    = $0368
    //> BridgeCollapseOffset  = $0369
    //> BowserGfxFlag         = $036a
    //> BowserHitPoints       = $0483
    //> MaxRangeFromOrigin    = $06dc
    //> BowserFlamePRandomOfs = $0417
    //> PiranhaPlantUpYPos    = $0417
    //> PiranhaPlantDownYPos  = $0434
    //> PiranhaPlant_Y_Speed  = $58
    //> PiranhaPlant_MoveFlag = $a0
    //> FireworksCounter      = $06d7
    //> ExplosionGfxCounter   = $58
    //> ExplosionTimerCounter = $a0
    //> ;sound related defines
    //> Squ2_NoteLenBuffer    = $07b3
    //> Squ2_NoteLenCounter   = $07b4
    //> Squ2_EnvelopeDataCtrl = $07b5
    //> Squ1_NoteLenCounter   = $07b6
    //> Squ1_EnvelopeDataCtrl = $07b7
    //> Tri_NoteLenBuffer     = $07b8
    //> Tri_NoteLenCounter    = $07b9
    //> Noise_BeatLenCounter  = $07ba
    //> Squ1_SfxLenCounter    = $07bb
    //> Squ2_SfxLenCounter    = $07bd
    //> Sfx_SecondaryCounter  = $07be
    //> Noise_SfxLenCounter   = $07bf
    //> PauseSoundQueue       = $fa
    //> Square1SoundQueue     = $ff
    //> Square2SoundQueue     = $fe
    //> NoiseSoundQueue       = $fd
    //> AreaMusicQueue        = $fb
    //> EventMusicQueue       = $fc
    //> Square1SoundBuffer    = $f1
    //> Square2SoundBuffer    = $f2
    //> NoiseSoundBuffer      = $f3
    //> AreaMusicBuffer       = $f4
    //> EventMusicBuffer      = $07b1
    //> PauseSoundBuffer      = $07b2
    //> MusicData             = $f5
    //> MusicDataLow          = $f5
    //> MusicDataHigh         = $f6
    //> MusicOffset_Square2   = $f7
    //> MusicOffset_Square1   = $f8
    //> MusicOffset_Triangle  = $f9
    //> MusicOffset_Noise     = $07b0
    //> NoteLenLookupTblOfs   = $f0
    //> DAC_Counter           = $07c0
    //> NoiseDataLoopbackOfs  = $07c1
    //> NoteLengthTblAdder    = $07c4
    //> AreaMusicBuffer_Alt   = $07c5
    //> PauseModeFlag         = $07c6
    //> GroundMusicHeaderOfs  = $07c7
    //> AltRegContentFlag     = $07ca
    //> ;-------------------------------------------------------------------------------------
    //> ;CONSTANTS
    //> ;sound effects constants
    //> Sfx_SmallJump         = %10000000
    //> Sfx_Flagpole          = %01000000
    //> Sfx_Fireball          = %00100000
    //> Sfx_PipeDown_Injury   = %00010000
    //> Sfx_EnemySmack        = %00001000
    //> Sfx_EnemyStomp        = %00000100
    //> Sfx_Bump              = %00000010
    //> Sfx_BigJump           = %00000001
    //> Sfx_BowserFall        = %10000000
    //> Sfx_ExtraLife         = %01000000
    //> Sfx_PowerUpGrab       = %00100000
    //> Sfx_TimerTick         = %00010000
    //> Sfx_Blast             = %00001000
    //> Sfx_GrowVine          = %00000100
    //> Sfx_GrowPowerUp       = %00000010
    //> Sfx_CoinGrab          = %00000001
    //> Sfx_BowserFlame       = %00000010
    //> Sfx_BrickShatter      = %00000001
    //> ;music constants
    //> Silence               = %10000000
    //> StarPowerMusic        = %01000000
    //> PipeIntroMusic        = %00100000
    //> CloudMusic            = %00010000
    //> CastleMusic           = %00001000
    //> UndergroundMusic      = %00000100
    //> WaterMusic            = %00000010
    //> GroundMusic           = %00000001
    //> TimeRunningOutMusic   = %01000000
    //> EndOfLevelMusic       = %00100000
    //> AltGameOverMusic      = %00010000
    //> EndOfCastleMusic      = %00001000
    //> VictoryMusic          = %00000100
    //> GameOverMusic         = %00000010
    //> DeathMusic            = %00000001
    //> ;enemy object constants
    //> GreenKoopa            = $00
    //> BuzzyBeetle           = $02
    //> RedKoopa              = $03
    //> HammerBro             = $05
    //> Goomba                = $06
    //> Bloober               = $07
    //> BulletBill_FrenzyVar  = $08
    //> GreyCheepCheep        = $0a
    //> RedCheepCheep         = $0b
    //> Podoboo               = $0c
    //> PiranhaPlant          = $0d
    //> GreenParatroopaJump   = $0e
    //> RedParatroopa         = $0f
    //> GreenParatroopaFly    = $10
    //> Lakitu                = $11
    //> Spiny                 = $12
    //> FlyCheepCheepFrenzy   = $14
    //> FlyingCheepCheep      = $14
    //> BowserFlame           = $15
    //> Fireworks             = $16
    //> BBill_CCheep_Frenzy   = $17
    //> Stop_Frenzy           = $18
    //> Bowser                = $2d
    //> PowerUpObject         = $2e
    //> VineObject            = $2f
    //> FlagpoleFlagObject    = $30
    //> StarFlagObject        = $31
    //> JumpspringObject      = $32
    //> BulletBill_CannonVar  = $33
    //> RetainerObject        = $35
    //> TallEnemy             = $09
    //> ;other constants
    //> World1 = 0
    //> World2 = 1
    //> World3 = 2
    //> World4 = 3
    //> World5 = 4
    //> World6 = 5
    //> World7 = 6
    //> World8 = 7
    //> Level1 = 0
    //> Level2 = 1
    //> Level3 = 2
    //> Level4 = 3
    //> WarmBootOffset        = <$07d6
    //> ColdBootOffset        = <$07fe
    //> TitleScreenDataOffset = $1ec0
    //> SoundMemory           = $07b0
    //> SwimTileRepOffset     = PlayerGraphicsTable + $9e
    //> MusicHeaderOffsetData = MusicHeaderData - 1
    //> MHD                   = MusicHeaderData
    //> A_Button              = %10000000
    //> B_Button              = %01000000
    //> Select_Button         = %00100000
    //> Start_Button          = %00010000
    //> Up_Dir                = %00001000
    //> Down_Dir              = %00000100
    //> Left_Dir              = %00000010
    //> Right_Dir             = %00000001
    //> TitleScreenModeValue  = 0
    //> GameModeValue         = 1
    //> VictoryModeValue      = 2
    //> GameOverModeValue     = 3
    //> ;-------------------------------------------------------------------------------------
    //> ;DIRECTIVES
    //> .index 8
    //> .mem 8
    //> .org $8000
    //> ;-------------------------------------------------------------------------------------
    //> Start:
    //> sei                          ;pretty standard 6502 type init here
    //> cld
    //> lda #%00010000               ;init PPU control register 1
    //> sta PPU_CTRL_REG1
    ppuCtrlReg1 = 0x10
    //> ldx #$ff                     ;reset stack pointer
    //> txs
    temp0 = 0xFF
    do {
        //> VBlank1:     lda PPU_STATUS               ;wait two frames
        //> bpl VBlank1
    } while ((ppuStatus[0] and 0x80) == 0)
    do {
        //> VBlank2:     lda PPU_STATUS
        //> bpl VBlank2
    } while ((ppuStatus[0] and 0x80) == 0)
    //> ldy #ColdBootOffset          ;load default cold boot pointer
    //> ldx #$05                     ;this is where we check for a warm boot
    temp0 = 0x05
    temp1 = ColdBootOffset
    while ((temp0 and 0x80) == 0) {
        //> dex
        temp0 = (temp0 - 1) and 0xFF
        //> bpl WBootCheck
    }
    //> lda WarmBootValidation       ;second checkpoint, check to see if
    //> cmp #$a5                     ;another location has a specific value
    //> bne ColdBoot
    temp2 = warmBootValidation
    if (warmBootValidation == 0xA5) {
        //> ldy #WarmBootOffset          ;if passed both, load warm boot pointer
        temp1 = WarmBootOffset
    }
    //> ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
    initializeMemory(temp1)
    //> sta SND_DELTA_REG+1          ;reset delta counter load register
    sndDeltaReg[1] = temp2
    //> sta OperMode                 ;reset primary mode of operation
    operMode = temp2
    //> lda #$a5                     ;set warm boot flag
    temp2 = 0xA5
    //> sta WarmBootValidation
    warmBootValidation = temp2
    //> sta PseudoRandomBitReg       ;set seed for pseudorandom register
    pseudoRandomBitReg = temp2
    //> lda #%00001111
    temp2 = 0x0F
    //> sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
    sndMasterctrlReg = temp2
    //> lda #%00000110
    temp2 = 0x06
    //> sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
    ppuCtrlReg2 = temp2
    //> jsr MoveAllSpritesOffscreen
    moveAllSpritesOffscreen()
    //> jsr InitializeNameTables     ;initialize both name tables
    initializeNameTables()
    //> inc DisableScreenFlag        ;set flag to disable screen output
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> lda Mirror_PPU_CTRL_REG1
    temp2 = mirrorPpuCtrlReg1
    //> ora #%10000000               ;enable NMIs
    temp3 = temp2 or 0x80
    //> jsr WritePPUReg1
    writePPUReg1(temp3)
    while (true) {
        //> EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
    }
}

// Decompiled from PauseRoutine
fun pauseRoutine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var gamePauseStatus by MemoryByte(GamePauseStatus)
    var gamePauseTimer by MemoryByte(GamePauseTimer)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var pauseSoundQueue by MemoryByte(PauseSoundQueue)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    //> PauseRoutine:
    //> lda OperMode           ;are we in victory mode?
    //> cmp #VictoryModeValue  ;if so, go ahead
    //> beq ChkPauseTimer
    temp0 = operMode
    if (operMode != VictoryModeValue) {
        //> cmp #GameModeValue     ;are we in game mode?
        //> bne ExitPause          ;if not, leave
        if (temp0 == GameModeValue) {
            //> lda OperMode_Task      ;if we are in game mode, are we running game engine?
            temp0 = opermodeTask
            //> cmp #$03
            //> bne ExitPause          ;if not, leave
            if (temp0 == 0x03) {
            } else {
                //> ExitPause:     rts
                return
            }
        }
    }
    //> ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
    temp0 = gamePauseTimer
    //> beq ChkStart
    if (temp0 != 0) {
        //> dec GamePauseTimer     ;if so, decrement and leave
        gamePauseTimer = (gamePauseTimer - 1) and 0xFF
        //> rts
        return
    } else {
        //> ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
        temp0 = savedJoypad1Bits
        //> and #Start_Button      ;on controller 1
        temp1 = temp0 and Start_Button
        //> beq ClrPauseTimer
        temp0 = temp1
        if (temp1 != 0) {
            //> lda GamePauseStatus    ;check to see if timer flag is set
            temp0 = gamePauseStatus
            //> and #%10000000         ;and if so, do not reset timer (residual,
            temp2 = temp0 and 0x80
            //> bne ExitPause          ;joypad reading routine makes this unnecessary)
            temp0 = temp2
            if (temp2 == 0) {
                //> lda #$2b               ;set pause timer
                temp0 = 0x2B
                //> sta GamePauseTimer
                gamePauseTimer = temp0
                //> lda GamePauseStatus
                temp0 = gamePauseStatus
                //> tay
                //> iny                    ;set pause sfx queue for next pause mode
                temp0 = (temp0 + 1) and 0xFF
                //> sty PauseSoundQueue
                pauseSoundQueue = temp0
                //> eor #%00000001         ;invert d0 and set d7
                temp3 = temp0 xor 0x01
                //> ora #%10000000
                temp4 = temp3 or 0x80
                //> bne SetPause           ;unconditional branch
                temp0 = temp4
                temp5 = temp0
                if (temp4 == 0) {
                }
            }
        }
    }
    //> ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
    temp0 = gamePauseStatus
    //> and #%01111111         ;is not pressed
    temp6 = temp0 and 0x7F
    //> SetPause:      sta GamePauseStatus
    gamePauseStatus = temp6
}

// Decompiled from SpriteShuffler
fun spriteShuffler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var areaType by MemoryByte(AreaType)
    var sprShuffleAmtOffset by MemoryByte(SprShuffleAmtOffset)
    val miscSprdataoffset by MemoryByteIndexed(Misc_SprDataOffset)
    val sprDataOffset by MemoryByteIndexed(SprDataOffset)
    val sprShuffleAmt by MemoryByteIndexed(SprShuffleAmt)
    //> SpriteShuffler:
    //> ldy AreaType                ;load level type, likely residual code
    //> lda #$28                    ;load preset value which will put it at
    //> sta $00                     ;sprite #10
    memory[0x0] = 0x28.toUByte()
    //> ldx #$0e                    ;start at the end of OAM data offsets
    temp0 = 0x0E
    temp1 = areaType
    do {
        //> ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
        //> cmp $00                     ;the preset value
        //> bcc NextSprOffset           ;if less, skip this part
        temp2 = sprDataOffset[temp0]
        if (sprDataOffset[temp0] >= memory[0x0].toInt()) {
            //> ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
            temp1 = sprShuffleAmtOffset
            //> clc
            //> adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
            temp3 = temp2 + sprShuffleAmt[temp1]
            temp2 = temp3 and 0xFF
            //> bcc StrSprOffset            ;if not exceeded $ff, skip second add
            if (temp3 > 0xFF) {
                //> clc
                //> adc $00                     ;otherwise add preset value $28 to offset
                temp4 = temp2 + memory[0x0].toInt()
                temp2 = temp4 and 0xFF
            }
            //> StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
            sprDataOffset[temp0] = temp2
        }
        //> NextSprOffset: dex                         ;move backwards to next one
        temp0 = (temp0 - 1) and 0xFF
        //> bpl ShuffleLoop
    } while ((temp0 and 0x80) == 0)
    //> ldx SprShuffleAmtOffset     ;load offset
    temp0 = sprShuffleAmtOffset
    //> inx
    temp0 = (temp0 + 1) and 0xFF
    //> cpx #$03                    ;check if offset + 1 goes to 3
    //> bne SetAmtOffset            ;if offset + 1 not 3, store
    if (temp0 == 0x03) {
        //> ldx #$00                    ;otherwise, init to 0
        temp0 = 0x00
    }
    //> SetAmtOffset:  stx SprShuffleAmtOffset
    sprShuffleAmtOffset = temp0
    //> ldx #$08                    ;load offsets for values and storage
    temp0 = 0x08
    //> ldy #$02
    temp1 = 0x02
    do {
        //> SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
        temp2 = sprDataOffset[5 + temp1]
        //> sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
        miscSprdataoffset[-2 + temp0] = temp2
        //> clc                         ;add eight to the second and eight
        //> adc #$08                    ;more to the third one
        temp5 = temp2 + 0x08
        temp2 = temp5 and 0xFF
        //> sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
        miscSprdataoffset[-1 + temp0] = temp2
        //> clc                         ;this code loads into the misc sprite offsets
        //> adc #$08
        temp6 = temp2 + 0x08
        temp2 = temp6 and 0xFF
        //> sta Misc_SprDataOffset,x
        miscSprdataoffset[temp0] = temp2
        //> dex
        temp0 = (temp0 - 1) and 0xFF
        //> dex
        temp0 = (temp0 - 1) and 0xFF
        //> dex
        temp0 = (temp0 - 1) and 0xFF
        //> dey
        temp1 = (temp1 - 1) and 0xFF
        //> bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
    } while ((temp1 and 0x80) == 0)
    //> rts
    return
}

// Decompiled from OperModeExecutionTree
fun operModeExecutionTree() {
    var operMode by MemoryByte(OperMode)
    //> OperModeExecutionTree:
    //> lda OperMode     ;this is the heart of the entire program,
    //> jsr JumpEngine   ;most of what goes on starts here
    when (operMode) {
        0 -> {
            titleScreenMode()
        }
        1 -> {
            gameMode()
        }
        2 -> {
            victoryMode()
        }
        3 -> {
            gameOverMode()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from MoveAllSpritesOffscreen
fun moveAllSpritesOffscreen() {
    //> MoveAllSpritesOffscreen:
    //> ldy #$00                ;this routine moves all sprites off the screen
    //> .db $2c                 ;BIT instruction opcode
    // Fall-through tail call to moveSpritesOffscreen
    moveSpritesOffscreen()
}

// Decompiled from MoveSpritesOffscreen
fun moveSpritesOffscreen() {
    var temp0: Int = 0
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> MoveSpritesOffscreen:
    //> ldy #$04                ;this routine moves all but sprite 0
    //> lda #$f8                ;off the screen
    temp0 = 0x04
    do {
        //> SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
        spriteYPosition[temp0] = 0xF8
        //> iny                     ;which will move it off the screen
        temp0 = (temp0 + 1) and 0xFF
        //> iny
        temp0 = (temp0 + 1) and 0xFF
        //> iny
        temp0 = (temp0 + 1) and 0xFF
        //> iny
        temp0 = (temp0 + 1) and 0xFF
        //> bne SprInitLoop
    } while (temp0 != 0)
    //> rts
    return
}

// Decompiled from TitleScreenMode
fun titleScreenMode() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> TitleScreenMode:
    //> lda OperMode_Task
    //> jsr JumpEngine
    when (opermodeTask) {
        0 -> {
            initializeGame(0)
        }
        1 -> {
            screenRoutines()
        }
        2 -> {
            primaryGameSetup()
        }
        3 -> {
            gameMenuRoutine()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from GameMenuRoutine
fun gameMenuRoutine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var continueWorld by MemoryByte(ContinueWorld)
    var demoTimer by MemoryByte(DemoTimer)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    var offscrHidden1upflag by MemoryByte(OffScr_Hidden1UpFlag)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    var savedJoypad2Bits by MemoryByte(SavedJoypad2Bits)
    var selectTimer by MemoryByte(SelectTimer)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    var worldNumber by MemoryByte(WorldNumber)
    var worldSelectEnableFlag by MemoryByte(WorldSelectEnableFlag)
    var worldSelectNumber by MemoryByte(WorldSelectNumber)
    val scoreAndCoinDisplay by MemoryByteIndexed(ScoreAndCoinDisplay)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    val wSelectBufferTemplate by MemoryByteIndexed(WSelectBufferTemplate)
    //> GameMenuRoutine:
    //> ldy #$00
    //> lda SavedJoypad1Bits        ;check to see if either player pressed
    //> ora SavedJoypad2Bits        ;only the start button (either joypad)
    temp0 = savedJoypad1Bits or savedJoypad2Bits
    //> cmp #Start_Button
    //> beq StartGame
    if (temp0 - Start_Button == 0) {
        //  goto StartGame
        return
    }
    temp1 = temp0
    temp2 = 0x00
    if (temp0 != Start_Button) {
        //> cmp #A_Button+Start_Button  ;check to see if A + start was pressed
        //> bne ChkSelect               ;if not, branch to check select button
        if (temp1 == A_Button+Start_Button) {
        }
    }
    //> StartGame:    jmp ChkContinue             ;if either start or A + start, execute here
    //> ChkSelect:    cmp #Select_Button          ;check to see if the select button was pressed
    //> beq SelectBLogic            ;if so, branch reset demo timer
    if (temp1 != Select_Button) {
        //> ldx DemoTimer               ;otherwise check demo timer
        //> bne ChkWorldSel             ;if demo timer not expired, branch to check world selection
        temp3 = demoTimer
        if (demoTimer == 0) {
            //> sta SelectTimer             ;set controller bits here if running demo
            selectTimer = temp1
            //> jsr DemoEngine              ;run through the demo actions
            demoEngine()
            //> bcs ResetTitle              ;if carry flag set, demo over, thus branch
            if (!(temp1 >= Select_Button)) {
                //> jmp RunDemo                 ;otherwise, run game engine for demo
            } else {
                //> ResetTitle:   lda #$00                    ;reset game modes, disable
                temp1 = 0x00
                //> sta OperMode                ;sprite 0 check and disable
                operMode = temp1
                //> sta OperMode_Task           ;screen output
                opermodeTask = temp1
                //> sta Sprite0HitDetectFlag
                sprite0HitDetectFlag = temp1
                //> inc DisableScreenFlag
                disableScreenFlag = (disableScreenFlag + 1) and 0xFF
                //> rts
                return
            }
        }
        //> ChkWorldSel:  ldx WorldSelectEnableFlag   ;check to see if world selection has been enabled
        temp3 = worldSelectEnableFlag
        //> beq NullJoypad
        if (temp3 != 0) {
            //> cmp #B_Button               ;if so, check to see if the B button was pressed
            //> bne NullJoypad
            if (temp1 == B_Button) {
                //> iny                         ;if so, increment Y and execute same code as select
                temp2 = (temp2 + 1) and 0xFF
            }
        }
    }
    //> SelectBLogic: lda DemoTimer               ;if select or B pressed, check demo timer one last time
    temp1 = demoTimer
    //> beq ResetTitle              ;if demo timer expired, branch to reset title screen mode
    if (temp1 != 0) {
        //> lda #$18                    ;otherwise reset demo timer
        temp1 = 0x18
        //> sta DemoTimer
        demoTimer = temp1
        //> lda SelectTimer             ;check select/B button timer
        temp1 = selectTimer
        //> bne NullJoypad              ;if not expired, branch
        if (temp1 == 0) {
            //> lda #$10                    ;otherwise reset select button timer
            temp1 = 0x10
            //> sta SelectTimer
            selectTimer = temp1
            //> cpy #$01                    ;was the B button pressed earlier?  if so, branch
            //> beq IncWorldSel             ;note this will not be run if world selection is disabled
            if (temp2 != 0x01) {
                //> lda NumberOfPlayers         ;if no, must have been the select button, therefore
                temp1 = numberOfPlayers
                //> eor #%00000001              ;change number of players and draw icon accordingly
                temp4 = temp1 xor 0x01
                //> sta NumberOfPlayers
                numberOfPlayers = temp4
                //> jsr DrawMushroomIcon
                drawMushroomIcon()
                //> jmp NullJoypad
            } else {
                //> IncWorldSel:  ldx WorldSelectNumber       ;increment world select number
                temp3 = worldSelectNumber
                //> inx
                temp3 = (temp3 + 1) and 0xFF
                //> txa
                //> and #%00000111              ;mask out higher bits
                temp5 = temp3 and 0x07
                //> sta WorldSelectNumber       ;store as current world select number
                worldSelectNumber = temp5
                //> jsr GoContinue
                goContinue(temp5)
                do {
                    //> UpdateShroom: lda WSelectBufferTemplate,x ;write template for world select in vram buffer
                    temp1 = wSelectBufferTemplate[temp3]
                    //> sta VRAM_Buffer1-1,x        ;do this until all bytes are written
                    vramBuffer1[-1 + temp3] = temp1
                    //> inx
                    temp3 = (temp3 + 1) and 0xFF
                    //> cpx #$06
                    //> bmi UpdateShroom
                } while ((temp3 and 0x80) != 0)
                //> ldy WorldNumber             ;get world number from variable and increment for
                temp2 = worldNumber
                //> iny                         ;proper display, and put in blank byte before
                temp2 = (temp2 + 1) and 0xFF
                //> sty VRAM_Buffer1+3          ;null terminator
                vramBuffer1[3] = temp2
            }
        }
        //> NullJoypad:   lda #$00                    ;clear joypad bits for player 1
        temp1 = 0x00
        //> sta SavedJoypad1Bits
        savedJoypad1Bits = temp1
        //> RunDemo:      jsr GameCoreRoutine         ;run game engine
        gameCoreRoutine()
        //> lda GameEngineSubroutine    ;check to see if we're running lose life routine
        temp1 = gameEngineSubroutine
        //> cmp #$06
        //> bne ExitMenu                ;if not, do not do all the resetting below
        if (temp1 == 0x06) {
        } else {
            //> ExitMenu:     rts
            return
        }
    }
    do {
        //> ChkContinue:  ldy DemoTimer               ;if timer for demo has expired, reset modes
        temp2 = demoTimer
        //> beq ResetTitle
    } while (temp2 == 0)
    //> asl                         ;check to see if A button was also pushed
    temp1 = (temp1 shl 1) and 0xFF
    //> bcc StartWorld1             ;if not, don't load continue function's world number
    if ((temp1 and 0x80) != 0) {
        //> lda ContinueWorld           ;load previously saved world number for secret
        temp1 = continueWorld
        //> jsr GoContinue              ;continue function when pressing A + start
        goContinue(temp1)
    }
    //> StartWorld1:  jsr LoadAreaPointer
    loadAreaPointer(temp1)
    //> inc Hidden1UpFlag           ;set 1-up box flag for both players
    hidden1UpFlag = (hidden1UpFlag + 1) and 0xFF
    //> inc OffScr_Hidden1UpFlag
    offscrHidden1upflag = (offscrHidden1upflag + 1) and 0xFF
    //> inc FetchNewGameTimerFlag   ;set fetch new game timer flag
    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
    //> inc OperMode                ;set next game mode
    operMode = (operMode + 1) and 0xFF
    //> lda WorldSelectEnableFlag   ;if world select flag is on, then primary
    temp1 = worldSelectEnableFlag
    //> sta PrimaryHardMode         ;hard mode must be on as well
    primaryHardMode = temp1
    //> lda #$00
    temp1 = 0x00
    //> sta OperMode_Task           ;set game mode here, and clear demo timer
    opermodeTask = temp1
    //> sta DemoTimer
    demoTimer = temp1
    //> ldx #$17
    temp3 = 0x17
    //> lda #$00
    temp1 = 0x00
    do {
        //> InitScores:   sta ScoreAndCoinDisplay,x   ;clear player scores and coin displays
        scoreAndCoinDisplay[temp3] = temp1
        //> dex
        temp3 = (temp3 - 1) and 0xFF
        //> bpl InitScores
    } while ((temp3 and 0x80) == 0)
}

// Decompiled from GoContinue
fun goContinue(A: Int) {
    var areaNumber by MemoryByte(AreaNumber)
    var offscrAreanumber by MemoryByte(OffScr_AreaNumber)
    var offscrWorldnumber by MemoryByte(OffScr_WorldNumber)
    var worldNumber by MemoryByte(WorldNumber)
    //> GoContinue:   sta WorldNumber             ;start both players at the first area
    worldNumber = A
    //> sta OffScr_WorldNumber      ;of the previously saved world number
    offscrWorldnumber = A
    //> ldx #$00                    ;note that on power-up using this function
    //> stx AreaNumber              ;will make no difference
    areaNumber = 0x00
    //> stx OffScr_AreaNumber
    offscrAreanumber = 0x00
    //> rts
    return
}

// Decompiled from DrawMushroomIcon
fun drawMushroomIcon() {
    var temp0: Int = 0
    var temp1: Int = 0
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    val mushroomIconData by MemoryByteIndexed(MushroomIconData)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> DrawMushroomIcon:
    //> ldy #$07                ;read eight bytes to be read by transfer routine
    temp0 = 0x07
    do {
        //> IconDataRead: lda MushroomIconData,y  ;note that the default position is set for a
        //> sta VRAM_Buffer1-1,y    ;1-player game
        vramBuffer1[-1 + temp0] = mushroomIconData[temp0]
        //> dey
        temp0 = (temp0 - 1) and 0xFF
        //> bpl IconDataRead
    } while ((temp0 and 0x80) == 0)
    //> lda NumberOfPlayers     ;check number of players
    //> beq ExitIcon            ;if set to 1-player game, we're done
    temp1 = numberOfPlayers
    if (numberOfPlayers != 0) {
        //> lda #$24                ;otherwise, load blank tile in 1-player position
        temp1 = 0x24
        //> sta VRAM_Buffer1+3
        vramBuffer1[3] = temp1
        //> lda #$ce                ;then load shroom icon tile in 2-player position
        temp1 = 0xCE
        //> sta VRAM_Buffer1+5
        vramBuffer1[5] = temp1
    }
    //> ExitIcon:     rts
    return
}

// Decompiled from DemoEngine
fun demoEngine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var demoAction by MemoryByte(DemoAction)
    var demoActionTimer by MemoryByte(DemoActionTimer)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    val demoActionData by MemoryByteIndexed(DemoActionData)
    val demoTimingData by MemoryByteIndexed(DemoTimingData)
    //> DemoEngine:
    //> ldx DemoAction         ;load current demo action
    //> lda DemoActionTimer    ;load current action timer
    //> bne DoAction           ;if timer still counting down, skip
    temp0 = demoActionTimer
    temp1 = demoAction
    if (demoActionTimer == 0) {
        //> inx
        temp1 = (temp1 + 1) and 0xFF
        //> inc DemoAction         ;if expired, increment action, X, and
        demoAction = (demoAction + 1) and 0xFF
        //> sec                    ;set carry by default for demo over
        //> lda DemoTimingData-1,x ;get next timer
        temp0 = demoTimingData[-1 + temp1]
        //> sta DemoActionTimer    ;store as current timer
        demoActionTimer = temp0
        //> beq DemoOver           ;if timer already at zero, skip
        if (temp0 != 0) {
        } else {
            //> DemoOver: rts
            return
        }
    }
    //> DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
    temp0 = demoActionData[-1 + temp1]
    //> sta SavedJoypad1Bits
    savedJoypad1Bits = temp0
    //> dec DemoActionTimer    ;decrement action timer
    demoActionTimer = (demoActionTimer - 1) and 0xFF
    //> clc                    ;clear carry if demo still going
}

// Decompiled from VictoryMode
fun victoryMode() {
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var opermodeTask by MemoryByte(OperMode_Task)
    //> VictoryMode:
    //> jsr VictoryModeSubroutines  ;run victory mode subroutines
    victoryModeSubroutines()
    //> lda OperMode_Task           ;get current task of victory mode
    //> beq AutoPlayer              ;if on bridge collapse, skip enemy processing
    if (opermodeTask == 0) {
        //  goto AutoPlayer
        return
    }
    temp0 = opermodeTask
    if (opermodeTask != 0) {
        //> ldx #$00
        //> stx ObjectOffset            ;otherwise reset enemy object offset
        objectOffset = 0x00
        //> jsr EnemiesAndLoopsCore     ;and run enemy code
        enemiesAndLoopsCore(0x00)
    }
    //> AutoPlayer: jsr RelativePlayerPosition  ;get player's relative coordinates
    relativePlayerPosition()
    //> jmp PlayerGfxHandler        ;draw the player, then leave
}

// Decompiled from VictoryModeSubroutines
fun victoryModeSubroutines() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> VictoryModeSubroutines:
    //> lda OperMode_Task
    //> jsr JumpEngine
    when (opermodeTask) {
        0 -> {
            bridgeCollapse()
        }
        1 -> {
            setupVictoryMode()
        }
        2 -> {
            playerVictoryWalk()
        }
        3 -> {
            printVictoryMessages()
        }
        4 -> {
            playerEndWorld()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from SetupVictoryMode
fun setupVictoryMode() {
    var destinationPageLoc by MemoryByte(DestinationPageLoc)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    //> SetupVictoryMode:
    //> ldx ScreenRight_PageLoc  ;get page location of right side of screen
    //> inx                      ;increment to next page
    screenrightPageloc = (screenrightPageloc + 1) and 0xFF
    //> stx DestinationPageLoc   ;store here
    destinationPageLoc = screenrightPageloc
    //> lda #EndOfCastleMusic
    //> sta EventMusicQueue      ;play win castle music
    eventMusicQueue = EndOfCastleMusic
    //> jmp IncModeTask_B        ;jump to set next major task in victory mode
    //> IncModeTask_B: inc OperMode_Task  ;move onto next mode
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from PlayerVictoryWalk
fun playerVictoryWalk() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var destinationPageLoc by MemoryByte(DestinationPageLoc)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var scrollFractional by MemoryByte(ScrollFractional)
    var victoryWalkControl by MemoryByte(VictoryWalkControl)
    //> PlayerVictoryWalk:
    //> ldy #$00                ;set value here to not walk player by default
    //> sty VictoryWalkControl
    victoryWalkControl = 0x00
    //> lda Player_PageLoc      ;get player's page location
    //> cmp DestinationPageLoc  ;compare with destination page location
    //> bne PerformWalk         ;if page locations don't match, branch
    temp0 = playerPageloc
    temp1 = 0x00
    if (playerPageloc == destinationPageLoc) {
        //> lda Player_X_Position   ;otherwise get player's horizontal position
        temp0 = playerXPosition
        //> cmp #$60                ;compare with preset horizontal position
        //> bcs DontWalk            ;if still on other page, branch ahead
        if (!(temp0 >= 0x60)) {
        }
    }
    //> PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
    victoryWalkControl = (victoryWalkControl + 1) and 0xFF
    //> iny                     ;note Y will be used to walk the player
    temp1 = (temp1 + 1) and 0xFF
    //> DontWalk:    tya                     ;put contents of Y in A and
    //> jsr AutoControlPlayer   ;use A to move player to the right or not
    autoControlPlayer(temp1)
    //> lda ScreenLeft_PageLoc  ;check page location of left side of screen
    temp0 = screenleftPageloc
    //> cmp DestinationPageLoc  ;against set value here
    //> beq ExitVWalk           ;branch if equal to change modes if necessary
    if (temp0 != destinationPageLoc) {
        //> lda ScrollFractional
        temp0 = scrollFractional
        //> clc                     ;do fixed point math on fractional part of scroll
        //> adc #$80
        temp2 = temp0 + 0x80
        temp0 = temp2 and 0xFF
        //> sta ScrollFractional    ;save fractional movement amount
        scrollFractional = temp0
        //> lda #$01                ;set 1 pixel per frame
        temp0 = 0x01
        //> adc #$00                ;add carry from previous addition
        temp3 = temp0 + (if (temp2 > 0xFF) 1 else 0)
        temp0 = temp3 and 0xFF
        //> tay                     ;use as scroll amount
        //> jsr ScrollScreen        ;do sub to scroll the screen
        scrollScreen(temp0)
        //> jsr UpdScrollVar        ;do another sub to update screen and scroll variables
        updScrollVar()
        //> inc VictoryWalkControl  ;increment value to stay in this routine
        victoryWalkControl = (victoryWalkControl + 1) and 0xFF
    }
    //> ExitVWalk:   lda VictoryWalkControl  ;load value set here
    temp0 = victoryWalkControl
    //> beq IncModeTask_A       ;if zero, branch to change modes
    if (temp0 == 0) {
        //  goto IncModeTask_A
        return
    }
    if (temp0 != 0) {
        //> rts                     ;otherwise leave
        return
    } else {
        //> IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
        opermodeTask = (opermodeTask + 1) and 0xFF
    }
    //> ExitMsgs:      rts                           ;leave
    return
}

// Decompiled from PrintVictoryMessages
fun printVictoryMessages() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var opermodeTask by MemoryByte(OperMode_Task)
    var primaryMsgCounter by MemoryByte(PrimaryMsgCounter)
    var secondaryMsgCounter by MemoryByte(SecondaryMsgCounter)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    var worldEndTimer by MemoryByte(WorldEndTimer)
    var worldNumber by MemoryByte(WorldNumber)
    //> PrintVictoryMessages:
    //> lda SecondaryMsgCounter   ;load secondary message counter
    //> bne IncMsgCounter         ;if set, branch to increment message counters
    temp0 = secondaryMsgCounter
    if (secondaryMsgCounter == 0) {
        //> lda PrimaryMsgCounter     ;otherwise load primary message counter
        temp0 = primaryMsgCounter
        //> beq ThankPlayer           ;if set to zero, branch to print first message
        if (temp0 != 0) {
            //> cmp #$09                  ;if at 9 or above, branch elsewhere (this comparison
            //> bcs IncMsgCounter         ;is residual code, counter never reaches 9)
            if (!(temp0 >= 0x09)) {
                //> ldy WorldNumber           ;check world number
                //> cpy #World8
                //> bne MRetainerMsg          ;if not at world 8, skip to next part
                temp1 = worldNumber
                if (worldNumber == World8) {
                    //> cmp #$03                  ;check primary message counter again
                    //> bcc IncMsgCounter         ;if not at 3 yet (world 8 only), branch to increment
                    if (temp0 >= 0x03) {
                        //> sbc #$01                  ;otherwise subtract one
                        temp2 = temp0 - 0x01 - (if (temp0 >= 0x03) 0 else 1)
                        temp0 = temp2 and 0xFF
                        //> jmp ThankPlayer           ;and skip to next part
                    }
                } else {
                    //> MRetainerMsg:  cmp #$02                  ;check primary message counter
                    //> bcc IncMsgCounter         ;if not at 2 yet (world 1-7 only), branch
                    if (temp0 >= 0x02) {
                    }
                }
            }
        }
        //> ThankPlayer:   tay                       ;put primary message counter into Y
        //> bne SecondPartMsg         ;if counter nonzero, skip this part, do not print first message
        temp1 = temp0
        if (temp0 == 0) {
            //> lda CurrentPlayer         ;otherwise get player currently on the screen
            temp0 = currentPlayer
            //> beq EvalForMusic          ;if mario, branch
            if (temp0 != 0) {
                //> iny                       ;otherwise increment Y once for luigi and
                temp1 = (temp1 + 1) and 0xFF
                //> bne EvalForMusic          ;do an unconditional branch to the same place
                if (temp1 == 0) {
                }
            }
        }
        //> SecondPartMsg: iny                       ;increment Y to do world 8's message
        temp1 = (temp1 + 1) and 0xFF
        //> lda WorldNumber
        temp0 = worldNumber
        //> cmp #World8               ;check world number
        //> beq EvalForMusic          ;if at world 8, branch to next part
        if (temp0 != World8) {
            //> dey                       ;otherwise decrement Y for world 1-7's message
            temp1 = (temp1 - 1) and 0xFF
            //> cpy #$04                  ;if counter at 4 (world 1-7 only)
            //> bcs SetEndTimer           ;branch to set victory end timer
            if (!(temp1 >= 0x04)) {
                //> cpy #$03                  ;if counter at 3 (world 1-7 only)
                //> bcs IncMsgCounter         ;branch to keep counting
                if (!(temp1 >= 0x03)) {
                }
            }
        }
        //> EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
        //> bne PrintMsg              ;to print message only (note world 1-7 will only
        if (temp1 == 0x03) {
            //> lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
            temp0 = VictoryMusic
            //> sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
            eventMusicQueue = temp0
        }
        //> PrintMsg:      tya                       ;put primary message counter in A
        //> clc                       ;add $0c or 12 to counter thus giving an appropriate value,
        //> adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
        temp3 = temp1 + 0x0C
        temp0 = temp3 and 0xFF
        //> sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
        vramBufferAddrctrl = temp0
    }
    //> IncMsgCounter: lda SecondaryMsgCounter
    temp0 = secondaryMsgCounter
    //> clc
    //> adc #$04                      ;add four to secondary message counter
    temp4 = temp0 + 0x04
    temp0 = temp4 and 0xFF
    //> sta SecondaryMsgCounter
    secondaryMsgCounter = temp0
    //> lda PrimaryMsgCounter
    temp0 = primaryMsgCounter
    //> adc #$00                      ;add carry to primary message counter
    temp5 = temp0 + (if (temp4 > 0xFF) 1 else 0)
    temp0 = temp5 and 0xFF
    //> sta PrimaryMsgCounter
    primaryMsgCounter = temp0
    //> cmp #$07                      ;check primary counter one more time
    //> SetEndTimer:   bcc ExitMsgs                  ;if not reached value yet, branch to leave
    if (temp0 >= 0x07) {
        //> lda #$06
        temp0 = 0x06
        //> sta WorldEndTimer             ;otherwise set world end timer
        worldEndTimer = temp0
        //> IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
        opermodeTask = (opermodeTask + 1) and 0xFF
    }
    //> ExitMsgs:      rts                           ;leave
    return
}

// Decompiled from PlayerEndWorld
fun playerEndWorld() {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var levelNumber by MemoryByte(LevelNumber)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var worldEndTimer by MemoryByte(WorldEndTimer)
    var worldNumber by MemoryByte(WorldNumber)
    //> PlayerEndWorld:
    //> lda WorldEndTimer          ;check to see if world end timer expired
    //> bne EndExitOne             ;branch to leave if not
    temp0 = worldEndTimer
    if (worldEndTimer == 0) {
        //> ldy WorldNumber            ;check world number
        //> cpy #World8                ;if on world 8, player is done with game,
        //> bcs EndChkBButton          ;thus branch to read controller
        temp1 = worldNumber
        if (!(worldNumber >= World8)) {
            //> lda #$00
            temp0 = 0x00
            //> sta AreaNumber             ;otherwise initialize area number used as offset
            areaNumber = temp0
            //> sta LevelNumber            ;and level number control to start at area 1
            levelNumber = temp0
            //> sta OperMode_Task          ;initialize secondary mode of operation
            opermodeTask = temp0
            //> inc WorldNumber            ;increment world number to move onto the next world
            worldNumber = (worldNumber + 1) and 0xFF
            //> jsr LoadAreaPointer        ;get area address offset for the next area
            loadAreaPointer(temp0)
            //> inc FetchNewGameTimerFlag  ;set flag to load game timer from header
            fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
            //> lda #GameModeValue
            temp0 = GameModeValue
            //> sta OperMode               ;set mode of operation to game mode
            operMode = temp0
        }
    }
    //> EndExitOne:    rts                        ;and leave
    return
}

// Decompiled from FloateyNumbersRoutine
fun floateyNumbersRoutine(X: Int) {
    val altSprdataoffset by MemoryByteIndexed(Alt_SprDataOffset)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val floateyNumTileData by MemoryByteIndexed(FloateyNumTileData)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val floateynumTimer by MemoryByteIndexed(FloateyNum_Timer)
    val floateynumXPos by MemoryByteIndexed(FloateyNum_X_Pos)
    val floateynumYPos by MemoryByteIndexed(FloateyNum_Y_Pos)
    val scoreUpdateData by MemoryByteIndexed(ScoreUpdateData)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    //> EndExitOne:    rts                        ;and leave
    return
}

// Decompiled from ScreenRoutines
fun screenRoutines() {
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> ScreenRoutines:
    //> lda ScreenRoutineTask        ;run one of the following subroutines
    //> jsr JumpEngine
    when (screenRoutineTask) {
        0 -> {
            initScreen()
        }
        1 -> {
            setupIntermediate()
        }
        2 -> {
            writeTopStatusLine()
        }
        3 -> {
            writeBottomStatusLine()
        }
        4 -> {
            displayTimeUp()
        }
        5 -> {
            resetSpritesAndScreenTimer()
        }
        6 -> {
            displayIntermediate()
        }
        7 -> {
            resetSpritesAndScreenTimer()
        }
        8 -> {
            areaParserTaskControl()
        }
        9 -> {
            getAreaPalette()
        }
        10 -> {
            getBackgroundColor()
        }
        11 -> {
            getAlternatePalette1()
        }
        12 -> {
            drawTitleScreen()
        }
        13 -> {
            clearBuffersDrawIcon()
        }
        14 -> {
            writeTopScore()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from InitScreen
fun initScreen() {
    var temp0: Int = 0
    var operMode by MemoryByte(OperMode)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> InitScreen:
    //> jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
    moveAllSpritesOffscreen()
    //> jsr InitializeNameTables    ;and erase both name and attribute tables
    initializeNameTables()
    //> lda OperMode
    //> beq NextSubtask             ;if mode still 0, do not load
    if (operMode == 0) {
        //  goto NextSubtask
        return
    }
    temp0 = operMode
    if (operMode != 0) {
        //> ldx #$03                    ;into buffer pointer
        //> jmp SetVRAMAddr_A
        //> SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
        vramBufferAddrctrl = 0x03
    }
    //> NextSubtask:   jmp IncSubtask           ;move onto next task
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from SetupIntermediate
fun setupIntermediate() {
    var temp0: Int = 0
    var temp1: Int = 0
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var playerStatus by MemoryByte(PlayerStatus)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> SetupIntermediate:
    //> lda BackgroundColorCtrl  ;save current background color control
    //> pha                      ;and player status to stack
    push(backgroundColorCtrl)
    //> lda PlayerStatus
    //> pha
    push(playerStatus)
    //> lda #$00                 ;set background color to black
    //> sta PlayerStatus         ;and player status to not fiery
    playerStatus = 0x00
    //> lda #$02                 ;this is the ONLY time background color control
    //> sta BackgroundColorCtrl  ;is set to less than 4
    backgroundColorCtrl = 0x02
    //> jsr GetPlayerColors
    getPlayerColors()
    //> pla                      ;we only execute this routine for
    temp0 = pull()
    //> sta PlayerStatus         ;the intermediate lives display
    playerStatus = temp0
    //> pla                      ;and once we're done, we return bg
    temp1 = pull()
    //> sta BackgroundColorCtrl  ;color ctrl and player status from stack
    backgroundColorCtrl = temp1
    //> jmp IncSubtask           ;then move onto the next task
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from GetAreaPalette
fun getAreaPalette() {
    var areaType by MemoryByte(AreaType)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    val areaPalette by MemoryByteIndexed(AreaPalette)
    //> GetAreaPalette:
    //> ldy AreaType             ;select appropriate palette to load
    //> ldx AreaPalette,y        ;based on area type
    //> SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
    vramBufferAddrctrl = areaPalette[areaType]
    //> NextSubtask:   jmp IncSubtask           ;move onto next task
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from GetBackgroundColor
fun getBackgroundColor() {
    var temp0: Int = 0
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    val bgcolorctrlAddr by MemoryByteIndexed(BGColorCtrl_Addr)
    //> GetBackgroundColor:
    //> ldy BackgroundColorCtrl   ;check background color control
    //> beq NoBGColor             ;if not set, increment task and fetch palette
    temp0 = backgroundColorCtrl
    if (backgroundColorCtrl != 0) {
        //> lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
        //> sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, $0301 will not be read
        vramBufferAddrctrl = bgcolorctrlAddr[-4 + temp0]
    }
    //> NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    // Fall-through tail call to getPlayerColors
    getPlayerColors()
}

// Decompiled from GetPlayerColors
fun getPlayerColors() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var areaType by MemoryByte(AreaType)
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var currentPlayer by MemoryByte(CurrentPlayer)
    var playerStatus by MemoryByte(PlayerStatus)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val backgroundColors by MemoryByteIndexed(BackgroundColors)
    val playerColors by MemoryByteIndexed(PlayerColors)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> GetPlayerColors:
    //> ldx VRAM_Buffer1_Offset  ;get current buffer offset
    //> ldy #$00
    //> lda CurrentPlayer        ;check which player is on the screen
    //> beq ChkFiery
    temp0 = currentPlayer
    temp1 = vramBuffer1Offset
    temp2 = 0x00
    if (currentPlayer != 0) {
        //> ldy #$04                 ;load offset for luigi
        temp2 = 0x04
    }
    //> ChkFiery:      lda PlayerStatus         ;check player status
    temp0 = playerStatus
    //> cmp #$02
    //> bne StartClrGet          ;if fiery, load alternate offset for fiery player
    if (temp0 == 0x02) {
        //> ldy #$08
        temp2 = 0x08
    }
    //> StartClrGet:   lda #$03                 ;do four colors
    temp0 = 0x03
    //> sta $00
    memory[0x0] = temp0.toUByte()
    do {
        //> ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
        temp0 = playerColors[temp2]
        //> sta VRAM_Buffer1+3,x     ;in the buffer
        vramBuffer1[3 + temp1] = temp0
        //> iny
        temp2 = (temp2 + 1) and 0xFF
        //> inx
        temp1 = (temp1 + 1) and 0xFF
        //> dec $00
        memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
        //> bpl ClrGetLoop
    } while ((memory[0x0].toInt() and 0x80) == 0)
    //> ldx VRAM_Buffer1_Offset  ;load original offset from before
    temp1 = vramBuffer1Offset
    //> ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
    temp2 = backgroundColorCtrl
    //> bne SetBGColor           ;therefore use it as offset to background color
    if (temp2 == 0) {
        //> ldy AreaType             ;otherwise use area type bits from area offset as offset
        temp2 = areaType
    }
    //> SetBGColor:    lda BackgroundColors,y   ;to background color instead
    temp0 = backgroundColors[temp2]
    //> sta VRAM_Buffer1+3,x
    vramBuffer1[3 + temp1] = temp0
    //> lda #$3f                 ;set for sprite palette address
    temp0 = 0x3F
    //> sta VRAM_Buffer1,x       ;save to buffer
    vramBuffer1[temp1] = temp0
    //> lda #$10
    temp0 = 0x10
    //> sta VRAM_Buffer1+1,x
    vramBuffer1[1 + temp1] = temp0
    //> lda #$04                 ;write length byte to buffer
    temp0 = 0x04
    //> sta VRAM_Buffer1+2,x
    vramBuffer1[2 + temp1] = temp0
    //> lda #$00                 ;now the null terminator
    temp0 = 0x00
    //> sta VRAM_Buffer1+7,x
    vramBuffer1[7 + temp1] = temp0
    //> txa                      ;move the buffer pointer ahead 7 bytes
    //> clc                      ;in case we want to write anything else later
    //> adc #$07
    temp3 = temp1 + 0x07
    temp0 = temp3 and 0xFF
    //> SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
    vramBuffer1Offset = temp0
    //> rts
    return
}

// Decompiled from GetAlternatePalette1
fun getAlternatePalette1() {
    var temp0: Int = 0
    var areaStyle by MemoryByte(AreaStyle)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> GetAlternatePalette1:
    //> lda AreaStyle            ;check for mushroom level style
    //> cmp #$01
    //> bne NoAltPal
    if (!(areaStyle - 0x01 == 0)) {
        //  goto NoAltPal
        return
    }
    temp0 = areaStyle
    if (areaStyle == 0x01) {
        //> lda #$0b                 ;if found, load appropriate palette
        temp0 = 0x0B
        //> SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
        vramBufferAddrctrl = temp0
    }
    //> NoAltPal:      jmp IncSubtask           ;now onto the next task
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from WriteTopStatusLine
fun writeTopStatusLine() {
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> WriteTopStatusLine:
    //> lda #$00          ;select main status bar
    //> jsr WriteGameText ;output it
    writeGameText(0x00)
    //> jmp IncSubtask    ;onto the next task
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from WriteBottomStatusLine
fun writeBottomStatusLine() {
    var temp0: Int = 0
    var levelNumber by MemoryByte(LevelNumber)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    var worldNumber by MemoryByte(WorldNumber)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> WriteBottomStatusLine:
    //> jsr GetSBNybbles        ;write player's score and coin tally to screen
    getSBNybbles()
    //> ldx VRAM_Buffer1_Offset
    //> lda #$20                ;write address for world-area number on screen
    //> sta VRAM_Buffer1,x
    vramBuffer1[vramBuffer1Offset] = 0x20
    //> lda #$73
    //> sta VRAM_Buffer1+1,x
    vramBuffer1[1 + vramBuffer1Offset] = 0x73
    //> lda #$03                ;write length for it
    //> sta VRAM_Buffer1+2,x
    vramBuffer1[2 + vramBuffer1Offset] = 0x03
    //> ldy WorldNumber         ;first the world number
    //> iny
    worldNumber = (worldNumber + 1) and 0xFF
    //> tya
    //> sta VRAM_Buffer1+3,x
    vramBuffer1[3 + vramBuffer1Offset] = worldNumber
    //> lda #$28                ;next the dash
    //> sta VRAM_Buffer1+4,x
    vramBuffer1[4 + vramBuffer1Offset] = 0x28
    //> ldy LevelNumber         ;next the level number
    //> iny                     ;increment for proper number display
    levelNumber = (levelNumber + 1) and 0xFF
    //> tya
    //> sta VRAM_Buffer1+5,x
    vramBuffer1[5 + vramBuffer1Offset] = levelNumber
    //> lda #$00                ;put null terminator on
    //> sta VRAM_Buffer1+6,x
    vramBuffer1[6 + vramBuffer1Offset] = 0x00
    //> txa                     ;move the buffer offset up by 6 bytes
    //> clc
    //> adc #$06
    temp0 = vramBuffer1Offset + 0x06
    //> sta VRAM_Buffer1_Offset
    vramBuffer1Offset = temp0 and 0xFF
    //> jmp IncSubtask
    //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from DisplayTimeUp
fun displayTimeUp() {
    var temp0: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    //> DisplayTimeUp:
    //> lda GameTimerExpiredFlag  ;if game timer not expired, increment task
    //> beq NoTimeUp              ;control 2 tasks forward, otherwise, stay here
    if (gameTimerExpiredFlag == 0) {
        //  goto NoTimeUp
        return
    }
    temp0 = gameTimerExpiredFlag
    if (gameTimerExpiredFlag != 0) {
        //> lda #$00
        temp0 = 0x00
        //> sta GameTimerExpiredFlag  ;reset timer expiration flag
        gameTimerExpiredFlag = temp0
        //> lda #$02                  ;output time-up screen to buffer
        temp0 = 0x02
        //> jmp OutputInter
    } else {
        //> NoTimeUp: inc ScreenRoutineTask     ;increment control task 2 tasks forward
        screenRoutineTask = (screenRoutineTask + 1) and 0xFF
        //> jmp IncSubtask
    }
    //> OutputInter:   jsr WriteGameText
    writeGameText(temp0)
    //> jsr ResetScreenTimer
    resetScreenTimer()
    //> lda #$00
    temp0 = 0x00
    //> sta DisableScreenFlag        ;reenable screen output
    disableScreenFlag = temp0
    //> rts
    return
}

// Decompiled from DisplayIntermediate
fun displayIntermediate() {
    var temp0: Int = 0
    var temp1: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var disableIntermediate by MemoryByte(DisableIntermediate)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var screenTimer by MemoryByte(ScreenTimer)
    //> DisplayIntermediate:
    //> lda OperMode                 ;check primary mode of operation
    //> beq NoInter                  ;if in title screen mode, skip this
    temp0 = operMode
    if (operMode != 0) {
        //> cmp #GameOverModeValue       ;are we in game over mode?
        //> beq GameOverInter            ;if so, proceed to display game over screen
        if (temp0 - GameOverModeValue == 0) {
            //  goto GameOverInter
            return
        }
        if (temp0 != GameOverModeValue) {
            //> lda AltEntranceControl       ;otherwise check for mode of alternate entry
            temp0 = altEntranceControl
            //> bne NoInter                  ;and branch if found
            if (temp0 == 0) {
                //> ldy AreaType                 ;check if we are on castle level
                //> cpy #$03                     ;and if so, branch (possibly residual)
                //> beq PlayerInter
                temp1 = areaType
                if (areaType != 0x03) {
                    //> lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
                    temp0 = disableIntermediate
                    //> bne NoInter                  ;and jump to specific task, otherwise
                    if (temp0 == 0) {
                    } else {
                        //> NoInter:       lda #$08                     ;set for specific task and leave
                        temp0 = 0x08
                        //> sta ScreenRoutineTask
                        screenRoutineTask = temp0
                        //> rts
                        return
                        //> IncModeTask_B: inc OperMode_Task  ;move onto next mode
                        opermodeTask = (opermodeTask + 1) and 0xFF
                        //> rts
                        return
                    }
                }
                //> PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
                drawplayerIntermediate()
                //> lda #$01                     ;lives display, then output lives display to buffer
                temp0 = 0x01
                //> OutputInter:   jsr WriteGameText
                writeGameText(temp0)
                //> jsr ResetScreenTimer
                resetScreenTimer()
                //> lda #$00
                temp0 = 0x00
                //> sta DisableScreenFlag        ;reenable screen output
                disableScreenFlag = temp0
                //> rts
                return
            }
        }
        //> GameOverInter: lda #$12                     ;set screen timer
        temp0 = 0x12
        //> sta ScreenTimer
        screenTimer = temp0
        //> lda #$03                     ;output game over screen to buffer
        temp0 = 0x03
        //> jsr WriteGameText
        writeGameText(temp0)
        //> jmp IncModeTask_B
    }
    // Fall-through tail call to displayTimeUp
    displayTimeUp()
}

// Decompiled from AreaParserTaskControl
fun areaParserTaskControl() {
    var temp0: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var columnSets by MemoryByte(ColumnSets)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> AreaParserTaskControl:
    //> inc DisableScreenFlag     ;turn off screen
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    do {
        //> TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
        areaParserTaskHandler()
        //> lda AreaParserTaskNum     ;check number of tasks
        //> bne TaskLoop              ;if tasks still not all done, do another one
    } while (areaParserTaskNum != 0)
    //> dec ColumnSets            ;do we need to render more column sets?
    columnSets = (columnSets - 1) and 0xFF
    //> bpl OutputCol
    temp0 = areaParserTaskNum
    if ((columnSets and 0x80) != 0) {
        //> inc ScreenRoutineTask     ;if not, move on to the next task
        screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    }
    //> OutputCol: lda #$06                  ;set vram buffer to output rendered column set
    temp0 = 0x06
    //> sta VRAM_Buffer_AddrCtrl  ;on next NMI
    vramBufferAddrctrl = temp0
    //> rts
    return
}

// Decompiled from DrawTitleScreen
fun drawTitleScreen() {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var ppuAddress by MemoryByte(PPU_ADDRESS)
    var ppuData by MemoryByte(PPU_DATA)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
    vramBufferAddrctrl = A
    //> NoAltPal:      jmp IncSubtask           ;now onto the next task
    //> DrawTitleScreen:
    //> lda OperMode                 ;are we in title screen mode?
    //> bne IncModeTask_B            ;if not, exit
    temp0 = operMode
    if (operMode == 0) {
        //> lda #>TitleScreenDataOffset  ;load address $1ec0 into
        temp0 = 0
        //> sta PPU_ADDRESS              ;the vram address register
        ppuAddress = temp0
        //> lda #<TitleScreenDataOffset
        temp0 = 0
        //> sta PPU_ADDRESS
        ppuAddress = temp0
        //> lda #$03                     ;put address $0300 into
        temp0 = 0x03
        //> sta $01                      ;the indirect at $00
        memory[0x1] = temp0.toUByte()
        //> ldy #$00
        //> sty $00
        memory[0x0] = 0x00.toUByte()
        //> lda PPU_DATA                 ;do one garbage read
        temp0 = ppuData
        temp1 = 0x00
        do {
            //> OutputTScr: lda PPU_DATA                 ;get title screen from chr-rom
            temp0 = ppuData
            //> sta ($00),y                  ;store 256 bytes into buffer
            memory[readWord(0x0) + temp1] = temp0.toUByte()
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> bne ChkHiByte                ;if not past 256 bytes, do not increment
            if (temp1 == 0) {
                //> inc $01                      ;otherwise increment high byte of indirect
                memory[0x1] = ((memory[0x1].toInt() + 1) and 0xFF).toUByte()
            }
            //> ChkHiByte:  lda $01                      ;check high byte?
            temp0 = memory[0x1].toInt()
            //> cmp #$04                     ;at $0400?
            //> bne OutputTScr               ;if not, loop back and do another
            //> cpy #$3a                     ;check if offset points past end of data
            //> bcc OutputTScr               ;if not, loop back and do another
        } while (temp1 != 0x3A)
        while (true) {
            //> lda #$05                     ;set buffer transfer control to $0300,
            temp0 = 0x05
            //> jmp SetVRAMAddr_B            ;increment task and exit
        }
        //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
        screenRoutineTask = (screenRoutineTask + 1) and 0xFF
        //> rts
        return
    } else {
        //> IncModeTask_B: inc OperMode_Task  ;move onto next mode
        opermodeTask = (opermodeTask + 1) and 0xFF
        //> rts
        return
    }
}

// Decompiled from ClearBuffersDrawIcon
fun clearBuffersDrawIcon() {
    var temp0: Int = 0
    var temp1: Int = 0
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> ClearBuffersDrawIcon:
    //> lda OperMode               ;check game mode
    //> bne IncModeTask_B          ;if not title screen mode, leave
    if (!(operMode == 0)) {
        //  goto IncModeTask_B
        return
    }
    temp0 = operMode
    if (operMode == 0) {
        //> ldx #$00                   ;otherwise, clear buffer space
        temp1 = 0x00
        do {
            //> TScrClear:   sta VRAM_Buffer1-1,x
            vramBuffer1[-1 + temp1] = temp0
            //> sta VRAM_Buffer1-1+$100,x
            //> dex
            temp1 = (temp1 - 1) and 0xFF
            //> bne TScrClear
        } while (temp1 != 0)
        //> jsr DrawMushroomIcon       ;draw player select icon
        drawMushroomIcon()
        //> IncSubtask:  inc ScreenRoutineTask      ;move onto next task
        screenRoutineTask = (screenRoutineTask + 1) and 0xFF
        //> rts
        return
    } else {
        //> IncModeTask_B: inc OperMode_Task  ;move onto next mode
        opermodeTask = (opermodeTask + 1) and 0xFF
        //> rts
        return
    }
}

// Decompiled from WriteTopScore
fun writeTopScore() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> WriteTopScore:
    //> lda #$fa           ;run display routine to display top score on title
    //> jsr UpdateNumber
    updateNumber()
    //> IncModeTask_B: inc OperMode_Task  ;move onto next mode
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from WriteGameText
fun writeGameText(A: Int) {
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val gameText by MemoryByteIndexed(GameText)
    val gameTextOffsets by MemoryByteIndexed(GameTextOffsets)
    val luigiName by MemoryByteIndexed(LuigiName)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    val warpZoneNumbers by MemoryByteIndexed(WarpZoneNumbers)
    //> SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
    vramBuffer1Offset = A
    //> rts
    return
}

// Decompiled from ResetSpritesAndScreenTimer
fun resetSpritesAndScreenTimer() {
    var temp0: Int = 0
    var screenTimer by MemoryByte(ScreenTimer)
    //> ResetSpritesAndScreenTimer:
    //> lda ScreenTimer             ;check if screen timer has expired
    //> bne NoReset                 ;if not, branch to leave
    temp0 = screenTimer
    if (screenTimer == 0) {
        //> jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
        moveAllSpritesOffscreen()
    }
    //> NoReset: rts
    return
}

// Decompiled from ResetScreenTimer
fun resetScreenTimer() {
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var screenTimer by MemoryByte(ScreenTimer)
    //> ResetScreenTimer:
    //> lda #$07                    ;reset timer again
    //> sta ScreenTimer
    screenTimer = 0x07
    //> inc ScreenRoutineTask       ;move onto next task
    screenRoutineTask = (screenRoutineTask + 1) and 0xFF
    //> NoReset: rts
    return
}

// Decompiled from RenderAreaGraphics
fun renderAreaGraphics() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentntaddrHigh by MemoryByte(CurrentNTAddr_High)
    var currentntaddrLow by MemoryByte(CurrentNTAddr_Low)
    var vramBuffer2Offset by MemoryByte(VRAM_Buffer2_Offset)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    val attributeBuffer by MemoryByteIndexed(AttributeBuffer)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val metatilegraphicsHigh by MemoryByteIndexed(MetatileGraphics_High)
    val metatilegraphicsLow by MemoryByteIndexed(MetatileGraphics_Low)
    val vramBuffer2 by MemoryByteIndexed(VRAM_Buffer2)
    //> RenderAreaGraphics:
    //> lda CurrentColumnPos         ;store LSB of where we're at
    //> and #$01
    temp0 = currentColumnPos and 0x01
    //> sta $05
    memory[0x5] = temp0.toUByte()
    //> ldy VRAM_Buffer2_Offset      ;store vram buffer offset
    //> sty $00
    memory[0x0] = vramBuffer2Offset.toUByte()
    //> lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
    //> sta VRAM_Buffer2+1,y
    vramBuffer2[1 + vramBuffer2Offset] = currentntaddrLow
    //> lda CurrentNTAddr_High
    //> sta VRAM_Buffer2,y
    vramBuffer2[vramBuffer2Offset] = currentntaddrHigh
    //> lda #$9a                     ;store length byte of 26 here with d7 set
    //> sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
    vramBuffer2[2 + vramBuffer2Offset] = 0x9A
    //> lda #$00                     ;init attribute row
    //> sta $04
    memory[0x4] = 0x00.toUByte()
    //> tax
    temp1 = 0x00
    temp2 = vramBuffer2Offset
    do {
        //> DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
        memory[0x1] = temp1.toUByte()
        //> lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
        //> and #%11000000
        temp3 = metatileBuffer[temp1] and 0xC0
        //> sta $03                      ;store attribute table bits here
        memory[0x3] = temp3.toUByte()
        //> asl                          ;note that metatile format is:
        temp3 = (temp3 shl 1) and 0xFF
        //> rol                          ;%xx000000 - attribute table bits,
        temp3 = (temp3 shl 1) and 0xFE or if ((temp3 and 0x80) != 0) 1 else 0
        //> rol                          ;%00xxxxxx - metatile number
        temp3 = (temp3 shl 1) and 0xFE or if ((temp3 and 0x80) != 0) 1 else 0
        //> tay                          ;rotate bits to d1-d0 and use as offset here
        //> lda MetatileGraphics_Low,y   ;get address to graphics table from here
        //> sta $06
        memory[0x6] = (metatilegraphicsLow[temp3] and 0xFF).toUByte()
        //> lda MetatileGraphics_High,y
        //> sta $07
        memory[0x7] = (metatilegraphicsHigh[temp3] and 0xFF).toUByte()
        //> lda MetatileBuffer,x         ;get metatile number again
        //> asl                          ;multiply by 4 and use as tile offset
        //> asl
        //> sta $02
        memory[0x2] = ((((metatileBuffer[temp1] shl 1) and 0xFF) shl 1) and 0xFF).toUByte()
        //> lda AreaParserTaskNum        ;get current task number for level processing and
        //> and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
        temp4 = areaParserTaskNum and 0x01
        //> eor #%00000001               ;to get the correct column position in the metatile,
        temp5 = temp4 xor 0x01
        //> asl                          ;then add to the tile offset so we can draw either side
        temp5 = (temp5 shl 1) and 0xFF
        //> adc $02                      ;of the metatiles
        temp6 = temp5 + memory[0x2].toInt() + (if ((temp5 and 0x80) != 0) 1 else 0)
        //> tay
        //> ldx $00                      ;use vram buffer offset from before as X
        temp1 = memory[0x0].toInt()
        //> lda ($06),y
        //> sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
        vramBuffer2[3 + temp1] = memory[readWord(0x6) + (temp6 and 0xFF)].toInt()
        //> iny
        temp2 = temp6 and 0xFF
        temp2 = (temp2 + 1) and 0xFF
        //> lda ($06),y                  ;now get the second (bottom left or bottom right) and store
        //> sta VRAM_Buffer2+4,x
        vramBuffer2[4 + temp1] = memory[readWord(0x6) + temp2].toInt()
        //> ldy $04                      ;get current attribute row
        temp2 = memory[0x4].toInt()
        //> lda $05                      ;get LSB of current column where we're at, and
        //> bne RightCheck               ;branch if set (clear = left attrib, set = right)
        temp7 = memory[0x5].toInt()
        if (memory[0x5].toInt() == 0) {
            //> lda $01                      ;get current row we're rendering
            temp7 = memory[0x1].toInt()
            //> lsr                          ;branch if LSB set (clear = top left, set = bottom left)
            temp7 = temp7 shr 1
            //> bcs LLeft
            if ((temp7 and 0x01) == 0) {
                //> rol $03                      ;rotate attribute bits 3 to the left
                memory[0x3] = (((memory[0x3].toInt() shl 1) and 0xFE or if ((temp7 and 0x01) != 0) 1 else 0) and 0xFF).toUByte()
                //> rol $03                      ;thus in d1-d0, for upper left square
                memory[0x3] = (((memory[0x3].toInt() shl 1) and 0xFE or if ((memory[0x3].toInt() and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
                //> rol $03
                memory[0x3] = (((memory[0x3].toInt() shl 1) and 0xFE or if ((memory[0x3].toInt() and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
                //> jmp SetAttrib
            }
        } else {
            //> RightCheck: lda $01                      ;get LSB of current row we're rendering
            temp7 = memory[0x1].toInt()
            //> lsr                          ;branch if set (clear = top right, set = bottom right)
            temp7 = temp7 shr 1
            //> bcs NextMTRow
            if ((temp7 and 0x01) == 0) {
                //> lsr $03                      ;shift attribute bits 4 to the right
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03                      ;thus in d3-d2, for upper right square
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> jmp SetAttrib
                //> LLeft:      lsr $03                      ;shift attribute bits 2 to the right
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
                //> lsr $03                      ;thus in d5-d4 for lower left square
                memory[0x3] = ((memory[0x3].toInt() shr 1) and 0xFF).toUByte()
            }
            //> NextMTRow:  inc $04                      ;move onto next attribute row
            memory[0x4] = ((memory[0x4].toInt() + 1) and 0xFF).toUByte()
        }
        //> SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
        temp7 = attributeBuffer[temp2]
        //> ora $03                      ;if any, and put new bits, if any, onto
        temp8 = temp7 or memory[0x3].toInt()
        //> sta AttributeBuffer,y        ;the old, and store
        attributeBuffer[temp2] = temp8
        //> inc $00                      ;increment vram buffer offset by 2
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> inc $00
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> ldx $01                      ;get current gfx buffer row, and check for
        temp1 = memory[0x1].toInt()
        //> inx                          ;the bottom of the screen
        temp1 = (temp1 + 1) and 0xFF
        //> cpx #$0d
        //> bcc DrawMTLoop               ;if not there yet, loop back
    } while (!(temp1 >= 0x0D))
    //> ldy $00                      ;get current vram buffer offset, increment by 3
    temp2 = memory[0x0].toInt()
    //> iny                          ;(for name table address and length bytes)
    temp2 = (temp2 + 1) and 0xFF
    //> iny
    temp2 = (temp2 + 1) and 0xFF
    //> iny
    temp2 = (temp2 + 1) and 0xFF
    //> lda #$00
    temp7 = 0x00
    //> sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
    vramBuffer2[temp2] = temp7
    //> sty VRAM_Buffer2_Offset      ;store new buffer offset
    vramBuffer2Offset = temp2
    //> inc CurrentNTAddr_Low        ;increment name table address low
    currentntaddrLow = (currentntaddrLow + 1) and 0xFF
    //> lda CurrentNTAddr_Low        ;check current low byte
    temp7 = currentntaddrLow
    //> and #%00011111               ;if no wraparound, just skip this part
    temp9 = temp7 and 0x1F
    //> bne ExitDrawM
    if (!(temp9 == 0)) {
        //  goto ExitDrawM
        return
    }
    temp7 = temp9
    if (temp9 == 0) {
        //> lda #$80                     ;if wraparound occurs, make sure low byte stays
        temp7 = 0x80
        //> sta CurrentNTAddr_Low        ;just under the status bar
        currentntaddrLow = temp7
        //> lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
        temp7 = currentntaddrHigh
        //> eor #%00000100               ;to move onto the next appropriate name table
        temp10 = temp7 xor 0x04
        //> sta CurrentNTAddr_High
        currentntaddrHigh = temp10
    }
    //> ExitDrawM:  jmp SetVRAMCtrl              ;jump to set buffer to $0341 and leave
    //> SetVRAMCtrl: lda #$06
    temp7 = 0x06
    //> sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
    vramBufferAddrctrl = temp7
    //> rts
    return
}

// Decompiled from RenderAttributeTables
fun renderAttributeTables() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var currentntaddrHigh by MemoryByte(CurrentNTAddr_High)
    var currentntaddrLow by MemoryByte(CurrentNTAddr_Low)
    var vramBuffer2Offset by MemoryByte(VRAM_Buffer2_Offset)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    val attributeBuffer by MemoryByteIndexed(AttributeBuffer)
    val vramBuffer2 by MemoryByteIndexed(VRAM_Buffer2)
    //> RenderAttributeTables:
    //> lda CurrentNTAddr_Low    ;get low byte of next name table address
    //> and #%00011111           ;to be written to, mask out all but 5 LSB,
    temp0 = currentntaddrLow and 0x1F
    //> sec                      ;subtract four
    //> sbc #$04
    temp1 = temp0 - 0x04
    //> and #%00011111           ;mask out bits again and store
    temp2 = temp1 and 0xFF and 0x1F
    //> sta $01
    memory[0x1] = temp2.toUByte()
    //> lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
    //> bcs SetATHigh
    temp3 = currentntaddrHigh
    if (!(temp1 >= 0)) {
        //> eor #%00000100           ;otherwise invert d2
        temp4 = temp3 xor 0x04
    }
    //> SetATHigh:   and #%00000100           ;mask out all other bits
    temp5 = temp3 and 0x04
    //> ora #$23                 ;add $2300 to the high byte and store
    temp6 = temp5 or 0x23
    //> sta $00
    memory[0x0] = temp6.toUByte()
    //> lda $01                  ;get low byte - 4, divide by 4, add offset for
    temp3 = memory[0x1].toInt()
    //> lsr                      ;attribute table and store
    temp3 = temp3 shr 1
    //> lsr
    temp3 = temp3 shr 1
    //> adc #$c0                 ;we should now have the appropriate block of
    temp7 = temp3 + 0xC0 + (if ((temp3 and 0x01) != 0) 1 else 0)
    temp3 = temp7 and 0xFF
    //> sta $01                  ;attribute table in our temp address
    memory[0x1] = temp3.toUByte()
    //> ldx #$00
    //> ldy VRAM_Buffer2_Offset  ;get buffer offset
    temp8 = 0x00
    temp9 = vramBuffer2Offset
    do {
        //> AttribLoop:  lda $00
        temp3 = memory[0x0].toInt()
        //> sta VRAM_Buffer2,y       ;store high byte of attribute table address
        vramBuffer2[temp9] = temp3
        //> lda $01
        temp3 = memory[0x1].toInt()
        //> clc                      ;get low byte, add 8 because we want to start
        //> adc #$08                 ;below the status bar, and store
        temp10 = temp3 + 0x08
        temp3 = temp10 and 0xFF
        //> sta VRAM_Buffer2+1,y
        vramBuffer2[1 + temp9] = temp3
        //> sta $01                  ;also store in temp again
        memory[0x1] = temp3.toUByte()
        //> lda AttributeBuffer,x    ;fetch current attribute table byte and store
        temp3 = attributeBuffer[temp8]
        //> sta VRAM_Buffer2+3,y     ;in the buffer
        vramBuffer2[3 + temp9] = temp3
        //> lda #$01
        temp3 = 0x01
        //> sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
        vramBuffer2[2 + temp9] = temp3
        //> lsr
        temp3 = temp3 shr 1
        //> sta AttributeBuffer,x    ;clear current byte in attribute buffer
        attributeBuffer[temp8] = temp3
        //> iny                      ;increment buffer offset by 4 bytes
        temp9 = (temp9 + 1) and 0xFF
        //> iny
        temp9 = (temp9 + 1) and 0xFF
        //> iny
        temp9 = (temp9 + 1) and 0xFF
        //> iny
        temp9 = (temp9 + 1) and 0xFF
        //> inx                      ;increment attribute offset and check to see
        temp8 = (temp8 + 1) and 0xFF
        //> cpx #$07                 ;if we're at the end yet
        //> bcc AttribLoop
    } while (!(temp8 >= 0x07))
    //> sta VRAM_Buffer2,y       ;put null terminator at the end
    vramBuffer2[temp9] = temp3
    //> sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
    vramBuffer2Offset = temp9
    //> SetVRAMCtrl: lda #$06
    temp3 = 0x06
    //> sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
    vramBufferAddrctrl = temp3
    //> rts
    return
}

// Decompiled from ColorRotation
fun colorRotation() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaType by MemoryByte(AreaType)
    var colorRotateOffset by MemoryByte(ColorRotateOffset)
    var frameCounter by MemoryByte(FrameCounter)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val blankPalette by MemoryByteIndexed(BlankPalette)
    val colorRotatePalette by MemoryByteIndexed(ColorRotatePalette)
    val palette3Data by MemoryByteIndexed(Palette3Data)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> ColorRotation:
    //> lda FrameCounter         ;get frame counter
    //> and #$07                 ;mask out all but three LSB
    temp0 = frameCounter and 0x07
    //> bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
    temp1 = temp0
    if (temp0 == 0) {
        //> ldx VRAM_Buffer1_Offset  ;check vram buffer offset
        //> cpx #$31
        //> bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
        temp2 = vramBuffer1Offset
        if (!(vramBuffer1Offset >= 0x31)) {
            //> tay                      ;otherwise use frame counter's 3 LSB as offset here
            temp3 = temp1
            do {
                //> GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
                temp1 = blankPalette[temp3]
                //> sta VRAM_Buffer1,x       ;store it in the vram buffer
                vramBuffer1[temp2] = temp1
                //> inx                      ;increment offsets
                temp2 = (temp2 + 1) and 0xFF
                //> iny
                temp3 = (temp3 + 1) and 0xFF
                //> cpy #$08
                //> bcc GetBlankPal          ;do this until all bytes are copied
            } while (!(temp3 >= 0x08))
            //> ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
            temp2 = vramBuffer1Offset
            //> lda #$03
            temp1 = 0x03
            //> sta $00                  ;set counter here
            memory[0x0] = temp1.toUByte()
            //> lda AreaType             ;get area type
            temp1 = areaType
            //> asl                      ;multiply by 4 to get proper offset
            temp1 = (temp1 shl 1) and 0xFF
            //> asl
            temp1 = (temp1 shl 1) and 0xFF
            //> tay                      ;save as offset here
            temp3 = temp1
            do {
                //> GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
                temp1 = palette3Data[temp3]
                //> sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
                vramBuffer1[3 + temp2] = temp1
                //> iny
                temp3 = (temp3 + 1) and 0xFF
                //> inx
                temp2 = (temp2 + 1) and 0xFF
                //> dec $00                  ;decrement counter
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bpl GetAreaPal           ;do this until the palette is all copied
            } while ((memory[0x0].toInt() and 0x80) == 0)
            //> ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
            temp2 = vramBuffer1Offset
            //> ldy ColorRotateOffset    ;get color cycling offset
            temp3 = colorRotateOffset
            //> lda ColorRotatePalette,y
            temp1 = colorRotatePalette[temp3]
            //> sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
            vramBuffer1[4 + temp2] = temp1
            //> lda VRAM_Buffer1_Offset
            temp1 = vramBuffer1Offset
            //> clc                      ;add seven bytes to vram buffer offset
            //> adc #$07
            temp4 = temp1 + 0x07
            temp1 = temp4 and 0xFF
            //> sta VRAM_Buffer1_Offset
            vramBuffer1Offset = temp1
            //> inc ColorRotateOffset    ;increment color cycling offset
            colorRotateOffset = (colorRotateOffset + 1) and 0xFF
            //> lda ColorRotateOffset
            temp1 = colorRotateOffset
            //> cmp #$06                 ;check to see if it's still in range
            //> bcc ExitColorRot         ;if so, branch to leave
            if (temp1 >= 0x06) {
                //> lda #$00
                temp1 = 0x00
                //> sta ColorRotateOffset    ;otherwise, init to keep it in range
                colorRotateOffset = temp1
            }
        }
    }
    //> ExitColorRot: rts                      ;leave
    return
}

// Decompiled from RemoveCoin_Axe
fun removecoinAxe() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var areaType by MemoryByte(AreaType)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> RemoveCoin_Axe:
    //> ldy #$41                 ;set low byte so offset points to $0341
    //> lda #$03                 ;load offset for default blank metatile
    //> ldx AreaType             ;check area type
    //> bne WriteBlankMT         ;if not water type, use offset
    temp0 = 0x03
    temp1 = areaType
    temp2 = 0x41
    if (areaType == 0) {
        //> lda #$04                 ;otherwise load offset for blank metatile used in water
        temp0 = 0x04
    }
    //> WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
    putBlockMetatile(temp0, temp1, temp2)
    //> lda #$06
    temp0 = 0x06
    //> sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
    vramBufferAddrctrl = temp0
    //> rts
    return
}

// Decompiled from ReplaceBlockMetatile
fun replaceBlockMetatile(X: Int) {
    var A: Int = 0
    var blockResidualcounter by MemoryByte(Block_ResidualCounter)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    //> ReplaceBlockMetatile:
    //> jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
    writeBlockMetatile(A)
    //> inc Block_ResidualCounter ;increment unused counter (residual code)
    blockResidualcounter = (blockResidualcounter + 1) and 0xFF
    //> dec Block_RepFlag,x       ;decrement flag (residual code)
    blockRepflag[X] = (blockRepflag[X] - 1) and 0xFF
    //> rts                       ;leave
    return
}

// Decompiled from DestroyBlockMetatile
fun destroyBlockMetatile() {
    //> DestroyBlockMetatile:
    //> lda #$00       ;force blank metatile if branched/jumped to this point
    // Fall-through tail call to writeBlockMetatile
    writeBlockMetatile(0x00)
}

// Decompiled from WriteBlockMetatile
fun writeBlockMetatile(A: Int) {
    var X: Int = 0
    var temp0: Int = 0
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    //> WriteBlockMetatile:
    //> ldy #$03                ;load offset for blank metatile
    //> cmp #$00                ;check contents of A for blank metatile
    //> beq UseBOffset          ;branch if found (unconditional if branched from 8a6b)
    temp0 = 0x03
    if (A != 0) {
        //> ldy #$00                ;load offset for brick metatile w/ line
        temp0 = 0x00
        //> cmp #$58
        //> beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
        if (A != 0x58) {
            //> cmp #$51
            //> beq UseBOffset          ;use offset if metatile is breakable brick w/ line
            if (A != 0x51) {
                //> iny                     ;increment offset for brick metatile w/o line
                temp0 = (temp0 + 1) and 0xFF
                //> cmp #$5d
                //> beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
                if (A != 0x5D) {
                    //> cmp #$52
                    //> beq UseBOffset          ;use offset if metatile is breakable brick w/o line
                    if (A != 0x52) {
                        //> iny                     ;if any other metatile, increment offset for empty block
                        temp0 = (temp0 + 1) and 0xFF
                    }
                }
            }
        }
    }
    //> UseBOffset:  tya                     ;put Y in A
    //> ldy VRAM_Buffer1_Offset ;get vram buffer offset
    temp0 = vramBuffer1Offset
    //> iny                     ;move onto next byte
    temp0 = (temp0 + 1) and 0xFF
    //> jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
    putBlockMetatile(temp0, X, temp0)
    // Fall-through tail call to moveVOffset
    moveVOffset(temp0)
}

// Decompiled from MoveVOffset
fun moveVOffset(Y: Int) {
    var A: Int = 0
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    //> SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
    vramBuffer1Offset = A
    //> rts
    return
}

// Decompiled from PutBlockMetatile
fun putBlockMetatile(A: Int, X: Int, Y: Int) {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    //> PutBlockMetatile:
    //> stx $00               ;store control bit from SprDataOffset_Ctrl
    memory[0x0] = X.toUByte()
    //> sty $01               ;store vram buffer offset for next byte
    memory[0x1] = Y.toUByte()
    //> asl
    A = (A shl 1) and 0xFF
    //> asl                   ;multiply A by four and use as X
    A = (A shl 1) and 0xFF
    //> tax
    //> ldy #$20              ;load high byte for name table 0
    //> lda $06               ;get low byte of block buffer pointer
    //> cmp #$d0              ;check to see if we're on odd-page block buffer
    //> bcc SaveHAdder        ;if not, use current high byte
    temp0 = memory[0x6].toInt()
    temp1 = A
    temp2 = 0x20
    if (memory[0x6].toInt() >= 0xD0) {
        //> ldy #$24              ;otherwise load high byte for name table 1
        temp2 = 0x24
    }
    //> SaveHAdder: sty $03               ;save high byte here
    memory[0x3] = temp2.toUByte()
    //> and #$0f              ;mask out high nybble of block buffer pointer
    temp3 = temp0 and 0x0F
    //> asl                   ;multiply by 2 to get appropriate name table low byte
    temp3 = (temp3 shl 1) and 0xFF
    //> sta $04               ;and then store it here
    memory[0x4] = temp3.toUByte()
    //> lda #$00
    temp0 = 0x00
    //> sta $05               ;initialize temp high byte
    memory[0x5] = temp0.toUByte()
    //> lda $02               ;get vertical high nybble offset used in block buffer routine
    temp0 = memory[0x2].toInt()
    //> clc
    //> adc #$20              ;add 32 pixels for the status bar
    temp4 = temp0 + 0x20
    temp0 = temp4 and 0xFF
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> rol $05               ;shift and rotate d7 onto d0 and d6 into carry
    memory[0x5] = (((memory[0x5].toInt() shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> rol $05               ;shift and rotate d6 onto d0 and d5 into carry
    memory[0x5] = (((memory[0x5].toInt() shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0) and 0xFF).toUByte()
    //> adc $04               ;add low byte of name table and carry to vertical high nybble
    temp5 = temp0 + memory[0x4].toInt() + (if ((memory[0x5].toInt() and 0x80) != 0) 1 else 0)
    temp0 = temp5 and 0xFF
    //> sta $04               ;and store here
    memory[0x4] = temp0.toUByte()
    //> lda $05               ;get whatever was in d7 and d6 of vertical high nybble
    temp0 = memory[0x5].toInt()
    //> adc #$00              ;add carry
    temp6 = temp0 + (if (temp5 > 0xFF) 1 else 0)
    temp0 = temp6 and 0xFF
    //> clc
    //> adc $03               ;then add high byte of name table
    temp7 = temp0 + memory[0x3].toInt()
    temp0 = temp7 and 0xFF
    //> sta $05               ;store here
    memory[0x5] = temp0.toUByte()
    //> ldy $01               ;get vram buffer offset to be used
    temp2 = memory[0x1].toInt()
    // Fall-through tail call to remBridge
    remBridge(temp1, temp2)
}

// Decompiled from RemBridge
fun remBridge(X: Int, Y: Int) {
    var temp0: Int = 0
    val blockGfxData by MemoryByteIndexed(BlockGfxData)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> RemBridge:  lda BlockGfxData,x    ;write top left and top right
    //> sta VRAM_Buffer1+2,y  ;tile numbers into first spot
    vramBuffer1[2 + Y] = blockGfxData[X]
    //> lda BlockGfxData+1,x
    //> sta VRAM_Buffer1+3,y
    vramBuffer1[3 + Y] = blockGfxData[1 + X]
    //> lda BlockGfxData+2,x  ;write bottom left and bottom
    //> sta VRAM_Buffer1+7,y  ;right tiles numbers into
    vramBuffer1[7 + Y] = blockGfxData[2 + X]
    //> lda BlockGfxData+3,x  ;second spot
    //> sta VRAM_Buffer1+8,y
    vramBuffer1[8 + Y] = blockGfxData[3 + X]
    //> lda $04
    //> sta VRAM_Buffer1,y    ;write low byte of name table
    vramBuffer1[Y] = memory[0x4].toInt()
    //> clc                   ;into first slot as read
    //> adc #$20              ;add 32 bytes to value
    temp0 = memory[0x4].toInt() + 0x20
    //> sta VRAM_Buffer1+5,y  ;write low byte of name table
    vramBuffer1[5 + Y] = temp0 and 0xFF
    //> lda $05               ;plus 32 bytes into second slot
    //> sta VRAM_Buffer1-1,y  ;write high byte of name
    vramBuffer1[-1 + Y] = memory[0x5].toInt()
    //> sta VRAM_Buffer1+4,y  ;table address to both slots
    vramBuffer1[4 + Y] = memory[0x5].toInt()
    //> lda #$02
    //> sta VRAM_Buffer1+1,y  ;put length of 2 in
    vramBuffer1[1 + Y] = 0x02
    //> sta VRAM_Buffer1+6,y  ;both slots
    vramBuffer1[6 + Y] = 0x02
    //> lda #$00
    //> sta VRAM_Buffer1+9,y  ;put null terminator at end
    vramBuffer1[9 + Y] = 0x00
    //> ldx $00               ;get offset control bit here
    //> rts                   ;and leave
    return
}

// Decompiled from JumpEngine
fun jumpEngine(A: Int) {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    //> JumpEngine:
    //> asl          ;shift bit from contents of A
    A = (A shl 1) and 0xFF
    //> tay
    //> pla          ;pull saved return address from stack
    temp0 = pull()
    //> sta $04      ;save to indirect
    memory[0x4] = temp0.toUByte()
    //> pla
    temp1 = pull()
    //> sta $05
    memory[0x5] = temp1.toUByte()
    //> iny
    A = (A + 1) and 0xFF
    //> lda ($04),y  ;load pointer from indirect
    //> sta $06      ;note that if an RTS is performed in next routine
    memory[0x6] = memory[readWord(0x4) + A].toInt().toUByte()
    //> iny          ;it will return to the execution before the sub
    A = (A + 1) and 0xFF
    //> lda ($04),y  ;that called this routine
    //> sta $07
    memory[0x7] = memory[readWord(0x4) + A].toInt().toUByte()
    //> jmp ($06)    ;jump to the address we loaded
}

// Decompiled from InitializeNameTables
fun initializeNameTables() {
    var temp0: Int = 0
    var temp1: Int = 0
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    val ppuStatus by MemoryByteIndexed(PPU_STATUS)
    //> InitializeNameTables:
    //> lda PPU_STATUS            ;reset flip-flop
    //> lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
    //> ora #%00010000            ;set sprites for first 4k and background for second 4k
    temp0 = mirrorPpuCtrlReg1 or 0x10
    //> and #%11110000            ;clear rest of lower nybble, leave higher alone
    temp1 = temp0 and 0xF0
    //> jsr WritePPUReg1
    writePPUReg1(temp1)
    //> lda #$24                  ;set vram address to start of name table 1
    //> jsr WriteNTAddr
    writeNTAddr(0x24)
    //> lda #$20                  ;and then set it to name table 0
    // Fall-through tail call to writeNTAddr
    writeNTAddr(0x20)
}

// Decompiled from WriteNTAddr
fun writeNTAddr(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var horizontalScroll by MemoryByte(HorizontalScroll)
    var ppuAddress by MemoryByte(PPU_ADDRESS)
    var ppuData by MemoryByte(PPU_DATA)
    var vramBuffer1 by MemoryByte(VRAM_Buffer1)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    var verticalScroll by MemoryByte(VerticalScroll)
    //> WriteNTAddr:  sta PPU_ADDRESS
    ppuAddress = A
    //> lda #$00
    //> sta PPU_ADDRESS
    ppuAddress = 0x00
    //> ldx #$04                  ;clear name table with blank tile #24
    //> ldy #$c0
    //> lda #$24
    temp0 = 0x04
    temp1 = 0xC0
    do {
        while (temp0 == 0) {
            //> dex
            temp0 = (temp0 - 1) and 0xFF
            //> bne InitNTLoop
        }
    } while (temp0 != 0)
    //> ldy #64                   ;now to clear the attribute table (with zero this time)
    temp1 = 0x40
    //> txa
    //> sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
    vramBuffer1Offset = temp0
    //> sta VRAM_Buffer1          ;init vram buffer 1
    vramBuffer1 = temp0
    do {
        //> InitATLoop:   sta PPU_DATA
        ppuData = temp0
        //> dey
        temp1 = (temp1 - 1) and 0xFF
        //> bne InitATLoop
    } while (temp1 != 0)
    //> sta HorizontalScroll      ;reset scroll variables
    horizontalScroll = temp0
    //> sta VerticalScroll
    verticalScroll = temp0
    //> jmp InitScroll            ;initialize scroll registers to zero
}

// Decompiled from ReadJoypads
fun readJoypads() {
    var temp0: Int = 0
    var joypadPort by MemoryByte(JOYPAD_PORT)
    //> ReadJoypads:
    //> lda #$01               ;reset and clear strobe of joypad ports
    //> sta JOYPAD_PORT
    joypadPort = 0x01
    //> lsr
    //> tax                    ;start with joypad 1's port
    //> sta JOYPAD_PORT
    joypadPort = 0x01 shr 1
    //> jsr ReadPortBits
    readPortBits(0x01 shr 1, 0x01 shr 1)
    //> inx                    ;increment for joypad 2's port
    temp0 = 0x01 shr 1
    temp0 = (temp0 + 1) and 0xFF
    // Fall-through tail call to readPortBits
    readPortBits(0x01 shr 1, temp0)
}

// Decompiled from ReadPortBits
fun readPortBits(A: Int, X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    val joypadPort by MemoryByteIndexed(JOYPAD_PORT)
    val joypadBitMask by MemoryByteIndexed(JoypadBitMask)
    val savedJoypadBits by MemoryByteIndexed(SavedJoypadBits)
    //> ReadPortBits: ldy #$08
    temp0 = 0x08
    do {
        //> PortLoop:     pha                    ;push previous bit onto stack
        push(A)
        //> lda JOYPAD_PORT,x      ;read current bit on joypad port
        //> sta $00                ;check d1 and d0 of port output
        memory[0x0] = (joypadPort[X] and 0xFF).toUByte()
        //> lsr                    ;this is necessary on the old
        //> ora $00                ;famicom systems in japan
        temp1 = joypadPort[X] shr 1 or memory[0x0].toInt()
        //> lsr
        temp1 = temp1 shr 1
        //> pla                    ;read bits from stack
        temp2 = pull()
        //> rol                    ;rotate bit from carry flag
        temp2 = (temp2 shl 1) and 0xFE or if ((temp1 and 0x01) != 0) 1 else 0
        //> dey
        temp0 = (temp0 - 1) and 0xFF
        //> bne PortLoop           ;count down bits left
    } while (temp0 != 0)
    //> sta SavedJoypadBits,x  ;save controller status here always
    savedJoypadBits[X] = temp2
    //> pha
    push(temp2)
    //> and #%00110000         ;check for select or start
    temp3 = temp2 and 0x30
    //> and JoypadBitMask,x    ;if neither saved state nor current state
    temp4 = temp3 and joypadBitMask[X]
    //> beq Save8Bits          ;have any of these two set, branch
    temp5 = temp4
    if (temp4 != 0) {
        //> pla
        temp5 = pull()
        //> and #%11001111         ;otherwise store without select
        temp6 = temp5 and 0xCF
        //> sta SavedJoypadBits,x  ;or start bits and leave
        savedJoypadBits[X] = temp6
        //> rts
        return
    } else {
        //> Save8Bits:    pla
        temp5 = pull()
        //> sta JoypadBitMask,x    ;save with all bits in another place and leave
        joypadBitMask[X] = temp5
        //> rts
        return
    }
}

// Decompiled from UpdateScreen
fun updateScreen() {
    var A: Int = 0
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var ppuAddress by MemoryByte(PPU_ADDRESS)
    var ppuData by MemoryByte(PPU_DATA)
    val ppuStatus by MemoryByteIndexed(PPU_STATUS)
    //> WriteBufferToScreen:
    //> sta PPU_ADDRESS           ;store high byte of vram address
    ppuAddress = A
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda ($00),y               ;load next byte (second)
    //> sta PPU_ADDRESS           ;store low byte of vram address
    ppuAddress = memory[readWord(0x0) + Y].toInt()
    //> iny
    Y = (Y + 1) and 0xFF
    //> lda ($00),y               ;load next byte (third)
    //> asl                       ;shift to left and save in stack
    //> pha
    push((memory[readWord(0x0) + Y].toInt() shl 1) and 0xFF)
    //> lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
    //> ora #%00000100            ;set ppu to increment by 32 by default
    temp0 = mirrorPpuCtrlReg1 or 0x04
    //> bcs SetupWrites           ;if d7 of third byte was clear, ppu will
    temp1 = temp0
    if ((memory[readWord(0x0) + Y].toInt() and 0x80) == 0) {
        //> and #%11111011            ;only increment by 1
        temp2 = temp1 and 0xFB
    }
    //> SetupWrites:   jsr WritePPUReg1          ;write to register
    writePPUReg1(temp1)
    //> pla                       ;pull from stack and shift to left again
    temp1 = pull()
    //> asl
    temp1 = (temp1 shl 1) and 0xFF
    //> bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
    if ((temp1 and 0x80) != 0) {
        //> ora #%00000010            ;otherwise set d1 and increment Y
        temp3 = temp1 or 0x02
        //> iny
        Y = (Y + 1) and 0xFF
    }
    //> GetLength:     lsr                       ;shift back to the right to get proper length
    temp1 = temp1 shr 1
    //> lsr                       ;note that d1 will now be in carry
    temp1 = temp1 shr 1
    //> tax
    temp4 = temp1
    do {
        //> OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
        if ((temp1 and 0x01) == 0) {
            //> iny                       ;otherwise increment Y to load next byte
            Y = (Y + 1) and 0xFF
        }
        //> RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
        temp1 = memory[readWord(0x0) + Y].toInt()
        //> sta PPU_DATA
        ppuData = temp1
        //> dex                       ;done writing?
        temp4 = (temp4 - 1) and 0xFF
        //> bne OutputToVRAM
    } while (temp4 != 0)
    //> sec
    //> tya
    //> adc $00                   ;add end length plus one to the indirect at $00
    temp5 = Y + memory[0x0].toInt() + 1
    temp1 = temp5 and 0xFF
    //> sta $00                   ;to allow this routine to read another set of updates
    memory[0x0] = temp1.toUByte()
    //> lda #$00
    temp1 = 0x00
    //> adc $01
    temp6 = temp1 + memory[0x1].toInt() + (if (temp5 > 0xFF) 1 else 0)
    temp1 = temp6 and 0xFF
    //> sta $01
    memory[0x1] = temp1.toUByte()
    //> lda #$3f                  ;sets vram address to $3f00
    temp1 = 0x3F
    //> sta PPU_ADDRESS
    ppuAddress = temp1
    //> lda #$00
    temp1 = 0x00
    //> sta PPU_ADDRESS
    ppuAddress = temp1
    //> sta PPU_ADDRESS           ;then reinitializes it for some reason
    ppuAddress = temp1
    //> sta PPU_ADDRESS
    ppuAddress = temp1
    //> UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
    temp4 = ppuStatus[0]
    //> ldy #$00                  ;load first byte from indirect as a pointer
    //> lda ($00),y
    temp1 = memory[readWord(0x0)].toInt()
    //> bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
    // Fall-through tail call to initScroll
    initScroll(temp1)
}

// Decompiled from InitScroll
fun initScroll(A: Int) {
    var ppuScrollReg by MemoryByte(PPU_SCROLL_REG)
    //> InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
    ppuScrollReg = A
    //> sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
    ppuScrollReg = A
    //> rts
    return
}

// Decompiled from WritePPUReg1
fun writePPUReg1(A: Int) {
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var ppuCtrlReg1 by MemoryByte(PPU_CTRL_REG1)
    //> WritePPUReg1:
    //> sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
    ppuCtrlReg1 = A
    //> sta Mirror_PPU_CTRL_REG1  ;and its mirror
    mirrorPpuCtrlReg1 = A
    //> rts
    return
}

// Decompiled from PrintStatusBarNumbers
fun printStatusBarNumbers(A: Int) {
    //> PrintStatusBarNumbers:
    //> sta $00            ;store player-specific offset
    memory[0x0] = A.toUByte()
    //> jsr OutputNumbers  ;use first nybble to print the coin display
    outputNumbers(A)
    //> lda $00            ;move high nybble to low
    //> lsr                ;and print to score display
    //> lsr
    //> lsr
    //> lsr
    // Fall-through tail call to outputNumbers
    outputNumbers(memory[0x0].toInt() shr 1 shr 1 shr 1 shr 1)
}

// Decompiled from OutputNumbers
fun outputNumbers(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val displayDigits by MemoryByteIndexed(DisplayDigits)
    val statusBarData by MemoryByteIndexed(StatusBarData)
    val statusBarOffset by MemoryByteIndexed(StatusBarOffset)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> OutputNumbers:
    //> clc                      ;add 1 to low nybble
    //> adc #$01
    temp0 = A + 0x01
    //> and #%00001111           ;mask out high nybble
    temp1 = temp0 and 0xFF and 0x0F
    //> cmp #$06
    //> bcs ExitOutputN
    temp2 = temp1
    if (!(temp1 >= 0x06)) {
        //> pha                      ;save incremented value to stack for now and
        push(temp2)
        //> asl                      ;shift to left and use as offset
        temp2 = (temp2 shl 1) and 0xFF
        //> tay
        //> ldx VRAM_Buffer1_Offset  ;get current buffer pointer
        //> lda #$20                 ;put at top of screen by default
        temp2 = 0x20
        //> cpy #$00                 ;are we writing top score on title screen?
        //> bne SetupNums
        temp3 = vramBuffer1Offset
        temp4 = temp2
        if (temp2 == 0x00) {
            //> lda #$22                 ;if so, put further down on the screen
            temp2 = 0x22
        }
        //> SetupNums:   sta VRAM_Buffer1,x
        vramBuffer1[temp3] = temp2
        //> lda StatusBarData,y      ;write low vram address and length of thing
        temp2 = statusBarData[temp4]
        //> sta VRAM_Buffer1+1,x     ;we're printing to the buffer
        vramBuffer1[1 + temp3] = temp2
        //> lda StatusBarData+1,y
        temp2 = statusBarData[1 + temp4]
        //> sta VRAM_Buffer1+2,x
        vramBuffer1[2 + temp3] = temp2
        //> sta $03                  ;save length byte in counter
        memory[0x3] = temp2.toUByte()
        //> stx $02                  ;and buffer pointer elsewhere for now
        memory[0x2] = temp3.toUByte()
        //> pla                      ;pull original incremented value from stack
        temp2 = pull()
        //> tax
        //> lda StatusBarOffset,x    ;load offset to value we want to write
        temp2 = statusBarOffset[temp2]
        //> sec
        //> sbc StatusBarData+1,y    ;subtract from length byte we read before
        temp5 = temp2 - statusBarData[1 + temp4]
        temp2 = temp5 and 0xFF
        //> tay                      ;use value as offset to display digits
        //> ldx $02
        temp3 = memory[0x2].toInt()
        temp4 = temp2
        do {
            //> DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
            temp2 = displayDigits[temp4]
            //> sta VRAM_Buffer1+3,x
            vramBuffer1[3 + temp3] = temp2
            //> inx
            temp3 = (temp3 + 1) and 0xFF
            //> iny
            temp4 = (temp4 + 1) and 0xFF
            //> dec $03                  ;do this until all the digits are written
            memory[0x3] = ((memory[0x3].toInt() - 1) and 0xFF).toUByte()
            //> bne DigitPLoop
        } while (memory[0x3].toInt() != 0)
        //> lda #$00                 ;put null terminator at end
        temp2 = 0x00
        //> sta VRAM_Buffer1+3,x
        vramBuffer1[3 + temp3] = temp2
        //> inx                      ;increment buffer pointer by 3
        temp3 = (temp3 + 1) and 0xFF
        //> inx
        temp3 = (temp3 + 1) and 0xFF
        //> inx
        temp3 = (temp3 + 1) and 0xFF
        //> stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
        vramBuffer1Offset = temp3
    }
    //> ExitOutputN: rts
    return
}

// Decompiled from DigitsMathRoutine
fun digitsMathRoutine(Y: Int) {
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var operMode by MemoryByte(OperMode)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val displayDigits by MemoryByteIndexed(DisplayDigits)
    //> DigitsMathRoutine:
    //> lda OperMode              ;check mode of operation
    //> cmp #TitleScreenModeValue
    //> beq EraseDMods            ;if in title screen mode, branch to lock score
    temp0 = operMode
    if (operMode != TitleScreenModeValue) {
        //> ldx #$05
        temp1 = 0x05
        while (!flagN) {
            //> cmp #10
            //> bcs CarryOne              ;if digit greater than $09, branch to add
            if (temp0 >= 0x0A) {
                //  goto CarryOne
                return
            }
            if (!(temp0 >= 0x0A)) {
                do {
                    //> AddModLoop: lda DigitModifier,x       ;load digit amount to increment
                    temp0 = digitModifier[temp1]
                    //> clc
                    //> adc DisplayDigits,y       ;add to current digit
                    temp2 = temp0 + displayDigits[Y]
                    temp0 = temp2 and 0xFF
                    //> bmi BorrowOne             ;if result is a negative number, branch to subtract
                    //> StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
                    displayDigits[Y] = temp0
                    //> dey                       ;move onto next digits in score or game timer
                    Y = (Y - 1) and 0xFF
                    //> dex                       ;and digit amounts to increment
                    temp1 = (temp1 - 1) and 0xFF
                    //> bpl AddModLoop            ;loop back if we're not done yet
                } while ((temp1 and 0x80) == 0)
            }
        }
    }
    //> EraseDMods: lda #$00                  ;store zero here
    temp0 = 0x00
    //> ldx #$06                  ;start with the last digit
    temp1 = 0x06
    do {
        //> EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
        digitModifier[-1 + temp1] = temp0
        //> dex
        temp1 = (temp1 - 1) and 0xFF
        //> bpl EraseMLoop            ;do this until they're all reset, then leave
    } while ((temp1 and 0x80) == 0)
    //> rts
    return
}

// Decompiled from UpdateTopScore
fun updateTopScore() {
    //> UpdateTopScore:
    //> ldx #$05          ;start with mario's score
    //> jsr TopScoreCheck
    topScoreCheck(0x05)
    //> ldx #$0b          ;now do luigi's score
    // Fall-through tail call to topScoreCheck
    topScoreCheck(0x0B)
}

// Decompiled from TopScoreCheck
fun topScoreCheck(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val playerScoreDisplay by MemoryByteIndexed(PlayerScoreDisplay)
    val topScoreDisplay by MemoryByteIndexed(TopScoreDisplay)
    //> TopScoreCheck:
    //> ldy #$05                 ;start with the lowest digit
    //> sec
    temp0 = 0x05
    do {
        //> GetScoreDiff: lda PlayerScoreDisplay,x ;subtract each player digit from each high score digit
        //> sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
        temp1 = playerScoreDisplay[X] - topScoreDisplay[temp0]
        //> dex                      ;any player digit, borrow will be set until a subsequent
        X = (X - 1) and 0xFF
        //> dey                      ;subtraction clears it (player digit is higher than top)
        temp0 = (temp0 - 1) and 0xFF
        //> bpl GetScoreDiff
    } while ((temp0 and 0x80) == 0)
    //> bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
    temp2 = temp1 and 0xFF
    if (temp1 >= 0) {
        //> inx                      ;increment X and Y once to the start of the score
        X = (X + 1) and 0xFF
        //> iny
        temp0 = (temp0 + 1) and 0xFF
        do {
            //> CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
            temp2 = playerScoreDisplay[X]
            //> sta TopScoreDisplay,y
            topScoreDisplay[temp0] = temp2
            //> inx
            X = (X + 1) and 0xFF
            //> iny
            temp0 = (temp0 + 1) and 0xFF
            //> cpy #$06                 ;do this until we have stored them all
            //> bcc CopyScore
        } while (!(temp0 >= 0x06))
    }
    //> NoTopSc:      rts
    return
}

// Decompiled from InitializeGame
fun initializeGame(A: Int) {
    var temp0: Int = 0
    var demoTimer by MemoryByte(DemoTimer)
    val soundMemory by MemoryByteIndexed(SoundMemory)
    //> InitializeGame:
    //> ldy #$6f              ;clear all memory as in initialization procedure,
    //> jsr InitializeMemory  ;but this time, clear only as far as $076f
    initializeMemory(0x6F)
    //> ldy #$1f
    temp0 = 0x1F
    do {
        //> ClrSndLoop:  sta SoundMemory,y     ;clear out memory used
        soundMemory[temp0] = A
        //> dey                   ;by the sound engines
        temp0 = (temp0 - 1) and 0xFF
        //> bpl ClrSndLoop
    } while ((temp0 and 0x80) == 0)
    //> lda #$18              ;set demo timer
    //> sta DemoTimer
    demoTimer = 0x18
    //> jsr LoadAreaPointer
    loadAreaPointer(0x18)
    // Fall-through tail call to initializeArea
    initializeArea()
}

// Decompiled from InitializeArea
fun initializeArea() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var blockBufferColumnPos by MemoryByte(BlockBufferColumnPos)
    var columnSets by MemoryByte(ColumnSets)
    var currentntaddrHigh by MemoryByte(CurrentNTAddr_High)
    var currentntaddrLow by MemoryByte(CurrentNTAddr_Low)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var entrancePage by MemoryByte(EntrancePage)
    var halfwayPage by MemoryByte(HalfwayPage)
    var levelNumber by MemoryByte(LevelNumber)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var worldNumber by MemoryByte(WorldNumber)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val timers by MemoryByteIndexed(Timers)
    //> InitializeArea:
    //> ldy #$4b                 ;clear all memory again, only as far as $074b
    //> jsr InitializeMemory     ;this is only necessary if branching from
    initializeMemory(0x4B)
    //> ldx #$21
    //> lda #$00
    temp0 = 0x21
    temp1 = 0x4B
    do {
        //> ClrTimersLoop: sta Timers,x             ;clear out memory between
        timers[temp0] = 0x00
        //> dex                      ;$0780 and $07a1
        temp0 = (temp0 - 1) and 0xFF
        //> bpl ClrTimersLoop
    } while ((temp0 and 0x80) == 0)
    //> lda HalfwayPage
    //> ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
    temp1 = altEntranceControl
    //> beq StartPage
    temp2 = halfwayPage
    if (temp1 != 0) {
        //> lda EntrancePage         ;otherwise use saved entry page number here
        temp2 = entrancePage
    }
    //> StartPage:     sta ScreenLeft_PageLoc   ;set as value here
    screenleftPageloc = temp2
    //> sta CurrentPageLoc       ;also set as current page
    currentPageLoc = temp2
    //> sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
    backloadingFlag = temp2
    //> jsr GetScreenPosition    ;get pixel coordinates for screen borders
    getScreenPosition()
    //> ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
    temp1 = 0x20
    //> and #%00000001           ;otherwise use $2080, this address used later as name table
    temp3 = temp2 and 0x01
    //> beq SetInitNTHigh        ;address for rendering of game area
    temp2 = temp3
    if (temp3 != 0) {
        //> ldy #$24
        temp1 = 0x24
    }
    //> SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
    currentntaddrHigh = temp1
    //> ldy #$80
    temp1 = 0x80
    //> sty CurrentNTAddr_Low
    currentntaddrLow = temp1
    //> asl                      ;store LSB of page number in high nybble
    temp2 = (temp2 shl 1) and 0xFF
    //> asl                      ;of block buffer column position
    temp2 = (temp2 shl 1) and 0xFF
    //> asl
    temp2 = (temp2 shl 1) and 0xFF
    //> asl
    temp2 = (temp2 shl 1) and 0xFF
    //> sta BlockBufferColumnPos
    blockBufferColumnPos = temp2
    //> dec AreaObjectLength     ;set area object lengths for all empty
    areaObjectLength[0] = (areaObjectLength[0] - 1) and 0xFF
    //> dec AreaObjectLength+1
    areaObjectLength[1] = (areaObjectLength[1] - 1) and 0xFF
    //> dec AreaObjectLength+2
    areaObjectLength[2] = (areaObjectLength[2] - 1) and 0xFF
    //> lda #$0b                 ;set value for renderer to update 12 column sets
    temp2 = 0x0B
    //> sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
    columnSets = temp2
    //> jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
    getAreaDataAddrs()
    //> lda PrimaryHardMode      ;check to see if primary hard mode has been activated
    temp2 = primaryHardMode
    //> bne SetSecHard           ;if so, activate the secondary no matter where we're at
    if (temp2 == 0) {
        //> lda WorldNumber          ;otherwise check world number
        temp2 = worldNumber
        //> cmp #World5              ;if less than 5, do not activate secondary
        //> bcc CheckHalfway
        if (temp2 >= World5) {
            //> bne SetSecHard           ;if not equal to, then world > 5, thus activate
            if (temp2 == World5) {
                //> lda LevelNumber          ;otherwise, world 5, so check level number
                temp2 = levelNumber
                //> cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
                //> bcc CheckHalfway
                if (temp2 >= Level3) {
                }
            }
        }
    }
    //> SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 5-3 and beyond
    secondaryHardMode = (secondaryHardMode + 1) and 0xFF
    //> CheckHalfway:  lda HalfwayPage
    temp2 = halfwayPage
    //> beq DoneInitArea
    if (temp2 != 0) {
        //> lda #$02                 ;if halfway page set, overwrite start position from header
        temp2 = 0x02
        //> sta PlayerEntranceCtrl
        playerEntranceCtrl = temp2
    }
    //> DoneInitArea:  lda #Silence             ;silence music
    temp2 = Silence
    //> sta AreaMusicQueue
    areaMusicQueue = temp2
    //> lda #$01                 ;disable screen output
    temp2 = 0x01
    //> sta DisableScreenFlag
    disableScreenFlag = temp2
    //> inc OperMode_Task        ;increment one of the modes
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from PrimaryGameSetup
fun primaryGameSetup() {
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var numberofLives by MemoryByte(NumberofLives)
    var offscrNumberoflives by MemoryByte(OffScr_NumberofLives)
    var playerSize by MemoryByte(PlayerSize)
    //> PrimaryGameSetup:
    //> lda #$01
    //> sta FetchNewGameTimerFlag   ;set flag to load game timer from header
    fetchNewGameTimerFlag = 0x01
    //> sta PlayerSize              ;set player's size to small
    playerSize = 0x01
    //> lda #$02
    //> sta NumberofLives           ;give each player three lives
    numberofLives = 0x02
    //> sta OffScr_NumberofLives
    offscrNumberoflives = 0x02
    // Fall-through tail call to secondaryGameSetup
    secondaryGameSetup()
}

// Decompiled from SecondaryGameSetup
fun secondaryGameSetup() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var balPlatformAlignment by MemoryByte(BalPlatformAlignment)
    var disableIntermediate by MemoryByte(DisableIntermediate)
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    val defaultSprOffsets by MemoryByteIndexed(DefaultSprOffsets)
    val sprDataOffset by MemoryByteIndexed(SprDataOffset)
    val sprShuffleAmt by MemoryByteIndexed(SprShuffleAmt)
    val sprite0Data by MemoryByteIndexed(Sprite0Data)
    val spriteData by MemoryByteIndexed(Sprite_Data)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> SecondaryGameSetup:
    //> lda #$00
    //> sta DisableScreenFlag     ;enable screen output
    disableScreenFlag = 0x00
    //> tay
    temp0 = 0x00
    do {
        //> ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
        vramBuffer1[-1 + temp0] = 0x00
        //> iny
        temp0 = (temp0 + 1) and 0xFF
        //> bne ClearVRLoop
    } while (temp0 != 0)
    //> sta GameTimerExpiredFlag  ;clear game timer exp flag
    gameTimerExpiredFlag = 0x00
    //> sta DisableIntermediate   ;clear skip lives display flag
    disableIntermediate = 0x00
    //> sta BackloadingFlag       ;clear value here
    backloadingFlag = 0x00
    //> lda #$ff
    //> sta BalPlatformAlignment  ;initialize balance platform assignment flag
    balPlatformAlignment = 0xFF
    //> lda ScreenLeft_PageLoc    ;get left side page location
    //> lsr Mirror_PPU_CTRL_REG1  ;shift LSB of ppu register #1 mirror out
    mirrorPpuCtrlReg1 = mirrorPpuCtrlReg1 shr 1
    //> and #$01                  ;mask out all but LSB of page location
    temp1 = screenleftPageloc and 0x01
    //> ror                       ;rotate LSB of page location into carry then onto mirror
    temp1 = temp1 shr 1 or if ((mirrorPpuCtrlReg1 and 0x01) != 0) 0x80 else 0
    //> rol Mirror_PPU_CTRL_REG1  ;this is to set the proper PPU name table
    mirrorPpuCtrlReg1 = (mirrorPpuCtrlReg1 shl 1) and 0xFE or if ((temp1 and 0x01) != 0) 1 else 0
    //> jsr GetAreaMusic          ;load proper music into queue
    getAreaMusic()
    //> lda #$38                  ;load sprite shuffle amounts to be used later
    //> sta SprShuffleAmt+2
    sprShuffleAmt[2] = 0x38
    //> lda #$48
    //> sta SprShuffleAmt+1
    sprShuffleAmt[1] = 0x48
    //> lda #$58
    //> sta SprShuffleAmt
    sprShuffleAmt[0] = 0x58
    //> ldx #$0e                  ;load default OAM offsets into $06e4-$06f2
    temp2 = 0x0E
    do {
        //> ShufAmtLoop: lda DefaultSprOffsets,x
        //> sta SprDataOffset,x
        sprDataOffset[temp2] = defaultSprOffsets[temp2]
        //> dex                       ;do this until they're all set
        temp2 = (temp2 - 1) and 0xFF
        //> bpl ShufAmtLoop
    } while ((temp2 and 0x80) == 0)
    //> ldy #$03                  ;set up sprite #0
    temp0 = 0x03
    do {
        //> ISpr0Loop:   lda Sprite0Data,y
        //> sta Sprite_Data,y
        spriteData[temp0] = sprite0Data[temp0]
        //> dey
        temp0 = (temp0 - 1) and 0xFF
        //> bpl ISpr0Loop
    } while ((temp0 and 0x80) == 0)
    //> jsr DoNothing2            ;these jsrs doesn't do anything useful
    doNothing2()
    //> jsr DoNothing1
    doNothing1()
    //> inc Sprite0HitDetectFlag  ;set sprite #0 check flag
    sprite0HitDetectFlag = (sprite0HitDetectFlag + 1) and 0xFF
    //> inc OperMode_Task         ;increment to next task
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from InitializeMemory
fun initializeMemory(Y: Int): Int {
    var Y: Int = Y
    var temp0: Int = 0
    //> InitializeMemory:
    //> ldx #$07          ;set initial high byte to $0700-$07ff
    //> lda #$00          ;set initial low byte to start of page (at $00 of page)
    //> sta $06
    memory[0x6] = 0x00.toUByte()
    temp0 = 0x07
    while ((temp0 and 0x80) == 0) {
        //> InitPageLoop: stx $07
        memory[0x7] = temp0.toUByte()
        //> InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
        //> bne InitByte      ;if not, go ahead anyway
        //> cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
        //> bcs SkipByte      ;if so, skip write
        //> InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
        memory[readWord(0x6) + Y] = 0x00.toUByte()
        //> SkipByte:     dey
        Y = (Y - 1) and 0xFF
        //> cpy #$ff          ;do this until all bytes in page have been erased
        //> bne InitByteLoop
        //> dex               ;go onto the next page
        temp0 = (temp0 - 1) and 0xFF
        //> bpl InitPageLoop  ;do this until all pages of memory have been erased
    }
    //> rts
    return A
}

// Decompiled from GetAreaMusic
fun getAreaMusic() {
    var temp0: Int = 0
    var temp1: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var operMode by MemoryByte(OperMode)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    val musicSelectData by MemoryByteIndexed(MusicSelectData)
    //> GetAreaMusic:
    //> lda OperMode           ;if in title screen mode, leave
    //> beq ExitGetM
    temp0 = operMode
    if (operMode != 0) {
        //> lda AltEntranceControl ;check for specific alternate mode of entry
        temp0 = altEntranceControl
        //> cmp #$02               ;if found, branch without checking starting position
        //> beq ChkAreaType        ;from area object data header
        if (temp0 != 0x02) {
            //> ldy #$05               ;select music for pipe intro scene by default
            //> lda PlayerEntranceCtrl ;check value from level header for certain values
            temp0 = playerEntranceCtrl
            //> cmp #$06
            //> beq StoreMusic         ;load music for pipe intro scene if header
            temp1 = 0x05
            if (temp0 != 0x06) {
                //> cmp #$07               ;start position either value $06 or $07
                //> beq StoreMusic
                if (temp0 != 0x07) {
                }
            }
        }
        //> ChkAreaType: ldy AreaType           ;load area type as offset for music bit
        temp1 = areaType
        //> lda CloudTypeOverride
        temp0 = cloudTypeOverride
        //> beq StoreMusic         ;check for cloud type override
        if (temp0 != 0) {
            //> ldy #$04               ;select music for cloud type level if found
            temp1 = 0x04
        }
        //> StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
        temp0 = musicSelectData[temp1]
        //> sta AreaMusicQueue     ;store in queue and leave
        areaMusicQueue = temp0
    }
    //> ExitGetM:    rts
    return
}

// Decompiled from Entrance_GameTimerSetup
fun entranceGametimersetup() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var blockYPosition by MemoryByte(Block_Y_Position)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var gameTimerSetting by MemoryByte(GameTimerSetting)
    var halfwayPage by MemoryByte(HalfwayPage)
    var joypadOverride by MemoryByte(JoypadOverride)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    val altYPosOffset by MemoryByteIndexed(AltYPosOffset)
    val gameTimerData by MemoryByteIndexed(GameTimerData)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    val playerBGPriorityData by MemoryByteIndexed(PlayerBGPriorityData)
    val playerstartingXPos by MemoryByteIndexed(PlayerStarting_X_Pos)
    val playerstartingYPos by MemoryByteIndexed(PlayerStarting_Y_Pos)
    //> Entrance_GameTimerSetup:
    //> lda ScreenLeft_PageLoc      ;set current page for area objects
    //> sta Player_PageLoc          ;as page location for player
    playerPageloc = screenleftPageloc
    //> lda #$28                    ;store value here
    //> sta VerticalForceDown       ;for fractional movement downwards if necessary
    verticalForceDown = 0x28
    //> lda #$01                    ;set high byte of player position and
    //> sta PlayerFacingDir         ;set facing direction so that player faces right
    playerFacingDir = 0x01
    //> sta Player_Y_HighPos
    playerYHighpos = 0x01
    //> lda #$00                    ;set player state to on the ground by default
    //> sta Player_State
    playerState = 0x00
    //> dec Player_CollisionBits    ;initialize player's collision bits
    playerCollisionbits = (playerCollisionbits - 1) and 0xFF
    //> ldy #$00                    ;initialize halfway page
    //> sty HalfwayPage
    halfwayPage = 0x00
    //> lda AreaType                ;check area type
    //> bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
    temp0 = areaType
    temp1 = 0x00
    if (areaType == 0) {
        //> iny
        temp1 = (temp1 + 1) and 0xFF
    }
    //> ChkStPos: sty SwimmingFlag
    swimmingFlag = temp1
    //> ldx PlayerEntranceCtrl      ;get starting position loaded from header
    //> ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
    temp1 = altEntranceControl
    //> beq SetStPos
    temp2 = playerEntranceCtrl
    if (temp1 != 0) {
        //> cpy #$01
        //> beq SetStPos
        if (temp1 != 0x01) {
            //> ldx AltYPosOffset-2,y       ;if not 0 or 1, override $0710 with new offset in X
            temp2 = altYPosOffset[-2 + temp1]
        }
    }
    //> SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
    temp0 = playerstartingXPos[temp1]
    //> sta Player_X_Position       ;and vertical positions for the player, using
    playerXPosition = temp0
    //> lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
    temp0 = playerstartingYPos[temp2]
    //> sta Player_Y_Position       ;or value that overwrote $0710 as offset for vertical
    playerYPosition = temp0
    //> lda PlayerBGPriorityData,x
    temp0 = playerBGPriorityData[temp2]
    //> sta Player_SprAttrib        ;set player sprite attributes using offset in X
    playerSprattrib = temp0
    //> jsr GetPlayerColors         ;get appropriate player palette
    getPlayerColors()
    //> ldy GameTimerSetting        ;get timer control value from header
    temp1 = gameTimerSetting
    //> beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
    if (temp1 != 0) {
        //> lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
        temp0 = fetchNewGameTimerFlag
        //> beq ChkOverR                ;old game timer setting
        if (temp0 != 0) {
            //> lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
            temp0 = gameTimerData[temp1]
            //> sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
            gameTimerDisplay[0] = temp0
            //> lda #$01
            temp0 = 0x01
            //> sta GameTimerDisplay+2      ;set last digit of game timer to 1
            gameTimerDisplay[2] = temp0
            //> lsr
            temp0 = temp0 shr 1
            //> sta GameTimerDisplay+1      ;set second digit of game timer
            gameTimerDisplay[1] = temp0
            //> sta FetchNewGameTimerFlag   ;clear flag for game timer reset
            fetchNewGameTimerFlag = temp0
            //> sta StarInvincibleTimer     ;clear star mario timer
            starInvincibleTimer = temp0
        }
    }
    //> ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
    temp1 = joypadOverride
    //> beq ChkSwimE
    if (temp1 != 0) {
        //> lda #$03                    ;set player state to climbing
        temp0 = 0x03
        //> sta Player_State
        playerState = temp0
        //> ldx #$00                    ;set offset for first slot, for block object
        temp2 = 0x00
        //> jsr InitBlock_XY_Pos
        initblockXyPos(temp2)
        //> lda #$f0                    ;set vertical coordinate for block object
        temp0 = 0xF0
        //> sta Block_Y_Position
        blockYPosition = temp0
        //> ldx #$05                    ;set offset in X for last enemy object buffer slot
        temp2 = 0x05
        //> ldy #$00                    ;set offset in Y for object coordinates used earlier
        temp1 = 0x00
        //> jsr Setup_Vine              ;do a sub to grow vine
        setupVine(temp2, temp1)
    }
    //> ChkSwimE: ldy AreaType                ;if level not water-type,
    temp1 = areaType
    //> bne SetPESub                ;skip this subroutine
    if (temp1 == 0) {
        //> jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
        setupBubble(temp2)
    }
    //> SetPESub: lda #$07                    ;set to run player entrance subroutine
    temp0 = 0x07
    //> sta GameEngineSubroutine    ;on the next frame of game engine
    gameEngineSubroutine = temp0
    //> rts
    return
}

// Decompiled from PlayerLoseLife
fun playerLoseLife() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var halfwayPage by MemoryByte(HalfwayPage)
    var levelNumber by MemoryByte(LevelNumber)
    var numberofLives by MemoryByte(NumberofLives)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerSize by MemoryByte(PlayerSize)
    var playerStatus by MemoryByte(PlayerStatus)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    var timerControl by MemoryByte(TimerControl)
    var worldNumber by MemoryByte(WorldNumber)
    val halfwayPageNybbles by MemoryByteIndexed(HalfwayPageNybbles)
    //> PlayerLoseLife:
    //> inc DisableScreenFlag    ;disable screen and sprite 0 check
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> lda #$00
    //> sta Sprite0HitDetectFlag
    sprite0HitDetectFlag = 0x00
    //> lda #Silence             ;silence music
    //> sta EventMusicQueue
    eventMusicQueue = Silence
    //> dec NumberofLives        ;take one life from player
    numberofLives = (numberofLives - 1) and 0xFF
    //> bpl StillInGame          ;if player still has lives, branch
    temp0 = Silence
    if ((numberofLives and 0x80) != 0) {
        //> lda #$00
        temp0 = 0x00
        //> sta OperMode_Task        ;initialize mode task,
        opermodeTask = temp0
        //> lda #GameOverModeValue   ;switch to game over mode
        temp0 = GameOverModeValue
        //> sta OperMode             ;and leave
        operMode = temp0
        //> rts
        return
    } else {
        //> StillInGame: lda WorldNumber          ;multiply world number by 2 and use
        temp0 = worldNumber
        //> asl                      ;as offset
        temp0 = (temp0 shl 1) and 0xFF
        //> tax
        //> lda LevelNumber          ;if in area -3 or -4, increment
        temp0 = levelNumber
        //> and #$02                 ;offset by one byte, otherwise
        temp1 = temp0 and 0x02
        //> beq GetHalfway           ;leave offset alone
        temp0 = temp1
        temp2 = temp0
        if (temp1 != 0) {
            //> inx
            temp2 = (temp2 + 1) and 0xFF
        }
    }
    //> GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
    //> lda LevelNumber          ;check area number's LSB
    temp0 = levelNumber
    //> lsr
    temp0 = temp0 shr 1
    //> tya                      ;if in area -2 or -4, use lower nybble
    //> bcs MaskHPNyb
    temp0 = halfwayPageNybbles[temp2]
    temp3 = halfwayPageNybbles[temp2]
    if ((temp0 and 0x01) == 0) {
        //> lsr                      ;move higher nybble to lower if area
        temp0 = temp0 shr 1
        //> lsr                      ;number is -1 or -3
        temp0 = temp0 shr 1
        //> lsr
        temp0 = temp0 shr 1
        //> lsr
        temp0 = temp0 shr 1
    }
    //> MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
    temp4 = temp0 and 0x0F
    //> cmp ScreenLeft_PageLoc
    //> beq SetHalfway           ;left side of screen must be at the halfway page,
    if (temp4 - screenleftPageloc == 0) {
        //  goto SetHalfway
        return
    }
    temp0 = temp4
    if (temp4 != screenleftPageloc) {
        //> bcc SetHalfway           ;otherwise player must start at the
        if (!(temp4 >= screenleftPageloc)) {
            //  goto SetHalfway
            return
        }
        if (temp4 >= screenleftPageloc) {
            //> lda #$00                 ;beginning of the level
            temp0 = 0x00
        }
    }
    //> SetHalfway:  sta HalfwayPage          ;store as halfway page for player
    halfwayPage = temp0
    //> jsr TransposePlayers     ;switch players around if 2-player game
    transposePlayers()
    //> jmp ContinueGame         ;continue the game
    //> ContinueGame:
    //> jsr LoadAreaPointer       ;update level pointer with
    loadAreaPointer(temp0)
    //> lda #$01                  ;actual world and area numbers, then
    temp0 = 0x01
    //> sta PlayerSize            ;reset player's size, status, and
    playerSize = temp0
    //> inc FetchNewGameTimerFlag ;set game timer flag to reload
    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
    //> lda #$00                  ;game timer from header
    temp0 = 0x00
    //> sta TimerControl          ;also set flag for timers to count again
    timerControl = temp0
    //> sta PlayerStatus
    playerStatus = temp0
    //> sta GameEngineSubroutine  ;reset task for game core
    gameEngineSubroutine = temp0
    //> sta OperMode_Task         ;set modes and leave
    opermodeTask = temp0
    //> lda #$01                  ;if in game over mode, switch back to
    temp0 = 0x01
    //> sta OperMode              ;game mode, because game is still on
    operMode = temp0
    //> GameIsOn:  rts
    return
}

// Decompiled from GameOverMode
fun gameOverMode() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> GameOverMode:
    //> lda OperMode_Task
    //> jsr JumpEngine
    when (opermodeTask) {
        0 -> {
            setupGameOver()
        }
        1 -> {
            screenRoutines()
        }
        2 -> {
            runGameOver()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from SetupGameOver
fun setupGameOver() {
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var opermodeTask by MemoryByte(OperMode_Task)
    var screenRoutineTask by MemoryByte(ScreenRoutineTask)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    //> SetupGameOver:
    //> lda #$00                  ;reset screen routine task control for title screen, game,
    //> sta ScreenRoutineTask     ;and game over modes
    screenRoutineTask = 0x00
    //> sta Sprite0HitDetectFlag  ;disable sprite 0 check
    sprite0HitDetectFlag = 0x00
    //> lda #GameOverMusic
    //> sta EventMusicQueue       ;put game over music in secondary queue
    eventMusicQueue = GameOverMusic
    //> inc DisableScreenFlag     ;disable screen output
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> inc OperMode_Task         ;set secondary mode to 1
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> rts
    return
}

// Decompiled from RunGameOver
fun runGameOver() {
    var temp0: Int = 0
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var savedJoypad1Bits by MemoryByte(SavedJoypad1Bits)
    var screenTimer by MemoryByte(ScreenTimer)
    //> RunGameOver:
    //> lda #$00              ;reenable screen
    //> sta DisableScreenFlag
    disableScreenFlag = 0x00
    //> lda SavedJoypad1Bits  ;check controller for start pressed
    //> and #Start_Button
    temp0 = savedJoypad1Bits and Start_Button
    //> bne TerminateGame
    if (!(temp0 == 0)) {
        //  goto TerminateGame
        return
    } else {
        //> lda ScreenTimer       ;if not pressed, wait for
        //> bne GameIsOn          ;screen timer to expire
        if (!(screenTimer == 0)) {
            //  goto GameIsOn
            return
        }
    }
    //> GameIsOn:  rts
    return
}

// Decompiled from TerminateGame
fun terminateGame() {
    var temp0: Int = 0
    var continueWorld by MemoryByte(ContinueWorld)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var operMode by MemoryByte(OperMode)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerSize by MemoryByte(PlayerSize)
    var playerStatus by MemoryByte(PlayerStatus)
    var screenTimer by MemoryByte(ScreenTimer)
    var timerControl by MemoryByte(TimerControl)
    var worldNumber by MemoryByte(WorldNumber)
    //> TerminateGame:
    //> lda #Silence          ;silence music
    //> sta EventMusicQueue
    eventMusicQueue = Silence
    //> jsr TransposePlayers  ;check if other player can keep
    transposePlayers()
    //> bcc ContinueGame      ;going, and do so if possible
    if (!(flagC)) {
        //  goto ContinueGame
        return
    }
    temp0 = Silence
    if (flagC) {
        //> lda WorldNumber       ;otherwise put world number of current
        temp0 = worldNumber
        //> sta ContinueWorld     ;player into secret continue function variable
        continueWorld = temp0
        //> lda #$00
        temp0 = 0x00
        //> asl                   ;residual ASL instruction
        temp0 = (temp0 shl 1) and 0xFF
        //> sta OperMode_Task     ;reset all modes to title screen and
        opermodeTask = temp0
        //> sta ScreenTimer       ;leave
        screenTimer = temp0
        //> sta OperMode
        operMode = temp0
        //> rts
        return
    } else {
        //> ContinueGame:
        //> jsr LoadAreaPointer       ;update level pointer with
        loadAreaPointer(temp0)
        //> lda #$01                  ;actual world and area numbers, then
        temp0 = 0x01
        //> sta PlayerSize            ;reset player's size, status, and
        playerSize = temp0
        //> inc FetchNewGameTimerFlag ;set game timer flag to reload
        fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
        //> lda #$00                  ;game timer from header
        temp0 = 0x00
        //> sta TimerControl          ;also set flag for timers to count again
        timerControl = temp0
        //> sta PlayerStatus
        playerStatus = temp0
        //> sta GameEngineSubroutine  ;reset task for game core
        gameEngineSubroutine = temp0
        //> sta OperMode_Task         ;set modes and leave
        opermodeTask = temp0
        //> lda #$01                  ;if in game over mode, switch back to
        temp0 = 0x01
        //> sta OperMode              ;game mode, because game is still on
        operMode = temp0
    }
    //> GameIsOn:  rts
    return
}

// Decompiled from TransposePlayers
fun transposePlayers() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var numberOfPlayers by MemoryByte(NumberOfPlayers)
    var offscrNumberoflives by MemoryByte(OffScr_NumberofLives)
    val offscreenPlayerInfo by MemoryByteIndexed(OffscreenPlayerInfo)
    val onscreenPlayerInfo by MemoryByteIndexed(OnscreenPlayerInfo)
    //> TransposePlayers:
    //> sec                       ;set carry flag by default to end game
    //> lda NumberOfPlayers       ;if only a 1 player game, leave
    //> beq ExTrans
    temp0 = numberOfPlayers
    if (numberOfPlayers != 0) {
        //> lda OffScr_NumberofLives  ;does offscreen player have any lives left?
        temp0 = offscrNumberoflives
        //> bmi ExTrans               ;branch if not
        if ((temp0 and 0x80) == 0) {
            //> lda CurrentPlayer         ;invert bit to update
            temp0 = currentPlayer
            //> eor #%00000001            ;which player is on the screen
            temp1 = temp0 xor 0x01
            //> sta CurrentPlayer
            currentPlayer = temp1
            //> ldx #$06
            temp2 = 0x06
            do {
                //> TransLoop: lda OnscreenPlayerInfo,x    ;transpose the information
                temp0 = onscreenPlayerInfo[temp2]
                //> pha                         ;of the onscreen player
                push(temp0)
                //> lda OffscreenPlayerInfo,x   ;with that of the offscreen player
                temp0 = offscreenPlayerInfo[temp2]
                //> sta OnscreenPlayerInfo,x
                onscreenPlayerInfo[temp2] = temp0
                //> pla
                temp0 = pull()
                //> sta OffscreenPlayerInfo,x
                offscreenPlayerInfo[temp2] = temp0
                //> dex
                temp2 = (temp2 - 1) and 0xFF
                //> bpl TransLoop
            } while ((temp2 and 0x80) == 0)
            //> clc            ;clear carry flag to get game going
        }
    }
    //> ExTrans:   rts
    return
}

// Decompiled from DoNothing1
fun doNothing1() {
    //> DoNothing1:
    //> lda #$ff       ;this is residual code, this value is
    //> sta $06c9      ;not used anywhere in the program
    memory[0x6C9] = 0xFF.toUByte()
    // Fall-through tail call to doNothing2
    doNothing2()
}

// Decompiled from DoNothing2
fun doNothing2() {
    //> DoNothing2:
    //> rts
    return
}

// Decompiled from AreaParserTaskHandler
fun areaParserTaskHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    //> AreaParserTaskHandler:
    //> ldy AreaParserTaskNum     ;check number of tasks here
    //> bne DoAPTasks             ;if already set, go ahead
    temp0 = areaParserTaskNum
    if (areaParserTaskNum == 0) {
        //> ldy #$08
        temp0 = 0x08
        //> sty AreaParserTaskNum     ;otherwise, set eight by default
        areaParserTaskNum = temp0
    }
    //> DoAPTasks:    dey
    temp0 = (temp0 - 1) and 0xFF
    //> tya
    //> jsr AreaParserTasks
    areaParserTasks()
    //> dec AreaParserTaskNum     ;if all tasks not complete do not
    areaParserTaskNum = (areaParserTaskNum - 1) and 0xFF
    //> bne SkipATRender          ;render attribute table yet
    temp1 = temp0
    if (areaParserTaskNum == 0) {
        //> jsr RenderAttributeTables
        renderAttributeTables()
    }
    //> SkipATRender: rts
    return
}

// Decompiled from AreaParserTasks
fun areaParserTasks() {
    //> AreaParserTasks:
    //> jsr JumpEngine
    when (A) {
        0 -> {
            incrementColumnPos()
        }
        1 -> {
            renderAreaGraphics()
        }
        2 -> {
            renderAreaGraphics()
        }
        3 -> {
            areaParserCore()
        }
        4 -> {
            incrementColumnPos()
        }
        5 -> {
            renderAreaGraphics()
        }
        6 -> {
            renderAreaGraphics()
        }
        7 -> {
            areaParserCore()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from IncrementColumnPos
fun incrementColumnPos() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var blockBufferColumnPos by MemoryByte(BlockBufferColumnPos)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    //> IncrementColumnPos:
    //> inc CurrentColumnPos     ;increment column where we're at
    currentColumnPos = (currentColumnPos + 1) and 0xFF
    //> lda CurrentColumnPos
    //> and #%00001111           ;mask out higher nybble
    temp0 = currentColumnPos and 0x0F
    //> bne NoColWrap
    temp1 = temp0
    if (temp0 == 0) {
        //> sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
        currentColumnPos = temp1
        //> inc CurrentPageLoc       ;and increment page number where we're at
        currentPageLoc = (currentPageLoc + 1) and 0xFF
    }
    //> NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
    blockBufferColumnPos = (blockBufferColumnPos + 1) and 0xFF
    //> lda BlockBufferColumnPos
    temp1 = blockBufferColumnPos
    //> and #%00011111           ;mask out all but 5 LSB (0-1f)
    temp2 = temp1 and 0x1F
    //> sta BlockBufferColumnPos ;and save
    blockBufferColumnPos = temp2
    //> rts
    return
}

// Decompiled from AreaParserCore
fun areaParserCore() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaType by MemoryByte(AreaType)
    var backgroundScenery by MemoryByte(BackgroundScenery)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var blockBufferColumnPos by MemoryByte(BlockBufferColumnPos)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var foregroundScenery by MemoryByte(ForegroundScenery)
    var terrainControl by MemoryByte(TerrainControl)
    var worldNumber by MemoryByte(WorldNumber)
    val bSceneDataOffsets by MemoryByteIndexed(BSceneDataOffsets)
    val backSceneryData by MemoryByteIndexed(BackSceneryData)
    val backSceneryMetatiles by MemoryByteIndexed(BackSceneryMetatiles)
    val bitmasks by MemoryByteIndexed(Bitmasks)
    val blockBuffLowBounds by MemoryByteIndexed(BlockBuffLowBounds)
    val fSceneDataOffsets by MemoryByteIndexed(FSceneDataOffsets)
    val foreSceneryData by MemoryByteIndexed(ForeSceneryData)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val terrainMetatiles by MemoryByteIndexed(TerrainMetatiles)
    val terrainRenderBits by MemoryByteIndexed(TerrainRenderBits)
    //> AreaParserCore:
    //> lda BackloadingFlag       ;check to see if we are starting right of start
    //> beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
    temp0 = backloadingFlag
    if (backloadingFlag != 0) {
        //> jsr ProcessAreaData       ;otherwise skip ahead and load level data
        processAreaData()
    }
    //> RenderSceneryTerrain:
    //> ldx #$0c
    //> lda #$00
    temp0 = 0x00
    temp1 = 0x0C
    do {
        //> ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
        metatileBuffer[temp1] = temp0
        //> dex
        temp1 = (temp1 - 1) and 0xFF
        //> bpl ClrMTBuf
    } while ((temp1 and 0x80) == 0)
    //> ldy BackgroundScenery      ;do we need to render the background scenery?
    //> beq RendFore               ;if not, skip to check the foreground
    temp2 = backgroundScenery
    if (backgroundScenery != 0) {
        //> lda CurrentPageLoc         ;otherwise check for every third page
        temp0 = currentPageLoc
        while ((temp3 and 0xFF and 0x80) == 0) {
            //> sec
            //> sbc #$03                   ;if 3 or more, subtract 3 and
            temp3 = temp0 - 0x03
            temp0 = temp3 and 0xFF
            //> bpl ThirdP                 ;do an unconditional branch
        }
        //> RendBack: asl                        ;move results to higher nybble
        temp0 = (temp0 shl 1) and 0xFF
        //> asl
        temp0 = (temp0 shl 1) and 0xFF
        //> asl
        temp0 = (temp0 shl 1) and 0xFF
        //> asl
        temp0 = (temp0 shl 1) and 0xFF
        //> adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
        temp4 = temp0 + bSceneDataOffsets[-1 + temp2] + (if ((temp0 and 0x80) != 0) 1 else 0)
        temp0 = temp4 and 0xFF
        //> adc CurrentColumnPos       ;add to the result our current column position
        temp5 = temp0 + currentColumnPos + (if (temp4 > 0xFF) 1 else 0)
        temp0 = temp5 and 0xFF
        //> tax
        //> lda BackSceneryData,x      ;load data from sum of offsets
        temp0 = backSceneryData[temp0]
        //> beq RendFore               ;if zero, no scenery for that part
        temp1 = temp0
        if (temp0 != 0) {
            //> pha
            push(temp0)
            //> and #$0f                   ;save to stack and clear high nybble
            temp6 = temp0 and 0x0F
            //> sec
            //> sbc #$01                   ;subtract one (because low nybble is $01-$0c)
            temp7 = temp6 - 0x01
            temp0 = temp7 and 0xFF
            //> sta $00                    ;save low nybble
            memory[0x0] = temp0.toUByte()
            //> asl                        ;multiply by three (shift to left and add result to old one)
            temp0 = (temp0 shl 1) and 0xFF
            //> adc $00                    ;note that since d7 was nulled, the carry flag is always clear
            temp8 = temp0 + memory[0x0].toInt() + (if ((temp0 and 0x80) != 0) 1 else 0)
            temp0 = temp8 and 0xFF
            //> tax                        ;save as offset for background scenery metatile data
            //> pla                        ;get high nybble from stack, move low
            temp0 = pull()
            //> lsr
            temp0 = temp0 shr 1
            //> lsr
            temp0 = temp0 shr 1
            //> lsr
            temp0 = temp0 shr 1
            //> lsr
            temp0 = temp0 shr 1
            //> tay                        ;use as second offset (used to determine height)
            //> lda #$03                   ;use previously saved memory location for counter
            temp0 = 0x03
            //> sta $00
            memory[0x0] = temp0.toUByte()
            temp1 = temp0
            temp2 = temp0
            while (memory[0x0].toInt() != 0) {
                //> dec $00                    ;decrement until counter expires, barring exception
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bne SceLoop1
            }
        }
    }
    //> RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
    temp1 = foregroundScenery
    //> beq RendTerr               ;if not, skip this part
    if (temp1 != 0) {
        //> ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
        temp2 = fSceneDataOffsets[-1 + temp1]
        //> ldx #$00                   ;reinit X
        temp1 = 0x00
        do {
            //> SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
            temp0 = foreSceneryData[temp2]
            //> beq NoFore                 ;do not store if zero found
            if (temp0 != 0) {
                //> sta MetatileBuffer,x
                metatileBuffer[temp1] = temp0
            }
            //> NoFore:   iny
            temp2 = (temp2 + 1) and 0xFF
            //> inx
            temp1 = (temp1 + 1) and 0xFF
            //> cpx #$0d                   ;store up to end of metatile buffer
            //> bne SceLoop2
        } while (temp1 != 0x0D)
    }
    //> RendTerr: ldy AreaType               ;check world type for water level
    temp2 = areaType
    //> bne TerMTile               ;if not water level, skip this part
    if (temp2 == 0) {
        //> lda WorldNumber            ;check world number, if not world number eight
        temp0 = worldNumber
        //> cmp #World8                ;then skip this part
        //> bne TerMTile
        if (temp0 == World8) {
            //> lda #$62                   ;if set as water level and world number eight,
            temp0 = 0x62
            //> jmp StoreMT                ;use castle wall metatile as terrain type
        }
    } else {
        //> TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
        temp0 = terrainMetatiles[temp2]
        //> ldy CloudTypeOverride      ;check for cloud type override
        temp2 = cloudTypeOverride
        //> beq StoreMT                ;if not set, keep value otherwise
        if (temp2 != 0) {
            //> lda #$88                   ;use cloud block terrain
            temp0 = 0x88
        }
    }
    //> StoreMT:  sta $07                    ;store value here
    memory[0x7] = temp0.toUByte()
    //> ldx #$00                   ;initialize X, use as metatile buffer offset
    temp1 = 0x00
    //> lda TerrainControl         ;use yet another value from the header
    temp0 = terrainControl
    //> asl                        ;multiply by 2 and use as yet another offset
    temp0 = (temp0 shl 1) and 0xFF
    //> tay
    //> TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
    temp0 = terrainRenderBits[temp0]
    //> sta $00
    memory[0x0] = temp0.toUByte()
    //> iny                        ;increment Y and use as offset next time around
    temp0 = (temp0 + 1) and 0xFF
    //> sty $01
    memory[0x1] = temp0.toUByte()
    //> lda CloudTypeOverride      ;skip if value here is zero
    temp0 = cloudTypeOverride
    //> beq NoCloud2
    temp2 = temp0
    if (temp0 != 0) {
        //> cpx #$00                   ;otherwise, check if we're doing the ceiling byte
        //> beq NoCloud2
        if (temp1 != 0x00) {
            //> lda $00                    ;if not, mask out all but d3
            temp0 = memory[0x0].toInt()
            //> and #%00001000
            temp9 = temp0 and 0x08
            //> sta $00
            memory[0x0] = temp9.toUByte()
        }
    }
    //> NoCloud2: ldy #$00                   ;start at beginning of bitmasks
    temp2 = 0x00
    do {
        //> TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
        temp0 = bitmasks[temp2]
        //> bit $00
        //> beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
        if ((temp0 and memory[0x0].toInt()) != 0) {
            //> lda $07
            temp0 = memory[0x7].toInt()
            //> sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
            metatileBuffer[temp1] = temp0
        }
        //> NextTBit: inx                        ;continue until end of buffer
        temp1 = (temp1 + 1) and 0xFF
        //> cpx #$0d
        //> beq RendBBuf               ;if we're at the end, break out of this loop
        if (temp1 != 0x0D) {
            //> lda AreaType               ;check world type for underground area
            temp0 = areaType
            //> cmp #$02
            //> bne EndUChk                ;if not underground, skip this part
            if (temp0 == 0x02) {
                //> cpx #$0b
                //> bne EndUChk                ;if we're at the bottom of the screen, override
                if (temp1 == 0x0B) {
                    //> lda #$54                   ;old terrain type with ground level terrain type
                    temp0 = 0x54
                    //> sta $07
                    memory[0x7] = temp0.toUByte()
                }
            }
            //> EndUChk:  iny                        ;increment bitmasks offset in Y
            temp2 = (temp2 + 1) and 0xFF
            //> cpy #$08
            //> bne TerrBChk               ;if not all bits checked, loop back
        }
    } while (!flagZ)
    //> ldy $01
    temp2 = memory[0x1].toInt()
    //> bne TerrLoop               ;unconditional branch, use Y to load next byte
    //> RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
    processAreaData()
    //> lda BlockBufferColumnPos
    temp0 = blockBufferColumnPos
    //> jsr GetBlockBufferAddr     ;get block buffer address from where we're at
    getBlockBufferAddr(temp0)
    //> ldx #$00
    temp1 = 0x00
    //> ldy #$00                   ;init index regs and start at beginning of smaller buffer
    temp2 = 0x00
    do {
        //> ChkMTLow: sty $00
        memory[0x0] = temp2.toUByte()
        //> lda MetatileBuffer,x       ;load stored metatile number
        temp0 = metatileBuffer[temp1]
        //> and #%11000000             ;mask out all but 2 MSB
        temp10 = temp0 and 0xC0
        //> asl
        temp10 = (temp10 shl 1) and 0xFF
        //> rol                        ;make %xx000000 into %000000xx
        temp10 = (temp10 shl 1) and 0xFE or if ((temp10 and 0x80) != 0) 1 else 0
        //> rol
        temp10 = (temp10 shl 1) and 0xFE or if ((temp10 and 0x80) != 0) 1 else 0
        //> tay                        ;use as offset in Y
        //> lda MetatileBuffer,x       ;reload original unmasked value here
        temp0 = metatileBuffer[temp1]
        //> cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
        //> bcs StrBlock               ;if equal or greater, branch
        temp2 = temp10
        if (!(temp0 >= blockBuffLowBounds[temp10])) {
            //> lda #$00                   ;if less, init value before storing
            temp0 = 0x00
        }
        //> StrBlock: ldy $00                    ;get offset for block buffer
        temp2 = memory[0x0].toInt()
        //> sta ($06),y                ;store value into block buffer
        memory[readWord(0x6) + temp2] = temp0.toUByte()
        //> tya
        //> clc                        ;add 16 (move down one row) to offset
        //> adc #$10
        temp11 = temp2 + 0x10
        temp0 = temp11 and 0xFF
        //> tay
        //> inx                        ;increment column value
        temp1 = (temp1 + 1) and 0xFF
        //> cpx #$0d
        //> bcc ChkMTLow               ;continue until we pass last row, then leave
    } while (!(temp1 >= 0x0D))
    //> rts
    return
}

// Decompiled from ProcessAreaData
fun processAreaData() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageLoc by MemoryByte(AreaObjectPageLoc)
    var areaObjectPageSel by MemoryByte(AreaObjectPageSel)
    var backloadingFlag by MemoryByte(BackloadingFlag)
    var behindAreaParserFlag by MemoryByte(BehindAreaParserFlag)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var objectOffset by MemoryByte(ObjectOffset)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> ProcessAreaData:
    //> ldx #$02                 ;start at the end of area object buffer
    temp0 = 0x02
    do {
        //> ProcADLoop: stx ObjectOffset
        objectOffset = temp0
        //> lda #$00                 ;reset flag
        //> sta BehindAreaParserFlag
        behindAreaParserFlag = 0x00
        //> ldy AreaDataOffset       ;get offset of area data pointer
        //> lda (AreaData),y         ;get first byte of area object
        //> cmp #$fd                 ;if end-of-area, skip all this crap
        //> beq RdyDecode
        if (memory[readWord(AreaData) + areaDataOffset].toInt() - 0xFD == 0) {
            //  goto RdyDecode
            return
        }
        temp1 = memory[readWord(AreaData) + areaDataOffset].toInt()
        temp2 = areaDataOffset
        if (memory[readWord(AreaData) + areaDataOffset].toInt() != 0xFD) {
            //> lda AreaObjectLength,x   ;check area object buffer flag
            temp1 = areaObjectLength[temp0]
            //> bpl RdyDecode            ;if buffer not negative, branch, otherwise
            if (!((temp1 and 0x80) != 0)) {
                //  goto RdyDecode
                return
            }
            if ((temp1 and 0x80) != 0) {
                //> iny
                temp2 = (temp2 + 1) and 0xFF
                //> lda (AreaData),y         ;get second byte of area object
                temp1 = memory[readWord(AreaData) + temp2].toInt()
                //> asl                      ;check for page select bit (d7), branch if not set
                temp1 = (temp1 shl 1) and 0xFF
                //> bcc Chk1Row13
                if ((temp1 and 0x80) != 0) {
                    //> lda AreaObjectPageSel    ;check page select
                    temp1 = areaObjectPageSel
                    //> bne Chk1Row13
                    if (temp1 == 0) {
                        //> inc AreaObjectPageSel    ;if not already set, set it now
                        areaObjectPageSel = (areaObjectPageSel + 1) and 0xFF
                        //> inc AreaObjectPageLoc    ;and increment page location
                        areaObjectPageLoc = (areaObjectPageLoc + 1) and 0xFF
                    }
                }
                //> Chk1Row13:  dey
                temp2 = (temp2 - 1) and 0xFF
                //> lda (AreaData),y         ;reread first byte of level object
                temp1 = memory[readWord(AreaData) + temp2].toInt()
                //> and #$0f                 ;mask out high nybble
                temp3 = temp1 and 0x0F
                //> cmp #$0d                 ;row 13?
                //> bne Chk1Row14
                temp1 = temp3
                if (temp3 == 0x0D) {
                    //> iny                      ;if so, reread second byte of level object
                    temp2 = (temp2 + 1) and 0xFF
                    //> lda (AreaData),y
                    temp1 = memory[readWord(AreaData) + temp2].toInt()
                    //> dey                      ;decrement to get ready to read first byte
                    temp2 = (temp2 - 1) and 0xFF
                    //> and #%01000000           ;check for d6 set (if not, object is page control)
                    temp4 = temp1 and 0x40
                    //> bne CheckRear
                    temp1 = temp4
                    if (temp4 == 0) {
                        //> lda AreaObjectPageSel    ;if page select is set, do not reread
                        temp1 = areaObjectPageSel
                        //> bne CheckRear
                        if (temp1 == 0) {
                            //> iny                      ;if d6 not set, reread second byte
                            temp2 = (temp2 + 1) and 0xFF
                            //> lda (AreaData),y
                            temp1 = memory[readWord(AreaData) + temp2].toInt()
                            //> and #%00011111           ;mask out all but 5 LSB and store in page control
                            temp5 = temp1 and 0x1F
                            //> sta AreaObjectPageLoc
                            areaObjectPageLoc = temp5
                            //> inc AreaObjectPageSel    ;increment page select
                            areaObjectPageSel = (areaObjectPageSel + 1) and 0xFF
                            //> jmp NextAObj
                        }
                    }
                }
                //> Chk1Row14:  cmp #$0e                 ;row 14?
                //> bne CheckRear
                if (temp1 == 0x0E) {
                    //> lda BackloadingFlag      ;check flag for saved page number and branch if set
                    temp1 = backloadingFlag
                    //> bne RdyDecode            ;to render the object (otherwise bg might not look right)
                    if (!(temp1 == 0)) {
                        //  goto RdyDecode
                        return
                    }
                    if (temp1 == 0) {
                    }
                }
                //> CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
                temp1 = areaObjectPageLoc
                //> cmp CurrentPageLoc       ;behind current page of renderer
                //> bcc SetBehind            ;if so branch
                if (temp1 >= currentPageLoc) {
                }
            }
        }
        //> RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
        decodeAreaData(temp0)
        //> jmp ChkLength
        //> SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
        behindAreaParserFlag = (behindAreaParserFlag + 1) and 0xFF
        //> NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
        incAreaObjOffset()
        //> ChkLength:  ldx ObjectOffset         ;get buffer offset
        temp0 = objectOffset
        //> lda AreaObjectLength,x   ;check object length for anything stored here
        temp1 = areaObjectLength[temp0]
        //> bmi ProcLoopb            ;if not, branch to handle loopback
        if ((temp1 and 0x80) == 0) {
            //> dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
            areaObjectLength[temp0] = (areaObjectLength[temp0] - 1) and 0xFF
        }
        //> ProcLoopb:  dex                      ;decrement buffer offset
        temp0 = (temp0 - 1) and 0xFF
        //> bpl ProcADLoop           ;and loopback unless exceeded buffer
    } while ((temp0 and 0x80) == 0)
    //> lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
    temp1 = behindAreaParserFlag
    //> bne ProcessAreaData      ;branch if true to load more level data, otherwise
    //> lda BackloadingFlag      ;check for flag set if starting right of page $00
    temp1 = backloadingFlag
    //> bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
    //> EndAParse:  rts
    return
}

// Decompiled from IncAreaObjOffset
fun incAreaObjOffset() {
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageSel by MemoryByte(AreaObjectPageSel)
    //> IncAreaObjOffset:
    //> inc AreaDataOffset    ;increment offset of level pointer
    areaDataOffset = (areaDataOffset + 1) and 0xFF
    //> inc AreaDataOffset
    areaDataOffset = (areaDataOffset + 1) and 0xFF
    //> lda #$00              ;reset page select
    //> sta AreaObjectPageSel
    areaObjectPageSel = 0x00
    //> rts
    return
}

// Decompiled from DecodeAreaData
fun decodeAreaData(X: Int) {
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> EndAParse:  rts
    return
}

// Decompiled from LoopCmdE
fun loopCmdE() {
    //> LoopCmdE: rts
    return
}

// Decompiled from AlterAreaAttributes
fun alterAreaAttributes(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var backgroundScenery by MemoryByte(BackgroundScenery)
    var foregroundScenery by MemoryByte(ForegroundScenery)
    var terrainControl by MemoryByte(TerrainControl)
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    //> AlterAreaAttributes:
    //> ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
    //> iny                       ;load second byte
    temp0 = areaObjOffsetBuffer[X]
    temp0 = (temp0 + 1) and 0xFF
    //> lda (AreaData),y
    //> pha                       ;save in stack for now
    push(memory[readWord(AreaData) + temp0].toInt())
    //> and #%01000000
    temp1 = memory[readWord(AreaData) + temp0].toInt() and 0x40
    //> bne Alter2                ;branch if d6 is set
    temp2 = temp1
    if (temp1 == 0) {
        //> pla
        temp2 = pull()
        //> pha                       ;pull and push offset to copy to A
        push(temp2)
        //> and #%00001111            ;mask out high nybble and store as
        temp3 = temp2 and 0x0F
        //> sta TerrainControl        ;new terrain height type bits
        terrainControl = temp3
        //> pla
        temp2 = pull()
        //> and #%00110000            ;pull and mask out all but d5 and d4
        temp4 = temp2 and 0x30
        //> lsr                       ;move bits to lower nybble and store
        temp4 = temp4 shr 1
        //> lsr                       ;as new background scenery bits
        temp4 = temp4 shr 1
        //> lsr
        temp4 = temp4 shr 1
        //> lsr
        temp4 = temp4 shr 1
        //> sta BackgroundScenery     ;then leave
        backgroundScenery = temp4
        //> rts
        return
    } else {
        //> Alter2:  pla
        temp2 = pull()
        //> and #%00000111            ;mask out all but 3 LSB
        temp5 = temp2 and 0x07
        //> cmp #$04                  ;if four or greater, set color control bits
        //> bcc SetFore               ;and nullify foreground scenery bits
        temp2 = temp5
        if (temp5 >= 0x04) {
            //> sta BackgroundColorCtrl
            backgroundColorCtrl = temp2
            //> lda #$00
            temp2 = 0x00
        }
    }
    //> SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
    foregroundScenery = temp2
    //> rts
    return
}

// Decompiled from ScrollLockObject_Warp
fun scrolllockobjectWarp() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var areaType by MemoryByte(AreaType)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    var worldNumber by MemoryByte(WorldNumber)
    //> ScrollLockObject_Warp:
    //> ldx #$04            ;load value of 4 for game text routine as default
    //> lda WorldNumber     ;warp zone (4-3-2), then check world number
    //> beq WarpNum
    temp0 = worldNumber
    temp1 = 0x04
    if (worldNumber != 0) {
        //> inx                 ;if world number > 1, increment for next warp zone (5)
        temp1 = (temp1 + 1) and 0xFF
        //> ldy AreaType        ;check area type
        //> dey
        areaType = (areaType - 1) and 0xFF
        //> bne WarpNum         ;if ground area type, increment for last warp zone
        temp2 = areaType
        if (areaType == 0) {
            //> inx                 ;(8-7-6) and move on
            temp1 = (temp1 + 1) and 0xFF
        }
    }
    //> WarpNum: txa
    //> sta WarpZoneControl ;store number here to be used by warp zone routine
    warpZoneControl = temp1
    //> jsr WriteGameText   ;print text and warp zone numbers
    writeGameText(temp1)
    //> lda #PiranhaPlant
    temp0 = PiranhaPlant
    //> jsr KillEnemies     ;load identifier for piranha plants and do sub
    killEnemies(temp0)
    // Fall-through tail call to scrollLockObject
    scrollLockObject()
}

// Decompiled from ScrollLockObject
fun scrollLockObject() {
    var temp0: Int = 0
    var scrollLock by MemoryByte(ScrollLock)
    //> ScrollLockObject:
    //> lda ScrollLock      ;invert scroll lock to turn it on
    //> eor #%00000001
    temp0 = scrollLock xor 0x01
    //> sta ScrollLock
    scrollLock = temp0
    //> rts
    return
}

// Decompiled from KillEnemies
fun killEnemies(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> KillEnemies:
    //> sta $00           ;store identifier here
    memory[0x0] = A.toUByte()
    //> lda #$00
    //> ldx #$04          ;check for identifier in enemy object buffer
    temp0 = 0x04
    do {
        //> KillELoop: ldy Enemy_ID,x
        //> cpy $00           ;if not found, branch
        //> bne NoKillE
        temp1 = 0x00
        temp2 = enemyId[temp0]
        if (enemyId[temp0] == memory[0x0].toInt()) {
            //> sta Enemy_Flag,x  ;if found, deactivate enemy object flag
            enemyFlag[temp0] = temp1
        }
        //> NoKillE:   dex               ;do this until all slots are checked
        temp0 = (temp0 - 1) and 0xFF
        //> bpl KillELoop
    } while ((temp0 and 0x80) == 0)
    //> rts
    return
}

// Decompiled from AreaFrenzy
fun areaFrenzy() {
    var temp0: Int = 0
    var temp1: Int = 0
    var enemyFrenzyQueue by MemoryByte(EnemyFrenzyQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val frenzyIDData by MemoryByteIndexed(FrenzyIDData)
    //> AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
    //> lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
    //> ldy #$05
    temp0 = memory[0x0].toInt()
    temp1 = 0x05
    while (frenzyIDData[-8 + memory[0x0].toInt()] != enemyId[temp1]) {
        //> cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
        //> bne FreCompLoop
    }
    //> lda #$00              ;if enemy object already present, nullify queue and leave
    //> ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
    enemyFrenzyQueue = 0x00
    //> rts
    return
}

// Decompiled from AreaStyleObject
fun areaStyleObject() {
    var areaStyle by MemoryByte(AreaStyle)
    //> AreaStyleObject:
    //> lda AreaStyle        ;load level object style and jump to the right sub
    //> jsr JumpEngine
    when (areaStyle) {
        0 -> {
            treeLedge(X, Y)
        }
        1 -> {
            mushroomLedge(X, Y)
        }
        2 -> {
            bulletBillCannon(Y)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from TreeLedge
fun treeLedge(X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> TreeLedge:
    //> jsr GetLrgObjAttrib     ;get row and length of green ledge
    getLrgObjAttrib(X)
    //> lda AreaObjectLength,x  ;check length counter for expiration
    //> beq EndTreeL
    if (areaObjectLength[X] == 0) {
        //  goto EndTreeL
        return
    }
    temp0 = areaObjectLength[X]
    if (areaObjectLength[X] != 0) {
        //> bpl MidTreeL
        if (!((areaObjectLength[X] and 0x80) != 0)) {
            //  goto MidTreeL
            return
        }
        if ((areaObjectLength[X] and 0x80) != 0) {
            //> tya
            //> sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
            areaObjectLength[X] = Y
            //> lda CurrentPageLoc
            temp0 = currentPageLoc
            //> ora CurrentColumnPos    ;are we at the start of the level?
            temp1 = temp0 or currentColumnPos
            //> beq MidTreeL
            if (temp1 == 0) {
                //  goto MidTreeL
                return
            }
            temp0 = temp1
            if (temp1 != 0) {
                //> lda #$16                ;render start of tree ledge
                temp0 = 0x16
                //> jmp NoUnder
            }
        }
        //> MidTreeL: ldx $07
        //> lda #$17                ;render middle of tree ledge
        temp0 = 0x17
        //> sta MetatileBuffer,x    ;note that this is also used if ledge position is
        metatileBuffer[memory[0x7].toInt()] = temp0
        //> lda #$4c                ;at the start of level for continuous effect
        temp0 = 0x4C
        //> jmp AllUnder            ;now render the part underneath
    } else {
        //> EndTreeL: lda #$18                ;render end of tree ledge
        temp0 = 0x18
        //> jmp NoUnder
    }
    //> AllUnder: inx
    X = (X + 1) and 0xFF
    //> ldy #$0f                   ;set $0f to render all way down
    //> jmp RenderUnderPart       ;now render the stem of mushroom
    //> NoUnder:  ldx $07                    ;load row of ledge
    //> ldy #$00                   ;set 0 for no bottom on this part
    //> jmp RenderUnderPart
}

// Decompiled from MushroomLedge
fun mushroomLedge(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val mushroomLedgeHalfLen by MemoryByteIndexed(MushroomLedgeHalfLen)
    //> MushroomLedge:
    //> jsr ChkLrgObjLength        ;get shroom dimensions
    chkLrgObjLength()
    //> sty $06                    ;store length here for now
    memory[0x6] = Y.toUByte()
    //> bcc EndMushL
    if (flagC) {
        //> lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
        //> lsr
        //> sta MushroomLedgeHalfLen,x
        mushroomLedgeHalfLen[X] = areaObjectLength[X] shr 1
        //> lda #$19                   ;render start of mushroom
        //> jmp NoUnder
    } else {
        //> EndMushL: lda #$1b                   ;if at the end, render end of mushroom
        //> ldy AreaObjectLength,x
        //> beq NoUnder
        if (areaObjectLength[X] == 0) {
            //  goto NoUnder
            return
        }
        temp0 = 0x1B
        temp1 = areaObjectLength[X]
        if (areaObjectLength[X] != 0) {
            //> lda MushroomLedgeHalfLen,x ;get divided length and store where length
            temp0 = mushroomLedgeHalfLen[X]
            //> sta $06                    ;was stored originally
            memory[0x6] = temp0.toUByte()
            //> ldx $07
            //> lda #$1a
            temp0 = 0x1A
            //> sta MetatileBuffer,x       ;render middle of mushroom
            metatileBuffer[memory[0x7].toInt()] = temp0
            //> cpy $06                    ;are we smack dab in the center?
            //> bne MushLExit              ;if not, branch to leave
            temp2 = memory[0x7].toInt()
            if (temp1 == memory[0x6].toInt()) {
                //> inx
                temp2 = (temp2 + 1) and 0xFF
                //> lda #$4f
                temp0 = 0x4F
                //> sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
                metatileBuffer[temp2] = temp0
                //> lda #$50
                temp0 = 0x50
                //> AllUnder: inx
                temp2 = (temp2 + 1) and 0xFF
                //> ldy #$0f                   ;set $0f to render all way down
                temp1 = 0x0F
                //> jmp RenderUnderPart       ;now render the stem of mushroom
            } else {
                //> MushLExit: rts                       ;and leave
                return
            }
        }
    }
    //> NoUnder:  ldx $07                    ;load row of ledge
    temp2 = memory[0x7].toInt()
    //> ldy #$00                   ;set 0 for no bottom on this part
    temp1 = 0x00
    //> jmp RenderUnderPart
}

// Decompiled from PulleyRopeObject
fun pulleyRopeObject(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var metatileBuffer by MemoryByte(MetatileBuffer)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val pulleyRopeMetatiles by MemoryByteIndexed(PulleyRopeMetatiles)
    //> PulleyRopeObject:
    //> jsr ChkLrgObjLength       ;get length of pulley/rope object
    chkLrgObjLength()
    //> ldy #$00                  ;initialize metatile offset
    //> bcs RenderPul             ;if starting, render left pulley
    temp0 = 0x00
    if (!flagC) {
        //> iny
        temp0 = (temp0 + 1) and 0xFF
        //> lda AreaObjectLength,x    ;if not at the end, render rope
        //> bne RenderPul
        temp1 = areaObjectLength[X]
        if (areaObjectLength[X] == 0) {
            //> iny                       ;otherwise render right pulley
            temp0 = (temp0 + 1) and 0xFF
        }
    }
    //> RenderPul: lda PulleyRopeMetatiles,y
    temp1 = pulleyRopeMetatiles[temp0]
    //> sta MetatileBuffer        ;render at the top of the screen
    metatileBuffer = temp1
    //> MushLExit: rts                       ;and leave
    return
}

// Decompiled from CastleObject
fun castleObject(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val castleMetatiles by MemoryByteIndexed(CastleMetatiles)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> CastleObject:
    //> jsr GetLrgObjAttrib      ;save lower nybble as starting row
    getLrgObjAttrib(X)
    //> sty $07                  ;if starting row is above $0a, game will crash!!!
    memory[0x7] = Y.toUByte()
    //> ldy #$04
    //> jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
    chkLrgObjFixedLength(X, 0x04)
    //> txa
    //> pha                      ;save obj buffer offset to stack
    push(X)
    //> ldy AreaObjectLength,x   ;use current length as offset for castle data
    //> ldx $07                  ;begin at starting row
    //> lda #$0b
    //> sta $06                  ;load upper limit of number of rows to print
    memory[0x6] = 0x0B.toUByte()
    temp0 = memory[0x7].toInt()
    temp1 = areaObjectLength[X]
    do {
        //> CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
        //> sta MetatileBuffer,x
        metatileBuffer[temp0] = castleMetatiles[temp1]
        //> inx                      ;store in buffer and increment buffer offset
        temp0 = (temp0 + 1) and 0xFF
        //> lda $06
        //> beq ChkCFloor            ;have we reached upper limit yet?
        temp2 = memory[0x6].toInt()
        if (memory[0x6].toInt() != 0) {
            //> iny                      ;if not, increment column-wise
            temp1 = (temp1 + 1) and 0xFF
            //> iny                      ;to byte in next row
            temp1 = (temp1 + 1) and 0xFF
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> dec $06                  ;move closer to upper limit
            memory[0x6] = ((memory[0x6].toInt() - 1) and 0xFF).toUByte()
        }
        //> ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
        //> bne CRendLoop            ;if not, go back and do another row
    } while (temp0 != 0x0B)
    //> pla
    temp2 = pull()
    //> tax                      ;get obj buffer offset from before
    //> lda CurrentPageLoc
    temp2 = currentPageLoc
    //> beq ExitCastle           ;if we're at page 0, we do not need to do anything else
    temp0 = temp2
    if (temp2 != 0) {
        //> lda AreaObjectLength,x   ;check length
        temp2 = areaObjectLength[temp0]
        //> cmp #$01                 ;if length almost about to expire, put brick at floor
        //> beq PlayerStop
        if (temp2 != 0x01) {
            //> ldy $07                  ;check starting row for tall castle ($00)
            temp1 = memory[0x7].toInt()
            //> bne NotTall
            if (temp1 == 0) {
                //> cmp #$03                 ;if found, then check to see if we're at the second column
                //> beq PlayerStop
                if (temp2 != 0x03) {
                }
            }
            //> NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
            //> bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
            if (temp2 == 0x02) {
                //> jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
                getAreaObjXPosition()
                //> pha
                push(temp2)
                //> jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
                findEmptyEnemySlot()
                //> pla
                temp2 = pull()
                //> sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
                enemyXPosition[temp0] = temp2
                //> lda CurrentPageLoc
                temp2 = currentPageLoc
                //> sta Enemy_PageLoc,x      ;set page location for star flag
                enemyPageloc[temp0] = temp2
                //> lda #$01
                temp2 = 0x01
                //> sta Enemy_Y_HighPos,x    ;set vertical high byte
                enemyYHighpos[temp0] = temp2
                //> sta Enemy_Flag,x         ;set flag for buffer
                enemyFlag[temp0] = temp2
                //> lda #$90
                temp2 = 0x90
                //> sta Enemy_Y_Position,x   ;set vertical coordinate
                enemyYPosition[temp0] = temp2
                //> lda #StarFlagObject      ;set star flag value in buffer itself
                temp2 = StarFlagObject
                //> sta Enemy_ID,x
                enemyId[temp0] = temp2
                //> rts
                return
            } else {
                //> ExitCastle: rts
                return
            }
        }
        //> PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
        temp1 = 0x52
        //> sty MetatileBuffer+10    ;this is only done if we're on the second column
        metatileBuffer[10] = temp1
    }
}

// Decompiled from WaterPipe
fun waterPipe(X: Int) {
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> WaterPipe:
    //> jsr GetLrgObjAttrib     ;get row and lower nybble
    getLrgObjAttrib(X)
    //> ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
    //> ldx $07                 ;get row
    //> lda #$6b
    //> sta MetatileBuffer,x    ;draw something here and below it
    metatileBuffer[memory[0x7].toInt()] = 0x6B
    //> lda #$6c
    //> sta MetatileBuffer+1,x
    metatileBuffer[1 + memory[0x7].toInt()] = 0x6C
    //> rts
    return
}

// Decompiled from IntroPipe
fun introPipe() {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val verticalPipeData by MemoryByteIndexed(VerticalPipeData)
    //> IntroPipe:
    //> ldy #$03                 ;check if length set, if not set, set it
    //> jsr ChkLrgObjFixedLength
    chkLrgObjFixedLength(X, 0x03)
    //> ldy #$0a                 ;set fixed value and render the sideways part
    //> jsr RenderSidewaysPipe
    renderSidewaysPipe(X, 0x0A)
    //> bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
    temp0 = 0x0A
    if (!flagC) {
        //> ldx #$06                 ;blank everything above the vertical pipe part
        temp1 = 0x06
        do {
            //> VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
            //> sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
            metatileBuffer[temp1] = 0x00
            //> dex
            temp1 = (temp1 - 1) and 0xFF
            //> bpl VPipeSectLoop
        } while ((temp1 and 0x80) == 0)
        //> lda VerticalPipeData,y   ;draw the end of the vertical pipe part
        //> sta MetatileBuffer+7
        metatileBuffer[7] = verticalPipeData[temp0]
    }
    //> NoBlankP:      rts
    return
}

// Decompiled from ExitPipe
fun exitPipe() {
    var X: Int = 0
    //> ExitPipe:
    //> ldy #$03                 ;check if length set, if not set, set it
    //> jsr ChkLrgObjFixedLength
    chkLrgObjFixedLength(X, 0x03)
    //> jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
    getLrgObjAttrib(X)
    // Fall-through tail call to renderSidewaysPipe
    renderSidewaysPipe(X, 0x03)
}

// Decompiled from RenderSidewaysPipe
fun renderSidewaysPipe(X: Int, Y: Int) {
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val sidePipeBottomPart by MemoryByteIndexed(SidePipeBottomPart)
    val sidePipeShaftData by MemoryByteIndexed(SidePipeShaftData)
    val sidePipeTopPart by MemoryByteIndexed(SidePipeTopPart)
    //> RenderSidewaysPipe:
    //> dey                       ;decrement twice to make room for shaft at bottom
    Y = (Y - 1) and 0xFF
    //> dey                       ;and store here for now as vertical length
    Y = (Y - 1) and 0xFF
    //> sty $05
    memory[0x5] = Y.toUByte()
    //> ldy AreaObjectLength,x    ;get length left over and store here
    //> sty $06
    memory[0x6] = (areaObjectLength[X] and 0xFF).toUByte()
    //> ldx $05                   ;get vertical length plus one, use as buffer offset
    //> inx
    temp0 = memory[0x5].toInt()
    temp0 = (temp0 + 1) and 0xFF
    //> lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
    //> cmp #$00
    //> beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
    temp1 = sidePipeShaftData[areaObjectLength[X]]
    temp2 = areaObjectLength[X]
    if (sidePipeShaftData[areaObjectLength[X]] != 0) {
        //> ldx #$00
        temp0 = 0x00
        //> ldy $05                   ;init buffer offset and get vertical length
        temp2 = memory[0x5].toInt()
        //> jsr RenderUnderPart       ;and render vertical shaft using tile number in A
        renderUnderPart(temp1, temp0, temp2)
        //> clc                       ;clear carry flag to be used by IntroPipe
    }
    //> DrawSidePart: ldy $06                   ;render side pipe part at the bottom
    temp2 = memory[0x6].toInt()
    //> lda SidePipeTopPart,y
    temp1 = sidePipeTopPart[temp2]
    //> sta MetatileBuffer,x      ;note that the pipe parts are stored
    metatileBuffer[temp0] = temp1
    //> lda SidePipeBottomPart,y  ;backwards horizontally
    temp1 = sidePipeBottomPart[temp2]
    //> sta MetatileBuffer+1,x
    metatileBuffer[1 + temp0] = temp1
    //> rts
    return
}

// Decompiled from VerticalPipe
fun verticalPipe(X: Int, Y: Int) {
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var worldNumber by MemoryByte(WorldNumber)
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    val verticalPipeData by MemoryByteIndexed(VerticalPipeData)
    //> VerticalPipe:
    //> jsr GetPipeHeight
    getPipeHeight(X)
    //> lda $00                  ;check to see if value was nullified earlier
    //> beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
    temp0 = memory[0x0].toInt()
    if (memory[0x0].toInt() != 0) {
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                      ;add four if usage control bit was not set
        Y = (Y + 1) and 0xFF
    }
    //> WarpPipe: tya                      ;save value in stack
    //> pha
    push(Y)
    //> lda AreaNumber
    temp0 = areaNumber
    //> ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
    temp1 = temp0 or worldNumber
    //> beq DrawPipe
    if (temp1 == 0) {
        //  goto DrawPipe
        return
    }
    temp0 = temp1
    if (temp1 != 0) {
        //> ldy AreaObjectLength,x   ;if on second column of pipe, branch
        //> beq DrawPipe             ;(because we only need to do this once)
        if (areaObjectLength[X] == 0) {
            //  goto DrawPipe
            return
        }
        temp2 = areaObjectLength[X]
        if (areaObjectLength[X] != 0) {
            //> jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
            findEmptyEnemySlot()
            //> bcs DrawPipe             ;if not found, too many enemies, thus skip
            if (flagC) {
                //  goto DrawPipe
                return
            }
            if (!flagC) {
                //> jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
                getAreaObjXPosition()
                //> clc
                //> adc #$08                 ;add eight to put the piranha plant in the center
                temp3 = temp0 + 0x08
                temp0 = temp3 and 0xFF
                //> sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
                enemyXPosition[X] = temp0
                //> lda CurrentPageLoc       ;add carry to current page number
                temp0 = currentPageLoc
                //> adc #$00
                temp4 = temp0 + (if (temp3 > 0xFF) 1 else 0)
                temp0 = temp4 and 0xFF
                //> sta Enemy_PageLoc,x      ;store as enemy's page coordinate
                enemyPageloc[X] = temp0
                //> lda #$01
                temp0 = 0x01
                //> sta Enemy_Y_HighPos,x
                enemyYHighpos[X] = temp0
                //> sta Enemy_Flag,x         ;activate enemy flag
                enemyFlag[X] = temp0
                //> jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
                getAreaObjYPosition()
                //> sta Enemy_Y_Position,x
                enemyYPosition[X] = temp0
                //> lda #PiranhaPlant        ;write piranha plant's value into buffer
                temp0 = PiranhaPlant
                //> sta Enemy_ID,x
                enemyId[X] = temp0
                //> jsr InitPiranhaPlant
                initPiranhaPlant(X)
            }
        }
    }
    //> DrawPipe: pla                      ;get value saved earlier and use as Y
    temp0 = pull()
    //> tay
    //> ldx $07                  ;get buffer offset
    //> lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
    temp0 = verticalPipeData[temp0]
    //> sta MetatileBuffer,x     ;render the top of the pipe
    metatileBuffer[memory[0x7].toInt()] = temp0
    //> inx
    temp5 = memory[0x7].toInt()
    temp5 = (temp5 + 1) and 0xFF
    //> lda VerticalPipeData+2,y ;render the rest of the pipe
    temp0 = verticalPipeData[2 + temp0]
    //> ldy $06                  ;subtract one from length and render the part underneath
    temp2 = memory[0x6].toInt()
    //> dey
    temp2 = (temp2 - 1) and 0xFF
    //> jmp RenderUnderPart
}

// Decompiled from GetPipeHeight
fun getPipeHeight(X: Int) {
    var temp0: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> GetPipeHeight:
    //> ldy #$01       ;check for length loaded, if not, load
    //> jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
    chkLrgObjFixedLength(X, 0x01)
    //> jsr GetLrgObjAttrib
    getLrgObjAttrib(X)
    //> tya            ;get saved lower nybble as height
    //> and #$07       ;save only the three lower bits as
    temp0 = 0x01 and 0x07
    //> sta $06        ;vertical length, then load Y with
    memory[0x6] = temp0.toUByte()
    //> ldy AreaObjectLength,x    ;length left over
    //> rts
    return
}

// Decompiled from FindEmptyEnemySlot
fun findEmptyEnemySlot(): Int {
    var temp0: Int = 0
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    //> FindEmptyEnemySlot:
    //> ldx #$00          ;start at first enemy slot
    temp0 = 0x00
    while (temp0 != 0x05) {
        //> inx
        temp0 = (temp0 + 1) and 0xFF
        //> cpx #$05          ;if nonzero, check next value
        //> bne EmptyChkLoop
    }
    //> ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
    return A
}

// Decompiled from Hole_Water
fun holeWater() {
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> Hole_Water:
    //> jsr ChkLrgObjLength   ;get low nybble and save as length
    chkLrgObjLength()
    //> lda #$86              ;render waves
    //> sta MetatileBuffer+10
    metatileBuffer[10] = 0x86
    //> ldx #$0b
    //> ldy #$01              ;now render the water underneath
    //> lda #$87
    //> jmp RenderUnderPart
}

// Decompiled from QuestionBlockRow_High
fun questionblockrowHigh() {
    //> QuestionBlockRow_High:
    //> lda #$03    ;start on the fourth row
    //> .db $2c     ;BIT instruction opcode
    // Fall-through tail call to questionblockrowLow
    questionblockrowLow()
}

// Decompiled from QuestionBlockRow_Low
fun questionblockrowLow() {
    var temp0: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> QuestionBlockRow_Low:
    //> lda #$07             ;start on the eighth row
    //> pha                  ;save whatever row to the stack for now
    push(0x07)
    //> jsr ChkLrgObjLength  ;get low nybble and save as length
    chkLrgObjLength()
    //> pla
    temp0 = pull()
    //> tax                  ;render question boxes with coins
    //> lda #$c0
    //> sta MetatileBuffer,x
    metatileBuffer[temp0] = 0xC0
    //> rts
    return
}

// Decompiled from Bridge_High
fun bridgeHigh() {
    //> Bridge_High:
    //> lda #$06  ;start on the seventh row from top of screen
    //> .db $2c   ;BIT instruction opcode
    // Fall-through tail call to bridgeMiddle
    bridgeMiddle()
}

// Decompiled from Bridge_Middle
fun bridgeMiddle() {
    //> Bridge_Middle:
    //> lda #$07  ;start on the eighth row
    //> .db $2c   ;BIT instruction opcode
    // Fall-through tail call to bridgeLow
    bridgeLow()
}

// Decompiled from Bridge_Low
fun bridgeLow() {
    var temp0: Int = 0
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> Bridge_Low:
    //> lda #$09             ;start on the tenth row
    //> pha                  ;save whatever row to the stack for now
    push(0x09)
    //> jsr ChkLrgObjLength  ;get low nybble and save as length
    chkLrgObjLength()
    //> pla
    temp0 = pull()
    //> tax                  ;render bridge railing
    //> lda #$0b
    //> sta MetatileBuffer,x
    metatileBuffer[temp0] = 0x0B
    //> inx
    temp0 = (temp0 + 1) and 0xFF
    //> ldy #$00             ;now render the bridge itself
    //> lda #$63
    //> jmp RenderUnderPart
}

// Decompiled from FlagBalls_Residual
fun flagballsResidual() {
    var X: Int = 0
    //> FlagBalls_Residual:
    //> jsr GetLrgObjAttrib  ;get low nybble from object byte
    getLrgObjAttrib(X)
    //> ldx #$02             ;render flag balls on third row from top
    //> lda #$6d             ;of screen downwards based on low nybble
    //> jmp RenderUnderPart
}

// Decompiled from FlagpoleObject
fun flagpoleObject() {
    var temp0: Int = 0
    var temp1: Int = 0
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var flagpolefnumYPos by MemoryByte(FlagpoleFNum_Y_Pos)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> FlagpoleObject:
    //> lda #$24                 ;render flagpole ball on top
    //> sta MetatileBuffer
    metatileBuffer[0] = 0x24
    //> ldx #$01                 ;now render the flagpole shaft
    //> ldy #$08
    //> lda #$25
    //> jsr RenderUnderPart
    renderUnderPart(0x25, 0x01, 0x08)
    //> lda #$61                 ;render solid block at the bottom
    //> sta MetatileBuffer+10
    metatileBuffer[10] = 0x61
    //> jsr GetAreaObjXPosition
    getAreaObjXPosition()
    //> sec                      ;get pixel coordinate of where the flagpole is,
    //> sbc #$08                 ;subtract eight pixels and use as horizontal
    temp0 = 0x61 - 0x08
    //> sta Enemy_X_Position+5   ;coordinate for the flag
    enemyXPosition[5] = temp0 and 0xFF
    //> lda CurrentPageLoc
    //> sbc #$00                 ;subtract borrow from page location and use as
    temp1 = currentPageLoc - (if (temp0 >= 0) 0 else 1)
    //> sta Enemy_PageLoc+5      ;page location for the flag
    enemyPageloc[5] = temp1 and 0xFF
    //> lda #$30
    //> sta Enemy_Y_Position+5   ;set vertical coordinate for flag
    enemyYPosition[5] = 0x30
    //> lda #$b0
    //> sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
    flagpolefnumYPos = 0xB0
    //> lda #FlagpoleFlagObject
    //> sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
    enemyId[5] = FlagpoleFlagObject
    //> inc Enemy_Flag+5         ;use last space in enemy object buffer
    enemyFlag[5] = (enemyFlag[5] + 1) and 0xFF
    //> rts
    return
}

// Decompiled from EndlessRope
fun endlessRope() {
    //> EndlessRope:
    //> ldx #$00       ;render rope from the top to the bottom of screen
    //> ldy #$0f
    //> jmp DrawRope
    //> DrawRope: lda #$40            ;render the actual rope
    //> jmp RenderUnderPart
}

// Decompiled from BalancePlatRope
fun balancePlatRope(X: Int) {
    var temp0: Int = 0
    //> BalancePlatRope:
    //> txa                 ;save object buffer offset for now
    //> pha
    push(X)
    //> ldx #$01            ;blank out all from second row to the bottom
    //> ldy #$0f            ;with blank used for balance platform rope
    //> lda #$44
    //> jsr RenderUnderPart
    renderUnderPart(0x44, 0x01, 0x0F)
    //> pla                 ;get back object buffer offset
    temp0 = pull()
    //> tax
    //> jsr GetLrgObjAttrib ;get vertical length from lower nybble
    getLrgObjAttrib(temp0)
    //> ldx #$01
    //> DrawRope: lda #$40            ;render the actual rope
    //> jmp RenderUnderPart
}

// Decompiled from RowOfCoins
fun rowOfCoins() {
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    val coinMetatileData by MemoryByteIndexed(CoinMetatileData)
    //> RowOfCoins:
    //> ldy AreaType            ;get area type
    //> lda CoinMetatileData,y  ;load appropriate coin metatile
    //> jmp GetRow
    //> GetRow:  pha                        ;store metatile here
    push(coinMetatileData[areaType])
    //> jsr ChkLrgObjLength        ;get row number, load length
    chkLrgObjLength()
    //> DrawRow: ldx $07
    //> ldy #$00                   ;set vertical height of 1
    //> pla
    temp0 = pull()
    //> jmp RenderUnderPart        ;render object
}

// Decompiled from CastleBridgeObj
fun castleBridgeObj() {
    var X: Int = 0
    //> CastleBridgeObj:
    //> ldy #$0c                  ;load length of 13 columns
    //> jsr ChkLrgObjFixedLength
    chkLrgObjFixedLength(X, 0x0C)
    //> jmp ChainObj
}

// Decompiled from AxeObj
fun axeObj() {
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> AxeObj:
    //> lda #$08                  ;load bowser's palette into sprite portion of palette
    //> sta VRAM_Buffer_AddrCtrl
    vramBufferAddrctrl = 0x08
    // Fall-through tail call to chainObj
    chainObj()
}

// Decompiled from ChainObj
fun chainObj() {
    val cObjectmetatile by MemoryByteIndexed(C_ObjectMetatile)
    val cObjectrow by MemoryByteIndexed(C_ObjectRow)
    //> ChainObj:
    //> ldy $00                   ;get value loaded earlier from decoder
    //> ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
    //> lda C_ObjectMetatile-2,y
    //> jmp ColObj
    //> ColObj: ldy #$00             ;column length of 1
    //> jmp RenderUnderPart
}

// Decompiled from EmptyBlock
fun emptyBlock() {
    var X: Int = 0
    //> EmptyBlock:
    //> jsr GetLrgObjAttrib  ;get row location
    getLrgObjAttrib(X)
    //> ldx $07
    //> lda #$c4
    //> ColObj: ldy #$00             ;column length of 1
    //> jmp RenderUnderPart
}

// Decompiled from RowOfBricks
fun rowOfBricks() {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    val brickMetatiles by MemoryByteIndexed(BrickMetatiles)
    //> RowOfBricks:
    //> ldy AreaType           ;load area type obtained from area offset pointer
    //> lda CloudTypeOverride  ;check for cloud type override
    //> beq DrawBricks
    if (cloudTypeOverride == 0) {
        //  goto DrawBricks
        return
    }
    temp0 = cloudTypeOverride
    temp1 = areaType
    if (cloudTypeOverride != 0) {
        //> ldy #$04               ;if cloud type, override area type
        temp1 = 0x04
    }
    //> DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
    temp0 = brickMetatiles[temp1]
    //> jmp GetRow             ;and go render it
    //> GetRow:  pha                        ;store metatile here
    push(temp0)
    //> jsr ChkLrgObjLength        ;get row number, load length
    chkLrgObjLength()
    //> DrawRow: ldx $07
    //> ldy #$00                   ;set vertical height of 1
    temp1 = 0x00
    //> pla
    temp0 = pull()
    //> jmp RenderUnderPart        ;render object
}

// Decompiled from RowOfSolidBlocks
fun rowOfSolidBlocks() {
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    val solidBlockMetatiles by MemoryByteIndexed(SolidBlockMetatiles)
    //> RowOfSolidBlocks:
    //> ldy AreaType               ;load area type obtained from area offset pointer
    //> lda SolidBlockMetatiles,y  ;get metatile
    //> GetRow:  pha                        ;store metatile here
    push(solidBlockMetatiles[areaType])
    //> jsr ChkLrgObjLength        ;get row number, load length
    chkLrgObjLength()
    //> DrawRow: ldx $07
    //> ldy #$00                   ;set vertical height of 1
    //> pla
    temp0 = pull()
    //> jmp RenderUnderPart        ;render object
    // Fall-through tail call to rowOfCoins
    rowOfCoins()
}

// Decompiled from ColumnOfBricks
fun columnOfBricks() {
    var X: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    val brickMetatiles by MemoryByteIndexed(BrickMetatiles)
    //> ColumnOfBricks:
    //> ldy AreaType          ;load area type obtained from area offset
    //> lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
    //> jmp GetRow2
    //> GetRow2: pha                        ;save metatile to stack for now
    push(brickMetatiles[areaType])
    //> jsr GetLrgObjAttrib        ;get length and row
    getLrgObjAttrib(X)
    //> pla                        ;restore metatile
    temp0 = pull()
    //> ldx $07                    ;get starting row
    //> jmp RenderUnderPart        ;now render the column
}

// Decompiled from ColumnOfSolidBlocks
fun columnOfSolidBlocks() {
    var X: Int = 0
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    val solidBlockMetatiles by MemoryByteIndexed(SolidBlockMetatiles)
    //> ColumnOfSolidBlocks:
    //> ldy AreaType               ;load area type obtained from area offset
    //> lda SolidBlockMetatiles,y  ;get metatile
    //> GetRow2: pha                        ;save metatile to stack for now
    push(solidBlockMetatiles[areaType])
    //> jsr GetLrgObjAttrib        ;get length and row
    getLrgObjAttrib(X)
    //> pla                        ;restore metatile
    temp0 = pull()
    //> ldx $07                    ;get starting row
    //> jmp RenderUnderPart        ;now render the column
}

// Decompiled from BulletBillCannon
fun bulletBillCannon(Y: Int) {
    var X: Int = 0
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var cannonOffset by MemoryByte(Cannon_Offset)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val cannonPageloc by MemoryByteIndexed(Cannon_PageLoc)
    val cannonXPosition by MemoryByteIndexed(Cannon_X_Position)
    val cannonYPosition by MemoryByteIndexed(Cannon_Y_Position)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> BulletBillCannon:
    //> jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
    getLrgObjAttrib(X)
    //> ldx $07                  ;start at first row
    //> lda #$64                 ;render bullet bill cannon
    //> sta MetatileBuffer,x
    metatileBuffer[memory[0x7].toInt()] = 0x64
    //> inx
    temp0 = memory[0x7].toInt()
    temp0 = (temp0 + 1) and 0xFF
    //> dey                      ;done yet?
    Y = (Y - 1) and 0xFF
    //> bmi SetupCannon
    temp1 = 0x64
    if ((Y and 0x80) == 0) {
        //> lda #$65                 ;if not, render middle part
        temp1 = 0x65
        //> sta MetatileBuffer,x
        metatileBuffer[temp0] = temp1
        //> inx
        temp0 = (temp0 + 1) and 0xFF
        //> dey                      ;done yet?
        Y = (Y - 1) and 0xFF
        //> bmi SetupCannon
        if ((Y and 0x80) == 0) {
            //> lda #$66                 ;if not, render bottom until length expires
            temp1 = 0x66
            //> jsr RenderUnderPart
            renderUnderPart(temp1, temp0, Y)
        }
    }
    //> SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
    temp0 = cannonOffset
    //> jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
    getAreaObjYPosition()
    //> sta Cannon_Y_Position,x  ;and store it here
    cannonYPosition[temp0] = temp1
    //> lda CurrentPageLoc
    temp1 = currentPageLoc
    //> sta Cannon_PageLoc,x     ;store page number for cannon here
    cannonPageloc[temp0] = temp1
    //> jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
    getAreaObjXPosition()
    //> sta Cannon_X_Position,x  ;and store it here
    cannonXPosition[temp0] = temp1
    //> inx
    temp0 = (temp0 + 1) and 0xFF
    //> cpx #$06                 ;increment and check offset
    //> bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
    if (temp0 >= 0x06) {
        //> ldx #$00                 ;otherwise initialize it
        temp0 = 0x00
    }
    //> StrCOffset:  stx Cannon_Offset        ;save new offset and leave
    cannonOffset = temp0
    //> rts
    return
}

// Decompiled from StaircaseObject
fun staircaseObject() {
    var staircaseControl by MemoryByte(StaircaseControl)
    val staircaseHeightData by MemoryByteIndexed(StaircaseHeightData)
    val staircaseRowData by MemoryByteIndexed(StaircaseRowData)
    //> StaircaseObject:
    //> jsr ChkLrgObjLength       ;check and load length
    chkLrgObjLength()
    //> bcc NextStair             ;if length already loaded, skip init part
    if (!(flagC)) {
        //  goto NextStair
        return
    }
    if (flagC) {
        //> lda #$09                  ;start past the end for the bottom
        //> sta StaircaseControl      ;of the staircase
        staircaseControl = 0x09
    }
    //> NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
    staircaseControl = (staircaseControl - 1) and 0xFF
    //> ldy StaircaseControl
    //> ldx StaircaseRowData,y    ;get starting row and height to render
    //> lda StaircaseHeightData,y
    //> tay
    //> lda #$61                  ;now render solid block staircase
    //> jmp RenderUnderPart
}

// Decompiled from Jumpspring
fun jumpspring(A: Int, X: Int) {
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val jumpspringFixedypos by MemoryByteIndexed(Jumpspring_FixedYPos)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    //> Jumpspring:
    //> jsr GetLrgObjAttrib
    getLrgObjAttrib(X)
    //> jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
    findEmptyEnemySlot()
    //> jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
    getAreaObjXPosition()
    //> sta Enemy_X_Position,x      ;and store
    enemyXPosition[X] = A
    //> lda CurrentPageLoc          ;store page location of jumpspring
    //> sta Enemy_PageLoc,x
    enemyPageloc[X] = currentPageLoc
    //> jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
    getAreaObjYPosition()
    //> sta Enemy_Y_Position,x      ;and store
    enemyYPosition[X] = currentPageLoc
    //> sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
    jumpspringFixedypos[X] = currentPageLoc
    //> lda #JumpspringObject
    //> sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
    enemyId[X] = JumpspringObject
    //> ldy #$01
    //> sty Enemy_Y_HighPos,x       ;store vertical high byte
    enemyYHighpos[X] = 0x01
    //> inc Enemy_Flag,x            ;set flag for enemy object buffer
    enemyFlag[X] = (enemyFlag[X] + 1) and 0xFF
    //> ldx $07
    //> lda #$67                    ;draw metatiles in two rows where jumpspring is
    //> sta MetatileBuffer,x
    metatileBuffer[memory[0x7].toInt()] = 0x67
    //> lda #$68
    //> sta MetatileBuffer+1,x
    metatileBuffer[1 + memory[0x7].toInt()] = 0x68
    //> rts
    return
}

// Decompiled from Hidden1UpBlock
fun hidden1UpBlock() {
    var temp0: Int = 0
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    //> Hidden1UpBlock:
    //> lda Hidden1UpFlag  ;if flag not set, do not render object
    //> beq ExitDecBlock
    if (hidden1UpFlag == 0) {
        //  goto ExitDecBlock
        return
    }
    temp0 = hidden1UpFlag
    if (hidden1UpFlag != 0) {
        //> lda #$00           ;if set, init for the next one
        temp0 = 0x00
        //> sta Hidden1UpFlag
        hidden1UpFlag = temp0
        //> jmp BrickWithItem  ;jump to code shared with unbreakable bricks
    }
    //> ExitDecBlock: rts
    return
}

// Decompiled from QuestionBlock
fun questionBlock(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val brickQBlockMetatiles by MemoryByteIndexed(BrickQBlockMetatiles)
    //> DrawRow: ldx $07
    //> ldy #$00                   ;set vertical height of 1
    //> pla
    temp0 = pull()
    //> jmp RenderUnderPart        ;render object
    //> QuestionBlock:
    //> jsr GetAreaObjectID ;get value from level decoder routine
    getAreaObjectID()
    //> jmp DrawQBlk        ;go to render it
    temp1 = memory[0x7].toInt()
    temp2 = 0x00
    while (true) {
        //> DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
        //> pha                         ;if branched to here from question block routine)
        push(brickQBlockMetatiles[temp2])
        //> jsr GetLrgObjAttrib         ;get row from location byte
        getLrgObjAttrib(temp1)
        //> jmp DrawRow                 ;now render the object
    }
}

// Decompiled from BrickWithCoins
fun brickWithCoins() {
    var brickCoinTimerFlag by MemoryByte(BrickCoinTimerFlag)
    //> BrickWithCoins:
    //> lda #$00                 ;initialize multi-coin timer flag
    //> sta BrickCoinTimerFlag
    brickCoinTimerFlag = 0x00
    // Fall-through tail call to brickWithItem
    brickWithItem(Y)
}

// Decompiled from BrickWithItem
fun brickWithItem(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaType by MemoryByte(AreaType)
    val brickQBlockMetatiles by MemoryByteIndexed(BrickQBlockMetatiles)
    //> DrawRow: ldx $07
    //> ldy #$00                   ;set vertical height of 1
    //> pla
    temp0 = pull()
    //> jmp RenderUnderPart        ;render object
    //> BrickWithItem:
    //> jsr GetAreaObjectID         ;save area object ID
    getAreaObjectID()
    //> sty $07
    memory[0x7] = 0x00.toUByte()
    //> lda #$00                    ;load default adder for bricks with lines
    //> ldy AreaType                ;check level type for ground level
    //> dey
    areaType = (areaType - 1) and 0xFF
    //> beq BWithL                  ;if ground type, do not start with 5
    temp1 = 0x00
    temp2 = memory[0x7].toInt()
    temp3 = areaType
    if (areaType != 0) {
        //> lda #$05                    ;otherwise use adder for bricks without lines
        temp1 = 0x05
    }
    //> BWithL:   clc                         ;add object ID to adder
    //> adc $07
    temp4 = temp1 + memory[0x7].toInt()
    temp1 = temp4 and 0xFF
    //> tay                         ;use as offset for metatile
    temp3 = temp1
    while (true) {
        //> DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
        temp1 = brickQBlockMetatiles[temp3]
        //> pha                         ;if branched to here from question block routine)
        push(temp1)
        //> jsr GetLrgObjAttrib         ;get row from location byte
        getLrgObjAttrib(temp2)
        //> jmp DrawRow                 ;now render the object
    }
    // Fall-through tail call to questionBlock
    questionBlock(temp3)
}

// Decompiled from GetAreaObjectID
fun getAreaObjectID() {
    var temp0: Int = 0
    //> GetAreaObjectID:
    //> lda $00    ;get value saved from area parser routine
    //> sec
    //> sbc #$00   ;possibly residual code
    temp0 = memory[0x0].toInt()
    //> tay        ;save to Y
    //> ExitDecBlock: rts
    return
}

// Decompiled from Hole_Empty
fun holeEmpty() {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var areaType by MemoryByte(AreaType)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var whirlpoolOffset by MemoryByte(Whirlpool_Offset)
    val holeMetatiles by MemoryByteIndexed(HoleMetatiles)
    val whirlpoolLeftextent by MemoryByteIndexed(Whirlpool_LeftExtent)
    val whirlpoolLength by MemoryByteIndexed(Whirlpool_Length)
    val whirlpoolPageloc by MemoryByteIndexed(Whirlpool_PageLoc)
    //> Hole_Empty:
    //> jsr ChkLrgObjLength          ;get lower nybble and save as length
    chkLrgObjLength()
    //> bcc NoWhirlP                 ;skip this part if length already loaded
    if (flagC) {
        //> lda AreaType                 ;check for water type level
        //> bne NoWhirlP                 ;if not water type, skip this part
        temp0 = areaType
        if (areaType == 0) {
            //> ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
            //> jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
            getAreaObjXPosition()
            //> sec
            //> sbc #$10                     ;subtract 16 pixels
            temp1 = temp0 - 0x10
            temp0 = temp1 and 0xFF
            //> sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
            whirlpoolLeftextent[whirlpoolOffset] = temp0
            //> lda CurrentPageLoc           ;get page location of where we're at
            temp0 = currentPageLoc
            //> sbc #$00                     ;subtract borrow
            temp2 = temp0 - (if (temp1 >= 0) 0 else 1)
            temp0 = temp2 and 0xFF
            //> sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
            whirlpoolPageloc[whirlpoolOffset] = temp0
            //> iny
            Y = (Y + 1) and 0xFF
            //> iny                          ;increment length by 2
            Y = (Y + 1) and 0xFF
            //> tya
            //> asl                          ;multiply by 16 to get size of whirlpool
            Y = (Y shl 1) and 0xFF
            //> asl                          ;note that whirlpool will always be
            Y = (Y shl 1) and 0xFF
            //> asl                          ;two blocks bigger than actual size of hole
            Y = (Y shl 1) and 0xFF
            //> asl                          ;and extend one block beyond each edge
            Y = (Y shl 1) and 0xFF
            //> sta Whirlpool_Length,x       ;save size of whirlpool here
            whirlpoolLength[whirlpoolOffset] = Y
            //> inx
            whirlpoolOffset = (whirlpoolOffset + 1) and 0xFF
            //> cpx #$05                     ;increment and check offset
            //> bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
            temp0 = Y
            temp3 = whirlpoolOffset
            if (whirlpoolOffset >= 0x05) {
                //> ldx #$00                     ;otherwise initialize it
                temp3 = 0x00
            }
            //> StrWOffset: stx Whirlpool_Offset         ;save new offset here
            whirlpoolOffset = temp3
        }
    }
    //> NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
    temp3 = areaType
    //> lda HoleMetatiles,x          ;render the hole proper
    temp0 = holeMetatiles[temp3]
    //> ldx #$08
    temp3 = 0x08
    //> ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
    //> ;--------------------------------
    // Fall-through tail call to renderUnderPart
    renderUnderPart(temp0, temp3, 0x0F)
}

// Decompiled from RenderUnderPart
fun renderUnderPart(A: Int, X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var areaObjectHeight by MemoryByte(AreaObjectHeight)
    val metatileBuffer by MemoryByteIndexed(MetatileBuffer)
    do {
        //> RenderUnderPart:
        //> sty AreaObjectHeight  ;store vertical length to render
        areaObjectHeight = Y
        //> ldy MetatileBuffer,x  ;check current spot to see if there's something
        //> beq DrawThisRow       ;we need to keep, if nothing, go ahead
        temp0 = metatileBuffer[X]
        if (metatileBuffer[X] != 0) {
            //> cpy #$17
            //> beq WaitOneRow        ;if middle part (tree ledge), wait until next row
            if (temp0 != 0x17) {
                //> cpy #$1a
                //> beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
                if (temp0 != 0x1A) {
                    //> cpy #$c0
                    //> beq DrawThisRow       ;if question block w/ coin, overwrite
                    if (temp0 != 0xC0) {
                        //> cpy #$c0
                        //> bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
                        if (!(temp0 >= 0xC0)) {
                            //> cpy #$54
                            //> bne DrawThisRow       ;if cracked rock terrain, overwrite
                            if (temp0 == 0x54) {
                                //> cmp #$50
                                //> beq WaitOneRow        ;if stem top of mushroom, wait until next row
                                if (A != 0x50) {
                                }
                            }
                        }
                    }
                }
            }
        }
        //> DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
        metatileBuffer[X] = A
        //> WaitOneRow:  inx
        X = (X + 1) and 0xFF
        //> cpx #$0d              ;stop rendering if we're at the bottom of the screen
        //> bcs ExitUPartR
        if (!(X >= 0x0D)) {
            //> ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
            temp0 = areaObjectHeight
            //> dey
            temp0 = (temp0 - 1) and 0xFF
            //> bpl RenderUnderPart
        }
    } while (!flagN)
    //> ExitUPartR:  rts
    return
}

// Decompiled from ChkLrgObjLength
fun chkLrgObjLength() {
    var X: Int = 0
    //> ChkLrgObjLength:
    //> jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
    getLrgObjAttrib(X)
    // Fall-through tail call to chkLrgObjFixedLength
    chkLrgObjFixedLength(X, Y)
}

// Decompiled from ChkLrgObjFixedLength
fun chkLrgObjFixedLength(X: Int, Y: Int) {
    var temp0: Int = 0
    val areaObjectLength by MemoryByteIndexed(AreaObjectLength)
    //> ChkLrgObjFixedLength:
    //> lda AreaObjectLength,x  ;check for set length counter
    //> clc                     ;clear carry flag for not just starting
    //> bpl LenSet              ;if counter not set, load it, otherwise leave alone
    temp0 = areaObjectLength[X]
    if ((areaObjectLength[X] and 0x80) != 0) {
        //> tya                     ;save length into length counter
        //> sta AreaObjectLength,x
        areaObjectLength[X] = Y
        //> sec                     ;set carry flag if just starting
    }
    //> LenSet: rts
    return
}

// Decompiled from GetLrgObjAttrib
fun getLrgObjAttrib(X: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val areaObjOffsetBuffer by MemoryByteIndexed(AreaObjOffsetBuffer)
    //> GetLrgObjAttrib:
    //> ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
    //> lda (AreaData),y          ;get first byte of level object
    //> and #%00001111
    temp0 = memory[readWord(AreaData) + areaObjOffsetBuffer[X]].toInt() and 0x0F
    //> sta $07                   ;save row location
    memory[0x7] = temp0.toUByte()
    //> iny
    temp1 = areaObjOffsetBuffer[X]
    temp1 = (temp1 + 1) and 0xFF
    //> lda (AreaData),y          ;get next byte, save lower nybble (length or height)
    //> and #%00001111            ;as Y, then leave
    temp2 = memory[readWord(AreaData) + temp1].toInt() and 0x0F
    //> tay
    //> rts
    return A
}

// Decompiled from GetAreaObjXPosition
fun getAreaObjXPosition(): Int {
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    //> GetAreaObjXPosition:
    //> lda CurrentColumnPos    ;multiply current offset where we're at by 16
    //> asl                     ;to obtain horizontal pixel coordinate
    currentColumnPos = (currentColumnPos shl 1) and 0xFF
    //> asl
    currentColumnPos = (currentColumnPos shl 1) and 0xFF
    //> asl
    currentColumnPos = (currentColumnPos shl 1) and 0xFF
    //> asl
    currentColumnPos = (currentColumnPos shl 1) and 0xFF
    //> rts
    return A
}

// Decompiled from GetAreaObjYPosition
fun getAreaObjYPosition(): Int {
    var temp0: Int = 0
    //> GetAreaObjYPosition:
    //> lda $07  ;multiply value by 16
    //> asl
    //> asl      ;this will give us the proper vertical pixel coordinate
    //> asl
    //> asl
    //> clc
    //> adc #32  ;add 32 pixels for the status bar
    temp0 = ((((((((memory[0x7].toInt() shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) + 0x20
    //> rts
    return A
}

// Decompiled from GetBlockBufferAddr
fun getBlockBufferAddr(A: Int) {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val blockBufferAddr by MemoryByteIndexed(BlockBufferAddr)
    //> GetBlockBufferAddr:
    //> pha                      ;take value of A, save
    push(A)
    //> lsr                      ;move high nybble to low
    A = A shr 1
    //> lsr
    A = A shr 1
    //> lsr
    A = A shr 1
    //> lsr
    A = A shr 1
    //> tay                      ;use nybble as pointer to high byte
    //> lda BlockBufferAddr+2,y  ;of indirect here
    //> sta $07
    memory[0x7] = (blockBufferAddr[2 + A] and 0xFF).toUByte()
    //> pla
    temp0 = pull()
    //> and #%00001111           ;pull from stack, mask out high nybble
    temp1 = temp0 and 0x0F
    //> clc
    //> adc BlockBufferAddr,y    ;add to low byte
    temp2 = temp1 + blockBufferAddr[A]
    //> sta $06                  ;store here and leave
    memory[0x6] = (temp2 and 0xFF).toUByte()
    //> rts
    return
}

// Decompiled from LoadAreaPointer
fun loadAreaPointer(A: Int) {
    var areaPointer by MemoryByte(AreaPointer)
    //> LoadAreaPointer:
    //> jsr FindAreaPointer  ;find it and store it here
    findAreaPointer()
    //> sta AreaPointer
    areaPointer = A
    // Fall-through tail call to getAreaType
    getAreaType(A)
}

// Decompiled from GetAreaType
fun getAreaType(A: Int): Int {
    var temp0: Int = 0
    var areaType by MemoryByte(AreaType)
    //> GetAreaType: and #%01100000       ;mask out all but d6 and d5
    temp0 = A and 0x60
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> rol
    temp0 = (temp0 shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0
    //> rol
    temp0 = (temp0 shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0
    //> rol                  ;make %0xx00000 into %000000xx
    temp0 = (temp0 shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0
    //> sta AreaType         ;save 2 MSB as area type
    areaType = temp0
    //> rts
    return A
}

// Decompiled from FindAreaPointer
fun findAreaPointer(): Int {
    var temp0: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var worldNumber by MemoryByte(WorldNumber)
    val areaAddrOffsets by MemoryByteIndexed(AreaAddrOffsets)
    val worldAddrOffsets by MemoryByteIndexed(WorldAddrOffsets)
    //> FindAreaPointer:
    //> ldy WorldNumber        ;load offset from world variable
    //> lda WorldAddrOffsets,y
    //> clc                    ;add area number used to find data
    //> adc AreaNumber
    temp0 = worldAddrOffsets[worldNumber] + areaNumber
    //> tay
    //> lda AreaAddrOffsets,y  ;from there we have our area pointer
    //> rts
    return A
}

// Decompiled from GetAreaDataAddrs
fun getAreaDataAddrs() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaAddrsLOffset by MemoryByte(AreaAddrsLOffset)
    var areaDataHigh by MemoryByte(AreaDataHigh)
    var areaDataLow by MemoryByte(AreaDataLow)
    var areaPointer by MemoryByte(AreaPointer)
    var areaStyle by MemoryByte(AreaStyle)
    var areaType by MemoryByte(AreaType)
    var backgroundColorCtrl by MemoryByte(BackgroundColorCtrl)
    var backgroundScenery by MemoryByte(BackgroundScenery)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var enemyDataHigh by MemoryByte(EnemyDataHigh)
    var enemyDataLow by MemoryByte(EnemyDataLow)
    var foregroundScenery by MemoryByte(ForegroundScenery)
    var gameTimerSetting by MemoryByte(GameTimerSetting)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var terrainControl by MemoryByte(TerrainControl)
    val areaDataAddrHigh by MemoryByteIndexed(AreaDataAddrHigh)
    val areaDataAddrLow by MemoryByteIndexed(AreaDataAddrLow)
    val areaDataHOffsets by MemoryByteIndexed(AreaDataHOffsets)
    val enemyAddrHOffsets by MemoryByteIndexed(EnemyAddrHOffsets)
    val enemyDataAddrHigh by MemoryByteIndexed(EnemyDataAddrHigh)
    val enemyDataAddrLow by MemoryByteIndexed(EnemyDataAddrLow)
    //> GetAreaDataAddrs:
    //> lda AreaPointer          ;use 2 MSB for Y
    //> jsr GetAreaType
    getAreaType(areaPointer)
    //> tay
    //> lda AreaPointer          ;mask out all but 5 LSB
    //> and #%00011111
    temp0 = areaPointer and 0x1F
    //> sta AreaAddrsLOffset     ;save as low offset
    areaAddrsLOffset = temp0
    //> lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
    //> clc                      ;then add base value to 5 LSB, result
    //> adc AreaAddrsLOffset     ;becomes offset for level data
    temp1 = enemyAddrHOffsets[areaPointer] + areaAddrsLOffset
    //> tay
    //> lda EnemyDataAddrLow,y   ;use offset to load pointer
    //> sta EnemyDataLow
    enemyDataLow = enemyDataAddrLow[temp1 and 0xFF]
    //> lda EnemyDataAddrHigh,y
    //> sta EnemyDataHigh
    enemyDataHigh = enemyDataAddrHigh[temp1 and 0xFF]
    //> ldy AreaType             ;use area type as offset
    //> lda AreaDataHOffsets,y   ;do the same thing but with different base value
    //> clc
    //> adc AreaAddrsLOffset
    temp2 = areaDataHOffsets[areaType] + areaAddrsLOffset
    //> tay
    //> lda AreaDataAddrLow,y    ;use this offset to load another pointer
    //> sta AreaDataLow
    areaDataLow = areaDataAddrLow[temp2 and 0xFF]
    //> lda AreaDataAddrHigh,y
    //> sta AreaDataHigh
    areaDataHigh = areaDataAddrHigh[temp2 and 0xFF]
    //> ldy #$00                 ;load first byte of header
    //> lda (AreaData),y
    //> pha                      ;save it to the stack for now
    push(memory[readWord(AreaData)].toInt())
    //> and #%00000111           ;save 3 LSB for foreground scenery or bg color control
    temp3 = memory[readWord(AreaData)].toInt() and 0x07
    //> cmp #$04
    //> bcc StoreFore
    temp4 = temp3
    temp5 = 0x00
    if (temp3 >= 0x04) {
        //> sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
        backgroundColorCtrl = temp4
        //> lda #$00
        temp4 = 0x00
    }
    //> StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
    foregroundScenery = temp4
    //> pla                      ;pull byte from stack and push it back
    temp4 = pull()
    //> pha
    push(temp4)
    //> and #%00111000           ;save player entrance control bits
    temp6 = temp4 and 0x38
    //> lsr                      ;shift bits over to LSBs
    temp6 = temp6 shr 1
    //> lsr
    temp6 = temp6 shr 1
    //> lsr
    temp6 = temp6 shr 1
    //> sta PlayerEntranceCtrl       ;save value here as player entrance control
    playerEntranceCtrl = temp6
    //> pla                      ;pull byte again but do not push it back
    temp4 = pull()
    //> and #%11000000           ;save 2 MSB for game timer setting
    temp7 = temp4 and 0xC0
    //> clc
    //> rol                      ;rotate bits over to LSBs
    temp7 = (temp7 shl 1) and 0xFE
    //> rol
    temp7 = (temp7 shl 1) and 0xFE or if ((temp7 and 0x80) != 0) 1 else 0
    //> rol
    temp7 = (temp7 shl 1) and 0xFE or if ((temp7 and 0x80) != 0) 1 else 0
    //> sta GameTimerSetting     ;save value here as game timer setting
    gameTimerSetting = temp7
    //> iny
    temp5 = (temp5 + 1) and 0xFF
    //> lda (AreaData),y         ;load second byte of header
    temp4 = memory[readWord(AreaData) + temp5].toInt()
    //> pha                      ;save to stack
    push(temp4)
    //> and #%00001111           ;mask out all but lower nybble
    temp8 = temp4 and 0x0F
    //> sta TerrainControl
    terrainControl = temp8
    //> pla                      ;pull and push byte to copy it to A
    temp4 = pull()
    //> pha
    push(temp4)
    //> and #%00110000           ;save 2 MSB for background scenery type
    temp9 = temp4 and 0x30
    //> lsr
    temp9 = temp9 shr 1
    //> lsr                      ;shift bits to LSBs
    temp9 = temp9 shr 1
    //> lsr
    temp9 = temp9 shr 1
    //> lsr
    temp9 = temp9 shr 1
    //> sta BackgroundScenery    ;save as background scenery
    backgroundScenery = temp9
    //> pla
    temp4 = pull()
    //> and #%11000000
    temp10 = temp4 and 0xC0
    //> clc
    //> rol                      ;rotate bits over to LSBs
    temp10 = (temp10 shl 1) and 0xFE
    //> rol
    temp10 = (temp10 shl 1) and 0xFE or if ((temp10 and 0x80) != 0) 1 else 0
    //> rol
    temp10 = (temp10 shl 1) and 0xFE or if ((temp10 and 0x80) != 0) 1 else 0
    //> cmp #%00000011           ;if set to 3, store here
    //> bne StoreStyle           ;and nullify other value
    temp4 = temp10
    if (temp10 == 0x03) {
        //> sta CloudTypeOverride    ;otherwise store value in other place
        cloudTypeOverride = temp4
        //> lda #$00
        temp4 = 0x00
    }
    //> StoreStyle: sta AreaStyle
    areaStyle = temp4
    //> lda AreaDataLow          ;increment area data address by 2 bytes
    temp4 = areaDataLow
    //> clc
    //> adc #$02
    temp11 = temp4 + 0x02
    temp4 = temp11 and 0xFF
    //> sta AreaDataLow
    areaDataLow = temp4
    //> lda AreaDataHigh
    temp4 = areaDataHigh
    //> adc #$00
    temp12 = temp4 + (if (temp11 > 0xFF) 1 else 0)
    temp4 = temp12 and 0xFF
    //> sta AreaDataHigh
    areaDataHigh = temp4
    //> rts
    return
}

// Decompiled from GameMode
fun gameMode() {
    var opermodeTask by MemoryByte(OperMode_Task)
    //> GameMode:
    //> lda OperMode_Task
    //> jsr JumpEngine
    when (opermodeTask) {
        0 -> {
            initializeArea()
        }
        1 -> {
            screenRoutines()
        }
        2 -> {
            secondaryGameSetup()
        }
        3 -> {
            gameCoreRoutine()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from GameCoreRoutine
fun gameCoreRoutine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var currentPlayer by MemoryByte(CurrentPlayer)
    var frameCounter by MemoryByte(FrameCounter)
    var intervalTimerControl by MemoryByte(IntervalTimerControl)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var objectOffset by MemoryByte(ObjectOffset)
    var opermodeTask by MemoryByte(OperMode_Task)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    val savedJoypadBits by MemoryByteIndexed(SavedJoypadBits)
    //> GameCoreRoutine:
    //> ldx CurrentPlayer          ;get which player is on the screen
    //> lda SavedJoypadBits,x      ;use appropriate player's controller bits
    //> sta SavedJoypadBits        ;as the master controller bits
    savedJoypadBits[0] = savedJoypadBits[currentPlayer]
    //> jsr GameRoutines           ;execute one of many possible subs
    gameRoutines()
    //> lda OperMode_Task          ;check major task of operating mode
    //> cmp #$03                   ;if we are supposed to be here,
    //> bcs GameEngine             ;branch to the game engine itself
    temp0 = opermodeTask
    temp1 = currentPlayer
    if (!(opermodeTask >= 0x03)) {
        //> rts
        return
    } else {
        //> GameEngine:
        //> jsr ProcFireball_Bubble    ;process fireballs and air bubbles
        procfireballBubble()
        //> ldx #$00
        temp1 = 0x00
    }
    do {
        //> ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
        objectOffset = temp1
        //> jsr EnemiesAndLoopsCore    ;process enemy objects
        enemiesAndLoopsCore(temp1)
        //> jsr FloateyNumbersRoutine  ;process floatey numbers
        floateyNumbersRoutine(temp1)
        //> inx
        temp1 = (temp1 + 1) and 0xFF
        //> cpx #$06                   ;do these two subroutines until the whole buffer is done
        //> bne ProcELoop
    } while (temp1 != 0x06)
    //> jsr GetPlayerOffscreenBits ;get offscreen bits for player object
    getPlayerOffscreenBits()
    //> jsr RelativePlayerPosition ;get relative coordinates for player object
    relativePlayerPosition()
    //> jsr PlayerGfxHandler       ;draw the player
    playerGfxHandler()
    //> jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
    blockobjmtUpdater()
    //> ldx #$01
    temp1 = 0x01
    //> stx ObjectOffset           ;set offset for second
    objectOffset = temp1
    //> jsr BlockObjectsCore       ;process second block object
    blockObjectsCore(temp1)
    //> dex
    temp1 = (temp1 - 1) and 0xFF
    //> stx ObjectOffset           ;set offset for first
    objectOffset = temp1
    //> jsr BlockObjectsCore       ;process first block object
    blockObjectsCore(temp1)
    //> jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
    miscObjectsCore()
    //> jsr ProcessCannons         ;process bullet bill cannons
    processCannons()
    //> jsr ProcessWhirlpools      ;process whirlpools
    processWhirlpools()
    //> jsr FlagpoleRoutine        ;process the flagpole
    flagpoleRoutine()
    //> jsr RunGameTimer           ;count down the game timer
    runGameTimer()
    //> jsr ColorRotation          ;cycle one of the background colors
    colorRotation()
    //> lda Player_Y_HighPos
    temp0 = playerYHighpos
    //> cmp #$02                   ;if player is below the screen, don't bother with the music
    //> bpl NoChgMus
    if (temp0 - 0x02 < 0) {
        //> lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
        temp0 = starInvincibleTimer
        //> beq ClrPlrPal              ;skip this part
        if (temp0 != 0) {
            //> cmp #$04
            //> bne NoChgMus               ;if not yet at a certain point, continue
            if (temp0 == 0x04) {
                //> lda IntervalTimerControl   ;if interval timer not yet expired,
                temp0 = intervalTimerControl
                //> bne NoChgMus               ;branch ahead, don't bother with the music
                if (temp0 == 0) {
                    //> jsr GetAreaMusic           ;to re-attain appropriate level music
                    getAreaMusic()
                }
            }
        }
    }
    //> NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
    //> lda FrameCounter           ;get frame counter
    temp0 = frameCounter
    //> cpy #$08                   ;if timer still above certain point,
    //> bcs CycleTwo               ;branch to cycle player's palette quickly
    if (starInvincibleTimer >= 0x08) {
        //  goto CycleTwo
        return
    }
    temp2 = starInvincibleTimer
    if (!(starInvincibleTimer >= 0x08)) {
        //> lsr                        ;otherwise, divide by 8 to cycle every eighth frame
        temp0 = temp0 shr 1
        //> lsr
        temp0 = temp0 shr 1
    }
    //> CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
    temp0 = temp0 shr 1
    //> jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
    cyclePlayerPalette(temp0)
    //> jmp SaveAB                 ;then skip this sub to finish up the game engine
    //> ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
    resetPalStar()
    //> SaveAB:       lda A_B_Buttons            ;save current A and B button
    temp0 = aBButtons
    //> sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
    previousaBButtons = temp0
    //> lda #$00
    temp0 = 0x00
    //> sta Left_Right_Buttons     ;nullify left and right buttons temp variable
    leftRightButtons = temp0
    // Fall-through tail call to updScrollVar
    updScrollVar()
}

// Decompiled from UpdScrollVar
fun updScrollVar() {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var scrollThirtyTwo by MemoryByte(ScrollThirtyTwo)
    var vramBuffer2Offset by MemoryByte(VRAM_Buffer2_Offset)
    var vramBufferAddrctrl by MemoryByte(VRAM_Buffer_AddrCtrl)
    //> UpdScrollVar: lda VRAM_Buffer_AddrCtrl
    //> cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
    //> beq ExitEng                ;then branch to leave
    temp0 = vramBufferAddrctrl
    if (vramBufferAddrctrl != 0x06) {
        //> lda AreaParserTaskNum      ;otherwise check number of tasks
        temp0 = areaParserTaskNum
        //> bne RunParser
        if (temp0 == 0) {
            //> lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
            temp0 = scrollThirtyTwo
            //> cmp #$20                   ;check to see if exceeded $21
            //> bmi ExitEng                ;branch to leave if not
            if (!(temp0 - 0x20 < 0)) {
                //> lda ScrollThirtyTwo
                temp0 = scrollThirtyTwo
                //> sbc #$20                   ;otherwise subtract $20 to set appropriately
                temp1 = temp0 - 0x20 - (if (temp0 >= 0x20) 0 else 1)
                temp0 = temp1 and 0xFF
                //> sta ScrollThirtyTwo        ;and store
                scrollThirtyTwo = temp0
                //> lda #$00                   ;reset vram buffer offset used in conjunction with
                temp0 = 0x00
                //> sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
                vramBuffer2Offset = temp0
            } else {
                //> ExitEng:      rts                        ;and after all that, we're finally done!
                return
            }
        }
        //> RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
        areaParserTaskHandler()
    }
}

// Decompiled from ScrollHandler
fun scrollHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var platformXScroll by MemoryByte(Platform_X_Scroll)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerPosForscroll by MemoryByte(Player_Pos_ForScroll)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var scrollAmount by MemoryByte(ScrollAmount)
    var scrollLock by MemoryByte(ScrollLock)
    var sideCollisionTimer by MemoryByte(SideCollisionTimer)
    val offscrJoypadBitsData by MemoryByteIndexed(OffscrJoypadBitsData)
    val screenedgePageloc by MemoryByteIndexed(ScreenEdge_PageLoc)
    val screenedgeXPos by MemoryByteIndexed(ScreenEdge_X_Pos)
    val xSubtracterdata by MemoryByteIndexed(X_SubtracterData)
    //> ScrollHandler:
    //> lda Player_X_Scroll       ;load value saved here
    //> clc
    //> adc Platform_X_Scroll     ;add value used by left/right platforms
    temp0 = playerXScroll + platformXScroll
    //> sta Player_X_Scroll       ;save as new value here to impose force on scroll
    playerXScroll = temp0 and 0xFF
    //> lda ScrollLock            ;check scroll lock flag
    //> bne InitScrlAmt           ;skip a bunch of code here if set
    temp1 = scrollLock
    if (scrollLock == 0) {
        //> lda Player_Pos_ForScroll
        temp1 = playerPosForscroll
        //> cmp #$50                  ;check player's horizontal screen position
        //> bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
        if (temp1 >= 0x50) {
            //> lda SideCollisionTimer    ;if timer related to player's side collision
            temp1 = sideCollisionTimer
            //> bne InitScrlAmt           ;not expired, branch
            if (temp1 == 0) {
                //> ldy Player_X_Scroll       ;get value and decrement by one
                //> dey                       ;if value originally set to zero or otherwise
                playerXScroll = (playerXScroll - 1) and 0xFF
                //> bmi InitScrlAmt           ;negative for left movement, branch
                temp2 = playerXScroll
                if ((playerXScroll and 0x80) == 0) {
                    //> iny
                    temp2 = (temp2 + 1) and 0xFF
                    //> cpy #$02                  ;if value $01, branch and do not decrement
                    //> bcc ChkNearMid
                    if (temp2 >= 0x02) {
                        //> dey                       ;otherwise decrement by one
                        temp2 = (temp2 - 1) and 0xFF
                    }
                    //> ChkNearMid: lda Player_Pos_ForScroll
                    temp1 = playerPosForscroll
                    //> cmp #$70                  ;check player's horizontal screen position
                    //> bcc ScrollScreen          ;if less than 112 pixels to the right, branch
                    if (!(temp1 >= 0x70)) {
                        //  goto ScrollScreen
                        return
                    }
                    //> ldy Player_X_Scroll       ;otherwise get original value undecremented
                    temp2 = playerXScroll
                }
            }
        }
    }
    //> InitScrlAmt:  lda #$00
    temp1 = 0x00
    //> sta ScrollAmount          ;initialize value here
    scrollAmount = temp1
    //> ChkPOffscr:   ldx #$00                  ;set X for player offset
    //> jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
    getXOffscreenBits(0x00)
    //> sta $00                   ;save them here
    memory[0x0] = temp1.toUByte()
    //> ldy #$00                  ;load default offset (left side)
    temp2 = 0x00
    //> asl                       ;if d7 of offscreen bits are set,
    temp1 = (temp1 shl 1) and 0xFF
    //> bcs KeepOnscr             ;branch with default offset
    temp3 = 0x00
    if ((temp1 and 0x80) == 0) {
        //> iny                         ;otherwise use different offset (right side)
        temp2 = (temp2 + 1) and 0xFF
        //> lda $00
        temp1 = memory[0x0].toInt()
        //> and #%00100000              ;check offscreen bits for d5 set
        temp4 = temp1 and 0x20
        //> beq InitPlatScrl            ;if not set, branch ahead of this part
        temp1 = temp4
        if (temp4 != 0) {
        } else {
            //> InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
            temp1 = 0x00
            //> sta Platform_X_Scroll
            platformXScroll = temp1
            //> rts
            return
        }
    }
    //> KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
    temp1 = screenedgeXPos[temp2]
    //> sec
    //> sbc X_SubtracterData,y      ;subtract amount based on offset
    temp5 = temp1 - xSubtracterdata[temp2]
    temp1 = temp5 and 0xFF
    //> sta Player_X_Position       ;store as player position to prevent movement further
    playerXPosition = temp1
    //> lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
    temp1 = screenedgePageloc[temp2]
    //> sbc #$00                    ;subtract borrow
    temp6 = temp1 - (if (temp5 >= 0) 0 else 1)
    temp1 = temp6 and 0xFF
    //> sta Player_PageLoc          ;save as player's page location
    playerPageloc = temp1
    //> lda Left_Right_Buttons      ;check saved controller bits
    temp1 = leftRightButtons
    //> cmp OffscrJoypadBitsData,y  ;against bits based on offset
    //> beq InitPlatScrl            ;if not equal, branch
    if (temp1 != offscrJoypadBitsData[temp2]) {
        //> lda #$00
        temp1 = 0x00
        //> sta Player_X_Speed          ;otherwise nullify horizontal speed of player
        playerXSpeed = temp1
    }
    // Fall-through tail call to scrollScreen
    scrollScreen(temp2)
}

// Decompiled from ScrollScreen
fun scrollScreen(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var horizontalScroll by MemoryByte(HorizontalScroll)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var mirrorPpuCtrlReg1 by MemoryByte(Mirror_PPU_CTRL_REG1)
    var platformXScroll by MemoryByte(Platform_X_Scroll)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var scrollAmount by MemoryByte(ScrollAmount)
    var scrollIntervalTimer by MemoryByte(ScrollIntervalTimer)
    var scrollThirtyTwo by MemoryByte(ScrollThirtyTwo)
    val offscrJoypadBitsData by MemoryByteIndexed(OffscrJoypadBitsData)
    val screenedgePageloc by MemoryByteIndexed(ScreenEdge_PageLoc)
    val screenedgeXPos by MemoryByteIndexed(ScreenEdge_X_Pos)
    val xSubtracterdata by MemoryByteIndexed(X_SubtracterData)
    //> ScrollScreen:
    //> tya
    //> sta ScrollAmount          ;save value here
    scrollAmount = Y
    //> clc
    //> adc ScrollThirtyTwo       ;add to value already set here
    temp0 = Y + scrollThirtyTwo
    //> sta ScrollThirtyTwo       ;save as new value here
    scrollThirtyTwo = temp0 and 0xFF
    //> tya
    //> clc
    //> adc ScreenLeft_X_Pos      ;add to left side coordinate
    temp1 = Y + screenleftXPos
    //> sta ScreenLeft_X_Pos      ;save as new left side coordinate
    screenleftXPos = temp1 and 0xFF
    //> sta HorizontalScroll      ;save here also
    horizontalScroll = temp1 and 0xFF
    //> lda ScreenLeft_PageLoc
    //> adc #$00                  ;add carry to page location for left
    temp2 = screenleftPageloc + (if (temp1 > 0xFF) 1 else 0)
    //> sta ScreenLeft_PageLoc    ;side of the screen
    screenleftPageloc = temp2 and 0xFF
    //> and #$01                  ;get LSB of page location
    temp3 = temp2 and 0xFF and 0x01
    //> sta $00                   ;save as temp variable for PPU register 1 mirror
    memory[0x0] = temp3.toUByte()
    //> lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
    //> and #%11111110            ;save all bits except d0
    temp4 = mirrorPpuCtrlReg1 and 0xFE
    //> ora $00                   ;get saved bit here and save in PPU register 1
    temp5 = temp4 or memory[0x0].toInt()
    //> sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
    mirrorPpuCtrlReg1 = temp5
    //> jsr GetScreenPosition     ;figure out where the right side is
    getScreenPosition()
    //> lda #$08
    //> sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
    scrollIntervalTimer = 0x08
    //> jmp ChkPOffscr            ;skip this part
    //> ChkPOffscr:   ldx #$00                  ;set X for player offset
    //> jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
    getXOffscreenBits(0x00)
    //> sta $00                   ;save them here
    memory[0x0] = 0x08.toUByte()
    //> ldy #$00                  ;load default offset (left side)
    //> asl                       ;if d7 of offscreen bits are set,
    //> bcs KeepOnscr             ;branch with default offset
    temp6 = (0x08 shl 1) and 0xFF
    temp7 = 0x00
    temp8 = 0x00
    if ((0x08 and 0x80) == 0) {
        //> iny                         ;otherwise use different offset (right side)
        temp8 = (temp8 + 1) and 0xFF
        //> lda $00
        temp6 = memory[0x0].toInt()
        //> and #%00100000              ;check offscreen bits for d5 set
        temp9 = temp6 and 0x20
        //> beq InitPlatScrl            ;if not set, branch ahead of this part
        temp6 = temp9
        if (temp9 != 0) {
        } else {
            //> InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
            temp6 = 0x00
            //> sta Platform_X_Scroll
            platformXScroll = temp6
            //> rts
            return
        }
    }
    //> KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
    temp6 = screenedgeXPos[temp8]
    //> sec
    //> sbc X_SubtracterData,y      ;subtract amount based on offset
    temp10 = temp6 - xSubtracterdata[temp8]
    temp6 = temp10 and 0xFF
    //> sta Player_X_Position       ;store as player position to prevent movement further
    playerXPosition = temp6
    //> lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
    temp6 = screenedgePageloc[temp8]
    //> sbc #$00                    ;subtract borrow
    temp11 = temp6 - (if (temp10 >= 0) 0 else 1)
    temp6 = temp11 and 0xFF
    //> sta Player_PageLoc          ;save as player's page location
    playerPageloc = temp6
    //> lda Left_Right_Buttons      ;check saved controller bits
    temp6 = leftRightButtons
    //> cmp OffscrJoypadBitsData,y  ;against bits based on offset
    //> beq InitPlatScrl            ;if not equal, branch
    if (temp6 != offscrJoypadBitsData[temp8]) {
        //> lda #$00
        temp6 = 0x00
        //> sta Player_X_Speed          ;otherwise nullify horizontal speed of player
        playerXSpeed = temp6
    }
}

// Decompiled from GetScreenPosition
fun getScreenPosition(): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    //> GetScreenPosition:
    //> lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
    //> clc
    //> adc #$ff                ;add 255 pixels
    temp0 = screenleftXPos + 0xFF
    //> sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
    screenrightXPos = temp0 and 0xFF
    //> lda ScreenLeft_PageLoc  ;get page number where left boundary is
    //> adc #$00                ;add carry from before
    temp1 = screenleftPageloc + (if (temp0 > 0xFF) 1 else 0)
    //> sta ScreenRight_PageLoc ;store as page number where right boundary is
    screenrightPageloc = temp1 and 0xFF
    //> rts
    return A
}

// Decompiled from GameRoutines
fun gameRoutines() {
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    //> GameRoutines:
    //> lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
    //> jsr JumpEngine            ;merely placeholders as conditions for other routines)
    when (gameEngineSubroutine) {
        0 -> {
            entranceGametimersetup()
        }
        1 -> {
            vineAutoclimb()
        }
        2 -> {
            sideExitPipeEntry()
        }
        3 -> {
            verticalPipeEntry()
        }
        4 -> {
            flagpoleSlide()
        }
        5 -> {
            playerEndLevel()
        }
        6 -> {
            playerLoseLife()
        }
        7 -> {
            playerEntrance()
        }
        8 -> {
            playerCtrlRoutine()
        }
        9 -> {
            playerChangeSize()
        }
        10 -> {
            playerInjuryBlink()
        }
        11 -> {
            playerDeath()
        }
        12 -> {
            playerFireFlower()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from PlayerEntrance
fun playerEntrance() {
    var temp0: Int = 0
    var temp1: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaNumber by MemoryByte(AreaNumber)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    var disableCollisionDet by MemoryByte(DisableCollisionDet)
    var disableIntermediate by MemoryByte(DisableIntermediate)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var halfwayPage by MemoryByte(HalfwayPage)
    var joypadOverride by MemoryByte(JoypadOverride)
    var playerEntranceCtrl by MemoryByte(PlayerEntranceCtrl)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var vineHeight by MemoryByte(VineHeight)
    //> PlayerEntrance:
    //> lda AltEntranceControl    ;check for mode of alternate entry
    //> cmp #$02
    //> beq EntrMode2             ;if found, branch to enter from pipe or with vine
    temp0 = altEntranceControl
    if (altEntranceControl != 0x02) {
        //> lda #$00
        temp0 = 0x00
        //> ldy Player_Y_Position     ;if vertical position above a certain
        //> cpy #$30                  ;point, nullify controller bits and continue
        //> bcc AutoControlPlayer     ;with player movement code, do not return
        if (!(playerYPosition >= 0x30)) {
            //  goto AutoControlPlayer
            return
        }
        //> lda PlayerEntranceCtrl    ;check player entry bits from header
        temp0 = playerEntranceCtrl
        //> cmp #$06
        //> beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
        temp1 = playerYPosition
        if (temp0 != 0x06) {
            //> cmp #$07                  ;otherwise branch to normal entry
            //> bne PlayerRdy
            if (temp0 == 0x07) {
            }
        }
        //> ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
        temp0 = playerSprattrib
        //> bne IntroEntr             ;branch if found
        if (temp0 == 0) {
            //> lda #$01
            temp0 = 0x01
            //> jmp AutoControlPlayer     ;force player to walk to the right
        }
        //> IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
        enterSidePipe()
        //> dec ChangeAreaTimer       ;decrement timer for change of area
        changeAreaTimer = (changeAreaTimer - 1) and 0xFF
        //> bne ExitEntr              ;branch to exit if not yet expired
        if (changeAreaTimer == 0) {
            //> inc DisableIntermediate   ;set flag to skip world and lives display
            disableIntermediate = (disableIntermediate + 1) and 0xFF
            //> jmp NextArea              ;jump to increment to next area and set modes
        } else {
            //> ExitEntr:   rts                       ;leave!
            return
        }
    } else {
        //> EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
        temp0 = joypadOverride
        //> bne VineEntr              ;branch to enter with vine
        if (temp0 == 0) {
            //> lda #$ff                  ;otherwise, set value here then execute sub
            temp0 = 0xFF
            //> jsr MovePlayerYAxis       ;to move player upwards (note $ff = -1)
            movePlayerYAxis(temp0)
            //> lda Player_Y_Position     ;check to see if player is at a specific coordinate
            temp0 = playerYPosition
            //> cmp #$91                  ;if player risen to a certain point (this requires pipes
            //> bcc PlayerRdy             ;to be at specific height to look/function right) branch
            if (temp0 >= 0x91) {
                //> rts                       ;to the last part, otherwise leave
                return
            }
        }
        //> VineEntr:   lda VineHeight
        temp0 = vineHeight
        //> cmp #$60                  ;check vine height
        //> bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
        if (temp0 == 0x60) {
            //> lda Player_Y_Position     ;get player's vertical coordinate
            temp0 = playerYPosition
            //> cmp #$99                  ;check player's vertical coordinate against preset value
            //> ldy #$00                  ;load default values to be written to
            temp1 = 0x00
            //> lda #$01                  ;this value moves player to the right off the vine
            temp0 = 0x01
            //> bcc OffVine               ;if vertical coordinate < preset value, use defaults
            if (temp0 >= 0x99) {
                //> lda #$03
                temp0 = 0x03
                //> sta Player_State          ;otherwise set player state to climbing
                playerState = temp0
                //> iny                       ;increment value in Y
                temp1 = (temp1 + 1) and 0xFF
                //> lda #$08                  ;set block in block buffer to cover hole, then
                temp0 = 0x08
                //> sta Block_Buffer_1+$b4    ;use same value to force player to climb
            }
            //> OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
            disableCollisionDet = temp1
            //> jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
            autoControlPlayer(temp0)
            //> lda Player_X_Position
            temp0 = playerXPosition
            //> cmp #$48                  ;check player's horizontal position
            //> bcc ExitEntr              ;if not far enough to the right, branch to leave
            if (temp0 >= 0x48) {
                //> PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
                temp0 = 0x08
                //> sta GameEngineSubroutine
                gameEngineSubroutine = temp0
                //> lda #$01                  ;set to face player to the right
                temp0 = 0x01
                //> sta PlayerFacingDir
                playerFacingDir = temp0
                //> lsr                       ;init A
                temp0 = temp0 shr 1
                //> sta AltEntranceControl    ;init mode of entry
                altEntranceControl = temp0
                //> sta DisableCollisionDet   ;init collision detection disable flag
                disableCollisionDet = temp0
                //> sta JoypadOverride        ;nullify controller override bits
                joypadOverride = temp0
            }
        }
    }
    //> NextArea: inc AreaNumber            ;increment area number used for address loader
    areaNumber = (areaNumber + 1) and 0xFF
    //> jsr LoadAreaPointer       ;get new level pointer
    loadAreaPointer(temp0)
    //> inc FetchNewGameTimerFlag ;set flag to load new game timer
    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
    //> jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
    chgAreaMode()
    //> sta HalfwayPage           ;reset halfway page to 0 (beginning)
    halfwayPage = temp0
    //> lda #Silence
    temp0 = Silence
    //> sta EventMusicQueue       ;silence music and leave
    eventMusicQueue = temp0
    //> ExitNA:   rts
    return
}

// Decompiled from AutoControlPlayer
fun autoControlPlayer(A: Int) {
    var savedJoypadBits by MemoryByte(SavedJoypadBits)
    //> AutoControlPlayer:
    //> sta SavedJoypadBits         ;override controller bits with contents of A if executing here
    savedJoypadBits = A
    // Fall-through tail call to playerCtrlRoutine
    playerCtrlRoutine()
}

// Decompiled from PlayerCtrlRoutine
fun playerCtrlRoutine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var deathMusicLoaded by MemoryByte(DeathMusicLoaded)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var joypadOverride by MemoryByte(JoypadOverride)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerSize by MemoryByte(PlayerSize)
    var playerBoundboxctrl by MemoryByte(Player_BoundBoxCtrl)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerState by MemoryByte(Player_State)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var savedJoypadBits by MemoryByte(SavedJoypadBits)
    var scrollLock by MemoryByte(ScrollLock)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    //> PlayerCtrlRoutine:
    //> lda GameEngineSubroutine    ;check task here
    //> cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
    //> beq SizeChk
    temp0 = gameEngineSubroutine
    if (gameEngineSubroutine != 0x0B) {
        //> lda AreaType                ;are we in a water type area?
        temp0 = areaType
        //> bne SaveJoyp                ;if not, branch
        if (temp0 == 0) {
            //> ldy Player_Y_HighPos
            //> dey                         ;if not in vertical area between
            playerYHighpos = (playerYHighpos - 1) and 0xFF
            //> bne DisJoyp                 ;status bar and bottom, branch
            temp1 = playerYHighpos
            if (playerYHighpos == 0) {
                //> lda Player_Y_Position
                temp0 = playerYPosition
                //> cmp #$d0                    ;if nearing the bottom of the screen or
                //> bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
                if (temp0 >= 0xD0) {
                }
            }
            //> DisJoyp:    lda #$00                    ;disable controller bits
            temp0 = 0x00
            //> sta SavedJoypadBits
            savedJoypadBits = temp0
        }
        //> SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
        temp0 = savedJoypadBits
        //> and #%11000000
        temp2 = temp0 and 0xC0
        //> sta A_B_Buttons
        aBButtons = temp2
        //> lda SavedJoypadBits         ;store left and right buttons in $0c
        temp0 = savedJoypadBits
        //> and #%00000011
        temp3 = temp0 and 0x03
        //> sta Left_Right_Buttons
        leftRightButtons = temp3
        //> lda SavedJoypadBits         ;store up and down buttons in $0b
        temp0 = savedJoypadBits
        //> and #%00001100
        temp4 = temp0 and 0x0C
        //> sta Up_Down_Buttons
        upDownButtons = temp4
        //> and #%00000100              ;check for pressing down
        temp5 = temp4 and 0x04
        //> beq SizeChk                 ;if not, branch
        temp0 = temp5
        if (temp5 != 0) {
            //> lda Player_State            ;check player's state
            temp0 = playerState
            //> bne SizeChk                 ;if not on the ground, branch
            if (temp0 == 0) {
                //> ldy Left_Right_Buttons      ;check left and right
                temp1 = leftRightButtons
                //> beq SizeChk                 ;if neither pressed, branch
                if (temp1 != 0) {
                    //> lda #$00
                    temp0 = 0x00
                    //> sta Left_Right_Buttons      ;if pressing down while on the ground,
                    leftRightButtons = temp0
                    //> sta Up_Down_Buttons         ;nullify directional bits
                    upDownButtons = temp0
                }
            }
        }
    }
    //> SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
    playerMovementSubs()
    //> ldy #$01                    ;is player small?
    temp1 = 0x01
    //> lda PlayerSize
    temp0 = playerSize
    //> bne ChkMoveDir
    if (temp0 == 0) {
        //> ldy #$00                    ;check for if crouching
        temp1 = 0x00
        //> lda CrouchingFlag
        temp0 = crouchingFlag
        //> beq ChkMoveDir              ;if not, branch ahead
        if (temp0 != 0) {
            //> ldy #$02                    ;if big and crouching, load y with 2
            temp1 = 0x02
        }
    }
    //> ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
    playerBoundboxctrl = temp1
    //> lda #$01                    ;set moving direction to right by default
    temp0 = 0x01
    //> ldy Player_X_Speed          ;check player's horizontal speed
    temp1 = playerXSpeed
    //> beq PlayerSubs              ;if not moving at all horizontally, skip this part
    if (temp1 != 0) {
        //> bpl SetMoveDir              ;if moving to the right, use default moving direction
        if ((temp1 and 0x80) != 0) {
            //> asl                         ;otherwise change to move to the left
            temp0 = (temp0 shl 1) and 0xFF
        }
        //> SetMoveDir: sta Player_MovingDir        ;set moving direction
        playerMovingdir = temp0
    }
    //> PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
    scrollHandler()
    //> jsr GetPlayerOffscreenBits  ;get player's offscreen bits
    getPlayerOffscreenBits()
    //> jsr RelativePlayerPosition  ;get coordinates relative to the screen
    relativePlayerPosition()
    //> ldx #$00                    ;set offset for player object
    //> jsr BoundingBoxCore         ;get player's bounding box coordinates
    boundingBoxCore(0x00, temp1)
    //> jsr PlayerBGCollision       ;do collision detection and process
    playerBGCollision()
    //> lda Player_Y_Position
    temp0 = playerYPosition
    //> cmp #$40                    ;check to see if player is higher than 64th pixel
    //> bcc PlayerHole              ;if so, branch ahead
    temp6 = 0x00
    if (temp0 >= 0x40) {
        //> lda GameEngineSubroutine
        temp0 = gameEngineSubroutine
        //> cmp #$05                    ;if running end-of-level routine, branch ahead
        //> beq PlayerHole
        if (temp0 != 0x05) {
            //> cmp #$07                    ;if running player entrance routine, branch ahead
            //> beq PlayerHole
            if (temp0 != 0x07) {
                //> cmp #$04                    ;if running routines $00-$03, branch ahead
                //> bcc PlayerHole
                if (temp0 >= 0x04) {
                    //> lda Player_SprAttrib
                    temp0 = playerSprattrib
                    //> and #%11011111              ;otherwise nullify player's
                    temp7 = temp0 and 0xDF
                    //> sta Player_SprAttrib        ;background priority flag
                    playerSprattrib = temp7
                }
            }
        }
    }
    //> PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
    temp0 = playerYHighpos
    //> cmp #$02                    ;for below the screen
    //> bmi ExitCtrl                ;branch to leave if not that far down
    if (!(temp0 - 0x02 < 0)) {
        //> ldx #$01
        temp6 = 0x01
        //> stx ScrollLock              ;set scroll lock
        scrollLock = temp6
        //> ldy #$04
        temp1 = 0x04
        //> sty $07                     ;set value here
        memory[0x7] = temp1.toUByte()
        //> ldx #$00                    ;use X as flag, and clear for cloud level
        temp6 = 0x00
        //> ldy GameTimerExpiredFlag    ;check game timer expiration flag
        temp1 = gameTimerExpiredFlag
        //> bne HoleDie                 ;if set, branch
        if (temp1 == 0) {
            //> ldy CloudTypeOverride       ;check for cloud type override
            temp1 = cloudTypeOverride
            //> bne ChkHoleX                ;skip to last part if found
            if (temp1 == 0) {
            }
        }
        //> HoleDie:    inx                         ;set flag in X for player death
        temp6 = (temp6 + 1) and 0xFF
        //> ldy GameEngineSubroutine
        temp1 = gameEngineSubroutine
        //> cpy #$0b                    ;check for some other routine running
        //> beq ChkHoleX                ;if so, branch ahead
        if (temp1 != 0x0B) {
            //> ldy DeathMusicLoaded        ;check value here
            temp1 = deathMusicLoaded
            //> bne HoleBottom              ;if already set, branch to next part
            if (temp1 == 0) {
                //> iny
                temp1 = (temp1 + 1) and 0xFF
                //> sty EventMusicQueue         ;otherwise play death music
                eventMusicQueue = temp1
                //> sty DeathMusicLoaded        ;and set value here
                deathMusicLoaded = temp1
            }
            //> HoleBottom: ldy #$06
            temp1 = 0x06
            //> sty $07                     ;change value here
            memory[0x7] = temp1.toUByte()
        }
        //> ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
        //> bmi ExitCtrl                ;if less, branch to leave
        if (!(temp0 - memory[0x7].toInt() < 0)) {
            //> dex                         ;otherwise decrement flag in X
            temp6 = (temp6 - 1) and 0xFF
            //> bmi CloudExit               ;if flag was clear, branch to set modes and other values
            if ((temp6 and 0x80) == 0) {
                //> ldy EventMusicBuffer        ;check to see if music is still playing
                temp1 = eventMusicBuffer
                //> bne ExitCtrl                ;branch to leave if so
                if (temp1 == 0) {
                    //> lda #$06                    ;otherwise set to run lose life routine
                    temp0 = 0x06
                    //> sta GameEngineSubroutine    ;on next frame
                    gameEngineSubroutine = temp0
                }
            } else {
                //> CloudExit:
                //> lda #$00
                temp0 = 0x00
                //> sta JoypadOverride      ;clear controller override bits if any are set
                joypadOverride = temp0
                //> jsr SetEntr             ;do sub to set secondary mode
                setEntr()
                //> inc AltEntranceControl  ;set mode of entry to 3
                altEntranceControl = (altEntranceControl + 1) and 0xFF
                //> rts
                return
            }
        }
    }
    //> ExitCtrl:   rts                         ;leave
    return
}

// Decompiled from Vine_AutoClimb
fun vineAutoclimb() {
    var temp0: Int = 0
    var joypadOverride by MemoryByte(JoypadOverride)
    var playerState by MemoryByte(Player_State)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    //> Vine_AutoClimb:
    //> lda Player_Y_HighPos   ;check to see whether player reached position
    //> bne AutoClimb          ;above the status bar yet and if so, set modes
    if (!(playerYHighpos == 0)) {
        //  goto AutoClimb
        return
    }
    temp0 = playerYHighpos
    if (playerYHighpos == 0) {
        //> lda Player_Y_Position
        temp0 = playerYPosition
        //> cmp #$e4
        //> bcc SetEntr
        if (!(temp0 >= 0xE4)) {
            //  goto SetEntr
            return
        }
    }
    //> AutoClimb: lda #%00001000         ;set controller bits override to up
    temp0 = 0x08
    //> sta JoypadOverride
    joypadOverride = temp0
    //> ldy #$03               ;set player state to climbing
    //> sty Player_State
    playerState = 0x03
    //> jmp AutoControlPlayer
}

// Decompiled from SetEntr
fun setEntr() {
    var altEntranceControl by MemoryByte(AltEntranceControl)
    //> SetEntr:   lda #$02               ;set starting position to override
    //> sta AltEntranceControl
    altEntranceControl = 0x02
    //> jmp ChgAreaMode        ;set modes
}

// Decompiled from VerticalPipeEntry
fun verticalPipeEntry() {
    var temp0: Int = 0
    var temp1: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaType by MemoryByte(AreaType)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    //> VerticalPipeEntry:
    //> lda #$01             ;set 1 as movement amount
    //> jsr MovePlayerYAxis  ;do sub to move player downwards
    movePlayerYAxis(0x01)
    //> jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
    scrollHandler()
    //> ldy #$00             ;load default mode of entry
    //> lda WarpZoneControl  ;check warp zone control variable/flag
    //> bne ChgAreaPipe      ;if set, branch to use mode 0
    temp0 = warpZoneControl
    temp1 = 0x00
    if (warpZoneControl == 0) {
        //> iny
        temp1 = (temp1 + 1) and 0xFF
        //> lda AreaType         ;check for castle level type
        temp0 = areaType
        //> cmp #$03
        //> bne ChgAreaPipe      ;if not castle type level, use mode 1
        if (temp0 == 0x03) {
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> jmp ChgAreaPipe      ;otherwise use mode 2
        }
    }
    //> ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
    changeAreaTimer = (changeAreaTimer - 1) and 0xFF
    //> bne ExitCAPipe
    if (changeAreaTimer == 0) {
        //> sty AltEntranceControl    ;when timer expires set mode of alternate entry
        altEntranceControl = temp1
    }
    //> ExitCAPipe:  rts                       ;leave
    return
}

// Decompiled from MovePlayerYAxis
fun movePlayerYAxis(A: Int) {
    var temp0: Int = 0
    var playerYPosition by MemoryByte(Player_Y_Position)
    //> MovePlayerYAxis:
    //> clc
    //> adc Player_Y_Position ;add contents of A to player position
    temp0 = A + playerYPosition
    //> sta Player_Y_Position
    playerYPosition = temp0 and 0xFF
    //> rts
    return
}

// Decompiled from SideExitPipeEntry
fun sideExitPipeEntry() {
    var temp0: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    //> SideExitPipeEntry:
    //> jsr EnterSidePipe         ;execute sub to move player to the right
    enterSidePipe()
    //> ldy #$02
    //> ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
    changeAreaTimer = (changeAreaTimer - 1) and 0xFF
    //> bne ExitCAPipe
    temp0 = 0x02
    if (changeAreaTimer == 0) {
        //> sty AltEntranceControl    ;when timer expires set mode of alternate entry
        altEntranceControl = temp0
    }
    //> ExitCAPipe:  rts                       ;leave
    return
}

// Decompiled from ChgAreaMode
fun chgAreaMode(): Int {
    var disableScreenFlag by MemoryByte(DisableScreenFlag)
    var opermodeTask by MemoryByte(OperMode_Task)
    var sprite0HitDetectFlag by MemoryByte(Sprite0HitDetectFlag)
    //> ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
    disableScreenFlag = (disableScreenFlag + 1) and 0xFF
    //> lda #$00
    //> sta OperMode_Task         ;set secondary mode of operation
    opermodeTask = 0x00
    //> sta Sprite0HitDetectFlag  ;disable sprite 0 check
    sprite0HitDetectFlag = 0x00
    //> ExitCAPipe:  rts                       ;leave
    return A
}

// Decompiled from EnterSidePipe
fun enterSidePipe() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> EnterSidePipe:
    //> lda #$08               ;set player's horizontal speed
    //> sta Player_X_Speed
    playerXSpeed = 0x08
    //> ldy #$01               ;set controller right button by default
    //> lda Player_X_Position  ;mask out higher nybble of player's
    //> and #%00001111         ;horizontal position
    temp0 = playerXPosition and 0x0F
    //> bne RightPipe
    temp1 = temp0
    temp2 = 0x01
    if (temp0 == 0) {
        //> sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
        playerXSpeed = temp1
        //> tay                    ;and nullify controller bit override here
    }
    //> RightPipe: tya                    ;use contents of Y to
    //> jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
    autoControlPlayer(temp2)
    //> rts
    return
}

// Decompiled from PlayerChangeSize
fun playerChangeSize() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    var timerControl by MemoryByte(TimerControl)
    //> PlayerChangeSize:
    //> lda TimerControl    ;check master timer control
    //> cmp #$f8            ;for specific moment in time
    //> bne EndChgSize      ;branch if before or after that point
    temp0 = timerControl
    if (timerControl == 0xF8) {
    } else {
        //> EndChgSize:  cmp #$c4            ;check again for another specific moment
        //> bne ExitChgSize     ;and branch to leave if before or after that point
        if (temp0 == 0xC4) {
            //> jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
            donePlayerTask()
        }
        //> ExitChgSize: rts                 ;and then leave
        return
    }
    //> InitChangeSize:
    //> ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
    //> bne ExitBoth              ;then branch to leave
    temp1 = playerChangeSizeFlag
    if (playerChangeSizeFlag == 0) {
        //> sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
        playerAnimCtrl = temp1
        //> inc PlayerChangeSizeFlag  ;set growing/shrinking flag
        playerChangeSizeFlag = (playerChangeSizeFlag + 1) and 0xFF
        //> lda PlayerSize
        temp0 = playerSize
        //> eor #$01                  ;invert player's size
        temp2 = temp0 xor 0x01
        //> sta PlayerSize
        playerSize = temp2
    }
    //> ExitBoth: rts                       ;leave
    return
}

// Decompiled from PlayerInjuryBlink
fun playerInjuryBlink() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    var timerControl by MemoryByte(TimerControl)
    //> PlayerInjuryBlink:
    //> lda TimerControl       ;check master timer control
    //> cmp #$f0               ;for specific moment in time
    //> bcs ExitBlink          ;branch if before that point
    temp0 = timerControl
    if (!(timerControl >= 0xF0)) {
        //> cmp #$c8               ;check again for another specific point
        //> beq DonePlayerTask     ;branch if at that point, and not before or after
        if (temp0 - 0xC8 == 0) {
            //  goto DonePlayerTask
            return
        }
        //> jmp PlayerCtrlRoutine  ;otherwise run player control routine
    }
    //> ExitBlink: bne ExitBoth           ;do unconditional branch to leave
    if (flagZ) {
        //> InitChangeSize:
        //> ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
        //> bne ExitBoth              ;then branch to leave
        temp1 = playerChangeSizeFlag
        if (playerChangeSizeFlag == 0) {
            //> sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
            playerAnimCtrl = temp1
            //> inc PlayerChangeSizeFlag  ;set growing/shrinking flag
            playerChangeSizeFlag = (playerChangeSizeFlag + 1) and 0xFF
            //> lda PlayerSize
            temp0 = playerSize
            //> eor #$01                  ;invert player's size
            temp2 = temp0 xor 0x01
            //> sta PlayerSize
            playerSize = temp2
        }
    }
    //> ExitBoth: rts                       ;leave
    return
}

// Decompiled from PlayerDeath
fun playerDeath() {
    var temp0: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> PlayerDeath:
    //> lda TimerControl       ;check master timer control
    //> cmp #$f0               ;for specific moment in time
    //> bcs ExitDeath          ;branch to leave if before that point
    temp0 = timerControl
    if (!(timerControl >= 0xF0)) {
        //> jmp PlayerCtrlRoutine  ;otherwise run player control routine
    }
    //> ExitDeath:
    //> rts          ;leave from death routine
    return
}

// Decompiled from DonePlayerTask
fun donePlayerTask() {
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var timerControl by MemoryByte(TimerControl)
    //> DonePlayerTask:
    //> lda #$00
    //> sta TimerControl          ;initialize master timer control to continue timers
    timerControl = 0x00
    //> lda #$08
    //> sta GameEngineSubroutine  ;set player control routine to run next frame
    gameEngineSubroutine = 0x08
    //> rts                       ;leave
    return
}

// Decompiled from PlayerFireFlower
fun playerFireFlower() {
    var temp0: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var timerControl by MemoryByte(TimerControl)
    //> PlayerFireFlower:
    //> lda TimerControl       ;check master timer control
    //> cmp #$c0               ;for specific moment in time
    //> beq ResetPalFireFlower ;branch if at moment, not before or after
    temp0 = timerControl
    if (timerControl != 0xC0) {
        //> lda FrameCounter       ;get frame counter
        temp0 = frameCounter
        //> lsr
        temp0 = temp0 shr 1
        //> lsr                    ;divide by four to change every four frames
        temp0 = temp0 shr 1
    }
    //> ResetPalFireFlower:
    //> jsr DonePlayerTask    ;do sub to init timer control and run player control routine
    donePlayerTask()
    // Fall-through tail call to cyclePlayerPalette
    cyclePlayerPalette(temp0)
}

// Decompiled from CyclePlayerPalette
fun cyclePlayerPalette(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    //> CyclePlayerPalette:
    //> and #$03              ;mask out all but d1-d0 (previously d3-d2)
    temp0 = A and 0x03
    //> sta $00               ;store result here to use as palette bits
    memory[0x0] = temp0.toUByte()
    //> lda Player_SprAttrib  ;get player attributes
    //> and #%11111100        ;save any other bits but palette bits
    temp1 = playerSprattrib and 0xFC
    //> ora $00               ;add palette bits
    temp2 = temp1 or memory[0x0].toInt()
    //> sta Player_SprAttrib  ;store as new player attributes
    playerSprattrib = temp2
    //> rts                   ;and leave
    return
}

// Decompiled from ResetPalStar
fun resetPalStar() {
    var temp0: Int = 0
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    //> ResetPalStar:
    //> lda Player_SprAttrib  ;get player attributes
    //> and #%11111100        ;mask out palette bits to force palette 0
    temp0 = playerSprattrib and 0xFC
    //> sta Player_SprAttrib  ;store as new player attributes
    playerSprattrib = temp0
    //> rts                   ;and leave
    return
}

// Decompiled from FlagpoleSlide
fun flagpoleSlide() {
    var temp0: Int = 0
    var temp1: Int = 0
    var flagpoleSoundQueue by MemoryByte(FlagpoleSoundQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> FlagpoleSlide:
    //> lda Enemy_ID+5           ;check special use enemy slot
    //> cmp #FlagpoleFlagObject  ;for flagpole flag object
    //> bne NoFPObj              ;if not found, branch to something residual
    temp0 = enemyId[5]
    if (enemyId[5] == FlagpoleFlagObject) {
        //> lda FlagpoleSoundQueue   ;load flagpole sound
        temp0 = flagpoleSoundQueue
        //> sta Square1SoundQueue    ;into square 1's sfx queue
        square1SoundQueue = temp0
        //> lda #$00
        temp0 = 0x00
        //> sta FlagpoleSoundQueue   ;init flagpole sound queue
        flagpoleSoundQueue = temp0
        //> ldy Player_Y_Position
        //> cpy #$9e                 ;check to see if player has slid down
        //> bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
        if (playerYPosition >= 0x9E) {
            //  goto SlidePlayer
            return
        }
        temp1 = playerYPosition
        if (!(playerYPosition >= 0x9E)) {
            //> lda #$04                 ;otherwise force player to climb down (to slide)
            temp0 = 0x04
        }
        //> SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
    }
    //> NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
    gameEngineSubroutine = (gameEngineSubroutine + 1) and 0xFF
    //> rts                      ;be residual code)
    return
}

// Decompiled from PlayerEndLevel
fun playerEndLevel() {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaNumber by MemoryByte(AreaNumber)
    var coinTallyFor1Ups by MemoryByte(CoinTallyFor1Ups)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var halfwayPage by MemoryByte(HalfwayPage)
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    var levelNumber by MemoryByte(LevelNumber)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var scrollLock by MemoryByte(ScrollLock)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    var worldNumber by MemoryByte(WorldNumber)
    val hidden1UpCoinAmts by MemoryByteIndexed(Hidden1UpCoinAmts)
    //> PlayerEndLevel:
    //> lda #$01                  ;force player to walk to the right
    //> jsr AutoControlPlayer
    autoControlPlayer(0x01)
    //> lda Player_Y_Position     ;check player's vertical position
    //> cmp #$ae
    //> bcc ChkStop               ;if player is not yet off the flagpole, skip this part
    temp0 = playerYPosition
    if (playerYPosition >= 0xAE) {
        //> lda ScrollLock            ;if scroll lock not set, branch ahead to next part
        temp0 = scrollLock
        //> beq ChkStop               ;because we only need to do this part once
        if (temp0 != 0) {
            //> lda #EndOfLevelMusic
            temp0 = EndOfLevelMusic
            //> sta EventMusicQueue       ;load win level music in event music queue
            eventMusicQueue = temp0
            //> lda #$00
            temp0 = 0x00
            //> sta ScrollLock            ;turn off scroll lock to skip this part later
            scrollLock = temp0
        }
    }
    //> ChkStop:  lda Player_CollisionBits  ;get player collision bits
    temp0 = playerCollisionbits
    //> lsr                       ;check for d0 set
    temp0 = temp0 shr 1
    //> bcs RdyNextA              ;if d0 set, skip to next part
    if ((temp0 and 0x01) == 0) {
        //> lda StarFlagTaskControl   ;if star flag task control already set,
        temp0 = starFlagTaskControl
        //> bne InCastle              ;go ahead with the rest of the code
        if (temp0 == 0) {
            //> inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
            starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
        }
        //> InCastle: lda #%00100000            ;set player's background priority bit to
        temp0 = 0x20
        //> sta Player_SprAttrib      ;give illusion of being inside the castle
        playerSprattrib = temp0
    }
    //> RdyNextA: lda StarFlagTaskControl
    temp0 = starFlagTaskControl
    //> cmp #$05                  ;if star flag task control not yet set
    //> bne ExitNA                ;beyond last valid task number, branch to leave
    if (!(temp0 - 0x05 == 0)) {
        //  goto ExitNA
        return
    }
    if (temp0 == 0x05) {
        //> inc LevelNumber           ;increment level number used for game logic
        levelNumber = (levelNumber + 1) and 0xFF
        //> lda LevelNumber
        temp0 = levelNumber
        //> cmp #$03                  ;check to see if we have yet reached level -4
        //> bne NextArea              ;and skip this last part here if not
        if (!(temp0 - 0x03 == 0)) {
            //  goto NextArea
            return
        }
        if (temp0 == 0x03) {
            //> ldy WorldNumber           ;get world number as offset
            //> lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
            temp0 = coinTallyFor1Ups
            //> cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
            //> bcc NextArea              ;at least this number of coins, leave flag clear
            if (!(temp0 >= hidden1UpCoinAmts[worldNumber])) {
                //  goto NextArea
                return
            }
            temp1 = worldNumber
            if (temp0 >= hidden1UpCoinAmts[worldNumber]) {
                //> inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
                hidden1UpFlag = (hidden1UpFlag + 1) and 0xFF
            }
        }
        //> NextArea: inc AreaNumber            ;increment area number used for address loader
        areaNumber = (areaNumber + 1) and 0xFF
        //> jsr LoadAreaPointer       ;get new level pointer
        loadAreaPointer(temp0)
        //> inc FetchNewGameTimerFlag ;set flag to load new game timer
        fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
        //> jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
        chgAreaMode()
        //> sta HalfwayPage           ;reset halfway page to 0 (beginning)
        halfwayPage = temp0
        //> lda #Silence
        temp0 = Silence
        //> sta EventMusicQueue       ;silence music and leave
        eventMusicQueue = temp0
    }
    //> ExitNA:   rts
    return
}

// Decompiled from PlayerMovementSubs
fun playerMovementSubs() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var climbSideTimer by MemoryByte(ClimbSideTimer)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    var playerState by MemoryByte(Player_State)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    //> PlayerMovementSubs:
    //> lda #$00                  ;set A to init crouch flag by default
    //> ldy PlayerSize            ;is player small?
    //> bne SetCrouch             ;if so, branch
    temp0 = 0x00
    temp1 = playerSize
    if (playerSize == 0) {
        //> lda Player_State          ;check state of player
        temp0 = playerState
        //> bne ProcMove              ;if not on the ground, branch
        if (temp0 == 0) {
            //> lda Up_Down_Buttons       ;load controller bits for up and down
            temp0 = upDownButtons
            //> and #%00000100            ;single out bit for down button
            temp2 = temp0 and 0x04
        }
    }
    //> SetCrouch: sta CrouchingFlag         ;store value in crouch flag
    crouchingFlag = temp0
    //> ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
    playerPhysicsSub()
    //> lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
    temp0 = playerChangeSizeFlag
    //> bne NoMoveSub             ;branch to leave
    if (temp0 == 0) {
        //> lda Player_State
        temp0 = playerState
        //> cmp #$03                  ;get player state
        //> beq MoveSubs              ;if climbing, branch ahead, leave timer unset
        if (temp0 != 0x03) {
            //> ldy #$18
            temp1 = 0x18
            //> sty ClimbSideTimer        ;otherwise reset timer now
            climbSideTimer = temp1
        }
        //> MoveSubs:  jsr JumpEngine
        when (temp0) {
            0 -> {
                onGroundStateSub()
            }
            1 -> {
                jumpSwimSub()
            }
            2 -> {
                fallingSub()
            }
            3 -> {
                climbingSub()
            }
            else -> {
                // Unknown JumpEngine index
            }
        }
        return
        //> .dw OnGroundStateSub
        //> .dw JumpSwimSub
        //> .dw FallingSub
        //> .dw ClimbingSub
    }
    //> NoMoveSub: rts
    return
}

// Decompiled from OnGroundStateSub
fun onGroundStateSub() {
    var temp0: Int = 0
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    //> OnGroundStateSub:
    //> jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
    getPlayerAnimSpeed()
    //> lda Left_Right_Buttons
    //> beq GndMove                ;if left/right controller bits not set, skip instruction
    temp0 = leftRightButtons
    if (leftRightButtons != 0) {
        //> sta PlayerFacingDir        ;otherwise set new facing direction
        playerFacingDir = temp0
    }
    //> GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
    imposeFriction(temp0)
    //> jsr MovePlayerHorizontally ;do another sub to move player horizontally
    movePlayerHorizontally()
    //> sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
    playerXScroll = temp0
    //> rts
    return
}

// Decompiled from FallingSub
fun fallingSub() {
    var temp0: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    var verticalForce by MemoryByte(VerticalForce)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    //> FallingSub:
    //> lda VerticalForceDown
    //> sta VerticalForce      ;dump vertical movement force for falling into main one
    verticalForce = verticalForceDown
    //> jmp LRAir              ;movement force, then skip ahead to process left/right movement
    //> LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
    //> beq JSMove                 ;if not pressing any, skip
    temp0 = leftRightButtons
    if (leftRightButtons != 0) {
        //> jsr ImposeFriction         ;otherwise process horizontal movement
        imposeFriction(temp0)
    }
    //> JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
    movePlayerHorizontally()
    //> sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
    playerXScroll = temp0
    //> lda GameEngineSubroutine
    temp0 = gameEngineSubroutine
    //> cmp #$0b                   ;check for specific routine selected
    //> bne ExitMov1               ;branch if not set to run
    if (!(temp0 - 0x0B == 0)) {
        //  goto ExitMov1
        return
    }
    if (temp0 == 0x0B) {
        //> lda #$28
        temp0 = 0x28
        //> sta VerticalForce          ;otherwise set fractional
        verticalForce = temp0
    }
    //> ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
    //> ExXMove:  rts                         ;and leave
    return
}

// Decompiled from JumpSwimSub
fun jumpSwimSub() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var diffToHaltJump by MemoryByte(DiffToHaltJump)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var jumporiginYPosition by MemoryByte(JumpOrigin_Y_Position)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerXScroll by MemoryByte(Player_X_Scroll)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    var verticalForce by MemoryByte(VerticalForce)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    //> JumpSwimSub:
    //> ldy Player_Y_Speed         ;if player's vertical speed zero
    //> bpl DumpFall               ;or moving downwards, branch to falling
    temp0 = playerYSpeed
    if ((playerYSpeed and 0x80) != 0) {
        //> lda A_B_Buttons
        //> and #A_Button              ;check to see if A button is being pressed
        temp1 = aBButtons and A_Button
        //> and PreviousA_B_Buttons    ;and was pressed in previous frame
        temp2 = temp1 and previousaBButtons
        //> bne ProcSwim               ;if so, branch elsewhere
        temp3 = temp2
        if (temp2 == 0) {
            //> lda JumpOrigin_Y_Position  ;get vertical position player jumped from
            temp3 = jumporiginYPosition
            //> sec
            //> sbc Player_Y_Position      ;subtract current from original vertical coordinate
            temp4 = temp3 - playerYPosition
            temp3 = temp4 and 0xFF
            //> cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
            //> bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
            if (temp3 >= diffToHaltJump) {
            }
        }
    }
    //> DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
    temp3 = verticalForceDown
    //> sta VerticalForce
    verticalForce = temp3
    //> ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
    temp3 = swimmingFlag
    //> beq LRAir                  ;branch ahead to last part
    if (temp3 == 0) {
        //  goto LRAir
        return
    }
    if (temp3 != 0) {
        //> jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
        getPlayerAnimSpeed()
        //> lda Player_Y_Position
        temp3 = playerYPosition
        //> cmp #$14                   ;check vertical position against preset value
        //> bcs LRWater                ;if not yet reached a certain position, branch ahead
        if (!(temp3 >= 0x14)) {
            //> lda #$18
            temp3 = 0x18
            //> sta VerticalForce          ;otherwise set fractional
            verticalForce = temp3
        }
        //> LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
        temp3 = leftRightButtons
        //> beq LRAir                  ;if not pressing any, skip
        if (temp3 == 0) {
            //  goto LRAir
            return
        }
        if (temp3 != 0) {
            //> sta PlayerFacingDir        ;otherwise set facing direction accordingly
            playerFacingDir = temp3
        }
    }
    //> LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
    temp3 = leftRightButtons
    //> beq JSMove                 ;if not pressing any, skip
    if (temp3 != 0) {
        //> jsr ImposeFriction         ;otherwise process horizontal movement
        imposeFriction(temp3)
    }
    //> JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
    movePlayerHorizontally()
    //> sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
    playerXScroll = temp3
    //> lda GameEngineSubroutine
    temp3 = gameEngineSubroutine
    //> cmp #$0b                   ;check for specific routine selected
    //> bne ExitMov1               ;branch if not set to run
    if (!(temp3 - 0x0B == 0)) {
        //  goto ExitMov1
        return
    }
    if (temp3 == 0x0B) {
        //> lda #$28
        temp3 = 0x28
        //> sta VerticalForce          ;otherwise set fractional
        verticalForce = temp3
    }
    //> ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
    //> ExXMove:  rts                         ;and leave
    return
}

// Decompiled from ClimbingSub
fun climbingSub() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var climbSideTimer by MemoryByte(ClimbSideTimer)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYmfDummy by MemoryByte(Player_YMF_Dummy)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val climbAdderHigh by MemoryByteIndexed(ClimbAdderHigh)
    val climbAdderLow by MemoryByteIndexed(ClimbAdderLow)
    //> ClimbingSub:
    //> lda Player_YMF_Dummy
    //> clc                      ;add movement force to dummy variable
    //> adc Player_Y_MoveForce   ;save with carry
    temp0 = playerYmfDummy + playerYMoveforce
    //> sta Player_YMF_Dummy
    playerYmfDummy = temp0 and 0xFF
    //> ldy #$00                 ;set default adder here
    //> lda Player_Y_Speed       ;get player's vertical speed
    //> bpl MoveOnVine           ;if not moving upwards, branch
    temp1 = playerYSpeed
    temp2 = 0x00
    if ((playerYSpeed and 0x80) != 0) {
        //> dey                      ;otherwise set adder to $ff
        temp2 = (temp2 - 1) and 0xFF
    }
    //> MoveOnVine:  sty $00                  ;store adder here
    memory[0x0] = temp2.toUByte()
    //> adc Player_Y_Position    ;add carry to player's vertical position
    temp3 = temp1 + playerYPosition + (if (temp0 > 0xFF) 1 else 0)
    temp1 = temp3 and 0xFF
    //> sta Player_Y_Position    ;and store to move player up or down
    playerYPosition = temp1
    //> lda Player_Y_HighPos
    temp1 = playerYHighpos
    //> adc $00                  ;add carry to player's page location
    temp4 = temp1 + memory[0x0].toInt() + (if (temp3 > 0xFF) 1 else 0)
    temp1 = temp4 and 0xFF
    //> sta Player_Y_HighPos     ;and store
    playerYHighpos = temp1
    //> lda Left_Right_Buttons   ;compare left/right controller bits
    temp1 = leftRightButtons
    //> and Player_CollisionBits ;to collision flag
    temp5 = temp1 and playerCollisionbits
    //> beq InitCSTimer          ;if not set, skip to end
    temp1 = temp5
    if (temp5 != 0) {
        //> ldy ClimbSideTimer       ;otherwise check timer
        temp2 = climbSideTimer
        //> bne ExitCSub             ;if timer not expired, branch to leave
        if (temp2 == 0) {
            //> ldy #$18
            temp2 = 0x18
            //> sty ClimbSideTimer       ;otherwise set timer now
            climbSideTimer = temp2
            //> ldx #$00                 ;set default offset here
            //> ldy PlayerFacingDir      ;get facing direction
            temp2 = playerFacingDir
            //> lsr                      ;move right button controller bit to carry
            temp1 = temp1 shr 1
            //> bcs ClimbFD              ;if controller right pressed, branch ahead
            temp6 = 0x00
            if ((temp1 and 0x01) == 0) {
                //> inx
                temp6 = (temp6 + 1) and 0xFF
                //> inx                      ;otherwise increment offset by 2 bytes
                temp6 = (temp6 + 1) and 0xFF
            }
            //> ClimbFD:     dey                      ;check to see if facing right
            temp2 = (temp2 - 1) and 0xFF
            //> beq CSetFDir             ;if so, branch, do not increment
            if (temp2 != 0) {
                //> inx                      ;otherwise increment by 1 byte
                temp6 = (temp6 + 1) and 0xFF
            }
            //> CSetFDir:    lda Player_X_Position
            temp1 = playerXPosition
            //> clc                      ;add or subtract from player's horizontal position
            //> adc ClimbAdderLow,x      ;using value here as adder and X as offset
            temp7 = temp1 + climbAdderLow[temp6]
            temp1 = temp7 and 0xFF
            //> sta Player_X_Position
            playerXPosition = temp1
            //> lda Player_PageLoc       ;add or subtract carry or borrow using value here
            temp1 = playerPageloc
            //> adc ClimbAdderHigh,x     ;from the player's page location
            temp8 = temp1 + climbAdderHigh[temp6] + (if (temp7 > 0xFF) 1 else 0)
            temp1 = temp8 and 0xFF
            //> sta Player_PageLoc
            playerPageloc = temp1
            //> lda Left_Right_Buttons   ;get left/right controller bits again
            temp1 = leftRightButtons
            //> eor #%00000011           ;invert them and store them while player
            temp9 = temp1 xor 0x03
            //> sta PlayerFacingDir      ;is on vine to face player in opposite direction
            playerFacingDir = temp9
        }
        //> ExitCSub:    rts                      ;then leave
        return
    } else {
        //> InitCSTimer: sta ClimbSideTimer       ;initialize timer here
        climbSideTimer = temp1
        //> rts
        return
    }
}

// Decompiled from PlayerPhysicsSub
fun playerPhysicsSub() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var areaType by MemoryByte(AreaType)
    var diffToHaltJump by MemoryByte(DiffToHaltJump)
    var frictionAdderHigh by MemoryByte(FrictionAdderHigh)
    var frictionAdderLow by MemoryByte(FrictionAdderLow)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var jumporiginYHighpos by MemoryByte(JumpOrigin_Y_HighPos)
    var jumporiginYPosition by MemoryByte(JumpOrigin_Y_Position)
    var jumpSwimTimer by MemoryByte(JumpSwimTimer)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var maximumLeftSpeed by MemoryByte(MaximumLeftSpeed)
    var maximumRightSpeed by MemoryByte(MaximumRightSpeed)
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerSize by MemoryByte(PlayerSize)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerState by MemoryByte(Player_State)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerYmfDummy by MemoryByte(Player_YMF_Dummy)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var runningSpeed by MemoryByte(RunningSpeed)
    var runningTimer by MemoryByte(RunningTimer)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    var verticalForce by MemoryByte(VerticalForce)
    var verticalForceDown by MemoryByte(VerticalForceDown)
    var whirlpoolFlag by MemoryByte(Whirlpool_Flag)
    val climbYMforcedata by MemoryByteIndexed(Climb_Y_MForceData)
    val climbYSpeeddata by MemoryByteIndexed(Climb_Y_SpeedData)
    val fallMForceData by MemoryByteIndexed(FallMForceData)
    val frictionData by MemoryByteIndexed(FrictionData)
    val initMForceData by MemoryByteIndexed(InitMForceData)
    val jumpMForceData by MemoryByteIndexed(JumpMForceData)
    val maxLeftXSpdData by MemoryByteIndexed(MaxLeftXSpdData)
    val maxRightXSpdData by MemoryByteIndexed(MaxRightXSpdData)
    val playerYSpdData by MemoryByteIndexed(PlayerYSpdData)
    //> PlayerPhysicsSub:
    //> lda Player_State          ;check player state
    //> cmp #$03
    //> bne CheckForJumping       ;if not climbing, branch
    temp0 = playerState
    if (playerState == 0x03) {
        //> ldy #$00
        //> lda Up_Down_Buttons       ;get controller bits for up/down
        temp0 = upDownButtons
        //> and Player_CollisionBits  ;check against player's collision detection bits
        temp1 = temp0 and playerCollisionbits
        //> beq ProcClimb             ;if not pressing up or down, branch
        temp0 = temp1
        temp2 = 0x00
        if (temp1 != 0) {
            //> iny
            temp2 = (temp2 + 1) and 0xFF
            //> and #%00001000            ;check for pressing up
            temp3 = temp0 and 0x08
            //> bne ProcClimb
            temp0 = temp3
            if (temp3 == 0) {
                //> iny
                temp2 = (temp2 + 1) and 0xFF
            }
        }
        //> ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
        //> stx Player_Y_MoveForce    ;store as vertical movement force
        playerYMoveforce = climbYMforcedata[temp2]
        //> lda #$08                  ;load default animation timing
        temp0 = 0x08
        //> ldx Climb_Y_SpeedData,y   ;load some other value here
        //> stx Player_Y_Speed        ;store as vertical speed
        playerYSpeed = climbYSpeeddata[temp2]
        //> bmi SetCAnim              ;if climbing down, use default animation timing value
        temp4 = climbYSpeeddata[temp2]
        if ((climbYSpeeddata[temp2] and 0x80) == 0) {
            //> lsr                       ;otherwise divide timer setting by 2
            temp0 = temp0 shr 1
        }
        //> SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
        playerAnimTimerSet = temp0
        //> rts
        return
    } else {
        //> CheckForJumping:
        //> lda JumpspringAnimCtrl    ;if jumpspring animating,
        temp0 = jumpspringAnimCtrl
        //> bne NoJump                ;skip ahead to something else
        if (!(temp0 == 0)) {
            //  goto NoJump
            return
        }
        if (temp0 == 0) {
            //> lda A_B_Buttons           ;check for A button press
            temp0 = aBButtons
            //> and #A_Button
            temp5 = temp0 and A_Button
            //> beq NoJump                ;if not, branch to something else
            if (temp5 == 0) {
                //  goto NoJump
                return
            }
            temp0 = temp5
            if (temp5 != 0) {
                //> and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
                temp6 = temp0 and previousaBButtons
                //> beq ProcJumping
                temp0 = temp6
                if (temp6 != 0) {
                }
            }
        }
    }
    //> NoJump: jmp X_Physics             ;otherwise, jump to something else
    //> ProcJumping:
    //> lda Player_State           ;check player state
    temp0 = playerState
    //> beq InitJS                 ;if on the ground, branch
    if (temp0 != 0) {
        //> lda SwimmingFlag           ;if swimming flag not set, jump to do something else
        temp0 = swimmingFlag
        //> beq NoJump                 ;to prevent midair jumping, otherwise continue
        if (temp0 == 0) {
            //  goto NoJump
            return
        }
        //> lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
        temp0 = jumpSwimTimer
        //> bne InitJS
        if (temp0 == 0) {
            //> lda Player_Y_Speed         ;check player's vertical speed
            temp0 = playerYSpeed
            //> bpl InitJS                 ;if player's vertical speed motionless or down, branch
            if ((temp0 and 0x80) != 0) {
            }
        }
    } else {
        //> InitJS:    lda #$20                   ;set jump/swim timer
        temp0 = 0x20
        //> sta JumpSwimTimer
        jumpSwimTimer = temp0
        //> ldy #$00                   ;initialize vertical force and dummy variable
        temp2 = 0x00
        //> sty Player_YMF_Dummy
        playerYmfDummy = temp2
        //> sty Player_Y_MoveForce
        playerYMoveforce = temp2
        //> lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
        temp0 = playerYHighpos
        //> sta JumpOrigin_Y_HighPos   ;and store them next to each other here
        jumporiginYHighpos = temp0
        //> lda Player_Y_Position
        temp0 = playerYPosition
        //> sta JumpOrigin_Y_Position
        jumporiginYPosition = temp0
        //> lda #$01                   ;set player state to jumping/swimming
        temp0 = 0x01
        //> sta Player_State
        playerState = temp0
        //> lda Player_XSpeedAbsolute  ;check value related to walking/running speed
        temp0 = playerXspeedabsolute
        //> cmp #$09
        //> bcc ChkWtr                 ;branch if below certain values, increment Y
        if (temp0 >= 0x09) {
            //> iny                        ;for each amount equal or exceeded
            temp2 = (temp2 + 1) and 0xFF
            //> cmp #$10
            //> bcc ChkWtr
            if (temp0 >= 0x10) {
                //> iny
                temp2 = (temp2 + 1) and 0xFF
                //> cmp #$19
                //> bcc ChkWtr
                if (temp0 >= 0x19) {
                    //> iny
                    temp2 = (temp2 + 1) and 0xFF
                    //> cmp #$1c
                    //> bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
                    if (temp0 >= 0x1C) {
                        //> iny
                        temp2 = (temp2 + 1) and 0xFF
                    }
                }
            }
        }
        //> ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
        temp0 = 0x01
        //> sta DiffToHaltJump
        diffToHaltJump = temp0
        //> lda SwimmingFlag           ;if swimming flag disabled, branch
        temp0 = swimmingFlag
        //> beq GetYPhy
        if (temp0 != 0) {
            //> ldy #$05                   ;otherwise set Y to 5, range is 5-6
            temp2 = 0x05
            //> lda Whirlpool_Flag         ;if whirlpool flag not set, branch
            temp0 = whirlpoolFlag
            //> beq GetYPhy
            if (temp0 != 0) {
                //> iny                        ;otherwise increment to 6
                temp2 = (temp2 + 1) and 0xFF
            }
        }
        //> GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
        temp0 = jumpMForceData[temp2]
        //> sta VerticalForce          ;data here
        verticalForce = temp0
        //> lda FallMForceData,y
        temp0 = fallMForceData[temp2]
        //> sta VerticalForceDown
        verticalForceDown = temp0
        //> lda InitMForceData,y
        temp0 = initMForceData[temp2]
        //> sta Player_Y_MoveForce
        playerYMoveforce = temp0
        //> lda PlayerYSpdData,y
        temp0 = playerYSpdData[temp2]
        //> sta Player_Y_Speed
        playerYSpeed = temp0
        //> lda SwimmingFlag           ;if swimming flag disabled, branch
        temp0 = swimmingFlag
        //> beq PJumpSnd
        if (temp0 != 0) {
            //> lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
            temp0 = Sfx_EnemyStomp
            //> sta Square1SoundQueue      ;square 1's sfx queue
            square1SoundQueue = temp0
            //> lda Player_Y_Position
            temp0 = playerYPosition
            //> cmp #$14                   ;check vertical low byte of player position
            //> bcs X_Physics              ;if below a certain point, branch
            if (!(temp0 >= 0x14)) {
                //> lda #$00                   ;otherwise reset player's vertical speed
                temp0 = 0x00
                //> sta Player_Y_Speed         ;and jump to something else to keep player
                playerYSpeed = temp0
                //> jmp X_Physics              ;from swimming above water level
            }
        } else {
            //> PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
            temp0 = Sfx_BigJump
            //> ldy PlayerSize             ;is mario big?
            temp2 = playerSize
            //> beq SJumpSnd
            if (temp2 != 0) {
                //> lda #Sfx_SmallJump         ;if not, load small mario's jump sound
                temp0 = Sfx_SmallJump
            }
            //> SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
            square1SoundQueue = temp0
        }
    }
    //> X_Physics: ldy #$00
    temp2 = 0x00
    //> sty $00                    ;init value here
    memory[0x0] = temp2.toUByte()
    //> lda Player_State           ;if mario is on the ground, branch
    temp0 = playerState
    //> beq ProcPRun
    if (temp0 != 0) {
        //> lda Player_XSpeedAbsolute  ;check something that seems to be related
        temp0 = playerXspeedabsolute
        //> cmp #$19                   ;to mario's speed
        //> bcs GetXPhy                ;if =>$19 branch here
        if (!(temp0 >= 0x19)) {
            //> bcc ChkRFast               ;if not branch elsewhere
            if (temp0 >= 0x19) {
            }
        }
    }
    //> ProcPRun:  iny                        ;if mario on the ground, increment Y
    temp2 = (temp2 + 1) and 0xFF
    //> lda AreaType               ;check area type
    temp0 = areaType
    //> beq ChkRFast               ;if water type, branch
    if (temp0 != 0) {
        //> dey                        ;decrement Y by default for non-water type area
        temp2 = (temp2 - 1) and 0xFF
        //> lda Left_Right_Buttons     ;get left/right controller bits
        temp0 = leftRightButtons
        //> cmp Player_MovingDir       ;check against moving direction
        //> bne ChkRFast               ;if controller bits <> moving direction, skip this part
        if (temp0 == playerMovingdir) {
            //> lda A_B_Buttons            ;check for b button pressed
            temp0 = aBButtons
            //> and #B_Button
            temp7 = temp0 and B_Button
            //> bne SetRTmr                ;if pressed, skip ahead to set timer
            temp0 = temp7
            if (temp7 == 0) {
                //> lda RunningTimer           ;check for running timer set
                temp0 = runningTimer
                //> bne GetXPhy                ;if set, branch
                if (temp0 == 0) {
                }
            }
        }
    }
    //> ChkRFast:  iny                        ;if running timer not set or level type is water,
    temp2 = (temp2 + 1) and 0xFF
    //> inc $00                    ;increment Y again and temp variable in memory
    memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
    //> lda RunningSpeed
    temp0 = runningSpeed
    //> bne FastXSp                ;if running speed set here, branch
    if (!(temp0 == 0)) {
        //  goto FastXSp
        return
    }
    if (temp0 == 0) {
        //> lda Player_XSpeedAbsolute
        temp0 = playerXspeedabsolute
        //> cmp #$21                   ;otherwise check player's walking/running speed
        //> bcc GetXPhy                ;if less than a certain amount, branch ahead
        if (temp0 >= 0x21) {
        }
    }
    //> FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
    memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
    //> jmp GetXPhy                ;and jump ahead
    //> SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
    temp0 = 0x0A
    //> sta RunningTimer
    runningTimer = temp0
    //> GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
    temp0 = maxLeftXSpdData[temp2]
    //> sta MaximumLeftSpeed
    maximumLeftSpeed = temp0
    //> lda GameEngineSubroutine   ;check for specific routine running
    temp0 = gameEngineSubroutine
    //> cmp #$07                   ;(player entrance)
    //> bne GetXPhy2               ;if not running, skip and use old value of Y
    if (temp0 == 0x07) {
        //> ldy #$03                   ;otherwise set Y to 3
        temp2 = 0x03
    }
    //> GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
    temp0 = maxRightXSpdData[temp2]
    //> sta MaximumRightSpeed
    maximumRightSpeed = temp0
    //> ldy $00                    ;get other value in memory
    temp2 = memory[0x0].toInt()
    //> lda FrictionData,y         ;get value using value in memory as offset
    temp0 = frictionData[temp2]
    //> sta FrictionAdderLow
    frictionAdderLow = temp0
    //> lda #$00
    temp0 = 0x00
    //> sta FrictionAdderHigh      ;init something here
    frictionAdderHigh = temp0
    //> lda PlayerFacingDir
    temp0 = playerFacingDir
    //> cmp Player_MovingDir       ;check facing direction against moving direction
    //> beq ExitPhy                ;if the same, branch to leave
    if (temp0 != playerMovingdir) {
        //> asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
        frictionAdderLow = (frictionAdderLow shl 1) and 0xFF
        //> rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
        frictionAdderHigh = (frictionAdderHigh shl 1) and 0xFE or if ((frictionAdderLow and 0x80) != 0) 1 else 0
    }
    //> ExitPhy:   rts                        ;and then leave
    return
}

// Decompiled from GetPlayerAnimSpeed
fun getPlayerAnimSpeed() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerXMoveforce by MemoryByte(Player_X_MoveForce)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var runningSpeed by MemoryByte(RunningSpeed)
    var savedJoypadBits by MemoryByte(SavedJoypadBits)
    val playerAnimTmrData by MemoryByteIndexed(PlayerAnimTmrData)
    //> GetPlayerAnimSpeed:
    //> ldy #$00                   ;initialize offset in Y
    //> lda Player_XSpeedAbsolute  ;check player's walking/running speed
    //> cmp #$1c                   ;against preset amount
    //> bcs SetRunSpd              ;if greater than a certain amount, branch ahead
    if (playerXspeedabsolute >= 0x1C) {
        //  goto SetRunSpd
        return
    }
    temp0 = playerXspeedabsolute
    temp1 = 0x00
    if (!(playerXspeedabsolute >= 0x1C)) {
        //> iny                        ;otherwise increment Y
        temp1 = (temp1 + 1) and 0xFF
        //> cmp #$0e                   ;compare against lower amount
        //> bcs ChkSkid                ;if greater than this but not greater than first, skip increment
        if (!(temp0 >= 0x0E)) {
            //> iny                        ;otherwise increment Y again
            temp1 = (temp1 + 1) and 0xFF
        }
        //> ChkSkid:    lda SavedJoypadBits        ;get controller bits
        temp0 = savedJoypadBits
        //> and #%01111111             ;mask out A button
        temp2 = temp0 and 0x7F
        //> beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
        temp0 = temp2
        if (temp2 != 0) {
            //> and #$03                   ;mask out all others except left and right
            temp3 = temp0 and 0x03
            //> cmp Player_MovingDir       ;check against moving direction
            //> bne ProcSkid               ;if left/right controller bits <> moving direction, branch
            temp0 = temp3
            if (temp3 == playerMovingdir) {
                //> lda #$00                   ;otherwise set zero value here
                temp0 = 0x00
            }
        } else {
            //> SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
            temp0 = playerAnimTmrData[temp1]
            //> sta PlayerAnimTimerSet
            playerAnimTimerSet = temp0
            //> rts
            return
        }
    }
    //> SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
    runningSpeed = temp0
    //> jmp SetAnimSpd
    //> ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
    temp0 = playerXspeedabsolute
    //> cmp #$0b                   ;against one last amount
    //> bcs SetAnimSpd             ;if greater than this amount, branch
    if (!(temp0 >= 0x0B)) {
        //> lda PlayerFacingDir
        temp0 = playerFacingDir
        //> sta Player_MovingDir       ;otherwise use facing direction to set moving direction
        playerMovingdir = temp0
        //> lda #$00
        temp0 = 0x00
        //> sta Player_X_Speed         ;nullify player's horizontal speed
        playerXSpeed = temp0
        //> sta Player_X_MoveForce     ;and dummy variable for player
        playerXMoveforce = temp0
    }
}

// Decompiled from ImposeFriction
fun imposeFriction(A: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var frictionAdderHigh by MemoryByte(FrictionAdderHigh)
    var frictionAdderLow by MemoryByte(FrictionAdderLow)
    var maximumLeftSpeed by MemoryByte(MaximumLeftSpeed)
    var maximumRightSpeed by MemoryByte(MaximumRightSpeed)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerXMoveforce by MemoryByte(Player_X_MoveForce)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    //> ImposeFriction:
    //> and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
    temp0 = A and playerCollisionbits
    //> cmp #$00                  ;then compare to zero (this instruction is redundant)
    //> bne JoypFrict             ;if any bits set, branch to next part
    temp1 = temp0
    if (temp0 == 0) {
        //> lda Player_X_Speed
        temp1 = playerXSpeed
        //> beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
        if (temp1 != 0) {
            //> bpl RghtFrict             ;if player moving to the right, branch to slow
            if ((temp1 and 0x80) != 0) {
                //> bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
                if ((temp1 and 0x80) == 0) {
                }
            }
        } else {
            //> SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
            playerXspeedabsolute = temp1
            //> rts
            return A
        }
    }
    //> JoypFrict: lsr                       ;put right controller bit into carry
    temp1 = temp1 shr 1
    //> bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
    if ((temp1 and 0x01) != 0) {
        //> LeftFrict: lda Player_X_MoveForce    ;load value set here
        temp1 = playerXMoveforce
        //> clc
        //> adc FrictionAdderLow      ;add to it another value set here
        temp2 = temp1 + frictionAdderLow
        temp1 = temp2 and 0xFF
        //> sta Player_X_MoveForce    ;store here
        playerXMoveforce = temp1
        //> lda Player_X_Speed
        temp1 = playerXSpeed
        //> adc FrictionAdderHigh     ;add value plus carry to horizontal speed
        temp3 = temp1 + frictionAdderHigh + (if (temp2 > 0xFF) 1 else 0)
        temp1 = temp3 and 0xFF
        //> sta Player_X_Speed        ;set as new horizontal speed
        playerXSpeed = temp1
        //> cmp MaximumRightSpeed     ;compare against maximum value for right movement
        //> bmi XSpdSign              ;if horizontal speed greater negatively, branch
        if (!(temp1 - maximumRightSpeed < 0)) {
            //> lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
            temp1 = maximumRightSpeed
            //> sta Player_X_Speed        ;thus slowing the player's left movement down
            playerXSpeed = temp1
            //> jmp SetAbsSpd             ;skip to the end
        }
    } else {
        //> RghtFrict: lda Player_X_MoveForce    ;load value set here
        temp1 = playerXMoveforce
        //> sec
        //> sbc FrictionAdderLow      ;subtract from it another value set here
        temp4 = temp1 - frictionAdderLow
        temp1 = temp4 and 0xFF
        //> sta Player_X_MoveForce    ;store here
        playerXMoveforce = temp1
        //> lda Player_X_Speed
        temp1 = playerXSpeed
        //> sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
        temp5 = temp1 - frictionAdderHigh - (if (temp4 >= 0) 0 else 1)
        temp1 = temp5 and 0xFF
        //> sta Player_X_Speed        ;set as new horizontal speed
        playerXSpeed = temp1
        //> cmp MaximumLeftSpeed      ;compare against maximum value for left movement
        //> bpl XSpdSign              ;if horizontal speed greater positively, branch
        if (temp1 - maximumLeftSpeed < 0) {
            //> lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
            temp1 = maximumLeftSpeed
            //> sta Player_X_Speed        ;thus slowing the player's right movement down
            playerXSpeed = temp1
        }
        //> XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
        //> bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
        if (temp1 < 0) {
            //> eor #$ff
            temp6 = temp1 xor 0xFF
            //> clc                       ;otherwise get two's compliment to get absolute
            //> adc #$01                  ;unsigned walking/running speed
            temp7 = temp6 + 0x01
            temp1 = temp7 and 0xFF
        }
    }
    return A
}

// Decompiled from ProcFireball_Bubble
fun procfireballBubble() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var areaType by MemoryByte(AreaType)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var fireballCounter by MemoryByte(FireballCounter)
    var fireballThrowingTimer by MemoryByte(FireballThrowingTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    var playerStatus by MemoryByte(PlayerStatus)
    var playerState by MemoryByte(Player_State)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val fireballState by MemoryByteIndexed(Fireball_State)
    //> ProcFireball_Bubble:
    //> lda PlayerStatus           ;check player's status
    //> cmp #$02
    //> bcc ProcAirBubbles         ;if not fiery, branch
    temp0 = playerStatus
    if (playerStatus >= 0x02) {
        //> lda A_B_Buttons
        temp0 = aBButtons
        //> and #B_Button              ;check for b button pressed
        temp1 = temp0 and B_Button
        //> beq ProcFireballs          ;branch if not pressed
        temp0 = temp1
        if (temp1 != 0) {
            //> and PreviousA_B_Buttons
            temp2 = temp0 and previousaBButtons
            //> bne ProcFireballs          ;if button pressed in previous frame, branch
            temp0 = temp2
            if (temp2 == 0) {
                //> lda FireballCounter        ;load fireball counter
                temp0 = fireballCounter
                //> and #%00000001             ;get LSB and use as offset for buffer
                temp3 = temp0 and 0x01
                //> tax
                //> lda Fireball_State,x       ;load fireball state
                temp0 = fireballState[temp3]
                //> bne ProcFireballs          ;if not inactive, branch
                temp4 = temp3
                if (temp0 == 0) {
                    //> ldy Player_Y_HighPos       ;if player too high or too low, branch
                    //> dey
                    playerYHighpos = (playerYHighpos - 1) and 0xFF
                    //> bne ProcFireballs
                    temp5 = playerYHighpos
                    if (playerYHighpos == 0) {
                        //> lda CrouchingFlag          ;if player crouching, branch
                        temp0 = crouchingFlag
                        //> bne ProcFireballs
                        if (temp0 == 0) {
                            //> lda Player_State           ;if player's state = climbing, branch
                            temp0 = playerState
                            //> cmp #$03
                            //> beq ProcFireballs
                            if (temp0 != 0x03) {
                                //> lda #Sfx_Fireball          ;play fireball sound effect
                                temp0 = Sfx_Fireball
                                //> sta Square1SoundQueue
                                square1SoundQueue = temp0
                                //> lda #$02                   ;load state
                                temp0 = 0x02
                                //> sta Fireball_State,x
                                fireballState[temp4] = temp0
                                //> ldy PlayerAnimTimerSet     ;copy animation frame timer setting
                                temp5 = playerAnimTimerSet
                                //> sty FireballThrowingTimer  ;into fireball throwing timer
                                fireballThrowingTimer = temp5
                                //> dey
                                temp5 = (temp5 - 1) and 0xFF
                                //> sty PlayerAnimTimer        ;decrement and store in player's animation timer
                                playerAnimTimer = temp5
                                //> inc FireballCounter        ;increment fireball counter
                                fireballCounter = (fireballCounter + 1) and 0xFF
                            }
                        }
                    }
                }
            }
        }
        //> ProcFireballs:
        //> ldx #$00
        temp4 = 0x00
        //> jsr FireballObjCore  ;process first fireball object
        fireballObjCore(temp4)
        //> ldx #$01
        temp4 = 0x01
        //> jsr FireballObjCore  ;process second fireball object, then do air bubbles
        fireballObjCore(temp4)
    }
    //> ProcAirBubbles:
    //> lda AreaType                ;if not water type level, skip the rest of this
    temp0 = areaType
    //> bne BublExit
    if (temp0 == 0) {
        //> ldx #$02                    ;otherwise load counter and use as offset
        temp4 = 0x02
        do {
            //> BublLoop: stx ObjectOffset            ;store offset
            objectOffset = temp4
            //> jsr BubbleCheck             ;check timers and coordinates, create air bubble
            bubbleCheck(temp4)
            //> jsr RelativeBubblePosition  ;get relative coordinates
            relativeBubblePosition()
            //> jsr GetBubbleOffscreenBits  ;get offscreen information
            getBubbleOffscreenBits()
            //> jsr DrawBubble              ;draw the air bubble
            drawBubble(temp4)
            //> dex
            temp4 = (temp4 - 1) and 0xFF
            //> bpl BublLoop                ;do this until all three are handled
        } while ((temp4 and 0x80) == 0)
    }
    //> BublExit: rts                         ;then leave
    return
}

// Decompiled from FireballObjCore
fun fireballObjCore(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var fballOffscreenbits by MemoryByte(FBall_OffscreenBits)
    var fireballRelXpos by MemoryByte(Fireball_Rel_XPos)
    var fireballRelYpos by MemoryByte(Fireball_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val altSprdataoffset by MemoryByteIndexed(Alt_SprDataOffset)
    val fballSprdataoffset by MemoryByteIndexed(FBall_SprDataOffset)
    val fireballXSpdData by MemoryByteIndexed(FireballXSpdData)
    val fireballBoundboxctrl by MemoryByteIndexed(Fireball_BoundBoxCtrl)
    val fireballPageloc by MemoryByteIndexed(Fireball_PageLoc)
    val fireballState by MemoryByteIndexed(Fireball_State)
    val fireballXPosition by MemoryByteIndexed(Fireball_X_Position)
    val fireballXSpeed by MemoryByteIndexed(Fireball_X_Speed)
    val fireballYHighpos by MemoryByteIndexed(Fireball_Y_HighPos)
    val fireballYPosition by MemoryByteIndexed(Fireball_Y_Position)
    val fireballYSpeed by MemoryByteIndexed(Fireball_Y_Speed)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> FireballObjCore:
    //> stx ObjectOffset             ;store offset as current object
    objectOffset = X
    //> lda Fireball_State,x         ;check for d7 = 1
    //> asl
    //> bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
    if ((fireballState[X] and 0x80) != 0) {
        //  goto FireballExplosion
        return
    }
    temp0 = (fireballState[X] shl 1) and 0xFF
    if ((fireballState[X] and 0x80) == 0) {
        //> ldy Fireball_State,x         ;if fireball inactive, branch to leave
        //> beq NoFBall
        temp1 = fireballState[X]
        if (fireballState[X] != 0) {
            //> dey                          ;if fireball state set to 1, skip this part and just run it
            temp1 = (temp1 - 1) and 0xFF
            //> beq RunFB
            if (temp1 != 0) {
                //> lda Player_X_Position        ;get player's horizontal position
                temp0 = playerXPosition
                //> adc #$04                     ;add four pixels and store as fireball's horizontal position
                temp2 = temp0 + 0x04 + (if ((fireballState[X] and 0x80) != 0) 1 else 0)
                temp0 = temp2 and 0xFF
                //> sta Fireball_X_Position,x
                fireballXPosition[X] = temp0
                //> lda Player_PageLoc           ;get player's page location
                temp0 = playerPageloc
                //> adc #$00                     ;add carry and store as fireball's page location
                temp3 = temp0 + (if (temp2 > 0xFF) 1 else 0)
                temp0 = temp3 and 0xFF
                //> sta Fireball_PageLoc,x
                fireballPageloc[X] = temp0
                //> lda Player_Y_Position        ;get player's vertical position and store
                temp0 = playerYPosition
                //> sta Fireball_Y_Position,x
                fireballYPosition[X] = temp0
                //> lda #$01                     ;set high byte of vertical position
                temp0 = 0x01
                //> sta Fireball_Y_HighPos,x
                fireballYHighpos[X] = temp0
                //> ldy PlayerFacingDir          ;get player's facing direction
                temp1 = playerFacingDir
                //> dey                          ;decrement to use as offset here
                temp1 = (temp1 - 1) and 0xFF
                //> lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
                temp0 = fireballXSpdData[temp1]
                //> sta Fireball_X_Speed,x
                fireballXSpeed[X] = temp0
                //> lda #$04                     ;set vertical speed of fireball
                temp0 = 0x04
                //> sta Fireball_Y_Speed,x
                fireballYSpeed[X] = temp0
                //> lda #$07
                temp0 = 0x07
                //> sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
                fireballBoundboxctrl[X] = temp0
                //> dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
                fireballState[X] = (fireballState[X] - 1) and 0xFF
            }
            //> RunFB:   txa                          ;add 7 to offset to use
            //> clc                          ;as fireball offset for next routines
            //> adc #$07
            temp4 = X + 0x07
            temp0 = temp4 and 0xFF
            //> tax
            //> lda #$50                     ;set downward movement force here
            temp0 = 0x50
            //> sta $00
            memory[0x0] = temp0.toUByte()
            //> lda #$03                     ;set maximum speed here
            temp0 = 0x03
            //> sta $02
            memory[0x2] = temp0.toUByte()
            //> lda #$00
            temp0 = 0x00
            //> jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
            imposeGravity(temp0, temp0)
            //> jsr MoveObjectHorizontally   ;do another sub to move it horizontally
            moveObjectHorizontally(temp0)
            //> ldx ObjectOffset             ;return fireball offset to X
            //> jsr RelativeFireballPosition ;get relative coordinates
            relativeFireballPosition()
            //> jsr GetFireballOffscreenBits ;get offscreen information
            getFireballOffscreenBits()
            //> jsr GetFireballBoundBox      ;get bounding box coordinates
            getFireballBoundBox(objectOffset)
            //> jsr FireballBGCollision      ;do fireball to background collision detection
            fireballBGCollision(objectOffset)
            //> lda FBall_OffscreenBits      ;get fireball offscreen bits
            temp0 = fballOffscreenbits
            //> and #%11001100               ;mask out certain bits
            temp5 = temp0 and 0xCC
            //> bne EraseFB                  ;if any bits still set, branch to kill fireball
            temp0 = temp5
            temp6 = objectOffset
            if (temp5 == 0) {
                //> jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
                fireballEnemyCollision(temp6)
                //> jmp DrawFireball             ;draw fireball appropriately and leave
            }
            //> EraseFB: lda #$00                     ;erase fireball state
            temp0 = 0x00
            //> sta Fireball_State,x
            fireballState[temp6] = temp0
        }
        //> NoFBall: rts                          ;leave
        return
    } else {
        //> FireballExplosion:
        //> jsr RelativeFireballPosition
        relativeFireballPosition()
        //> jmp DrawExplosion_Fireball
    }
    //> DrawFireball:
    //> ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
    temp1 = fballSprdataoffset[temp6]
    //> lda Fireball_Rel_YPos      ;get relative vertical coordinate
    temp0 = fireballRelYpos
    //> sta Sprite_Y_Position,y    ;store as sprite Y coordinate
    spriteYPosition[temp1] = temp0
    //> lda Fireball_Rel_XPos      ;get relative horizontal coordinate
    temp0 = fireballRelXpos
    //> sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
    spriteXPosition[temp1] = temp0
    //> DrawExplosion_Fireball:
    //> ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
    temp1 = altSprdataoffset[temp6]
    //> lda Fireball_State,x     ;load fireball state
    temp0 = fireballState[temp6]
    //> inc Fireball_State,x     ;increment state for next frame
    fireballState[temp6] = (fireballState[temp6] + 1) and 0xFF
    //> lsr                      ;divide by 2
    temp0 = temp0 shr 1
    //> and #%00000111           ;mask out all but d3-d1
    temp7 = temp0 and 0x07
    //> cmp #$03                 ;check to see if time to kill fireball
    //> bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
    temp0 = temp7
    if (!(temp7 >= 0x03)) {
    }
    //> KillFireBall:
    //> lda #$00                    ;clear fireball state to kill it
    temp0 = 0x00
    //> sta Fireball_State,x
    fireballState[temp6] = temp0
    //> rts
    return
}

// Decompiled from BubbleCheck
fun bubbleCheck(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var airBubbleTimer by MemoryByte(AirBubbleTimer)
    val bubbleMforcedata by MemoryByteIndexed(Bubble_MForceData)
    val bubbleYmfDummy by MemoryByteIndexed(Bubble_YMF_Dummy)
    val bubbleYPosition by MemoryByteIndexed(Bubble_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> BubbleCheck:
    //> lda PseudoRandomBitReg+1,x  ;get part of LSFR
    //> and #$01
    temp0 = pseudoRandomBitReg[1 + X] and 0x01
    //> sta $07                     ;store pseudorandom bit here
    memory[0x7] = temp0.toUByte()
    //> lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
    //> cmp #$f8                    ;if offscreen coordinate not set,
    //> bne MoveBubl                ;branch to move air bubble
    temp1 = bubbleYPosition[X]
    if (bubbleYPosition[X] == 0xF8) {
        //> lda AirBubbleTimer          ;if air bubble timer not expired,
        temp1 = airBubbleTimer
        //> bne ExitBubl                ;branch to leave, otherwise create new air bubble
        if (temp1 == 0) {
        } else {
            //> ExitBubl: rts                      ;leave
            return
        }
    }
    //> MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
    //> lda Bubble_YMF_Dummy,x
    temp1 = bubbleYmfDummy[X]
    //> sec                      ;subtract pseudorandom amount from dummy variable
    //> sbc Bubble_MForceData,y
    temp2 = temp1 - bubbleMforcedata[memory[0x7].toInt()]
    temp1 = temp2 and 0xFF
    //> sta Bubble_YMF_Dummy,x   ;save dummy variable
    bubbleYmfDummy[X] = temp1
    //> lda Bubble_Y_Position,x
    temp1 = bubbleYPosition[X]
    //> sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
    temp3 = temp1 - (if (temp2 >= 0) 0 else 1)
    temp1 = temp3 and 0xFF
    //> cmp #$20                 ;if below the status bar,
    //> bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
    temp4 = memory[0x7].toInt()
    if (!(temp1 >= 0x20)) {
        //> lda #$f8                 ;otherwise set offscreen coordinate
        temp1 = 0xF8
    }
    //> Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
    bubbleYPosition[X] = temp1
    // Fall-through tail call to setupBubble
    setupBubble(X)
}

// Decompiled from SetupBubble
fun setupBubble(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var airBubbleTimer by MemoryByte(AirBubbleTimer)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val bubbleTimerData by MemoryByteIndexed(BubbleTimerData)
    val bubbleMforcedata by MemoryByteIndexed(Bubble_MForceData)
    val bubblePageloc by MemoryByteIndexed(Bubble_PageLoc)
    val bubbleXPosition by MemoryByteIndexed(Bubble_X_Position)
    val bubbleYmfDummy by MemoryByteIndexed(Bubble_YMF_Dummy)
    val bubbleYHighpos by MemoryByteIndexed(Bubble_Y_HighPos)
    val bubbleYPosition by MemoryByteIndexed(Bubble_Y_Position)
    //> SetupBubble:
    //> ldy #$00                 ;load default value here
    //> lda PlayerFacingDir      ;get player's facing direction
    //> lsr                      ;move d0 to carry
    playerFacingDir = playerFacingDir shr 1
    //> bcc PosBubl              ;branch to use default value if facing left
    temp0 = playerFacingDir
    temp1 = 0x00
    if ((playerFacingDir and 0x01) != 0) {
        //> ldy #$08                 ;otherwise load alternate value here
        temp1 = 0x08
    }
    //> PosBubl:  tya                      ;use value loaded as adder
    //> adc Player_X_Position    ;add to player's horizontal position
    temp2 = temp1 + playerXPosition + (if ((playerFacingDir and 0x01) != 0) 1 else 0)
    temp0 = temp2 and 0xFF
    //> sta Bubble_X_Position,x  ;save as horizontal position for airbubble
    bubbleXPosition[X] = temp0
    //> lda Player_PageLoc
    temp0 = playerPageloc
    //> adc #$00                 ;add carry to player's page location
    temp3 = temp0 + (if (temp2 > 0xFF) 1 else 0)
    temp0 = temp3 and 0xFF
    //> sta Bubble_PageLoc,x     ;save as page location for airbubble
    bubblePageloc[X] = temp0
    //> lda Player_Y_Position
    temp0 = playerYPosition
    //> clc                      ;add eight pixels to player's vertical position
    //> adc #$08
    temp4 = temp0 + 0x08
    temp0 = temp4 and 0xFF
    //> sta Bubble_Y_Position,x  ;save as vertical position for air bubble
    bubbleYPosition[X] = temp0
    //> lda #$01
    temp0 = 0x01
    //> sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
    bubbleYHighpos[X] = temp0
    //> ldy $07                  ;get pseudorandom bit, use as offset
    temp1 = memory[0x7].toInt()
    //> lda BubbleTimerData,y    ;get data for air bubble timer
    temp0 = bubbleTimerData[temp1]
    //> sta AirBubbleTimer       ;set air bubble timer
    airBubbleTimer = temp0
    //> MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
    temp1 = memory[0x7].toInt()
    //> lda Bubble_YMF_Dummy,x
    temp0 = bubbleYmfDummy[X]
    //> sec                      ;subtract pseudorandom amount from dummy variable
    //> sbc Bubble_MForceData,y
    temp5 = temp0 - bubbleMforcedata[temp1]
    temp0 = temp5 and 0xFF
    //> sta Bubble_YMF_Dummy,x   ;save dummy variable
    bubbleYmfDummy[X] = temp0
    //> lda Bubble_Y_Position,x
    temp0 = bubbleYPosition[X]
    //> sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
    temp6 = temp0 - (if (temp5 >= 0) 0 else 1)
    temp0 = temp6 and 0xFF
    //> cmp #$20                 ;if below the status bar,
    //> bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
    if (!(temp0 >= 0x20)) {
        //> lda #$f8                 ;otherwise set offscreen coordinate
        temp0 = 0xF8
    }
    //> Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
    bubbleYPosition[X] = temp0
    //> ExitBubl: rts                      ;leave
    return
}

// Decompiled from RunGameTimer
fun runGameTimer() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var gameTimerCtrlTimer by MemoryByte(GameTimerCtrlTimer)
    var gameTimerExpiredFlag by MemoryByte(GameTimerExpiredFlag)
    var operMode by MemoryByte(OperMode)
    var playerStatus by MemoryByte(PlayerStatus)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    //> RunGameTimer:
    //> lda OperMode               ;get primary mode of operation
    //> beq ExGTimer               ;branch to leave if in title screen mode
    temp0 = operMode
    if (operMode != 0) {
        //> lda GameEngineSubroutine
        temp0 = gameEngineSubroutine
        //> cmp #$08                   ;if routine number less than eight running,
        //> bcc ExGTimer               ;branch to leave
        if (temp0 >= 0x08) {
            //> cmp #$0b                   ;if running death routine,
            //> beq ExGTimer               ;branch to leave
            if (temp0 != 0x0B) {
                //> lda Player_Y_HighPos
                temp0 = playerYHighpos
                //> cmp #$02                   ;if player below the screen,
                //> bcs ExGTimer               ;branch to leave regardless of level type
                if (!(temp0 >= 0x02)) {
                    //> lda GameTimerCtrlTimer     ;if game timer control not yet expired,
                    temp0 = gameTimerCtrlTimer
                    //> bne ExGTimer               ;branch to leave
                    if (temp0 == 0) {
                        //> lda GameTimerDisplay
                        temp0 = gameTimerDisplay[0]
                        //> ora GameTimerDisplay+1     ;otherwise check game timer digits
                        temp1 = temp0 or gameTimerDisplay[1]
                        //> ora GameTimerDisplay+2
                        temp2 = temp1 or gameTimerDisplay[2]
                        //> beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
                        temp0 = temp2
                        if (temp2 != 0) {
                            //> ldy GameTimerDisplay       ;otherwise check first digit
                            //> dey                        ;if first digit not on 1,
                            temp3 = gameTimerDisplay[0]
                            temp3 = (temp3 - 1) and 0xFF
                            //> bne ResGTCtrl              ;branch to reset game timer control
                            if (!(temp3 == 0)) {
                                //  goto ResGTCtrl
                                return
                            }
                            if (temp3 == 0) {
                                //> lda GameTimerDisplay+1     ;otherwise check second and third digits
                                temp0 = gameTimerDisplay[1]
                                //> ora GameTimerDisplay+2
                                temp4 = temp0 or gameTimerDisplay[2]
                                //> bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
                                if (!(temp4 == 0)) {
                                    //  goto ResGTCtrl
                                    return
                                }
                                temp0 = temp4
                                if (temp4 == 0) {
                                    //> lda #TimeRunningOutMusic
                                    temp0 = TimeRunningOutMusic
                                    //> sta EventMusicQueue        ;otherwise load time running out music
                                    eventMusicQueue = temp0
                                }
                            }
                            //> ResGTCtrl: lda #$18                   ;reset game timer control
                            temp0 = 0x18
                            //> sta GameTimerCtrlTimer
                            gameTimerCtrlTimer = temp0
                            //> ldy #$23                   ;set offset for last digit
                            temp3 = 0x23
                            //> lda #$ff                   ;set value to decrement game timer digit
                            temp0 = 0xFF
                            //> sta DigitModifier+5
                            digitModifier[5] = temp0
                            //> jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
                            digitsMathRoutine(temp3)
                            //> lda #$a4                   ;set status nybbles to update game timer display
                            temp0 = 0xA4
                            //> jmp PrintStatusBarNumbers  ;do sub to update the display
                        }
                        //> TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
                        playerStatus = temp0
                        //> jsr ForceInjury            ;do sub to kill the player (note player is small here)
                        forceInjury(temp0)
                        //> inc GameTimerExpiredFlag   ;set game timer expiration flag
                        gameTimerExpiredFlag = (gameTimerExpiredFlag + 1) and 0xFF
                    }
                }
            }
        }
    }
    //> ExGTimer:  rts                        ;leave
    return
}

// Decompiled from WarpZoneObject
fun warpZoneObject() {
    //> ExGTimer:  rts                        ;leave
    return
}

// Decompiled from ProcessWhirlpools
fun processWhirlpools() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var areaType by MemoryByte(AreaType)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var timerControl by MemoryByte(TimerControl)
    var whirlpoolFlag by MemoryByte(Whirlpool_Flag)
    val whirlpoolLeftextent by MemoryByteIndexed(Whirlpool_LeftExtent)
    val whirlpoolLength by MemoryByteIndexed(Whirlpool_Length)
    val whirlpoolPageloc by MemoryByteIndexed(Whirlpool_PageLoc)
    //> ProcessWhirlpools:
    //> lda AreaType                ;check for water type level
    //> bne ExitWh                  ;branch to leave if not found
    temp0 = areaType
    if (areaType == 0) {
        //> sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
        whirlpoolFlag = temp0
        //> lda TimerControl            ;if master timer control set,
        temp0 = timerControl
        //> bne ExitWh                  ;branch to leave
        if (temp0 == 0) {
            //> ldy #$04                    ;otherwise start with last whirlpool data
            temp1 = 0x04
            do {
                //> WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
                temp0 = whirlpoolLeftextent[temp1]
                //> clc
                //> adc Whirlpool_Length,y      ;add length of whirlpool
                temp2 = temp0 + whirlpoolLength[temp1]
                temp0 = temp2 and 0xFF
                //> sta $02                     ;store result as right extent here
                memory[0x2] = temp0.toUByte()
                //> lda Whirlpool_PageLoc,y     ;get page location
                temp0 = whirlpoolPageloc[temp1]
                //> beq NextWh                  ;if none or page 0, branch to get next data
                if (temp0 != 0) {
                    //> adc #$00                    ;add carry
                    temp3 = temp0 + (if (temp2 > 0xFF) 1 else 0)
                    temp0 = temp3 and 0xFF
                    //> sta $01                     ;store result as page location of right extent here
                    memory[0x1] = temp0.toUByte()
                    //> lda Player_X_Position       ;get player's horizontal position
                    temp0 = playerXPosition
                    //> sec
                    //> sbc Whirlpool_LeftExtent,y  ;subtract left extent
                    temp4 = temp0 - whirlpoolLeftextent[temp1]
                    temp0 = temp4 and 0xFF
                    //> lda Player_PageLoc          ;get player's page location
                    temp0 = playerPageloc
                    //> sbc Whirlpool_PageLoc,y     ;subtract borrow
                    temp5 = temp0 - whirlpoolPageloc[temp1] - (if (temp4 >= 0) 0 else 1)
                    temp0 = temp5 and 0xFF
                    //> bmi NextWh                  ;if player too far left, branch to get next data
                    if ((temp5 and 0xFF and 0x80) == 0) {
                        //> lda $02                     ;otherwise get right extent
                        temp0 = memory[0x2].toInt()
                        //> sec
                        //> sbc Player_X_Position       ;subtract player's horizontal coordinate
                        temp6 = temp0 - playerXPosition
                        temp0 = temp6 and 0xFF
                        //> lda $01                     ;get right extent's page location
                        temp0 = memory[0x1].toInt()
                        //> sbc Player_PageLoc          ;subtract borrow
                        temp7 = temp0 - playerPageloc - (if (temp6 >= 0) 0 else 1)
                        temp0 = temp7 and 0xFF
                        //> bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
                        if ((temp7 and 0xFF and 0x80) != 0) {
                        }
                    }
                }
                //> NextWh: dey                         ;move onto next whirlpool data
                temp1 = (temp1 - 1) and 0xFF
                //> bpl WhLoop                  ;do this until all whirlpools are checked
            } while ((temp1 and 0x80) == 0)
        }
    }
    //> ExitWh: rts                         ;leave
    return
}

// Decompiled from FlagpoleRoutine
fun flagpoleRoutine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var flagpolefnumYmfdummy by MemoryByte(FlagpoleFNum_YMFDummy)
    var flagpolefnumYPos by MemoryByte(FlagpoleFNum_Y_Pos)
    var flagpoleScore by MemoryByte(FlagpoleScore)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerState by MemoryByte(Player_State)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flagpoleScoreDigits by MemoryByteIndexed(FlagpoleScoreDigits)
    val flagpoleScoreMods by MemoryByteIndexed(FlagpoleScoreMods)
    //> FlagpoleRoutine:
    //> ldx #$05                  ;set enemy object offset
    //> stx ObjectOffset          ;to special use slot
    objectOffset = 0x05
    //> lda Enemy_ID,x
    //> cmp #FlagpoleFlagObject   ;if flagpole flag not found,
    //> bne ExitFlagP             ;branch to leave
    temp0 = enemyId[0x05]
    temp1 = 0x05
    if (enemyId[0x05] == FlagpoleFlagObject) {
        //> lda GameEngineSubroutine
        temp0 = gameEngineSubroutine
        //> cmp #$04                  ;if flagpole slide routine not running,
        //> bne SkipScore             ;branch to near the end of code
        if (!(temp0 - 0x04 == 0)) {
            //  goto SkipScore
            return
        }
        if (temp0 == 0x04) {
            //> lda Player_State
            temp0 = playerState
            //> cmp #$03                  ;if player state not climbing,
            //> bne SkipScore             ;branch to near the end of code
            if (!(temp0 - 0x03 == 0)) {
                //  goto SkipScore
                return
            }
            if (temp0 == 0x03) {
                //> lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
                temp0 = enemyYPosition[temp1]
                //> cmp #$aa                  ;if flagpole flag down to a certain point,
                //> bcs GiveFPScr             ;branch to end the level
                if (!(temp0 >= 0xAA)) {
                    //> lda Player_Y_Position     ;check player's vertical coordinate
                    temp0 = playerYPosition
                    //> cmp #$a2                  ;if player down to a certain point,
                    //> bcs GiveFPScr             ;branch to end the level
                    if (!(temp0 >= 0xA2)) {
                        //> lda Enemy_YMF_Dummy,x
                        temp0 = enemyYmfDummy[temp1]
                        //> adc #$ff                  ;add movement amount to dummy variable
                        temp2 = temp0 + 0xFF + (if (temp0 >= 0xA2) 1 else 0)
                        temp0 = temp2 and 0xFF
                        //> sta Enemy_YMF_Dummy,x     ;save dummy variable
                        enemyYmfDummy[temp1] = temp0
                        //> lda Enemy_Y_Position,x    ;get flag's vertical coordinate
                        temp0 = enemyYPosition[temp1]
                        //> adc #$01                  ;add 1 plus carry to move flag, and
                        temp3 = temp0 + 0x01 + (if (temp2 > 0xFF) 1 else 0)
                        temp0 = temp3 and 0xFF
                        //> sta Enemy_Y_Position,x    ;store vertical coordinate
                        enemyYPosition[temp1] = temp0
                        //> lda FlagpoleFNum_YMFDummy
                        temp0 = flagpolefnumYmfdummy
                        //> sec                       ;subtract movement amount from dummy variable
                        //> sbc #$ff
                        temp4 = temp0 - 0xFF
                        temp0 = temp4 and 0xFF
                        //> sta FlagpoleFNum_YMFDummy ;save dummy variable
                        flagpolefnumYmfdummy = temp0
                        //> lda FlagpoleFNum_Y_Pos
                        temp0 = flagpolefnumYPos
                        //> sbc #$01                  ;subtract one plus borrow to move floatey number,
                        temp5 = temp0 - 0x01 - (if (temp4 >= 0) 0 else 1)
                        temp0 = temp5 and 0xFF
                        //> sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
                        flagpolefnumYPos = temp0
                    }
                }
            }
        }
        //> SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
        //> GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
        //> lda FlagpoleScoreMods,y   ;get amount to award player points
        temp0 = flagpoleScoreMods[flagpoleScore]
        //> ldx FlagpoleScoreDigits,y ;get digit with which to award points
        temp1 = flagpoleScoreDigits[flagpoleScore]
        //> sta DigitModifier,x       ;store in digit modifier
        digitModifier[temp1] = temp0
        //> jsr AddToScore            ;do sub to award player points depending on height of collision
        addToScore()
        //> lda #$05
        temp0 = 0x05
        //> sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
        gameEngineSubroutine = temp0
        //> FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
        getEnemyOffscreenBits(temp1)
        //> jsr RelativeEnemyPosition ;get relative coordinates
        relativeEnemyPosition()
        //> jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
        flagpoleGfxHandler(temp1)
    }
    //> ExitFlagP: rts
    return
}

// Decompiled from JumpspringHandler
fun jumpspringHandler(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var jumpspringForce by MemoryByte(JumpspringForce)
    var jumpspringTimer by MemoryByte(JumpspringTimer)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var previousaBButtons by MemoryByte(PreviousA_B_Buttons)
    var timerControl by MemoryByte(TimerControl)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val jumpspringFixedypos by MemoryByteIndexed(Jumpspring_FixedYPos)
    val jumpspringYPosdata by MemoryByteIndexed(Jumpspring_Y_PosData)
    //> JumpspringHandler:
    //> jsr GetEnemyOffscreenBits   ;get offscreen information
    getEnemyOffscreenBits(X)
    //> lda TimerControl            ;check master timer control
    //> bne DrawJSpr                ;branch to last section if set
    temp0 = timerControl
    if (timerControl == 0) {
        //> lda JumpspringAnimCtrl      ;check jumpspring frame control
        temp0 = jumpspringAnimCtrl
        //> beq DrawJSpr                ;branch to last section if not set
        if (temp0 != 0) {
            //> tay
            //> dey                         ;subtract one from frame control,
            temp0 = (temp0 - 1) and 0xFF
            //> tya                         ;the only way a poor nmos 6502 can
            //> and #%00000010              ;mask out all but d1, original value still in Y
            temp1 = temp0 and 0x02
            //> bne DownJSpr                ;if set, branch to move player up
            temp0 = temp1
            temp2 = temp0
            if (temp1 == 0) {
                //> inc Player_Y_Position
                playerYPosition = (playerYPosition + 1) and 0xFF
                //> inc Player_Y_Position       ;move player's vertical position down two pixels
                playerYPosition = (playerYPosition + 1) and 0xFF
                //> jmp PosJSpr                 ;skip to next part
            } else {
                //> DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
                playerYPosition = (playerYPosition - 1) and 0xFF
                //> dec Player_Y_Position
                playerYPosition = (playerYPosition - 1) and 0xFF
            }
            //> PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
            temp0 = jumpspringFixedypos[X]
            //> clc
            //> adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
            temp3 = temp0 + jumpspringYPosdata[temp2]
            temp0 = temp3 and 0xFF
            //> sta Enemy_Y_Position,x      ;store as new vertical position
            enemyYPosition[X] = temp0
            //> cpy #$01                    ;check frame control offset (second frame is $00)
            //> bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
            if (temp2 >= 0x01) {
                //> lda A_B_Buttons
                temp0 = aBButtons
                //> and #A_Button               ;check saved controller bits for A button press
                temp4 = temp0 and A_Button
                //> beq BounceJS                ;skip to next part if A not pressed
                temp0 = temp4
                if (temp4 != 0) {
                    //> and PreviousA_B_Buttons     ;check for A button pressed in previous frame
                    temp5 = temp0 and previousaBButtons
                    //> bne BounceJS                ;skip to next part if so
                    temp0 = temp5
                    if (temp5 == 0) {
                        //> lda #$f4
                        temp0 = 0xF4
                        //> sta JumpspringForce         ;otherwise write new jumpspring force here
                        jumpspringForce = temp0
                    }
                }
            }
            //> BounceJS:  cpy #$03                    ;check frame control offset again
            //> bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
            if (temp2 == 0x03) {
                //> lda JumpspringForce
                temp0 = jumpspringForce
                //> sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
                playerYSpeed = temp0
                //> lda #$00
                temp0 = 0x00
                //> sta JumpspringAnimCtrl      ;initialize jumpspring frame control
                jumpspringAnimCtrl = temp0
            }
        }
    }
    //> DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
    relativeEnemyPosition()
    //> jsr EnemyGfxHandler         ;draw jumpspring
    enemyGfxHandler(X)
    //> jsr OffscreenBoundsCheck    ;check to see if we need to kill it
    offscreenBoundsCheck(X)
    //> lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
    temp0 = jumpspringAnimCtrl
    //> beq ExJSpring               ;trying to animate it, just leave
    if (temp0 != 0) {
        //> lda JumpspringTimer
        temp0 = jumpspringTimer
        //> bne ExJSpring               ;if jumpspring timer not expired yet, leave
        if (temp0 == 0) {
            //> lda #$04
            temp0 = 0x04
            //> sta JumpspringTimer         ;otherwise initialize jumpspring timer
            jumpspringTimer = temp0
            //> inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
            jumpspringAnimCtrl = (jumpspringAnimCtrl + 1) and 0xFF
        }
    }
    //> ExJSpring: rts                         ;leave
    return
}

// Decompiled from Setup_Vine
fun setupVine(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var vineFlagOffset by MemoryByte(VineFlagOffset)
    var vinestartYPosition by MemoryByte(VineStart_Y_Position)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val vineObjOffset by MemoryByteIndexed(VineObjOffset)
    //> Setup_Vine:
    //> lda #VineObject          ;load identifier for vine object
    //> sta Enemy_ID,x           ;store in buffer
    enemyId[X] = VineObject
    //> lda #$01
    //> sta Enemy_Flag,x         ;set flag for enemy object buffer
    enemyFlag[X] = 0x01
    //> lda Block_PageLoc,y
    //> sta Enemy_PageLoc,x      ;copy page location from previous object
    enemyPageloc[X] = blockPageloc[Y]
    //> lda Block_X_Position,y
    //> sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
    enemyXPosition[X] = blockXPosition[Y]
    //> lda Block_Y_Position,y
    //> sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
    enemyYPosition[X] = blockYPosition[Y]
    //> ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
    //> bne NextVO               ;if set at all, don't bother to store vertical
    temp0 = blockYPosition[Y]
    temp1 = vineFlagOffset
    if (vineFlagOffset == 0) {
        //> sta VineStart_Y_Position ;otherwise store vertical coordinate here
        vinestartYPosition = temp0
    }
    //> NextVO: txa                      ;store object offset to next available vine slot
    //> sta VineObjOffset,y      ;using vine flag as offset
    vineObjOffset[temp1] = X
    //> inc VineFlagOffset       ;increment vine flag offset
    vineFlagOffset = (vineFlagOffset + 1) and 0xFF
    //> lda #Sfx_GrowVine
    temp0 = Sfx_GrowVine
    //> sta Square2SoundQueue    ;load vine grow sound
    square2SoundQueue = temp0
    //> rts
    return
}

// Decompiled from VineObjectHandler
fun vineObjectHandler(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var vineFlagOffset by MemoryByte(VineFlagOffset)
    var vineHeight by MemoryByte(VineHeight)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val vineHeightData by MemoryByteIndexed(VineHeightData)
    val vineObjOffset by MemoryByteIndexed(VineObjOffset)
    //> VineObjectHandler:
    //> cpx #$05                  ;check enemy offset for special use slot
    //> bne ExitVH                ;if not in last slot, branch to leave
    if (X == 0x05) {
        //> ldy VineFlagOffset
        //> dey                       ;decrement vine flag in Y, use as offset
        vineFlagOffset = (vineFlagOffset - 1) and 0xFF
        //> lda VineHeight
        //> cmp VineHeightData,y      ;if vine has reached certain height,
        //> beq RunVSubs              ;branch ahead to skip this part
        temp0 = vineHeight
        temp1 = vineFlagOffset
        if (vineHeight != vineHeightData[vineFlagOffset]) {
            //> lda FrameCounter          ;get frame counter
            temp0 = frameCounter
            //> lsr                       ;shift d1 into carry
            temp0 = temp0 shr 1
            //> lsr
            temp0 = temp0 shr 1
            //> bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
            if ((temp0 and 0x01) != 0) {
                //> lda Enemy_Y_Position+5
                temp0 = enemyYPosition[5]
                //> sbc #$01                  ;subtract vertical position of vine
                temp2 = temp0 - 0x01 - (if ((temp0 and 0x01) != 0) 0 else 1)
                temp0 = temp2 and 0xFF
                //> sta Enemy_Y_Position+5    ;one pixel every frame it's time
                enemyYPosition[5] = temp0
                //> inc VineHeight            ;increment vine height
                vineHeight = (vineHeight + 1) and 0xFF
            }
        }
        //> RunVSubs:  lda VineHeight            ;if vine still very small,
        temp0 = vineHeight
        //> cmp #$08                  ;branch to leave
        //> bcc ExitVH
        if (temp0 >= 0x08) {
            //> jsr RelativeEnemyPosition ;get relative coordinates of vine,
            relativeEnemyPosition()
            //> jsr GetEnemyOffscreenBits ;and any offscreen bits
            getEnemyOffscreenBits(X)
            //> ldy #$00                  ;initialize offset used in draw vine sub
            temp1 = 0x00
            do {
                //> VDrawLoop: jsr DrawVine              ;draw vine
                drawVine(temp1)
                //> iny                       ;increment offset
                temp1 = (temp1 + 1) and 0xFF
                //> cpy VineFlagOffset        ;if offset in Y and offset here
                //> bne VDrawLoop             ;do not yet match, loop back to draw more vine
            } while (temp1 != vineFlagOffset)
            //> lda Enemy_OffscreenBits
            temp0 = enemyOffscreenbits
            //> and #%00001100            ;mask offscreen bits
            temp3 = temp0 and 0x0C
            //> beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
            temp0 = temp3
            if (temp3 != 0) {
                //> dey                       ;otherwise decrement Y to get proper offset again
                temp1 = (temp1 - 1) and 0xFF
                do {
                    //> KillVine:  ldx VineObjOffset,y       ;get enemy object offset for this vine object
                    //> jsr EraseEnemyObject      ;kill this vine object
                    eraseEnemyObject(vineObjOffset[temp1])
                    //> dey                       ;decrement Y
                    temp1 = (temp1 - 1) and 0xFF
                    //> bpl KillVine              ;if any vine objects left, loop back to kill it
                } while ((temp1 and 0x80) == 0)
                //> sta VineFlagOffset        ;initialize vine flag/offset
                vineFlagOffset = temp0
                //> sta VineHeight            ;initialize vine height
                vineHeight = temp0
            }
            //> WrCMTile:  lda VineHeight            ;check vine height
            temp0 = vineHeight
            //> cmp #$20                  ;if vine small (less than 32 pixels tall)
            //> bcc ExitVH                ;then branch ahead to leave
            if (temp0 >= 0x20) {
                //> ldx #$06                  ;set offset in X to last enemy slot
                //> lda #$01                  ;set A to obtain horizontal in $04, but we don't care
                temp0 = 0x01
                //> ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
                temp1 = 0x1B
                //> jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
                blockBufferCollision(temp0, 0x06, temp1)
                //> ldy $02
                temp1 = memory[0x2].toInt()
                //> cpy #$d0                  ;if vertical high nybble offset beyond extent of
                //> bcs ExitVH                ;current block buffer, branch to leave, do not write
                temp4 = 0x06
                if (!(temp1 >= 0xD0)) {
                    //> lda ($06),y               ;otherwise check contents of block buffer at
                    temp0 = memory[readWord(0x6) + temp1].toInt()
                    //> bne ExitVH                ;current offset, if not empty, branch to leave
                    if (temp0 == 0) {
                        //> lda #$26
                        temp0 = 0x26
                        //> sta ($06),y               ;otherwise, write climbing metatile to block buffer
                        memory[readWord(0x6) + temp1] = temp0.toUByte()
                    }
                }
            }
        }
    }
    //> ExitVH:    ldx ObjectOffset          ;get enemy object offset and leave
    temp4 = objectOffset
    //> rts
    return
}

// Decompiled from ProcessCannons
fun processCannons() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var areaType by MemoryByte(AreaType)
    var objectOffset by MemoryByte(ObjectOffset)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var timerControl by MemoryByte(TimerControl)
    val cannonBitmasks by MemoryByteIndexed(CannonBitmasks)
    val cannonPageloc by MemoryByteIndexed(Cannon_PageLoc)
    val cannonTimer by MemoryByteIndexed(Cannon_Timer)
    val cannonXPosition by MemoryByteIndexed(Cannon_X_Position)
    val cannonYPosition by MemoryByteIndexed(Cannon_Y_Position)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> ProcessCannons:
    //> lda AreaType                ;get area type
    //> beq ExCannon                ;if water type area, branch to leave
    temp0 = areaType
    if (areaType != 0) {
        //> ldx #$02
        //> ThreeSChk: stx ObjectOffset            ;start at third enemy slot
        objectOffset = 0x02
        //> lda Enemy_Flag,x            ;check enemy buffer flag
        temp0 = enemyFlag[0x02]
        //> bne Chk_BB                  ;if set, branch to check enemy
        temp1 = 0x02
        if (temp0 == 0) {
            //> lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
            temp0 = pseudoRandomBitReg[1 + temp1]
            //> ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
            //> and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
            temp2 = temp0 and cannonBitmasks[secondaryHardMode]
            //> cmp #$06                    ;check to see if lower nybble is above certain value
            //> bcs Chk_BB                  ;if so, branch to check enemy
            temp0 = temp2
            temp3 = secondaryHardMode
            if (!(temp2 >= 0x06)) {
                //> tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
                //> lda Cannon_PageLoc,y        ;get page location
                temp0 = cannonPageloc[temp0]
                //> beq Chk_BB                  ;if not set or on page 0, branch to check enemy
                temp3 = temp0
                if (temp0 != 0) {
                    //> lda Cannon_Timer,y          ;get cannon timer
                    temp0 = cannonTimer[temp3]
                    //> beq FireCannon              ;if expired, branch to fire cannon
                    if (temp0 != 0) {
                        //> sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
                        temp4 = temp0 - (if (temp2 >= 0x06) 0 else 1)
                        temp0 = temp4 and 0xFF
                        //> sta Cannon_Timer,y          ;to count timer down
                        cannonTimer[temp3] = temp0
                        //> jmp Chk_BB                  ;then jump ahead to check enemy
                    } else {
                        //> FireCannon:
                        //> lda TimerControl           ;if master timer control set,
                        temp0 = timerControl
                        //> bne Chk_BB                 ;branch to check enemy
                        if (temp0 == 0) {
                            //> lda #$0e                   ;otherwise we start creating one
                            temp0 = 0x0E
                            //> sta Cannon_Timer,y         ;first, reset cannon timer
                            cannonTimer[temp3] = temp0
                            //> lda Cannon_PageLoc,y       ;get page location of cannon
                            temp0 = cannonPageloc[temp3]
                            //> sta Enemy_PageLoc,x        ;save as page location of bullet bill
                            enemyPageloc[temp1] = temp0
                            //> lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
                            temp0 = cannonXPosition[temp3]
                            //> sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
                            enemyXPosition[temp1] = temp0
                            //> lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
                            temp0 = cannonYPosition[temp3]
                            //> sec
                            //> sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
                            temp5 = temp0 - 0x08
                            temp0 = temp5 and 0xFF
                            //> sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
                            enemyYPosition[temp1] = temp0
                            //> lda #$01
                            temp0 = 0x01
                            //> sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
                            enemyYHighpos[temp1] = temp0
                            //> sta Enemy_Flag,x           ;set buffer flag
                            enemyFlag[temp1] = temp0
                            //> lsr                        ;shift right once to init A
                            temp0 = temp0 shr 1
                            //> sta Enemy_State,x          ;then initialize enemy's state
                            enemyState[temp1] = temp0
                            //> lda #$09
                            temp0 = 0x09
                            //> sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
                            enemyBoundboxctrl[temp1] = temp0
                            //> lda #BulletBill_CannonVar
                            temp0 = BulletBill_CannonVar
                            //> sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
                            enemyId[temp1] = temp0
                            //> jmp Next3Slt               ;move onto next slot
                        }
                    }
                }
            }
        } else {
            //> Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
            temp0 = enemyId[temp1]
            //> cmp #BulletBill_CannonVar
            //> bne Next3Slt               ;if not found, branch to get next slot
            if (temp0 == BulletBill_CannonVar) {
                //> jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
                offscreenBoundsCheck(temp1)
                //> lda Enemy_Flag,x           ;check enemy buffer flag
                temp0 = enemyFlag[temp1]
                //> beq Next3Slt               ;if not set, branch to get next slot
                if (temp0 != 0) {
                    //> jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
                    getEnemyOffscreenBits(temp1)
                    //> jsr BulletBillHandler      ;then do sub to handle bullet bill
                    bulletBillHandler(temp1)
                }
            }
        }
        //> Next3Slt: dex                        ;move onto next slot
        temp1 = (temp1 - 1) and 0xFF
        //> bpl ThreeSChk              ;do this until first three slots are checked
    }
    //> ExCannon: rts                        ;then leave
    return
}

// Decompiled from BulletBillHandler
fun bulletBillHandler(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var timerControl by MemoryByte(TimerControl)
    val bulletBillXSpdData by MemoryByteIndexed(BulletBillXSpdData)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> BulletBillHandler:
    //> lda TimerControl          ;if master timer control set,
    //> bne RunBBSubs             ;branch to run subroutines except movement sub
    if (!(timerControl == 0)) {
        //  goto RunBBSubs
        return
    }
    temp0 = timerControl
    if (timerControl == 0) {
        //> lda Enemy_State,x
        temp0 = enemyState[X]
        //> bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
        if (temp0 == 0) {
            //> lda Enemy_OffscreenBits   ;otherwise load offscreen bits
            temp0 = enemyOffscreenbits
            //> and #%00001100            ;mask out bits
            temp1 = temp0 and 0x0C
            //> cmp #%00001100            ;check to see if all bits are set
            //> beq KillBB                ;if so, branch to kill this object
            temp0 = temp1
            if (temp1 != 0x0C) {
                //> ldy #$01                  ;set to move right by default
                //> jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
                playerEnemyDiff(X)
                //> bmi SetupBB               ;if enemy to the left of player, branch
                temp2 = 0x01
                if ((0x01 and 0x80) == 0) {
                    //> iny                       ;otherwise increment to move left
                    temp2 = (temp2 + 1) and 0xFF
                }
                //> SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
                enemyMovingdir[X] = temp2
                //> dey                       ;decrement to use as offset
                temp2 = (temp2 - 1) and 0xFF
                //> lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
                temp0 = bulletBillXSpdData[temp2]
                //> sta Enemy_X_Speed,x       ;and store it
                enemyXSpeed[X] = temp0
                //> lda $00                   ;get horizontal difference
                temp0 = memory[0x0].toInt()
                //> adc #$28                  ;add 40 pixels
                temp3 = temp0 + 0x28 + (if (temp1 >= 0x0C) 1 else 0)
                temp0 = temp3 and 0xFF
                //> cmp #$50                  ;if less than a certain amount, player is too close
                //> bcc KillBB                ;to cannon either on left or right side, thus branch
                if (temp0 >= 0x50) {
                    //> lda #$01
                    temp0 = 0x01
                    //> sta Enemy_State,x         ;otherwise set bullet bill's state
                    enemyState[X] = temp0
                    //> lda #$0a
                    temp0 = 0x0A
                    //> sta EnemyFrameTimer,x     ;set enemy frame timer
                    enemyFrameTimer[X] = temp0
                    //> lda #Sfx_Blast
                    temp0 = Sfx_Blast
                    //> sta Square2SoundQueue     ;play fireworks/gunfire sound
                    square2SoundQueue = temp0
                } else {
                    //> KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
                    eraseEnemyObject(X)
                    //> rts
                    return
                }
            }
        }
        //> ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
        temp0 = enemyState[X]
        //> and #%00100000
        temp4 = temp0 and 0x20
        //> beq BBFly                 ;if not set, skip to move horizontally
        temp0 = temp4
        if (temp4 != 0) {
            //> jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
            movedEnemyvertically(X)
        }
        //> BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
        moveEnemyHorizontally(X)
    }
    //> RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
    getEnemyOffscreenBits(X)
    //> jsr RelativeEnemyPosition ;get relative coordinates
    relativeEnemyPosition()
    //> jsr GetEnemyBoundBox      ;get bounding box coordinates
    getEnemyBoundBox(X)
    //> jsr PlayerEnemyCollision  ;handle player to enemy collisions
    playerEnemyCollision(X)
    //> jmp EnemyGfxHandler       ;draw the bullet bill and leave
}

// Decompiled from SpawnHammerObj
fun spawnHammerObj() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val hammerEnemyOffset by MemoryByteIndexed(HammerEnemyOffset)
    val hammerEnemyOfsData by MemoryByteIndexed(HammerEnemyOfsData)
    val miscBoundboxctrl by MemoryByteIndexed(Misc_BoundBoxCtrl)
    val miscState by MemoryByteIndexed(Misc_State)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> SpawnHammerObj:
    //> lda PseudoRandomBitReg+1 ;get pseudorandom bits from
    //> and #%00000111           ;second part of LSFR
    temp0 = pseudoRandomBitReg[1] and 0x07
    //> bne SetMOfs              ;if any bits are set, branch and use as offset
    temp1 = temp0
    if (temp0 == 0) {
        //> lda PseudoRandomBitReg+1
        temp1 = pseudoRandomBitReg[1]
        //> and #%00001000           ;get d3 from same part of LSFR
        temp2 = temp1 and 0x08
    }
    //> SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
    //> lda Misc_State,y         ;if any values loaded in
    temp1 = miscState[temp1]
    //> bne NoHammer             ;$2a-$32 where offset is then leave with carry clear
    temp3 = temp1
    if (temp1 == 0) {
        //> ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
        //> lda Enemy_Flag,x         ;check enemy buffer flag at offset
        temp1 = enemyFlag[hammerEnemyOfsData[temp3]]
        //> bne NoHammer             ;if buffer flag set, branch to leave with carry clear
        temp4 = hammerEnemyOfsData[temp3]
        if (temp1 == 0) {
            //> ldx ObjectOffset         ;get original enemy object offset
            temp4 = objectOffset
            //> txa
            //> sta HammerEnemyOffset,y  ;save here
            hammerEnemyOffset[temp3] = temp4
            //> lda #$90
            temp1 = 0x90
            //> sta Misc_State,y         ;save hammer's state here
            miscState[temp3] = temp1
            //> lda #$07
            temp1 = 0x07
            //> sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
            miscBoundboxctrl[temp3] = temp1
            //> sec                      ;return with carry set
            //> rts
            return
        }
    }
    //> NoHammer: ldx ObjectOffset         ;get original enemy object offset
    temp4 = objectOffset
    //> clc                      ;return with carry clear
    //> rts
    return
}

// Decompiled from ProcHammerObj
fun procHammerObj(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val hammerEnemyOffset by MemoryByteIndexed(HammerEnemyOffset)
    val hammerXSpdData by MemoryByteIndexed(HammerXSpdData)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscXSpeed by MemoryByteIndexed(Misc_X_Speed)
    val miscYHighpos by MemoryByteIndexed(Misc_Y_HighPos)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> ProcHammerObj:
    //> lda TimerControl           ;if master timer control set
    //> bne RunHSubs               ;skip all of this code and go to last subs at the end
    temp0 = timerControl
    if (timerControl == 0) {
        //> lda Misc_State,x           ;otherwise get hammer's state
        temp0 = miscState[X]
        //> and #%01111111             ;mask out d7
        temp1 = temp0 and 0x7F
        //> ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
        //> cmp #$02                   ;check hammer's state
        //> beq SetHSpd                ;if currently at 2, branch
        temp0 = temp1
        temp2 = hammerEnemyOffset[X]
        if (temp1 != 0x02) {
            //> bcs SetHPos                ;if greater than 2, branch elsewhere
            if (!(temp1 >= 0x02)) {
                //> txa
                //> clc                        ;add 13 bytes to use
                //> adc #$0d                   ;proper misc object
                temp3 = X + 0x0D
                temp0 = temp3 and 0xFF
                //> tax                        ;return offset to X
                //> lda #$10
                temp0 = 0x10
                //> sta $00                    ;set downward movement force
                memory[0x0] = temp0.toUByte()
                //> lda #$0f
                temp0 = 0x0F
                //> sta $01                    ;set upward movement force (not used)
                memory[0x1] = temp0.toUByte()
                //> lda #$04
                temp0 = 0x04
                //> sta $02                    ;set maximum vertical speed
                memory[0x2] = temp0.toUByte()
                //> lda #$00                   ;set A to impose gravity on hammer
                temp0 = 0x00
                //> jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
                imposeGravity(temp0, temp0)
                //> jsr MoveObjectHorizontally ;do sub to move it horizontally
                moveObjectHorizontally(temp0)
                //> ldx ObjectOffset           ;get original misc object offset
                //> jmp RunAllH                ;branch to essential subroutines
            }
        } else {
            //> SetHSpd:  lda #$fe
            temp0 = 0xFE
            //> sta Misc_Y_Speed,x         ;set hammer's vertical speed
            miscYSpeed[X] = temp0
            //> lda Enemy_State,y          ;get enemy object state
            temp0 = enemyState[temp2]
            //> and #%11110111             ;mask out d3
            temp4 = temp0 and 0xF7
            //> sta Enemy_State,y          ;store new state
            enemyState[temp2] = temp4
            //> ldx Enemy_MovingDir,y      ;get enemy's moving direction
            //> dex                        ;decrement to use as offset
            temp5 = enemyMovingdir[temp2]
            temp5 = (temp5 - 1) and 0xFF
            //> lda HammerXSpdData,x       ;get proper speed to use based on moving direction
            temp0 = hammerXSpdData[temp5]
            //> ldx ObjectOffset           ;reobtain hammer's buffer offset
            temp5 = objectOffset
            //> sta Misc_X_Speed,x         ;set hammer's horizontal speed
            miscXSpeed[temp5] = temp0
            //> SetHPos:  dec Misc_State,x           ;decrement hammer's state
            miscState[temp5] = (miscState[temp5] - 1) and 0xFF
            //> lda Enemy_X_Position,y     ;get enemy's horizontal position
            temp0 = enemyXPosition[temp2]
            //> clc
            //> adc #$02                   ;set position 2 pixels to the right
            temp6 = temp0 + 0x02
            temp0 = temp6 and 0xFF
            //> sta Misc_X_Position,x      ;store as hammer's horizontal position
            miscXPosition[temp5] = temp0
            //> lda Enemy_PageLoc,y        ;get enemy's page location
            temp0 = enemyPageloc[temp2]
            //> adc #$00                   ;add carry
            temp7 = temp0 + (if (temp6 > 0xFF) 1 else 0)
            temp0 = temp7 and 0xFF
            //> sta Misc_PageLoc,x         ;store as hammer's page location
            miscPageloc[temp5] = temp0
            //> lda Enemy_Y_Position,y     ;get enemy's vertical position
            temp0 = enemyYPosition[temp2]
            //> sec
            //> sbc #$0a                   ;move position 10 pixels upward
            temp8 = temp0 - 0x0A
            temp0 = temp8 and 0xFF
            //> sta Misc_Y_Position,x      ;store as hammer's vertical position
            miscYPosition[temp5] = temp0
            //> lda #$01
            temp0 = 0x01
            //> sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
            miscYHighpos[temp5] = temp0
            //> bne RunHSubs               ;unconditional branch to skip first routine
            if (temp0 == 0) {
            } else {
                //> RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
                getMiscOffscreenBits()
                //> jsr RelativeMiscPosition   ;get relative coordinates
                relativeMiscPosition()
                //> jsr GetMiscBoundBox        ;get bounding box coordinates
                getMiscBoundBox(temp5)
                //> jsr DrawHammer             ;draw the hammer
                drawHammer(temp5)
                //> rts                        ;and we are done here
                return
            }
        }
        //> RunAllH:  jsr PlayerHammerCollision  ;handle collisions
        playerHammerCollision(temp5)
    }
}

// Decompiled from CoinBlock
fun coinBlock(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var coinTallyFor1Ups by MemoryByte(CoinTallyFor1Ups)
    var objectOffset by MemoryByte(ObjectOffset)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscYHighpos by MemoryByteIndexed(Misc_Y_HighPos)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> CoinBlock:
    //> jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
    findEmptyMiscSlot()
    //> lda Block_PageLoc,x     ;get page location of block object
    //> sta Misc_PageLoc,y      ;store as page location of misc object
    miscPageloc[Y] = blockPageloc[X]
    //> lda Block_X_Position,x  ;get horizontal coordinate of block object
    //> ora #$05                ;add 5 pixels
    temp0 = blockXPosition[X] or 0x05
    //> sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
    miscXPosition[Y] = temp0
    //> lda Block_Y_Position,x  ;get vertical coordinate of block object
    //> sbc #$10                ;subtract 16 pixels
    temp1 = blockYPosition[X] - 0x10
    //> sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
    miscYPosition[Y] = temp1 and 0xFF
    //> jmp JCoinC              ;jump to rest of code as applies to this misc object
    //> JCoinC: lda #$fb
    //> sta Misc_Y_Speed,y     ;set vertical speed
    miscYSpeed[Y] = 0xFB
    //> lda #$01
    //> sta Misc_Y_HighPos,y   ;set vertical high byte
    miscYHighpos[Y] = 0x01
    //> sta Misc_State,y       ;set state for misc object
    miscState[Y] = 0x01
    //> sta Square2SoundQueue  ;load coin grab sound
    square2SoundQueue = 0x01
    //> stx ObjectOffset       ;store current control bit as misc object offset
    objectOffset = X
    //> jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
    giveOneCoin()
    //> inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
    coinTallyFor1Ups = (coinTallyFor1Ups + 1) and 0xFF
    //> rts
    return
}

// Decompiled from SetupJumpCoin
fun setupJumpCoin(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var coinTallyFor1Ups by MemoryByte(CoinTallyFor1Ups)
    var objectOffset by MemoryByte(ObjectOffset)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val blockPageloc2 by MemoryByteIndexed(Block_PageLoc2)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscYHighpos by MemoryByteIndexed(Misc_Y_HighPos)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> SetupJumpCoin:
    //> jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
    findEmptyMiscSlot()
    //> lda Block_PageLoc2,x   ;get page location saved earlier
    //> sta Misc_PageLoc,y     ;and save as page location for misc object
    miscPageloc[Y] = blockPageloc2[X]
    //> lda $06                ;get low byte of block buffer offset
    //> asl
    //> asl                    ;multiply by 16 to use lower nybble
    //> asl
    //> asl
    //> ora #$05               ;add five pixels
    temp0 = (((((((memory[0x6].toInt() shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or 0x05
    //> sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
    miscXPosition[Y] = temp0
    //> lda $02                ;get vertical high nybble offset from earlier
    //> adc #$20               ;add 32 pixels for the status bar
    temp1 = memory[0x2].toInt() + 0x20 + (if (((((((memory[0x6].toInt() shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF and 0x80) != 0) 1 else 0)
    //> sta Misc_Y_Position,y  ;store as vertical coordinate
    miscYPosition[Y] = temp1 and 0xFF
    //> JCoinC: lda #$fb
    //> sta Misc_Y_Speed,y     ;set vertical speed
    miscYSpeed[Y] = 0xFB
    //> lda #$01
    //> sta Misc_Y_HighPos,y   ;set vertical high byte
    miscYHighpos[Y] = 0x01
    //> sta Misc_State,y       ;set state for misc object
    miscState[Y] = 0x01
    //> sta Square2SoundQueue  ;load coin grab sound
    square2SoundQueue = 0x01
    //> stx ObjectOffset       ;store current control bit as misc object offset
    objectOffset = X
    //> jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
    giveOneCoin()
    //> inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
    coinTallyFor1Ups = (coinTallyFor1Ups + 1) and 0xFF
    //> rts
    return
}

// Decompiled from FindEmptyMiscSlot
fun findEmptyMiscSlot() {
    var temp0: Int = 0
    var jumpCoinMiscOffset by MemoryByte(JumpCoinMiscOffset)
    val miscState by MemoryByteIndexed(Misc_State)
    //> FindEmptyMiscSlot:
    //> ldy #$08                ;start at end of misc objects buffer
    temp0 = 0x08
    while (temp0 != 0x05) {
        //> dey                     ;decrement offset
        temp0 = (temp0 - 1) and 0xFF
        //> cpy #$05                ;do this for three slots
        //> bne FMiscLoop           ;do this until all slots are checked
    }
    //> ldy #$08                ;if no empty slots found, use last slot
    temp0 = 0x08
    //> UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
    jumpCoinMiscOffset = temp0
    //> rts
    return
}

// Decompiled from MiscObjectsCore
fun miscObjectsCore() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var scrollAmount by MemoryByte(ScrollAmount)
    val miscPageloc by MemoryByteIndexed(Misc_PageLoc)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscXPosition by MemoryByteIndexed(Misc_X_Position)
    val miscYSpeed by MemoryByteIndexed(Misc_Y_Speed)
    //> MiscObjectsCore:
    //> ldx #$08          ;set at end of misc object buffer
    //> MiscLoop: stx ObjectOffset  ;store misc object offset here
    objectOffset = 0x08
    //> lda Misc_State,x  ;check misc object state
    //> beq MiscLoopBack  ;branch to check next slot
    temp0 = miscState[0x08]
    temp1 = 0x08
    if (miscState[0x08] != 0) {
        //> asl               ;otherwise shift d7 into carry
        temp0 = (temp0 shl 1) and 0xFF
        //> bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
        if ((temp0 and 0x80) != 0) {
            //> jsr ProcHammerObj ;otherwise go to process hammer,
            procHammerObj(temp1)
            //> jmp MiscLoopBack  ;then check next slot
        } else {
            //> ProcJumpCoin:
            //> ldy Misc_State,x          ;check misc object state
            //> dey                       ;decrement to see if it's set to 1
            temp2 = miscState[temp1]
            temp2 = (temp2 - 1) and 0xFF
            //> beq JCoinRun              ;if so, branch to handle jumping coin
            if (temp2 != 0) {
                //> inc Misc_State,x          ;otherwise increment state to either start off or as timer
                miscState[temp1] = (miscState[temp1] + 1) and 0xFF
                //> lda Misc_X_Position,x     ;get horizontal coordinate for misc object
                temp0 = miscXPosition[temp1]
                //> clc                       ;whether its jumping coin (state 0 only) or floatey number
                //> adc ScrollAmount          ;add current scroll speed
                temp3 = temp0 + scrollAmount
                temp0 = temp3 and 0xFF
                //> sta Misc_X_Position,x     ;store as new horizontal coordinate
                miscXPosition[temp1] = temp0
                //> lda Misc_PageLoc,x        ;get page location
                temp0 = miscPageloc[temp1]
                //> adc #$00                  ;add carry
                temp4 = temp0 + (if (temp3 > 0xFF) 1 else 0)
                temp0 = temp4 and 0xFF
                //> sta Misc_PageLoc,x        ;store as new page location
                miscPageloc[temp1] = temp0
                //> lda Misc_State,x
                temp0 = miscState[temp1]
                //> cmp #$30                  ;check state of object for preset value
                //> bne RunJCSubs             ;if not yet reached, branch to subroutines
                if (temp0 == 0x30) {
                    //> lda #$00
                    temp0 = 0x00
                    //> sta Misc_State,x          ;otherwise nullify object state
                    miscState[temp1] = temp0
                    //> jmp MiscLoopBack          ;and move onto next slot
                }
            } else {
                //> JCoinRun:  txa
                //> clc                       ;add 13 bytes to offset for next subroutine
                //> adc #$0d
                temp5 = temp1 + 0x0D
                temp0 = temp5 and 0xFF
                //> tax
                //> lda #$50                  ;set downward movement amount
                temp0 = 0x50
                //> sta $00
                memory[0x0] = temp0.toUByte()
                //> lda #$06                  ;set maximum vertical speed
                temp0 = 0x06
                //> sta $02
                memory[0x2] = temp0.toUByte()
                //> lsr                       ;divide by 2 and set
                temp0 = temp0 shr 1
                //> sta $01                   ;as upward movement amount (apparently residual)
                memory[0x1] = temp0.toUByte()
                //> lda #$00                  ;set A to impose gravity on jumping coin
                temp0 = 0x00
                //> jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
                imposeGravity(temp0, temp0)
                //> ldx ObjectOffset          ;get original misc object offset
                temp1 = objectOffset
                //> lda Misc_Y_Speed,x        ;check vertical speed
                temp0 = miscYSpeed[temp1]
                //> cmp #$05
                //> bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
                if (temp0 == 0x05) {
                    //> inc Misc_State,x          ;otherwise increment state to change to floatey number
                    miscState[temp1] = (miscState[temp1] + 1) and 0xFF
                }
                //> RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
                relativeMiscPosition()
                //> jsr GetMiscOffscreenBits  ;get offscreen information
                getMiscOffscreenBits()
                //> jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
                getMiscBoundBox(temp1)
                //> jsr JCoinGfxHandler       ;draw the coin or floatey number
                jCoinGfxHandler(temp1)
            }
        }
    }
    do {
        //> MiscLoopBack:
        //> dex                       ;decrement misc object offset
        temp1 = (temp1 - 1) and 0xFF
        //> bpl MiscLoop              ;loop back until all misc objects handled
    } while ((temp1 and 0x80) == 0)
    //> rts                       ;then leave
    return
}

// Decompiled from GiveOneCoin
fun giveOneCoin() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var coinTally by MemoryByte(CoinTally)
    var currentPlayer by MemoryByte(CurrentPlayer)
    var numberofLives by MemoryByte(NumberofLives)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val coinTallyOffsets by MemoryByteIndexed(CoinTallyOffsets)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    //> GiveOneCoin:
    //> lda #$01               ;set digit modifier to add 1 coin
    //> sta DigitModifier+5    ;to the current player's coin tally
    digitModifier[5] = 0x01
    //> ldx CurrentPlayer      ;get current player on the screen
    //> ldy CoinTallyOffsets,x ;get offset for player's coin tally
    //> jsr DigitsMathRoutine  ;update the coin tally
    digitsMathRoutine(coinTallyOffsets[currentPlayer])
    //> inc CoinTally          ;increment onscreen player's coin amount
    coinTally = (coinTally + 1) and 0xFF
    //> lda CoinTally
    //> cmp #100               ;does player have 100 coins yet?
    //> bne CoinPoints         ;if not, skip all of this
    temp0 = coinTally
    temp1 = currentPlayer
    temp2 = coinTallyOffsets[currentPlayer]
    if (coinTally == 0x64) {
        //> lda #$00
        temp0 = 0x00
        //> sta CoinTally          ;otherwise, reinitialize coin amount
        coinTally = temp0
        //> inc NumberofLives      ;give the player an extra life
        numberofLives = (numberofLives + 1) and 0xFF
        //> lda #Sfx_ExtraLife
        temp0 = Sfx_ExtraLife
        //> sta Square2SoundQueue  ;play 1-up sound
        square2SoundQueue = temp0
    }
    //> CoinPoints:
    //> lda #$02               ;set digit modifier to award
    temp0 = 0x02
    //> sta DigitModifier+4    ;200 points to the player
    digitModifier[4] = temp0
    // Fall-through tail call to addToScore
    addToScore()
}

// Decompiled from AddToScore
fun addToScore() {
    var currentPlayer by MemoryByte(CurrentPlayer)
    val scoreOffsets by MemoryByteIndexed(ScoreOffsets)
    //> AddToScore:
    //> ldx CurrentPlayer      ;get current player
    //> ldy ScoreOffsets,x     ;get offset for player's score
    //> jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
    digitsMathRoutine(scoreOffsets[currentPlayer])
    // Fall-through tail call to getSBNybbles
    getSBNybbles()
}

// Decompiled from GetSBNybbles
fun getSBNybbles() {
    var currentPlayer by MemoryByte(CurrentPlayer)
    val statusBarNybbles by MemoryByteIndexed(StatusBarNybbles)
    //> GetSBNybbles:
    //> ldy CurrentPlayer      ;get current player
    //> lda StatusBarNybbles,y ;get nybbles based on player, use to update score and coins
    // Fall-through tail call to updateNumber
    updateNumber()
}

// Decompiled from UpdateNumber
fun updateNumber() {
    var A: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> UpdateNumber:
    //> jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
    printStatusBarNumbers(A)
    //> ldy VRAM_Buffer1_Offset
    //> lda VRAM_Buffer1-6,y      ;check highest digit of score
    //> bne NoZSup                ;if zero, overwrite with space tile for zero suppression
    temp0 = vramBuffer1[-6 + vramBuffer1Offset]
    temp1 = vramBuffer1Offset
    if (vramBuffer1[-6 + vramBuffer1Offset] == 0) {
        //> lda #$24
        temp0 = 0x24
        //> sta VRAM_Buffer1-6,y
        vramBuffer1[-6 + temp1] = temp0
    }
    //> NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
    //> rts
    return
}

// Decompiled from PwrUpJmp
fun pwrUpJmp() {
    var temp0: Int = 0
    var playerStatus by MemoryByte(PlayerStatus)
    var powerUpType by MemoryByte(PowerUpType)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
    //> sta Enemy_State+5         ;set power-up object's state
    enemyState[5] = 0x01
    //> sta Enemy_Flag+5          ;set buffer flag
    enemyFlag[5] = 0x01
    //> lda #$03
    //> sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
    enemyBoundboxctrl[5] = 0x03
    //> lda PowerUpType
    //> cmp #$02                  ;check currently loaded power-up type
    //> bcs PutBehind             ;if star or 1-up, branch ahead
    temp0 = powerUpType
    if (!(powerUpType >= 0x02)) {
        //> lda PlayerStatus          ;otherwise check player's current status
        temp0 = playerStatus
        //> cmp #$02
        //> bcc StrType               ;if player not fiery, use status as power-up type
        if (temp0 >= 0x02) {
            //> lsr                       ;otherwise shift right to force fire flower type
            temp0 = temp0 shr 1
        }
        //> StrType:   sta PowerUpType           ;store type here
        powerUpType = temp0
    }
    //> PutBehind: lda #%00100000
    temp0 = 0x20
    //> sta Enemy_SprAttrib+5     ;set background priority bit
    enemySprattrib[5] = temp0
    //> lda #Sfx_GrowPowerUp
    temp0 = Sfx_GrowPowerUp
    //> sta Square2SoundQueue     ;load power-up reveal sound and leave
    square2SoundQueue = temp0
    //> rts
    return
}

// Decompiled from PowerUpObjHandler
fun powerUpObjHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var powerUpType by MemoryByte(PowerUpType)
    var timerControl by MemoryByte(TimerControl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> PowerUpObjHandler:
    //> ldx #$05                   ;set object offset for last slot in enemy object buffer
    //> stx ObjectOffset
    objectOffset = 0x05
    //> lda Enemy_State+5          ;check power-up object's state
    //> beq ExitPUp                ;if not set, branch to leave
    temp0 = enemyState[5]
    temp1 = 0x05
    if (enemyState[5] != 0) {
        //> asl                        ;shift to check if d7 was set in object state
        temp0 = (temp0 shl 1) and 0xFF
        //> bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
        if ((temp0 and 0x80) != 0) {
            //> lda TimerControl           ;if master timer control set,
            temp0 = timerControl
            //> bne RunPUSubs              ;branch ahead to enemy object routines
            if (temp0 == 0) {
                //> lda PowerUpType            ;check power-up type
                temp0 = powerUpType
                //> beq ShroomM                ;if normal mushroom, branch ahead to move it
                if (temp0 == 0) {
                    //  goto ShroomM
                    return
                }
                if (temp0 != 0) {
                    //> cmp #$03
                    //> beq ShroomM                ;if 1-up mushroom, branch ahead to move it
                    if (temp0 - 0x03 == 0) {
                        //  goto ShroomM
                        return
                    }
                    if (temp0 != 0x03) {
                        //> cmp #$02
                        //> bne RunPUSubs              ;if not star, branch elsewhere to skip movement
                        if (temp0 == 0x02) {
                            //> jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
                            moveJumpingEnemy()
                            //> jsr EnemyJump              ;note that green paratroopa shares the same code here
                            enemyJump(temp1)
                            //> jmp RunPUSubs              ;then jump to other power-up subroutines
                        }
                    }
                }
                //> ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
                moveNormalEnemy(temp1)
                //> jsr EnemyToBGCollisionDet  ;deal with collisions
                enemyToBGCollisionDet(temp1)
                //> jmp RunPUSubs              ;run the other subroutines
            }
        } else {
            //> GrowThePowerUp:
            //> lda FrameCounter           ;get frame counter
            temp0 = frameCounter
            //> and #$03                   ;mask out all but 2 LSB
            temp2 = temp0 and 0x03
            //> bne ChkPUSte               ;if any bits set here, branch
            temp0 = temp2
            if (temp2 == 0) {
                //> dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
                enemyYPosition[5] = (enemyYPosition[5] - 1) and 0xFF
                //> lda Enemy_State+5          ;load power-up object state
                temp0 = enemyState[5]
                //> inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
                enemyState[5] = (enemyState[5] + 1) and 0xFF
                //> cmp #$11                   ;if power-up object state not yet past 16th pixel,
                //> bcc ChkPUSte               ;branch ahead to last part here
                if (temp0 >= 0x11) {
                    //> lda #$10
                    temp0 = 0x10
                    //> sta Enemy_X_Speed,x        ;otherwise set horizontal speed
                    enemyXSpeed[temp1] = temp0
                    //> lda #%10000000
                    temp0 = 0x80
                    //> sta Enemy_State+5          ;and then set d7 in power-up object's state
                    enemyState[5] = temp0
                    //> asl                        ;shift once to init A
                    temp0 = (temp0 shl 1) and 0xFF
                    //> sta Enemy_SprAttrib+5      ;initialize background priority bit set here
                    enemySprattrib[5] = temp0
                    //> rol                        ;rotate A to set right moving direction
                    temp0 = (temp0 shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0
                    //> sta Enemy_MovingDir,x      ;set moving direction
                    enemyMovingdir[temp1] = temp0
                }
            }
            //> ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
            temp0 = enemyState[5]
            //> cmp #$06                   ;for if power-up has risen enough
            //> bcc ExitPUp                ;if not, don't even bother running these routines
            if (temp0 >= 0x06) {
            } else {
                //> ExitPUp:   rts                        ;and we're done
                return
            }
        }
        //> RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
        relativeEnemyPosition()
        //> jsr GetEnemyOffscreenBits  ;get offscreen bits
        getEnemyOffscreenBits(temp1)
        //> jsr GetEnemyBoundBox       ;get bounding box coordinates
        getEnemyBoundBox(temp1)
        //> jsr DrawPowerUp            ;draw the power-up object
        drawPowerUp()
        //> jsr PlayerEnemyCollision   ;check for collision with player
        playerEnemyCollision(temp1)
        //> jsr OffscreenBoundsCheck   ;check to see if it went offscreen
        offscreenBoundsCheck(temp1)
    }
}

// Decompiled from PlayerHeadCollision
fun playerHeadCollision(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var blockBounceTimer by MemoryByte(BlockBounceTimer)
    var brickCoinTimer by MemoryByte(BrickCoinTimer)
    var brickCoinTimerFlag by MemoryByte(BrickCoinTimerFlag)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var playerSize by MemoryByte(PlayerSize)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    val blockYPosAdderData by MemoryByteIndexed(BlockYPosAdderData)
    val blockBbufLow by MemoryByteIndexed(Block_BBuf_Low)
    val blockMetatile by MemoryByteIndexed(Block_Metatile)
    val blockOrigYpos by MemoryByteIndexed(Block_Orig_YPos)
    val blockState by MemoryByteIndexed(Block_State)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    //> PlayerHeadCollision:
    //> pha                      ;store metatile number to stack
    push(A)
    //> lda #$11                 ;load unbreakable block object state by default
    //> ldx SprDataOffset_Ctrl   ;load offset control bit here
    //> ldy PlayerSize           ;check player's size
    //> bne DBlockSte            ;if small, branch
    temp0 = 0x11
    temp1 = sprdataoffsetCtrl
    temp2 = playerSize
    if (playerSize == 0) {
        //> lda #$12                 ;otherwise load breakable block object state
        temp0 = 0x12
    }
    //> DBlockSte: sta Block_State,x        ;store into block object buffer
    blockState[temp1] = temp0
    //> jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
    destroyBlockMetatile()
    //> ldx SprDataOffset_Ctrl   ;load offset control bit
    temp1 = sprdataoffsetCtrl
    //> lda $02                  ;get vertical high nybble offset used in block buffer routine
    temp0 = memory[0x2].toInt()
    //> sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
    blockOrigYpos[temp1] = temp0
    //> tay
    //> lda $06                  ;get low byte of block buffer address used in same routine
    temp0 = memory[0x6].toInt()
    //> sta Block_BBuf_Low,x     ;save as offset here to be used later
    blockBbufLow[temp1] = temp0
    //> lda ($06),y              ;get contents of block buffer at old address at $06, $07
    temp0 = memory[readWord(0x6) + temp0].toInt()
    //> jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
    blockBumpedChk(temp0)
    //> sta $00                  ;store metatile here
    memory[0x0] = temp0.toUByte()
    //> ldy PlayerSize           ;check player's size
    temp2 = playerSize
    //> bne ChkBrick             ;if small, use metatile itself as contents of A
    if (temp2 == 0) {
        //> tya                      ;otherwise init A (note: big = 0)
    }
    //> ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
    if (flagC) {
        //> ldy #$11                 ;otherwise load unbreakable state into block object buffer
        temp2 = 0x11
        //> sty Block_State,x        ;note this applies to both player sizes
        blockState[temp1] = temp2
        //> lda #$c4                 ;load empty block metatile into A for now
        temp0 = 0xC4
        //> ldy $00                  ;get metatile from before
        temp2 = memory[0x0].toInt()
        //> cpy #$58                 ;is it brick with coins (with line)?
        //> beq StartBTmr            ;if so, branch
        if (temp2 != 0x58) {
            //> cpy #$5d                 ;is it brick with coins (without line)?
            //> bne PutMTileB            ;if not, branch ahead to store empty block metatile
            if (temp2 == 0x5D) {
            }
        }
        //> StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
        temp0 = brickCoinTimerFlag
        //> bne ContBTmr             ;if set, timer expired or counting down, thus branch
        if (temp0 == 0) {
            //> lda #$0b
            temp0 = 0x0B
            //> sta BrickCoinTimer       ;if not set, set brick coin timer
            brickCoinTimer = temp0
            //> inc BrickCoinTimerFlag   ;and set flag linked to it
            brickCoinTimerFlag = (brickCoinTimerFlag + 1) and 0xFF
        }
        //> ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
        temp0 = brickCoinTimer
        //> bne PutOldMT             ;if not yet expired, branch to use current metatile
        if (temp0 == 0) {
            //> ldy #$c4                 ;otherwise use empty block metatile
            temp2 = 0xC4
        }
        //> PutOldMT:  tya                      ;put metatile into A
    }
    //> PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
    blockMetatile[temp1] = temp0
    //> jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
    initblockXyPos(temp1)
    //> ldy $02                  ;get vertical high nybble offset
    temp2 = memory[0x2].toInt()
    //> lda #$23
    temp0 = 0x23
    //> sta ($06),y              ;write blank metatile $23 to block buffer
    memory[readWord(0x6) + temp2] = temp0.toUByte()
    //> lda #$10
    temp0 = 0x10
    //> sta BlockBounceTimer     ;set block bounce timer
    blockBounceTimer = temp0
    //> pla                      ;pull original metatile from stack
    temp0 = pull()
    //> sta $05                  ;and save here
    memory[0x5] = temp0.toUByte()
    //> ldy #$00                 ;set default offset
    temp2 = 0x00
    //> lda CrouchingFlag        ;is player crouching?
    temp0 = crouchingFlag
    //> bne SmallBP              ;if so, branch to increment offset
    if (temp0 == 0) {
        //> lda PlayerSize           ;is player big?
        temp0 = playerSize
        //> beq BigBP                ;if so, branch to use default offset
        if (temp0 != 0) {
        }
    }
    //> SmallBP:   iny                      ;increment for small or big and crouching
    temp2 = (temp2 + 1) and 0xFF
    //> BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
    temp0 = playerYPosition
    //> clc
    //> adc BlockYPosAdderData,y ;add value determined by size
    temp3 = temp0 + blockYPosAdderData[temp2]
    temp0 = temp3 and 0xFF
    //> and #$f0                 ;mask out low nybble to get 16-pixel correspondence
    temp4 = temp0 and 0xF0
    //> sta Block_Y_Position,x   ;save as vertical coordinate for block object
    blockYPosition[temp1] = temp4
    //> ldy Block_State,x        ;get block object state
    temp2 = blockState[temp1]
    //> cpy #$11
    //> beq Unbreak              ;if set to value loaded for unbreakable, branch
    temp0 = temp4
    if (temp2 != 0x11) {
        //> jsr BrickShatter         ;execute code for breakable brick
        brickShatter(temp1)
        //> jmp InvOBit              ;skip subroutine to do last part of code here
    } else {
        //> Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
        bumpBlock(temp1, temp2)
    }
    //> InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
    temp0 = sprdataoffsetCtrl
    //> eor #$01                 ;and floatey numbers
    temp5 = temp0 xor 0x01
    //> sta SprDataOffset_Ctrl
    sprdataoffsetCtrl = temp5
    //> rts                      ;leave!
    return
}

// Decompiled from InitBlock_XY_Pos
fun initblockXyPos(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockPageloc2 by MemoryByteIndexed(Block_PageLoc2)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYHighpos by MemoryByteIndexed(Block_Y_HighPos)
    //> InitBlock_XY_Pos:
    //> lda Player_X_Position   ;get player's horizontal coordinate
    //> clc
    //> adc #$08                ;add eight pixels
    temp0 = playerXPosition + 0x08
    //> and #$f0                ;mask out low nybble to give 16-pixel correspondence
    temp1 = temp0 and 0xFF and 0xF0
    //> sta Block_X_Position,x  ;save as horizontal coordinate for block object
    blockXPosition[X] = temp1
    //> lda Player_PageLoc
    //> adc #$00                ;add carry to page location of player
    temp2 = playerPageloc + (if (temp0 > 0xFF) 1 else 0)
    //> sta Block_PageLoc,x     ;save as page location of block object
    blockPageloc[X] = temp2 and 0xFF
    //> sta Block_PageLoc2,x    ;save elsewhere to be used later
    blockPageloc2[X] = temp2 and 0xFF
    //> lda Player_Y_HighPos
    //> sta Block_Y_HighPos,x   ;save vertical high byte of player into
    blockYHighpos[X] = playerYHighpos
    //> rts                     ;vertical high byte of block object and leave
    return
}

// Decompiled from BumpBlock
fun bumpBlock(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val blockXSpeed by MemoryByteIndexed(Block_X_Speed)
    val blockYMoveforce by MemoryByteIndexed(Block_Y_MoveForce)
    val blockYSpeed by MemoryByteIndexed(Block_Y_Speed)
    //> BumpBlock:
    //> jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
    checkTopOfBlock()
    //> lda #Sfx_Bump
    //> sta Square1SoundQueue   ;play bump sound
    square1SoundQueue = Sfx_Bump
    //> lda #$00
    //> sta Block_X_Speed,x     ;initialize horizontal speed for block object
    blockXSpeed[X] = 0x00
    //> sta Block_Y_MoveForce,x ;init fractional movement force
    blockYMoveforce[X] = 0x00
    //> sta Player_Y_Speed      ;init player's vertical speed
    playerYSpeed = 0x00
    //> lda #$fe
    //> sta Block_Y_Speed,x     ;set vertical speed for block object
    blockYSpeed[X] = 0xFE
    //> lda $05                 ;get original metatile from stack
    //> jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
    blockBumpedChk(memory[0x5].toInt())
    //> bcc ExitBlockChk        ;if no match was found, branch to leave
    temp0 = memory[0x5].toInt()
    if (flagC) {
        //> tya                     ;move block number to A
        //> cmp #$09                ;if block number was within 0-8 range,
        //> bcc BlockCode           ;branch to use current number
        temp0 = Y
        if (Y >= 0x09) {
            //> sbc #$05                ;otherwise subtract 5 for second set to get proper number
            temp1 = temp0 - 0x05 - (if (Y >= 0x09) 0 else 1)
            temp0 = temp1 and 0xFF
        }
        //> BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
        when (temp0) {
            0 -> {
                mushFlowerBlock()
            }
            1 -> {
                coinBlock(X, Y)
            }
            2 -> {
                coinBlock(X, Y)
            }
            3 -> {
                extraLifeMushBlock(X)
            }
            4 -> {
                mushFlowerBlock()
            }
            5 -> {
                vineBlock()
            }
            6 -> {
                starBlock()
            }
            7 -> {
                coinBlock(X, Y)
            }
            8 -> {
                extraLifeMushBlock(X)
            }
            else -> {
                // Unknown JumpEngine index
            }
        }
        return
        //> .dw MushFlowerBlock
        //> .dw CoinBlock
        //> .dw CoinBlock
        //> .dw ExtraLifeMushBlock
        //> .dw MushFlowerBlock
        //> .dw VineBlock
        //> .dw StarBlock
        //> .dw CoinBlock
        //> .dw ExtraLifeMushBlock
        //> ;--------------------------------
    }
    //> ExitBlockChk:
    //> rts                     ;leave
    return
}

// Decompiled from MushFlowerBlock
fun mushFlowerBlock() {
    //> MushFlowerBlock:
    //> lda #$00       ;load mushroom/fire flower into power-up type
    //> .db $2c        ;BIT instruction opcode
    // Fall-through tail call to starBlock
    starBlock()
}

// Decompiled from StarBlock
fun starBlock() {
    //> StarBlock:
    //> lda #$02       ;load star into power-up type
    //> .db $2c        ;BIT instruction opcode
    // Fall-through tail call to extraLifeMushBlock
    extraLifeMushBlock(X)
}

// Decompiled from ExtraLifeMushBlock
fun extraLifeMushBlock(X: Int) {
    var temp0: Int = 0
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> SetupPowerUp:
    //> lda #PowerUpObject        ;load power-up identifier into
    //> sta Enemy_ID+5            ;special use slot of enemy object buffer
    enemyId[5] = PowerUpObject
    //> lda Block_PageLoc,x       ;store page location of block object
    //> sta Enemy_PageLoc+5       ;as page location of power-up object
    enemyPageloc[5] = blockPageloc[X]
    //> lda Block_X_Position,x    ;store horizontal coordinate of block object
    //> sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
    enemyXPosition[5] = blockXPosition[X]
    //> lda #$01
    //> sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
    enemyYHighpos[5] = 0x01
    //> lda Block_Y_Position,x    ;get vertical coordinate of block object
    //> sec
    //> sbc #$08                  ;subtract 8 pixels
    temp0 = blockYPosition[X] - 0x08
    //> sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
    enemyYPosition[5] = temp0 and 0xFF
    while (true) {
        //> ExtraLifeMushBlock:
        //> lda #$03         ;load 1-up mushroom into power-up type
        //> sta $39          ;store correct power-up type
        memory[0x39] = 0x03.toUByte()
        //> jmp SetupPowerUp
    }
    // Fall-through tail call to pwrUpJmp
    pwrUpJmp()
}

// Decompiled from VineBlock
fun vineBlock() {
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    //> VineBlock:
    //> ldx #$05                ;load last slot for enemy object buffer
    //> ldy SprDataOffset_Ctrl  ;get control bit
    //> jsr Setup_Vine          ;set up vine object
    setupVine(0x05, sprdataoffsetCtrl)
    //> ExitBlockChk:
    //> rts                     ;leave
    return
}

// Decompiled from BlockBumpedChk
fun blockBumpedChk(A: Int) {
    var temp0: Int = 0
    val brickQBlockMetatiles by MemoryByteIndexed(BrickQBlockMetatiles)
    //> BlockBumpedChk:
    //> ldy #$0d                    ;start at end of metatile data
    temp0 = 0x0D
    while ((temp0 and 0x80) == 0) {
        //> dey                         ;otherwise move onto next metatile
        temp0 = (temp0 - 1) and 0xFF
        //> bpl BumpChkLoop             ;do this until all metatiles are checked
    }
    //> clc                         ;if none match, return with carry clear
    //> MatchBump:   rts                         ;note carry is set if found match
    return
}

// Decompiled from BrickShatter
fun brickShatter(X: Int) {
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    //> BrickShatter:
    //> jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
    checkTopOfBlock()
    //> lda #Sfx_BrickShatter
    //> sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
    blockRepflag[X] = Sfx_BrickShatter
    //> sta NoiseSoundQueue    ;load brick shatter sound
    noiseSoundQueue = Sfx_BrickShatter
    //> jsr SpawnBrickChunks   ;create brick chunk objects
    spawnBrickChunks(X)
    //> lda #$fe
    //> sta Player_Y_Speed     ;set vertical speed for player
    playerYSpeed = 0xFE
    //> lda #$05
    //> sta DigitModifier+5    ;set digit modifier to give player 50 points
    digitModifier[5] = 0x05
    //> jsr AddToScore         ;do sub to update the score
    addToScore()
    //> ldx SprDataOffset_Ctrl ;load control bit and leave
    //> rts
    return
}

// Decompiled from CheckTopOfBlock
fun checkTopOfBlock() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var sprdataoffsetCtrl by MemoryByte(SprDataOffset_Ctrl)
    //> CheckTopOfBlock:
    //> ldx SprDataOffset_Ctrl  ;load control bit
    //> ldy $02                 ;get vertical high nybble offset used in block buffer
    //> beq TopEx               ;branch to leave if set to zero, because we're at the top
    temp0 = sprdataoffsetCtrl
    temp1 = memory[0x2].toInt()
    if (memory[0x2].toInt() != 0) {
        //> tya                     ;otherwise set to A
        //> sec
        //> sbc #$10                ;subtract $10 to move up one row in the block buffer
        temp2 = temp1 - 0x10
        //> sta $02                 ;store as new vertical high nybble offset
        memory[0x2] = (temp2 and 0xFF).toUByte()
        //> tay
        //> lda ($06),y             ;get contents of block buffer in same column, one row up
        //> cmp #$c2                ;is it a coin? (not underwater)
        //> bne TopEx               ;if not, branch to leave
        temp3 = memory[readWord(0x6) + (temp2 and 0xFF)].toInt()
        temp1 = temp2 and 0xFF
        if (memory[readWord(0x6) + (temp2 and 0xFF)].toInt() == 0xC2) {
            //> lda #$00
            temp3 = 0x00
            //> sta ($06),y             ;otherwise put blank metatile where coin was
            memory[readWord(0x6) + temp1] = temp3.toUByte()
            //> jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
            removecoinAxe()
            //> ldx SprDataOffset_Ctrl  ;get control bit
            temp0 = sprdataoffsetCtrl
            //> jsr SetupJumpCoin       ;create jumping coin object and update coin variables
            setupJumpCoin(temp0, temp1)
        }
    }
    //> TopEx: rts                     ;leave!
    return
}

// Decompiled from SpawnBrickChunks
fun spawnBrickChunks(X: Int) {
    var temp0: Int = 0
    val blockOrigXpos by MemoryByteIndexed(Block_Orig_XPos)
    val blockPageloc by MemoryByteIndexed(Block_PageLoc)
    val blockXPosition by MemoryByteIndexed(Block_X_Position)
    val blockXSpeed by MemoryByteIndexed(Block_X_Speed)
    val blockYMoveforce by MemoryByteIndexed(Block_Y_MoveForce)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    val blockYSpeed by MemoryByteIndexed(Block_Y_Speed)
    //> SpawnBrickChunks:
    //> lda Block_X_Position,x     ;set horizontal coordinate of block object
    //> sta Block_Orig_XPos,x      ;as original horizontal coordinate here
    blockOrigXpos[X] = blockXPosition[X]
    //> lda #$f0
    //> sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
    blockXSpeed[X] = 0xF0
    //> sta Block_X_Speed+2,x
    blockXSpeed[2 + X] = 0xF0
    //> lda #$fa
    //> sta Block_Y_Speed,x        ;set vertical speed for one
    blockYSpeed[X] = 0xFA
    //> lda #$fc
    //> sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
    blockYSpeed[2 + X] = 0xFC
    //> lda #$00
    //> sta Block_Y_MoveForce,x    ;init fractional movement force for both
    blockYMoveforce[X] = 0x00
    //> sta Block_Y_MoveForce+2,x
    blockYMoveforce[2 + X] = 0x00
    //> lda Block_PageLoc,x
    //> sta Block_PageLoc+2,x      ;copy page location
    blockPageloc[2 + X] = blockPageloc[X]
    //> lda Block_X_Position,x
    //> sta Block_X_Position+2,x   ;copy horizontal coordinate
    blockXPosition[2 + X] = blockXPosition[X]
    //> lda Block_Y_Position,x
    //> clc                        ;add 8 pixels to vertical coordinate
    //> adc #$08                   ;and save as vertical coordinate for one of them
    temp0 = blockYPosition[X] + 0x08
    //> sta Block_Y_Position+2,x
    blockYPosition[2 + X] = temp0 and 0xFF
    //> lda #$fa
    //> sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
    blockYSpeed[X] = 0xFA
    //> rts
    return
}

// Decompiled from BlockObjectsCore
fun blockObjectsCore(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    val blockState by MemoryByteIndexed(Block_State)
    val blockYHighpos by MemoryByteIndexed(Block_Y_HighPos)
    val blockYPosition by MemoryByteIndexed(Block_Y_Position)
    //> BlockObjectsCore:
    //> lda Block_State,x           ;get state of block object
    //> beq UpdSte                  ;if not set, branch to leave
    temp0 = blockState[X]
    if (blockState[X] != 0) {
        //> and #$0f                    ;mask out high nybble
        temp1 = temp0 and 0x0F
        //> pha                         ;push to stack
        push(temp1)
        //> tay                         ;put in Y for now
        //> txa
        //> clc
        //> adc #$09                    ;add 9 bytes to offset (note two block objects are created
        temp2 = X + 0x09
        temp0 = temp2 and 0xFF
        //> tax                         ;when using brick chunks, but only one offset for both)
        //> dey                         ;decrement Y to check for solid block state
        temp1 = (temp1 - 1) and 0xFF
        //> beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
        temp3 = temp0
        temp4 = temp1
        if (temp1 != 0) {
            //> jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
            imposeGravityBlock()
            //> jsr MoveObjectHorizontally  ;do another sub to move horizontally
            moveObjectHorizontally(temp3)
            //> txa
            //> clc                         ;move onto next block object
            //> adc #$02
            temp5 = temp3 + 0x02
            temp0 = temp5 and 0xFF
            //> tax
            //> jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
            imposeGravityBlock()
            //> jsr MoveObjectHorizontally  ;do another sub to move horizontally
            moveObjectHorizontally(temp0)
            //> ldx ObjectOffset            ;get block object offset used for both
            temp3 = objectOffset
            //> jsr RelativeBlockPosition   ;get relative coordinates
            relativeBlockPosition(temp3)
            //> jsr GetBlockOffscreenBits   ;get offscreen information
            getBlockOffscreenBits(temp3)
            //> jsr DrawBrickChunks         ;draw the brick chunks
            drawBrickChunks(temp3)
            //> pla                         ;get lower nybble of saved state
            temp0 = pull()
            //> ldy Block_Y_HighPos,x       ;check vertical high byte of block object
            temp4 = blockYHighpos[temp3]
            //> beq UpdSte                  ;if above the screen, branch to kill it
            if (temp4 != 0) {
                //> pha                         ;otherwise save state back into stack
                push(temp0)
                //> lda #$f0
                temp0 = 0xF0
                //> cmp Block_Y_Position+2,x    ;check to see if bottom block object went
                //> bcs ChkTop                  ;to the bottom of the screen, and branch if not
                if (!(temp0 >= blockYPosition[2 + temp3])) {
                    //> sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
                    blockYPosition[2 + temp3] = temp0
                }
                //> ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
                temp0 = blockYPosition[temp3]
                //> cmp #$f0                    ;see if it went to the bottom of the screen
                //> pla                         ;pull block object state from stack
                temp0 = pull()
                //> bcc UpdSte                  ;if not, branch to save state
                if (temp0 >= 0xF0) {
                    //> bcs KillBlock               ;otherwise do unconditional branch to kill it
                    if (!(temp0 >= 0xF0)) {
                    }
                } else {
                    //> UpdSte:    sta Block_State,x          ;store contents of A in block object state
                    blockState[temp3] = temp0
                    //> rts
                    return
                }
            }
        }
        //> BouncingBlockHandler:
        //> jsr ImposeGravityBlock     ;do sub to impose gravity on block object
        imposeGravityBlock()
        //> ldx ObjectOffset           ;get block object offset
        temp3 = objectOffset
        //> jsr RelativeBlockPosition  ;get relative coordinates
        relativeBlockPosition(temp3)
        //> jsr GetBlockOffscreenBits  ;get offscreen information
        getBlockOffscreenBits(temp3)
        //> jsr DrawBlock              ;draw the block
        drawBlock(temp3)
        //> lda Block_Y_Position,x     ;get vertical coordinate
        temp0 = blockYPosition[temp3]
        //> and #$0f                   ;mask out high nybble
        temp6 = temp0 and 0x0F
        //> cmp #$05                   ;check to see if low nybble wrapped around
        //> pla                        ;pull state from stack
        temp0 = pull()
        //> bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
        if (!(temp6 >= 0x05)) {
            //> lda #$01
            temp0 = 0x01
            //> sta Block_RepFlag,x        ;otherwise set flag to replace metatile
            blockRepflag[temp3] = temp0
            //> KillBlock: lda #$00                   ;if branched here, nullify object state
            temp0 = 0x00
        }
    }
}

// Decompiled from BlockObjMT_Updater
fun blockobjmtUpdater() {
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var vramBuffer1 by MemoryByte(VRAM_Buffer1)
    val blockBbufLow by MemoryByteIndexed(Block_BBuf_Low)
    val blockMetatile by MemoryByteIndexed(Block_Metatile)
    val blockOrigYpos by MemoryByteIndexed(Block_Orig_YPos)
    val blockRepflag by MemoryByteIndexed(Block_RepFlag)
    //> BlockObjMT_Updater:
    //> ldx #$01                  ;set offset to start with second block object
    temp0 = 0x01
    do {
        //> UpdateLoop: stx ObjectOffset          ;set offset here
        objectOffset = temp0
        //> lda VRAM_Buffer1          ;if vram buffer already being used here,
        //> bne NextBUpd              ;branch to move onto next block object
        temp1 = vramBuffer1
        if (vramBuffer1 == 0) {
            //> lda Block_RepFlag,x       ;if flag for block object already clear,
            temp1 = blockRepflag[temp0]
            //> beq NextBUpd              ;branch to move onto next block object
            if (temp1 != 0) {
                //> lda Block_BBuf_Low,x      ;get low byte of block buffer
                temp1 = blockBbufLow[temp0]
                //> sta $06                   ;store into block buffer address
                memory[0x6] = temp1.toUByte()
                //> lda #$05
                temp1 = 0x05
                //> sta $07                   ;set high byte of block buffer address
                memory[0x7] = temp1.toUByte()
                //> lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
                temp1 = blockOrigYpos[temp0]
                //> sta $02                   ;store here and use as offset to block buffer
                memory[0x2] = temp1.toUByte()
                //> tay
                //> lda Block_Metatile,x      ;get metatile to be written
                temp1 = blockMetatile[temp0]
                //> sta ($06),y               ;write it to the block buffer
                memory[readWord(0x6) + temp1] = temp1.toUByte()
                //> jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
                replaceBlockMetatile(temp0)
                //> lda #$00
                temp1 = 0x00
                //> sta Block_RepFlag,x       ;clear block object flag
                blockRepflag[temp0] = temp1
            }
        }
        //> NextBUpd:   dex                       ;decrement block object offset
        temp0 = (temp0 - 1) and 0xFF
        //> bpl UpdateLoop            ;do this until both block objects are dealt with
    } while ((temp0 and 0x80) == 0)
    //> rts                       ;then leave
    return
}

// Decompiled from MoveEnemyHorizontally
fun moveEnemyHorizontally(X: Int) {
    var X: Int = X
    var objectOffset by MemoryByte(ObjectOffset)
    //> MoveEnemyHorizontally:
    //> inx                         ;increment offset for enemy offset
    X = (X + 1) and 0xFF
    //> jsr MoveObjectHorizontally  ;position object horizontally according to
    moveObjectHorizontally(X)
    //> ldx ObjectOffset            ;counters, return with saved value in A,
    //> rts                         ;put enemy offset back in X and leave
    return
}

// Decompiled from MovePlayerHorizontally
fun movePlayerHorizontally(): Int {
    var temp0: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    //> MovePlayerHorizontally:
    //> lda JumpspringAnimCtrl  ;if jumpspring currently animating,
    //> bne ExXMove             ;branch to leave
    if (!(jumpspringAnimCtrl == 0)) {
        //  goto ExXMove
        return A
    }
    temp0 = jumpspringAnimCtrl
    if (jumpspringAnimCtrl == 0) {
        //> tax                     ;otherwise set zero for offset to use player's stuff
    }
    //> ExXMove:  rts                         ;and leave
    return A
}

// Decompiled from MoveObjectHorizontally
fun moveObjectHorizontally(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXMoveforce by MemoryByteIndexed(SprObject_X_MoveForce)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val sprobjectXSpeed by MemoryByteIndexed(SprObject_X_Speed)
    //> MoveObjectHorizontally:
    //> lda SprObject_X_Speed,x     ;get currently saved value (horizontal
    //> asl                         ;speed, secondary counter, whatever)
    //> asl                         ;and move low nybble to high
    //> asl
    //> asl
    //> sta $01                     ;store result here
    memory[0x1] = ((((((((sprobjectXSpeed[X] shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF).toUByte()
    //> lda SprObject_X_Speed,x     ;get saved value again
    //> lsr                         ;move high nybble to low
    //> lsr
    //> lsr
    //> lsr
    //> cmp #$08                    ;if < 8, branch, do not change
    //> bcc SaveXSpd
    temp0 = sprobjectXSpeed[X] shr 1 shr 1 shr 1 shr 1
    if (sprobjectXSpeed[X] shr 1 shr 1 shr 1 shr 1 >= 0x08) {
        //> ora #%11110000              ;otherwise alter high nybble
        temp1 = temp0 or 0xF0
    }
    //> SaveXSpd: sta $00                     ;save result here
    memory[0x0] = temp0.toUByte()
    //> ldy #$00                    ;load default Y value here
    //> cmp #$00                    ;if result positive, leave Y alone
    //> bpl UseAdder
    temp2 = 0x00
    if (temp0 < 0) {
        //> dey                         ;otherwise decrement Y
        temp2 = (temp2 - 1) and 0xFF
    }
    //> UseAdder: sty $02                     ;save Y here
    memory[0x2] = temp2.toUByte()
    //> lda SprObject_X_MoveForce,x ;get whatever number's here
    temp0 = sprobjectXMoveforce[X]
    //> clc
    //> adc $01                     ;add low nybble moved to high
    temp3 = temp0 + memory[0x1].toInt()
    temp0 = temp3 and 0xFF
    //> sta SprObject_X_MoveForce,x ;store result here
    sprobjectXMoveforce[X] = temp0
    //> lda #$00                    ;init A
    temp0 = 0x00
    //> rol                         ;rotate carry into d0
    temp0 = (temp0 shl 1) and 0xFE or if (temp3 > 0xFF) 1 else 0
    //> pha                         ;push onto stack
    push(temp0)
    //> ror                         ;rotate d0 back onto carry
    temp0 = temp0 shr 1 or if ((temp0 and 0x80) != 0) 0x80 else 0
    //> lda SprObject_X_Position,x
    temp0 = sprobjectXPosition[X]
    //> adc $00                     ;add carry plus saved value (high nybble moved to low
    temp4 = temp0 + memory[0x0].toInt() + (if ((temp0 and 0x01) != 0) 1 else 0)
    temp0 = temp4 and 0xFF
    //> sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
    sprobjectXPosition[X] = temp0
    //> lda SprObject_PageLoc,x
    temp0 = sprobjectPageloc[X]
    //> adc $02                     ;add carry plus other saved value to the
    temp5 = temp0 + memory[0x2].toInt() + (if (temp4 > 0xFF) 1 else 0)
    temp0 = temp5 and 0xFF
    //> sta SprObject_PageLoc,x     ;object's page location and save
    sprobjectPageloc[X] = temp0
    //> pla
    temp0 = pull()
    //> clc                         ;pull old carry from stack and add
    //> adc $00                     ;to high nybble moved to low
    temp6 = temp0 + memory[0x0].toInt()
    temp0 = temp6 and 0xFF
    //> ExXMove:  rts                         ;and leave
    return
}

// Decompiled from MoveD_EnemyVertically
fun movedEnemyvertically(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> MoveD_EnemyVertically:
    //> ldy #$3d           ;set quick movement amount downwards
    //> lda Enemy_State,x  ;then check enemy state
    //> cmp #$05           ;if not set to unique state for spiny's egg, go ahead
    //> bne ContVMove      ;and use, otherwise set different movement amount, continue on
    if (!(enemyState[X] - 0x05 == 0)) {
        //  goto ContVMove
        return
    }
    temp0 = enemyState[X]
    temp1 = 0x3D
    if (enemyState[X] == 0x05) {
    }
    //> ContVMove: jmp SetHiMax   ;jump to skip the rest of this
    //> SetHiMax:    lda #$03                ;set maximum speed in A
    temp0 = 0x03
    // Fall-through tail call to moveFallingPlatform
    moveFallingPlatform()
}

// Decompiled from MoveFallingPlatform
fun moveFallingPlatform() {
    //> MoveFallingPlatform:
    //> ldy #$20       ;set movement amount
    //> ContVMove: jmp SetHiMax   ;jump to skip the rest of this
    //> SetHiMax:    lda #$03                ;set maximum speed in A
}

// Decompiled from MoveDropPlatform
fun moveDropPlatform() {
    var temp0: Int = 0
    //> MoveDropPlatform:
    //> ldy #$7f      ;set movement amount for drop platform
    //> bne SetMdMax  ;skip ahead of other value set here
    temp0 = 0x7F
    if (0x7F == 0) {
    }
    //> SetMdMax: lda #$02         ;set maximum speed in A
    //> bne SetXMoveAmt  ;unconditional branch
    if (!(0x02 == 0)) {
        //  goto SetXMoveAmt
        return
    } else {
        //> ;--------------------------------
    }
    // Fall-through tail call to moveEnemySlowVert
    moveEnemySlowVert()
}

// Decompiled from MoveEnemySlowVert
fun moveEnemySlowVert() {
    //> MoveEnemySlowVert:
    //> ldy #$0f         ;set movement amount for bowser/other objects
    //> SetMdMax: lda #$02         ;set maximum speed in A
    //> bne SetXMoveAmt  ;unconditional branch
    if (!(0x02 == 0)) {
        //  goto SetXMoveAmt
        return
    } else {
        //> ;--------------------------------
    }
    // Fall-through tail call to moveDropPlatform
    moveDropPlatform()
}

// Decompiled from MoveJ_EnemyVertically
fun movejEnemyvertically() {
    //> MoveJ_EnemyVertically:
    //> ldy #$1c                ;set movement amount for podoboo/other objects
    //> SetHiMax:    lda #$03                ;set maximum speed in A
    // Fall-through tail call to setXMoveAmt
    setXMoveAmt(X, 0x1C)
}

// Decompiled from SetXMoveAmt
fun setXMoveAmt(X: Int, Y: Int) {
    var A: Int = 0
    var X: Int = X
    var objectOffset by MemoryByte(ObjectOffset)
    //> SetXMoveAmt: sty $00                 ;set movement amount here
    memory[0x0] = Y.toUByte()
    //> inx                     ;increment X for enemy offset
    X = (X + 1) and 0xFF
    //> jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
    imposeGravitySprObj(A)
    //> ldx ObjectOffset        ;get enemy object buffer offset and leave
    //> rts
    return
}

// Decompiled from ImposeGravityBlock
fun imposeGravityBlock() {
    val maxSpdBlockData by MemoryByteIndexed(MaxSpdBlockData)
    //> ImposeGravityBlock:
    //> ldy #$01       ;set offset for maximum speed
    //> lda #$50       ;set movement amount here
    //> sta $00
    memory[0x0] = 0x50.toUByte()
    //> lda MaxSpdBlockData,y    ;get maximum speed
    // Fall-through tail call to imposeGravitySprObj
    imposeGravitySprObj(maxSpdBlockData[0x01])
}

// Decompiled from ImposeGravitySprObj
fun imposeGravitySprObj(A: Int) {
    //> ImposeGravitySprObj:
    //> sta $02            ;set maximum speed here
    memory[0x2] = A.toUByte()
    //> lda #$00           ;set value to move downwards
    //> jmp ImposeGravity  ;jump to the code that actually moves it
}

// Decompiled from MovePlatformDown
fun movePlatformDown() {
    //> MovePlatformDown:
    //> lda #$00    ;save value to stack (if branching here, execute next
    //> .db $2c     ;part as BIT instruction)
    // Fall-through tail call to movePlatformUp
    movePlatformUp(X)
}

// Decompiled from MovePlatformUp
fun movePlatformUp(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> MovePlatformUp:
    //> lda #$01        ;save value to stack
    //> pha
    push(0x01)
    //> ldy Enemy_ID,x  ;get enemy object identifier
    //> inx             ;increment offset for enemy object
    X = (X + 1) and 0xFF
    //> lda #$05        ;load default value here
    //> cpy #$29        ;residual comparison, object #29 never executes
    //> bne SetDplSpd   ;this code, thus unconditional branch here
    temp0 = 0x05
    temp1 = enemyId[X]
    if (enemyId[X] == 0x29) {
        //> lda #$09        ;residual code
        temp0 = 0x09
    }
    //> SetDplSpd: sta $00         ;save downward movement amount here
    memory[0x0] = temp0.toUByte()
    //> lda #$0a        ;save upward movement amount here
    temp0 = 0x0A
    //> sta $01
    memory[0x1] = temp0.toUByte()
    //> lda #$03        ;save maximum vertical speed here
    temp0 = 0x03
    //> sta $02
    memory[0x2] = temp0.toUByte()
    //> pla             ;get value from stack
    temp0 = pull()
    //> tay             ;use as Y, then move onto code shared by red koopa
    //> RedPTroopaGrav:
    //> jsr ImposeGravity  ;do a sub to move object gradually
    imposeGravity(temp0, X)
    //> ldx ObjectOffset   ;get enemy object offset and leave
    //> rts
    return
}

// Decompiled from ImposeGravity
fun imposeGravity(A: Int, X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    val sprobjectYmfDummy by MemoryByteIndexed(SprObject_YMF_Dummy)
    val sprobjectYHighpos by MemoryByteIndexed(SprObject_Y_HighPos)
    val sprobjectYMoveforce by MemoryByteIndexed(SprObject_Y_MoveForce)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    val sprobjectYSpeed by MemoryByteIndexed(SprObject_Y_Speed)
    //> ImposeGravity:
    //> pha                          ;push value to stack
    push(A)
    //> lda SprObject_YMF_Dummy,x
    //> clc                          ;add value in movement force to contents of dummy variable
    //> adc SprObject_Y_MoveForce,x
    temp0 = sprobjectYmfDummy[X] + sprobjectYMoveforce[X]
    //> sta SprObject_YMF_Dummy,x
    sprobjectYmfDummy[X] = temp0 and 0xFF
    //> ldy #$00                     ;set Y to zero by default
    //> lda SprObject_Y_Speed,x      ;get current vertical speed
    //> bpl AlterYP                  ;if currently moving downwards, do not decrement Y
    temp1 = sprobjectYSpeed[X]
    temp2 = 0x00
    if ((sprobjectYSpeed[X] and 0x80) != 0) {
        //> dey                          ;otherwise decrement Y
        temp2 = (temp2 - 1) and 0xFF
    }
    //> AlterYP: sty $07                      ;store Y here
    memory[0x7] = temp2.toUByte()
    //> adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
    temp3 = temp1 + sprobjectYPosition[X] + (if (temp0 > 0xFF) 1 else 0)
    temp1 = temp3 and 0xFF
    //> sta SprObject_Y_Position,x   ;store as new vertical position
    sprobjectYPosition[X] = temp1
    //> lda SprObject_Y_HighPos,x
    temp1 = sprobjectYHighpos[X]
    //> adc $07                      ;add carry plus contents of $07 to vertical high byte
    temp4 = temp1 + memory[0x7].toInt() + (if (temp3 > 0xFF) 1 else 0)
    temp1 = temp4 and 0xFF
    //> sta SprObject_Y_HighPos,x    ;store as new vertical high byte
    sprobjectYHighpos[X] = temp1
    //> lda SprObject_Y_MoveForce,x
    temp1 = sprobjectYMoveforce[X]
    //> clc
    //> adc $00                      ;add downward movement amount to contents of $0433
    temp5 = temp1 + memory[0x0].toInt()
    temp1 = temp5 and 0xFF
    //> sta SprObject_Y_MoveForce,x
    sprobjectYMoveforce[X] = temp1
    //> lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
    temp1 = sprobjectYSpeed[X]
    //> adc #$00
    temp6 = temp1 + (if (temp5 > 0xFF) 1 else 0)
    temp1 = temp6 and 0xFF
    //> sta SprObject_Y_Speed,x
    sprobjectYSpeed[X] = temp1
    //> cmp $02                      ;compare to maximum speed
    //> bmi ChkUpM                   ;if less than preset value, skip this part
    if (!(temp1 - memory[0x2].toInt() < 0)) {
        //> lda SprObject_Y_MoveForce,x
        temp1 = sprobjectYMoveforce[X]
        //> cmp #$80                     ;if less positively than preset maximum, skip this part
        //> bcc ChkUpM
        if (temp1 >= 0x80) {
            //> lda $02
            temp1 = memory[0x2].toInt()
            //> sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
            sprobjectYSpeed[X] = temp1
            //> lda #$00
            temp1 = 0x00
            //> sta SprObject_Y_MoveForce,x  ;clear fractional
            sprobjectYMoveforce[X] = temp1
        }
    }
    //> ChkUpM:  pla                          ;get value from stack
    temp1 = pull()
    //> beq ExVMove                  ;if set to zero, branch to leave
    if (temp1 != 0) {
        //> lda $02
        temp1 = memory[0x2].toInt()
        //> eor #%11111111               ;otherwise get two's compliment of maximum speed
        temp7 = temp1 xor 0xFF
        //> tay
        //> iny
        temp7 = (temp7 + 1) and 0xFF
        //> sty $07                      ;store two's compliment here
        memory[0x7] = temp7.toUByte()
        //> lda SprObject_Y_MoveForce,x
        temp1 = sprobjectYMoveforce[X]
        //> sec                          ;subtract upward movement amount from contents
        //> sbc $01                      ;of movement force, note that $01 is twice as large as $00,
        temp8 = temp1 - memory[0x1].toInt()
        temp1 = temp8 and 0xFF
        //> sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
        sprobjectYMoveforce[X] = temp1
        //> lda SprObject_Y_Speed,x
        temp1 = sprobjectYSpeed[X]
        //> sbc #$00                     ;subtract borrow from vertical speed and store
        temp9 = temp1 - (if (temp8 >= 0) 0 else 1)
        temp1 = temp9 and 0xFF
        //> sta SprObject_Y_Speed,x
        sprobjectYSpeed[X] = temp1
        //> cmp $07                      ;compare vertical speed to two's compliment
        //> bpl ExVMove                  ;if less negatively than preset maximum, skip this part
        temp2 = temp7
        if (temp1 - memory[0x7].toInt() < 0) {
            //> lda SprObject_Y_MoveForce,x
            temp1 = sprobjectYMoveforce[X]
            //> cmp #$80                     ;check if fractional part is above certain amount,
            //> bcs ExVMove                  ;and if so, branch to leave
            if (!(temp1 >= 0x80)) {
                //> lda $07
                temp1 = memory[0x7].toInt()
                //> sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
                sprobjectYSpeed[X] = temp1
                //> lda #$ff
                temp1 = 0xFF
                //> sta SprObject_Y_MoveForce,x  ;clear fractional
                sprobjectYMoveforce[X] = temp1
            }
        }
    }
    //> ExVMove: rts                          ;leave!
    return
}

// Decompiled from EnemiesAndLoopsCore
fun enemiesAndLoopsCore(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp16: Int = 0
    var temp17: Int = 0
    var temp18: Int = 0
    var temp19: Int = 0
    var temp2: Int = 0
    var temp20: Int = 0
    var temp21: Int = 0
    var temp22: Int = 0
    var temp23: Int = 0
    var temp24: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var areaParserTaskNum by MemoryByte(AreaParserTaskNum)
    var areaPointer by MemoryByte(AreaPointer)
    var currentColumnPos by MemoryByte(CurrentColumnPos)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var enemyFrenzyQueue by MemoryByte(EnemyFrenzyQueue)
    var enemyObjectPageLoc by MemoryByte(EnemyObjectPageLoc)
    var enemyObjectPageSel by MemoryByte(EnemyObjectPageSel)
    var entrancePage by MemoryByte(EntrancePage)
    var loopCommand by MemoryByte(LoopCommand)
    var multiLoopCorrectCntr by MemoryByte(MultiLoopCorrectCntr)
    var multiLoopPassCntr by MemoryByte(MultiLoopPassCntr)
    var numberofGroupEnemies by MemoryByte(NumberofGroupEnemies)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerState by MemoryByte(Player_State)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var vineFlagOffset by MemoryByte(VineFlagOffset)
    var worldNumber by MemoryByte(WorldNumber)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val loopCmdPageNumber by MemoryByteIndexed(LoopCmdPageNumber)
    val loopCmdWorldNumber by MemoryByteIndexed(LoopCmdWorldNumber)
    val loopCmdYPosition by MemoryByteIndexed(LoopCmdYPosition)
    //> EnemiesAndLoopsCore:
    //> lda Enemy_Flag,x         ;check data here for MSB set
    //> pha                      ;save in stack
    push(enemyFlag[X])
    //> asl
    //> bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
    temp0 = (enemyFlag[X] shl 1) and 0xFF
    if ((enemyFlag[X] and 0x80) == 0) {
        //> pla                      ;get from stack
        temp0 = pull()
        //> beq ChkAreaTsk           ;if data zero, branch
        if (temp0 != 0) {
            //> jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
        }
        //> ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
        temp0 = areaParserTaskNum
        //> and #$07
        temp1 = temp0 and 0x07
        //> cmp #$07                 ;if at a specific task, jump and leave
        //> beq ExitELCore
        temp0 = temp1
        if (temp1 != 0x07) {
        } else {
            //> ExitELCore: rts
            return
        }
    } else {
        //> ChkBowserF: pla                      ;get data from stack
        temp0 = pull()
        //> and #%00001111           ;mask out high nybble
        temp2 = temp0 and 0x0F
        //> tay
        //> lda Enemy_Flag,y         ;use as pointer and load same place with different offset
        temp0 = enemyFlag[temp2]
        //> bne ExitELCore
        temp3 = temp2
        if (temp0 == 0) {
            //> sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
            enemyFlag[X] = temp0
        }
    }
    //> ProcLoopCommand:
    //> lda LoopCommand           ;check if loop command was found
    temp0 = loopCommand
    //> beq ChkEnemyFrenzy
    if (temp0 != 0) {
        //> lda CurrentColumnPos      ;check to see if we're still on the first page
        temp0 = currentColumnPos
        //> bne ChkEnemyFrenzy        ;if not, do not loop yet
        if (temp0 == 0) {
            //> ldy #$0b                  ;start at the end of each set of loop data
            temp3 = 0x0B
            while (temp0 != loopCmdPageNumber[temp3]) {
                //> lda WorldNumber           ;check to see if one of the world numbers
                temp0 = worldNumber
                //> cmp LoopCmdWorldNumber,y  ;matches our current world number
                //> bne FindLoop
                //> lda CurrentPageLoc        ;check to see if one of the page numbers
                temp0 = currentPageLoc
                //> cmp LoopCmdPageNumber,y   ;matches the page we're currently on
                //> bne FindLoop
            }
            //> lda Player_Y_Position     ;check to see if the player is at the correct position
            temp0 = playerYPosition
            //> cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
            //> bne WrongChk
            if (temp0 == loopCmdYPosition[temp3]) {
                //> lda Player_State          ;check to see if the player is
                temp0 = playerState
                //> cmp #$00                  ;on solid ground (i.e. not jumping or falling)
                //> bne WrongChk              ;if not, player fails to pass loop, and loopback
                if (temp0 == 0) {
                    //> lda WorldNumber           ;are we in world 7? (check performed on correct
                    temp0 = worldNumber
                    //> cmp #World7               ;vertical position and on solid ground)
                    //> bne InitMLp               ;if not, initialize flags used there, otherwise
                    if (temp0 == World7) {
                        //> inc MultiLoopCorrectCntr  ;increment counter for correct progression
                        multiLoopCorrectCntr = (multiLoopCorrectCntr + 1) and 0xFF
                        //> IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
                        multiLoopPassCntr = (multiLoopPassCntr + 1) and 0xFF
                        //> lda MultiLoopPassCntr     ;have we done all three parts?
                        temp0 = multiLoopPassCntr
                        //> cmp #$03
                        //> bne InitLCmd              ;if not, skip this part
                        if (temp0 == 0x03) {
                            //> lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
                            temp0 = multiLoopCorrectCntr
                            //> cmp #$03
                            //> beq InitMLp               ;if so, branch past unnecessary check here
                            if (temp0 != 0x03) {
                                //> bne DoLpBack              ;unconditional branch if previous branch fails
                                if (temp0 == 0x03) {
                                }
                            }
                        }
                    }
                }
            }
            do {
                //> WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
                temp0 = worldNumber
                //> cmp #World7               ;incorrect vertical position or not on solid ground)
                //> beq IncMLoop
            } while (temp0 == World7)
            //> DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
            execGameLoopback(temp3)
            //> jsr KillAllEnemies
            killAllEnemies(temp0)
            //> InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
            temp0 = 0x00
            //> sta MultiLoopPassCntr
            multiLoopPassCntr = temp0
            //> sta MultiLoopCorrectCntr
            multiLoopCorrectCntr = temp0
            //> InitLCmd: lda #$00                  ;initialize loop command flag
            temp0 = 0x00
            //> sta LoopCommand
            loopCommand = temp0
            //> ;--------------------------------
        }
    }
    //> ChkEnemyFrenzy:
    //> lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
    temp0 = enemyFrenzyQueue
    //> beq ProcessEnemyData  ;if not, skip this part
    if (temp0 != 0) {
        //> sta Enemy_ID,x        ;store as enemy object identifier here
        enemyId[X] = temp0
        //> lda #$01
        temp0 = 0x01
        //> sta Enemy_Flag,x      ;activate enemy object flag
        enemyFlag[X] = temp0
        //> lda #$00
        temp0 = 0x00
        //> sta Enemy_State,x     ;initialize state and frenzy queue
        enemyState[X] = temp0
        //> sta EnemyFrenzyQueue
        enemyFrenzyQueue = temp0
        //> jmp InitEnemyObject   ;and then jump to deal with this enemy
    }
    //> ProcessEnemyData:
    //> ldy EnemyDataOffset      ;get offset of enemy object data
    temp3 = enemyDataOffset
    //> lda (EnemyData),y        ;load first byte
    temp0 = memory[readWord(EnemyData) + temp3].toInt()
    //> cmp #$ff                 ;check for EOD terminator
    //> bne CheckEndofBuffer
    if (temp0 == 0xFF) {
    } else {
        //> CheckEndofBuffer:
        //> and #%00001111           ;check for special row $0e
        temp4 = temp0 and 0x0F
        //> cmp #$0e
        //> beq CheckRightBounds     ;if found, branch, otherwise
        temp0 = temp4
        if (temp4 != 0x0E) {
            //> cpx #$05                 ;check for end of buffer
            //> bcc CheckRightBounds     ;if not at end of buffer, branch
            if (X >= 0x05) {
                //> iny
                temp3 = (temp3 + 1) and 0xFF
                //> lda (EnemyData),y        ;check for specific value here
                temp0 = memory[readWord(EnemyData) + temp3].toInt()
                //> and #%00111111           ;not sure what this was intended for, exactly
                temp5 = temp0 and 0x3F
                //> cmp #$2e                 ;this part is quite possibly residual code
                //> beq CheckRightBounds     ;but it has the effect of keeping enemies out of
                temp0 = temp5
                if (temp5 != 0x2E) {
                    //> rts                      ;the sixth slot
                    return
                }
            }
        }
        //> CheckRightBounds:
        //> lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
        temp0 = screenrightXPos
        //> clc
        //> adc #$30
        temp6 = temp0 + 0x30
        temp0 = temp6 and 0xFF
        //> and #%11110000           ;store high nybble
        temp7 = temp0 and 0xF0
        //> sta $07
        memory[0x7] = temp7.toUByte()
        //> lda ScreenRight_PageLoc  ;add carry to page location of right boundary
        temp0 = screenrightPageloc
        //> adc #$00
        temp8 = temp0 + (if (temp6 > 0xFF) 1 else 0)
        temp0 = temp8 and 0xFF
        //> sta $06                  ;store page location + carry
        memory[0x6] = temp0.toUByte()
        //> ldy EnemyDataOffset
        temp3 = enemyDataOffset
        //> iny
        temp3 = (temp3 + 1) and 0xFF
        //> lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
        temp0 = memory[readWord(EnemyData) + temp3].toInt()
        //> asl
        temp0 = (temp0 shl 1) and 0xFF
        //> bcc CheckPageCtrlRow
        if ((temp0 and 0x80) != 0) {
            //> lda EnemyObjectPageSel   ;if page select already set, do not set again
            temp0 = enemyObjectPageSel
            //> bne CheckPageCtrlRow
            if (temp0 == 0) {
                //> inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
                enemyObjectPageSel = (enemyObjectPageSel + 1) and 0xFF
                //> inc EnemyObjectPageLoc   ;and increment page control
                enemyObjectPageLoc = (enemyObjectPageLoc + 1) and 0xFF
            }
        }
        //> CheckPageCtrlRow:
        //> dey
        temp3 = (temp3 - 1) and 0xFF
        //> lda (EnemyData),y        ;reread first byte
        temp0 = memory[readWord(EnemyData) + temp3].toInt()
        //> and #$0f
        temp9 = temp0 and 0x0F
        //> cmp #$0f                 ;check for special row $0f
        //> bne PositionEnemyObj     ;if not found, branch to position enemy object
        temp0 = temp9
        if (temp9 == 0x0F) {
            //> lda EnemyObjectPageSel   ;if page select set,
            temp0 = enemyObjectPageSel
            //> bne PositionEnemyObj     ;branch without reading second byte
            if (temp0 == 0) {
                while (true) {
                    //> FindLoop: dey
                    temp3 = (temp3 - 1) and 0xFF
                    //> bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
                    //> jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
                    //> iny
                    temp3 = (temp3 + 1) and 0xFF
                    //> lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
                    temp0 = memory[readWord(EnemyData) + temp3].toInt()
                    //> and #%00111111
                    temp10 = temp0 and 0x3F
                    //> sta EnemyObjectPageLoc   ;store as page control for enemy object data
                    enemyObjectPageLoc = temp10
                    //> inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
                    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
                    //> inc EnemyDataOffset
                    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
                    //> inc EnemyObjectPageSel   ;set page select for enemy object data and
                    enemyObjectPageSel = (enemyObjectPageSel + 1) and 0xFF
                    //> jmp ProcLoopCommand      ;jump back to process loop commands again
                }
            }
        }
        //> PositionEnemyObj:
        //> lda EnemyObjectPageLoc   ;store page control as page location
        temp0 = enemyObjectPageLoc
        //> sta Enemy_PageLoc,x      ;for enemy object
        enemyPageloc[X] = temp0
        //> lda (EnemyData),y        ;get first byte of enemy object
        temp0 = memory[readWord(EnemyData) + temp3].toInt()
        //> and #%11110000
        temp11 = temp0 and 0xF0
        //> sta Enemy_X_Position,x   ;store column position
        enemyXPosition[X] = temp11
        //> cmp ScreenRight_X_Pos    ;check column position against right boundary
        //> lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
        temp0 = enemyPageloc[X]
        //> sbc ScreenRight_PageLoc  ;from page location
        temp12 = temp0 - screenrightPageloc - (if (temp11 >= screenrightXPos) 0 else 1)
        temp0 = temp12 and 0xFF
        //> bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
        if (!(temp12 >= 0)) {
            //> lda (EnemyData),y
            temp0 = memory[readWord(EnemyData) + temp3].toInt()
            //> and #%00001111           ;check for special row $0e
            temp13 = temp0 and 0x0F
            //> cmp #$0e                 ;if found, jump elsewhere
            //> beq ParseRow0e
            temp0 = temp13
            if (temp13 != 0x0E) {
                //> jmp CheckThreeBytes      ;if not found, unconditional jump
            }
        }
        //> CheckRightExtBounds:
        //> lda $07                  ;check right boundary + 48 against
        temp0 = memory[0x7].toInt()
        //> cmp Enemy_X_Position,x   ;column position without subtracting,
        //> lda $06                  ;then subtract borrow from page control temp
        temp0 = memory[0x6].toInt()
        //> sbc Enemy_PageLoc,x      ;plus carry
        temp14 = temp0 - enemyPageloc[X] - (if (temp0 >= enemyXPosition[X]) 0 else 1)
        temp0 = temp14 and 0xFF
        //> bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
        if (temp14 >= 0) {
            //> lda #$01                 ;store value in vertical high byte
            temp0 = 0x01
            //> sta Enemy_Y_HighPos,x
            enemyYHighpos[X] = temp0
            //> lda (EnemyData),y        ;get first byte again
            temp0 = memory[readWord(EnemyData) + temp3].toInt()
            //> asl                      ;multiply by four to get the vertical
            temp0 = (temp0 shl 1) and 0xFF
            //> asl                      ;coordinate
            temp0 = (temp0 shl 1) and 0xFF
            //> asl
            temp0 = (temp0 shl 1) and 0xFF
            //> asl
            temp0 = (temp0 shl 1) and 0xFF
            //> sta Enemy_Y_Position,x
            enemyYPosition[X] = temp0
            //> cmp #$e0                 ;do one last check for special row $0e
            //> beq ParseRow0e           ;(necessary if branched to $c1cb)
            if (temp0 != 0xE0) {
                //> iny
                temp3 = (temp3 + 1) and 0xFF
                //> lda (EnemyData),y        ;get second byte of object
                temp0 = memory[readWord(EnemyData) + temp3].toInt()
                //> and #%01000000           ;check to see if hard mode bit is set
                temp15 = temp0 and 0x40
                //> beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
                temp0 = temp15
                if (temp15 != 0) {
                    //> lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
                    temp0 = secondaryHardMode
                    //> beq Inc2B                ;is on, and if not, branch to skip this object completely
                    if (temp0 != 0) {
                    } else {
                        //> Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
                        enemyDataOffset = (enemyDataOffset + 1) and 0xFF
                        //> inc EnemyDataOffset
                        enemyDataOffset = (enemyDataOffset + 1) and 0xFF
                        //> lda #$00                 ;init page select for enemy objects
                        temp0 = 0x00
                        //> sta EnemyObjectPageSel
                        enemyObjectPageSel = temp0
                        //> ldx ObjectOffset         ;reload current offset in enemy buffers
                        //> rts                      ;and leave
                        return
                    }
                }
                //> CheckForEnemyGroup:
                //> lda (EnemyData),y      ;get second byte and mask out 2 MSB
                temp0 = memory[readWord(EnemyData) + temp3].toInt()
                //> and #%00111111
                temp16 = temp0 and 0x3F
                //> cmp #$37               ;check for value below $37
                //> bcc BuzzyBeetleMutate
                temp0 = temp16
                if (temp16 >= 0x37) {
                    //> cmp #$3f               ;if $37 or greater, check for value
                    //> bcc DoGroup            ;below $3f, branch if below $3f
                    if (!(temp0 >= 0x3F)) {
                        //  goto DoGroup
                        return
                    }
                    if (temp0 >= 0x3F) {
                    }
                }
                //> BuzzyBeetleMutate:
                //> cmp #Goomba          ;if below $37, check for goomba
                //> bne StrID            ;value ($3f or more always fails)
                if (temp0 == Goomba) {
                    //> ldy PrimaryHardMode  ;check if primary hard mode flag is set
                    temp3 = primaryHardMode
                    //> beq StrID            ;and if so, change goomba to buzzy beetle
                    if (temp3 != 0) {
                        //> lda #BuzzyBeetle
                        temp0 = BuzzyBeetle
                    }
                }
                //> StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                enemyId[X] = temp0
                //> lda #$01
                temp0 = 0x01
                //> sta Enemy_Flag,x     ;set flag for enemy in buffer
                enemyFlag[X] = temp0
                //> jsr InitEnemyObject
                initEnemyObject(X)
                //> lda Enemy_Flag,x     ;check to see if flag is set
                temp0 = enemyFlag[X]
                //> bne Inc2B            ;if not, leave, otherwise branch
                if (temp0 == 0) {
                    //> rts
                    return
                }
            }
        }
    }
    //> CheckFrenzyBuffer:
    //> lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
    temp0 = enemyFrenzyBuffer
    //> bne StrFre               ;then branch ahead to store in enemy object buffer
    if (temp0 == 0) {
        //> lda VineFlagOffset       ;otherwise check vine flag offset
        temp0 = vineFlagOffset
        //> cmp #$01
        //> bne ExEPar               ;if other value <> 1, leave
        if (temp0 == 0x01) {
            //> lda #VineObject          ;otherwise put vine in enemy identifier
            temp0 = VineObject
        } else {
            //> ExEPar: rts                      ;then leave
            return
        }
    }
    //> StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
    enemyId[X] = temp0
    //> DoGroup:
    //> jmp HandleGroupEnemies   ;handle enemy group objects
    //> ParseRow0e:
    //> iny                      ;increment Y to load third byte of object
    temp3 = (temp3 + 1) and 0xFF
    //> iny
    temp3 = (temp3 + 1) and 0xFF
    //> lda (EnemyData),y
    temp0 = memory[readWord(EnemyData) + temp3].toInt()
    //> lsr                      ;move 3 MSB to the bottom, effectively
    temp0 = temp0 shr 1
    //> lsr                      ;making %xxx00000 into %00000xxx
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> cmp WorldNumber          ;is it the same world number as we're on?
    //> bne NotUse               ;if not, do not use (this allows multiple uses
    if (!(temp0 - worldNumber == 0)) {
        //  goto NotUse
        return
    }
    if (temp0 == worldNumber) {
        //> dey                      ;of the same area, like the underground bonus areas)
        temp3 = (temp3 - 1) and 0xFF
        //> lda (EnemyData),y        ;otherwise, get second byte and use as offset
        temp0 = memory[readWord(EnemyData) + temp3].toInt()
        //> sta AreaPointer          ;to addresses for level and enemy object data
        areaPointer = temp0
        //> iny
        temp3 = (temp3 + 1) and 0xFF
        //> lda (EnemyData),y        ;get third byte again, and this time mask out
        temp0 = memory[readWord(EnemyData) + temp3].toInt()
        //> and #%00011111           ;the 3 MSB from before, save as page number to be
        temp17 = temp0 and 0x1F
        //> sta EntrancePage         ;used upon entry to area, if area is entered
        entrancePage = temp17
    }
    //> NotUse: jmp Inc3B
    //> CheckThreeBytes:
    //> ldy EnemyDataOffset      ;load current offset for enemy object data
    temp3 = enemyDataOffset
    //> lda (EnemyData),y        ;get first byte
    temp0 = memory[readWord(EnemyData) + temp3].toInt()
    //> and #%00001111           ;check for special row $0e
    temp18 = temp0 and 0x0F
    //> cmp #$0e
    //> bne Inc2B
    temp0 = temp18
    if (temp18 == 0x0E) {
        //> Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
        enemyDataOffset = (enemyDataOffset + 1) and 0xFF
    }
    //> HandleGroupEnemies:
    //> ldy #$00                  ;load value for green koopa troopa
    temp3 = 0x00
    //> sec
    //> sbc #$37                  ;subtract $37 from second byte read
    temp19 = temp0 - 0x37
    temp0 = temp19 and 0xFF
    //> pha                       ;save result in stack for now
    push(temp0)
    //> cmp #$04                  ;was byte in $3b-$3e range?
    //> bcs SnglID                ;if so, branch
    if (!(temp0 >= 0x04)) {
        //> pha                       ;save another copy to stack
        push(temp0)
        //> ldy #Goomba               ;load value for goomba enemy
        temp3 = Goomba
        //> lda PrimaryHardMode       ;if primary hard mode flag not set,
        temp0 = primaryHardMode
        //> beq PullID                ;branch, otherwise change to value
        if (temp0 != 0) {
            //> ldy #BuzzyBeetle          ;for buzzy beetle
            temp3 = BuzzyBeetle
        }
        //> PullID: pla                       ;get second copy from stack
        temp0 = pull()
    }
    //> SnglID: sty $01                   ;save enemy id here
    memory[0x1] = temp3.toUByte()
    //> ldy #$b0                  ;load default y coordinate
    temp3 = 0xB0
    //> and #$02                  ;check to see if d1 was set
    temp20 = temp0 and 0x02
    //> beq SetYGp                ;if so, move y coordinate up,
    temp0 = temp20
    if (temp20 != 0) {
        //> ldy #$70                  ;otherwise branch and use default
        temp3 = 0x70
    }
    //> SetYGp: sty $00                   ;save y coordinate here
    memory[0x0] = temp3.toUByte()
    //> lda ScreenRight_PageLoc   ;get page number of right edge of screen
    temp0 = screenrightPageloc
    //> sta $02                   ;save here
    memory[0x2] = temp0.toUByte()
    //> lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
    temp0 = screenrightXPos
    //> sta $03                   ;save here
    memory[0x3] = temp0.toUByte()
    //> ldy #$02                  ;load two enemies by default
    temp3 = 0x02
    //> pla                       ;get first copy from stack
    temp0 = pull()
    //> lsr                       ;check to see if d0 was set
    temp0 = temp0 shr 1
    //> bcc CntGrp                ;if not, use default value
    if ((temp0 and 0x01) != 0) {
        //> iny                       ;otherwise increment to three enemies
        temp3 = (temp3 + 1) and 0xFF
    }
    //> CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
    numberofGroupEnemies = temp3
    while (numberofGroupEnemies != 0) {
        //> GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
        //> GSltLp: inx                       ;increment and branch if past
        temp21 = 0xFF
        temp21 = (temp21 + 1) and 0xFF
        //> cpx #$05                  ;end of buffers
        //> bcs NextED
        if (temp21 >= 0x05) {
            //  goto NextED
            return
        }
        //> lda Enemy_Flag,x          ;check to see if enemy is already
        temp0 = enemyFlag[temp21]
        //> bne GSltLp                ;stored in buffer, and branch if so
        //> lda $01
        temp0 = memory[0x1].toInt()
        //> sta Enemy_ID,x            ;store enemy object identifier
        enemyId[temp21] = temp0
        //> lda $02
        temp0 = memory[0x2].toInt()
        //> sta Enemy_PageLoc,x       ;store page location for enemy object
        enemyPageloc[temp21] = temp0
        //> lda $03
        temp0 = memory[0x3].toInt()
        //> sta Enemy_X_Position,x    ;store x coordinate for enemy object
        enemyXPosition[temp21] = temp0
        //> clc
        //> adc #$18                  ;add 24 pixels for next enemy
        temp22 = temp0 + 0x18
        temp0 = temp22 and 0xFF
        //> sta $03
        memory[0x3] = temp0.toUByte()
        //> lda $02                   ;add carry to page location for
        temp0 = memory[0x2].toInt()
        //> adc #$00                  ;next enemy
        temp23 = temp0 + (if (temp22 > 0xFF) 1 else 0)
        temp0 = temp23 and 0xFF
        //> sta $02
        memory[0x2] = temp0.toUByte()
        //> lda $00                   ;store y coordinate for enemy object
        temp0 = memory[0x0].toInt()
        //> sta Enemy_Y_Position,x
        enemyYPosition[temp21] = temp0
        //> lda #$01                  ;activate flag for buffer, and
        temp0 = 0x01
        //> sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
        enemyYHighpos[temp21] = temp0
        //> sta Enemy_Flag,x
        enemyFlag[temp21] = temp0
        //> jsr CheckpointEnemyID     ;process each enemy object separately
        checkpointEnemyID(temp21)
        //> dec NumberofGroupEnemies  ;do this until we run out of enemy objects
        numberofGroupEnemies = (numberofGroupEnemies - 1) and 0xFF
        //> bne GrLoop
    }
    while (true) {
        //> NextED: jmp Inc2B                 ;jump to increment data offset and leave
    }
    //> RunEnemyObjectsCore:
    //> ldx ObjectOffset  ;get offset for enemy object buffer
    temp21 = objectOffset
    //> lda #$00          ;load value 0 for jump engine by default
    temp0 = 0x00
    //> ldy Enemy_ID,x
    temp3 = enemyId[temp21]
    //> cpy #$15          ;if enemy object < $15, use default value
    //> bcc JmpEO
    if (temp3 >= 0x15) {
        //> tya               ;otherwise subtract $14 from the value and use
        //> sbc #$14          ;as value for jump engine
        temp24 = temp3 - 0x14 - (if (temp3 >= 0x15) 0 else 1)
        temp0 = temp24 and 0xFF
    }
    //> JmpEO: jsr JumpEngine
    when (temp0) {
        0 -> {
            runNormalEnemies(temp21)
        }
        1 -> {
            runBowserFlame()
        }
        2 -> {
            runFireworks(temp21)
        }
        3 -> {
            noRunCode()
        }
        4 -> {
            noRunCode()
        }
        5 -> {
            noRunCode()
        }
        6 -> {
            noRunCode()
        }
        7 -> {
            runFirebarObj()
        }
        8 -> {
            runFirebarObj()
        }
        9 -> {
            runFirebarObj()
        }
        10 -> {
            runFirebarObj()
        }
        11 -> {
            runFirebarObj()
        }
        12 -> {
            runFirebarObj()
        }
        13 -> {
            runFirebarObj()
        }
        14 -> {
            runFirebarObj()
        }
        15 -> {
            noRunCode()
        }
        16 -> {
            runLargePlatform()
        }
        17 -> {
            runLargePlatform()
        }
        18 -> {
            runLargePlatform()
        }
        19 -> {
            runLargePlatform()
        }
        20 -> {
            runLargePlatform()
        }
        21 -> {
            runLargePlatform()
        }
        22 -> {
            runLargePlatform()
        }
        23 -> {
            runSmallPlatform()
        }
        24 -> {
            runSmallPlatform()
        }
        25 -> {
            runBowser(temp21)
        }
        26 -> {
            powerUpObjHandler()
        }
        27 -> {
            vineObjectHandler(temp21)
        }
        28 -> {
            noRunCode()
        }
        29 -> {
            runStarFlagObj()
        }
        30 -> {
            jumpspringHandler(temp21)
        }
        31 -> {
            noRunCode()
        }
        32 -> {
            warpZoneObject()
        }
        33 -> {
            runRetainerObj()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from ExecGameLoopback
fun execGameLoopback(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaDataOffset by MemoryByte(AreaDataOffset)
    var areaObjectPageLoc by MemoryByte(AreaObjectPageLoc)
    var areaObjectPageSel by MemoryByte(AreaObjectPageSel)
    var currentPageLoc by MemoryByte(CurrentPageLoc)
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    var enemyObjectPageLoc by MemoryByte(EnemyObjectPageLoc)
    var enemyObjectPageSel by MemoryByte(EnemyObjectPageSel)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    val areaDataOfsLoopback by MemoryByteIndexed(AreaDataOfsLoopback)
    //> ExecGameLoopback:
    //> lda Player_PageLoc        ;send player back four pages
    //> sec
    //> sbc #$04
    temp0 = playerPageloc - 0x04
    //> sta Player_PageLoc
    playerPageloc = temp0 and 0xFF
    //> lda CurrentPageLoc        ;send current page back four pages
    //> sec
    //> sbc #$04
    temp1 = currentPageLoc - 0x04
    //> sta CurrentPageLoc
    currentPageLoc = temp1 and 0xFF
    //> lda ScreenLeft_PageLoc    ;subtract four from page location
    //> sec                       ;of screen's left border
    //> sbc #$04
    temp2 = screenleftPageloc - 0x04
    //> sta ScreenLeft_PageLoc
    screenleftPageloc = temp2 and 0xFF
    //> lda ScreenRight_PageLoc   ;do the same for the page location
    //> sec                       ;of screen's right border
    //> sbc #$04
    temp3 = screenrightPageloc - 0x04
    //> sta ScreenRight_PageLoc
    screenrightPageloc = temp3 and 0xFF
    //> lda AreaObjectPageLoc     ;subtract four from page control
    //> sec                       ;for area objects
    //> sbc #$04
    temp4 = areaObjectPageLoc - 0x04
    //> sta AreaObjectPageLoc
    areaObjectPageLoc = temp4 and 0xFF
    //> lda #$00                  ;initialize page select for both
    //> sta EnemyObjectPageSel    ;area and enemy objects
    enemyObjectPageSel = 0x00
    //> sta AreaObjectPageSel
    areaObjectPageSel = 0x00
    //> sta EnemyDataOffset       ;initialize enemy object data offset
    enemyDataOffset = 0x00
    //> sta EnemyObjectPageLoc    ;and enemy object page control
    enemyObjectPageLoc = 0x00
    //> lda AreaDataOfsLoopback,y ;adjust area object offset based on
    //> sta AreaDataOffset        ;which loop command we encountered
    areaDataOffset = areaDataOfsLoopback[Y]
    //> rts
    return
}

// Decompiled from InitEnemyObject
fun initEnemyObject(X: Int) {
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> InitEnemyObject:
    //> lda #$00                 ;initialize enemy state
    //> sta Enemy_State,x
    enemyState[X] = 0x00
    //> jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
    checkpointEnemyID(X)
    //> ExEPar: rts                      ;then leave
    return
}

// Decompiled from CheckpointEnemyID
fun checkpointEnemyID(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> CheckpointEnemyID:
    //> lda Enemy_ID,x
    //> cmp #$15                     ;check enemy object identifier for $15 or greater
    //> bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
    temp0 = enemyId[X]
    if (!(enemyId[X] >= 0x15)) {
        //> tay                          ;save identifier in Y register for now
        //> lda Enemy_Y_Position,x
        temp0 = enemyYPosition[X]
        //> adc #$08                     ;add eight pixels to what will eventually be the
        temp1 = temp0 + 0x08 + (if (enemyId[X] >= 0x15) 1 else 0)
        temp0 = temp1 and 0xFF
        //> sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
        enemyYPosition[X] = temp0
        //> lda #$01
        temp0 = 0x01
        //> sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
        enemyOffscrBitsMasked[X] = temp0
        //> tya                          ;get identifier back and use as offset for jump engine
    }
    //> InitEnemyRoutines:
    //> jsr JumpEngine
    when (temp0) {
        0 -> {
            initNormalEnemy(X)
        }
        1 -> {
            initNormalEnemy(X)
        }
        2 -> {
            initNormalEnemy(X)
        }
        3 -> {
            initRedKoopa(X)
        }
        4 -> {
            noInitCode()
        }
        5 -> {
            initHammerBro(X)
        }
        6 -> {
            initGoomba()
        }
        7 -> {
            initBloober(X)
        }
        8 -> {
            initBulletBill(X)
        }
        9 -> {
            noInitCode()
        }
        10 -> {
            initCheepCheep(X)
        }
        11 -> {
            initCheepCheep(X)
        }
        12 -> {
            initPodoboo(X)
        }
        13 -> {
            initPiranhaPlant(X)
        }
        14 -> {
            initJumpGPTroopa(X)
        }
        15 -> {
            initRedPTroopa(X)
        }
        16 -> {
            initHorizFlySwimEnemy(X)
        }
        17 -> {
            initLakitu()
        }
        18 -> {
            initEnemyFrenzy(X)
        }
        19 -> {
            noInitCode()
        }
        20 -> {
            initEnemyFrenzy(X)
        }
        21 -> {
            initEnemyFrenzy(X)
        }
        22 -> {
            initEnemyFrenzy(X)
        }
        23 -> {
            initEnemyFrenzy(X)
        }
        24 -> {
            endFrenzy(X)
        }
        25 -> {
            noInitCode()
        }
        26 -> {
            noInitCode()
        }
        27 -> {
            initShortFirebar(X)
        }
        28 -> {
            initShortFirebar(X)
        }
        29 -> {
            initShortFirebar(X)
        }
        30 -> {
            initShortFirebar(X)
        }
        31 -> {
            initLongFirebar()
        }
        32 -> {
            noInitCode()
        }
        33 -> {
            noInitCode()
        }
        34 -> {
            noInitCode()
        }
        35 -> {
            noInitCode()
        }
        36 -> {
            initBalPlatform(X)
        }
        37 -> {
            initVertPlatform(X)
        }
        38 -> {
            largeLiftUp(X)
        }
        39 -> {
            largeLiftDown(X)
        }
        40 -> {
            initHoriPlatform(X)
        }
        41 -> {
            initDropPlatform(X)
        }
        42 -> {
            initHoriPlatform(X)
        }
        43 -> {
            platLiftUp(X)
        }
        44 -> {
            platLiftDown(X)
        }
        45 -> {
            initBowser(X)
        }
        46 -> {
            pwrUpJmp()
        }
        47 -> {
            setupVine(X, Y)
        }
        48 -> {
            noInitCode()
        }
        49 -> {
            noInitCode()
        }
        50 -> {
            noInitCode()
        }
        51 -> {
            noInitCode()
        }
        52 -> {
            noInitCode()
        }
        53 -> {
            initRetainerObj(X)
        }
        54 -> {
            endOfEnemyInitCode()
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from NoInitCode
fun noInitCode() {
    //> NoInitCode:
    //> rts               ;this executed when enemy object has no init code
    return
}

// Decompiled from InitGoomba
fun initGoomba() {
    var X: Int = 0
    //> InitGoomba:
    //> jsr InitNormalEnemy  ;set appropriate horizontal speed
    initNormalEnemy(X)
    //> jmp SmallBBox        ;set $09 as bounding box control, set other values
}

// Decompiled from InitPodoboo
fun initPodoboo(X: Int) {
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> InitPodoboo:
    //> lda #$02                  ;set enemy position to below
    //> sta Enemy_Y_HighPos,x     ;the bottom of the screen
    enemyYHighpos[X] = 0x02
    //> sta Enemy_Y_Position,x
    enemyYPosition[X] = 0x02
    //> lsr
    //> sta EnemyIntervalTimer,x  ;set timer for enemy
    enemyIntervalTimer[X] = 0x02 shr 1
    //> lsr
    //> sta Enemy_State,x         ;initialize enemy state, then jump to use
    enemyState[X] = 0x02 shr 1 shr 1
    //> jmp SmallBBox             ;$09 as bounding box size and set other things
}

// Decompiled from InitRetainerObj
fun initRetainerObj(X: Int) {
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> InitRetainerObj:
    //> lda #$b8                ;set fixed vertical position for
    //> sta Enemy_Y_Position,x  ;princess/mushroom retainer object
    enemyYPosition[X] = 0xB8
    //> rts
    return
}

// Decompiled from InitNormalEnemy
fun initNormalEnemy(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var primaryHardMode by MemoryByte(PrimaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val normalXSpdData by MemoryByteIndexed(NormalXSpdData)
    //> InitNormalEnemy:
    //> ldy #$01              ;load offset of 1 by default
    //> lda PrimaryHardMode   ;check for primary hard mode flag set
    //> bne GetESpd
    temp0 = primaryHardMode
    temp1 = 0x01
    if (primaryHardMode == 0) {
        //> dey                   ;if not set, decrement offset
        temp1 = (temp1 - 1) and 0xFF
    }
    //> GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
    temp0 = normalXSpdData[temp1]
    //> SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
    enemyXSpeed[X] = temp0
    //> jmp TallBBox          ;branch to set bounding box control and other data
    //> TallBBox: lda #$03                    ;set specific bounding box size control
    temp0 = 0x03
    //> SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
    enemyBoundboxctrl[X] = temp0
    //> lda #$02                    ;set moving direction for left
    temp0 = 0x02
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = temp0
}

// Decompiled from InitRedKoopa
fun initRedKoopa(X: Int) {
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> InitRedKoopa:
    //> jsr InitNormalEnemy   ;load appropriate horizontal speed
    initNormalEnemy(X)
    //> lda #$01              ;set enemy state for red koopa troopa $03
    //> sta Enemy_State,x
    enemyState[X] = 0x01
    //> rts
    return
}

// Decompiled from InitHammerBro
fun initHammerBro(X: Int) {
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val hBroWalkingTimerData by MemoryByteIndexed(HBroWalkingTimerData)
    val hammerThrowingTimer by MemoryByteIndexed(HammerThrowingTimer)
    //> InitHammerBro:
    //> lda #$00                    ;init horizontal speed and timer used by hammer bro
    //> sta HammerThrowingTimer,x   ;apparently to time hammer throwing
    hammerThrowingTimer[X] = 0x00
    //> sta Enemy_X_Speed,x
    enemyXSpeed[X] = 0x00
    //> ldy SecondaryHardMode       ;get secondary hard mode flag
    //> lda HBroWalkingTimerData,y
    //> sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
    enemyIntervalTimer[X] = hBroWalkingTimerData[secondaryHardMode]
    //> lda #$0b                    ;set specific value for bounding box size control
    //> jmp SetBBox
    //> SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
    enemyBoundboxctrl[X] = 0x0B
    //> lda #$02                    ;set moving direction for left
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = 0x02
}

// Decompiled from InitHorizFlySwimEnemy
fun initHorizFlySwimEnemy(X: Int) {
    var A: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
    enemyXSpeed[X] = A
    //> jmp TallBBox          ;branch to set bounding box control and other data
    while (true) {
        //> InitHorizFlySwimEnemy:
        //> lda #$00        ;initialize horizontal speed
        //> jmp SetESpd
    }
    //> TallBBox: lda #$03                    ;set specific bounding box size control
    //> SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
    enemyBoundboxctrl[X] = 0x03
    //> lda #$02                    ;set moving direction for left
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = 0x02
}

// Decompiled from InitBloober
fun initBloober(X: Int) {
    val blooperMoveSpeed by MemoryByteIndexed(BlooperMoveSpeed)
    //> InitBloober:
    //> lda #$00               ;initialize horizontal speed
    //> sta BlooperMoveSpeed,x
    blooperMoveSpeed[X] = 0x00
    // Fall-through tail call to smallBBox
    smallBBox(X)
}

// Decompiled from SmallBBox
fun smallBBox(X: Int): Int {
    var temp0: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> SmallBBox: lda #$09               ;set specific bounding box size control
    //> bne SetBBox            ;unconditional branch
    temp0 = 0x09
    if (0x09 == 0) {
        //> ;--------------------------------
    }
    //> SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
    enemyBoundboxctrl[X] = temp0
    //> lda #$02                    ;set moving direction for left
    temp0 = 0x02
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = temp0
    // Fall-through tail call to initRedPTroopa
    initRedPTroopa(X)
    return A
}

// Decompiled from InitRedPTroopa
fun initRedPTroopa(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val redPTroopaCenterYPos by MemoryByteIndexed(RedPTroopaCenterYPos)
    val redPTroopaOrigXPos by MemoryByteIndexed(RedPTroopaOrigXPos)
    //> InitRedPTroopa:
    //> ldy #$30                    ;load central position adder for 48 pixels down
    //> lda Enemy_Y_Position,x      ;set vertical coordinate into location to
    //> sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
    redPTroopaOrigXPos[X] = enemyYPosition[X]
    //> bpl GetCent                 ;if vertical coordinate < $80
    temp0 = enemyYPosition[X]
    temp1 = 0x30
    if ((enemyYPosition[X] and 0x80) != 0) {
        //> ldy #$e0                    ;if => $80, load position adder for 32 pixels up
        temp1 = 0xE0
    }
    //> GetCent:  tya                         ;send central position adder to A
    //> adc Enemy_Y_Position,x      ;add to current vertical coordinate
    temp2 = temp1 + enemyYPosition[X]
    temp0 = temp2 and 0xFF
    //> sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
    redPTroopaCenterYPos[X] = temp0
    //> TallBBox: lda #$03                    ;set specific bounding box size control
    temp0 = 0x03
    //> SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
    enemyBoundboxctrl[X] = temp0
    //> lda #$02                    ;set moving direction for left
    temp0 = 0x02
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = temp0
    // Fall-through tail call to smallBBox
    smallBBox(X)
}

// Decompiled from InitVStf
fun initVStf(X: Int): Int {
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> InitVStf: lda #$00                    ;initialize vertical speed
    //> sta Enemy_Y_Speed,x         ;and movement force
    enemyYSpeed[X] = 0x00
    //> sta Enemy_Y_MoveForce,x
    enemyYMoveforce[X] = 0x00
    //> rts
    return A
}

// Decompiled from InitBulletBill
fun initBulletBill(X: Int) {
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> InitBulletBill:
    //> lda #$02                  ;set moving direction for left
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = 0x02
    //> lda #$09                  ;set bounding box control for $09
    //> sta Enemy_BoundBoxCtrl,x
    enemyBoundboxctrl[X] = 0x09
    //> rts
    return
}

// Decompiled from InitCheepCheep
fun initCheepCheep(X: Int) {
    var temp0: Int = 0
    val cheepCheepMoveMFlag by MemoryByteIndexed(CheepCheepMoveMFlag)
    val cheepCheepOrigYPos by MemoryByteIndexed(CheepCheepOrigYPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> InitCheepCheep:
    //> jsr SmallBBox              ;set vertical bounding box, speed, init others
    smallBBox(X)
    //> lda PseudoRandomBitReg,x   ;check one portion of LSFR
    //> and #%00010000             ;get d4 from it
    temp0 = pseudoRandomBitReg[X] and 0x10
    //> sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
    cheepCheepMoveMFlag[X] = temp0
    //> lda Enemy_Y_Position,x
    //> sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
    cheepCheepOrigYPos[X] = enemyYPosition[X]
    //> rts
    return
}

// Decompiled from InitLakitu
fun initLakitu() {
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    //> InitLakitu:
    //> lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
    //> bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
    if (!(enemyFrenzyBuffer == 0)) {
        //  goto KillLakitu
        return
    }
    temp0 = enemyFrenzyBuffer
    if (enemyFrenzyBuffer == 0) {
    }
    //> KillLakitu:
    //> jmp EraseEnemyObject
    // Fall-through tail call to setupLakitu
    setupLakitu(X)
}

// Decompiled from SetupLakitu
fun setupLakitu(X: Int) {
    var lakituReappearTimer by MemoryByte(LakituReappearTimer)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    //> SetupLakitu:
    //> lda #$00                   ;erase counter for lakitu's reappearance
    //> sta LakituReappearTimer
    lakituReappearTimer = 0x00
    //> jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
    initHorizFlySwimEnemy(X)
    //> jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
    //> TallBBox2: lda #$03                  ;set specific value for bounding box control
    //> SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
    enemyBoundboxctrl[X] = 0x03
    //> rts
    return
}

// Decompiled from LakituAndSpinyHandler
fun lakituAndSpinyHandler(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var lakituReappearTimer by MemoryByte(LakituReappearTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val pRDiffAdjustData by MemoryByteIndexed(PRDiffAdjustData)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> LakituAndSpinyHandler:
    //> lda FrenzyEnemyTimer    ;if timer here not expired, leave
    //> bne ExLSHand
    temp0 = frenzyEnemyTimer
    if (frenzyEnemyTimer == 0) {
        //> cpx #$05                ;if we are on the special use slot, leave
        //> bcs ExLSHand
        if (!(X >= 0x05)) {
            //> lda #$80                ;set timer
            temp0 = 0x80
            //> sta FrenzyEnemyTimer
            frenzyEnemyTimer = temp0
            //> ldy #$04                ;start with the last enemy slot
            temp1 = 0x04
            while ((temp1 and 0x80) == 0) {
                //> dey                     ;otherwise check another slot
                temp1 = (temp1 - 1) and 0xFF
                //> bpl ChkLak              ;loop until all slots are checked
            }
            //> inc LakituReappearTimer ;increment reappearance timer
            lakituReappearTimer = (lakituReappearTimer + 1) and 0xFF
            //> lda LakituReappearTimer
            temp0 = lakituReappearTimer
            //> cmp #$07                ;check to see if we're up to a certain value yet
            //> bcc ExLSHand            ;if not, leave
            if (temp0 >= 0x07) {
                //> ldx #$04                ;start with the last enemy slot again
                temp2 = 0x04
                while ((temp2 and 0x80) == 0) {
                    //> dex                     ;otherwise check next slot
                    temp2 = (temp2 - 1) and 0xFF
                    //> bpl ChkNoEn             ;branch until all slots are checked
                }
                //> bmi RetEOfs             ;if no empty slots were found, branch to leave
                if ((temp2 and 0x80) == 0) {
                    //> CreateL:  lda #$00                ;initialize enemy state
                    temp0 = 0x00
                    //> sta Enemy_State,x
                    enemyState[temp2] = temp0
                    //> lda #Lakitu             ;create lakitu enemy object
                    temp0 = Lakitu
                    //> sta Enemy_ID,x
                    enemyId[temp2] = temp0
                    //> jsr SetupLakitu         ;do a sub to set up lakitu
                    setupLakitu(temp2)
                    //> lda #$20
                    temp0 = 0x20
                    //> jsr PutAtRightExtent    ;finish setting up lakitu
                    putAtRightExtent(temp0, temp2)
                }
                //> RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
                temp2 = objectOffset
            }
        }
    }
    //> ExLSHand: rts
    return
}

// Decompiled from InitLongFirebar
fun initLongFirebar() {
    var X: Int = 0
    //> InitLongFirebar:
    //> jsr DuplicateEnemyObj       ;create enemy object for long firebar
    duplicateEnemyObj(X)
    // Fall-through tail call to initShortFirebar
    initShortFirebar(X)
}

// Decompiled from InitShortFirebar
fun initShortFirebar(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val firebarSpinDirData by MemoryByteIndexed(FirebarSpinDirData)
    val firebarSpinDirection by MemoryByteIndexed(FirebarSpinDirection)
    val firebarSpinSpdData by MemoryByteIndexed(FirebarSpinSpdData)
    val firebarSpinSpeed by MemoryByteIndexed(FirebarSpinSpeed)
    val firebarspinstateLow by MemoryByteIndexed(FirebarSpinState_Low)
    //> InitShortFirebar:
    //> lda #$00                    ;initialize low byte of spin state
    //> sta FirebarSpinState_Low,x
    firebarspinstateLow[X] = 0x00
    //> lda Enemy_ID,x              ;subtract $1b from enemy identifier
    //> sec                         ;to get proper offset for firebar data
    //> sbc #$1b
    temp0 = enemyId[X] - 0x1B
    //> tay
    //> lda FirebarSpinSpdData,y    ;get spinning speed of firebar
    //> sta FirebarSpinSpeed,x
    firebarSpinSpeed[X] = firebarSpinSpdData[temp0 and 0xFF]
    //> lda FirebarSpinDirData,y    ;get spinning direction of firebar
    //> sta FirebarSpinDirection,x
    firebarSpinDirection[X] = firebarSpinDirData[temp0 and 0xFF]
    //> lda Enemy_Y_Position,x
    //> clc                         ;add four pixels to vertical coordinate
    //> adc #$04
    temp1 = enemyYPosition[X] + 0x04
    //> sta Enemy_Y_Position,x
    enemyYPosition[X] = temp1 and 0xFF
    //> lda Enemy_X_Position,x
    //> clc                         ;add four pixels to horizontal coordinate
    //> adc #$04
    temp2 = enemyXPosition[X] + 0x04
    //> sta Enemy_X_Position,x
    enemyXPosition[X] = temp2 and 0xFF
    //> lda Enemy_PageLoc,x
    //> adc #$00                    ;add carry to page location
    temp3 = enemyPageloc[X] + (if (temp2 > 0xFF) 1 else 0)
    //> sta Enemy_PageLoc,x
    enemyPageloc[X] = temp3 and 0xFF
    //> jmp TallBBox2               ;set bounding box control (not used) and leave
    //> TallBBox2: lda #$03                  ;set specific value for bounding box control
    //> SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
    enemyBoundboxctrl[X] = 0x03
    //> rts
    return
}

// Decompiled from InitFlyingCheepCheep
fun initFlyingCheepCheep(X: Int) {
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val flyCCTimerData by MemoryByteIndexed(FlyCCTimerData)
    val flyCCXPositionData by MemoryByteIndexed(FlyCCXPositionData)
    val flyCCXSpeedData by MemoryByteIndexed(FlyCCXSpeedData)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> ChpChpEx: rts
    return
}

// Decompiled from InitBowser
fun initBowser(X: Int) {
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFeetCounter by MemoryByte(BowserFeetCounter)
    var bowserFireBreathTimer by MemoryByte(BowserFireBreathTimer)
    var bowserfrontOffset by MemoryByte(BowserFront_Offset)
    var bowserHitPoints by MemoryByte(BowserHitPoints)
    var bowserMovementSpeed by MemoryByte(BowserMovementSpeed)
    var bowserOrigXPos by MemoryByte(BowserOrigXPos)
    var bridgeCollapseOffset by MemoryByte(BridgeCollapseOffset)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> InitBowser:
    //> jsr DuplicateEnemyObj     ;jump to create another bowser object
    duplicateEnemyObj(X)
    //> stx BowserFront_Offset    ;save offset of first here
    bowserfrontOffset = X
    //> lda #$00
    //> sta BowserBodyControls    ;initialize bowser's body controls
    bowserBodyControls = 0x00
    //> sta BridgeCollapseOffset  ;and bridge collapse offset
    bridgeCollapseOffset = 0x00
    //> lda Enemy_X_Position,x
    //> sta BowserOrigXPos        ;store original horizontal position here
    bowserOrigXPos = enemyXPosition[X]
    //> lda #$df
    //> sta BowserFireBreathTimer ;store something here
    bowserFireBreathTimer = 0xDF
    //> sta Enemy_MovingDir,x     ;and in moving direction
    enemyMovingdir[X] = 0xDF
    //> lda #$20
    //> sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
    bowserFeetCounter = 0x20
    //> sta EnemyFrameTimer,x
    enemyFrameTimer[X] = 0x20
    //> lda #$05
    //> sta BowserHitPoints       ;give bowser 5 hit points
    bowserHitPoints = 0x05
    //> lsr
    //> sta BowserMovementSpeed   ;set default movement speed here
    bowserMovementSpeed = 0x05 shr 1
    //> rts
    return
}

// Decompiled from DuplicateEnemyObj
fun duplicateEnemyObj(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> DuplicateEnemyObj:
    //> ldy #$ff                ;start at beginning of enemy slots
    temp0 = 0xFF
    do {
        //> FSLoop: iny                     ;increment one slot
        temp0 = (temp0 + 1) and 0xFF
        //> lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
        //> bne FSLoop              ;if set, branch and keep checking
    } while (enemyFlag[temp0] != 0)
    //> sty DuplicateObj_Offset ;otherwise set offset here
    duplicateobjOffset = temp0
    //> txa                     ;transfer original enemy buffer offset
    //> ora #%10000000          ;store with d7 set as flag in new enemy
    temp1 = X or 0x80
    //> sta Enemy_Flag,y        ;slot as well as enemy offset
    enemyFlag[temp0] = temp1
    //> lda Enemy_PageLoc,x
    //> sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
    enemyPageloc[temp0] = enemyPageloc[X]
    //> lda Enemy_X_Position,x  ;from original enemy to new enemy
    //> sta Enemy_X_Position,y
    enemyXPosition[temp0] = enemyXPosition[X]
    //> lda #$01
    //> sta Enemy_Flag,x        ;set flag as normal for original enemy
    enemyFlag[X] = 0x01
    //> sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
    enemyYHighpos[temp0] = 0x01
    //> lda Enemy_Y_Position,x
    //> sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
    enemyYPosition[temp0] = enemyYPosition[X]
    //> FlmEx:  rts                     ;and then leave
    return
}

// Decompiled from InitBowserFlame
fun initBowserFlame(X: Int) {
    val bowserFlamePRandomOfs by MemoryByteIndexed(BowserFlamePRandomOfs)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flameYMFAdderData by MemoryByteIndexed(FlameYMFAdderData)
    val flameYPosData by MemoryByteIndexed(FlameYPosData)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> FlmEx:  rts                     ;and then leave
    return
}

// Decompiled from PutAtRightExtent
fun putAtRightExtent(A: Int, X: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXMoveforce by MemoryByteIndexed(Enemy_X_MoveForce)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> PutAtRightExtent:
    //> sta Enemy_Y_Position,x    ;set vertical position
    enemyYPosition[X] = A
    //> lda ScreenRight_X_Pos
    //> clc
    //> adc #$20                  ;place enemy 32 pixels beyond right side of screen
    temp0 = screenrightXPos + 0x20
    //> sta Enemy_X_Position,x
    enemyXPosition[X] = temp0 and 0xFF
    //> lda ScreenRight_PageLoc
    //> adc #$00                  ;add carry
    temp1 = screenrightPageloc + (if (temp0 > 0xFF) 1 else 0)
    //> sta Enemy_PageLoc,x
    enemyPageloc[X] = temp1 and 0xFF
    //> jmp FinishFlame           ;skip this part to finish setting values
    //> FinishFlame:
    //> lda #$08                 ;set $08 for bounding box control
    //> sta Enemy_BoundBoxCtrl,x
    enemyBoundboxctrl[X] = 0x08
    //> lda #$01                 ;set high byte of vertical and
    //> sta Enemy_Y_HighPos,x    ;enemy buffer flag
    enemyYHighpos[X] = 0x01
    //> sta Enemy_Flag,x
    enemyFlag[X] = 0x01
    //> lsr
    //> sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
    enemyXMoveforce[X] = 0x01 shr 1
    //> sta Enemy_State,x        ;enemy state
    enemyState[X] = 0x01 shr 1
    //> rts
    return A
}

// Decompiled from InitFireworks
fun initFireworks(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var fireworksCounter by MemoryByte(FireworksCounter)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val explosionGfxCounter by MemoryByteIndexed(ExplosionGfxCounter)
    val explosionTimerCounter by MemoryByteIndexed(ExplosionTimerCounter)
    val fireworksXPosData by MemoryByteIndexed(FireworksXPosData)
    val fireworksYPosData by MemoryByteIndexed(FireworksYPosData)
    //> InitFireworks:
    //> lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
    //> bne ExitFWk
    temp0 = frenzyEnemyTimer
    if (frenzyEnemyTimer == 0) {
        //> lda #$20                     ;otherwise reset timer
        temp0 = 0x20
        //> sta FrenzyEnemyTimer
        frenzyEnemyTimer = temp0
        //> dec FireworksCounter         ;decrement for each explosion
        fireworksCounter = (fireworksCounter - 1) and 0xFF
        //> ldy #$06                     ;start at last slot
        temp1 = 0x06
        do {
            //> StarFChk: dey
            temp1 = (temp1 - 1) and 0xFF
            //> lda Enemy_ID,y               ;check for presence of star flag object
            temp0 = enemyId[temp1]
            //> cmp #StarFlagObject          ;if there isn't a star flag object,
            //> bne StarFChk                 ;routine goes into infinite loop = crash
        } while (temp0 != StarFlagObject)
        //> lda Enemy_X_Position,y
        temp0 = enemyXPosition[temp1]
        //> sec                          ;get horizontal coordinate of star flag object, then
        //> sbc #$30                     ;subtract 48 pixels from it and save to
        temp2 = temp0 - 0x30
        temp0 = temp2 and 0xFF
        //> pha                          ;the stack
        push(temp0)
        //> lda Enemy_PageLoc,y
        temp0 = enemyPageloc[temp1]
        //> sbc #$00                     ;subtract the carry from the page location
        temp3 = temp0 - (if (temp2 >= 0) 0 else 1)
        temp0 = temp3 and 0xFF
        //> sta $00                      ;of the star flag object
        memory[0x0] = temp0.toUByte()
        //> lda FireworksCounter         ;get fireworks counter
        temp0 = fireworksCounter
        //> clc
        //> adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
        temp4 = temp0 + enemyState[temp1]
        temp0 = temp4 and 0xFF
        //> tay                          ;use as offset
        //> pla                          ;get saved horizontal coordinate of star flag - 48 pixels
        temp0 = pull()
        //> clc
        //> adc FireworksXPosData,y      ;add number based on offset of fireworks counter
        temp5 = temp0 + fireworksXPosData[temp0]
        temp0 = temp5 and 0xFF
        //> sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
        enemyXPosition[X] = temp0
        //> lda $00
        temp0 = memory[0x0].toInt()
        //> adc #$00                     ;add carry and store as page location for
        temp6 = temp0 + (if (temp5 > 0xFF) 1 else 0)
        temp0 = temp6 and 0xFF
        //> sta Enemy_PageLoc,x          ;the fireworks object
        enemyPageloc[X] = temp0
        //> lda FireworksYPosData,y      ;get vertical position using same offset
        temp0 = fireworksYPosData[temp0]
        //> sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
        enemyYPosition[X] = temp0
        //> lda #$01
        temp0 = 0x01
        //> sta Enemy_Y_HighPos,x        ;store in vertical high byte
        enemyYHighpos[X] = temp0
        //> sta Enemy_Flag,x             ;and activate enemy buffer flag
        enemyFlag[X] = temp0
        //> lsr
        temp0 = temp0 shr 1
        //> sta ExplosionGfxCounter,x    ;initialize explosion counter
        explosionGfxCounter[X] = temp0
        //> lda #$08
        temp0 = 0x08
        //> sta ExplosionTimerCounter,x  ;set explosion timing counter
        explosionTimerCounter[X] = temp0
    }
    //> ExitFWk:  rts
    return
}

// Decompiled from BulletBillCheepCheep
fun bulletBillCheepCheep(X: Int) {
    var enemyDataOffset by MemoryByte(EnemyDataOffset)
    var enemyObjectPageSel by MemoryByte(EnemyObjectPageSel)
    var objectOffset by MemoryByte(ObjectOffset)
    val bitmasks by MemoryByteIndexed(Bitmasks)
    val enemy17YPosData by MemoryByteIndexed(Enemy17YPosData)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    val swimccIddata by MemoryByteIndexed(SwimCC_IDData)
    //> Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
    //> inc EnemyDataOffset
    enemyDataOffset = (enemyDataOffset + 1) and 0xFF
    //> lda #$00                 ;init page select for enemy objects
    //> sta EnemyObjectPageSel
    enemyObjectPageSel = 0x00
    //> ldx ObjectOffset         ;reload current offset in enemy buffers
    //> rts                      ;and leave
    return
}

// Decompiled from InitPiranhaPlant
fun initPiranhaPlant(X: Int) {
    var temp0: Int = 0
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val piranhaPlantDownYPos by MemoryByteIndexed(PiranhaPlantDownYPos)
    val piranhaPlantUpYPos by MemoryByteIndexed(PiranhaPlantUpYPos)
    val piranhaplantMoveflag by MemoryByteIndexed(PiranhaPlant_MoveFlag)
    val piranhaplantYSpeed by MemoryByteIndexed(PiranhaPlant_Y_Speed)
    //> InitPiranhaPlant:
    //> lda #$01                     ;set initial speed
    //> sta PiranhaPlant_Y_Speed,x
    piranhaplantYSpeed[X] = 0x01
    //> lsr
    //> sta Enemy_State,x            ;initialize enemy state and what would normally
    enemyState[X] = 0x01 shr 1
    //> sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
    piranhaplantMoveflag[X] = 0x01 shr 1
    //> lda Enemy_Y_Position,x
    //> sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
    piranhaPlantDownYPos[X] = enemyYPosition[X]
    //> sec
    //> sbc #$18
    temp0 = enemyYPosition[X] - 0x18
    //> sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
    piranhaPlantUpYPos[X] = temp0 and 0xFF
    //> lda #$09
    //> jmp SetBBox2                 ;set specific value for bounding box control
    //> SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
    enemyBoundboxctrl[X] = 0x09
    //> rts
    return
}

// Decompiled from InitEnemyFrenzy
fun initEnemyFrenzy(X: Int) {
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> InitEnemyFrenzy:
    //> lda Enemy_ID,x        ;load enemy identifier
    //> sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
    enemyFrenzyBuffer = enemyId[X]
    //> sec
    //> sbc #$12              ;subtract 12 and use as offset for jump engine
    temp0 = enemyId[X] - 0x12
    //> jsr JumpEngine
    when (temp0 and 0xFF) {
        0 -> {
            lakituAndSpinyHandler(X)
        }
        1 -> {
            noFrenzyCode()
        }
        2 -> {
            initFlyingCheepCheep(X)
        }
        3 -> {
            initBowserFlame(X)
        }
        4 -> {
            initFireworks(X)
        }
        5 -> {
            bulletBillCheepCheep(X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from NoFrenzyCode
fun noFrenzyCode() {
    //> NoFrenzyCode:
    //> rts
    return
}

// Decompiled from EndFrenzy
fun endFrenzy(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> EndFrenzy:
    //> ldy #$05               ;start at last slot
    temp0 = 0x05
    do {
        //> LakituChk: lda Enemy_ID,y         ;check enemy identifiers
        //> cmp #Lakitu            ;for lakitu
        //> bne NextFSlot
        temp1 = enemyId[temp0]
        if (enemyId[temp0] == Lakitu) {
            //> lda #$01               ;if found, set state
            temp1 = 0x01
            //> sta Enemy_State,y
            enemyState[temp0] = temp1
        }
        //> NextFSlot: dey                    ;move onto the next slot
        temp0 = (temp0 - 1) and 0xFF
        //> bpl LakituChk          ;do this until all slots are checked
    } while ((temp0 and 0x80) == 0)
    //> lda #$00
    temp1 = 0x00
    //> sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
    enemyFrenzyBuffer = temp1
    //> sta Enemy_Flag,x       ;disable enemy buffer flag for this object
    enemyFlag[X] = temp1
    //> rts
    return
}

// Decompiled from InitJumpGPTroopa
fun initJumpGPTroopa(X: Int) {
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> InitJumpGPTroopa:
    //> lda #$02                  ;set for movement to the left
    //> sta Enemy_MovingDir,x
    enemyMovingdir[X] = 0x02
    //> lda #$f8                  ;set horizontal speed
    //> sta Enemy_X_Speed,x
    enemyXSpeed[X] = 0xF8
    //> TallBBox2: lda #$03                  ;set specific value for bounding box control
    //> SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
    enemyBoundboxctrl[X] = 0x03
    //> rts
    return
}

// Decompiled from InitBalPlatform
fun initBalPlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var balPlatformAlignment by MemoryByte(BalPlatformAlignment)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> InitBalPlatform:
    //> dec Enemy_Y_Position,x    ;raise vertical position by two pixels
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> dec Enemy_Y_Position,x
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> ldy SecondaryHardMode     ;if secondary hard mode flag not set,
    //> bne AlignP                ;branch ahead
    temp0 = secondaryHardMode
    if (secondaryHardMode == 0) {
        //> ldy #$02                  ;otherwise set value here
        temp0 = 0x02
        //> jsr PosPlatform           ;do a sub to add or subtract pixels
        posPlatform(X, temp0)
    }
    //> AlignP: ldy #$ff                  ;set default value here for now
    temp0 = 0xFF
    //> lda BalPlatformAlignment  ;get current balance platform alignment
    //> sta Enemy_State,x         ;set platform alignment to object state here
    enemyState[X] = balPlatformAlignment
    //> bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
    temp1 = balPlatformAlignment
    if ((balPlatformAlignment and 0x80) != 0) {
        //> txa                       ;if old contents already $ff, put
        //> tay                       ;object offset as alignment to make next positive
    }
    //> SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
    balPlatformAlignment = temp0
    //> lda #$00
    temp1 = 0x00
    //> sta Enemy_MovingDir,x     ;init moving direction
    enemyMovingdir[X] = temp1
    //> tay                       ;init Y
    //> jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
    posPlatform(X, temp1)
    //> ;--------------------------------
    // Fall-through tail call to initDropPlatform
    initDropPlatform(X)
}

// Decompiled from InitDropPlatform
fun initDropPlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> InitDropPlatform:
    //> lda #$ff
    //> sta PlatformCollisionFlag,x  ;set some value here
    platformCollisionFlag[X] = 0xFF
    //> jmp CommonPlatCode           ;then jump ahead to execute more code
    //> CommonPlatCode:
    //> jsr InitVStf              ;do a sub to init certain other values
    initVStf(X)
    //> SPBBox: lda #$05                  ;set default bounding box size control
    //> ldy AreaType
    //> cpy #$03                  ;check for castle-type level
    //> beq CasPBB                ;use default value if found
    temp0 = 0x05
    temp1 = areaType
    if (areaType != 0x03) {
        //> ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
        temp1 = secondaryHardMode
        //> bne CasPBB                ;if set, use default value
        if (temp1 == 0) {
            //> lda #$06                  ;use alternate value if not castle or secondary not set
            temp0 = 0x06
        }
    }
    //> CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
    enemyBoundboxctrl[X] = temp0
    //> rts
    return
}

// Decompiled from InitHoriPlatform
fun initHoriPlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val xMoveSecondaryCounter by MemoryByteIndexed(XMoveSecondaryCounter)
    //> InitHoriPlatform:
    //> lda #$00
    //> sta XMoveSecondaryCounter,x  ;init one of the moving counters
    xMoveSecondaryCounter[X] = 0x00
    //> jmp CommonPlatCode           ;jump ahead to execute more code
    //> CommonPlatCode:
    //> jsr InitVStf              ;do a sub to init certain other values
    initVStf(X)
    //> SPBBox: lda #$05                  ;set default bounding box size control
    //> ldy AreaType
    //> cpy #$03                  ;check for castle-type level
    //> beq CasPBB                ;use default value if found
    temp0 = 0x05
    temp1 = areaType
    if (areaType != 0x03) {
        //> ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
        temp1 = secondaryHardMode
        //> bne CasPBB                ;if set, use default value
        if (temp1 == 0) {
            //> lda #$06                  ;use alternate value if not castle or secondary not set
            temp0 = 0x06
        }
    }
    //> CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
    enemyBoundboxctrl[X] = temp0
    //> rts
    return
}

// Decompiled from InitVertPlatform
fun initVertPlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaType by MemoryByte(AreaType)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val yPlatformCenterYPos by MemoryByteIndexed(YPlatformCenterYPos)
    val yPlatformTopYPos by MemoryByteIndexed(YPlatformTopYPos)
    //> InitVertPlatform:
    //> ldy #$40                    ;set default value here
    //> lda Enemy_Y_Position,x      ;check vertical position
    //> bpl SetYO                   ;if above a certain point, skip this part
    temp0 = enemyYPosition[X]
    temp1 = 0x40
    if ((enemyYPosition[X] and 0x80) != 0) {
        //> eor #$ff
        temp2 = temp0 xor 0xFF
        //> clc                         ;otherwise get two's compliment
        //> adc #$01
        temp3 = temp2 + 0x01
        temp0 = temp3 and 0xFF
        //> ldy #$c0                    ;get alternate value to add to vertical position
        temp1 = 0xC0
    }
    //> SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
    yPlatformTopYPos[X] = temp0
    //> tya
    //> clc                         ;load value from earlier, add number of pixels
    //> adc Enemy_Y_Position,x      ;to vertical position
    temp4 = temp1 + enemyYPosition[X]
    temp0 = temp4 and 0xFF
    //> sta YPlatformCenterYPos,x   ;save result as central vertical position
    yPlatformCenterYPos[X] = temp0
    //> ;--------------------------------
    //> CommonPlatCode:
    //> jsr InitVStf              ;do a sub to init certain other values
    initVStf(X)
    //> SPBBox: lda #$05                  ;set default bounding box size control
    temp0 = 0x05
    //> ldy AreaType
    temp1 = areaType
    //> cpy #$03                  ;check for castle-type level
    //> beq CasPBB                ;use default value if found
    if (temp1 != 0x03) {
        //> ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
        temp1 = secondaryHardMode
        //> bne CasPBB                ;if set, use default value
        if (temp1 == 0) {
            //> lda #$06                  ;use alternate value if not castle or secondary not set
            temp0 = 0x06
        }
    }
    //> CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
    enemyBoundboxctrl[X] = temp0
    //> rts
    return
}

// Decompiled from LargeLiftUp
fun largeLiftUp(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    //> SPBBox: lda #$05                  ;set default bounding box size control
    //> ldy AreaType
    //> cpy #$03                  ;check for castle-type level
    //> beq CasPBB                ;use default value if found
    temp0 = 0x05
    temp1 = areaType
    if (areaType != 0x03) {
        //> ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
        temp1 = secondaryHardMode
        //> bne CasPBB                ;if set, use default value
        if (temp1 == 0) {
            //> lda #$06                  ;use alternate value if not castle or secondary not set
            temp0 = 0x06
        }
    }
    //> CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
    enemyBoundboxctrl[X] = temp0
    //> rts
    return
}

// Decompiled from LargeLiftDown
fun largeLiftDown(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var areaType by MemoryByte(AreaType)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    //> SPBBox: lda #$05                  ;set default bounding box size control
    //> ldy AreaType
    //> cpy #$03                  ;check for castle-type level
    //> beq CasPBB                ;use default value if found
    temp0 = 0x05
    temp1 = areaType
    if (areaType != 0x03) {
        //> ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
        temp1 = secondaryHardMode
        //> bne CasPBB                ;if set, use default value
        if (temp1 == 0) {
            //> lda #$06                  ;use alternate value if not castle or secondary not set
            temp0 = 0x06
        }
    }
    //> CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
    enemyBoundboxctrl[X] = temp0
    //> rts
    return
}

// Decompiled from PlatLiftUp
fun platLiftUp(X: Int) {
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> PlatLiftUp:
    //> lda #$10                 ;set movement amount here
    //> sta Enemy_Y_MoveForce,x
    enemyYMoveforce[X] = 0x10
    //> lda #$ff                 ;set moving speed for platforms going up
    //> sta Enemy_Y_Speed,x
    enemyYSpeed[X] = 0xFF
    //> jmp CommonSmallLift      ;skip ahead to part we should be executing
    //> CommonSmallLift:
    //> ldy #$01
    //> jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
    posPlatform(X, 0x01)
    //> lda #$04
    //> sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
    enemyBoundboxctrl[X] = 0x04
    //> rts
    return
}

// Decompiled from PlatLiftDown
fun platLiftDown(X: Int) {
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> PlatLiftDown:
    //> lda #$f0                 ;set movement amount here
    //> sta Enemy_Y_MoveForce,x
    enemyYMoveforce[X] = 0xF0
    //> lda #$00                 ;set moving speed for platforms going down
    //> sta Enemy_Y_Speed,x
    enemyYSpeed[X] = 0x00
    //> ;--------------------------------
    //> CommonSmallLift:
    //> ldy #$01
    //> jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
    posPlatform(X, 0x01)
    //> lda #$04
    //> sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
    enemyBoundboxctrl[X] = 0x04
    //> rts
    return
}

// Decompiled from PosPlatform
fun posPlatform(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val platPosDataHigh by MemoryByteIndexed(PlatPosDataHigh)
    val platPosDataLow by MemoryByteIndexed(PlatPosDataLow)
    //> PosPlatform:
    //> lda Enemy_X_Position,x  ;get horizontal coordinate
    //> clc
    //> adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
    temp0 = enemyXPosition[X] + platPosDataLow[Y]
    //> sta Enemy_X_Position,x  ;store as new horizontal coordinate
    enemyXPosition[X] = temp0 and 0xFF
    //> lda Enemy_PageLoc,x
    //> adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
    temp1 = enemyPageloc[X] + platPosDataHigh[Y] + (if (temp0 > 0xFF) 1 else 0)
    //> sta Enemy_PageLoc,x     ;store as new page location
    enemyPageloc[X] = temp1 and 0xFF
    //> rts                     ;and go back
    return
}

// Decompiled from EndOfEnemyInitCode
fun endOfEnemyInitCode() {
    //> EndOfEnemyInitCode:
    //> rts
    return
}

// Decompiled from NoRunCode
fun noRunCode() {
    //> NoRunCode:
    //> rts
    return
}

// Decompiled from RunRetainerObj
fun runRetainerObj() {
    var X: Int = 0
    //> RunRetainerObj:
    //> jsr GetEnemyOffscreenBits
    getEnemyOffscreenBits(X)
    //> jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jmp EnemyGfxHandler
}

// Decompiled from RunNormalEnemies
fun runNormalEnemies(X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var timerControl by MemoryByte(TimerControl)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    //> RunNormalEnemies:
    //> lda #$00                  ;init sprite attributes
    //> sta Enemy_SprAttrib,x
    enemySprattrib[X] = 0x00
    //> jsr GetEnemyOffscreenBits
    getEnemyOffscreenBits(X)
    //> jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jsr EnemyGfxHandler
    enemyGfxHandler(X)
    //> jsr GetEnemyBoundBox
    getEnemyBoundBox(X)
    //> jsr EnemyToBGCollisionDet
    enemyToBGCollisionDet(X)
    //> jsr EnemiesCollision
    enemiesCollision(X, Y)
    //> jsr PlayerEnemyCollision
    playerEnemyCollision(X)
    //> ldy TimerControl          ;if master timer control set, skip to last routine
    //> bne SkipMove
    if (!(timerControl == 0)) {
        //  goto SkipMove
        return
    }
    temp0 = 0x00
    temp1 = timerControl
    if (timerControl == 0) {
        //> jsr EnemyMovementSubs
        enemyMovementSubs(X)
    }
    //> SkipMove: jmp OffscreenBoundsCheck
}

// Decompiled from EnemyMovementSubs
fun enemyMovementSubs(X: Int) {
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> EnemyMovementSubs:
    //> lda Enemy_ID,x
    //> jsr JumpEngine
    when (enemyId[X]) {
        0 -> {
            moveNormalEnemy(X)
        }
        1 -> {
            moveNormalEnemy(X)
        }
        2 -> {
            moveNormalEnemy(X)
        }
        3 -> {
            moveNormalEnemy(X)
        }
        4 -> {
            moveNormalEnemy(X)
        }
        5 -> {
            procHammerBro(X)
        }
        6 -> {
            moveNormalEnemy(X)
        }
        7 -> {
            moveBloober(X)
        }
        8 -> {
            moveBulletBill(X)
        }
        9 -> {
            noMoveCode()
        }
        10 -> {
            moveSwimmingCheepCheep(X)
        }
        11 -> {
            moveSwimmingCheepCheep(X)
        }
        12 -> {
            movePodoboo(X)
        }
        13 -> {
            movePiranhaPlant(X)
        }
        14 -> {
            moveJumpingEnemy()
        }
        15 -> {
            procMoveRedPTroopa(X)
        }
        16 -> {
            moveFlyGreenPTroopa(X)
        }
        17 -> {
            moveLakitu(X)
        }
        18 -> {
            moveNormalEnemy(X)
        }
        19 -> {
            noMoveCode()
        }
        20 -> {
            moveFlyingCheepCheep(X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from NoMoveCode
fun noMoveCode() {
    //> NoMoveCode:
    //> rts
    return
}

// Decompiled from RunBowserFlame
fun runBowserFlame() {
    var X: Int = 0
    //> RunBowserFlame:
    //> jsr ProcBowserFlame
    procBowserFlame(X)
    //> jsr GetEnemyOffscreenBits
    getEnemyOffscreenBits(X)
    //> jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jsr GetEnemyBoundBox
    getEnemyBoundBox(X)
    //> jsr PlayerEnemyCollision
    playerEnemyCollision(X)
    //> jmp OffscreenBoundsCheck
}

// Decompiled from RunFirebarObj
fun runFirebarObj() {
    var X: Int = 0
    //> RunFirebarObj:
    //> jsr ProcFirebar
    procFirebar(X)
    //> jmp OffscreenBoundsCheck
}

// Decompiled from RunSmallPlatform
fun runSmallPlatform() {
    var X: Int = 0
    var Y: Int = 0
    //> RunSmallPlatform:
    //> jsr GetEnemyOffscreenBits
    getEnemyOffscreenBits(X)
    //> jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jsr SmallPlatformBoundBox
    smallPlatformBoundBox(X)
    //> jsr SmallPlatformCollision
    smallPlatformCollision(X, Y)
    //> jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jsr DrawSmallPlatform
    drawSmallPlatform(X)
    //> jsr MoveSmallPlatform
    moveSmallPlatform(X)
    //> jmp OffscreenBoundsCheck
}

// Decompiled from RunLargePlatform
fun runLargePlatform() {
    var A: Int = 0
    var X: Int = 0
    var temp0: Int = 0
    var timerControl by MemoryByte(TimerControl)
    //> RunLargePlatform:
    //> jsr GetEnemyOffscreenBits
    getEnemyOffscreenBits(X)
    //> jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jsr LargePlatformBoundBox
    largePlatformBoundBox(A, X)
    //> jsr LargePlatformCollision
    largePlatformCollision(X)
    //> lda TimerControl             ;if master timer control set,
    //> bne SkipPT                   ;skip subroutine tree
    if (!(timerControl == 0)) {
        //  goto SkipPT
        return
    }
    temp0 = timerControl
    if (timerControl == 0) {
        //> jsr LargePlatformSubroutines
        largePlatformSubroutines(X)
    }
    //> SkipPT: jsr RelativeEnemyPosition
    relativeEnemyPosition()
    //> jsr DrawLargePlatform
    drawLargePlatform(X)
    //> jmp OffscreenBoundsCheck
}

// Decompiled from LargePlatformSubroutines
fun largePlatformSubroutines(X: Int) {
    var temp0: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> LargePlatformSubroutines:
    //> lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
    //> sec
    //> sbc #$24
    temp0 = enemyId[X] - 0x24
    //> jsr JumpEngine
    when (temp0 and 0xFF) {
        0 -> {
            balancePlatform(X)
        }
        1 -> {
            yMovingPlatform(X)
        }
        2 -> {
            moveLargeLiftPlat(X)
        }
        3 -> {
            moveLargeLiftPlat(X)
        }
        4 -> {
            xMovingPlatform(X)
        }
        5 -> {
            dropPlatform(X)
        }
        6 -> {
            rightPlatform(6, X)
        }
        else -> {
            // Unknown JumpEngine index
        }
    }
    return
}

// Decompiled from EraseEnemyObject
fun eraseEnemyObject(X: Int) {
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val shellChainCounter by MemoryByteIndexed(ShellChainCounter)
    //> EraseEnemyObject:
    //> lda #$00                 ;clear all enemy object variables
    //> sta Enemy_Flag,x
    enemyFlag[X] = 0x00
    //> sta Enemy_ID,x
    enemyId[X] = 0x00
    //> sta Enemy_State,x
    enemyState[X] = 0x00
    //> sta FloateyNum_Control,x
    floateynumControl[X] = 0x00
    //> sta EnemyIntervalTimer,x
    enemyIntervalTimer[X] = 0x00
    //> sta ShellChainCounter,x
    shellChainCounter[X] = 0x00
    //> sta Enemy_SprAttrib,x
    enemySprattrib[X] = 0x00
    //> sta EnemyFrameTimer,x
    enemyFrameTimer[X] = 0x00
    //> rts
    return
}

// Decompiled from MovePodoboo
fun movePodoboo(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> MovePodoboo:
    //> lda EnemyIntervalTimer,x   ;check enemy timer
    //> bne PdbM                   ;branch to move enemy if not expired
    if (!(enemyIntervalTimer[X] == 0)) {
        //  goto PdbM
        return
    }
    temp0 = enemyIntervalTimer[X]
    if (enemyIntervalTimer[X] == 0) {
        //> jsr InitPodoboo            ;otherwise set up podoboo again
        initPodoboo(X)
        //> lda PseudoRandomBitReg+1,x ;get part of LSFR
        temp0 = pseudoRandomBitReg[1 + X]
        //> ora #%10000000             ;set d7
        temp1 = temp0 or 0x80
        //> sta Enemy_Y_MoveForce,x    ;store as movement force
        enemyYMoveforce[X] = temp1
        //> and #%00001111             ;mask out high nybble
        temp2 = temp1 and 0x0F
        //> ora #$06                   ;set for at least six intervals
        temp3 = temp2 or 0x06
        //> sta EnemyIntervalTimer,x   ;store as new enemy timer
        enemyIntervalTimer[X] = temp3
        //> lda #$f9
        temp0 = 0xF9
        //> sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
        enemyYSpeed[X] = temp0
    }
    //> PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
}

// Decompiled from ProcHammerBro
fun procHammerBro(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var frameCounter by MemoryByte(FrameCounter)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val hammerBroJumpLData by MemoryByteIndexed(HammerBroJumpLData)
    val hammerBroJumpTimer by MemoryByteIndexed(HammerBroJumpTimer)
    val hammerThrowTmrData by MemoryByteIndexed(HammerThrowTmrData)
    val hammerThrowingTimer by MemoryByteIndexed(HammerThrowingTimer)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> ProcHammerBro:
    //> lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
    //> and #%00100000
    temp0 = enemyState[X] and 0x20
    //> beq ChkJH                  ;if not set, go ahead with code
    temp1 = temp0
    if (temp0 != 0) {
    } else {
        //> ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
        temp1 = hammerBroJumpTimer[X]
        //> beq HammerBroJumpCode      ;if expired, branch to jump
        if (temp1 != 0) {
            //> dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
            hammerBroJumpTimer[X] = (hammerBroJumpTimer[X] - 1) and 0xFF
            //> lda Enemy_OffscreenBits
            temp1 = enemyOffscreenbits
            //> and #%00001100             ;check offscreen bits
            temp2 = temp1 and 0x0C
            //> bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
            if (!(temp2 == 0)) {
                //  goto MoveHammerBroXDir
                return
            }
            temp1 = temp2
            if (temp2 == 0) {
                //> lda HammerThrowingTimer,x  ;check hammer throwing timer
                temp1 = hammerThrowingTimer[X]
                //> bne DecHT                  ;if not expired, skip ahead, do not throw hammer
                if (!(temp1 == 0)) {
                    //  goto DecHT
                    return
                }
                if (temp1 == 0) {
                    //> ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
                    //> lda HammerThrowTmrData,y   ;get timer data using flag as offset
                    temp1 = hammerThrowTmrData[secondaryHardMode]
                    //> sta HammerThrowingTimer,x  ;set as new timer
                    hammerThrowingTimer[X] = temp1
                    //> jsr SpawnHammerObj         ;do a sub here to spawn hammer object
                    spawnHammerObj()
                    //> bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
                    if (!(flagC)) {
                        //  goto DecHT
                        return
                    }
                    temp3 = secondaryHardMode
                    if (flagC) {
                        //> lda Enemy_State,x
                        temp1 = enemyState[X]
                        //> ora #%00001000             ;set d3 in enemy state for hammer throw
                        temp4 = temp1 or 0x08
                        //> sta Enemy_State,x
                        enemyState[X] = temp4
                        //> jmp MoveHammerBroXDir      ;jump to move hammer bro
                    }
                }
                //> DecHT: dec HammerThrowingTimer,x  ;decrement timer
                hammerThrowingTimer[X] = (hammerThrowingTimer[X] - 1) and 0xFF
                //> jmp MoveHammerBroXDir      ;jump to move hammer bro
            }
        } else {
            //> HammerBroJumpCode:
            //> lda Enemy_State,x           ;get hammer bro's enemy state
            temp1 = enemyState[X]
            //> and #%00000111              ;mask out all but 3 LSB
            temp5 = temp1 and 0x07
            //> cmp #$01                    ;check for d0 set (for jumping)
            //> beq MoveHammerBroXDir       ;if set, branch ahead to moving code
            if (temp5 - 0x01 == 0) {
                //  goto MoveHammerBroXDir
                return
            }
            temp1 = temp5
            if (temp5 != 0x01) {
                //> lda #$00                    ;load default value here
                temp1 = 0x00
                //> sta $00                     ;save into temp variable for now
                memory[0x0] = temp1.toUByte()
                //> ldy #$fa                    ;set default vertical speed
                temp3 = 0xFA
                //> lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
                temp1 = enemyYPosition[X]
                //> bmi SetHJ                   ;if on the bottom half of the screen, use current speed
                if ((temp1 and 0x80) != 0) {
                    //  goto SetHJ
                    return
                }
                if ((temp1 and 0x80) == 0) {
                    //> ldy #$fd                    ;otherwise set alternate vertical speed
                    temp3 = 0xFD
                    //> cmp #$70                    ;check to see if hammer bro is above the middle of screen
                    //> inc $00                     ;increment preset value to $01
                    memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
                    //> bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
                    if (!(temp1 >= 0x70)) {
                        //  goto SetHJ
                        return
                    }
                    if (temp1 >= 0x70) {
                        //> dec $00                     ;otherwise return value to $00
                        memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                        //> lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
                        temp1 = pseudoRandomBitReg[1 + X]
                        //> and #$01
                        temp6 = temp1 and 0x01
                        //> bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
                        if (!(temp6 == 0)) {
                            //  goto SetHJ
                            return
                        }
                        temp1 = temp6
                        if (temp6 == 0) {
                            //> ldy #$fa                    ;otherwise reset to default vertical speed
                            temp3 = 0xFA
                        }
                    }
                }
                //> SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
                enemyYSpeed[X] = temp3
                //> lda Enemy_State,x           ;set d0 in enemy state for jumping
                temp1 = enemyState[X]
                //> ora #$01
                temp7 = temp1 or 0x01
                //> sta Enemy_State,x
                enemyState[X] = temp7
                //> lda $00                     ;load preset value here to use as bitmask
                temp1 = memory[0x0].toInt()
                //> and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
                temp8 = temp1 and pseudoRandomBitReg[2 + X]
                //> tay                         ;then use as offset
                //> lda SecondaryHardMode       ;check secondary hard mode flag
                temp1 = secondaryHardMode
                //> bne HJump
                temp3 = temp8
                if (temp1 == 0) {
                    //> tay                         ;if secondary hard mode flag clear, set offset to 0
                }
                //> HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
                temp1 = hammerBroJumpLData[temp3]
                //> sta EnemyFrameTimer,x       ;save in enemy timer
                enemyFrameTimer[X] = temp1
                //> lda PseudoRandomBitReg+1,x
                temp1 = pseudoRandomBitReg[1 + X]
                //> ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
                temp9 = temp1 or 0xC0
                //> sta HammerBroJumpTimer,x    ;store in jump timer
                hammerBroJumpTimer[X] = temp9
            }
        }
        //> MoveHammerBroXDir:
        //> ldy #$fc                  ;move hammer bro a little to the left
        temp3 = 0xFC
        //> lda FrameCounter
        temp1 = frameCounter
        //> and #%01000000            ;change hammer bro's direction every 64 frames
        temp10 = temp1 and 0x40
        //> bne Shimmy
        temp1 = temp10
        if (temp10 == 0) {
            //> ldy #$04                  ;if d6 set in counter, move him a little to the right
            temp3 = 0x04
        }
        //> Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
        enemyXSpeed[X] = temp3
        //> ldy #$01                  ;set to face right by default
        temp3 = 0x01
        //> jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
        playerEnemyDiff(X)
        //> bmi SetShim               ;if enemy to the left of player, skip this part
        if ((temp3 and 0x80) == 0) {
            //> iny                       ;set to face left
            temp3 = (temp3 + 1) and 0xFF
            //> lda EnemyIntervalTimer,x  ;check walking timer
            temp1 = enemyIntervalTimer[X]
            //> bne SetShim               ;if not yet expired, skip to set moving direction
            if (temp1 == 0) {
                //> lda #$f8
                temp1 = 0xF8
                //> sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
                enemyXSpeed[X] = temp1
            }
        }
        //> SetShim: sty Enemy_MovingDir,x     ;set moving direction
        enemyMovingdir[X] = temp3
    }
    //> MoveDefeatedEnemy:
    //> jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
    movedEnemyvertically(X)
    //> jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
    // Fall-through tail call to chkforbumpHammerbroj
    chkforbumpHammerbroj(X)
}

// Decompiled from MoveNormalEnemy
fun moveNormalEnemy(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val revivedXSpeed by MemoryByteIndexed(RevivedXSpeed)
    val xSpeedAdderData by MemoryByteIndexed(XSpeedAdderData)
    //> MoveNormalEnemy:
    //> ldy #$00                   ;init Y to leave horizontal movement as-is
    //> lda Enemy_State,x
    //> and #%01000000             ;check enemy state for d6 set, if set skip
    temp0 = enemyState[X] and 0x40
    //> bne FallE                  ;to move enemy vertically, then horizontally if necessary
    temp1 = temp0
    temp2 = 0x00
    if (temp0 == 0) {
        //> lda Enemy_State,x
        temp1 = enemyState[X]
        //> asl                        ;check enemy state for d7 set
        temp1 = (temp1 shl 1) and 0xFF
        //> bcs SteadM                 ;if set, branch to move enemy horizontally
        if ((temp1 and 0x80) == 0) {
            //> lda Enemy_State,x
            temp1 = enemyState[X]
            //> and #%00100000             ;check enemy state for d5 set
            temp3 = temp1 and 0x20
            //> bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
            if (!(temp3 == 0)) {
                //  goto MoveDefeatedEnemy
                return
            }
            temp1 = temp3
            if (temp3 == 0) {
                //> lda Enemy_State,x
                temp1 = enemyState[X]
                //> and #%00000111             ;check d2-d0 of enemy state for any set bits
                temp4 = temp1 and 0x07
                //> beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
                temp1 = temp4
                if (temp4 != 0) {
                    //> cmp #$05
                    //> beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
                    if (temp1 != 0x05) {
                        //> cmp #$03
                        //> bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
                        if (!(temp1 >= 0x03)) {
                        }
                    }
                }
            }
        }
    }
    //> FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
    movedEnemyvertically(X)
    //> ldy #$00
    temp2 = 0x00
    //> lda Enemy_State,x          ;check for enemy state $02
    temp1 = enemyState[X]
    //> cmp #$02
    //> beq MEHor                  ;if found, branch to move enemy horizontally
    if (temp1 - 0x02 == 0) {
        //  goto MEHor
        return
    }
    if (temp1 != 0x02) {
        //> and #%01000000             ;check for d6 set
        temp5 = temp1 and 0x40
        //> beq SteadM                 ;if not set, branch to something else
        temp1 = temp5
        if (temp5 != 0) {
            //> lda Enemy_ID,x
            temp1 = enemyId[X]
            //> cmp #PowerUpObject         ;check for power-up object
            //> beq SteadM
            if (temp1 != PowerUpObject) {
                //> bne SlowM                  ;if any other object where d6 set, jump to set Y
                if (temp1 == PowerUpObject) {
                }
            }
        }
    }
    //> MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
    //> SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
    temp2 = 0x01
    //> SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
    temp1 = enemyXSpeed[X]
    //> pha                       ;save to stack
    push(temp1)
    //> bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
    if ((temp1 and 0x80) != 0) {
        //> iny
        temp2 = (temp2 + 1) and 0xFF
        //> iny                       ;otherwise increment Y to next data
        temp2 = (temp2 + 1) and 0xFF
    }
    //> AddHS:  clc
    //> adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
    temp6 = temp1 + xSpeedAdderData[temp2]
    temp1 = temp6 and 0xFF
    //> sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
    enemyXSpeed[X] = temp1
    //> jsr MoveEnemyHorizontally ;then do a sub to move horizontally
    moveEnemyHorizontally(X)
    //> pla
    temp1 = pull()
    //> sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
    enemyXSpeed[X] = temp1
    //> rts                       ;original memory location, then leave
    return
}

// Decompiled from MoveJumpingEnemy
fun moveJumpingEnemy() {
    //> MoveJumpingEnemy:
    //> jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
    movejEnemyvertically()
    //> jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
}

// Decompiled from ProcMoveRedPTroopa
fun procMoveRedPTroopa(X: Int) {
    var X: Int = X
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val redPTroopaCenterYPos by MemoryByteIndexed(RedPTroopaCenterYPos)
    val redPTroopaOrigXPos by MemoryByteIndexed(RedPTroopaOrigXPos)
    //> MoveRedPTroopaDown:
    //> ldy #$00            ;set Y to move downwards
    //> jmp MoveRedPTroopa  ;skip to movement routine
    //> MoveRedPTroopaUp:
    //> ldy #$01            ;set Y to move upwards
    //> MoveRedPTroopa:
    //> inx                 ;increment X for enemy offset
    X = (X + 1) and 0xFF
    //> lda #$03
    //> sta $00             ;set downward movement amount here
    memory[0x0] = 0x03.toUByte()
    //> lda #$06
    //> sta $01             ;set upward movement amount here
    memory[0x1] = 0x06.toUByte()
    //> lda #$02
    //> sta $02             ;set maximum speed here
    memory[0x2] = 0x02.toUByte()
    //> tya                 ;set movement direction in A, and
    //> jmp RedPTroopaGrav  ;jump to move this thing
    //> RedPTroopaGrav:
    //> jsr ImposeGravity  ;do a sub to move object gradually
    imposeGravity(0x01, X)
    //> ldx ObjectOffset   ;get enemy object offset and leave
    //> rts
    return
}

// Decompiled from MoveFlyGreenPTroopa
fun moveFlyGreenPTroopa(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> MoveFlyGreenPTroopa:
    //> jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
    xmovecntrGreenptroopa()
    //> jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
    moveWithXMCntrs(X)
    //> ldy #$01                   ;set Y to move green paratroopa down
    //> lda FrameCounter
    //> and #%00000011             ;check frame counter 2 LSB for any bits set
    temp0 = frameCounter and 0x03
    //> bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
    temp1 = temp0
    temp2 = 0x01
    if (temp0 == 0) {
        //> lda FrameCounter
        temp1 = frameCounter
        //> and #%01000000             ;check frame counter for d6 set
        temp3 = temp1 and 0x40
        //> bne YSway                  ;branch to move green paratroopa down if set
        temp1 = temp3
        if (temp3 == 0) {
            //> ldy #$ff                   ;otherwise set Y to move green paratroopa up
            temp2 = 0xFF
        }
        //> YSway:  sty $00                    ;store adder here
        memory[0x0] = temp2.toUByte()
        //> lda Enemy_Y_Position,x
        temp1 = enemyYPosition[X]
        //> clc                        ;add or subtract from vertical position
        //> adc $00                    ;to give green paratroopa a wavy flight
        temp4 = temp1 + memory[0x0].toInt()
        temp1 = temp4 and 0xFF
        //> sta Enemy_Y_Position,x
        enemyYPosition[X] = temp1
    }
    //> NoMGPT: rts                        ;leave!
    return
}

// Decompiled from XMoveCntr_GreenPTroopa
fun xmovecntrGreenptroopa() {
    //> XMoveCntr_GreenPTroopa:
    //> lda #$13                    ;load preset maximum value for secondary counter
    // Fall-through tail call to xmovecntrPlatform
    xmovecntrPlatform(0x13, X)
}

// Decompiled from XMoveCntr_Platform
fun xmovecntrPlatform(A: Int, X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val xMovePrimaryCounter by MemoryByteIndexed(XMovePrimaryCounter)
    val xMoveSecondaryCounter by MemoryByteIndexed(XMoveSecondaryCounter)
    //> XMoveCntr_Platform:
    //> sta $01                     ;store value here
    memory[0x1] = A.toUByte()
    //> lda FrameCounter
    //> and #%00000011              ;branch to leave if not on
    temp0 = frameCounter and 0x03
    //> bne NoIncXM                 ;every fourth frame
    temp1 = temp0
    if (temp0 == 0) {
        //> ldy XMoveSecondaryCounter,x ;get secondary counter
        //> lda XMovePrimaryCounter,x   ;get primary counter
        temp1 = xMovePrimaryCounter[X]
        //> lsr
        temp1 = temp1 shr 1
        //> bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
        temp2 = xMoveSecondaryCounter[X]
        if ((temp1 and 0x01) == 0) {
            //> cpy $01                     ;compare secondary counter to preset maximum value
            //> beq IncPXM                  ;if equal, branch ahead of this part
            if (temp2 != memory[0x1].toInt()) {
                //> inc XMoveSecondaryCounter,x ;increment secondary counter and leave
                xMoveSecondaryCounter[X] = (xMoveSecondaryCounter[X] + 1) and 0xFF
            } else {
                //> IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
                xMovePrimaryCounter[X] = (xMovePrimaryCounter[X] + 1) and 0xFF
                //> rts
                return
            }
        }
    }
    //> NoIncXM: rts
    return
}

// Decompiled from MoveWithXMCntrs
fun moveWithXMCntrs(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val xMovePrimaryCounter by MemoryByteIndexed(XMovePrimaryCounter)
    val xMoveSecondaryCounter by MemoryByteIndexed(XMoveSecondaryCounter)
    //> MoveWithXMCntrs:
    //> lda XMoveSecondaryCounter,x  ;save secondary counter to stack
    //> pha
    push(xMoveSecondaryCounter[X])
    //> ldy #$01                     ;set value here by default
    //> lda XMovePrimaryCounter,x
    //> and #%00000010               ;if d1 of primary counter is
    temp0 = xMovePrimaryCounter[X] and 0x02
    //> bne XMRight                  ;set, branch ahead of this part here
    temp1 = temp0
    temp2 = 0x01
    if (temp0 == 0) {
        //> lda XMoveSecondaryCounter,x
        temp1 = xMoveSecondaryCounter[X]
        //> eor #$ff                     ;otherwise change secondary
        temp3 = temp1 xor 0xFF
        //> clc                          ;counter to two's compliment
        //> adc #$01
        temp4 = temp3 + 0x01
        temp1 = temp4 and 0xFF
        //> sta XMoveSecondaryCounter,x
        xMoveSecondaryCounter[X] = temp1
        //> ldy #$02                     ;load alternate value here
        temp2 = 0x02
    }
    //> XMRight: sty Enemy_MovingDir,x        ;store as moving direction
    enemyMovingdir[X] = temp2
    //> jsr MoveEnemyHorizontally
    moveEnemyHorizontally(X)
    //> sta $00                      ;save value obtained from sub here
    memory[0x0] = temp1.toUByte()
    //> pla                          ;get secondary counter from stack
    temp1 = pull()
    //> sta XMoveSecondaryCounter,x  ;and return to original place
    xMoveSecondaryCounter[X] = temp1
    //> rts
    return
}

// Decompiled from MoveBloober
fun moveBloober(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val blooberBitmasks by MemoryByteIndexed(BlooberBitmasks)
    val blooperMoveSpeed by MemoryByteIndexed(BlooperMoveSpeed)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> MoveBloober:
    //> lda Enemy_State,x
    //> and #%00100000             ;check enemy state for d5 set
    temp0 = enemyState[X] and 0x20
    //> bne MoveDefeatedBloober    ;branch if set to move defeated bloober
    if (!(temp0 == 0)) {
        //  goto MoveDefeatedBloober
        return
    }
    temp1 = temp0
    if (temp0 == 0) {
        //> ldy SecondaryHardMode      ;use secondary hard mode flag as offset
        //> lda PseudoRandomBitReg+1,x ;get LSFR
        temp1 = pseudoRandomBitReg[1 + X]
        //> and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
        temp2 = temp1 and blooberBitmasks[secondaryHardMode]
        //> bne BlooberSwim            ;if any bits set, skip ahead to make swim
        temp1 = temp2
        temp3 = secondaryHardMode
        if (temp2 == 0) {
            //> txa
            //> lsr                        ;check to see if on second or fourth slot (1 or 3)
            X = X shr 1
            //> bcc FBLeft                 ;if not, branch to figure out moving direction
            temp1 = X
            if ((X and 0x01) != 0) {
                //> ldy Player_MovingDir       ;otherwise, load player's moving direction and
                temp3 = playerMovingdir
                //> bcs SBMDir                 ;do an unconditional branch to set
                if ((X and 0x01) == 0) {
                }
            }
            //> FBLeft: ldy #$02                   ;set left moving direction by default
            temp3 = 0x02
            //> jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
            playerEnemyDiff(X)
            //> bpl SBMDir                 ;if enemy to the right of player, keep left
            if ((temp3 and 0x80) != 0) {
                //> dey                        ;otherwise decrement to set right moving direction
                temp3 = (temp3 - 1) and 0xFF
            }
            //> SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
            enemyMovingdir[X] = temp3
        }
        //> BlooberSwim:
        //> jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
        procSwimmingB(X)
        //> lda Enemy_Y_Position,x   ;get vertical coordinate
        temp1 = enemyYPosition[X]
        //> sec
        //> sbc Enemy_Y_MoveForce,x  ;subtract movement force
        temp4 = temp1 - enemyYMoveforce[X]
        temp1 = temp4 and 0xFF
        //> cmp #$20                 ;check to see if position is above edge of status bar
        //> bcc SwimX                ;if so, don't do it
        if (temp1 >= 0x20) {
            //> sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
            enemyYPosition[X] = temp1
        }
        //> SwimX: ldy Enemy_MovingDir,x    ;check moving direction
        temp3 = enemyMovingdir[X]
        //> dey
        temp3 = (temp3 - 1) and 0xFF
        //> bne LeftSwim             ;if moving to the left, branch to second part
        if (temp3 == 0) {
            //> lda Enemy_X_Position,x
            temp1 = enemyXPosition[X]
            //> clc                      ;add movement speed to horizontal coordinate
            //> adc BlooperMoveSpeed,x
            temp5 = temp1 + blooperMoveSpeed[X]
            temp1 = temp5 and 0xFF
            //> sta Enemy_X_Position,x   ;store result as new horizontal coordinate
            enemyXPosition[X] = temp1
            //> lda Enemy_PageLoc,x
            temp1 = enemyPageloc[X]
            //> adc #$00                 ;add carry to page location
            temp6 = temp1 + (if (temp5 > 0xFF) 1 else 0)
            temp1 = temp6 and 0xFF
            //> sta Enemy_PageLoc,x      ;store as new page location and leave
            enemyPageloc[X] = temp1
            //> rts
            return
        }
        //> LeftSwim:
        //> lda Enemy_X_Position,x
        temp1 = enemyXPosition[X]
        //> sec                      ;subtract movement speed from horizontal coordinate
        //> sbc BlooperMoveSpeed,x
        temp7 = temp1 - blooperMoveSpeed[X]
        temp1 = temp7 and 0xFF
        //> sta Enemy_X_Position,x   ;store result as new horizontal coordinate
        enemyXPosition[X] = temp1
        //> lda Enemy_PageLoc,x
        temp1 = enemyPageloc[X]
        //> sbc #$00                 ;subtract borrow from page location
        temp8 = temp1 - (if (temp7 >= 0) 0 else 1)
        temp1 = temp8 and 0xFF
        //> sta Enemy_PageLoc,x      ;store as new page location and leave
        enemyPageloc[X] = temp1
        //> rts
        return
    } else {
        //> MoveDefeatedBloober:
        //> jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
    }
}

// Decompiled from ProcSwimmingB
fun procSwimmingB(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var playerYPosition by MemoryByte(Player_Y_Position)
    val blooperMoveCounter by MemoryByteIndexed(BlooperMoveCounter)
    val blooperMoveSpeed by MemoryByteIndexed(BlooperMoveSpeed)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ProcSwimmingB:
    //> lda BlooperMoveCounter,x  ;get enemy's movement counter
    //> and #%00000010            ;check for d1 set
    temp0 = blooperMoveCounter[X] and 0x02
    //> bne ChkForFloatdown       ;branch if set
    temp1 = temp0
    if (temp0 == 0) {
        //> lda FrameCounter
        temp1 = frameCounter
        //> and #%00000111            ;get 3 LSB of frame counter
        temp2 = temp1 and 0x07
        //> pha                       ;and save it to the stack
        push(temp2)
        //> lda BlooperMoveCounter,x  ;get enemy's movement counter
        temp1 = blooperMoveCounter[X]
        //> lsr                       ;check for d0 set
        temp1 = temp1 shr 1
        //> bcs SlowSwim              ;branch if set
        if ((temp1 and 0x01) == 0) {
            //> pla                       ;pull 3 LSB of frame counter from the stack
            temp1 = pull()
            //> bne BSwimE                ;branch to leave, execute code only every eighth frame
            if (temp1 == 0) {
                //> lda Enemy_Y_MoveForce,x
                temp1 = enemyYMoveforce[X]
                //> clc                       ;add to movement force to speed up swim
                //> adc #$01
                temp3 = temp1 + 0x01
                temp1 = temp3 and 0xFF
                //> sta Enemy_Y_MoveForce,x   ;set movement force
                enemyYMoveforce[X] = temp1
                //> sta BlooperMoveSpeed,x    ;set as movement speed
                blooperMoveSpeed[X] = temp1
                //> cmp #$02
                //> bne BSwimE                ;if certain horizontal speed, branch to leave
                if (temp1 == 0x02) {
                    //> inc BlooperMoveCounter,x  ;otherwise increment movement counter
                    blooperMoveCounter[X] = (blooperMoveCounter[X] + 1) and 0xFF
                }
            }
            //> BSwimE: rts
            return
        }
        //> SlowSwim:
        //> pla                      ;pull 3 LSB of frame counter from the stack
        temp1 = pull()
        //> bne NoSSw                ;branch to leave, execute code only every eighth frame
        if (temp1 == 0) {
            //> lda Enemy_Y_MoveForce,x
            temp1 = enemyYMoveforce[X]
            //> sec                      ;subtract from movement force to slow swim
            //> sbc #$01
            temp4 = temp1 - 0x01
            temp1 = temp4 and 0xFF
            //> sta Enemy_Y_MoveForce,x  ;set movement force
            enemyYMoveforce[X] = temp1
            //> sta BlooperMoveSpeed,x   ;set as movement speed
            blooperMoveSpeed[X] = temp1
            //> bne NoSSw                ;if any speed, branch to leave
            if ((temp4 and 0xFF) == 0) {
                //> inc BlooperMoveCounter,x ;otherwise increment movement counter
                blooperMoveCounter[X] = (blooperMoveCounter[X] + 1) and 0xFF
                //> lda #$02
                temp1 = 0x02
                //> sta EnemyIntervalTimer,x ;set enemy's timer
                enemyIntervalTimer[X] = temp1
            }
        }
        //> NoSSw: rts                      ;leave
        return
    } else {
        //> ChkForFloatdown:
        //> lda EnemyIntervalTimer,x ;get enemy timer
        temp1 = enemyIntervalTimer[X]
        //> beq ChkNearPlayer        ;branch if expired
        if (temp1 != 0) {
            //> Floatdown:
            //> lda FrameCounter        ;get frame counter
            temp1 = frameCounter
            //> lsr                     ;check for d0 set
            temp1 = temp1 shr 1
            //> bcs NoFD                ;branch to leave on every other frame
            if ((temp1 and 0x01) == 0) {
                //> inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
                enemyYPosition[X] = (enemyYPosition[X] + 1) and 0xFF
            }
            //> NoFD: rts                     ;leave
            return
        }
    }
    do {
        //> ChkNearPlayer:
        //> lda Enemy_Y_Position,x    ;get vertical coordinate
        temp1 = enemyYPosition[X]
        //> adc #$10                  ;add sixteen pixels
        temp5 = temp1 + 0x10
        temp1 = temp5 and 0xFF
        //> cmp Player_Y_Position     ;compare result with player's vertical coordinate
        //> bcc Floatdown             ;if modified vertical less than player's, branch
    } while (!(temp1 >= playerYPosition))
    //> lda #$00
    temp1 = 0x00
    //> sta BlooperMoveCounter,x  ;otherwise nullify movement counter
    blooperMoveCounter[X] = temp1
    //> rts
    return
}

// Decompiled from MoveBulletBill
fun moveBulletBill(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> MoveBulletBill:
    //> lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
    //> and #%00100000
    temp0 = enemyState[X] and 0x20
    //> beq NotDefB                ;if not set, continue with movement code
    if (temp0 == 0) {
        //  goto NotDefB
        return
    }
    temp1 = temp0
    if (temp0 != 0) {
        //> jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
    }
    //> NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
    temp1 = 0xE8
    //> sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
    enemyXSpeed[X] = temp1
    //> jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
}

// Decompiled from MoveSwimmingCheepCheep
fun moveSwimmingCheepCheep(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    val cheepCheepMoveMFlag by MemoryByteIndexed(CheepCheepMoveMFlag)
    val cheepCheepOrigYPos by MemoryByteIndexed(CheepCheepOrigYPos)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXMoveforce by MemoryByteIndexed(Enemy_X_MoveForce)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val swimCCXMoveData by MemoryByteIndexed(SwimCCXMoveData)
    //> MoveSwimmingCheepCheep:
    //> lda Enemy_State,x         ;check cheep-cheep's enemy object state
    //> and #%00100000            ;for d5 set
    temp0 = enemyState[X] and 0x20
    //> beq CCSwim                ;if not set, continue with movement code
    temp1 = temp0
    if (temp0 != 0) {
        //> jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
    }
    //> CCSwim: sta $03                   ;save enemy state in $03
    memory[0x3] = temp1.toUByte()
    //> lda Enemy_ID,x            ;get enemy identifier
    temp1 = enemyId[X]
    //> sec
    //> sbc #$0a                  ;subtract ten for cheep-cheep identifiers
    temp2 = temp1 - 0x0A
    temp1 = temp2 and 0xFF
    //> tay                       ;use as offset
    //> lda SwimCCXMoveData,y     ;load value here
    temp1 = swimCCXMoveData[temp1]
    //> sta $02
    memory[0x2] = temp1.toUByte()
    //> lda Enemy_X_MoveForce,x   ;load horizontal force
    temp1 = enemyXMoveforce[X]
    //> sec
    //> sbc $02                   ;subtract preset value from horizontal force
    temp3 = temp1 - memory[0x2].toInt()
    temp1 = temp3 and 0xFF
    //> sta Enemy_X_MoveForce,x   ;store as new horizontal force
    enemyXMoveforce[X] = temp1
    //> lda Enemy_X_Position,x    ;get horizontal coordinate
    temp1 = enemyXPosition[X]
    //> sbc #$00                  ;subtract borrow (thus moving it slowly)
    temp4 = temp1 - (if (temp3 >= 0) 0 else 1)
    temp1 = temp4 and 0xFF
    //> sta Enemy_X_Position,x    ;and save as new horizontal coordinate
    enemyXPosition[X] = temp1
    //> lda Enemy_PageLoc,x
    temp1 = enemyPageloc[X]
    //> sbc #$00                  ;subtract borrow again, this time from the
    temp5 = temp1 - (if (temp4 >= 0) 0 else 1)
    temp1 = temp5 and 0xFF
    //> sta Enemy_PageLoc,x       ;page location, then save
    enemyPageloc[X] = temp1
    //> lda #$20
    temp1 = 0x20
    //> sta $02                   ;save new value here
    memory[0x2] = temp1.toUByte()
    //> cpx #$02                  ;check enemy object offset
    //> bcc ExSwCC                ;if in first or second slot, branch to leave
    temp6 = temp1
    if (X >= 0x02) {
        //> lda CheepCheepMoveMFlag,x ;check movement flag
        temp1 = cheepCheepMoveMFlag[X]
        //> cmp #$10                  ;if movement speed set to $00,
        //> bcc CCSwimUpwards         ;branch to move upwards
        if (temp1 >= 0x10) {
            //> lda Enemy_YMF_Dummy,x
            temp1 = enemyYmfDummy[X]
            //> clc
            //> adc $02                   ;add preset value to dummy variable to get carry
            temp7 = temp1 + memory[0x2].toInt()
            temp1 = temp7 and 0xFF
            //> sta Enemy_YMF_Dummy,x     ;and save dummy
            enemyYmfDummy[X] = temp1
            //> lda Enemy_Y_Position,x    ;get vertical coordinate
            temp1 = enemyYPosition[X]
            //> adc $03                   ;add carry to it plus enemy state to slowly move it downwards
            temp8 = temp1 + memory[0x3].toInt() + (if (temp7 > 0xFF) 1 else 0)
            temp1 = temp8 and 0xFF
            //> sta Enemy_Y_Position,x    ;save as new vertical coordinate
            enemyYPosition[X] = temp1
            //> lda Enemy_Y_HighPos,x
            temp1 = enemyYHighpos[X]
            //> adc #$00                  ;add carry to page location and
            temp9 = temp1 + (if (temp8 > 0xFF) 1 else 0)
            temp1 = temp9 and 0xFF
            //> jmp ChkSwimYPos           ;jump to end of movement code
        } else {
            //> CCSwimUpwards:
            //> lda Enemy_YMF_Dummy,x
            temp1 = enemyYmfDummy[X]
            //> sec
            //> sbc $02                   ;subtract preset value to dummy variable to get borrow
            temp10 = temp1 - memory[0x2].toInt()
            temp1 = temp10 and 0xFF
            //> sta Enemy_YMF_Dummy,x     ;and save dummy
            enemyYmfDummy[X] = temp1
            //> lda Enemy_Y_Position,x    ;get vertical coordinate
            temp1 = enemyYPosition[X]
            //> sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
            temp11 = temp1 - memory[0x3].toInt() - (if (temp10 >= 0) 0 else 1)
            temp1 = temp11 and 0xFF
            //> sta Enemy_Y_Position,x    ;save as new vertical coordinate
            enemyYPosition[X] = temp1
            //> lda Enemy_Y_HighPos,x
            temp1 = enemyYHighpos[X]
            //> sbc #$00                  ;subtract borrow from page location
            temp12 = temp1 - (if (temp11 >= 0) 0 else 1)
            temp1 = temp12 and 0xFF
        }
        //> ChkSwimYPos:
        //> sta Enemy_Y_HighPos,x     ;save new page location here
        enemyYHighpos[X] = temp1
        //> ldy #$00                  ;load movement speed to upwards by default
        temp6 = 0x00
        //> lda Enemy_Y_Position,x    ;get vertical coordinate
        temp1 = enemyYPosition[X]
        //> sec
        //> sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
        temp13 = temp1 - cheepCheepOrigYPos[X]
        temp1 = temp13 and 0xFF
        //> bpl YPDiff                ;if result positive, skip to next part
        if ((temp13 and 0xFF and 0x80) != 0) {
            //> ldy #$10                  ;otherwise load movement speed to downwards
            temp6 = 0x10
            //> eor #$ff
            temp14 = temp1 xor 0xFF
            //> clc                       ;get two's compliment of result
            //> adc #$01                  ;to obtain total difference of original vs. current
            temp15 = temp14 + 0x01
            temp1 = temp15 and 0xFF
        }
        //> YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
        //> bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
        if (temp1 >= 0x0F) {
            //> tya
            //> sta CheepCheepMoveMFlag,x ;otherwise change movement speed
            cheepCheepMoveMFlag[X] = temp6
        }
    }
    //> ExSwCC: rts                       ;leave
    return
}

// Decompiled from ProcFirebar
fun procFirebar(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var timerControl by MemoryByte(TimerControl)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val firebarSpinSpeed by MemoryByteIndexed(FirebarSpinSpeed)
    val firebarspinstateHigh by MemoryByteIndexed(FirebarSpinState_High)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> ProcFirebar:
    //> jsr GetEnemyOffscreenBits   ;get offscreen information
    getEnemyOffscreenBits(X)
    //> lda Enemy_OffscreenBits     ;check for d3 set
    //> and #%00001000              ;if so, branch to leave
    temp0 = enemyOffscreenbits and 0x08
    //> bne SkipFBar
    temp1 = temp0
    if (temp0 == 0) {
        //> lda TimerControl            ;if master timer control set, branch
        temp1 = timerControl
        //> bne SusFbar                 ;ahead of this part
        if (temp1 == 0) {
            //> lda FirebarSpinSpeed,x      ;load spinning speed of firebar
            temp1 = firebarSpinSpeed[X]
            //> jsr FirebarSpin             ;modify current spinstate
            firebarSpin(temp1, X)
            //> and #%00011111              ;mask out all but 5 LSB
            temp2 = temp1 and 0x1F
            //> sta FirebarSpinState_High,x ;and store as new high byte of spinstate
            firebarspinstateHigh[X] = temp2
        }
        //> SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
        temp1 = firebarspinstateHigh[X]
        //> ldy Enemy_ID,x              ;check enemy identifier
        //> cpy #$1f
        //> bcc SetupGFB                ;if < $1f (long firebar), branch
        temp3 = enemyId[X]
        if (enemyId[X] >= 0x1F) {
            //> cmp #$08                    ;check high byte of spinstate
            //> beq SkpFSte                 ;if eight, branch to change
            if (temp1 != 0x08) {
                //> cmp #$18
                //> bne SetupGFB                ;if not at twenty-four branch to not change
                if (temp1 == 0x18) {
                }
            }
            //> SkpFSte:  clc
            //> adc #$01                    ;add one to spinning thing to avoid horizontal state
            temp4 = temp1 + 0x01
            temp1 = temp4 and 0xFF
            //> sta FirebarSpinState_High,x
            firebarspinstateHigh[X] = temp1
        }
        //> SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
        memory[0xEF] = temp1.toUByte()
        //> jsr RelativeEnemyPosition   ;get relative coordinates to screen
        relativeEnemyPosition()
        //> jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
        getFirebarPosition(temp1)
        //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
        temp3 = enemySprdataoffset[X]
        //> lda Enemy_Rel_YPos          ;get relative vertical coordinate
        temp1 = enemyRelYpos
        //> sta Sprite_Y_Position,y     ;store as Y in OAM data
        spriteYPosition[temp3] = temp1
        //> sta $07                     ;also save here
        memory[0x7] = temp1.toUByte()
        //> lda Enemy_Rel_XPos          ;get relative horizontal coordinate
        temp1 = enemyRelXpos
        //> sta Sprite_X_Position,y     ;store as X in OAM data
        spriteXPosition[temp3] = temp1
        //> sta $06                     ;also save here
        memory[0x6] = temp1.toUByte()
        //> lda #$01
        temp1 = 0x01
        //> sta $00                     ;set $01 value here (not necessary)
        memory[0x0] = temp1.toUByte()
        //> jsr FirebarCollision        ;draw fireball part and do collision detection
        firebarCollision(temp3)
        //> ldy #$05                    ;load value for short firebars by default
        temp3 = 0x05
        //> lda Enemy_ID,x
        temp1 = enemyId[X]
        //> cmp #$1f                    ;are we doing a long firebar?
        //> bcc SetMFbar                ;no, branch then
        if (temp1 >= 0x1F) {
            //> ldy #$0b                    ;otherwise load value for long firebars
            temp3 = 0x0B
        }
        //> SetMFbar: sty $ed                     ;store maximum value for length of firebars
        memory[0xED] = temp3.toUByte()
        //> lda #$00
        temp1 = 0x00
        //> sta $00                     ;initialize counter here
        memory[0x0] = temp1.toUByte()
        do {
            //> DrawFbar: lda $ef                     ;load high byte of spinstate
            temp1 = memory[0xEF].toInt()
            //> jsr GetFirebarPosition      ;get fireball position data depending on firebar part
            getFirebarPosition(temp1)
            //> jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
            drawfirebarCollision()
            //> lda $00                     ;check which firebar part
            temp1 = memory[0x0].toInt()
            //> cmp #$04
            //> bne NextFbar
            if (temp1 == 0x04) {
                //> ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
                temp3 = duplicateobjOffset
                //> lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
                temp1 = enemySprdataoffset[temp3]
                //> sta $06                     ;using long firebar offset, then store as new one here
                memory[0x6] = temp1.toUByte()
            }
            //> NextFbar: inc $00                     ;move onto the next firebar part
            memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
            //> lda $00
            temp1 = memory[0x0].toInt()
            //> cmp $ed                     ;if we end up at the maximum part, go on and leave
            //> bcc DrawFbar                ;otherwise go back and do another
        } while (!(temp1 >= memory[0xED].toInt()))
    }
    //> SkipFBar: rts
    return
}

// Decompiled from DrawFirebar_Collision
fun drawfirebarCollision() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawFirebar_Collision:
    //> lda $03                  ;store mirror data elsewhere
    //> sta $05
    memory[0x5] = memory[0x3].toInt().toUByte()
    //> ldy $06                  ;load OAM data offset for firebar
    //> lda $01                  ;load horizontal adder we got from position loader
    //> lsr $05                  ;shift LSB of mirror data
    memory[0x5] = ((memory[0x5].toInt() shr 1) and 0xFF).toUByte()
    //> bcs AddHA                ;if carry was set, skip this part
    temp0 = memory[0x1].toInt()
    temp1 = memory[0x6].toInt()
    if ((memory[0x5].toInt() and 0x01) == 0) {
        //> eor #$ff
        temp2 = temp0 xor 0xFF
        //> adc #$01                 ;otherwise get two's compliment of horizontal adder
        temp3 = temp2 + 0x01 + (if ((memory[0x5].toInt() and 0x01) != 0) 1 else 0)
        temp0 = temp3 and 0xFF
    }
    //> AddHA:   clc                      ;add horizontal coordinate relative to screen to
    //> adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
    temp4 = temp0 + enemyRelXpos
    temp0 = temp4 and 0xFF
    //> sta Sprite_X_Position,y  ;store as X coordinate here
    spriteXPosition[temp1] = temp0
    //> sta $06                  ;store here for now, note offset is saved in Y still
    memory[0x6] = temp0.toUByte()
    //> cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
    //> bcs SubtR1               ;if sprite coordinate => original coordinate, branch
    if (!(temp0 >= enemyRelXpos)) {
        //> lda Enemy_Rel_XPos
        temp0 = enemyRelXpos
        //> sec                      ;otherwise subtract sprite X from the
        //> sbc $06                  ;original one and skip this part
        temp5 = temp0 - memory[0x6].toInt()
        temp0 = temp5 and 0xFF
        //> jmp ChkFOfs
    } else {
        //> SubtR1:  sec                      ;subtract original X from the
        //> sbc Enemy_Rel_XPos       ;current sprite X
        temp6 = temp0 - enemyRelXpos
        temp0 = temp6 and 0xFF
    }
    //> ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
    //> bcc VAHandl              ;continue by handling vertical adder
    if (temp0 >= 0x59) {
        //> lda #$f8                 ;otherwise, load offscreen Y coordinate
        temp0 = 0xF8
        //> bne SetVFbr              ;and unconditionally branch to move sprite offscreen
        if (temp0 == 0) {
        }
    }
    //> VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
    temp0 = enemyRelYpos
    //> cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
    //> beq SetVFbr
    if (temp0 != 0xF8) {
        //> lda $02                  ;load vertical adder we got from position loader
        temp0 = memory[0x2].toInt()
        //> lsr $05                  ;shift LSB of mirror data one more time
        memory[0x5] = ((memory[0x5].toInt() shr 1) and 0xFF).toUByte()
        //> bcs AddVA                ;if carry was set, skip this part
        if ((memory[0x5].toInt() and 0x01) == 0) {
            //> eor #$ff
            temp7 = temp0 xor 0xFF
            //> adc #$01                 ;otherwise get two's compliment of second part
            temp8 = temp7 + 0x01 + (if ((memory[0x5].toInt() and 0x01) != 0) 1 else 0)
            temp0 = temp8 and 0xFF
        }
        //> AddVA:   clc                      ;add vertical coordinate relative to screen to
        //> adc Enemy_Rel_YPos       ;the second data, modified or otherwise
        temp9 = temp0 + enemyRelYpos
        temp0 = temp9 and 0xFF
    }
    //> SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
    spriteYPosition[temp1] = temp0
    //> sta $07                  ;also store here for now
    memory[0x7] = temp0.toUByte()
    // Fall-through tail call to firebarCollision
    firebarCollision(temp1)
}

// Decompiled from FirebarCollision
fun firebarCollision(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var enemyMovingdir by MemoryByte(Enemy_MovingDir)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerSize by MemoryByte(PlayerSize)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var timerControl by MemoryByte(TimerControl)
    val firebarYPos by MemoryByteIndexed(FirebarYPos)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    //> FirebarCollision:
    //> jsr DrawFirebar          ;run sub here to draw current tile of firebar
    drawFirebar(Y)
    //> tya                      ;return OAM data offset and save
    //> pha                      ;to the stack for now
    push(Y)
    //> lda StarInvincibleTimer  ;if star mario invincibility timer
    //> ora TimerControl         ;or master timer controls set
    temp0 = starInvincibleTimer or timerControl
    //> bne NoColFB              ;then skip all of this
    temp1 = temp0
    if (temp0 == 0) {
        //> sta $05                  ;otherwise initialize counter
        memory[0x5] = temp1.toUByte()
        //> ldy Player_Y_HighPos
        //> dey                      ;if player's vertical high byte offscreen,
        playerYHighpos = (playerYHighpos - 1) and 0xFF
        //> bne NoColFB              ;skip all of this
        temp2 = playerYHighpos
        if (playerYHighpos == 0) {
            //> ldy Player_Y_Position    ;get player's vertical position
            temp2 = playerYPosition
            //> lda PlayerSize           ;get player's size
            temp1 = playerSize
            //> bne AdjSm                ;if player small, branch to alter variables
            if (temp1 == 0) {
                //> lda CrouchingFlag
                temp1 = crouchingFlag
                //> beq BigJp                ;if player big and not crouching, jump ahead
                if (temp1 != 0) {
                }
            }
            //> AdjSm:   inc $05                  ;if small or big but crouching, execute this part
            memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
            //> inc $05                  ;first increment our counter twice (setting $02 as flag)
            memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
            //> tya
            //> clc                      ;then add 24 pixels to the player's
            //> adc #$18                 ;vertical coordinate
            temp3 = temp2 + 0x18
            temp1 = temp3 and 0xFF
            //> tay
            //> BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
            temp2 = temp1
            while (true /* unknown branch JMP */) {
                //> eor #$ff                 ;skip two's compliment part
                temp4 = temp1 xor 0xFF
                //> clc                      ;otherwise get two's compliment
                //> adc #$01
                temp5 = temp4 + 0x01
                temp1 = temp5 and 0xFF
                //> ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
                //> bcs Chk2Ofs
                if (!(temp1 >= 0x08)) {
                    //> lda $06                  ;if firebar on far right on the screen, skip this,
                    temp1 = memory[0x6].toInt()
                    //> cmp #$f0                 ;because, really, what's the point?
                    //> bcs Chk2Ofs
                    if (!(temp1 >= 0xF0)) {
                        //> lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
                        temp1 = spriteXPosition[4]
                        //> clc
                        //> adc #$04                 ;add four pixels
                        temp6 = temp1 + 0x04
                        temp1 = temp6 and 0xFF
                        //> sta $04                  ;store here
                        memory[0x4] = temp1.toUByte()
                        //> sec                      ;subtract horizontal coordinate of firebar
                        //> sbc $06                  ;from the X coordinate of player's sprite 1
                        temp7 = temp1 - memory[0x6].toInt()
                        temp1 = temp7 and 0xFF
                        //> bpl ChkFBCl              ;if modded X coordinate to the right of firebar
                        if ((temp7 and 0xFF and 0x80) != 0) {
                            //> eor #$ff                 ;skip two's compliment part
                            temp8 = temp1 xor 0xFF
                            //> clc                      ;otherwise get two's compliment
                            //> adc #$01
                            temp9 = temp8 + 0x01
                            temp1 = temp9 and 0xFF
                        }
                        //> ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
                        //> bcc ChgSDir              ;to process
                        if (temp1 >= 0x08) {
                        }
                    }
                }
                //> Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
                temp1 = memory[0x5].toInt()
                //> cmp #$02                 ;branch to increment OAM offset and leave, no collision
                //> beq NoColFB
                if (temp1 != 0x02) {
                    while (true) {
                        //> FBCLoop: sec                      ;subtract vertical position of firebar
                        //> sbc $07                  ;from the vertical coordinate of the player
                        temp10 = temp1 - memory[0x7].toInt()
                        temp1 = temp10 and 0xFF
                        //> bpl ChkVFBD              ;if player lower on the screen than firebar,
                        //> ldy $05                  ;otherwise get temp here and use as offset
                        temp2 = memory[0x5].toInt()
                        //> lda Player_Y_Position
                        temp1 = playerYPosition
                        //> clc
                        //> adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
                        temp11 = temp1 + firebarYPos[temp2]
                        temp1 = temp11 and 0xFF
                        //> inc $05                  ;then increment temp and jump back
                        memory[0x5] = ((memory[0x5].toInt() + 1) and 0xFF).toUByte()
                        //> jmp FBCLoop
                    }
                } else {
                    //> NoColFB: pla                      ;get OAM data offset
                    temp1 = pull()
                    //> clc                      ;add four to it and save
                    //> adc #$04
                    temp12 = temp1 + 0x04
                    temp1 = temp12 and 0xFF
                    //> sta $06
                    memory[0x6] = temp1.toUByte()
                    //> ldx ObjectOffset         ;get enemy object buffer offset and leave
                    //> rts
                    return
                }
            }
            //> ChgSDir: ldx #$01                 ;set movement direction by default
            //> lda $04                  ;if OAM X coordinate of player's sprite 1
            temp1 = memory[0x4].toInt()
            //> cmp $06                  ;is greater than horizontal coordinate of firebar
            //> bcs SetSDir              ;then do not alter movement direction
            temp13 = 0x01
            if (!(temp1 >= memory[0x6].toInt())) {
                //> inx                      ;otherwise increment it
                temp13 = (temp13 + 1) and 0xFF
            }
            //> SetSDir: stx Enemy_MovingDir      ;store movement direction here
            enemyMovingdir = temp13
            //> ldx #$00
            temp13 = 0x00
            //> lda $00                  ;save value written to $00 to stack
            temp1 = memory[0x0].toInt()
            //> pha
            push(temp1)
            //> jsr InjurePlayer         ;perform sub to hurt or kill player
            injurePlayer()
            //> pla
            temp1 = pull()
            //> sta $00                  ;get value of $00 from stack
            memory[0x0] = temp1.toUByte()
        }
    }
}

// Decompiled from GetFirebarPosition
fun getFirebarPosition(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    val firebarMirrorData by MemoryByteIndexed(FirebarMirrorData)
    val firebarPosLookupTbl by MemoryByteIndexed(FirebarPosLookupTbl)
    val firebarTblOffsets by MemoryByteIndexed(FirebarTblOffsets)
    //> GetFirebarPosition:
    //> pha                        ;save high byte of spinstate to the stack
    push(A)
    //> and #%00001111             ;mask out low nybble
    temp0 = A and 0x0F
    //> cmp #$09
    //> bcc GetHAdder              ;if lower than $09, branch ahead
    temp1 = temp0
    if (temp0 >= 0x09) {
        //> eor #%00001111             ;otherwise get two's compliment to oscillate
        temp2 = temp1 xor 0x0F
        //> clc
        //> adc #$01
        temp3 = temp2 + 0x01
        temp1 = temp3 and 0xFF
    }
    //> GetHAdder: sta $01                    ;store result, modified or not, here
    memory[0x1] = temp1.toUByte()
    //> ldy $00                    ;load number of firebar ball where we're at
    //> lda FirebarTblOffsets,y    ;load offset to firebar position data
    temp1 = firebarTblOffsets[memory[0x0].toInt()]
    //> clc
    //> adc $01                    ;add oscillated high byte of spinstate
    temp4 = temp1 + memory[0x1].toInt()
    temp1 = temp4 and 0xFF
    //> tay                        ;to offset here and use as new offset
    //> lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
    temp1 = firebarPosLookupTbl[temp1]
    //> sta $01
    memory[0x1] = temp1.toUByte()
    //> pla                        ;pull whatever was in A from the stack
    temp1 = pull()
    //> pha                        ;save it again because we still need it
    push(temp1)
    //> clc
    //> adc #$08                   ;add eight this time, to get vertical adder
    temp5 = temp1 + 0x08
    temp1 = temp5 and 0xFF
    //> and #%00001111             ;mask out high nybble
    temp6 = temp1 and 0x0F
    //> cmp #$09                   ;if lower than $09, branch ahead
    //> bcc GetVAdder
    temp1 = temp6
    temp7 = temp1
    if (temp6 >= 0x09) {
        //> eor #%00001111             ;otherwise get two's compliment
        temp8 = temp1 xor 0x0F
        //> clc
        //> adc #$01
        temp9 = temp8 + 0x01
        temp1 = temp9 and 0xFF
    }
    //> GetVAdder: sta $02                    ;store result here
    memory[0x2] = temp1.toUByte()
    //> ldy $00
    temp7 = memory[0x0].toInt()
    //> lda FirebarTblOffsets,y    ;load offset to firebar position data again
    temp1 = firebarTblOffsets[temp7]
    //> clc
    //> adc $02                    ;this time add value in $02 to offset here and use as offset
    temp10 = temp1 + memory[0x2].toInt()
    temp1 = temp10 and 0xFF
    //> tay
    //> lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
    temp1 = firebarPosLookupTbl[temp1]
    //> sta $02
    memory[0x2] = temp1.toUByte()
    //> pla                        ;pull out whatever was in A one last time
    temp1 = pull()
    //> lsr                        ;divide by eight or shift three to the right
    temp1 = temp1 shr 1
    //> lsr
    temp1 = temp1 shr 1
    //> lsr
    temp1 = temp1 shr 1
    //> tay                        ;use as offset
    //> lda FirebarMirrorData,y    ;load mirroring data here
    temp1 = firebarMirrorData[temp1]
    //> sta $03                    ;store
    memory[0x3] = temp1.toUByte()
    //> rts
    return
}

// Decompiled from MoveFlyingCheepCheep
fun moveFlyingCheepCheep(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flyCCBPriority by MemoryByteIndexed(FlyCCBPriority)
    val pRandomSubtracter by MemoryByteIndexed(PRandomSubtracter)
    //> MoveFlyingCheepCheep:
    //> lda Enemy_State,x          ;check cheep-cheep's enemy state
    //> and #%00100000             ;for d5 set
    temp0 = enemyState[X] and 0x20
    //> beq FlyCC                  ;branch to continue code if not set
    temp1 = temp0
    if (temp0 != 0) {
        //> lda #$00
        temp1 = 0x00
        //> sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
        enemySprattrib[X] = temp1
        //> jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
    }
    //> FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
    moveEnemyHorizontally(X)
    //> ldy #$0d                   ;set vertical movement amount
    //> lda #$05                   ;set maximum speed
    temp1 = 0x05
    //> jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
    setXMoveAmt(X, 0x0D)
    //> lda Enemy_Y_MoveForce,x
    temp1 = enemyYMoveforce[X]
    //> lsr                        ;get vertical movement force and
    temp1 = temp1 shr 1
    //> lsr                        ;move high nybble to low
    temp1 = temp1 shr 1
    //> lsr
    temp1 = temp1 shr 1
    //> lsr
    temp1 = temp1 shr 1
    //> tay                        ;save as offset (note this tends to go into reach of code)
    //> lda Enemy_Y_Position,x     ;get vertical position
    temp1 = enemyYPosition[X]
    //> sec                        ;subtract pseudorandom value based on offset from position
    //> sbc PRandomSubtracter,y
    temp2 = temp1 - pRandomSubtracter[temp1]
    temp1 = temp2 and 0xFF
    //> bpl AddCCF                  ;if result within top half of screen, skip this part
    temp3 = temp1
    if ((temp2 and 0xFF and 0x80) != 0) {
        //> eor #$ff
        temp4 = temp1 xor 0xFF
        //> clc                        ;otherwise get two's compliment
        //> adc #$01
        temp5 = temp4 + 0x01
        temp1 = temp5 and 0xFF
    }
    //> AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
    //> bcs BPGet                  ;skip to the end without changing movement force
    if (!(temp1 >= 0x08)) {
        //> lda Enemy_Y_MoveForce,x
        temp1 = enemyYMoveforce[X]
        //> clc
        //> adc #$10                   ;otherwise add to it
        temp6 = temp1 + 0x10
        temp1 = temp6 and 0xFF
        //> sta Enemy_Y_MoveForce,x
        enemyYMoveforce[X] = temp1
        //> lsr                        ;move high nybble to low again
        temp1 = temp1 shr 1
        //> lsr
        temp1 = temp1 shr 1
        //> lsr
        temp1 = temp1 shr 1
        //> lsr
        temp1 = temp1 shr 1
        //> tay
    }
    //> BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
    temp1 = flyCCBPriority[temp3]
    //> sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
    enemySprattrib[X] = temp1
    //> rts                        ;drawing it next frame), then leave
    return
}

// Decompiled from MoveLakitu
fun moveLakitu(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val lakituDiffAdj by MemoryByteIndexed(LakituDiffAdj)
    val lakituMoveDirection by MemoryByteIndexed(LakituMoveDirection)
    val lakituMoveSpeed by MemoryByteIndexed(LakituMoveSpeed)
    //> MoveLakitu:
    //> lda Enemy_State,x          ;check lakitu's enemy state
    //> and #%00100000             ;for d5 set
    temp0 = enemyState[X] and 0x20
    //> beq ChkLS                  ;if not set, continue with code
    temp1 = temp0
    if (temp0 != 0) {
        //> jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
    }
    //> ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
    temp1 = enemyState[X]
    //> beq Fr12S                  ;go ahead and continue with code
    if (temp1 != 0) {
        //> lda #$00
        temp1 = 0x00
        //> sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
        lakituMoveDirection[X] = temp1
        //> sta EnemyFrenzyBuffer      ;initialize frenzy buffer
        enemyFrenzyBuffer = temp1
        //> lda #$10
        temp1 = 0x10
        //> bne SetLSpd                ;load horizontal speed and do unconditional branch
        if (temp1 == 0) {
        }
    }
    //> Fr12S:   lda #Spiny
    temp1 = Spiny
    //> sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
    enemyFrenzyBuffer = temp1
    //> ldy #$02
    temp2 = 0x02
    do {
        //> LdLDa:   lda LakituDiffAdj,y        ;load values
        temp1 = lakituDiffAdj[temp2]
        //> sta $0001,y                ;store in zero page
        memory[0x1 + temp2] = temp1.toUByte()
        //> dey
        temp2 = (temp2 - 1) and 0xFF
        //> bpl LdLDa                  ;do this until all values are stired
    } while ((temp2 and 0x80) == 0)
    //> jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
    playerLakituDiff(X)
    //> SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
    lakituMoveSpeed[X] = temp1
    //> ldy #$01                   ;set moving direction to right by default
    temp2 = 0x01
    //> lda LakituMoveDirection,x
    temp1 = lakituMoveDirection[X]
    //> and #$01                   ;get LSB of moving direction
    temp3 = temp1 and 0x01
    //> bne SetLMov                ;if set, branch to the end to use moving direction
    if (!(temp3 == 0)) {
        //  goto SetLMov
        return
    }
    temp1 = temp3
    if (temp3 == 0) {
        //> lda LakituMoveSpeed,x
        temp1 = lakituMoveSpeed[X]
        //> eor #$ff                   ;get two's compliment of moving speed
        temp4 = temp1 xor 0xFF
        //> clc
        //> adc #$01
        temp5 = temp4 + 0x01
        temp1 = temp5 and 0xFF
        //> sta LakituMoveSpeed,x      ;store as new moving speed
        lakituMoveSpeed[X] = temp1
        //> iny                        ;increment moving direction to left
        temp2 = (temp2 + 1) and 0xFF
    }
    //> SetLMov: sty Enemy_MovingDir,x      ;store moving direction
    enemyMovingdir[X] = temp2
    //> jmp MoveEnemyHorizontally  ;move lakitu horizontally
}

// Decompiled from PlayerLakituDiff
fun playerLakituDiff(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var scrollAmount by MemoryByte(ScrollAmount)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val lakituMoveDirection by MemoryByteIndexed(LakituMoveDirection)
    val lakituMoveSpeed by MemoryByteIndexed(LakituMoveSpeed)
    //> PlayerLakituDiff:
    //> ldy #$00                   ;set Y for default value
    //> jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
    playerEnemyDiff(X)
    //> bpl ChkLakDif              ;branch if enemy is to the right of the player
    temp0 = 0x00
    if ((0x00 and 0x80) != 0) {
        //> iny                        ;increment Y for left of player
        temp0 = (temp0 + 1) and 0xFF
        //> lda $00
        //> eor #$ff                   ;get two's compliment of low byte of horizontal difference
        temp1 = memory[0x0].toInt() xor 0xFF
        //> clc
        //> adc #$01                   ;store two's compliment as horizontal difference
        temp2 = temp1 + 0x01
        //> sta $00
        memory[0x0] = (temp2 and 0xFF).toUByte()
    }
    //> ChkLakDif: lda $00                    ;get low byte of horizontal difference
    //> cmp #$3c                   ;if within a certain distance of player, branch
    //> bcc ChkPSpeed
    temp3 = memory[0x0].toInt()
    if (memory[0x0].toInt() >= 0x3C) {
        //> lda #$3c                   ;otherwise set maximum distance
        temp3 = 0x3C
        //> sta $00
        memory[0x0] = temp3.toUByte()
        //> lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
        temp3 = enemyId[X]
        //> cmp #Lakitu
        //> bne ChkPSpeed              ;if not, branch elsewhere
        if (temp3 == Lakitu) {
            //> tya                        ;compare contents of Y, now in A
            //> cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
            //> beq ChkPSpeed              ;if moving toward the player, branch, do not alter
            temp3 = temp0
            if (temp0 != lakituMoveDirection[X]) {
                //> lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
                temp3 = lakituMoveDirection[X]
                //> beq SetLMovD               ;branch and alter without delay
                if (temp3 != 0) {
                    //> dec LakituMoveSpeed,x      ;decrement horizontal speed
                    lakituMoveSpeed[X] = (lakituMoveSpeed[X] - 1) and 0xFF
                    //> lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
                    temp3 = lakituMoveSpeed[X]
                    //> bne ExMoveLak
                    if (temp3 == 0) {
                    } else {
                        //> ExMoveLak: rts                        ;leave!!!
                        return
                    }
                }
                //> SetLMovD:  tya                        ;set horizontal direction depending on horizontal
                //> sta LakituMoveDirection,x  ;difference between enemy and player if necessary
                lakituMoveDirection[X] = temp0
            }
        }
    }
    //> ChkPSpeed: lda $00
    temp3 = memory[0x0].toInt()
    //> and #%00111100             ;mask out all but four bits in the middle
    temp4 = temp3 and 0x3C
    //> lsr                        ;divide masked difference by four
    temp4 = temp4 shr 1
    //> lsr
    temp4 = temp4 shr 1
    //> sta $00                    ;store as new value
    memory[0x0] = temp4.toUByte()
    //> ldy #$00                   ;init offset
    temp0 = 0x00
    //> lda Player_X_Speed
    temp3 = playerXSpeed
    //> beq SubDifAdj              ;if player not moving horizontally, branch
    if (temp3 != 0) {
        //> lda ScrollAmount
        temp3 = scrollAmount
        //> beq SubDifAdj              ;if scroll speed not set, branch to same place
        if (temp3 != 0) {
            //> iny                        ;otherwise increment offset
            temp0 = (temp0 + 1) and 0xFF
            //> lda Player_X_Speed
            temp3 = playerXSpeed
            //> cmp #$19                   ;if player not running, branch
            //> bcc ChkSpinyO
            if (temp3 >= 0x19) {
                //> lda ScrollAmount
                temp3 = scrollAmount
                //> cmp #$02                   ;if scroll speed below a certain amount, branch
                //> bcc ChkSpinyO              ;to same place
                if (temp3 >= 0x02) {
                    //> iny                        ;otherwise increment once more
                    temp0 = (temp0 + 1) and 0xFF
                }
            }
            //> ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
            temp3 = enemyId[X]
            //> cmp #Spiny
            //> bne ChkEmySpd              ;branch if not found
            if (temp3 == Spiny) {
                //> lda Player_X_Speed         ;if player not moving, skip this part
                temp3 = playerXSpeed
                //> bne SubDifAdj
                if (temp3 == 0) {
                }
            }
            //> ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
            temp3 = enemyYSpeed[X]
            //> bne SubDifAdj              ;branch if nonzero
            if (temp3 == 0) {
                //> ldy #$00                   ;otherwise reinit offset
                temp0 = 0x00
            }
        }
    }
    //> SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
    temp3 = memory[0x1 + temp0].toInt()
    //> ldy $00                    ;get saved horizontal difference
    temp0 = memory[0x0].toInt()
    do {
        //> SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
        //> sbc #$01                   ;from one of three saved values
        temp5 = temp3 - 0x01
        temp3 = temp5 and 0xFF
        //> dey
        temp0 = (temp0 - 1) and 0xFF
        //> bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
    } while ((temp0 and 0x80) == 0)
}

// Decompiled from BridgeCollapse
fun bridgeCollapse() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFeetCounter by MemoryByte(BowserFeetCounter)
    var bowserfrontOffset by MemoryByte(BowserFront_Offset)
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    var bridgeCollapseOffset by MemoryByte(BridgeCollapseOffset)
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var objectOffset by MemoryByte(ObjectOffset)
    var opermodeTask by MemoryByte(OperMode_Task)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val bridgeCollapseData by MemoryByteIndexed(BridgeCollapseData)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> BridgeCollapse:
    //> ldx BowserFront_Offset    ;get enemy offset for bowser
    //> lda Enemy_ID,x            ;check enemy object identifier for bowser
    //> cmp #Bowser               ;if not found, branch ahead,
    //> bne SetM2                 ;metatile removal not necessary
    if (!(enemyId[bowserfrontOffset] - Bowser == 0)) {
        //  goto SetM2
        return
    }
    temp0 = enemyId[bowserfrontOffset]
    temp1 = bowserfrontOffset
    if (enemyId[bowserfrontOffset] == Bowser) {
        //> stx ObjectOffset          ;store as enemy offset here
        objectOffset = temp1
        //> lda Enemy_State,x         ;if bowser in normal state, skip all of this
        temp0 = enemyState[temp1]
        //> beq RemoveBridge
        if (temp0 != 0) {
            //> and #%01000000            ;if bowser's state has d6 clear, skip to silence music
            temp2 = temp0 and 0x40
            //> beq SetM2
            if (temp2 == 0) {
                //  goto SetM2
                return
            }
            temp0 = temp2
            if (temp2 != 0) {
                //> lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
                temp0 = enemyYPosition[temp1]
                //> cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
                //> bcc MoveD_Bowser
                if (!(temp0 >= 0xE0)) {
                    //  goto MoveD_Bowser
                    return
                }
                if (temp0 >= 0xE0) {
                }
            }
        }
    }
    //> SetM2: lda #Silence              ;silence music
    temp0 = Silence
    //> sta EventMusicQueue
    eventMusicQueue = temp0
    //> inc OperMode_Task         ;move onto next secondary mode in autoctrl mode
    opermodeTask = (opermodeTask + 1) and 0xFF
    //> jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
    //> MoveD_Bowser:
    //> jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
    moveEnemySlowVert()
    //> jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
    //> RemoveBridge:
    //> dec BowserFeetCounter     ;decrement timer to control bowser's feet
    bowserFeetCounter = (bowserFeetCounter - 1) and 0xFF
    //> bne NoBFall               ;if not expired, skip all of this
    if (!(bowserFeetCounter == 0)) {
        //  goto NoBFall
        return
    }
    if (bowserFeetCounter == 0) {
        //> lda #$04
        temp0 = 0x04
        //> sta BowserFeetCounter     ;otherwise, set timer now
        bowserFeetCounter = temp0
        //> lda BowserBodyControls
        temp0 = bowserBodyControls
        //> eor #$01                  ;invert bit to control bowser's feet
        temp3 = temp0 xor 0x01
        //> sta BowserBodyControls
        bowserBodyControls = temp3
        //> lda #$22                  ;put high byte of name table address here for now
        temp0 = 0x22
        //> sta $05
        memory[0x5] = temp0.toUByte()
        //> ldy BridgeCollapseOffset  ;get bridge collapse offset here
        //> lda BridgeCollapseData,y  ;load low byte of name table address and store here
        temp0 = bridgeCollapseData[bridgeCollapseOffset]
        //> sta $04
        memory[0x4] = temp0.toUByte()
        //> ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
        //> iny
        vramBuffer1Offset = (vramBuffer1Offset + 1) and 0xFF
        //> ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
        temp1 = 0x0C
        //> jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
        remBridge(temp1, vramBuffer1Offset)
        //> ldx ObjectOffset          ;get enemy offset
        temp1 = objectOffset
        //> jsr MoveVOffset           ;set new vram buffer offset
        moveVOffset(vramBuffer1Offset)
        //> lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
        temp0 = Sfx_Blast
        //> sta Square2SoundQueue     ;queue while at the same time loading the brick
        square2SoundQueue = temp0
        //> lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
        temp0 = Sfx_BrickShatter
        //> sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
        noiseSoundQueue = temp0
        //> inc BridgeCollapseOffset  ;increment bridge collapse offset
        bridgeCollapseOffset = (bridgeCollapseOffset + 1) and 0xFF
        //> lda BridgeCollapseOffset
        temp0 = bridgeCollapseOffset
        //> cmp #$0f                  ;if bridge collapse offset has not yet reached
        //> bne NoBFall               ;the end, go ahead and skip this part
        if (!(temp0 - 0x0F == 0)) {
            //  goto NoBFall
            return
        }
        temp4 = vramBuffer1Offset
        if (temp0 == 0x0F) {
            //> jsr InitVStf              ;initialize whatever vertical speed bowser has
            initVStf(temp1)
            //> lda #%01000000
            temp0 = 0x40
            //> sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
            enemyState[temp1] = temp0
            //> lda #Sfx_BowserFall
            temp0 = Sfx_BowserFall
            //> sta Square2SoundQueue     ;play bowser defeat sound
            square2SoundQueue = temp0
        }
    }
    //> NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
    //> BowserGfxHandler:
    //> jsr ProcessBowserHalf    ;do a sub here to process bowser's front
    processBowserHalf(temp1)
    //> ldy #$10                 ;load default value here to position bowser's rear
    temp4 = 0x10
    //> lda Enemy_MovingDir,x    ;check moving direction
    temp0 = enemyMovingdir[temp1]
    //> lsr
    temp0 = temp0 shr 1
    //> bcc CopyFToR             ;if moving left, use default
    if ((temp0 and 0x01) != 0) {
        //> ldy #$f0                 ;otherwise load alternate positioning value here
        temp4 = 0xF0
    }
    //> CopyFToR: tya                      ;move bowser's rear object position value to A
    //> clc
    //> adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
    temp5 = temp4 + enemyXPosition[temp1]
    temp0 = temp5 and 0xFF
    //> ldy DuplicateObj_Offset  ;get bowser's rear object offset
    temp4 = duplicateobjOffset
    //> sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
    enemyXPosition[temp4] = temp0
    //> lda Enemy_Y_Position,x
    temp0 = enemyYPosition[temp1]
    //> clc                      ;add eight pixels to bowser's front object
    //> adc #$08                 ;vertical coordinate and store as vertical coordinate
    temp6 = temp0 + 0x08
    temp0 = temp6 and 0xFF
    //> sta Enemy_Y_Position,y   ;for bowser's rear
    enemyYPosition[temp4] = temp0
    //> lda Enemy_State,x
    temp0 = enemyState[temp1]
    //> sta Enemy_State,y        ;copy enemy state directly from front to rear
    enemyState[temp4] = temp0
    //> lda Enemy_MovingDir,x
    temp0 = enemyMovingdir[temp1]
    //> sta Enemy_MovingDir,y    ;copy moving direction also
    enemyMovingdir[temp4] = temp0
    //> lda ObjectOffset         ;save enemy object offset of front to stack
    temp0 = objectOffset
    //> pha
    push(temp0)
    //> ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
    temp1 = duplicateobjOffset
    //> stx ObjectOffset
    objectOffset = temp1
    //> lda #Bowser              ;set bowser's enemy identifier
    temp0 = Bowser
    //> sta Enemy_ID,x           ;store in bowser's rear object
    enemyId[temp1] = temp0
    //> jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
    processBowserHalf(temp1)
    //> pla
    temp0 = pull()
    //> sta ObjectOffset         ;get original enemy object offset
    objectOffset = temp0
    //> tax
    //> lda #$00                 ;nullify bowser's front/rear graphics flag
    temp0 = 0x00
    //> sta BowserGfxFlag
    bowserGfxFlag = temp0
    //> ExBGfxH:  rts                      ;leave!
    return
}

// Decompiled from RunBowser
fun runBowser(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp16: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserFeetCounter by MemoryByte(BowserFeetCounter)
    var bowserFireBreathTimer by MemoryByte(BowserFireBreathTimer)
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    var bowserMovementSpeed by MemoryByte(BowserMovementSpeed)
    var bowserOrigXPos by MemoryByte(BowserOrigXPos)
    var duplicateobjOffset by MemoryByte(DuplicateObj_Offset)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var frameCounter by MemoryByte(FrameCounter)
    var maxRangeFromOrigin by MemoryByte(MaxRangeFromOrigin)
    var objectOffset by MemoryByte(ObjectOffset)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var timerControl by MemoryByte(TimerControl)
    var worldNumber by MemoryByte(WorldNumber)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val pRandomRange by MemoryByteIndexed(PRandomRange)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> MoveD_Bowser:
    //> jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
    moveEnemySlowVert()
    //> jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
    //> RunBowser:
    //> lda Enemy_State,x       ;if d5 in enemy state is not set
    //> and #%00100000          ;then branch elsewhere to run bowser
    temp0 = enemyState[X] and 0x20
    //> beq BowserControl
    temp1 = temp0
    if (temp0 != 0) {
        //> lda Enemy_Y_Position,x  ;otherwise check vertical position
        temp1 = enemyYPosition[X]
        //> cmp #$e0                ;if above a certain point, branch to move defeated bowser
        //> bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
        if (!(temp1 >= 0xE0)) {
            //  goto MoveD_Bowser
            return
        }
    }
    //> BowserControl:
    //> lda #$00
    temp1 = 0x00
    //> sta EnemyFrenzyBuffer      ;empty frenzy buffer
    enemyFrenzyBuffer = temp1
    //> lda TimerControl           ;if master timer control not set,
    temp1 = timerControl
    //> beq ChkMouth               ;skip jump and execute code here
    if (temp1 != 0) {
    } else {
        //> ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
        temp1 = bowserBodyControls
        //> bpl FeetTmr                ;if bit clear, go ahead with code here
        if ((temp1 and 0x80) != 0) {
        } else {
            //> FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
            bowserFeetCounter = (bowserFeetCounter - 1) and 0xFF
            //> bne ResetMDr               ;if not expired, skip this part
            if (bowserFeetCounter == 0) {
                //> lda #$20                   ;otherwise, reset timer
                temp1 = 0x20
                //> sta BowserFeetCounter
                bowserFeetCounter = temp1
                //> lda BowserBodyControls     ;and invert bit used
                temp1 = bowserBodyControls
                //> eor #%00000001             ;to control bowser's feet
                temp2 = temp1 xor 0x01
                //> sta BowserBodyControls
                bowserBodyControls = temp2
            }
            //> ResetMDr:  lda FrameCounter           ;check frame counter
            temp1 = frameCounter
            //> and #%00001111             ;if not on every sixteenth frame, skip
            temp3 = temp1 and 0x0F
            //> bne B_FaceP                ;ahead to continue code
            temp1 = temp3
            if (temp3 == 0) {
                //> lda #$02                   ;otherwise reset moving/facing direction every
                temp1 = 0x02
                //> sta Enemy_MovingDir,x      ;sixteen frames
                enemyMovingdir[X] = temp1
            }
            //> B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
            temp1 = enemyFrameTimer[X]
            //> beq GetPRCmp               ;branch to next section
            if (temp1 != 0) {
                //> jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
                playerEnemyDiff(X)
                //> bpl GetPRCmp               ;and branch if bowser to the right of the player
                if ((temp1 and 0x80) != 0) {
                    //> lda #$01
                    temp1 = 0x01
                    //> sta Enemy_MovingDir,x      ;set bowser to move and face to the right
                    enemyMovingdir[X] = temp1
                    //> lda #$02
                    temp1 = 0x02
                    //> sta BowserMovementSpeed    ;set movement speed
                    bowserMovementSpeed = temp1
                    //> lda #$20
                    temp1 = 0x20
                    //> sta EnemyFrameTimer,x      ;set timer here
                    enemyFrameTimer[X] = temp1
                    //> sta BowserFireBreathTimer  ;set timer used for bowser's flame
                    bowserFireBreathTimer = temp1
                    //> lda Enemy_X_Position,x
                    temp1 = enemyXPosition[X]
                    //> cmp #$c8                   ;if bowser to the right past a certain point,
                    //> bcs HammerChk              ;skip ahead to some other section
                    if (!(temp1 >= 0xC8)) {
                    }
                }
            }
            //> GetPRCmp:  lda FrameCounter           ;get frame counter
            temp1 = frameCounter
            //> and #%00000011
            temp4 = temp1 and 0x03
            //> bne HammerChk              ;execute this code every fourth frame, otherwise branch
            temp1 = temp4
            if (temp4 == 0) {
                //> lda Enemy_X_Position,x
                temp1 = enemyXPosition[X]
                //> cmp BowserOrigXPos         ;if bowser not at original horizontal position,
                //> bne GetDToO                ;branch to skip this part
                if (temp1 == bowserOrigXPos) {
                    //> lda PseudoRandomBitReg,x
                    temp1 = pseudoRandomBitReg[X]
                    //> and #%00000011             ;get pseudorandom offset
                    temp5 = temp1 and 0x03
                    //> tay
                    //> lda PRandomRange,y         ;load value using pseudorandom offset
                    temp1 = pRandomRange[temp5]
                    //> sta MaxRangeFromOrigin     ;and store here
                    maxRangeFromOrigin = temp1
                }
                //> GetDToO:   lda Enemy_X_Position,x
                temp1 = enemyXPosition[X]
                //> clc                        ;add movement speed to bowser's horizontal
                //> adc BowserMovementSpeed    ;coordinate and save as new horizontal position
                temp6 = temp1 + bowserMovementSpeed
                temp1 = temp6 and 0xFF
                //> sta Enemy_X_Position,x
                enemyXPosition[X] = temp1
                //> ldy Enemy_MovingDir,x
                //> cpy #$01                   ;if bowser moving and facing to the right, skip ahead
                //> beq HammerChk
                temp7 = enemyMovingdir[X]
                if (enemyMovingdir[X] != 0x01) {
                    //> ldy #$ff                   ;set default movement speed here (move left)
                    temp7 = 0xFF
                    //> sec                        ;get difference of current vs. original
                    //> sbc BowserOrigXPos         ;horizontal position
                    temp8 = temp1 - bowserOrigXPos
                    temp1 = temp8 and 0xFF
                    //> bpl CompDToO               ;if current position to the right of original, skip ahead
                    if ((temp8 and 0xFF and 0x80) != 0) {
                        //> eor #$ff
                        temp9 = temp1 xor 0xFF
                        //> clc                        ;get two's compliment
                        //> adc #$01
                        temp10 = temp9 + 0x01
                        temp1 = temp10 and 0xFF
                        //> ldy #$01                   ;set alternate movement speed here (move right)
                        temp7 = 0x01
                    }
                    //> CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
                    //> bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
                    if (temp1 >= maxRangeFromOrigin) {
                        //> sty BowserMovementSpeed    ;otherwise change bowser's movement speed
                        bowserMovementSpeed = temp7
                    }
                }
            }
        }
        //> HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
        temp1 = enemyFrameTimer[X]
        //> bne MakeBJump              ;some other section of code
        if (temp1 == 0) {
            //> jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
            moveEnemySlowVert()
            //> lda WorldNumber            ;check world number
            temp1 = worldNumber
            //> cmp #World6
            //> bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
            if (temp1 >= World6) {
                //> lda FrameCounter
                temp1 = frameCounter
                //> and #%00000011             ;check to see if it's time to execute sub
                temp11 = temp1 and 0x03
                //> bne SetHmrTmr              ;if not, skip sub, otherwise
                temp1 = temp11
                if (temp11 == 0) {
                    //> jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn misc object (hammer)
                    spawnHammerObj()
                }
            }
            //> SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
            temp1 = enemyYPosition[X]
            //> cmp #$80                   ;if still above a certain point
            //> bcc ChkFireB               ;then skip to world number check for flames
            if (temp1 >= 0x80) {
                //> lda PseudoRandomBitReg,x
                temp1 = pseudoRandomBitReg[X]
                //> and #%00000011             ;get pseudorandom offset
                temp12 = temp1 and 0x03
                //> tay
                //> lda PRandomRange,y         ;get value using pseudorandom offset
                temp1 = pRandomRange[temp12]
                //> sta EnemyFrameTimer,x      ;set for timer here
                enemyFrameTimer[X] = temp1
            }
        }
    }
    //> SkipToFB:  jmp ChkFireB               ;jump to execute flames code
    //> MakeBJump: cmp #$01                   ;if timer not yet about to expire,
    //> bne ChkFireB               ;skip ahead to next part
    if (temp1 == 0x01) {
        //> dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
        enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
        //> jsr InitVStf               ;initialize movement amount
        initVStf(X)
        //> lda #$fe
        temp1 = 0xFE
        //> sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
        enemyYSpeed[X] = temp1
    }
    do {
        //> ChkFireB:  lda WorldNumber            ;check world number here
        temp1 = worldNumber
        //> cmp #World8                ;world 8?
        //> beq SpawnFBr               ;if so, execute this part here
        if (temp1 != World8) {
            //> cmp #World6                ;world 6-7?
            //> bcs BowserGfxHandler       ;if so, skip this part here
            if (temp1 >= World6) {
                //  goto BowserGfxHandler
                return
            }
            if (!(temp1 >= World6)) {
            }
        }
        //> SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
        temp1 = bowserFireBreathTimer
        //> bne BowserGfxHandler       ;if not expired yet, skip all of this
        if (!(temp1 == 0)) {
            //  goto BowserGfxHandler
            return
        }
        if (temp1 == 0) {
            //> lda #$20
            temp1 = 0x20
            //> sta BowserFireBreathTimer  ;set timer here
            bowserFireBreathTimer = temp1
            //> lda BowserBodyControls
            temp1 = bowserBodyControls
            //> eor #%10000000             ;invert bowser's mouth bit to open
            temp13 = temp1 xor 0x80
            //> sta BowserBodyControls     ;and close bowser's mouth
            bowserBodyControls = temp13
            //> bmi ChkFireB               ;if bowser's mouth open, loop back
        }
    } while (flagN)
    //> jsr SetFlameTimer          ;get timing for bowser's flame
    setFlameTimer()
    //> ldy SecondaryHardMode
    temp7 = secondaryHardMode
    //> beq SetFBTmr               ;if secondary hard mode flag not set, skip this
    if (temp7 != 0) {
        //> sec
        //> sbc #$10                   ;otherwise subtract from value in A
        temp14 = temp1 - 0x10
        temp1 = temp14 and 0xFF
    }
    //> SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
    bowserFireBreathTimer = temp1
    //> lda #BowserFlame           ;put bowser's flame identifier
    temp1 = BowserFlame
    //> sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
    enemyFrenzyBuffer = temp1
    //> ;--------------------------------
    //> BowserGfxHandler:
    //> jsr ProcessBowserHalf    ;do a sub here to process bowser's front
    processBowserHalf(X)
    //> ldy #$10                 ;load default value here to position bowser's rear
    temp7 = 0x10
    //> lda Enemy_MovingDir,x    ;check moving direction
    temp1 = enemyMovingdir[X]
    //> lsr
    temp1 = temp1 shr 1
    //> bcc CopyFToR             ;if moving left, use default
    if ((temp1 and 0x01) != 0) {
        //> ldy #$f0                 ;otherwise load alternate positioning value here
        temp7 = 0xF0
    }
    //> CopyFToR: tya                      ;move bowser's rear object position value to A
    //> clc
    //> adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
    temp15 = temp7 + enemyXPosition[X]
    temp1 = temp15 and 0xFF
    //> ldy DuplicateObj_Offset  ;get bowser's rear object offset
    temp7 = duplicateobjOffset
    //> sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
    enemyXPosition[temp7] = temp1
    //> lda Enemy_Y_Position,x
    temp1 = enemyYPosition[X]
    //> clc                      ;add eight pixels to bowser's front object
    //> adc #$08                 ;vertical coordinate and store as vertical coordinate
    temp16 = temp1 + 0x08
    temp1 = temp16 and 0xFF
    //> sta Enemy_Y_Position,y   ;for bowser's rear
    enemyYPosition[temp7] = temp1
    //> lda Enemy_State,x
    temp1 = enemyState[X]
    //> sta Enemy_State,y        ;copy enemy state directly from front to rear
    enemyState[temp7] = temp1
    //> lda Enemy_MovingDir,x
    temp1 = enemyMovingdir[X]
    //> sta Enemy_MovingDir,y    ;copy moving direction also
    enemyMovingdir[temp7] = temp1
    //> lda ObjectOffset         ;save enemy object offset of front to stack
    temp1 = objectOffset
    //> pha
    push(temp1)
    //> ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
    //> stx ObjectOffset
    objectOffset = duplicateobjOffset
    //> lda #Bowser              ;set bowser's enemy identifier
    temp1 = Bowser
    //> sta Enemy_ID,x           ;store in bowser's rear object
    enemyId[duplicateobjOffset] = temp1
    //> jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
    processBowserHalf(duplicateobjOffset)
    //> pla
    temp1 = pull()
    //> sta ObjectOffset         ;get original enemy object offset
    objectOffset = temp1
    //> tax
    //> lda #$00                 ;nullify bowser's front/rear graphics flag
    temp1 = 0x00
    //> sta BowserGfxFlag
    bowserGfxFlag = temp1
    //> ExBGfxH:  rts                      ;leave!
    return
}

// Decompiled from KillAllEnemies
fun killAllEnemies(A: Int) {
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var objectOffset by MemoryByte(ObjectOffset)
    //> KillAllEnemies:
    //> ldx #$04              ;start with last enemy slot
    temp0 = 0x04
    do {
        //> KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
        eraseEnemyObject(temp0)
        //> dex                   ;move onto next enemy slot
        temp0 = (temp0 - 1) and 0xFF
        //> bpl KillLoop          ;do this until all slots are emptied
    } while ((temp0 and 0x80) == 0)
    //> sta EnemyFrenzyBuffer ;empty frenzy buffer
    enemyFrenzyBuffer = A
    //> ldx ObjectOffset      ;get enemy object offset and leave
    temp0 = objectOffset
    //> rts
    return
}

// Decompiled from ProcessBowserHalf
fun processBowserHalf(X: Int) {
    val enemyBoundboxctrl by MemoryByteIndexed(Enemy_BoundBoxCtrl)
    val enemyState by MemoryByteIndexed(Enemy_State)
    //> ExBGfxH:  rts                      ;leave!
    return
}

// Decompiled from SetFlameTimer
fun setFlameTimer(): Int {
    var temp0: Int = 0
    var bowserFlameTimerCtrl by MemoryByte(BowserFlameTimerCtrl)
    val flameTimerData by MemoryByteIndexed(FlameTimerData)
    //> SetFlameTimer:
    //> ldy BowserFlameTimerCtrl  ;load counter as offset
    //> inc BowserFlameTimerCtrl  ;increment
    bowserFlameTimerCtrl = (bowserFlameTimerCtrl + 1) and 0xFF
    //> lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
    //> and #%00000111            ;to keep in range of 0-7
    temp0 = bowserFlameTimerCtrl and 0x07
    //> sta BowserFlameTimerCtrl
    bowserFlameTimerCtrl = temp0
    //> lda FlameTimerData,y      ;load value to be used then leave
    //> ExFl: rts
    return A
}

// Decompiled from ProcBowserFlame
fun procBowserFlame(X: Int) {
    val bowserFlamePRandomOfs by MemoryByteIndexed(BowserFlamePRandomOfs)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXMoveforce by MemoryByteIndexed(Enemy_X_MoveForce)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flameYPosData by MemoryByteIndexed(FlameYPosData)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> ExFl: rts
    return
}

// Decompiled from RunFireworks
fun runFireworks(X: Int) {
    var temp0: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var fireballRelXpos by MemoryByte(Fireball_Rel_XPos)
    var fireballRelYpos by MemoryByte(Fireball_Rel_YPos)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val explosionGfxCounter by MemoryByteIndexed(ExplosionGfxCounter)
    val explosionTimerCounter by MemoryByteIndexed(ExplosionTimerCounter)
    //> RunFireworks:
    //> dec ExplosionTimerCounter,x ;decrement explosion timing counter here
    explosionTimerCounter[X] = (explosionTimerCounter[X] - 1) and 0xFF
    //> bne SetupExpl               ;if not expired, skip this part
    if (explosionTimerCounter[X] == 0) {
        //> lda #$08
        //> sta ExplosionTimerCounter,x ;reset counter
        explosionTimerCounter[X] = 0x08
        //> inc ExplosionGfxCounter,x   ;increment explosion graphics counter
        explosionGfxCounter[X] = (explosionGfxCounter[X] + 1) and 0xFF
        //> lda ExplosionGfxCounter,x
        //> cmp #$03                    ;check explosion graphics counter
        //> bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
        if (explosionGfxCounter[X] >= 0x03) {
            //  goto FireworksSoundScore
            return
        }
        temp0 = explosionGfxCounter[X]
        if (!(explosionGfxCounter[X] >= 0x03)) {
        }
    }
    //> SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
    relativeEnemyPosition()
    //> lda Enemy_Rel_YPos          ;copy relative coordinates
    temp0 = enemyRelYpos
    //> sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
    fireballRelYpos = temp0
    //> lda Enemy_Rel_XPos          ;first vertical, then horizontal
    temp0 = enemyRelXpos
    //> sta Fireball_Rel_XPos
    fireballRelXpos = temp0
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    //> lda ExplosionGfxCounter,x   ;get explosion graphics counter
    temp0 = explosionGfxCounter[X]
    //> jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
    drawexplosionFireworks(temp0, enemySprdataoffset[X])
    //> rts
    return
}

// Decompiled from RunStarFlagObj
fun runStarFlagObj() {
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    //> RunStarFlagObj:
    //> lda #$00                 ;initialize enemy frenzy buffer
    //> sta EnemyFrenzyBuffer
    enemyFrenzyBuffer = 0x00
    //> lda StarFlagTaskControl  ;check star flag object task number here
    //> cmp #$05                 ;if greater than 5, branch to exit
    //> bcs StarFlagExit
    if (starFlagTaskControl >= 0x05) {
        //  goto StarFlagExit
        return
    } else {
        //> jsr JumpEngine           ;otherwise jump to appropriate sub
        when (starFlagTaskControl) {
            0 -> {
                starFlagExit()
            }
            1 -> {
                gameTimerFireworks(X)
            }
            2 -> {
                awardGameTimerPoints()
            }
            3 -> {
                raiseFlagSetoffFWorks(X)
            }
            4 -> {
                delayToAreaEnd(X)
            }
            else -> {
                // Unknown JumpEngine index
            }
        }
        return
    }
}

// Decompiled from GameTimerFireworks
fun gameTimerFireworks(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var fireworksCounter by MemoryByte(FireworksCounter)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    //> GameTimerFireworks:
    //> ldy #$05               ;set default state for star flag object
    //> lda GameTimerDisplay+2 ;get game timer's last digit
    //> cmp #$01
    //> beq SetFWC             ;if last digit of game timer set to 1, skip ahead
    temp0 = gameTimerDisplay[2]
    temp1 = 0x05
    if (gameTimerDisplay[2] != 0x01) {
        //> ldy #$03               ;otherwise load new value for state
        temp1 = 0x03
        //> cmp #$03
        //> beq SetFWC             ;if last digit of game timer set to 3, skip ahead
        if (temp0 != 0x03) {
            //> ldy #$00               ;otherwise load one more potential value for state
            temp1 = 0x00
            //> cmp #$06
            //> beq SetFWC             ;if last digit of game timer set to 6, skip ahead
            if (temp0 != 0x06) {
                //> lda #$ff               ;otherwise set value for no fireworks
                temp0 = 0xFF
            }
        }
    }
    //> SetFWC: sta FireworksCounter   ;set fireworks counter here
    fireworksCounter = temp0
    //> sty Enemy_State,x      ;set whatever state we have in star flag object
    enemyState[X] = temp1
    //> IncrementSFTask1:
    //> inc StarFlagTaskControl  ;increment star flag object task number
    starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
    // Fall-through tail call to awardGameTimerPoints
    awardGameTimerPoints()
}

// Decompiled from StarFlagExit
fun starFlagExit() {
    //> StarFlagExit:
    //> rts                      ;leave
    return
}

// Decompiled from AwardGameTimerPoints
fun awardGameTimerPoints() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var currentPlayer by MemoryByte(CurrentPlayer)
    var frameCounter by MemoryByte(FrameCounter)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    val digitModifier by MemoryByteIndexed(DigitModifier)
    val gameTimerDisplay by MemoryByteIndexed(GameTimerDisplay)
    //> IncrementSFTask1:
    //> inc StarFlagTaskControl  ;increment star flag object task number
    starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
    do {
        //> AwardGameTimerPoints:
        //> lda GameTimerDisplay   ;check all game timer digits for any intervals left
        //> ora GameTimerDisplay+1
        temp0 = gameTimerDisplay[0] or gameTimerDisplay[1]
        //> ora GameTimerDisplay+2
        temp1 = temp0 or gameTimerDisplay[2]
        //> beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
    } while (temp1 == 0)
    //> lda FrameCounter
    //> and #%00000100         ;check frame counter for d2 set (skip ahead
    temp2 = frameCounter and 0x04
    //> beq NoTTick            ;for four frames every four frames) branch if not set
    temp3 = temp2
    if (temp2 != 0) {
        //> lda #Sfx_TimerTick
        temp3 = Sfx_TimerTick
        //> sta Square2SoundQueue  ;load timer tick sound
        square2SoundQueue = temp3
    }
    //> NoTTick: ldy #$23               ;set offset here to subtract from game timer's last digit
    //> lda #$ff               ;set adder here to $ff, or -1, to subtract one
    temp3 = 0xFF
    //> sta DigitModifier+5    ;from the last digit of the game timer
    digitModifier[5] = temp3
    //> jsr DigitsMathRoutine  ;subtract digit
    digitsMathRoutine(0x23)
    //> lda #$05               ;set now to add 50 points
    temp3 = 0x05
    //> sta DigitModifier+5    ;per game timer interval subtracted
    digitModifier[5] = temp3
    //> EndAreaPoints:
    //> ldy #$0b               ;load offset for mario's score by default
    //> lda CurrentPlayer      ;check player on the screen
    temp3 = currentPlayer
    //> beq ELPGive            ;if mario, do not change
    if (temp3 == 0) {
        //  goto ELPGive
        return
    }
    temp4 = 0x0B
    if (temp3 != 0) {
        //> ldy #$11               ;otherwise load offset for luigi's score
        temp4 = 0x11
    }
    //> ELPGive: jsr DigitsMathRoutine  ;award 50 points per game timer interval
    digitsMathRoutine(temp4)
    //> lda CurrentPlayer      ;get player on the screen (or 500 points per
    temp3 = currentPlayer
    //> asl                    ;fireworks explosion if branched here from there)
    temp3 = (temp3 shl 1) and 0xFF
    //> asl                    ;shift to high nybble
    temp3 = (temp3 shl 1) and 0xFF
    //> asl
    temp3 = (temp3 shl 1) and 0xFF
    //> asl
    temp3 = (temp3 shl 1) and 0xFF
    //> ora #%00000100         ;add four to set nybble for game timer
    temp5 = temp3 or 0x04
    //> jmp UpdateNumber       ;jump to print the new score and game timer
    // Fall-through tail call to starFlagExit
    starFlagExit()
}

// Decompiled from RaiseFlagSetoffFWorks
fun raiseFlagSetoffFWorks(X: Int) {
    var temp0: Int = 0
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var fireworksCounter by MemoryByte(FireworksCounter)
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> RaiseFlagSetoffFWorks:
    //> lda Enemy_Y_Position,x  ;check star flag's vertical position
    //> cmp #$72                ;against preset value
    //> bcc SetoffF             ;if star flag higher vertically, branch to other code
    temp0 = enemyYPosition[X]
    if (enemyYPosition[X] >= 0x72) {
        //> dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
        enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
        //> jmp DrawStarFlag        ;and skip this part here
    }
    //> SetoffF: lda FireworksCounter    ;check fireworks counter
    temp0 = fireworksCounter
    //> beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
    if (temp0 != 0) {
        //> bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
        if ((temp0 and 0x80) == 0) {
            //> lda #Fireworks
            temp0 = Fireworks
            //> sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
            enemyFrenzyBuffer = temp0
        }
    }
    //> DrawFlagSetTimer:
    //> jsr DrawStarFlag          ;do sub to draw star flag
    drawStarFlag(X)
    //> lda #$06
    temp0 = 0x06
    //> sta EnemyIntervalTimer,x  ;set interval timer here
    enemyIntervalTimer[X] = temp0
    //> IncrementSFTask2:
    //> inc StarFlagTaskControl   ;move onto next task
    starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
    //> rts
    return
}

// Decompiled from DrawStarFlag
fun drawStarFlag(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    val starFlagTileData by MemoryByteIndexed(StarFlagTileData)
    val starFlagXPosAdder by MemoryByteIndexed(StarFlagXPosAdder)
    val starFlagYPosAdder by MemoryByteIndexed(StarFlagYPosAdder)
    //> DrawStarFlag:
    //> jsr RelativeEnemyPosition  ;get relative coordinates of star flag
    relativeEnemyPosition()
    //> ldy Enemy_SprDataOffset,x  ;get OAM data offset
    //> ldx #$03                   ;do four sprites
    temp0 = 0x03
    temp1 = enemySprdataoffset[X]
    do {
        //> DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
        //> clc
        //> adc StarFlagYPosAdder,x    ;add Y coordinate adder data
        temp2 = enemyRelYpos + starFlagYPosAdder[temp0]
        //> sta Sprite_Y_Position,y    ;store as Y coordinate
        spriteYPosition[temp1] = temp2 and 0xFF
        //> lda StarFlagTileData,x     ;get tile number
        //> sta Sprite_Tilenumber,y    ;store as tile number
        spriteTilenumber[temp1] = starFlagTileData[temp0]
        //> lda #$22                   ;set palette and background priority bits
        //> sta Sprite_Attributes,y    ;store as attributes
        spriteAttributes[temp1] = 0x22
        //> lda Enemy_Rel_XPos         ;get relative horizontal coordinate
        //> clc
        //> adc StarFlagXPosAdder,x    ;add X coordinate adder data
        temp3 = enemyRelXpos + starFlagXPosAdder[temp0]
        //> sta Sprite_X_Position,y    ;store as X coordinate
        spriteXPosition[temp1] = temp3 and 0xFF
        //> iny
        temp1 = (temp1 + 1) and 0xFF
        //> iny                        ;increment OAM data offset four bytes
        temp1 = (temp1 + 1) and 0xFF
        //> iny                        ;for next sprite
        temp1 = (temp1 + 1) and 0xFF
        //> iny
        temp1 = (temp1 + 1) and 0xFF
        //> dex                        ;move onto next sprite
        temp0 = (temp0 - 1) and 0xFF
        //> bpl DSFLoop                ;do this until all sprites are done
    } while ((temp0 and 0x80) == 0)
    //> ldx ObjectOffset           ;get enemy object offset and leave
    temp0 = objectOffset
    //> rts
    return
}

// Decompiled from DelayToAreaEnd
fun delayToAreaEnd(X: Int) {
    var starFlagTaskControl by MemoryByte(StarFlagTaskControl)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    //> IncrementSFTask2:
    //> inc StarFlagTaskControl   ;move onto next task
    starFlagTaskControl = (starFlagTaskControl + 1) and 0xFF
    //> rts
    return
}

// Decompiled from MovePiranhaPlant
fun movePiranhaPlant(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var timerControl by MemoryByte(TimerControl)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val piranhaPlantDownYPos by MemoryByteIndexed(PiranhaPlantDownYPos)
    val piranhaPlantUpYPos by MemoryByteIndexed(PiranhaPlantUpYPos)
    val piranhaplantMoveflag by MemoryByteIndexed(PiranhaPlant_MoveFlag)
    val piranhaplantYSpeed by MemoryByteIndexed(PiranhaPlant_Y_Speed)
    //> MovePiranhaPlant:
    //> lda Enemy_State,x           ;check enemy state
    //> bne PutinPipe               ;if set at all, branch to leave
    temp0 = enemyState[X]
    if (enemyState[X] == 0) {
        //> lda EnemyFrameTimer,x       ;check enemy's timer here
        temp0 = enemyFrameTimer[X]
        //> bne PutinPipe               ;branch to end if not yet expired
        if (temp0 == 0) {
            //> lda PiranhaPlant_MoveFlag,x ;check movement flag
            temp0 = piranhaplantMoveflag[X]
            //> bne SetupToMovePPlant       ;if moving, skip to part ahead
            if (temp0 == 0) {
                //> lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
                temp0 = piranhaplantYSpeed[X]
                //> bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
                if ((temp0 and 0x80) == 0) {
                    //> jsr PlayerEnemyDiff         ;get horizontal difference between player and
                    playerEnemyDiff(X)
                    //> bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
                    if ((temp0 and 0x80) != 0) {
                        //> lda $00                     ;otherwise get saved horizontal difference
                        temp0 = memory[0x0].toInt()
                        //> eor #$ff
                        temp1 = temp0 xor 0xFF
                        //> clc                         ;and change to two's compliment
                        //> adc #$01
                        temp2 = temp1 + 0x01
                        temp0 = temp2 and 0xFF
                        //> sta $00                     ;save as new horizontal difference
                        memory[0x0] = temp0.toUByte()
                    }
                    //> ChkPlayerNearPipe:
                    //> lda $00                     ;get saved horizontal difference
                    temp0 = memory[0x0].toInt()
                    //> cmp #$21
                    //> bcc PutinPipe               ;if player within a certain distance, branch to leave
                    if (temp0 >= 0x21) {
                    } else {
                        //> PutinPipe:
                        //> lda #%00100000              ;set background priority bit in sprite
                        temp0 = 0x20
                        //> sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
                        enemySprattrib[X] = temp0
                        //> rts                         ;then leave
                        return
                    }
                }
                //> ReversePlantSpeed:
                //> lda PiranhaPlant_Y_Speed,x  ;get vertical speed
                temp0 = piranhaplantYSpeed[X]
                //> eor #$ff
                temp3 = temp0 xor 0xFF
                //> clc                         ;change to two's compliment
                //> adc #$01
                temp4 = temp3 + 0x01
                temp0 = temp4 and 0xFF
                //> sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
                piranhaplantYSpeed[X] = temp0
                //> inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
                piranhaplantMoveflag[X] = (piranhaplantMoveflag[X] + 1) and 0xFF
            }
            //> SetupToMovePPlant:
            //> lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
            temp0 = piranhaPlantDownYPos[X]
            //> ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
            //> bpl RiseFallPiranhaPlant    ;branch if moving downwards
            temp5 = piranhaplantYSpeed[X]
            if ((piranhaplantYSpeed[X] and 0x80) != 0) {
                //> lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
                temp0 = piranhaPlantUpYPos[X]
            }
            //> RiseFallPiranhaPlant:
            //> sta $00                     ;save vertical coordinate here
            memory[0x0] = temp0.toUByte()
            //> lda FrameCounter            ;get frame counter
            temp0 = frameCounter
            //> lsr
            temp0 = temp0 shr 1
            //> bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
            if ((temp0 and 0x01) != 0) {
                //> lda TimerControl            ;get master timer control
                temp0 = timerControl
                //> bne PutinPipe               ;branch to leave if set (likely not necessary)
                if (temp0 == 0) {
                    //> lda Enemy_Y_Position,x      ;get current vertical coordinate
                    temp0 = enemyYPosition[X]
                    //> clc
                    //> adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
                    temp6 = temp0 + piranhaplantYSpeed[X]
                    temp0 = temp6 and 0xFF
                    //> sta Enemy_Y_Position,x      ;save as new vertical coordinate
                    enemyYPosition[X] = temp0
                    //> cmp $00                     ;compare against low or high coordinate
                    //> bne PutinPipe               ;branch to leave if not yet reached
                    if (temp0 == memory[0x0].toInt()) {
                        //> lda #$00
                        temp0 = 0x00
                        //> sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
                        piranhaplantMoveflag[X] = temp0
                        //> lda #$40
                        temp0 = 0x40
                        //> sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
                        enemyFrameTimer[X] = temp0
                    }
                }
            }
        }
    }
}

// Decompiled from FirebarSpin
fun firebarSpin(A: Int, X: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    val firebarSpinDirection by MemoryByteIndexed(FirebarSpinDirection)
    val firebarspinstateHigh by MemoryByteIndexed(FirebarSpinState_High)
    val firebarspinstateLow by MemoryByteIndexed(FirebarSpinState_Low)
    //> FirebarSpin:
    //> sta $07                     ;save spinning speed here
    memory[0x7] = A.toUByte()
    //> lda FirebarSpinDirection,x  ;check spinning direction
    //> bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
    temp0 = firebarSpinDirection[X]
    if (firebarSpinDirection[X] == 0) {
        //> ldy #$18                    ;possibly residual ldy
        //> lda FirebarSpinState_Low,x
        temp0 = firebarspinstateLow[X]
        //> clc                         ;add spinning speed to what would normally be
        //> adc $07                     ;the horizontal speed
        temp1 = temp0 + memory[0x7].toInt()
        temp0 = temp1 and 0xFF
        //> sta FirebarSpinState_Low,x
        firebarspinstateLow[X] = temp0
        //> lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
        temp0 = firebarspinstateHigh[X]
        //> adc #$00
        temp2 = temp0 + (if (temp1 > 0xFF) 1 else 0)
        temp0 = temp2 and 0xFF
        //> rts
        return A
    } else {
        //> SpinCounterClockwise:
        //> ldy #$08                    ;possibly residual ldy
        //> lda FirebarSpinState_Low,x
        temp0 = firebarspinstateLow[X]
        //> sec                         ;subtract spinning speed to what would normally be
        //> sbc $07                     ;the horizontal speed
        temp3 = temp0 - memory[0x7].toInt()
        temp0 = temp3 and 0xFF
        //> sta FirebarSpinState_Low,x
        firebarspinstateLow[X] = temp0
        //> lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
        temp0 = firebarspinstateHigh[X]
        //> sbc #$00
        temp4 = temp0 - (if (temp3 >= 0) 0 else 1)
        temp0 = temp4 and 0xFF
        //> rts
        return A
    }
    return A
}

// Decompiled from BalancePlatform
fun balancePlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var playerRelXpos by MemoryByte(Player_Rel_XPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val floateynumXPos by MemoryByteIndexed(FloateyNum_X_Pos)
    val floateynumYPos by MemoryByteIndexed(FloateyNum_Y_Pos)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    val vramBuffer1 by MemoryByteIndexed(VRAM_Buffer1)
    //> BalancePlatform:
    //> lda Enemy_Y_HighPos,x       ;check high byte of vertical position
    //> cmp #$03
    //> bne DoBPl
    temp0 = enemyYHighpos[X]
    if (enemyYHighpos[X] == 0x03) {
        //> jmp EraseEnemyObject        ;if far below screen, kill the object
    }
    //> DoBPl: lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
    temp0 = enemyState[X]
    //> bpl CheckBalPlatform        ;if doing other balance platform, branch to leave
    if ((temp0 and 0x80) != 0) {
        //> rts
        return
    } else {
        //> CheckBalPlatform:
        //> tay                         ;save offset from state as Y
        //> lda PlatformCollisionFlag,x ;get collision flag of platform
        temp0 = platformCollisionFlag[X]
        //> sta $00                     ;store here
        memory[0x0] = temp0.toUByte()
        //> lda Enemy_MovingDir,x       ;get moving direction
        temp0 = enemyMovingdir[X]
        //> beq ChkForFall
        temp1 = temp0
        if (temp0 != 0) {
        } else {
            //> ChkForFall:
            //> lda #$2d                    ;check if platform is above a certain point
            temp0 = 0x2D
            //> cmp Enemy_Y_Position,x
            //> bcc ChkOtherForFall         ;if not, branch elsewhere
            if (temp0 >= enemyYPosition[X]) {
                //> cpy $00                     ;if collision flag is set to same value as
                //> beq MakePlatformFall        ;enemy state, branch to make platforms fall
                if (temp1 == memory[0x0].toInt()) {
                    //  goto MakePlatformFall
                    return
                }
                if (temp1 != memory[0x0].toInt()) {
                    //> clc
                    //> adc #$02                    ;otherwise add 2 pixels to vertical position
                    temp2 = temp0 + 0x02
                    temp0 = temp2 and 0xFF
                    //> sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
                    enemyYPosition[X] = temp0
                    //> jmp StopPlatforms           ;to make platforms stop
                }
            } else {
                //> ChkOtherForFall:
                //> cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
                //> bcc ChkToMoveBalPlat        ;if not, branch elsewhere
                if (temp0 >= enemyYPosition[temp1]) {
                    //> cpx $00                     ;if collision flag is set to same value as
                    //> beq MakePlatformFall        ;enemy state, branch to make platforms fall
                    if (X == memory[0x0].toInt()) {
                        //  goto MakePlatformFall
                        return
                    }
                    //> clc
                    //> adc #$02                    ;otherwise add 2 pixels to vertical position
                    temp3 = temp0 + 0x02
                    temp0 = temp3 and 0xFF
                    //> sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
                    enemyYPosition[temp1] = temp0
                    //> jmp StopPlatforms           ;jump to stop movement and do not return
                }
                //> ChkToMoveBalPlat:
                //> lda Enemy_Y_Position,x      ;save vertical position to stack
                temp0 = enemyYPosition[X]
                //> pha
                push(temp0)
                //> lda PlatformCollisionFlag,x ;get collision flag
                temp0 = platformCollisionFlag[X]
                //> bpl ColFlg                  ;branch if collision
                if ((temp0 and 0x80) != 0) {
                    //> lda Enemy_Y_MoveForce,x
                    temp0 = enemyYMoveforce[X]
                    //> clc                         ;add $05 to contents of moveforce, whatever they be
                    //> adc #$05
                    temp4 = temp0 + 0x05
                    temp0 = temp4 and 0xFF
                    //> sta $00                     ;store here
                    memory[0x0] = temp0.toUByte()
                    //> lda Enemy_Y_Speed,x
                    temp0 = enemyYSpeed[X]
                    //> adc #$00                    ;add carry to vertical speed
                    temp5 = temp0 + (if (temp4 > 0xFF) 1 else 0)
                    temp0 = temp5 and 0xFF
                    //> bmi PlatDn                  ;branch if moving downwards
                    if ((temp5 and 0xFF and 0x80) == 0) {
                        //> bne PlatUp                  ;branch elsewhere if moving upwards
                        if (!((temp5 and 0xFF) == 0)) {
                            //  goto PlatUp
                            return
                        }
                        if ((temp5 and 0xFF) == 0) {
                            //> lda $00
                            temp0 = memory[0x0].toInt()
                            //> cmp #$0b                    ;check if there's still a little force left
                            //> bcc PlatSt                  ;if not enough, branch to stop movement
                            if (!(temp0 >= 0x0B)) {
                                //  goto PlatSt
                                return
                            }
                            if (temp0 >= 0x0B) {
                                //> bcs PlatUp                  ;otherwise keep branch to move upwards
                                if (temp0 >= 0x0B) {
                                    //  goto PlatUp
                                    return
                                }
                                if (!(temp0 >= 0x0B)) {
                                }
                            }
                        }
                    }
                }
                //> ColFlg: cmp ObjectOffset            ;if collision flag matches
                //> beq PlatDn                  ;current enemy object offset, branch
                if (temp0 != objectOffset) {
                    //> PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
                    movePlatformUp(X)
                    //> jmp DoOtherPlatform         ;jump ahead to remaining code
                    //> PlatSt: jsr StopPlatforms           ;do a sub to stop movement
                    stopPlatforms(temp0, temp1)
                    //> jmp DoOtherPlatform         ;jump ahead to remaining code
                } else {
                    //> PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
                    movePlatformDown()
                }
                //> DoOtherPlatform:
                //> ldy Enemy_State,x           ;get offset of other platform
                temp1 = enemyState[X]
                //> pla                         ;get old vertical coordinate from stack
                temp0 = pull()
                //> sec
                //> sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
                temp6 = temp0 - enemyYPosition[X]
                temp0 = temp6 and 0xFF
                //> clc
                //> adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
                temp7 = temp0 + enemyYPosition[temp1]
                temp0 = temp7 and 0xFF
                //> sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
                enemyYPosition[temp1] = temp0
                //> lda PlatformCollisionFlag,x ;if no collision, skip this part here
                temp0 = platformCollisionFlag[X]
                //> bmi DrawEraseRope
                if ((temp0 and 0x80) == 0) {
                    //> tax                         ;put offset which collision occurred here
                    //> jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
                    positionPlayerOnVPlat(temp0)
                }
                //> DrawEraseRope:
                //> ldy ObjectOffset            ;get enemy object offset
                temp1 = objectOffset
                //> lda Enemy_Y_Speed,y         ;check to see if current platform is
                temp0 = enemyYSpeed[temp1]
                //> ora Enemy_Y_MoveForce,y     ;moving at all
                temp8 = temp0 or enemyYMoveforce[temp1]
                //> beq ExitRp                  ;if not, skip all of this and branch to leave
                temp0 = temp8
                if (temp8 != 0) {
                    //> ldx VRAM_Buffer1_Offset     ;get vram buffer offset
                    //> cpx #$20                    ;if offset beyond a certain point, go ahead
                    //> bcs ExitRp                  ;and skip this, branch to leave
                    temp9 = vramBuffer1Offset
                    if (!(vramBuffer1Offset >= 0x20)) {
                        //> lda Enemy_Y_Speed,y
                        temp0 = enemyYSpeed[temp1]
                        //> pha                         ;save two copies of vertical speed to stack
                        push(temp0)
                        //> pha
                        push(temp0)
                        //> jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
                        setupPlatformRope(temp0, temp1)
                        //> lda $01                     ;write name table address to vram buffer
                        temp0 = memory[0x1].toInt()
                        //> sta VRAM_Buffer1,x          ;first the high byte, then the low
                        vramBuffer1[temp9] = temp0
                        //> lda $00
                        temp0 = memory[0x0].toInt()
                        //> sta VRAM_Buffer1+1,x
                        vramBuffer1[1 + temp9] = temp0
                        //> lda #$02                    ;set length for 2 bytes
                        temp0 = 0x02
                        //> sta VRAM_Buffer1+2,x
                        vramBuffer1[2 + temp9] = temp0
                        //> lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
                        temp0 = enemyYSpeed[temp1]
                        //> bmi EraseR1                 ;to do something else
                        if ((temp0 and 0x80) == 0) {
                            //> lda #$a2
                            temp0 = 0xA2
                            //> sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
                            vramBuffer1[3 + temp9] = temp0
                            //> lda #$a3                    ;and right sides of rope in vram buffer
                            temp0 = 0xA3
                            //> sta VRAM_Buffer1+4,x
                            vramBuffer1[4 + temp9] = temp0
                            //> jmp OtherRope               ;jump to skip this part
                        } else {
                            //> EraseR1: lda #$24                    ;put blank tiles in vram buffer
                            temp0 = 0x24
                            //> sta VRAM_Buffer1+3,x        ;to erase rope
                            vramBuffer1[3 + temp9] = temp0
                            //> sta VRAM_Buffer1+4,x
                            vramBuffer1[4 + temp9] = temp0
                        }
                        //> OtherRope:
                        //> lda Enemy_State,y           ;get offset of other platform from state
                        temp0 = enemyState[temp1]
                        //> tay                         ;use as Y here
                        //> pla                         ;pull second copy of vertical speed from stack
                        temp0 = pull()
                        //> eor #$ff                    ;invert bits to reverse speed
                        temp10 = temp0 xor 0xFF
                        //> jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
                        setupPlatformRope(temp10, temp0)
                        //> lda $01                     ;write name table address to vram buffer
                        temp0 = memory[0x1].toInt()
                        //> sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
                        vramBuffer1[5 + temp9] = temp0
                        //> lda $00                     ;the other platform
                        temp0 = memory[0x0].toInt()
                        //> sta VRAM_Buffer1+6,x
                        vramBuffer1[6 + temp9] = temp0
                        //> lda #$02
                        temp0 = 0x02
                        //> sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
                        vramBuffer1[7 + temp9] = temp0
                        //> pla                         ;pull first copy of vertical speed from stack
                        temp0 = pull()
                        //> bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
                        temp1 = temp0
                        if ((temp0 and 0x80) != 0) {
                            //> lda #$a2
                            temp0 = 0xA2
                            //> sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
                            vramBuffer1[8 + temp9] = temp0
                            //> lda #$a3                    ;and right sides of rope in vram
                            temp0 = 0xA3
                            //> sta VRAM_Buffer1+9,x        ;transfer buffer
                            vramBuffer1[9 + temp9] = temp0
                            //> jmp EndRp                   ;jump to skip this part
                        } else {
                            //> EraseR2: lda #$24                    ;put blank tiles in vram buffer
                            temp0 = 0x24
                            //> sta VRAM_Buffer1+8,x        ;to erase rope
                            vramBuffer1[8 + temp9] = temp0
                            //> sta VRAM_Buffer1+9,x
                            vramBuffer1[9 + temp9] = temp0
                        }
                        //> EndRp:   lda #$00                    ;put null terminator at the end
                        temp0 = 0x00
                        //> sta VRAM_Buffer1+10,x
                        vramBuffer1[10 + temp9] = temp0
                        //> lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
                        temp0 = vramBuffer1Offset
                        //> clc                         ;and store
                        //> adc #10
                        temp11 = temp0 + 0x0A
                        temp0 = temp11 and 0xFF
                        //> sta VRAM_Buffer1_Offset
                        vramBuffer1Offset = temp0
                    }
                }
                //> ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
                temp9 = objectOffset
                //> rts
                return
            }
            //> InitPlatformFall:
            //> tya                        ;move offset of other platform from Y to X
            //> tax
            //> jsr GetEnemyOffscreenBits  ;get offscreen bits
            getEnemyOffscreenBits(temp1)
            //> lda #$06
            temp0 = 0x06
            //> jsr SetupFloateyNumber     ;award 1000 points to player
            setupFloateyNumber(temp0, temp1)
            //> lda Player_Rel_XPos
            temp0 = playerRelXpos
            //> sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
            floateynumXPos[temp1] = temp0
            //> lda Player_Y_Position
            temp0 = playerYPosition
            //> sta FloateyNum_Y_Pos,x
            floateynumYPos[temp1] = temp0
            //> lda #$01                   ;set moving direction as flag for
            temp0 = 0x01
            //> sta Enemy_MovingDir,x      ;falling platforms
            enemyMovingdir[temp1] = temp0
        }
    }
    //> PlatformFall:
    //> tya                         ;save offset for other platform to stack
    //> pha
    push(temp1)
    //> jsr MoveFallingPlatform     ;make current platform fall
    moveFallingPlatform()
    //> pla
    temp0 = pull()
    //> tax                         ;pull offset from stack and save to X
    //> jsr MoveFallingPlatform     ;make other platform fall
    moveFallingPlatform()
    //> ldx ObjectOffset
    temp9 = objectOffset
    //> lda PlatformCollisionFlag,x ;if player not standing on either platform,
    temp0 = platformCollisionFlag[temp9]
    //> bmi ExPF                    ;skip this part
    if ((temp0 and 0x80) == 0) {
        //> tax                         ;transfer collision flag offset as offset to X
        //> jsr PositionPlayerOnVPlat   ;and position player appropriately
        positionPlayerOnVPlat(temp0)
    }
    //> ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
    temp9 = objectOffset
    //> rts
    return
}

// Decompiled from SetupPlatformRope
fun setupPlatformRope(A: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    var vramBuffer1Offset by MemoryByte(VRAM_Buffer1_Offset)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> SetupPlatformRope:
    //> pha                     ;save second/third copy to stack
    push(A)
    //> lda Enemy_X_Position,y  ;get horizontal coordinate
    //> clc
    //> adc #$08                ;add eight pixels
    temp0 = enemyXPosition[Y] + 0x08
    //> ldx SecondaryHardMode   ;if secondary hard mode flag set,
    //> bne GetLRp              ;use coordinate as-is
    temp1 = temp0 and 0xFF
    temp2 = secondaryHardMode
    if (secondaryHardMode == 0) {
        //> clc
        //> adc #$10                ;otherwise add sixteen more pixels
        temp3 = temp1 + 0x10
        temp1 = temp3 and 0xFF
    }
    //> GetLRp: pha                     ;save modified horizontal coordinate to stack
    push(temp1)
    //> lda Enemy_PageLoc,y
    temp1 = enemyPageloc[Y]
    //> adc #$00                ;add carry to page location
    temp4 = temp1
    temp1 = temp4 and 0xFF
    //> sta $02                 ;and save here
    memory[0x2] = temp1.toUByte()
    //> pla                     ;pull modified horizontal coordinate
    temp1 = pull()
    //> and #%11110000          ;from the stack, mask out low nybble
    temp5 = temp1 and 0xF0
    //> lsr                     ;and shift three bits to the right
    temp5 = temp5 shr 1
    //> lsr
    temp5 = temp5 shr 1
    //> lsr
    temp5 = temp5 shr 1
    //> sta $00                 ;store result here as part of name table low byte
    memory[0x0] = temp5.toUByte()
    //> ldx Enemy_Y_Position,y  ;get vertical coordinate
    temp2 = enemyYPosition[Y]
    //> pla                     ;get second/third copy of vertical speed from stack
    temp1 = pull()
    //> bpl GetHRp              ;skip this part if moving downwards or not at all
    if ((temp1 and 0x80) != 0) {
        //> txa
        //> clc
        //> adc #$08                ;add eight to vertical coordinate and
        temp6 = temp2 + 0x08
        temp1 = temp6 and 0xFF
        //> tax                     ;save as X
    }
    //> GetHRp: txa                     ;move vertical coordinate to A
    //> ldx VRAM_Buffer1_Offset ;get vram buffer offset
    temp2 = vramBuffer1Offset
    //> asl
    temp2 = (temp2 shl 1) and 0xFF
    //> rol                     ;rotate d7 to d0 and d6 into carry
    temp2 = (temp2 shl 1) and 0xFE or if ((temp2 and 0x80) != 0) 1 else 0
    //> pha                     ;save modified vertical coordinate to stack
    push(temp2)
    //> rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
    temp2 = (temp2 shl 1) and 0xFE or if ((temp2 and 0x80) != 0) 1 else 0
    //> and #%00000011          ;mask out all bits but d7 and d6, then set
    temp7 = temp2 and 0x03
    //> ora #%00100000          ;d5 to get appropriate high byte of name table
    temp8 = temp7 or 0x20
    //> sta $01                 ;address, then store
    memory[0x1] = temp8.toUByte()
    //> lda $02                 ;get saved page location from earlier
    temp1 = memory[0x2].toInt()
    //> and #$01                ;mask out all but LSB
    temp9 = temp1 and 0x01
    //> asl
    temp9 = (temp9 shl 1) and 0xFF
    //> asl                     ;shift twice to the left and save with the
    temp9 = (temp9 shl 1) and 0xFF
    //> ora $01                 ;rest of the bits of the high byte, to get
    temp10 = temp9 or memory[0x1].toInt()
    //> sta $01                 ;the proper name table and the right place on it
    memory[0x1] = temp10.toUByte()
    //> pla                     ;get modified vertical coordinate from stack
    temp1 = pull()
    //> and #%11100000          ;mask out low nybble and LSB of high nybble
    temp11 = temp1 and 0xE0
    //> clc
    //> adc $00                 ;add to horizontal part saved here
    temp12 = temp11 + memory[0x0].toInt()
    temp1 = temp12 and 0xFF
    //> sta $00                 ;save as name table low byte
    memory[0x0] = temp1.toUByte()
    //> lda Enemy_Y_Position,y
    temp1 = enemyYPosition[Y]
    //> cmp #$e8                ;if vertical position not below the
    //> bcc ExPRp               ;bottom of the screen, we're done, branch to leave
    if (temp1 >= 0xE8) {
        //> lda $00
        temp1 = memory[0x0].toInt()
        //> and #%10111111          ;mask out d6 of low byte of name table address
        temp13 = temp1 and 0xBF
        //> sta $00
        memory[0x0] = temp13.toUByte()
    }
    //> ExPRp:  rts                     ;leave!
    return
}

// Decompiled from StopPlatforms
fun stopPlatforms(A: Int, Y: Int) {
    var X: Int = 0
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> StopPlatforms:
    //> jsr InitVStf             ;initialize vertical speed and low byte
    initVStf(X)
    //> sta Enemy_Y_Speed,y      ;for both platforms and leave
    enemyYSpeed[Y] = A
    //> sta Enemy_Y_MoveForce,y
    enemyYMoveforce[Y] = A
    //> rts
    return
}

// Decompiled from YMovingPlatform
fun yMovingPlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    val yPlatformCenterYPos by MemoryByteIndexed(YPlatformCenterYPos)
    val yPlatformTopYPos by MemoryByteIndexed(YPlatformTopYPos)
    //> YMovingPlatform:
    //> lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
    //> ora Enemy_Y_MoveForce,x      ;check on other position
    temp0 = enemyYSpeed[X] or enemyYMoveforce[X]
    //> bne ChkYCenterPos
    temp1 = temp0
    if (temp0 == 0) {
        //> sta Enemy_YMF_Dummy,x        ;initialize dummy variable
        enemyYmfDummy[X] = temp1
        //> lda Enemy_Y_Position,x
        temp1 = enemyYPosition[X]
        //> cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
        //> bcs ChkYCenterPos            ;ahead of all this
        if (!(temp1 >= yPlatformTopYPos[X])) {
            //> lda FrameCounter
            temp1 = frameCounter
            //> and #%00000111               ;check for every eighth frame
            temp2 = temp1 and 0x07
            //> bne SkipIY
            if (!(temp2 == 0)) {
                //  goto SkipIY
                return
            }
            temp1 = temp2
            if (temp2 == 0) {
                //> inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
                enemyYPosition[X] = (enemyYPosition[X] + 1) and 0xFF
            }
        }
    } else {
        //> ChkYCenterPos:
        //> lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
        temp1 = enemyYPosition[X]
        //> cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
        //> bcc YMDown
        if (temp1 >= yPlatformCenterYPos[X]) {
            //> jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
            movePlatformUp(X)
            //> jmp ChkYPCollision
        } else {
            //> YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
            movePlatformDown()
        }
    }
    //> ChkYPCollision:
    //> lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
    temp1 = platformCollisionFlag[X]
    //> bmi ExYPl                    ;to leave
    if ((temp1 and 0x80) == 0) {
        //> jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
        positionPlayerOnVPlat(X)
    }
    //> ExYPl: rts                          ;leave
    return
}

// Decompiled from XMovingPlatform
fun xMovingPlatform(X: Int) {
    var temp0: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> XMovingPlatform:
    //> lda #$0e                     ;load preset maximum value for secondary counter
    //> jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
    xmovecntrPlatform(0x0E, X)
    //> jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
    moveWithXMCntrs(X)
    //> lda PlatformCollisionFlag,x  ;if no collision with player,
    //> bmi ExXMP                    ;branch ahead to leave
    temp0 = platformCollisionFlag[X]
    if ((platformCollisionFlag[X] and 0x80) == 0) {
    }
    //> ExXMP:   rts                       ;and we are done here
    return
}

// Decompiled from PositionPlayerOnHPlat
fun positionPlayerOnHPlat() {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var platformXScroll by MemoryByte(Platform_X_Scroll)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    //> PositionPlayerOnHPlat:
    //> lda Player_X_Position
    //> clc                       ;add saved value from second subroutine to
    //> adc $00                   ;current player's position to position
    temp0 = playerXPosition + memory[0x0].toInt()
    //> sta Player_X_Position     ;player accordingly in horizontal position
    playerXPosition = temp0 and 0xFF
    //> lda Player_PageLoc        ;get player's page location
    //> ldy $00                   ;check to see if saved value here is positive or negative
    //> bmi PPHSubt               ;if negative, branch to subtract
    temp1 = playerPageloc
    temp2 = memory[0x0].toInt()
    if ((memory[0x0].toInt() and 0x80) == 0) {
        //> adc #$00                  ;otherwise add carry to page location
        temp3 = temp1 + (if (temp0 > 0xFF) 1 else 0)
        temp1 = temp3 and 0xFF
        //> jmp SetPVar               ;jump to skip subtraction
    } else {
        //> PPHSubt: sbc #$00                  ;subtract borrow from page location
        temp4 = temp1 - (if (temp0 > 0xFF) 0 else 1)
        temp1 = temp4 and 0xFF
    }
    //> SetPVar: sta Player_PageLoc        ;save result to player's page location
    playerPageloc = temp1
    //> sty Platform_X_Scroll     ;put saved value from second sub here to be used later
    platformXScroll = temp2
    //> jsr PositionPlayerOnVPlat ;position player vertically and appropriately
    positionPlayerOnVPlat(X)
    //> ExXMP:   rts                       ;and we are done here
    return
}

// Decompiled from DropPlatform
fun dropPlatform(X: Int) {
    var temp0: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> DropPlatform:
    //> lda PlatformCollisionFlag,x  ;if no collision between platform and player
    //> bmi ExDPl                    ;occurred, just leave without moving anything
    temp0 = platformCollisionFlag[X]
    if ((platformCollisionFlag[X] and 0x80) == 0) {
        //> jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
        moveDropPlatform()
        //> jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
        positionPlayerOnVPlat(X)
    }
    //> ExDPl: rts                          ;leave
    return
}

// Decompiled from RightPlatform
fun rightPlatform(A: Int, X: Int) {
    var temp0: Int = 0
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> RightPlatform:
    //> jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
    moveEnemyHorizontally(X)
    //> sta $00                       ;store saved value here (residual code)
    memory[0x0] = A.toUByte()
    //> lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
    //> bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
    temp0 = platformCollisionFlag[X]
    if ((platformCollisionFlag[X] and 0x80) == 0) {
        //> lda #$10
        temp0 = 0x10
        //> sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
        enemyXSpeed[X] = temp0
        //> jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
        positionPlayerOnHPlat()
    }
    //> ExRPl: rts                           ;then leave
    return
}

// Decompiled from MoveLargeLiftPlat
fun moveLargeLiftPlat(X: Int) {
    var temp0: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> ChkYPCollision:
    //> lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
    //> bmi ExYPl                    ;to leave
    temp0 = platformCollisionFlag[X]
    if ((platformCollisionFlag[X] and 0x80) == 0) {
        //> jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
        positionPlayerOnVPlat(X)
    }
    //> ExYPl: rts                          ;leave
    return
}

// Decompiled from MoveSmallPlatform
fun moveSmallPlatform(X: Int) {
    var temp0: Int = 0
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> MoveSmallPlatform:
    //> jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
    moveLiftPlatforms(X)
    //> jmp ChkSmallPlatCollision  ;branch to position player correctly
    //> ChkSmallPlatCollision:
    //> lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
    //> beq ExLiftP                 ;if none found, leave player position alone
    temp0 = platformCollisionFlag[X]
    if (platformCollisionFlag[X] != 0) {
        //> jsr PositionPlayerOnS_Plat  ;use to position player correctly
        positionplayeronsPlat(temp0, X)
    }
    //> ExLiftP: rts                         ;then leave
    return
}

// Decompiled from MoveLiftPlatforms
fun moveLiftPlatforms(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var timerControl by MemoryByte(TimerControl)
    val enemyYmfDummy by MemoryByteIndexed(Enemy_YMF_Dummy)
    val enemyYMoveforce by MemoryByteIndexed(Enemy_Y_MoveForce)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> MoveLiftPlatforms:
    //> lda TimerControl         ;if master timer control set, skip all of this
    //> bne ExLiftP              ;and branch to leave
    if (!(timerControl == 0)) {
        //  goto ExLiftP
        return
    }
    temp0 = timerControl
    if (timerControl == 0) {
        //> lda Enemy_YMF_Dummy,x
        temp0 = enemyYmfDummy[X]
        //> clc                      ;add contents of movement amount to whatever's here
        //> adc Enemy_Y_MoveForce,x
        temp1 = temp0 + enemyYMoveforce[X]
        temp0 = temp1 and 0xFF
        //> sta Enemy_YMF_Dummy,x
        enemyYmfDummy[X] = temp0
        //> lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
        temp0 = enemyYPosition[X]
        //> adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
        temp2 = temp0 + enemyYSpeed[X] + (if (temp1 > 0xFF) 1 else 0)
        temp0 = temp2 and 0xFF
        //> sta Enemy_Y_Position,x   ;and then leave
        enemyYPosition[X] = temp0
        //> rts
        return
    } else {
        //> ExLiftP: rts                         ;then leave
        return
    }
}

// Decompiled from OffscreenBoundsCheck
fun offscreenBoundsCheck(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    var screenrightPageloc by MemoryByte(ScreenRight_PageLoc)
    var screenrightXPos by MemoryByte(ScreenRight_X_Pos)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> OffscreenBoundsCheck:
    //> lda Enemy_ID,x          ;check for cheep-cheep object
    //> cmp #FlyingCheepCheep   ;branch to leave if found
    //> beq ExScrnBd
    temp0 = enemyId[X]
    if (enemyId[X] != FlyingCheepCheep) {
        //> lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
        temp0 = screenleftXPos
        //> ldy Enemy_ID,x
        //> cpy #HammerBro          ;check for hammer bro object
        //> beq LimitB
        temp1 = enemyId[X]
        if (enemyId[X] != HammerBro) {
            //> cpy #PiranhaPlant       ;check for piranha plant object
            //> bne ExtendLB            ;these two will be erased sooner than others if too far left
            if (temp1 == PiranhaPlant) {
            }
        }
        //> LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
        temp2 = temp0 + 0x38
        temp0 = temp2 and 0xFF
        //> ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
        temp3 = temp0 - 0x48 - (if (temp2 > 0xFF) 0 else 1)
        temp0 = temp3 and 0xFF
        //> sta $01                 ;store result here
        memory[0x1] = temp0.toUByte()
        //> lda ScreenLeft_PageLoc
        temp0 = screenleftPageloc
        //> sbc #$00                ;subtract borrow from page location of left side
        temp4 = temp0 - (if (temp3 >= 0) 0 else 1)
        temp0 = temp4 and 0xFF
        //> sta $00                 ;store result here
        memory[0x0] = temp0.toUByte()
        //> lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
        temp0 = screenrightXPos
        //> adc #$48
        temp5 = temp0 + 0x48 + (if (temp4 >= 0) 1 else 0)
        temp0 = temp5 and 0xFF
        //> sta $03                 ;store result here
        memory[0x3] = temp0.toUByte()
        //> lda ScreenRight_PageLoc
        temp0 = screenrightPageloc
        //> adc #$00                ;then add the carry to the page location
        temp6 = temp0 + (if (temp5 > 0xFF) 1 else 0)
        temp0 = temp6 and 0xFF
        //> sta $02                 ;and store result here
        memory[0x2] = temp0.toUByte()
        //> lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
        temp0 = enemyXPosition[X]
        //> cmp $01                 ;to modified horizontal left edge coordinate to get carry
        //> lda Enemy_PageLoc,x
        temp0 = enemyPageloc[X]
        //> sbc $00                 ;then subtract it from the page coordinate of the enemy object
        temp7 = temp0 - memory[0x0].toInt() - (if (temp0 >= memory[0x1].toInt()) 0 else 1)
        temp0 = temp7 and 0xFF
        //> bmi TooFar              ;if enemy object is too far left, branch to erase it
        if ((temp7 and 0xFF and 0x80) == 0) {
            //> lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
            temp0 = enemyXPosition[X]
            //> cmp $03                 ;to modified horizontal right edge coordinate to get carry
            //> lda Enemy_PageLoc,x
            temp0 = enemyPageloc[X]
            //> sbc $02                 ;then subtract it from the page coordinate of the enemy object
            temp8 = temp0 - memory[0x2].toInt() - (if (temp0 >= memory[0x3].toInt()) 0 else 1)
            temp0 = temp8 and 0xFF
            //> bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
            if ((temp8 and 0xFF and 0x80) == 0) {
                //> lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
                temp0 = enemyState[X]
                //> cmp #HammerBro          ;if in state used by spiny's egg, do not erase
                //> beq ExScrnBd
                if (temp0 != HammerBro) {
                    //> cpy #PiranhaPlant       ;if piranha plant, do not erase
                    //> beq ExScrnBd
                    if (temp1 != PiranhaPlant) {
                        //> cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
                        //> beq ExScrnBd
                        if (temp1 != FlagpoleFlagObject) {
                            //> cpy #StarFlagObject     ;if star flag, do not erase
                            //> beq ExScrnBd
                            if (temp1 != StarFlagObject) {
                                //> cpy #JumpspringObject   ;if jumpspring, do not erase
                                //> beq ExScrnBd            ;erase all others too far to the right
                                if (temp1 != JumpspringObject) {
                                } else {
                                    //> ExScrnBd: rts                     ;leave
                                    return
                                }
                            }
                        }
                    }
                }
            }
        }
        //> TooFar:   jsr EraseEnemyObject    ;erase object if necessary
        eraseEnemyObject(X)
    }
}

// Decompiled from FireballEnemyCollision
fun fireballEnemyCollision(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val fireballState by MemoryByteIndexed(Fireball_State)
    //> FireballEnemyCollision:
    //> lda Fireball_State,x  ;check to see if fireball state is set at all
    //> beq ExitFBallEnemy    ;branch to leave if not
    temp0 = fireballState[X]
    if (fireballState[X] != 0) {
        //> asl
        temp0 = (temp0 shl 1) and 0xFF
        //> bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
        if ((temp0 and 0x80) == 0) {
            //> lda FrameCounter
            temp0 = frameCounter
            //> lsr                   ;get LSB of frame counter
            temp0 = temp0 shr 1
            //> bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
            if ((temp0 and 0x01) == 0) {
                //> txa
                //> asl                   ;multiply fireball offset by four
                X = (X shl 1) and 0xFF
                //> asl
                X = (X shl 1) and 0xFF
                //> clc
                //> adc #$1c              ;then add $1c or 28 bytes to it
                temp1 = X + 0x1C
                temp0 = temp1 and 0xFF
                //> tay                   ;to use fireball's bounding box coordinates
                //> ldx #$04
                temp2 = 0x04
                temp3 = temp0
                do {
                    //> FireballEnemyCDLoop:
                    //> stx $01                     ;store enemy object offset here
                    memory[0x1] = temp2.toUByte()
                    //> tya
                    //> pha                         ;push fireball offset to the stack
                    push(temp3)
                    //> lda Enemy_State,x
                    temp0 = enemyState[temp2]
                    //> and #%00100000              ;check to see if d5 is set in enemy state
                    temp4 = temp0 and 0x20
                    //> bne NoFToECol               ;if so, skip to next enemy slot
                    temp0 = temp4
                    if (temp4 == 0) {
                        //> lda Enemy_Flag,x            ;check to see if buffer flag is set
                        temp0 = enemyFlag[temp2]
                        //> beq NoFToECol               ;if not, skip to next enemy slot
                        if (temp0 != 0) {
                            //> lda Enemy_ID,x              ;check enemy identifier
                            temp0 = enemyId[temp2]
                            //> cmp #$24
                            //> bcc GoombaDie               ;if < $24, branch to check further
                            if (temp0 >= 0x24) {
                                //> cmp #$2b
                                //> bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
                                if (temp0 >= 0x2B) {
                                }
                            }
                            //> GoombaDie: cmp #Goomba                 ;check for goomba identifier
                            //> bne NotGoomba               ;if not found, continue with code
                            if (temp0 == Goomba) {
                                //> lda Enemy_State,x           ;otherwise check for defeated state
                                temp0 = enemyState[temp2]
                                //> cmp #$02                    ;if stomped or otherwise defeated,
                                //> bcs NoFToECol               ;skip to next enemy slot
                                if (!(temp0 >= 0x02)) {
                                }
                            }
                            //> NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
                            temp0 = enemyOffscrBitsMasked[temp2]
                            //> bne NoFToECol               ;skip to next enemy slot
                            if (temp0 == 0) {
                                //> txa
                                //> asl                         ;otherwise multiply enemy offset by four
                                temp2 = (temp2 shl 1) and 0xFF
                                //> asl
                                temp2 = (temp2 shl 1) and 0xFF
                                //> clc
                                //> adc #$04                    ;add 4 bytes to it
                                temp5 = temp2 + 0x04
                                temp0 = temp5 and 0xFF
                                //> tax                         ;to use enemy's bounding box coordinates
                                //> jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
                                sprObjectCollisionCore(temp0, temp3)
                                //> ldx ObjectOffset            ;return fireball's original offset
                                temp2 = objectOffset
                                //> bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
                                if (temp5 > 0xFF) {
                                    //> lda #%10000000
                                    temp0 = 0x80
                                    //> sta Fireball_State,x        ;set d7 in enemy state
                                    fireballState[temp2] = temp0
                                    //> ldx $01                     ;get enemy offset
                                    temp2 = memory[0x1].toInt()
                                    //> jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
                                    handleEnemyFBallCol()
                                }
                            }
                        }
                    }
                    //> NoFToECol: pla                         ;pull fireball offset from stack
                    temp0 = pull()
                    //> tay                         ;put it in Y
                    //> ldx $01                     ;get enemy object offset
                    temp2 = memory[0x1].toInt()
                    //> dex                         ;decrement it
                    temp2 = (temp2 - 1) and 0xFF
                    //> bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
                } while ((temp2 and 0x80) == 0)
            }
        }
    }
    //> ExitFBallEnemy:
    //> ldx ObjectOffset                 ;get original fireball offset and leave
    temp2 = objectOffset
    //> rts
    return
}

// Decompiled from HandleEnemyFBallCol
fun handleEnemyFBallCol() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var bowserHitPoints by MemoryByte(BowserHitPoints)
    var enemyFrenzyBuffer by MemoryByte(EnemyFrenzyBuffer)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var worldNumber by MemoryByte(WorldNumber)
    val bowserIdentities by MemoryByteIndexed(BowserIdentities)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> HandleEnemyFBallCol:
    //> jsr RelativeEnemyPosition  ;get relative coordinate of enemy
    relativeEnemyPosition()
    //> ldx $01                    ;get current enemy object offset
    //> lda Enemy_Flag,x           ;check buffer flag for d7 set
    //> bpl ChkBuzzyBeetle         ;branch if not set to continue
    temp0 = enemyFlag[memory[0x1].toInt()]
    temp1 = memory[0x1].toInt()
    if ((enemyFlag[memory[0x1].toInt()] and 0x80) != 0) {
        //> and #%00001111             ;otherwise mask out high nybble and
        temp2 = temp0 and 0x0F
        //> tax                        ;use low nybble as enemy offset
        //> lda Enemy_ID,x
        temp0 = enemyId[temp2]
        //> cmp #Bowser                ;check enemy identifier for bowser
        //> beq HurtBowser             ;branch if found
        temp1 = temp2
        if (temp0 != Bowser) {
            //> ldx $01                    ;otherwise retrieve current enemy offset
            temp1 = memory[0x1].toInt()
        }
    }
    //> ChkBuzzyBeetle:
    //> lda Enemy_ID,x
    temp0 = enemyId[temp1]
    //> cmp #BuzzyBeetle           ;check for buzzy beetle
    //> beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
    if (temp0 - BuzzyBeetle == 0) {
        //  goto ExHCF
        return
    }
    if (temp0 != BuzzyBeetle) {
        //> cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
        //> bne ChkOtherEnemies        ;if not found, branch to check other enemies
        if (temp0 == Bowser) {
            //> HurtBowser:
            //> dec BowserHitPoints        ;decrement bowser's hit points
            bowserHitPoints = (bowserHitPoints - 1) and 0xFF
            //> bne ExHCF                  ;if bowser still has hit points, branch to leave
            if (!(bowserHitPoints == 0)) {
                //  goto ExHCF
                return
            }
            if (bowserHitPoints == 0) {
                //> jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
                initVStf(temp1)
                //> sta Enemy_X_Speed,x        ;initialize horizontal speed
                enemyXSpeed[temp1] = temp0
                //> sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
                enemyFrenzyBuffer = temp0
                //> lda #$fe
                temp0 = 0xFE
                //> sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
                enemyYSpeed[temp1] = temp0
                //> ldy WorldNumber            ;use world number as offset
                //> lda BowserIdentities,y     ;get enemy identifier to replace bowser with
                temp0 = bowserIdentities[worldNumber]
                //> sta Enemy_ID,x             ;set as new enemy identifier
                enemyId[temp1] = temp0
                //> lda #$20                   ;set A to use starting value for state
                temp0 = 0x20
                //> cpy #$03                   ;check to see if using offset of 3 or more
                //> bcs SetDBSte               ;branch if so
                temp3 = worldNumber
                if (!(worldNumber >= 0x03)) {
                    //> ora #$03                   ;otherwise add 3 to enemy state
                    temp4 = temp0 or 0x03
                }
                //> SetDBSte: sta Enemy_State,x          ;set defeated enemy state
                enemyState[temp1] = temp0
                //> lda #Sfx_BowserFall
                temp0 = Sfx_BowserFall
                //> sta Square2SoundQueue      ;load bowser defeat sound
                square2SoundQueue = temp0
                //> ldx $01                    ;get enemy offset
                temp1 = memory[0x1].toInt()
                //> lda #$09                   ;award 5000 points to player for defeating bowser
                temp0 = 0x09
                //> bne EnemySmackScore        ;unconditional branch to award points
                if (!(temp0 == 0)) {
                    //  goto EnemySmackScore
                    return
                }
                if (temp0 == 0) {
                }
            } else {
                //> ExHCF: rts                      ;and now let's leave
                return
            }
        }
        //> ChkOtherEnemies:
        //> cmp #BulletBill_FrenzyVar
        //> beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
        if (temp0 - BulletBill_FrenzyVar == 0) {
            //  goto ExHCF
            return
        }
        if (temp0 != BulletBill_FrenzyVar) {
            //> cmp #Podoboo
            //> beq ExHCF                 ;branch to leave if podoboo
            if (temp0 - Podoboo == 0) {
                //  goto ExHCF
                return
            }
            if (temp0 != Podoboo) {
                //> cmp #$15
                //> bcs ExHCF                 ;branch to leave if identifier => $15
                if (temp0 >= 0x15) {
                    //  goto ExHCF
                    return
                }
                if (!(temp0 >= 0x15)) {
                    //> EnemySmackScore:
                    //> jsr SetupFloateyNumber   ;update necessary score variables
                    setupFloateyNumber(temp0, temp1)
                    //> lda #Sfx_EnemySmack      ;play smack enemy sound
                    temp0 = Sfx_EnemySmack
                    //> sta Square1SoundQueue
                    square1SoundQueue = temp0
                }
            }
        }
    }
    // Fall-through tail call to shellOrBlockDefeat
    shellOrBlockDefeat(temp1)
}

// Decompiled from ShellOrBlockDefeat
fun shellOrBlockDefeat(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ShellOrBlockDefeat:
    //> lda Enemy_ID,x            ;check for piranha plant
    //> cmp #PiranhaPlant
    //> bne StnE                  ;branch if not found
    temp0 = enemyId[X]
    if (enemyId[X] == PiranhaPlant) {
        //> lda Enemy_Y_Position,x
        temp0 = enemyYPosition[X]
        //> adc #$18                  ;add 24 pixels to enemy object's vertical position
        temp1 = temp0 + 0x18 + (if (enemyId[X] >= PiranhaPlant) 1 else 0)
        temp0 = temp1 and 0xFF
        //> sta Enemy_Y_Position,x
        enemyYPosition[X] = temp0
    }
    //> StnE: jsr ChkToStunEnemies      ;do yet another sub
    chkToStunEnemies(temp0, X)
    //> lda Enemy_State,x
    temp0 = enemyState[X]
    //> and #%00011111            ;mask out 2 MSB of enemy object's state
    temp2 = temp0 and 0x1F
    //> ora #%00100000            ;set d5 to defeat enemy and save as new state
    temp3 = temp2 or 0x20
    //> sta Enemy_State,x
    enemyState[X] = temp3
    //> lda #$02                  ;award 200 points by default
    temp0 = 0x02
    //> ldy Enemy_ID,x            ;check for hammer bro
    //> cpy #HammerBro
    //> bne GoombaPoints          ;branch if not found
    temp4 = enemyId[X]
    if (enemyId[X] == HammerBro) {
        //> lda #$06                  ;award 1000 points for hammer bro
        temp0 = 0x06
    }
    //> GoombaPoints:
    //> cpy #Goomba               ;check for goomba
    //> bne EnemySmackScore       ;branch if not found
    if (temp4 == Goomba) {
        //> lda #$01                  ;award 100 points for goomba
        temp0 = 0x01
    }
    //> EnemySmackScore:
    //> jsr SetupFloateyNumber   ;update necessary score variables
    setupFloateyNumber(temp0, X)
    //> lda #Sfx_EnemySmack      ;play smack enemy sound
    temp0 = Sfx_EnemySmack
    //> sta Square1SoundQueue
    square1SoundQueue = temp0
    //> ExHCF: rts                      ;and now let's leave
    return
}

// Decompiled from PlayerHammerCollision
fun playerHammerCollision(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var miscOffscreenbits by MemoryByte(Misc_OffscreenBits)
    var objectOffset by MemoryByte(ObjectOffset)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    var timerControl by MemoryByte(TimerControl)
    val miscCollisionFlag by MemoryByteIndexed(Misc_Collision_Flag)
    val miscXSpeed by MemoryByteIndexed(Misc_X_Speed)
    //> PlayerHammerCollision:
    //> lda FrameCounter          ;get frame counter
    //> lsr                       ;shift d0 into carry
    frameCounter = frameCounter shr 1
    //> bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
    temp0 = frameCounter
    if ((frameCounter and 0x01) != 0) {
        //> lda TimerControl          ;if either master timer control
        temp0 = timerControl
        //> ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
        temp1 = temp0 or miscOffscreenbits
        //> bne ExPHC                 ;branch to leave
        temp0 = temp1
        if (temp1 == 0) {
            //> txa
            //> asl                       ;multiply misc object offset by four
            X = (X shl 1) and 0xFF
            //> asl
            X = (X shl 1) and 0xFF
            //> clc
            //> adc #$24                  ;add 36 or $24 bytes to get proper offset
            temp2 = X + 0x24
            temp0 = temp2 and 0xFF
            //> tay                       ;for misc object bounding box coordinates
            //> jsr PlayerCollisionCore   ;do player-to-hammer collision detection
            playerCollisionCore()
            //> ldx ObjectOffset          ;get misc object offset
            //> bcc ClHCol                ;if no collision, then branch
            temp3 = objectOffset
            temp4 = temp0
            if (temp2 > 0xFF) {
                //> lda Misc_Collision_Flag,x ;otherwise read collision flag
                temp0 = miscCollisionFlag[temp3]
                //> bne ExPHC                 ;if collision flag already set, branch to leave
                if (temp0 == 0) {
                    //> lda #$01
                    temp0 = 0x01
                    //> sta Misc_Collision_Flag,x ;otherwise set collision flag now
                    miscCollisionFlag[temp3] = temp0
                    //> lda Misc_X_Speed,x
                    temp0 = miscXSpeed[temp3]
                    //> eor #$ff                  ;get two's compliment of
                    temp5 = temp0 xor 0xFF
                    //> clc                       ;hammer's horizontal speed
                    //> adc #$01
                    temp6 = temp5 + 0x01
                    temp0 = temp6 and 0xFF
                    //> sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
                    miscXSpeed[temp3] = temp0
                    //> lda StarInvincibleTimer   ;if star mario invincibility timer set,
                    temp0 = starInvincibleTimer
                    //> bne ExPHC                 ;branch to leave
                    if (temp0 == 0) {
                        //> jmp InjurePlayer          ;otherwise jump to hurt player, do not return
                    } else {
                        //> ExPHC:  rts
                        return
                    }
                }
            }
            //> ClHCol: lda #$00                  ;clear collision flag
            temp0 = 0x00
            //> sta Misc_Collision_Flag,x
            miscCollisionFlag[temp3] = temp0
        }
    }
}

// Decompiled from PlayerEnemyCollision
fun playerEnemyCollision(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var frameCounter by MemoryByte(FrameCounter)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerStatus by MemoryByte(PlayerStatus)
    var powerUpType by MemoryByte(PowerUpType)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    var starInvincibleTimer by MemoryByte(StarInvincibleTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyCollisionbits by MemoryByteIndexed(Enemy_CollisionBits)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val kickedShellPtsData by MemoryByteIndexed(KickedShellPtsData)
    val kickedShellXSpdData by MemoryByteIndexed(KickedShellXSpdData)
    //> HandlePowerUpCollision:
    //> jsr EraseEnemyObject    ;erase the power-up object
    eraseEnemyObject(X)
    //> lda #$06
    //> jsr SetupFloateyNumber  ;award 1000 points to player by default
    setupFloateyNumber(0x06, X)
    //> lda #Sfx_PowerUpGrab
    //> sta Square2SoundQueue   ;play the power-up sound
    square2SoundQueue = Sfx_PowerUpGrab
    //> lda PowerUpType         ;check power-up type
    //> cmp #$02
    //> bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
    temp0 = powerUpType
    if (powerUpType >= 0x02) {
        //> cmp #$03
        //> beq SetFor1Up           ;if 1-up mushroom, branch
        if (temp0 != 0x03) {
            //> lda #$23                ;otherwise set star mario invincibility
            temp0 = 0x23
            //> sta StarInvincibleTimer ;timer, and load the star mario music
            starInvincibleTimer = temp0
            //> lda #StarPowerMusic     ;into the area music queue, then leave
            temp0 = StarPowerMusic
            //> sta AreaMusicQueue
            areaMusicQueue = temp0
            //> rts
            return
        } else {
            //> SetFor1Up:
            //> lda #$0b                 ;change 1000 points into 1-up instead
            temp0 = 0x0B
            //> sta FloateyNum_Control,x ;and then leave
            floateynumControl[X] = temp0
            //> rts
            return
        }
    }
    //> Shroom_Flower_PUp:
    //> lda PlayerStatus    ;if player status = small, branch
    temp0 = playerStatus
    //> beq UpToSuper
    if (temp0 != 0) {
        //> cmp #$01            ;if player status not super, leave
        //> bne NoPUp
        if (temp0 == 0x01) {
            //> ldx ObjectOffset    ;get enemy offset, not necessary
            //> lda #$02            ;set player status to fiery
            temp0 = 0x02
            //> sta PlayerStatus
            playerStatus = temp0
            //> jsr GetPlayerColors ;run sub to change colors of player
            getPlayerColors()
            //> ldx ObjectOffset    ;get enemy offset again, and again not necessary
            //> lda #$0c            ;set value to be used by subroutine tree (fiery)
            temp0 = 0x0C
            //> jmp UpToFiery       ;jump to set values accordingly
        } else {
            //> NoPUp: rts
            return
        }
    }
    //> UpToSuper:
    //> lda #$01         ;set player status to super
    temp0 = 0x01
    //> sta PlayerStatus
    playerStatus = temp0
    //> lda #$09         ;set value to be used by subroutine tree (super)
    temp0 = 0x09
    //> UpToFiery:
    //> ldy #$00         ;set value to be used as new player state
    //> jsr SetPRout     ;set values to stop certain things in motion
    setPRout(temp0, 0x00)
    temp1 = 0x00
    do {
        //> PlayerEnemyCollision:
        //> lda FrameCounter            ;check counter for d0 set
        temp0 = frameCounter
        //> lsr
        temp0 = temp0 shr 1
        //> bcs NoPUp                   ;if set, branch to leave
    } while ((temp0 and 0x01) != 0)
    //> jsr CheckPlayerVertical     ;if player object is completely offscreen or
    checkPlayerVertical()
    //> bcs NoPECol                 ;if down past 224th pixel row, branch to leave
    if ((temp0 and 0x01) == 0) {
        //> lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
        temp0 = enemyOffscrBitsMasked[X]
        //> bne NoPECol                 ;go ahead and branch to leave
        if (temp0 == 0) {
            //> lda GameEngineSubroutine
            temp0 = gameEngineSubroutine
            //> cmp #$08                    ;if not set to run player control routine
            //> bne NoPECol                 ;on next frame, branch to leave
            if (temp0 == 0x08) {
                //> lda Enemy_State,x
                temp0 = enemyState[X]
                //> and #%00100000              ;if enemy state has d5 set, branch to leave
                temp2 = temp0 and 0x20
                //> bne NoPECol
                temp0 = temp2
                if (temp2 == 0) {
                    //> jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
                    getEnemyBoundBoxOfs()
                    //> jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
                    playerCollisionCore()
                    //> ldx ObjectOffset            ;get enemy object buffer offset
                    //> bcs CheckForPUpCollision    ;if collision, branch past this part here
                    temp3 = objectOffset
                    if (!(temp0 >= 0x08)) {
                        //> lda Enemy_CollisionBits,x
                        temp0 = enemyCollisionbits[temp3]
                        //> and #%11111110              ;otherwise, clear d0 of current enemy object's
                        temp4 = temp0 and 0xFE
                        //> sta Enemy_CollisionBits,x   ;collision bit
                        enemyCollisionbits[temp3] = temp4
                    }
                }
            }
        }
    }
    //> NoPECol: rts
    return
}

// Decompiled from InjurePlayer
fun injurePlayer() {
    var temp0: Int = 0
    var injuryTimer by MemoryByte(InjuryTimer)
    var objectOffset by MemoryByte(ObjectOffset)
    //> InjurePlayer:
    //> lda InjuryTimer          ;check again to see if injured invincibility timer is
    //> bne ExInjColRoutines     ;at zero, and branch to leave if so
    temp0 = injuryTimer
    if (injuryTimer == 0) {
    }
    //> ExInjColRoutines:
    //> ldx ObjectOffset              ;get enemy offset and leave
    //> rts
    return
}

// Decompiled from ForceInjury
fun forceInjury(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var injuryTimer by MemoryByte(InjuryTimer)
    var playerStatus by MemoryByte(PlayerStatus)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val demotedKoopaXSpdData by MemoryByteIndexed(DemotedKoopaXSpdData)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val revivalRateData by MemoryByteIndexed(RevivalRateData)
    val stompedEnemyPtsData by MemoryByteIndexed(StompedEnemyPtsData)
    //> ForceInjury:
    //> ldx PlayerStatus          ;check player's status
    //> beq KillPlayer            ;branch if small
    temp0 = playerStatus
    if (playerStatus != 0) {
        //> sta PlayerStatus          ;otherwise set player's status to small
        playerStatus = A
        //> lda #$08
        //> sta InjuryTimer           ;set injured invincibility timer
        injuryTimer = 0x08
        //> asl
        //> sta Square1SoundQueue     ;play pipedown/injury sound
        square1SoundQueue = (0x08 shl 1) and 0xFF
        //> jsr GetPlayerColors       ;change player's palette if necessary
        getPlayerColors()
        //> lda #$0a                  ;set subroutine to run on next frame
        //> SetKRout: ldy #$01                  ;set new player state
    }
    do {
        //> KillPlayer:
        //> stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
        playerXSpeed = temp0
        //> inx
        temp0 = (temp0 + 1) and 0xFF
        //> stx EventMusicQueue  ;set event music queue to death music
        eventMusicQueue = temp0
        //> lda #$fc
        //> sta Player_Y_Speed   ;set new vertical speed
        playerYSpeed = 0xFC
        //> lda #$0b             ;set subroutine to run on next frame
        //> bne SetKRout         ;branch to set player's state and other things
    } while (0x0B != 0)
    //> StompedEnemyPtsData:
    //> .db $02, $06, $05, $06
    //> EnemyStomped:
    //> lda Enemy_ID,x             ;check for spiny, branch to hurt player
    //> cmp #Spiny                 ;if found
    //> beq InjurePlayer
    if (enemyId[temp0] - Spiny == 0) {
        //  goto InjurePlayer
        return
    } else {
        //> lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
        //> sta Square1SoundQueue
        square1SoundQueue = Sfx_EnemyStomp
        //> lda Enemy_ID,x
        //> ldy #$00                   ;initialize points data offset for stomped enemies
        //> cmp #FlyingCheepCheep      ;branch for cheep-cheep
        //> beq EnemyStompedPts
        temp1 = enemyId[temp0]
        temp2 = 0x00
        if (enemyId[temp0] != FlyingCheepCheep) {
            //> cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
            //> beq EnemyStompedPts
            if (temp1 != BulletBill_FrenzyVar) {
                //> cmp #BulletBill_CannonVar
                //> beq EnemyStompedPts
                if (temp1 != BulletBill_CannonVar) {
                    //> cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
                    //> beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
                    if (temp1 != Podoboo) {
                        //> iny                        ;increment points data offset
                        temp2 = (temp2 + 1) and 0xFF
                        //> cmp #HammerBro             ;branch for hammer bro
                        //> beq EnemyStompedPts
                        if (temp1 != HammerBro) {
                            //> iny                        ;increment points data offset
                            temp2 = (temp2 + 1) and 0xFF
                            //> cmp #Lakitu                ;branch for lakitu
                            //> beq EnemyStompedPts
                            if (temp1 != Lakitu) {
                                //> iny                        ;increment points data offset
                                temp2 = (temp2 + 1) and 0xFF
                                //> cmp #Bloober               ;branch if NOT bloober
                                //> bne ChkForDemoteKoopa
                                if (temp1 == Bloober) {
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    //> EnemyStompedPts:
    //> lda StompedEnemyPtsData,y  ;load points data using offset in Y
    temp1 = stompedEnemyPtsData[temp2]
    //> jsr SetupFloateyNumber     ;run sub to set floatey number controls
    setupFloateyNumber(temp1, temp0)
    //> lda Enemy_MovingDir,x
    temp1 = enemyMovingdir[temp0]
    //> pha                        ;save enemy movement direction to stack
    push(temp1)
    //> jsr SetStun                ;run sub to kill enemy
    setStun(temp0)
    //> pla
    temp1 = pull()
    //> sta Enemy_MovingDir,x      ;return enemy movement direction from stack
    enemyMovingdir[temp0] = temp1
    //> lda #%00100000
    temp1 = 0x20
    //> sta Enemy_State,x          ;set d5 in enemy state
    enemyState[temp0] = temp1
    //> jsr InitVStf               ;nullify vertical speed, physics-related thing,
    initVStf(temp0)
    //> sta Enemy_X_Speed,x        ;and horizontal speed
    enemyXSpeed[temp0] = temp1
    //> lda #$fd                   ;set player's vertical speed, to give bounce
    temp1 = 0xFD
    //> sta Player_Y_Speed
    playerYSpeed = temp1
    //> rts
    return
}

// Decompiled from SetPRout
fun setPRout(A: Int, Y: Int) {
    var temp0: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var objectOffset by MemoryByte(ObjectOffset)
    var playerState by MemoryByte(Player_State)
    var scrollAmount by MemoryByte(ScrollAmount)
    var timerControl by MemoryByte(TimerControl)
    //> SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
    gameEngineSubroutine = A
    //> sty Player_State          ;store new player state
    playerState = Y
    //> ldy #$ff
    //> sty TimerControl          ;set master timer control flag to halt timers
    timerControl = 0xFF
    //> iny
    temp0 = 0xFF
    temp0 = (temp0 + 1) and 0xFF
    //> sty ScrollAmount          ;initialize scroll speed
    scrollAmount = temp0
    //> ExInjColRoutines:
    //> ldx ObjectOffset              ;get enemy offset and leave
    //> rts
    return
}

// Decompiled from EnemyFacePlayer
fun enemyFacePlayer(X: Int) {
    var temp0: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    //> EnemyFacePlayer:
    //> ldy #$01               ;set to move right by default
    //> jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
    playerEnemyDiff(X)
    //> bpl SFcRt              ;if enemy is to the right of player, do not increment
    temp0 = 0x01
    if ((0x01 and 0x80) != 0) {
        //> iny                    ;otherwise, increment to set to move to the left
        temp0 = (temp0 + 1) and 0xFF
    }
    //> SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
    enemyMovingdir[X] = temp0
    //> dey                    ;then decrement to use as a proper offset
    temp0 = (temp0 - 1) and 0xFF
    //> rts
    return
}

// Decompiled from SetupFloateyNumber
fun setupFloateyNumber(A: Int, X: Int) {
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val floateynumControl by MemoryByteIndexed(FloateyNum_Control)
    val floateynumTimer by MemoryByteIndexed(FloateyNum_Timer)
    val floateynumXPos by MemoryByteIndexed(FloateyNum_X_Pos)
    val floateynumYPos by MemoryByteIndexed(FloateyNum_Y_Pos)
    //> SetupFloateyNumber:
    //> sta FloateyNum_Control,x ;set number of points control for floatey numbers
    floateynumControl[X] = A
    //> lda #$30
    //> sta FloateyNum_Timer,x   ;set timer for floatey numbers
    floateynumTimer[X] = 0x30
    //> lda Enemy_Y_Position,x
    //> sta FloateyNum_Y_Pos,x   ;set vertical coordinate
    floateynumYPos[X] = enemyYPosition[X]
    //> lda Enemy_Rel_XPos
    //> sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
    floateynumXPos[X] = enemyRelXpos
    //> ExSFN: rts
    return
}

// Decompiled from EnemiesCollision
fun enemiesCollision(X: Int, Y: Int) {
    val clearBitsMask by MemoryByteIndexed(ClearBitsMask)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyCollisionbits by MemoryByteIndexed(Enemy_CollisionBits)
    val enemyFlag by MemoryByteIndexed(Enemy_Flag)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val setBitsMask by MemoryByteIndexed(SetBitsMask)
    //> ExSFN: rts
    return
}

// Decompiled from ProcEnemyCollisions
fun procEnemyCollisions(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val shellChainCounter by MemoryByteIndexed(ShellChainCounter)
    //> ProcEnemyCollisions:
    //> lda Enemy_State,y        ;check both enemy states for d5 set
    //> ora Enemy_State,x
    temp0 = enemyState[Y] or enemyState[X]
    //> and #%00100000           ;if d5 is set in either state, or both, branch
    temp1 = temp0 and 0x20
    //> bne ExitProcessEColl     ;to leave and do nothing else at this point
    temp2 = temp1
    if (temp1 == 0) {
        //> lda Enemy_State,x
        temp2 = enemyState[X]
        //> cmp #$06                 ;if second enemy state < $06, branch elsewhere
        //> bcc ProcSecondEnemyColl
        if (temp2 >= 0x06) {
            //> lda Enemy_ID,x           ;check second enemy identifier for hammer bro
            temp2 = enemyId[X]
            //> cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
            //> beq ExitProcessEColl
            if (temp2 != HammerBro) {
                //> lda Enemy_State,y        ;check first enemy state for d7 set
                temp2 = enemyState[Y]
                //> asl
                temp2 = (temp2 shl 1) and 0xFF
                //> bcc ShellCollisions      ;branch if d7 is clear
                if ((temp2 and 0x80) != 0) {
                    //> lda #$06
                    temp2 = 0x06
                    //> jsr SetupFloateyNumber   ;award 1000 points for killing enemy
                    setupFloateyNumber(temp2, X)
                    //> jsr ShellOrBlockDefeat   ;then kill enemy, then load
                    shellOrBlockDefeat(X)
                    //> ldy $01                  ;original offset of second enemy
                }
                //> ShellCollisions:
                //> tya                      ;move Y to X
                //> tax
                //> jsr ShellOrBlockDefeat   ;kill second enemy
                shellOrBlockDefeat(Y)
                //> ldx ObjectOffset
                //> lda ShellChainCounter,x  ;get chain counter for shell
                temp2 = shellChainCounter[objectOffset]
                //> clc
                //> adc #$04                 ;add four to get appropriate point offset
                temp3 = temp2 + 0x04
                temp2 = temp3 and 0xFF
                //> ldx $01
                //> jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
                setupFloateyNumber(temp2, memory[0x1].toInt())
                //> ldx ObjectOffset         ;load original offset of first enemy
                //> inc ShellChainCounter,x  ;increment chain counter for additional enemies
                shellChainCounter[objectOffset] = (shellChainCounter[objectOffset] + 1) and 0xFF
            }
        }
    }
    //> ExitProcessEColl:
    //> rts                      ;leave!!!
    return
}

// Decompiled from EnemyTurnAround
fun enemyTurnAround(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    //> EnemyTurnAround:
    //> lda Enemy_ID,x           ;check for specific enemies
    //> cmp #PiranhaPlant
    //> beq ExTA                 ;if piranha plant, leave
    temp0 = enemyId[X]
    if (enemyId[X] != PiranhaPlant) {
        //> cmp #Lakitu
        //> beq ExTA                 ;if lakitu, leave
        if (temp0 != Lakitu) {
            //> cmp #HammerBro
            //> beq ExTA                 ;if hammer bro, leave
            if (temp0 != HammerBro) {
                //> cmp #Spiny
                //> beq RXSpd                ;if spiny, turn it around
                if (temp0 != Spiny) {
                    //> cmp #GreenParatroopaJump
                    //> beq RXSpd                ;if green paratroopa, turn it around
                    if (temp0 != GreenParatroopaJump) {
                        //> cmp #$07
                        //> bcs ExTA                 ;if any OTHER enemy object => $07, leave
                        if (!(temp0 >= 0x07)) {
                        } else {
                            //> ExTA:  rts                      ;leave!!!
                            return
                        }
                    }
                }
                //> RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
                temp0 = enemyXSpeed[X]
                //> eor #$ff                 ;get two's compliment for horizontal speed
                temp1 = temp0 xor 0xFF
                //> tay
                //> iny
                temp1 = (temp1 + 1) and 0xFF
                //> sty Enemy_X_Speed,x      ;store as new horizontal speed
                enemyXSpeed[X] = temp1
                //> lda Enemy_MovingDir,x
                temp0 = enemyMovingdir[X]
                //> eor #%00000011           ;invert moving direction and store, then leave
                temp2 = temp0 xor 0x03
                //> sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
                enemyMovingdir[X] = temp2
            }
        }
    }
}

// Decompiled from LargePlatformCollision
fun largePlatformCollision(X: Int) {
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> LargePlatformCollision:
    //> lda #$ff                     ;save value here
    //> sta PlatformCollisionFlag,x
    platformCollisionFlag[X] = 0xFF
    //> lda TimerControl             ;check master timer control
    //> bne ExLPC                    ;if set, branch to leave
    if (!(timerControl == 0)) {
        //  goto ExLPC
        return
    }
    temp0 = timerControl
    if (timerControl == 0) {
        //> lda Enemy_State,x            ;if d7 set in object state,
        temp0 = enemyState[X]
        //> bmi ExLPC                    ;branch to leave
        if ((temp0 and 0x80) != 0) {
            //  goto ExLPC
            return
        }
        if ((temp0 and 0x80) == 0) {
            //> lda Enemy_ID,x
            temp0 = enemyId[X]
            //> cmp #$24                     ;check enemy object identifier for
            //> bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
            if (!(temp0 - 0x24 == 0)) {
                //  goto ChkForPlayerC_LargeP
                return
            }
            //> lda Enemy_State,x
            temp0 = enemyState[X]
            //> tax                          ;set state as enemy offset here
            //> jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
            chkforplayercLargep(temp0)
        }
    }
    //> ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
    //> rts
    return
}

// Decompiled from ChkForPlayerC_LargeP
fun chkforplayercLargep(X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ChkForPlayerC_LargeP:
    //> jsr CheckPlayerVertical      ;figure out if player is below a certain point
    checkPlayerVertical()
    //> bcs ExLPC                    ;or offscreen, branch to leave if true
    if (!flagC) {
        //> txa
        //> jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
        getEnemyBoundBoxOfsArg(X)
        //> lda Enemy_Y_Position,x       ;store vertical coordinate in
        //> sta $00                      ;temp variable for now
        memory[0x0] = (enemyYPosition[X] and 0xFF).toUByte()
        //> txa                          ;send offset we're on to the stack
        //> pha
        push(X)
        //> jsr PlayerCollisionCore      ;do player-to-platform collision detection
        playerCollisionCore()
        //> pla                          ;retrieve offset from the stack
        temp0 = pull()
        //> tax
        //> bcc ExLPC                    ;if no collision, branch to leave
        temp1 = temp0
        temp2 = temp0
        if (flagC) {
            //> jsr ProcLPlatCollisions      ;otherwise collision, perform sub
            procLPlatCollisions(temp2, Y)
        }
    }
    //> ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
    temp2 = objectOffset
    //> rts
    return
}

// Decompiled from SmallPlatformCollision
fun smallPlatformCollision(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val boundingboxDrYpos by MemoryByteIndexed(BoundingBox_DR_YPos)
    val boundingboxUlYpos by MemoryByteIndexed(BoundingBox_UL_YPos)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> SmallPlatformCollision:
    //> lda TimerControl             ;if master timer control set,
    //> bne ExSPC                    ;branch to leave
    temp0 = timerControl
    if (timerControl == 0) {
        //> sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
        platformCollisionFlag[X] = temp0
        //> jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
        checkPlayerVertical()
        //> bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
        if (!flagC) {
            //> lda #$02
            temp0 = 0x02
            //> sta $00                      ;load counter here for 2 bounding boxes
            memory[0x0] = temp0.toUByte()
            while (memory[0x0].toInt() != 0) {
                //> lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
                temp0 = boundingboxUlYpos[Y]
                //> cmp #$20                   ;above a specific point
                //> bcc MoveBoundBox           ;if so, branch, don't do collision detection
                if (temp0 >= 0x20) {
                    //> jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
                    playerCollisionCore()
                    //> bcs ProcSPlatCollisions    ;skip ahead if collision
                    if (!(temp0 >= 0x20)) {
                    }
                }
                //> MoveBoundBox:
                //> lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
                temp0 = boundingboxUlYpos[Y]
                //> clc                        ;128 pixels downwards
                //> adc #$80
                temp1 = temp0 + 0x80
                temp0 = temp1 and 0xFF
                //> sta BoundingBox_UL_YPos,y
                boundingboxUlYpos[Y] = temp0
                //> lda BoundingBox_DR_YPos,y
                temp0 = boundingboxDrYpos[Y]
                //> clc
                //> adc #$80
                temp2 = temp0 + 0x80
                temp0 = temp2 and 0xFF
                //> sta BoundingBox_DR_YPos,y
                boundingboxDrYpos[Y] = temp0
                //> dec $00                    ;decrement counter we set earlier
                memory[0x0] = ((memory[0x0].toInt() - 1) and 0xFF).toUByte()
                //> bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
            }
        }
    }
    //> ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
    //> rts
    return
}

// Decompiled from ProcLPlatCollisions
fun procLPlatCollisions(X: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var playerState by MemoryByte(Player_State)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxDrYpos by MemoryByteIndexed(BoundingBox_DR_YPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val boundingboxUlYpos by MemoryByteIndexed(BoundingBox_UL_YPos)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val platformCollisionFlag by MemoryByteIndexed(PlatformCollisionFlag)
    //> ProcLPlatCollisions:
    //> lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
    //> sec                          ;of the player's bounding box from the bottom
    //> sbc BoundingBox_UL_YPos      ;of the platform's bounding box
    temp0 = boundingboxDrYpos[Y] - boundingboxUlYpos[0]
    //> cmp #$04                     ;if difference too large or negative,
    //> bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
    temp1 = temp0 and 0xFF
    if (!((temp0 and 0xFF) >= 0x04)) {
        //> lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
        temp1 = playerYSpeed
        //> bpl ChkForTopCollision       ;if so, don't mess with it
        if ((temp1 and 0x80) != 0) {
            //> lda #$01                     ;otherwise, set vertical
            temp1 = 0x01
            //> sta Player_Y_Speed           ;speed of player to kill jump
            playerYSpeed = temp1
        }
    }
    //> ChkForTopCollision:
    //> lda BoundingBox_DR_YPos      ;get difference by subtracting the top
    temp1 = boundingboxDrYpos[0]
    //> sec                          ;of the platform's bounding box from the bottom
    //> sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
    temp2 = temp1 - boundingboxUlYpos[Y]
    temp1 = temp2 and 0xFF
    //> cmp #$06
    //> bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
    if (!(temp1 >= 0x06)) {
        //> lda Player_Y_Speed
        temp1 = playerYSpeed
        //> bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
        if ((temp1 and 0x80) == 0) {
            //> lda $00                      ;get saved bounding box counter from earlier
            temp1 = memory[0x0].toInt()
            //> ldy Enemy_ID,x
            //> cpy #$2b                     ;if either of the two small platform objects are found,
            //> beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
            temp3 = enemyId[X]
            if (enemyId[X] != 0x2B) {
                //> cpy #$2c                     ;as contents of collision flag
                //> beq SetCollisionFlag
                if (temp3 != 0x2C) {
                    //> txa                          ;otherwise use enemy object buffer offset
                }
            }
            //> SetCollisionFlag:
            //> ldx ObjectOffset             ;get enemy object buffer offset
            //> sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
            platformCollisionFlag[objectOffset] = temp1
            //> lda #$00
            temp1 = 0x00
            //> sta Player_State             ;set player state to normal then leave
            playerState = temp1
            //> rts
            return
        }
    }
    //> PlatformSideCollisions:
    //> lda #$01                   ;set value here to indicate possible horizontal
    temp1 = 0x01
    //> sta $00                    ;collision on left side of platform
    memory[0x0] = temp1.toUByte()
    //> lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
    temp1 = boundingboxDrXpos[0]
    //> sec                        ;from player's right edge
    //> sbc BoundingBox_UL_XPos,y
    temp4 = temp1 - boundingboxUlXpos[temp3]
    temp1 = temp4 and 0xFF
    //> cmp #$08                   ;if difference close enough, skip all of this
    //> bcc SideC
    if (temp1 >= 0x08) {
        //> inc $00                    ;otherwise increment value set here for right side collision
        memory[0x0] = ((memory[0x0].toInt() + 1) and 0xFF).toUByte()
        //> lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
        temp1 = boundingboxDrXpos[temp3]
        //> clc                        ;from platform's right edge
        //> sbc BoundingBox_UL_XPos
        temp5 = temp1 - boundingboxUlXpos[0] - 1
        temp1 = temp5 and 0xFF
        //> cmp #$09                   ;if difference not close enough, skip subroutine
        //> bcs NoSideC                ;and instead branch to leave (no collision)
        if (!(temp1 >= 0x09)) {
        } else {
            //> NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
            //> rts
            return
        }
    }
    //> SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
    impedePlayerMove()
}

// Decompiled from PositionPlayerOnS_Plat
fun positionplayeronsPlat(A: Int, X: Int) {
    var temp0: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val playerPosSPlatData by MemoryByteIndexed(PlayerPosSPlatData)
    //> PositionPlayerOnS_Plat:
    //> tay                        ;use bounding box counter saved in collision flag
    //> lda Enemy_Y_Position,x     ;for offset
    //> clc                        ;add positioning data using offset to the vertical
    //> adc PlayerPosSPlatData-1,y ;coordinate
    temp0 = enemyYPosition[X] + playerPosSPlatData[-1 + A]
    //> .db $2c                    ;BIT instruction opcode
    // Fall-through tail call to positionPlayerOnVPlat
    positionPlayerOnVPlat(X)
}

// Decompiled from PositionPlayerOnVPlat
fun positionPlayerOnVPlat(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYMoveforce by MemoryByte(Player_Y_MoveForce)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> PositionPlayerOnVPlat:
    //> lda Enemy_Y_Position,x    ;get vertical coordinate
    //> ldy GameEngineSubroutine
    //> cpy #$0b                  ;if certain routine being executed on this frame,
    //> beq ExPlPos               ;skip all of this
    temp0 = enemyYPosition[X]
    temp1 = gameEngineSubroutine
    if (gameEngineSubroutine != 0x0B) {
        //> ldy Enemy_Y_HighPos,x
        temp1 = enemyYHighpos[X]
        //> cpy #$01                  ;if vertical high byte offscreen, skip this
        //> bne ExPlPos
        if (temp1 == 0x01) {
            //> sec                       ;subtract 32 pixels from vertical coordinate
            //> sbc #$20                  ;for the player object's height
            temp2 = temp0 - 0x20
            temp0 = temp2 and 0xFF
            //> sta Player_Y_Position     ;save as player's new vertical coordinate
            playerYPosition = temp0
            //> tya
            //> sbc #$00                  ;subtract borrow and store as player's
            temp3 = temp1 - (if (temp2 >= 0) 0 else 1)
            temp0 = temp3 and 0xFF
            //> sta Player_Y_HighPos      ;new vertical high byte
            playerYHighpos = temp0
            //> lda #$00
            temp0 = 0x00
            //> sta Player_Y_Speed        ;initialize vertical speed and low byte of force
            playerYSpeed = temp0
            //> sta Player_Y_MoveForce    ;and then leave
            playerYMoveforce = temp0
        }
    }
    //> ExPlPos: rts
    return
}

// Decompiled from CheckPlayerVertical
fun checkPlayerVertical() {
    var temp0: Int = 0
    var temp1: Int = 0
    var playerOffscreenbits by MemoryByte(Player_OffscreenBits)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    //> CheckPlayerVertical:
    //> lda Player_OffscreenBits  ;if player object is completely offscreen
    //> cmp #$f0                  ;vertically, leave this routine
    //> bcs ExCPV
    temp0 = playerOffscreenbits
    if (!(playerOffscreenbits >= 0xF0)) {
        //> ldy Player_Y_HighPos      ;if player high vertical byte is not
        //> dey                       ;within the screen, leave this routine
        playerYHighpos = (playerYHighpos - 1) and 0xFF
        //> bne ExCPV
        temp1 = playerYHighpos
        if (playerYHighpos == 0) {
            //> lda Player_Y_Position     ;if on the screen, check to see how far down
            temp0 = playerYPosition
            //> cmp #$d0                  ;the player is vertically
        }
    }
    //> ExCPV: rts
    return
}

// Decompiled from GetEnemyBoundBoxOfs
fun getEnemyBoundBoxOfs(): Int {
    var objectOffset by MemoryByte(ObjectOffset)
    //> GetEnemyBoundBoxOfs:
    //> lda ObjectOffset         ;get enemy object buffer offset
    // Fall-through tail call to getEnemyBoundBoxOfsArg
    getEnemyBoundBoxOfsArg(objectOffset)
    return A
}

// Decompiled from GetEnemyBoundBoxOfsArg
fun getEnemyBoundBoxOfsArg(A: Int) {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    //> GetEnemyBoundBoxOfsArg:
    //> asl                      ;multiply A by four, then add four
    A = (A shl 1) and 0xFF
    //> asl                      ;to skip player's bounding box
    A = (A shl 1) and 0xFF
    //> clc
    //> adc #$04
    temp0 = A + 0x04
    //> tay                      ;send to Y
    //> lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
    //> and #%00001111           ;save low nybble
    temp1 = enemyOffscreenbits and 0x0F
    //> cmp #%00001111           ;check for all bits set
    //> rts
    return
}

// Decompiled from PlayerBGCollision
fun playerBGCollision() {
    var temp0: Int = 0
    var temp1: Int = 0
    var disableCollisionDet by MemoryByte(DisableCollisionDet)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerState by MemoryByte(Player_State)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    var playerYPosition by MemoryByte(Player_Y_Position)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    val areaChangeTimerData by MemoryByteIndexed(AreaChangeTimerData)
    val blockBufferAdderData by MemoryByteIndexed(BlockBufferAdderData)
    val climbPLocAdder by MemoryByteIndexed(ClimbPLocAdder)
    val climbXPosAdder by MemoryByteIndexed(ClimbXPosAdder)
    val flagpoleYPosData by MemoryByteIndexed(FlagpoleYPosData)
    val playerBGUpperExtent by MemoryByteIndexed(PlayerBGUpperExtent)
    //> PlayerBGCollision:
    //> lda DisableCollisionDet   ;if collision detection disabled flag set,
    //> bne ExPBGCol              ;branch to leave
    temp0 = disableCollisionDet
    if (disableCollisionDet == 0) {
        //> lda GameEngineSubroutine
        temp0 = gameEngineSubroutine
        //> cmp #$0b                  ;if running routine #11 or $0b
        //> beq ExPBGCol              ;branch to leave
        if (temp0 != 0x0B) {
            //> cmp #$04
            //> bcc ExPBGCol              ;if running routines $00-$03 branch to leave
            if (temp0 >= 0x04) {
                //> lda #$01                  ;load default player state for swimming
                temp0 = 0x01
                //> ldy SwimmingFlag          ;if swimming flag set,
                //> bne SetPSte               ;branch ahead to set default state
                temp1 = swimmingFlag
                if (swimmingFlag == 0) {
                    //> lda Player_State          ;if player in normal state,
                    temp0 = playerState
                    //> beq SetFallS              ;branch to set default state for falling
                    if (temp0 != 0) {
                        //> cmp #$03
                        //> bne ChkOnScr              ;if in any other state besides climbing, skip to next part
                        if (temp0 == 0x03) {
                        }
                    }
                    //> SetFallS: lda #$02                  ;load default player state for falling
                    temp0 = 0x02
                }
                //> SetPSte:  sta Player_State          ;set whatever player state is appropriate
                playerState = temp0
                //> ChkOnScr: lda Player_Y_HighPos
                temp0 = playerYHighpos
                //> cmp #$01                  ;check player's vertical high byte for still on the screen
                //> bne ExPBGCol              ;branch to leave if not
                if (temp0 == 0x01) {
                    //> lda #$ff
                    temp0 = 0xFF
                    //> sta Player_CollisionBits  ;initialize player's collision flag
                    playerCollisionbits = temp0
                    //> lda Player_Y_Position
                    temp0 = playerYPosition
                    //> cmp #$cf                  ;check player's vertical coordinate
                    //> bcc ChkCollSize           ;if not too close to the bottom of screen, continue
                    if (temp0 >= 0xCF) {
                    }
                }
            }
        }
    }
    //> ExPBGCol: rts                       ;otherwise leave
    return
}

// Decompiled from ErACM
fun erACM() {
    //> ErACM: ldy $02             ;load vertical high nybble offset for block buffer
    //> lda #$00            ;load blank metatile
    //> sta ($06),y         ;store to remove old contents from block buffer
    memory[readWord(0x6) + memory[0x2].toInt()] = 0x00.toUByte()
    //> jmp RemoveCoin_Axe  ;update the screen accordingly
}

// Decompiled from ChkInvisibleMTiles
fun chkInvisibleMTiles(A: Int) {
    //> ChkInvisibleMTiles:
    //> cmp #$5f       ;check for hidden coin block
    //> beq ExCInvT    ;branch to leave if found
    if (A != 0x5F) {
        //> cmp #$60       ;check for hidden 1-up block
    }
    //> ExCInvT: rts            ;leave with zero flag set if either found
    return
}

// Decompiled from ChkForLandJumpSpring
fun chkForLandJumpSpring() {
    var A: Int = 0
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var jumpspringForce by MemoryByte(JumpspringForce)
    var jumpspringTimer by MemoryByte(JumpspringTimer)
    var verticalForce by MemoryByte(VerticalForce)
    //> ChkForLandJumpSpring:
    //> jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
    chkJumpspringMetatiles(A)
    //> bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
    if (flagC) {
        //> lda #$70
        //> sta VerticalForce           ;otherwise set vertical movement force for player
        verticalForce = 0x70
        //> lda #$f9
        //> sta JumpspringForce         ;set default jumpspring force
        jumpspringForce = 0xF9
        //> lda #$03
        //> sta JumpspringTimer         ;set jumpspring timer to be used later
        jumpspringTimer = 0x03
        //> lsr
        //> sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
        jumpspringAnimCtrl = 0x03 shr 1
    }
    //> ExCJSp: rts                         ;and leave
    return
}

// Decompiled from ChkJumpspringMetatiles
fun chkJumpspringMetatiles(A: Int) {
    //> ChkJumpspringMetatiles:
    //> cmp #$67      ;check for top jumpspring metatile
    //> beq JSFnd     ;branch to set carry if found
    if (A != 0x67) {
        //> cmp #$68      ;check for bottom jumpspring metatile
        //> clc           ;clear carry flag
        //> bne NoJSFnd   ;branch to use cleared carry if not found
        if (A == 0x68) {
        } else {
            //> NoJSFnd: rts           ;leave
            return
        }
    }
    //> JSFnd:   sec           ;set carry if found
}

// Decompiled from HandlePipeEntry
fun handlePipeEntry() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var altEntranceControl by MemoryByte(AltEntranceControl)
    var areaNumber by MemoryByte(AreaNumber)
    var areaPointer by MemoryByte(AreaPointer)
    var changeAreaTimer by MemoryByte(ChangeAreaTimer)
    var entrancePage by MemoryByte(EntrancePage)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var fetchNewGameTimerFlag by MemoryByte(FetchNewGameTimerFlag)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var hidden1UpFlag by MemoryByte(Hidden1UpFlag)
    var levelNumber by MemoryByte(LevelNumber)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerXPosition by MemoryByte(Player_X_Position)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var upDownButtons by MemoryByte(Up_Down_Buttons)
    var warpZoneControl by MemoryByte(WarpZoneControl)
    var worldNumber by MemoryByte(WorldNumber)
    val areaAddrOffsets by MemoryByteIndexed(AreaAddrOffsets)
    val warpZoneNumbers by MemoryByteIndexed(WarpZoneNumbers)
    val worldAddrOffsets by MemoryByteIndexed(WorldAddrOffsets)
    //> HandlePipeEntry:
    //> lda Up_Down_Buttons       ;check saved controller bits from earlier
    //> and #%00000100            ;for pressing down
    temp0 = upDownButtons and 0x04
    //> beq ExPipeE               ;if not pressing down, branch to leave
    temp1 = temp0
    if (temp0 != 0) {
        //> lda $00
        temp1 = memory[0x0].toInt()
        //> cmp #$11                  ;check right foot metatile for warp pipe right metatile
        //> bne ExPipeE               ;branch to leave if not found
        if (temp1 == 0x11) {
            //> lda $01
            temp1 = memory[0x1].toInt()
            //> cmp #$10                  ;check left foot metatile for warp pipe left metatile
            //> bne ExPipeE               ;branch to leave if not found
            if (temp1 == 0x10) {
                //> lda #$30
                temp1 = 0x30
                //> sta ChangeAreaTimer       ;set timer for change of area
                changeAreaTimer = temp1
                //> lda #$03
                temp1 = 0x03
                //> sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
                gameEngineSubroutine = temp1
                //> lda #Sfx_PipeDown_Injury
                temp1 = Sfx_PipeDown_Injury
                //> sta Square1SoundQueue     ;load pipedown/injury sound
                square1SoundQueue = temp1
                //> lda #%00100000
                temp1 = 0x20
                //> sta Player_SprAttrib      ;set background priority bit in player's attributes
                playerSprattrib = temp1
                //> lda WarpZoneControl       ;check warp zone control
                temp1 = warpZoneControl
                //> beq ExPipeE               ;branch to leave if none found
                if (temp1 != 0) {
                    //> and #%00000011            ;mask out all but 2 LSB
                    temp2 = temp1 and 0x03
                    //> asl
                    temp2 = (temp2 shl 1) and 0xFF
                    //> asl                       ;multiply by four
                    temp2 = (temp2 shl 1) and 0xFF
                    //> tax                       ;save as offset to warp zone numbers (starts at left pipe)
                    //> lda Player_X_Position     ;get player's horizontal position
                    temp1 = playerXPosition
                    //> cmp #$60
                    //> bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
                    temp3 = temp2
                    if (temp1 >= 0x60) {
                        //> inx                       ;otherwise increment for middle pipe
                        temp3 = (temp3 + 1) and 0xFF
                        //> cmp #$a0
                        //> bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
                        if (temp1 >= 0xA0) {
                            //> inx                       ;otherwise increment for last pipe
                            temp3 = (temp3 + 1) and 0xFF
                        }
                    }
                    //> GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
                    //> dey                       ;decrement for use as world number
                    temp4 = warpZoneNumbers[temp3]
                    temp4 = (temp4 - 1) and 0xFF
                    //> sty WorldNumber           ;store as world number and offset
                    worldNumber = temp4
                    //> ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
                    temp3 = worldAddrOffsets[temp4]
                    //> lda AreaAddrOffsets,x     ;get area offset based on world offset
                    temp1 = areaAddrOffsets[temp3]
                    //> sta AreaPointer           ;store area offset here to be used to change areas
                    areaPointer = temp1
                    //> lda #Silence
                    temp1 = Silence
                    //> sta EventMusicQueue       ;silence music
                    eventMusicQueue = temp1
                    //> lda #$00
                    temp1 = 0x00
                    //> sta EntrancePage          ;initialize starting page number
                    entrancePage = temp1
                    //> sta AreaNumber            ;initialize area number used for area address offset
                    areaNumber = temp1
                    //> sta LevelNumber           ;initialize level number used for world display
                    levelNumber = temp1
                    //> sta AltEntranceControl    ;initialize mode of entry
                    altEntranceControl = temp1
                    //> inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
                    hidden1UpFlag = (hidden1UpFlag + 1) and 0xFF
                    //> inc FetchNewGameTimerFlag ;set flag to load new game timer
                    fetchNewGameTimerFlag = (fetchNewGameTimerFlag + 1) and 0xFF
                }
            }
        }
    }
    //> ExPipeE: rts                       ;leave!!!
    return
}

// Decompiled from ImpedePlayerMove
fun impedePlayerMove() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var playerCollisionbits by MemoryByte(Player_CollisionBits)
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var sideCollisionTimer by MemoryByte(SideCollisionTimer)
    //> ImpedePlayerMove:
    //> lda #$00                  ;initialize value here
    //> ldy Player_X_Speed        ;get player's horizontal speed
    //> ldx $00                   ;check value set earlier for
    //> dex                       ;left side collision
    temp0 = memory[0x0].toInt()
    temp0 = (temp0 - 1) and 0xFF
    //> bne RImpd                 ;if right side collision, skip this part
    temp1 = 0x00
    temp2 = playerXSpeed
    if (temp0 == 0) {
        //> inx                       ;return value to X
        temp0 = (temp0 + 1) and 0xFF
        //> cpy #$00                  ;if player moving to the left,
        //> bmi ExIPM                 ;branch to invert bit and leave
        if ((temp0 and 0x80) == 0) {
            //> lda #$ff                  ;otherwise load A with value to be used later
            temp1 = 0xFF
            //> jmp NXSpd                 ;and jump to affect movement
        } else {
            //> ExIPM: txa                       ;invert contents of X
            //> eor #$ff
            temp3 = temp0 xor 0xFF
            //> and Player_CollisionBits  ;mask out bit that was set here
            temp4 = temp3 and playerCollisionbits
            //> sta Player_CollisionBits  ;store to clear bit
            playerCollisionbits = temp4
            //> rts
            return
        }
    } else {
        //> RImpd: ldx #$02                  ;return $02 to X
        temp0 = 0x02
        //> cpy #$01                  ;if player moving to the right,
        //> bpl ExIPM                 ;branch to invert bit and leave
        if ((temp0 and 0x80) != 0) {
            //> lda #$01                  ;otherwise load A with value to be used here
            temp1 = 0x01
        }
    }
    //> NXSpd: ldy #$10
    temp2 = 0x10
    //> sty SideCollisionTimer    ;set timer of some sort
    sideCollisionTimer = temp2
    //> ldy #$00
    temp2 = 0x00
    //> sty Player_X_Speed        ;nullify player's horizontal speed
    playerXSpeed = temp2
    //> cmp #$00                  ;if value set in A not set to $ff,
    //> bpl PlatF                 ;branch ahead, do not decrement Y
    if (temp1 < 0) {
        //> dey                       ;otherwise decrement Y now
        temp2 = (temp2 - 1) and 0xFF
    }
    //> PlatF: sty $00                   ;store Y as high bits of horizontal adder
    memory[0x0] = temp2.toUByte()
    //> clc
    //> adc Player_X_Position     ;add contents of A to player's horizontal
    temp5 = temp1 + playerXPosition
    temp1 = temp5 and 0xFF
    //> sta Player_X_Position     ;position to move player left or right
    playerXPosition = temp1
    //> lda Player_PageLoc
    temp1 = playerPageloc
    //> adc $00                   ;add high bits and carry to
    temp6 = temp1 + memory[0x0].toInt() + (if (temp5 > 0xFF) 1 else 0)
    temp1 = temp6 and 0xFF
    //> sta Player_PageLoc        ;page location if necessary
    playerPageloc = temp1
}

// Decompiled from CheckForSolidMTiles
fun checkForSolidMTiles(A: Int, X: Int) {
    val solidMTileUpperExt by MemoryByteIndexed(SolidMTileUpperExt)
    //> CheckForSolidMTiles:
    //> jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
    getMTileAttrib(A)
    //> cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
    //> rts
    return
}

// Decompiled from CheckForClimbMTiles
fun checkForClimbMTiles(A: Int, X: Int) {
    val climbMTileUpperExt by MemoryByteIndexed(ClimbMTileUpperExt)
    //> CheckForClimbMTiles:
    //> jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
    getMTileAttrib(A)
    //> cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
    //> rts
    return
}

// Decompiled from CheckForCoinMTiles
fun checkForCoinMTiles(A: Int) {
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    //> CheckForCoinMTiles:
    //> cmp #$c2              ;check for regular coin
    //> beq CoinSd            ;branch if found
    if (A != 0xC2) {
        //> cmp #$c3              ;check for underwater coin
        //> beq CoinSd            ;branch if found
        if (A != 0xC3) {
            //> clc                   ;otherwise clear carry and leave
            //> rts
            return
        }
    }
    //> CoinSd:  lda #Sfx_CoinGrab
    //> sta Square2SoundQueue ;load coin grab sound and leave
    square2SoundQueue = Sfx_CoinGrab
    //> rts
    return
}

// Decompiled from GetMTileAttrib
fun getMTileAttrib(A: Int): Int {
    var temp0: Int = 0
    //> GetMTileAttrib:
    //> tay            ;save metatile value into Y
    //> and #%11000000 ;mask out all but 2 MSB
    temp0 = A and 0xC0
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> rol            ;shift and rotate d7-d6 to d1-d0
    temp0 = (temp0 shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0
    //> rol
    temp0 = (temp0 shl 1) and 0xFE or if ((temp0 and 0x80) != 0) 1 else 0
    //> tax            ;use as offset for metatile data
    //> tya            ;get original metatile value back
    //> ExEBG: rts            ;leave
    return A
}

// Decompiled from EnemyToBGCollisionDet
fun enemyToBGCollisionDet(X: Int) {
    val enemyBGCStateData by MemoryByteIndexed(EnemyBGCStateData)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> ExEBG: rts            ;leave
    return
}

// Decompiled from ChkToStunEnemies
fun chkToStunEnemies(A: Int, X: Int) {
    var temp0: Int = 0
    val enemyId by MemoryByteIndexed(Enemy_ID)
    //> ChkToStunEnemies:
    //> cmp #$09                   ;perform many comparisons on enemy object identifier
    //> bcc SetStun
    if (!(A >= 0x09)) {
        //  goto SetStun
        return
    } else {
        //> cmp #$11                   ;if the enemy object identifier is equal to the values
        //> bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
        if (A >= 0x11) {
            //  goto SetStun
            return
        }
    }
    //> cmp #$0a                   ;modified if not any of those values, note that piranha plant will
    //> bcc Demote                 ;always fail this test because A will still have vertical
    if (A >= 0x0A) {
        //> cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
        //> bcc SetStun                ;are only necessary if branching from $d7a1
        if (!(A >= PiranhaPlant)) {
            //  goto SetStun
            return
        }
    }
    //> Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
    temp0 = A and 0x01
    //> sta Enemy_ID,x             ;into green or red koopa troopa to demote them
    enemyId[X] = temp0
    // Fall-through tail call to setStun
    setStun(X)
}

// Decompiled from SetStun
fun setStun(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var areaType by MemoryByte(AreaType)
    val enemyBGCXSpdData by MemoryByteIndexed(EnemyBGCXSpdData)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> SetStun:  lda Enemy_State,x          ;load enemy state
    //> and #%11110000             ;save high nybble
    temp0 = enemyState[X] and 0xF0
    //> ora #%00000010
    temp1 = temp0 or 0x02
    //> sta Enemy_State,x          ;set d1 of enemy state
    enemyState[X] = temp1
    //> dec Enemy_Y_Position,x
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
    enemyYPosition[X] = (enemyYPosition[X] - 1) and 0xFF
    //> lda Enemy_ID,x
    //> cmp #Bloober               ;check for bloober object
    //> beq SetWYSpd
    temp2 = enemyId[X]
    if (enemyId[X] != Bloober) {
        //> lda #$fd                   ;set default vertical speed
        temp2 = 0xFD
        //> ldy AreaType
        //> bne SetNotW                ;if area type not water, set as speed, otherwise
        temp3 = areaType
        if (areaType == 0) {
        }
    }
    //> SetWYSpd: lda #$ff                   ;change the vertical speed
    temp2 = 0xFF
    //> SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
    enemyYSpeed[X] = temp2
    //> ldy #$01
    temp3 = 0x01
    //> jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
    playerEnemyDiff(X)
    //> bpl ChkBBill               ;branch if enemy is to the right of player
    if ((temp3 and 0x80) != 0) {
        //> iny                        ;increment Y if not
        temp3 = (temp3 + 1) and 0xFF
    }
    //> ChkBBill: lda Enemy_ID,x
    temp2 = enemyId[X]
    //> cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
    //> beq NoCDirF
    if (temp2 != BulletBill_CannonVar) {
        //> cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
        //> beq NoCDirF                ;branch if either found, direction does not change
        if (temp2 != BulletBill_FrenzyVar) {
            //> sty Enemy_MovingDir,x      ;store as moving direction
            enemyMovingdir[X] = temp3
        }
    }
    //> NoCDirF:  dey                        ;decrement and use as offset
    temp3 = (temp3 - 1) and 0xFF
    //> lda EnemyBGCXSpdData,y     ;get proper horizontal speed
    temp2 = enemyBGCXSpdData[temp3]
    //> sta Enemy_X_Speed,x        ;and store, then leave
    enemyXSpeed[X] = temp2
    //> ExEBGChk: rts
    return
}

// Decompiled from ChkForBump_HammerBroJ
fun chkforbumpHammerbroj(X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyXSpeed by MemoryByteIndexed(Enemy_X_Speed)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val hammerBroJumpLData by MemoryByteIndexed(HammerBroJumpLData)
    val hammerBroJumpTimer by MemoryByteIndexed(HammerBroJumpTimer)
    val pseudoRandomBitReg by MemoryByteIndexed(PseudoRandomBitReg)
    //> SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
    enemyYSpeed[X] = Y
    //> lda Enemy_State,x           ;set d0 in enemy state for jumping
    //> ora #$01
    temp0 = enemyState[X] or 0x01
    //> sta Enemy_State,x
    enemyState[X] = temp0
    //> lda $00                     ;load preset value here to use as bitmask
    //> and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
    temp1 = memory[0x0].toInt() and pseudoRandomBitReg[2 + X]
    //> tay                         ;then use as offset
    //> lda SecondaryHardMode       ;check secondary hard mode flag
    //> bne HJump
    temp2 = secondaryHardMode
    temp3 = temp1
    if (secondaryHardMode == 0) {
        //> tay                         ;if secondary hard mode flag clear, set offset to 0
    }
    //> HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
    temp2 = hammerBroJumpLData[temp3]
    //> sta EnemyFrameTimer,x       ;save in enemy timer
    enemyFrameTimer[X] = temp2
    //> lda PseudoRandomBitReg+1,x
    temp2 = pseudoRandomBitReg[1 + X]
    //> ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
    temp4 = temp2 or 0xC0
    //> sta HammerBroJumpTimer,x    ;store in jump timer
    hammerBroJumpTimer[X] = temp4
    //> MoveHammerBroXDir:
    //> ldy #$fc                  ;move hammer bro a little to the left
    temp3 = 0xFC
    //> lda FrameCounter
    temp2 = frameCounter
    //> and #%01000000            ;change hammer bro's direction every 64 frames
    temp5 = temp2 and 0x40
    //> bne Shimmy
    temp2 = temp5
    if (temp5 == 0) {
        //> ldy #$04                  ;if d6 set in counter, move him a little to the right
        temp3 = 0x04
    }
    //> Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
    enemyXSpeed[X] = temp3
    //> ldy #$01                  ;set to face right by default
    temp3 = 0x01
    //> jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
    playerEnemyDiff(X)
    //> bmi SetShim               ;if enemy to the left of player, skip this part
    if ((temp3 and 0x80) == 0) {
        //> iny                       ;set to face left
        temp3 = (temp3 + 1) and 0xFF
        //> lda EnemyIntervalTimer,x  ;check walking timer
        temp2 = enemyIntervalTimer[X]
        //> bne SetShim               ;if not yet expired, skip to set moving direction
        if (temp2 == 0) {
            //> lda #$f8
            temp2 = 0xF8
            //> sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
            enemyXSpeed[X] = temp2
        }
    }
    //> SetShim: sty Enemy_MovingDir,x     ;set moving direction
    enemyMovingdir[X] = temp3
    //> RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
    temp2 = enemyXSpeed[X]
    //> eor #$ff                 ;get two's compliment for horizontal speed
    temp6 = temp2 xor 0xFF
    //> tay
    //> iny
    temp6 = (temp6 + 1) and 0xFF
    //> sty Enemy_X_Speed,x      ;store as new horizontal speed
    enemyXSpeed[X] = temp6
    //> lda Enemy_MovingDir,x
    temp2 = enemyMovingdir[X]
    //> eor #%00000011           ;invert moving direction and store, then leave
    temp7 = temp2 xor 0x03
    //> sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
    enemyMovingdir[X] = temp7
    //> ExTA:  rts                      ;leave!!!
    return
}

// Decompiled from PlayerEnemyDiff
fun playerEnemyDiff(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var playerPageloc by MemoryByte(Player_PageLoc)
    var playerXPosition by MemoryByte(Player_X_Position)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    //> PlayerEnemyDiff:
    //> lda Enemy_X_Position,x  ;get distance between enemy object's
    //> sec                     ;horizontal coordinate and the player's
    //> sbc Player_X_Position   ;horizontal coordinate
    temp0 = enemyXPosition[X] - playerXPosition
    //> sta $00                 ;and store here
    memory[0x0] = (temp0 and 0xFF).toUByte()
    //> lda Enemy_PageLoc,x
    //> sbc Player_PageLoc      ;subtract borrow, then leave
    temp1 = enemyPageloc[X] - playerPageloc - (if (temp0 >= 0) 0 else 1)
    //> rts
    return
}

// Decompiled from EnemyLanding
fun enemyLanding(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> EnemyLanding:
    //> jsr InitVStf            ;do something here to vertical speed and something else
    initVStf(X)
    //> lda Enemy_Y_Position,x
    //> and #%11110000          ;save high nybble of vertical coordinate, and
    temp0 = enemyYPosition[X] and 0xF0
    //> ora #%00001000          ;set d3, then store, probably used to set enemy object
    temp1 = temp0 or 0x08
    //> sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
    enemyYPosition[X] = temp1
    //> rts
    return
}

// Decompiled from SubtEnemyYPos
fun subtEnemyYPos(X: Int) {
    var temp0: Int = 0
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    //> SubtEnemyYPos:
    //> lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
    //> clc                     ;vertical coordinate
    //> adc #$3e
    temp0 = enemyYPosition[X] + 0x3E
    //> cmp #$44                ;compare against a certain range
    //> rts                     ;and leave with flags set for conditional branch
    return
}

// Decompiled from EnemyJump
fun enemyJump(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> DoEnemySideCheck:
    //> lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
    //> cmp #$20                   ;because there's nothing there that impedes movement
    //> bcc ExESdeC
    temp0 = enemyYPosition[X]
    if (enemyYPosition[X] >= 0x20) {
        //> ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
        //> lda #$02                   ;set value here in what is also used as
        temp0 = 0x02
        //> sta $eb                    ;OAM data offset
        memory[0xEB] = temp0.toUByte()
        temp1 = 0x16
        do {
            //> SdeCLoop: lda $eb                    ;check value
            temp0 = memory[0xEB].toInt()
            //> cmp Enemy_MovingDir,x      ;compare value against moving direction
            //> bne NextSdeC               ;branch if different and do not seek block there
            if (temp0 == enemyMovingdir[X]) {
                //> lda #$01                   ;set flag in A for save horizontal coordinate
                temp0 = 0x01
                //> jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
                blockbufferchkEnemy(temp0, X)
                //> beq NextSdeC               ;if nothing found, branch
                if (temp0 != 0) {
                    //> jsr ChkForNonSolids        ;check for non-solid blocks
                    chkForNonSolids(temp0)
                    //> bne ChkForBump_HammerBroJ  ;branch if not found
                    if (!(temp0 == 0)) {
                        //  goto ChkForBump_HammerBroJ
                        return
                    }
                }
            }
            //> NextSdeC: dec $eb                    ;move to the next direction
            memory[0xEB] = ((memory[0xEB].toInt() - 1) and 0xFF).toUByte()
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
            //> bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
        } while (!(temp1 >= 0x18))
    }
    //> ExESdeC:  rts
    return
}

// Decompiled from KillEnemyAboveBlock
fun killEnemyAboveBlock(X: Int) {
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    //> KillEnemyAboveBlock:
    //> jsr ShellOrBlockDefeat  ;do this sub to kill enemy
    shellOrBlockDefeat(X)
    //> lda #$fc                ;alter vertical speed of enemy and leave
    //> sta Enemy_Y_Speed,x
    enemyYSpeed[X] = 0xFC
    //> rts
    return
}

// Decompiled from ChkUnderEnemy
fun chkUnderEnemy() {
    //> ChkUnderEnemy:
    //> lda #$00                  ;set flag in A for save vertical coordinate
    //> ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
    //> jmp BlockBufferChk_Enemy  ;hop to it!
}

// Decompiled from ChkForNonSolids
fun chkForNonSolids(A: Int) {
    //> ChkForNonSolids:
    //> cmp #$26       ;blank metatile used for vines?
    //> beq NSFnd
    if (A != 0x26) {
        //> cmp #$c2       ;regular coin?
        //> beq NSFnd
        if (A != 0xC2) {
            //> cmp #$c3       ;underwater coin?
            //> beq NSFnd
            if (A != 0xC3) {
                //> cmp #$5f       ;hidden coin block?
                //> beq NSFnd
                if (A != 0x5F) {
                    //> cmp #$60       ;hidden 1-up block?
                }
            }
        }
    }
    //> NSFnd: rts
    return
}

// Decompiled from FireballBGCollision
fun fireballBGCollision(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val fireballBouncingFlag by MemoryByteIndexed(FireballBouncingFlag)
    val fireballState by MemoryByteIndexed(Fireball_State)
    val fireballYPosition by MemoryByteIndexed(Fireball_Y_Position)
    val fireballYSpeed by MemoryByteIndexed(Fireball_Y_Speed)
    //> FireballBGCollision:
    //> lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
    //> cmp #$18
    //> bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
    temp0 = fireballYPosition[X]
    if (fireballYPosition[X] >= 0x18) {
        //> jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
        blockbufferchkFball(X)
        //> beq ClearBounceFlag         ;if nothing underneath fireball, branch
        if (fireballYPosition[X] != 0x18) {
            //> jsr ChkForNonSolids         ;check for non-solid metatiles
            chkForNonSolids(temp0)
            //> beq ClearBounceFlag         ;branch if any found
            if (fireballYPosition[X] != 0x18) {
                //> lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
                temp0 = fireballYSpeed[X]
                //> bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
                if ((temp0 and 0x80) == 0) {
                    //> lda FireballBouncingFlag,x  ;if bouncing flag already set,
                    temp0 = fireballBouncingFlag[X]
                    //> bne InitFireballExplode     ;branch to set exploding bit in fireball's state
                    if (temp0 == 0) {
                        //> lda #$fd
                        temp0 = 0xFD
                        //> sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
                        fireballYSpeed[X] = temp0
                        //> lda #$01
                        temp0 = 0x01
                        //> sta FireballBouncingFlag,x  ;set bouncing flag
                        fireballBouncingFlag[X] = temp0
                        //> lda Fireball_Y_Position,x
                        temp0 = fireballYPosition[X]
                        //> and #$f8                    ;modify vertical coordinate to land it properly
                        temp1 = temp0 and 0xF8
                        //> sta Fireball_Y_Position,x   ;store as new vertical coordinate
                        fireballYPosition[X] = temp1
                        //> rts                         ;leave
                        return
                    } else {
                        //> InitFireballExplode:
                        //> lda #$80
                        temp0 = 0x80
                        //> sta Fireball_State,x        ;set exploding flag in fireball's state
                        fireballState[X] = temp0
                        //> lda #Sfx_Bump
                        temp0 = Sfx_Bump
                        //> sta Square1SoundQueue       ;load bump sound
                        square1SoundQueue = temp0
                        //> rts                         ;leave
                        return
                    }
                }
            }
        }
    }
    //> ClearBounceFlag:
    //> lda #$00
    temp0 = 0x00
    //> sta FireballBouncingFlag,x  ;clear bouncing flag by default
    fireballBouncingFlag[X] = temp0
    //> rts                         ;leave
    return
}

// Decompiled from GetFireballBoundBox
fun getFireballBoundBox(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    //> GetFireballBoundBox:
    //> txa         ;add seven bytes to offset
    //> clc         ;to use in routines as offset for fireball
    //> adc #$07
    temp0 = X + 0x07
    //> tax
    //> ldy #$02    ;set offset for relative coordinates
    //> bne FBallB  ;unconditional branch
    if (!(0x02 == 0)) {
        //  goto FBallB
        return
    }
    temp1 = temp0 and 0xFF
    temp2 = temp0 and 0xFF
    temp3 = 0x02
    if (0x02 == 0) {
    }
    //> FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
    boundingBoxCore(temp2, temp3)
    //> jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
    //> CheckRightScreenBBox:
    //> lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
    temp1 = screenleftXPos
    //> clc                        ;and store as horizontal coordinate of middle
    //> adc #$80
    temp4 = temp1 + 0x80
    temp1 = temp4 and 0xFF
    //> sta $02
    memory[0x2] = temp1.toUByte()
    //> lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
    temp1 = screenleftPageloc
    //> adc #$00                   ;and store as page location of middle
    temp5 = temp1 + (if (temp4 > 0xFF) 1 else 0)
    temp1 = temp5 and 0xFF
    //> sta $01
    memory[0x1] = temp1.toUByte()
    //> lda SprObject_X_Position,x ;get horizontal coordinate
    temp1 = sprobjectXPosition[temp2]
    //> cmp $02                    ;compare against middle horizontal coordinate
    //> lda SprObject_PageLoc,x    ;get page location
    temp1 = sprobjectPageloc[temp2]
    //> sbc $01                    ;subtract from middle page location
    temp6 = temp1 - memory[0x1].toInt() - (if (temp1 >= memory[0x2].toInt()) 0 else 1)
    temp1 = temp6 and 0xFF
    //> bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
    if (temp6 >= 0) {
        //> lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
        temp1 = boundingboxDrXpos[temp3]
        //> bmi NoOfs                  ;coordinates, branch if still on the screen
        if ((temp1 and 0x80) == 0) {
            //> lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
            temp1 = 0xFF
            //> ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
            temp2 = boundingboxUlXpos[temp3]
            //> bmi SORte                  ;coordinates, and branch if still on the screen
            if ((temp2 and 0x80) == 0) {
                //> sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp3] = temp1
            }
            //> SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
            boundingboxDrXpos[temp3] = temp1
        }
        //> NoOfs: ldx ObjectOffset           ;get object offset and leave
        temp2 = objectOffset
        //> rts
        return
    } else {
        //> CheckLeftScreenBBox:
        //> lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
        temp1 = boundingboxUlXpos[temp3]
        //> bpl NoOfs2                 ;coordinates, and branch if still on the screen
        if ((temp1 and 0x80) != 0) {
            //> cmp #$a0                   ;check to see if left-side edge is in the middle of the
            //> bcc NoOfs2                 ;screen or really offscreen, and branch if still on
            if (temp1 >= 0xA0) {
                //> lda #$00
                temp1 = 0x00
                //> ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
                temp2 = boundingboxDrXpos[temp3]
                //> bpl SOLft                  ;coordinates, branch if still onscreen
                if ((temp2 and 0x80) != 0) {
                    //> sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
                    boundingboxDrXpos[temp3] = temp1
                }
                //> SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp3] = temp1
            }
        }
    }
    //> NoOfs2: ldx ObjectOffset           ;get object offset and leave
    temp2 = objectOffset
    //> rts
    return
}

// Decompiled from GetMiscBoundBox
fun getMiscBoundBox(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    //> GetMiscBoundBox:
    //> txa                       ;add nine bytes to offset
    //> clc                       ;to use in routines as offset for misc object
    //> adc #$09
    temp0 = X + 0x09
    //> tax
    //> ldy #$06                  ;set offset for relative coordinates
    //> FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
    boundingBoxCore(temp0 and 0xFF, 0x06)
    //> jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
    //> CheckRightScreenBBox:
    //> lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
    //> clc                        ;and store as horizontal coordinate of middle
    //> adc #$80
    temp1 = screenleftXPos + 0x80
    //> sta $02
    memory[0x2] = (temp1 and 0xFF).toUByte()
    //> lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
    //> adc #$00                   ;and store as page location of middle
    temp2 = screenleftPageloc + (if (temp1 > 0xFF) 1 else 0)
    //> sta $01
    memory[0x1] = (temp2 and 0xFF).toUByte()
    //> lda SprObject_X_Position,x ;get horizontal coordinate
    //> cmp $02                    ;compare against middle horizontal coordinate
    //> lda SprObject_PageLoc,x    ;get page location
    //> sbc $01                    ;subtract from middle page location
    temp3 = sprobjectPageloc[temp0 and 0xFF] - memory[0x1].toInt() - (if (sprobjectXPosition[temp0 and 0xFF] >= memory[0x2].toInt()) 0 else 1)
    //> bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
    temp4 = temp3 and 0xFF
    temp5 = temp0 and 0xFF
    temp6 = 0x06
    if (temp3 >= 0) {
        //> lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
        temp4 = boundingboxDrXpos[temp6]
        //> bmi NoOfs                  ;coordinates, branch if still on the screen
        if ((temp4 and 0x80) == 0) {
            //> lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
            temp4 = 0xFF
            //> ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
            temp5 = boundingboxUlXpos[temp6]
            //> bmi SORte                  ;coordinates, and branch if still on the screen
            if ((temp5 and 0x80) == 0) {
                //> sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp6] = temp4
            }
            //> SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
            boundingboxDrXpos[temp6] = temp4
        }
        //> NoOfs: ldx ObjectOffset           ;get object offset and leave
        temp5 = objectOffset
        //> rts
        return
    } else {
        //> CheckLeftScreenBBox:
        //> lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
        temp4 = boundingboxUlXpos[temp6]
        //> bpl NoOfs2                 ;coordinates, and branch if still on the screen
        if ((temp4 and 0x80) != 0) {
            //> cmp #$a0                   ;check to see if left-side edge is in the middle of the
            //> bcc NoOfs2                 ;screen or really offscreen, and branch if still on
            if (temp4 >= 0xA0) {
                //> lda #$00
                temp4 = 0x00
                //> ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
                temp5 = boundingboxDrXpos[temp6]
                //> bpl SOLft                  ;coordinates, branch if still onscreen
                if ((temp5 and 0x80) != 0) {
                    //> sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
                    boundingboxDrXpos[temp6] = temp4
                }
                //> SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp6] = temp4
            }
        }
    }
    //> NoOfs2: ldx ObjectOffset           ;get object offset and leave
    temp5 = objectOffset
    //> rts
    return
}

// Decompiled from GetEnemyBoundBox
fun getEnemyBoundBox(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var objectOffset by MemoryByte(ObjectOffset)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val enemyBoundingBoxCoord by MemoryByteIndexed(EnemyBoundingBoxCoord)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    //> GetEnemyBoundBox:
    //> ldy #$48                 ;store bitmask here for now
    //> sty $00
    memory[0x0] = 0x48.toUByte()
    //> ldy #$44                 ;store another bitmask here for now and jump
    //> jmp GetMaskedOffScrBits
    //> GetMaskedOffScrBits:
    //> lda Enemy_X_Position,x      ;get enemy object position relative
    //> sec                         ;to the left side of the screen
    //> sbc ScreenLeft_X_Pos
    temp0 = enemyXPosition[X] - screenleftXPos
    //> sta $01                     ;store here
    memory[0x1] = (temp0 and 0xFF).toUByte()
    //> lda Enemy_PageLoc,x         ;subtract borrow from current page location
    //> sbc ScreenLeft_PageLoc      ;of left side
    temp1 = enemyPageloc[X] - screenleftPageloc - (if (temp0 >= 0) 0 else 1)
    //> bmi CMBits                  ;if enemy object is beyond left edge, branch
    temp2 = temp1 and 0xFF
    temp3 = 0x44
    if ((temp1 and 0xFF and 0x80) == 0) {
        //> ora $01
        temp4 = temp2 or memory[0x1].toInt()
        //> beq CMBits                  ;if precisely at the left edge, branch
        temp2 = temp4
        if (temp4 != 0) {
            //> ldy $00                     ;if to the right of left edge, use value in $00 for A
            temp3 = memory[0x0].toInt()
        }
    }
    //> CMBits: tya                         ;otherwise use contents of Y
    //> and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
    temp5 = temp3 and enemyOffscreenbits
    //> sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
    enemyOffscrBitsMasked[X] = temp5
    //> bne MoveBoundBoxOffscreen   ;if anything set here, branch
    temp2 = temp5
    if (temp5 == 0) {
        //> jmp SetupEOffsetFBBox       ;otherwise, do something else
        //> SetupEOffsetFBBox:
        //> txa                        ;add 1 to offset to properly address
        //> clc                        ;the enemy object memory locations
        //> adc #$01
        temp6 = X + 0x01
        temp2 = temp6 and 0xFF
        //> tax
        //> ldy #$01                   ;load 1 as offset here, same reason
        temp3 = 0x01
        //> jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
        boundingBoxCore(temp2, temp3)
        //> jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
    } else {
        //> MoveBoundBoxOffscreen:
        //> txa                            ;multiply offset by 4
        //> asl
        X = (X shl 1) and 0xFF
        //> asl
        X = (X shl 1) and 0xFF
        //> tay                            ;use as offset here
        //> lda #$ff
        temp2 = 0xFF
        //> sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
        enemyBoundingBoxCoord[X] = temp2
        //> sta EnemyBoundingBoxCoord+1,y
        enemyBoundingBoxCoord[1 + X] = temp2
        //> sta EnemyBoundingBoxCoord+2,y
        enemyBoundingBoxCoord[2 + X] = temp2
        //> sta EnemyBoundingBoxCoord+3,y
        enemyBoundingBoxCoord[3 + X] = temp2
        //> rts
        return
    }
    //> CheckRightScreenBBox:
    //> lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
    temp2 = screenleftXPos
    //> clc                        ;and store as horizontal coordinate of middle
    //> adc #$80
    temp7 = temp2 + 0x80
    temp2 = temp7 and 0xFF
    //> sta $02
    memory[0x2] = temp2.toUByte()
    //> lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
    temp2 = screenleftPageloc
    //> adc #$00                   ;and store as page location of middle
    temp8 = temp2 + (if (temp7 > 0xFF) 1 else 0)
    temp2 = temp8 and 0xFF
    //> sta $01
    memory[0x1] = temp2.toUByte()
    //> lda SprObject_X_Position,x ;get horizontal coordinate
    temp2 = sprobjectXPosition[X]
    //> cmp $02                    ;compare against middle horizontal coordinate
    //> lda SprObject_PageLoc,x    ;get page location
    temp2 = sprobjectPageloc[X]
    //> sbc $01                    ;subtract from middle page location
    temp9 = temp2 - memory[0x1].toInt() - (if (temp2 >= memory[0x2].toInt()) 0 else 1)
    temp2 = temp9 and 0xFF
    //> bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
    if (temp9 >= 0) {
        //> lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
        temp2 = boundingboxDrXpos[temp3]
        //> bmi NoOfs                  ;coordinates, branch if still on the screen
        if ((temp2 and 0x80) == 0) {
            //> lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
            temp2 = 0xFF
            //> ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
            //> bmi SORte                  ;coordinates, and branch if still on the screen
            temp10 = boundingboxUlXpos[temp3]
            if ((boundingboxUlXpos[temp3] and 0x80) == 0) {
                //> sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp3] = temp2
            }
            //> SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
            boundingboxDrXpos[temp3] = temp2
        }
        //> NoOfs: ldx ObjectOffset           ;get object offset and leave
        temp10 = objectOffset
        //> rts
        return
    } else {
        //> CheckLeftScreenBBox:
        //> lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
        temp2 = boundingboxUlXpos[temp3]
        //> bpl NoOfs2                 ;coordinates, and branch if still on the screen
        if ((temp2 and 0x80) != 0) {
            //> cmp #$a0                   ;check to see if left-side edge is in the middle of the
            //> bcc NoOfs2                 ;screen or really offscreen, and branch if still on
            if (temp2 >= 0xA0) {
                //> lda #$00
                temp2 = 0x00
                //> ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
                temp10 = boundingboxDrXpos[temp3]
                //> bpl SOLft                  ;coordinates, branch if still onscreen
                if ((temp10 and 0x80) != 0) {
                    //> sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
                    boundingboxDrXpos[temp3] = temp2
                }
                //> SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp3] = temp2
            }
        }
    }
    //> NoOfs2: ldx ObjectOffset           ;get object offset and leave
    temp10 = objectOffset
    //> rts
    return
}

// Decompiled from SmallPlatformBoundBox
fun smallPlatformBoundBox(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var objectOffset by MemoryByte(ObjectOffset)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val enemyBoundingBoxCoord by MemoryByteIndexed(EnemyBoundingBoxCoord)
    val enemyOffscrBitsMasked by MemoryByteIndexed(EnemyOffscrBitsMasked)
    val enemyPageloc by MemoryByteIndexed(Enemy_PageLoc)
    val enemyXPosition by MemoryByteIndexed(Enemy_X_Position)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    //> SmallPlatformBoundBox:
    //> ldy #$08                 ;store bitmask here for now
    //> sty $00
    memory[0x0] = 0x08.toUByte()
    //> ldy #$04                 ;store another bitmask here for now
    //> GetMaskedOffScrBits:
    //> lda Enemy_X_Position,x      ;get enemy object position relative
    //> sec                         ;to the left side of the screen
    //> sbc ScreenLeft_X_Pos
    temp0 = enemyXPosition[X] - screenleftXPos
    //> sta $01                     ;store here
    memory[0x1] = (temp0 and 0xFF).toUByte()
    //> lda Enemy_PageLoc,x         ;subtract borrow from current page location
    //> sbc ScreenLeft_PageLoc      ;of left side
    temp1 = enemyPageloc[X] - screenleftPageloc - (if (temp0 >= 0) 0 else 1)
    //> bmi CMBits                  ;if enemy object is beyond left edge, branch
    temp2 = temp1 and 0xFF
    temp3 = 0x04
    if ((temp1 and 0xFF and 0x80) == 0) {
        //> ora $01
        temp4 = temp2 or memory[0x1].toInt()
        //> beq CMBits                  ;if precisely at the left edge, branch
        temp2 = temp4
        if (temp4 != 0) {
            //> ldy $00                     ;if to the right of left edge, use value in $00 for A
            temp3 = memory[0x0].toInt()
        }
    }
    //> CMBits: tya                         ;otherwise use contents of Y
    //> and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
    temp5 = temp3 and enemyOffscreenbits
    //> sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
    enemyOffscrBitsMasked[X] = temp5
    //> bne MoveBoundBoxOffscreen   ;if anything set here, branch
    temp2 = temp5
    if (temp5 == 0) {
        //> jmp SetupEOffsetFBBox       ;otherwise, do something else
        //> SetupEOffsetFBBox:
        //> txa                        ;add 1 to offset to properly address
        //> clc                        ;the enemy object memory locations
        //> adc #$01
        temp6 = X + 0x01
        temp2 = temp6 and 0xFF
        //> tax
        //> ldy #$01                   ;load 1 as offset here, same reason
        temp3 = 0x01
        //> jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
        boundingBoxCore(temp2, temp3)
        //> jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
    } else {
        //> MoveBoundBoxOffscreen:
        //> txa                            ;multiply offset by 4
        //> asl
        X = (X shl 1) and 0xFF
        //> asl
        X = (X shl 1) and 0xFF
        //> tay                            ;use as offset here
        //> lda #$ff
        temp2 = 0xFF
        //> sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
        enemyBoundingBoxCoord[X] = temp2
        //> sta EnemyBoundingBoxCoord+1,y
        enemyBoundingBoxCoord[1 + X] = temp2
        //> sta EnemyBoundingBoxCoord+2,y
        enemyBoundingBoxCoord[2 + X] = temp2
        //> sta EnemyBoundingBoxCoord+3,y
        enemyBoundingBoxCoord[3 + X] = temp2
        //> rts
        return
    }
    //> CheckRightScreenBBox:
    //> lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
    temp2 = screenleftXPos
    //> clc                        ;and store as horizontal coordinate of middle
    //> adc #$80
    temp7 = temp2 + 0x80
    temp2 = temp7 and 0xFF
    //> sta $02
    memory[0x2] = temp2.toUByte()
    //> lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
    temp2 = screenleftPageloc
    //> adc #$00                   ;and store as page location of middle
    temp8 = temp2 + (if (temp7 > 0xFF) 1 else 0)
    temp2 = temp8 and 0xFF
    //> sta $01
    memory[0x1] = temp2.toUByte()
    //> lda SprObject_X_Position,x ;get horizontal coordinate
    temp2 = sprobjectXPosition[X]
    //> cmp $02                    ;compare against middle horizontal coordinate
    //> lda SprObject_PageLoc,x    ;get page location
    temp2 = sprobjectPageloc[X]
    //> sbc $01                    ;subtract from middle page location
    temp9 = temp2 - memory[0x1].toInt() - (if (temp2 >= memory[0x2].toInt()) 0 else 1)
    temp2 = temp9 and 0xFF
    //> bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
    if (temp9 >= 0) {
        //> lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
        temp2 = boundingboxDrXpos[temp3]
        //> bmi NoOfs                  ;coordinates, branch if still on the screen
        if ((temp2 and 0x80) == 0) {
            //> lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
            temp2 = 0xFF
            //> ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
            //> bmi SORte                  ;coordinates, and branch if still on the screen
            temp10 = boundingboxUlXpos[temp3]
            if ((boundingboxUlXpos[temp3] and 0x80) == 0) {
                //> sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp3] = temp2
            }
            //> SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
            boundingboxDrXpos[temp3] = temp2
        }
        //> NoOfs: ldx ObjectOffset           ;get object offset and leave
        temp10 = objectOffset
        //> rts
        return
    } else {
        //> CheckLeftScreenBBox:
        //> lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
        temp2 = boundingboxUlXpos[temp3]
        //> bpl NoOfs2                 ;coordinates, and branch if still on the screen
        if ((temp2 and 0x80) != 0) {
            //> cmp #$a0                   ;check to see if left-side edge is in the middle of the
            //> bcc NoOfs2                 ;screen or really offscreen, and branch if still on
            if (temp2 >= 0xA0) {
                //> lda #$00
                temp2 = 0x00
                //> ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
                temp10 = boundingboxDrXpos[temp3]
                //> bpl SOLft                  ;coordinates, branch if still onscreen
                if ((temp10 and 0x80) != 0) {
                    //> sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
                    boundingboxDrXpos[temp3] = temp2
                }
                //> SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[temp3] = temp2
            }
        }
    }
    //> NoOfs2: ldx ObjectOffset           ;get object offset and leave
    temp10 = objectOffset
    //> rts
    return
}

// Decompiled from LargePlatformBoundBox
fun largePlatformBoundBox(A: Int, X: Int) {
    var X: Int = X
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    var screenleftPageloc by MemoryByte(ScreenLeft_PageLoc)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val boundingboxDrXpos by MemoryByteIndexed(BoundingBox_DR_XPos)
    val boundingboxUlXpos by MemoryByteIndexed(BoundingBox_UL_XPos)
    val enemyBoundingBoxCoord by MemoryByteIndexed(EnemyBoundingBoxCoord)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    //> LargePlatformBoundBox:
    //> inx                        ;increment X to get the proper offset
    X = (X + 1) and 0xFF
    //> jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
    getXOffscreenBits(X)
    //> dex                        ;decrement to return to original offset
    X = (X - 1) and 0xFF
    //> cmp #$fe                   ;if completely offscreen, branch to put entire bounding
    //> bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
    if (A >= 0xFE) {
        //  goto MoveBoundBoxOffscreen
        return
    }
    if (!(A >= 0xFE)) {
        //> SetupEOffsetFBBox:
        //> txa                        ;add 1 to offset to properly address
        //> clc                        ;the enemy object memory locations
        //> adc #$01
        temp0 = X + 0x01
        //> tax
        //> ldy #$01                   ;load 1 as offset here, same reason
        //> jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
        boundingBoxCore(temp0 and 0xFF, 0x01)
        //> jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
    } else {
        //> MoveBoundBoxOffscreen:
        //> txa                            ;multiply offset by 4
        //> asl
        X = (X shl 1) and 0xFF
        //> asl
        X = (X shl 1) and 0xFF
        //> tay                            ;use as offset here
        //> lda #$ff
        //> sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
        enemyBoundingBoxCoord[X] = 0xFF
        //> sta EnemyBoundingBoxCoord+1,y
        enemyBoundingBoxCoord[1 + X] = 0xFF
        //> sta EnemyBoundingBoxCoord+2,y
        enemyBoundingBoxCoord[2 + X] = 0xFF
        //> sta EnemyBoundingBoxCoord+3,y
        enemyBoundingBoxCoord[3 + X] = 0xFF
        //> rts
        return
    }
    //> CheckRightScreenBBox:
    //> lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
    //> clc                        ;and store as horizontal coordinate of middle
    //> adc #$80
    temp1 = screenleftXPos + 0x80
    //> sta $02
    memory[0x2] = (temp1 and 0xFF).toUByte()
    //> lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
    //> adc #$00                   ;and store as page location of middle
    temp2 = screenleftPageloc + (if (temp1 > 0xFF) 1 else 0)
    //> sta $01
    memory[0x1] = (temp2 and 0xFF).toUByte()
    //> lda SprObject_X_Position,x ;get horizontal coordinate
    //> cmp $02                    ;compare against middle horizontal coordinate
    //> lda SprObject_PageLoc,x    ;get page location
    //> sbc $01                    ;subtract from middle page location
    temp3 = sprobjectPageloc[X] - memory[0x1].toInt() - (if (sprobjectXPosition[X] >= memory[0x2].toInt()) 0 else 1)
    //> bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
    temp4 = temp3 and 0xFF
    if (temp3 >= 0) {
        //> lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
        temp4 = boundingboxDrXpos[Y]
        //> bmi NoOfs                  ;coordinates, branch if still on the screen
        if ((temp4 and 0x80) == 0) {
            //> lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
            temp4 = 0xFF
            //> ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
            //> bmi SORte                  ;coordinates, and branch if still on the screen
            temp5 = boundingboxUlXpos[Y]
            if ((boundingboxUlXpos[Y] and 0x80) == 0) {
                //> sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[Y] = temp4
            }
            //> SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
            boundingboxDrXpos[Y] = temp4
        }
        //> NoOfs: ldx ObjectOffset           ;get object offset and leave
        temp5 = objectOffset
        //> rts
        return
    } else {
        //> CheckLeftScreenBBox:
        //> lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
        temp4 = boundingboxUlXpos[Y]
        //> bpl NoOfs2                 ;coordinates, and branch if still on the screen
        if ((temp4 and 0x80) != 0) {
            //> cmp #$a0                   ;check to see if left-side edge is in the middle of the
            //> bcc NoOfs2                 ;screen or really offscreen, and branch if still on
            if (temp4 >= 0xA0) {
                //> lda #$00
                temp4 = 0x00
                //> ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
                temp5 = boundingboxDrXpos[Y]
                //> bpl SOLft                  ;coordinates, branch if still onscreen
                if ((temp5 and 0x80) != 0) {
                    //> sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
                    boundingboxDrXpos[Y] = temp4
                }
                //> SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
                boundingboxUlXpos[Y] = temp4
            }
        }
    }
    //> NoOfs2: ldx ObjectOffset           ;get object offset and leave
    temp5 = objectOffset
    //> rts
    return
}

// Decompiled from BoundingBoxCore
fun boundingBoxCore(X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    val boundBoxCtrlData by MemoryByteIndexed(BoundBoxCtrlData)
    val boundingboxLrCorner by MemoryByteIndexed(BoundingBox_LR_Corner)
    val boundingboxUlCorner by MemoryByteIndexed(BoundingBox_UL_Corner)
    val sprobjBoundboxctrl by MemoryByteIndexed(SprObj_BoundBoxCtrl)
    val sprobjectRelXpos by MemoryByteIndexed(SprObject_Rel_XPos)
    val sprobjectRelYpos by MemoryByteIndexed(SprObject_Rel_YPos)
    //> BoundingBoxCore:
    //> stx $00                     ;save offset here
    memory[0x0] = X.toUByte()
    //> lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
    //> sta $02                     ;vertically and horizontally, respectively
    memory[0x2] = (sprobjectRelYpos[Y] and 0xFF).toUByte()
    //> lda SprObject_Rel_XPos,y
    //> sta $01
    memory[0x1] = (sprobjectRelXpos[Y] and 0xFF).toUByte()
    //> txa                         ;multiply offset by four and save to stack
    //> asl
    X = (X shl 1) and 0xFF
    //> asl
    X = (X shl 1) and 0xFF
    //> pha
    push(X)
    //> tay                         ;use as offset for Y, X is left alone
    //> lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
    //> asl                         ;multiply that by four and use as X
    //> asl
    //> tax
    //> lda $01                     ;add the first number in the bounding box data to the
    //> clc                         ;relative horizontal coordinate using enemy object offset
    //> adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
    temp0 = memory[0x1].toInt() + boundBoxCtrlData[(((sprobjBoundboxctrl[X] shl 1) and 0xFF) shl 1) and 0xFF]
    //> sta BoundingBox_UL_Corner,y ;store here
    boundingboxUlCorner[X] = temp0 and 0xFF
    //> lda $01
    //> clc
    //> adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
    temp1 = memory[0x1].toInt() + boundBoxCtrlData[2 + ((((sprobjBoundboxctrl[X] shl 1) and 0xFF) shl 1) and 0xFF)]
    //> sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
    boundingboxLrCorner[X] = temp1 and 0xFF
    //> inx                         ;increment both offsets
    temp2 = (((sprobjBoundboxctrl[X] shl 1) and 0xFF) shl 1) and 0xFF
    temp2 = (temp2 + 1) and 0xFF
    //> iny
    X = (X + 1) and 0xFF
    //> lda $02                     ;add the second number to the relative vertical coordinate
    //> clc                         ;using incremented offset and store using the other
    //> adc BoundBoxCtrlData,x      ;incremented offset
    temp3 = memory[0x2].toInt() + boundBoxCtrlData[temp2]
    //> sta BoundingBox_UL_Corner,y
    boundingboxUlCorner[X] = temp3 and 0xFF
    //> lda $02
    //> clc
    //> adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
    temp4 = memory[0x2].toInt() + boundBoxCtrlData[2 + temp2]
    //> sta BoundingBox_LR_Corner,y ;and store
    boundingboxLrCorner[X] = temp4 and 0xFF
    //> pla                         ;get original offset loaded into $00 * y from stack
    temp5 = pull()
    //> tay                         ;use as Y
    //> ldx $00                     ;get original offset and use as X again
    temp2 = memory[0x0].toInt()
    //> rts
    return
}

// Decompiled from PlayerCollisionCore
fun playerCollisionCore() {
    //> PlayerCollisionCore:
    //> ldx #$00     ;initialize X to use player's bounding box for comparison
    // Fall-through tail call to sprObjectCollisionCore
    sprObjectCollisionCore(0x00, Y)
}

// Decompiled from SprObjectCollisionCore
fun sprObjectCollisionCore(X: Int, Y: Int) {
    var X: Int = X
    var Y: Int = Y
    var temp0: Int = 0
    val boundingboxLrCorner by MemoryByteIndexed(BoundingBox_LR_Corner)
    val boundingboxUlCorner by MemoryByteIndexed(BoundingBox_UL_Corner)
    //> SprObjectCollisionCore:
    //> sty $06      ;save contents of Y here
    memory[0x6] = Y.toUByte()
    //> lda #$01
    //> sta $07      ;save value 1 here as counter, compare horizontal coordinates first
    memory[0x7] = 0x01.toUByte()
    //> CollisionCoreLoop:
    //> lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
    //> cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
    //> bcs FirstBoxGreater          ;if first left/top => second, branch
    temp0 = boundingboxUlCorner[Y]
    if (!(boundingboxUlCorner[Y] >= boundingboxUlCorner[X])) {
        //> cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
        //> bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
        if (temp0 >= boundingboxLrCorner[X]) {
            //> beq CollisionFound           ;if somehow equal, collision, thus branch
            if (temp0 != boundingboxLrCorner[X]) {
                //> lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
                temp0 = boundingboxLrCorner[Y]
                //> cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
                //> bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
                if (temp0 >= boundingboxUlCorner[Y]) {
                    //> cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
                    //> bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
                    if (!(temp0 >= boundingboxUlCorner[X])) {
                        //> ldy $06                      ;otherwise return with carry clear and Y = $0006
                        //> rts                          ;note horizontal wrapping never occurs
                        return
                    }
                }
            }
        }
        //> SecondBoxVerticalChk:
        //> lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
        temp0 = boundingboxLrCorner[X]
        //> cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
        //> bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
        if (temp0 >= boundingboxUlCorner[X]) {
            //> lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
            temp0 = boundingboxLrCorner[Y]
            //> cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
            //> bcs CollisionFound           ;if equal or greater, collision, thus branch
            if (!(temp0 >= boundingboxUlCorner[X])) {
                //> ldy $06                      ;otherwise return with carry clear and Y = $0006
                //> rts
                return
            }
        }
    }
    //> FirstBoxGreater:
    //> cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
    //> beq CollisionFound           ;if first coordinate = second, collision, thus branch
    if (temp0 != boundingboxUlCorner[X]) {
        //> cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
        //> bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
        if (temp0 >= boundingboxLrCorner[X]) {
            //> beq CollisionFound           ;then collision, thus branch
            if (temp0 != boundingboxLrCorner[X]) {
                //> cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
                //> bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
                if (temp0 >= boundingboxLrCorner[Y]) {
                    //> beq NoCollisionFound
                    if (temp0 != boundingboxLrCorner[Y]) {
                        //> lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
                        temp0 = boundingboxLrCorner[Y]
                        //> cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
                        //> bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
                        if (!(temp0 >= boundingboxUlCorner[X])) {
                        }
                    }
                }
                //> NoCollisionFound:
                //> clc          ;clear carry, then load value set earlier, then leave
                //> ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
                //> rts          ;not bother checking vertical ones, because what's the point?
                return
            }
        }
    }
    //> CollisionFound:
    //> inx                    ;increment offsets on both objects to check
    X = (X + 1) and 0xFF
    //> iny                    ;the vertical coordinates
    Y = (Y + 1) and 0xFF
    //> dec $07                ;decrement counter to reflect this
    memory[0x7] = ((memory[0x7].toInt() - 1) and 0xFF).toUByte()
    //> bpl CollisionCoreLoop  ;if counter not expired, branch to loop
    //> sec                    ;otherwise we already did both sets, therefore collision, so set carry
    //> ldy $06                ;load original value set here earlier, then leave
    //> rts
    return
}

// Decompiled from BlockBufferChk_Enemy
fun blockbufferchkEnemy(A: Int, X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> BlockBufferChk_Enemy:
    //> pha        ;save contents of A to stack
    push(A)
    //> txa
    //> clc        ;add 1 to X to run sub with enemy offset in mind
    //> adc #$01
    temp0 = X + 0x01
    //> tax
    //> pla        ;pull A from stack and jump elsewhere
    temp1 = pull()
    //> jmp BBChk_E
    //> BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
    blockBufferCollision(temp1, temp0 and 0xFF, Y)
    //> ldx ObjectOffset          ;get object offset
    //> cmp #$00                  ;check to see if object bumped into anything
    //> rts
    return
}

// Decompiled from BlockBufferChk_FBall
fun blockbufferchkFball(X: Int) {
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> BlockBufferChk_FBall:
    //> ldy #$1a                  ;set offset for block buffer adder data
    //> txa
    //> clc
    //> adc #$07                  ;add seven bytes to use
    temp0 = X + 0x07
    //> tax
    //> ResJmpM: lda #$00                  ;set A to return vertical coordinate
    //> BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
    blockBufferCollision(0x00, temp0 and 0xFF, 0x1A)
    //> ldx ObjectOffset          ;get object offset
    //> cmp #$00                  ;check to see if object bumped into anything
    //> rts
    return
}

// Decompiled from BlockBufferColli_Feet
fun blockbuffercolliFeet(Y: Int) {
    var Y: Int = Y
    //> BlockBufferColli_Feet:
    //> iny            ;if branched here, increment to next set of adders
    Y = (Y + 1) and 0xFF
    // Fall-through tail call to blockbuffercolliHead
    blockbuffercolliHead()
}

// Decompiled from BlockBufferColli_Head
fun blockbuffercolliHead() {
    //> BlockBufferColli_Head:
    //> lda #$00       ;set flag to return vertical coordinate
    //> .db $2c        ;BIT instruction opcode
    // Fall-through tail call to blockbuffercolliSide
    blockbuffercolliSide()
}

// Decompiled from BlockBufferColli_Side
fun blockbuffercolliSide() {
    //> BlockBufferColli_Side:
    //> lda #$01       ;set flag to return horizontal coordinate
    //> ldx #$00       ;set offset for player object
    // Fall-through tail call to blockBufferCollision
    blockBufferCollision(0x01, 0x00, Y)
}

// Decompiled from BlockBufferCollision
fun blockBufferCollision(A: Int, X: Int, Y: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    val blockbufferXAdder by MemoryByteIndexed(BlockBuffer_X_Adder)
    val blockbufferYAdder by MemoryByteIndexed(BlockBuffer_Y_Adder)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    //> BlockBufferCollision:
    //> pha                         ;save contents of A to stack
    push(A)
    //> sty $04                     ;save contents of Y here
    memory[0x4] = Y.toUByte()
    //> lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
    //> clc                         ;of object to value obtained using Y as offset
    //> adc SprObject_X_Position,x
    temp0 = blockbufferXAdder[Y] + sprobjectXPosition[X]
    //> sta $05                     ;store here
    memory[0x5] = (temp0 and 0xFF).toUByte()
    //> lda SprObject_PageLoc,x
    //> adc #$00                    ;add carry to page location
    temp1 = sprobjectPageloc[X] + (if (temp0 > 0xFF) 1 else 0)
    //> and #$01                    ;get LSB, mask out all other bits
    temp2 = temp1 and 0xFF and 0x01
    //> lsr                         ;move to carry
    temp2 = temp2 shr 1
    //> ora $05                     ;get stored value
    temp3 = temp2 or memory[0x5].toInt()
    //> ror                         ;rotate carry to MSB of A
    temp3 = temp3 shr 1 or if ((temp2 and 0x01) != 0) 0x80 else 0
    //> lsr                         ;and effectively move high nybble to
    temp3 = temp3 shr 1
    //> lsr                         ;lower, LSB which became MSB will be
    temp3 = temp3 shr 1
    //> lsr                         ;d4 at this point
    temp3 = temp3 shr 1
    //> jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
    getBlockBufferAddr(temp3)
    //> ldy $04                     ;get old contents of Y
    //> lda SprObject_Y_Position,x  ;get vertical coordinate of object
    //> clc
    //> adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
    temp4 = sprobjectYPosition[X] + blockbufferYAdder[memory[0x4].toInt()]
    //> and #%11110000              ;mask out low nybble
    temp5 = temp4 and 0xFF and 0xF0
    //> sec
    //> sbc #$20                    ;subtract 32 pixels for the status bar
    temp6 = temp5 - 0x20
    //> sta $02                     ;store result here
    memory[0x2] = (temp6 and 0xFF).toUByte()
    //> tay                         ;use as offset for block buffer
    //> lda ($06),y                 ;check current content of block buffer
    //> sta $03                     ;and store here
    memory[0x3] = memory[readWord(0x6) + (temp6 and 0xFF)].toInt().toUByte()
    //> ldy $04                     ;get old contents of Y again
    //> pla                         ;pull A from stack
    temp7 = pull()
    //> bne RetXC                   ;if A = 1, branch
    temp8 = temp7
    temp9 = memory[0x4].toInt()
    if (temp7 == 0) {
        //> lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
        temp8 = sprobjectYPosition[X]
        //> jmp RetYC                   ;and jump
    } else {
        //> RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
        temp8 = sprobjectXPosition[X]
    }
    //> RetYC: and #%00001111              ;and mask out high nybble
    temp10 = temp8 and 0x0F
    //> sta $04                     ;store masked out result here
    memory[0x4] = temp10.toUByte()
    //> lda $03                     ;get saved content of block buffer
    temp8 = memory[0x3].toInt()
    //> rts                         ;and leave
    return A
}

// Decompiled from DrawVine
fun drawVine(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var vinestartYPosition by MemoryByte(VineStart_Y_Position)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    val vineObjOffset by MemoryByteIndexed(VineObjOffset)
    val vineYPosAdder by MemoryByteIndexed(VineYPosAdder)
    //> DrawVine:
    //> sty $00                    ;save offset here
    memory[0x0] = Y.toUByte()
    //> lda Enemy_Rel_YPos         ;get relative vertical coordinate
    //> clc
    //> adc VineYPosAdder,y        ;add value using offset in Y to get value
    temp0 = enemyRelYpos + vineYPosAdder[Y]
    //> ldx VineObjOffset,y        ;get offset to vine
    //> ldy Enemy_SprDataOffset,x  ;get sprite data offset
    //> sty $02                    ;store sprite data offset here
    memory[0x2] = (enemySprdataoffset[vineObjOffset[Y]] and 0xFF).toUByte()
    //> jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
    sixSpriteStacker(temp0 and 0xFF, enemySprdataoffset[vineObjOffset[Y]])
    //> lda Enemy_Rel_XPos         ;get relative horizontal coordinate
    //> sta Sprite_X_Position,y    ;store in first, third and fifth sprites
    spriteXPosition[enemySprdataoffset[vineObjOffset[Y]]] = enemyRelXpos
    //> sta Sprite_X_Position+8,y
    spriteXPosition[8 + enemySprdataoffset[vineObjOffset[Y]]] = enemyRelXpos
    //> sta Sprite_X_Position+16,y
    spriteXPosition[16 + enemySprdataoffset[vineObjOffset[Y]]] = enemyRelXpos
    //> clc
    //> adc #$06                   ;add six pixels to second, fourth and sixth sprites
    temp1 = enemyRelXpos + 0x06
    //> sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
    spriteXPosition[4 + enemySprdataoffset[vineObjOffset[Y]]] = temp1 and 0xFF
    //> sta Sprite_X_Position+12,y ;our vertical stack of sprites
    spriteXPosition[12 + enemySprdataoffset[vineObjOffset[Y]]] = temp1 and 0xFF
    //> sta Sprite_X_Position+20,y
    spriteXPosition[20 + enemySprdataoffset[vineObjOffset[Y]]] = temp1 and 0xFF
    //> lda #%00100001             ;set bg priority and palette attribute bits
    //> sta Sprite_Attributes,y    ;set in first, third and fifth sprites
    spriteAttributes[enemySprdataoffset[vineObjOffset[Y]]] = 0x21
    //> sta Sprite_Attributes+8,y
    spriteAttributes[8 + enemySprdataoffset[vineObjOffset[Y]]] = 0x21
    //> sta Sprite_Attributes+16,y
    spriteAttributes[16 + enemySprdataoffset[vineObjOffset[Y]]] = 0x21
    //> ora #%01000000             ;additionally, set horizontal flip bit
    temp2 = 0x21 or 0x40
    //> sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
    spriteAttributes[4 + enemySprdataoffset[vineObjOffset[Y]]] = temp2
    //> sta Sprite_Attributes+12,y
    spriteAttributes[12 + enemySprdataoffset[vineObjOffset[Y]]] = temp2
    //> sta Sprite_Attributes+20,y
    spriteAttributes[20 + enemySprdataoffset[vineObjOffset[Y]]] = temp2
    //> ldx #$05                   ;set tiles for six sprites
    temp3 = 0x05
    temp4 = enemySprdataoffset[vineObjOffset[Y]]
    do {
        //> VineTL:  lda #$e1                   ;set tile number for sprite
        //> sta Sprite_Tilenumber,y
        spriteTilenumber[temp4] = 0xE1
        //> iny                        ;move offset to next sprite data
        temp4 = (temp4 + 1) and 0xFF
        //> iny
        temp4 = (temp4 + 1) and 0xFF
        //> iny
        temp4 = (temp4 + 1) and 0xFF
        //> iny
        temp4 = (temp4 + 1) and 0xFF
        //> dex                        ;move onto next sprite
        temp3 = (temp3 - 1) and 0xFF
        //> bpl VineTL                 ;loop until all sprites are done
    } while ((temp3 and 0x80) == 0)
    //> ldy $02                    ;get original offset
    temp4 = memory[0x2].toInt()
    //> lda $00                    ;get offset to vine adding data
    //> bne SkpVTop                ;if offset not zero, skip this part
    temp5 = memory[0x0].toInt()
    if (memory[0x0].toInt() == 0) {
        //> lda #$e0
        temp5 = 0xE0
        //> sta Sprite_Tilenumber,y    ;set other tile number for top of vine
        spriteTilenumber[temp4] = temp5
    }
    //> SkpVTop: ldx #$00                   ;start with the first sprite again
    temp3 = 0x00
    do {
        //> ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
        temp5 = vinestartYPosition
        //> sec
        //> sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
        temp6 = temp5 - spriteYPosition[temp4]
        temp5 = temp6 and 0xFF
        //> cmp #$64                   ;if two coordinates are less than 100/$64 pixels
        //> bcc NextVSp                ;apart, skip this to leave sprite alone
        if (temp5 >= 0x64) {
            //> lda #$f8
            temp5 = 0xF8
            //> sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
            spriteYPosition[temp4] = temp5
        }
        //> NextVSp: iny                        ;move offset to next OAM data
        temp4 = (temp4 + 1) and 0xFF
        //> iny
        temp4 = (temp4 + 1) and 0xFF
        //> iny
        temp4 = (temp4 + 1) and 0xFF
        //> iny
        temp4 = (temp4 + 1) and 0xFF
        //> inx                        ;move onto next sprite
        temp3 = (temp3 + 1) and 0xFF
        //> cpx #$06                   ;do this until all sprites are checked
        //> bne ChkFTop
    } while (temp3 != 0x06)
    //> ldy $00                    ;return offset set earlier
    temp4 = memory[0x0].toInt()
    //> rts
    return
}

// Decompiled from SixSpriteStacker
fun sixSpriteStacker(A: Int, Y: Int) {
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> SixSpriteStacker:
    //> ldx #$06           ;do six sprites
    temp0 = 0x06
    do {
        //> StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
        spriteData[Y] = A
        //> clc
        //> adc #$08           ;add eight pixels
        temp1 = A + 0x08
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny                ;move offset four bytes forward
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> iny
        Y = (Y + 1) and 0xFF
        //> dex                ;do another sprite
        temp0 = (temp0 - 1) and 0xFF
        //> bne StkLp          ;do this until all sprites are done
    } while (temp0 != 0)
    //> ldy $02            ;get saved OAM data offset and leave
    //> rts
    return
}

// Decompiled from DrawHammer
fun drawHammer(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var miscOffscreenbits by MemoryByte(Misc_OffscreenBits)
    var miscRelXpos by MemoryByte(Misc_Rel_XPos)
    var miscRelYpos by MemoryByte(Misc_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    val firstSprTilenum by MemoryByteIndexed(FirstSprTilenum)
    val firstSprXPos by MemoryByteIndexed(FirstSprXPos)
    val firstSprYPos by MemoryByteIndexed(FirstSprYPos)
    val hammerSprAttrib by MemoryByteIndexed(HammerSprAttrib)
    val miscSprdataoffset by MemoryByteIndexed(Misc_SprDataOffset)
    val miscState by MemoryByteIndexed(Misc_State)
    val secondSprTilenum by MemoryByteIndexed(SecondSprTilenum)
    val secondSprXPos by MemoryByteIndexed(SecondSprXPos)
    val secondSprYPos by MemoryByteIndexed(SecondSprYPos)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawHammer:
    //> ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
    //> lda TimerControl
    //> bne ForceHPose              ;if master timer control set, skip this part
    temp0 = timerControl
    temp1 = miscSprdataoffset[X]
    if (timerControl == 0) {
        //> lda Misc_State,x            ;otherwise get hammer's state
        temp0 = miscState[X]
        //> and #%01111111              ;mask out d7
        temp2 = temp0 and 0x7F
        //> cmp #$01                    ;check to see if set to 1 yet
        //> beq GetHPose                ;if so, branch
        temp0 = temp2
        if (temp2 != 0x01) {
        }
    }
    //> ForceHPose: ldx #$00                    ;reset offset here
    //> beq RenderH                 ;do unconditional branch to rendering part
    temp3 = 0x00
    if (0x00 != 0) {
        //> GetHPose:   lda FrameCounter            ;get frame counter
        temp0 = frameCounter
        //> lsr                         ;move d3-d2 to d1-d0
        temp0 = temp0 shr 1
        //> lsr
        temp0 = temp0 shr 1
        //> and #%00000011              ;mask out all but d1-d0 (changes every four frames)
        temp4 = temp0 and 0x03
        //> tax                         ;use as timing offset
    }
    //> RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
    temp0 = miscRelYpos
    //> clc
    //> adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
    temp5 = temp0 + firstSprYPos[temp3]
    temp0 = temp5 and 0xFF
    //> sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
    spriteYPosition[temp1] = temp0
    //> clc
    //> adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
    temp6 = temp0 + secondSprYPos[temp3]
    temp0 = temp6 and 0xFF
    //> sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
    spriteYPosition[4 + temp1] = temp0
    //> lda Misc_Rel_XPos           ;get relative horizontal coordinate
    temp0 = miscRelXpos
    //> clc
    //> adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
    temp7 = temp0 + firstSprXPos[temp3]
    temp0 = temp7 and 0xFF
    //> sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
    spriteXPosition[temp1] = temp0
    //> clc
    //> adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
    temp8 = temp0 + secondSprXPos[temp3]
    temp0 = temp8 and 0xFF
    //> sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
    spriteXPosition[4 + temp1] = temp0
    //> lda FirstSprTilenum,x
    temp0 = firstSprTilenum[temp3]
    //> sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
    spriteTilenumber[temp1] = temp0
    //> lda SecondSprTilenum,x
    temp0 = secondSprTilenum[temp3]
    //> sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
    spriteTilenumber[4 + temp1] = temp0
    //> lda HammerSprAttrib,x
    temp0 = hammerSprAttrib[temp3]
    //> sta Sprite_Attributes,y     ;get and store attribute bytes for both
    spriteAttributes[temp1] = temp0
    //> sta Sprite_Attributes+4,y   ;note in this case they use the same data
    spriteAttributes[4 + temp1] = temp0
    //> ldx ObjectOffset            ;get misc object offset
    temp3 = objectOffset
    //> lda Misc_OffscreenBits
    temp0 = miscOffscreenbits
    //> and #%11111100              ;check offscreen bits
    temp9 = temp0 and 0xFC
    //> beq NoHOffscr               ;if all bits clear, leave object alone
    temp0 = temp9
    if (temp9 != 0) {
        //> lda #$00
        temp0 = 0x00
        //> sta Misc_State,x            ;otherwise nullify misc object state
        miscState[temp3] = temp0
        //> lda #$f8
        temp0 = 0xF8
        //> jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
        dumpTwoSpr(temp0, temp1)
    }
    //> NoHOffscr:  rts                         ;leave
    return
}

// Decompiled from FlagpoleGfxHandler
fun flagpoleGfxHandler(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var flagpoleCollisionYPos by MemoryByte(FlagpoleCollisionYPos)
    var flagpolefnumYPos by MemoryByte(FlagpoleFNum_Y_Pos)
    var flagpoleScore by MemoryByte(FlagpoleScore)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val flagpoleScoreNumTiles by MemoryByteIndexed(FlagpoleScoreNumTiles)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> FlagpoleGfxHandler:
    //> ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
    //> lda Enemy_Rel_XPos             ;get relative horizontal coordinate
    //> sta Sprite_X_Position,y        ;store as X coordinate for first sprite
    spriteXPosition[enemySprdataoffset[X]] = enemyRelXpos
    //> clc
    //> adc #$08                       ;add eight pixels and store
    temp0 = enemyRelXpos + 0x08
    //> sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
    spriteXPosition[4 + enemySprdataoffset[X]] = temp0 and 0xFF
    //> sta Sprite_X_Position+8,y
    spriteXPosition[8 + enemySprdataoffset[X]] = temp0 and 0xFF
    //> clc
    //> adc #$0c                       ;add twelve more pixels and
    temp1 = (temp0 and 0xFF) + 0x0C
    //> sta $05                        ;store here to be used later by floatey number
    memory[0x5] = (temp1 and 0xFF).toUByte()
    //> lda Enemy_Y_Position,x         ;get vertical coordinate
    //> jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
    dumpTwoSpr(enemyYPosition[X], enemySprdataoffset[X])
    //> adc #$08                       ;add eight pixels
    temp2 = enemyYPosition[X] + 0x08 + (if (temp1 > 0xFF) 1 else 0)
    //> sta Sprite_Y_Position+8,y      ;and store into third sprite
    spriteYPosition[8 + enemySprdataoffset[X]] = temp2 and 0xFF
    //> lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
    //> sta $02                        ;store it here
    memory[0x2] = flagpolefnumYPos.toUByte()
    //> lda #$01
    //> sta $03                        ;set value for flip which will not be used, and
    memory[0x3] = 0x01.toUByte()
    //> sta $04                        ;attribute byte for floatey number
    memory[0x4] = 0x01.toUByte()
    //> sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
    spriteAttributes[enemySprdataoffset[X]] = 0x01
    //> sta Sprite_Attributes+4,y
    spriteAttributes[4 + enemySprdataoffset[X]] = 0x01
    //> sta Sprite_Attributes+8,y
    spriteAttributes[8 + enemySprdataoffset[X]] = 0x01
    //> lda #$7e
    //> sta Sprite_Tilenumber,y        ;put triangle shaped tile
    spriteTilenumber[enemySprdataoffset[X]] = 0x7E
    //> sta Sprite_Tilenumber+8,y      ;into first and third sprites
    spriteTilenumber[8 + enemySprdataoffset[X]] = 0x7E
    //> lda #$7f
    //> sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
    spriteTilenumber[4 + enemySprdataoffset[X]] = 0x7F
    //> lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
    //> beq ChkFlagOffscreen           ;if zero, branch ahead
    temp3 = flagpoleCollisionYPos
    temp4 = enemySprdataoffset[X]
    if (flagpoleCollisionYPos != 0) {
        //> tya
        //> clc                            ;add 12 bytes to sprite data offset
        //> adc #$0c
        temp5 = temp4 + 0x0C
        temp3 = temp5 and 0xFF
        //> tay                            ;put back in Y
        //> lda FlagpoleScore              ;get offset used to award points for touching flagpole
        temp3 = flagpoleScore
        //> asl                            ;multiply by 2 to get proper offset here
        temp3 = (temp3 shl 1) and 0xFF
        //> tax
        //> lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
        temp3 = flagpoleScoreNumTiles[temp3]
        //> sta $00
        memory[0x0] = temp3.toUByte()
        //> lda FlagpoleScoreNumTiles+1,x
        temp3 = flagpoleScoreNumTiles[1 + temp3]
        //> jsr DrawOneSpriteRow           ;use it to render floatey number
        drawOneSpriteRow(temp3, temp3, temp3)
    }
    //> ChkFlagOffscreen:
    //> ldx ObjectOffset               ;get object offset for flag
    //> ldy Enemy_SprDataOffset,x      ;get OAM data offset
    temp4 = enemySprdataoffset[objectOffset]
    //> lda Enemy_OffscreenBits        ;get offscreen bits
    temp3 = enemyOffscreenbits
    //> and #%00001110                 ;mask out all but d3-d1
    temp6 = temp3 and 0x0E
    //> beq ExitDumpSpr                ;if none of these bits set, branch to leave
    if (temp6 == 0) {
        //  goto ExitDumpSpr
        return
    }
    temp3 = temp6
    temp7 = objectOffset
    if (temp6 != 0) {
        //> ;-------------------------------------------------------------------------------------
    }
    //> ExitDumpSpr:
    //> rts
    return
}

// Decompiled from MoveSixSpritesOffscreen
fun moveSixSpritesOffscreen() {
    //> MoveSixSpritesOffscreen:
    //> lda #$f8                  ;set offscreen coordinate if jumping here
    // Fall-through tail call to dumpSixSpr
    dumpSixSpr(0xF8, Y)
}

// Decompiled from DumpSixSpr
fun dumpSixSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpSixSpr:
    //> sta Sprite_Data+20,y      ;dump A contents
    spriteData[20 + Y] = A
    //> sta Sprite_Data+16,y      ;into third row sprites
    spriteData[16 + Y] = A
    // Fall-through tail call to dumpFourSpr
    dumpFourSpr(A, Y)
}

// Decompiled from DumpFourSpr
fun dumpFourSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpFourSpr:
    //> sta Sprite_Data+12,y      ;into second row sprites
    spriteData[12 + Y] = A
    // Fall-through tail call to dumpThreeSpr
    dumpThreeSpr(A, Y)
}

// Decompiled from DumpThreeSpr
fun dumpThreeSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpThreeSpr:
    //> sta Sprite_Data+8,y
    spriteData[8 + Y] = A
    // Fall-through tail call to dumpTwoSpr
    dumpTwoSpr(A, Y)
}

// Decompiled from DumpTwoSpr
fun dumpTwoSpr(A: Int, Y: Int) {
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> DumpTwoSpr:
    //> sta Sprite_Data+4,y       ;and into first row sprites
    spriteData[4 + Y] = A
    //> sta Sprite_Data,y
    spriteData[Y] = A
    //> ExitDumpSpr:
    //> rts
    return
}

// Decompiled from DrawLargePlatform
fun drawLargePlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var areaType by MemoryByte(AreaType)
    var cloudTypeOverride by MemoryByte(CloudTypeOverride)
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var objectOffset by MemoryByte(ObjectOffset)
    var secondaryHardMode by MemoryByte(SecondaryHardMode)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawLargePlatform:
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    //> sty $02                     ;store here
    memory[0x2] = (enemySprdataoffset[X] and 0xFF).toUByte()
    //> iny                         ;add 3 to it for offset
    temp0 = enemySprdataoffset[X]
    temp0 = (temp0 + 1) and 0xFF
    //> iny                         ;to X coordinate
    temp0 = (temp0 + 1) and 0xFF
    //> iny
    temp0 = (temp0 + 1) and 0xFF
    //> lda Enemy_Rel_XPos          ;get horizontal relative coordinate
    //> jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
    sixSpriteStacker(enemyRelXpos, temp0)
    //> ldx ObjectOffset
    //> lda Enemy_Y_Position,x      ;get vertical coordinate
    //> jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
    dumpFourSpr(enemyYPosition[objectOffset], temp0)
    //> ldy AreaType
    temp0 = areaType
    //> cpy #$03                    ;check for castle-type level
    //> beq ShrinkPlatform
    temp1 = enemyYPosition[objectOffset]
    temp2 = objectOffset
    if (temp0 != 0x03) {
        //> ldy SecondaryHardMode       ;check for secondary hard mode flag set
        temp0 = secondaryHardMode
        //> beq SetLast2Platform        ;branch if not set elsewhere
        if (temp0 != 0) {
        }
    }
    //> ShrinkPlatform:
    //> lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
    temp1 = 0xF8
    //> SetLast2Platform:
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    temp0 = enemySprdataoffset[temp2]
    //> sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
    spriteYPosition[16 + temp0] = temp1
    //> sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
    spriteYPosition[20 + temp0] = temp1
    //> lda #$5b                    ;load default tile for platform (girder)
    temp1 = 0x5B
    //> ldx CloudTypeOverride
    temp2 = cloudTypeOverride
    //> beq SetPlatformTilenum      ;if cloud level override flag not set, use
    if (temp2 != 0) {
        //> lda #$75                    ;otherwise load other tile for platform (puff)
        temp1 = 0x75
    }
    //> SetPlatformTilenum:
    //> ldx ObjectOffset            ;get enemy object buffer offset
    temp2 = objectOffset
    //> iny                         ;increment Y for tile offset
    temp0 = (temp0 + 1) and 0xFF
    //> jsr DumpSixSpr              ;dump tile number into all six sprites
    dumpSixSpr(temp1, temp0)
    //> lda #$02                    ;set palette controls
    temp1 = 0x02
    //> iny                         ;increment Y for sprite attributes
    temp0 = (temp0 + 1) and 0xFF
    //> jsr DumpSixSpr              ;dump attributes into all six sprites
    dumpSixSpr(temp1, temp0)
    //> inx                         ;increment X for enemy objects
    temp2 = (temp2 + 1) and 0xFF
    //> jsr GetXOffscreenBits       ;get offscreen bits again
    getXOffscreenBits(temp2)
    //> dex
    temp2 = (temp2 - 1) and 0xFF
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    temp0 = enemySprdataoffset[temp2]
    //> asl                         ;rotate d7 into carry, save remaining
    temp1 = (temp1 shl 1) and 0xFF
    //> pha                         ;bits to the stack
    push(temp1)
    //> bcc SChk2
    if ((temp1 and 0x80) != 0) {
        //> lda #$f8                    ;if d7 was set, move first sprite offscreen
        temp1 = 0xF8
        //> sta Sprite_Y_Position,y
        spriteYPosition[temp0] = temp1
    }
    //> SChk2:  pla                         ;get bits from stack
    temp1 = pull()
    //> asl                         ;rotate d6 into carry
    temp1 = (temp1 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(temp1)
    //> bcc SChk3
    if ((temp1 and 0x80) != 0) {
        //> lda #$f8                    ;if d6 was set, move second sprite offscreen
        temp1 = 0xF8
        //> sta Sprite_Y_Position+4,y
        spriteYPosition[4 + temp0] = temp1
    }
    //> SChk3:  pla                         ;get bits from stack
    temp1 = pull()
    //> asl                         ;rotate d5 into carry
    temp1 = (temp1 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(temp1)
    //> bcc SChk4
    if ((temp1 and 0x80) != 0) {
        //> lda #$f8                    ;if d5 was set, move third sprite offscreen
        temp1 = 0xF8
        //> sta Sprite_Y_Position+8,y
        spriteYPosition[8 + temp0] = temp1
    }
    //> SChk4:  pla                         ;get bits from stack
    temp1 = pull()
    //> asl                         ;rotate d4 into carry
    temp1 = (temp1 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(temp1)
    //> bcc SChk5
    if ((temp1 and 0x80) != 0) {
        //> lda #$f8                    ;if d4 was set, move fourth sprite offscreen
        temp1 = 0xF8
        //> sta Sprite_Y_Position+12,y
        spriteYPosition[12 + temp0] = temp1
    }
    //> SChk5:  pla                         ;get bits from stack
    temp1 = pull()
    //> asl                         ;rotate d3 into carry
    temp1 = (temp1 shl 1) and 0xFF
    //> pha                         ;save to stack
    push(temp1)
    //> bcc SChk6
    if ((temp1 and 0x80) != 0) {
        //> lda #$f8                    ;if d3 was set, move fifth sprite offscreen
        temp1 = 0xF8
        //> sta Sprite_Y_Position+16,y
        spriteYPosition[16 + temp0] = temp1
    }
    //> SChk6:  pla                         ;get bits from stack
    temp1 = pull()
    //> asl                         ;rotate d2 into carry
    temp1 = (temp1 shl 1) and 0xFF
    //> bcc SLChk                   ;save to stack
    if ((temp1 and 0x80) != 0) {
        //> lda #$f8
        temp1 = 0xF8
        //> sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
        spriteYPosition[20 + temp0] = temp1
    }
    //> SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
    temp1 = enemyOffscreenbits
    //> asl                         ;and if d7 is not set, skip sub
    temp1 = (temp1 shl 1) and 0xFF
    //> bcc ExDLPl
    if ((temp1 and 0x80) != 0) {
        //> jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
        moveSixSpritesOffscreen()
    }
    //> ExDLPl: rts
    return
}

// Decompiled from JCoinGfxHandler
fun jCoinGfxHandler(X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var miscRelXpos by MemoryByte(Misc_Rel_XPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val jumpingCoinTiles by MemoryByteIndexed(JumpingCoinTiles)
    val miscSprdataoffset by MemoryByteIndexed(Misc_SprDataOffset)
    val miscState by MemoryByteIndexed(Misc_State)
    val miscYPosition by MemoryByteIndexed(Misc_Y_Position)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawFloateyNumber_Coin:
    //> lda FrameCounter          ;get frame counter
    //> lsr                       ;divide by 2
    frameCounter = frameCounter shr 1
    //> bcs NotRsNum              ;branch if d0 not set to raise number every other frame
    if ((frameCounter and 0x01) != 0) {
        //  goto NotRsNum
        return
    }
    temp0 = frameCounter
    if ((frameCounter and 0x01) == 0) {
        //> dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
        miscYPosition[X] = (miscYPosition[X] - 1) and 0xFF
    }
    //> NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
    temp0 = miscYPosition[X]
    //> jsr DumpTwoSpr            ;dump into both sprites
    dumpTwoSpr(temp0, Y)
    //> lda Misc_Rel_XPos         ;get relative horizontal coordinate
    temp0 = miscRelXpos
    //> sta Sprite_X_Position,y   ;store as X coordinate for first sprite
    spriteXPosition[Y] = temp0
    //> clc
    //> adc #$08                  ;add eight pixels
    temp1 = temp0 + 0x08
    temp0 = temp1 and 0xFF
    //> sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
    spriteXPosition[4 + Y] = temp0
    //> lda #$02
    temp0 = 0x02
    //> sta Sprite_Attributes,y   ;store attribute byte in both sprites
    spriteAttributes[Y] = temp0
    //> sta Sprite_Attributes+4,y
    spriteAttributes[4 + Y] = temp0
    //> lda #$f7
    temp0 = 0xF7
    //> sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
    spriteTilenumber[Y] = temp0
    //> lda #$fb                  ;that resemble "200"
    temp0 = 0xFB
    //> sta Sprite_Tilenumber+4,y
    spriteTilenumber[4 + Y] = temp0
    //> jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
    //> JCoinGfxHandler:
    //> ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
    //> lda Misc_State,x            ;get state of misc object
    temp0 = miscState[X]
    //> cmp #$02                    ;if 2 or greater,
    //> bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
    //> lda Misc_Y_Position,x       ;store vertical coordinate as
    temp0 = miscYPosition[X]
    //> sta Sprite_Y_Position,y     ;Y coordinate for first sprite
    spriteYPosition[miscSprdataoffset[X]] = temp0
    //> clc
    //> adc #$08                    ;add eight pixels
    temp2 = temp0 + 0x08
    temp0 = temp2 and 0xFF
    //> sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
    spriteYPosition[4 + miscSprdataoffset[X]] = temp0
    //> lda Misc_Rel_XPos           ;get relative horizontal coordinate
    temp0 = miscRelXpos
    //> sta Sprite_X_Position,y
    spriteXPosition[miscSprdataoffset[X]] = temp0
    //> sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
    spriteXPosition[4 + miscSprdataoffset[X]] = temp0
    //> lda FrameCounter            ;get frame counter
    temp0 = frameCounter
    //> lsr                         ;divide by 2 to alter every other frame
    temp0 = temp0 shr 1
    //> and #%00000011              ;mask out d2-d1
    temp3 = temp0 and 0x03
    //> tax                         ;use as graphical offset
    //> lda JumpingCoinTiles,x      ;load tile number
    temp0 = jumpingCoinTiles[temp3]
    //> iny                         ;increment OAM data offset to write tile numbers
    temp4 = miscSprdataoffset[X]
    temp4 = (temp4 + 1) and 0xFF
    //> jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
    dumpTwoSpr(temp0, temp4)
    //> dey                         ;decrement to get old offset
    temp4 = (temp4 - 1) and 0xFF
    //> lda #$02
    temp0 = 0x02
    //> sta Sprite_Attributes,y     ;set attribute byte in first sprite
    spriteAttributes[temp4] = temp0
    //> lda #$82
    temp0 = 0x82
    //> sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
    spriteAttributes[4 + temp4] = temp0
    //> ldx ObjectOffset            ;get misc object offset
    //> ExJCGfx: rts                         ;leave
    return
}

// Decompiled from DrawPowerUp
fun drawPowerUp() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var enemyRelYpos by MemoryByte(Enemy_Rel_YPos)
    var frameCounter by MemoryByte(FrameCounter)
    var objectOffset by MemoryByte(ObjectOffset)
    var powerUpType by MemoryByte(PowerUpType)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val powerUpAttributes by MemoryByteIndexed(PowerUpAttributes)
    val powerUpGfxTable by MemoryByteIndexed(PowerUpGfxTable)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    //> DrawPowerUp:
    //> ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
    //> lda Enemy_Rel_YPos         ;get relative vertical coordinate
    //> clc
    //> adc #$08                   ;add eight pixels
    temp0 = enemyRelYpos + 0x08
    //> sta $02                    ;store result here
    memory[0x2] = (temp0 and 0xFF).toUByte()
    //> lda Enemy_Rel_XPos         ;get relative horizontal coordinate
    //> sta $05                    ;store here
    memory[0x5] = enemyRelXpos.toUByte()
    //> ldx PowerUpType            ;get power-up type
    //> lda PowerUpAttributes,x    ;get attribute data for power-up type
    //> ora Enemy_SprAttrib+5      ;add background priority bit if set
    temp1 = powerUpAttributes[powerUpType] or enemySprattrib[5]
    //> sta $04                    ;store attributes here
    memory[0x4] = temp1.toUByte()
    //> txa
    //> pha                        ;save power-up type to the stack
    push(powerUpType)
    //> asl
    powerUpType = (powerUpType shl 1) and 0xFF
    //> asl                        ;multiply by four to get proper offset
    powerUpType = (powerUpType shl 1) and 0xFF
    //> tax                        ;use as X
    //> lda #$01
    //> sta $07                    ;set counter here to draw two rows of sprite object
    memory[0x7] = 0x01.toUByte()
    //> sta $03                    ;init d1 of flip control
    memory[0x3] = 0x01.toUByte()
    temp2 = powerUpType
    temp3 = enemySprdataoffset[5]
    do {
        //> PUpDrawLoop:
        //> lda PowerUpGfxTable,x      ;load left tile of power-up object
        //> sta $00
        memory[0x0] = (powerUpGfxTable[temp2] and 0xFF).toUByte()
        //> lda PowerUpGfxTable+1,x    ;load right tile
        //> jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
        drawOneSpriteRow(powerUpGfxTable[1 + temp2], temp2, temp3)
        //> dec $07                    ;decrement counter
        memory[0x7] = ((memory[0x7].toInt() - 1) and 0xFF).toUByte()
        //> bpl PUpDrawLoop            ;branch until two rows are drawn
    } while ((memory[0x7].toInt() and 0x80) == 0)
    //> ldy Enemy_SprDataOffset+5  ;get sprite data offset again
    temp3 = enemySprdataoffset[5]
    //> pla                        ;pull saved power-up type from the stack
    temp4 = pull()
    //> beq PUpOfs                 ;if regular mushroom, branch, do not change colors or flip
    if (temp4 == 0) {
        //  goto PUpOfs
        return
    }
    temp5 = temp4
    if (temp4 != 0) {
        //> cmp #$03
        //> beq PUpOfs                 ;if 1-up mushroom, branch, do not change colors or flip
        if (temp5 - 0x03 == 0) {
            //  goto PUpOfs
            return
        }
        if (temp5 != 0x03) {
            //> sta $00                    ;store power-up type here now
            memory[0x0] = temp5.toUByte()
            //> lda FrameCounter           ;get frame counter
            temp5 = frameCounter
            //> lsr                        ;divide by 2 to change colors every two frames
            temp5 = temp5 shr 1
            //> and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
            temp6 = temp5 and 0x03
            //> ora Enemy_SprAttrib+5      ;add background priority bit if any set
            temp7 = temp6 or enemySprattrib[5]
            //> sta Sprite_Attributes,y    ;set as new palette bits for top left and
            spriteAttributes[temp3] = temp7
            //> sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
            spriteAttributes[4 + temp3] = temp7
            //> ldx $00
            temp2 = memory[0x0].toInt()
            //> dex                        ;check power-up type for fire flower
            temp2 = (temp2 - 1) and 0xFF
            //> beq FlipPUpRightSide       ;if found, skip this part
            temp5 = temp7
            if (temp2 != 0) {
                //> sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
                spriteAttributes[8 + temp3] = temp5
                //> sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
                spriteAttributes[12 + temp3] = temp5
            }
            //> FlipPUpRightSide:
            //> lda Sprite_Attributes+4,y
            temp5 = spriteAttributes[4 + temp3]
            //> ora #%01000000             ;set horizontal flip bit for top right sprite
            temp8 = temp5 or 0x40
            //> sta Sprite_Attributes+4,y
            spriteAttributes[4 + temp3] = temp8
            //> lda Sprite_Attributes+12,y
            temp5 = spriteAttributes[12 + temp3]
            //> ora #%01000000             ;set horizontal flip bit for bottom right sprite
            temp9 = temp5 or 0x40
            //> sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
            spriteAttributes[12 + temp3] = temp9
        }
    }
    //> PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
    //> SprObjectOffscrChk:
    //> ldx ObjectOffset          ;get enemy buffer offset
    temp2 = objectOffset
    //> lda Enemy_OffscreenBits   ;check offscreen information
    temp5 = enemyOffscreenbits
    //> lsr
    temp5 = temp5 shr 1
    //> lsr                       ;shift three times to the right
    temp5 = temp5 shr 1
    //> lsr                       ;which puts d2 into carry
    temp5 = temp5 shr 1
    //> pha                       ;save to stack
    push(temp5)
    //> bcc LcChk                 ;branch if not set
    if ((temp5 and 0x01) != 0) {
        //> lda #$04                  ;set for right column sprites
        temp5 = 0x04
        //> jsr MoveESprColOffscreen  ;and move them offscreen
        moveESprColOffscreen(temp5, temp2)
    }
    //> LcChk:   pla                       ;get from stack
    temp5 = pull()
    //> lsr                       ;move d3 to carry
    temp5 = temp5 shr 1
    //> pha                       ;save to stack
    push(temp5)
    //> bcc Row3C                 ;branch if not set
    if ((temp5 and 0x01) != 0) {
        //> lda #$00                  ;set for left column sprites,
        temp5 = 0x00
        //> jsr MoveESprColOffscreen  ;move them offscreen
        moveESprColOffscreen(temp5, temp2)
    }
    //> Row3C:   pla                       ;get from stack again
    temp5 = pull()
    //> lsr                       ;move d5 to carry this time
    temp5 = temp5 shr 1
    //> lsr
    temp5 = temp5 shr 1
    //> pha                       ;save to stack again
    push(temp5)
    //> bcc Row23C                ;branch if carry not set
    if ((temp5 and 0x01) != 0) {
        //> lda #$10                  ;set for third row of sprites
        temp5 = 0x10
        //> jsr MoveESprRowOffscreen  ;and move them offscreen
        moveESprRowOffscreen(temp5, temp2)
    }
    //> Row23C:  pla                       ;get from stack
    temp5 = pull()
    //> lsr                       ;move d6 into carry
    temp5 = temp5 shr 1
    //> pha                       ;save to stack
    push(temp5)
    //> bcc AllRowC
    if ((temp5 and 0x01) != 0) {
        //> lda #$08                  ;set for second and third rows
        temp5 = 0x08
        //> jsr MoveESprRowOffscreen  ;move them offscreen
        moveESprRowOffscreen(temp5, temp2)
    }
    //> AllRowC: pla                       ;get from stack once more
    temp5 = pull()
    //> lsr                       ;move d7 into carry
    temp5 = temp5 shr 1
    //> bcc ExEGHandler
    if ((temp5 and 0x01) != 0) {
        //> jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
        moveESprRowOffscreen(temp5, temp2)
        //> lda Enemy_ID,x
        temp5 = enemyId[temp2]
        //> cmp #Podoboo              ;check enemy identifier for podoboo
        //> beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
        if (temp5 != Podoboo) {
            //> lda Enemy_Y_HighPos,x     ;check high byte of vertical position
            temp5 = enemyYHighpos[temp2]
            //> cmp #$02                  ;if not yet past the bottom of the screen, branch
            //> bne ExEGHandler
            if (temp5 == 0x02) {
                //> jsr EraseEnemyObject      ;what it says
                eraseEnemyObject(temp2)
            }
        }
    }
    //> ExEGHandler:
    //> rts
    return
}

// Decompiled from EnemyGfxHandler
fun enemyGfxHandler(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp15: Int = 0
    var temp16: Int = 0
    var temp17: Int = 0
    var temp18: Int = 0
    var temp19: Int = 0
    var temp2: Int = 0
    var temp20: Int = 0
    var temp21: Int = 0
    var temp22: Int = 0
    var temp23: Int = 0
    var temp24: Int = 0
    var temp25: Int = 0
    var temp26: Int = 0
    var temp27: Int = 0
    var temp28: Int = 0
    var temp29: Int = 0
    var temp3: Int = 0
    var temp30: Int = 0
    var temp31: Int = 0
    var temp32: Int = 0
    var temp33: Int = 0
    var temp34: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var bowserBodyControls by MemoryByte(BowserBodyControls)
    var bowserGfxFlag by MemoryByte(BowserGfxFlag)
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var frameCounter by MemoryByte(FrameCounter)
    var frenzyEnemyTimer by MemoryByte(FrenzyEnemyTimer)
    var jumpspringAnimCtrl by MemoryByte(JumpspringAnimCtrl)
    var objectOffset by MemoryByte(ObjectOffset)
    var timerControl by MemoryByte(TimerControl)
    var verticalFlipFlag by MemoryByte(VerticalFlipFlag)
    var worldNumber by MemoryByte(WorldNumber)
    val enemyAnimTimingBMask by MemoryByteIndexed(EnemyAnimTimingBMask)
    val enemyAttributeData by MemoryByteIndexed(EnemyAttributeData)
    val enemyFrameTimer by MemoryByteIndexed(EnemyFrameTimer)
    val enemyGfxTableOffsets by MemoryByteIndexed(EnemyGfxTableOffsets)
    val enemyIntervalTimer by MemoryByteIndexed(EnemyIntervalTimer)
    val enemyId by MemoryByteIndexed(Enemy_ID)
    val enemyMovingdir by MemoryByteIndexed(Enemy_MovingDir)
    val enemySprattrib by MemoryByteIndexed(Enemy_SprAttrib)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyState by MemoryByteIndexed(Enemy_State)
    val enemyYHighpos by MemoryByteIndexed(Enemy_Y_HighPos)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val enemyYSpeed by MemoryByteIndexed(Enemy_Y_Speed)
    val jumpspringFrameOffsets by MemoryByteIndexed(JumpspringFrameOffsets)
    val piranhaplantYSpeed by MemoryByteIndexed(PiranhaPlant_Y_Speed)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    //> EnemyGfxHandler:
    //> lda Enemy_Y_Position,x      ;get enemy object vertical position
    //> sta $02
    memory[0x2] = (enemyYPosition[X] and 0xFF).toUByte()
    //> lda Enemy_Rel_XPos          ;get enemy object horizontal position
    //> sta $05                     ;relative to screen
    memory[0x5] = enemyRelXpos.toUByte()
    //> ldy Enemy_SprDataOffset,x
    //> sty $eb                     ;get sprite data offset
    memory[0xEB] = (enemySprdataoffset[X] and 0xFF).toUByte()
    //> lda #$00
    //> sta VerticalFlipFlag        ;initialize vertical flip flag by default
    verticalFlipFlag = 0x00
    //> lda Enemy_MovingDir,x
    //> sta $03                     ;get enemy object moving direction
    memory[0x3] = (enemyMovingdir[X] and 0xFF).toUByte()
    //> lda Enemy_SprAttrib,x
    //> sta $04                     ;get enemy object sprite attributes
    memory[0x4] = (enemySprattrib[X] and 0xFF).toUByte()
    //> lda Enemy_ID,x
    //> cmp #PiranhaPlant           ;is enemy object piranha plant?
    //> bne CheckForRetainerObj     ;if not, branch
    temp0 = enemyId[X]
    temp1 = enemySprdataoffset[X]
    if (enemyId[X] == PiranhaPlant) {
        //> ldy PiranhaPlant_Y_Speed,x
        temp1 = piranhaplantYSpeed[X]
        //> bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
        if ((temp1 and 0x80) == 0) {
            //> ldy EnemyFrameTimer,x
            temp1 = enemyFrameTimer[X]
            //> beq CheckForRetainerObj     ;if timer for movement expired, branch
            if (temp1 != 0) {
                //> rts                         ;if all conditions fail, leave
                return
            }
        }
    }
    //> CheckForRetainerObj:
    //> lda Enemy_State,x           ;store enemy state
    temp0 = enemyState[X]
    //> sta $ed
    memory[0xED] = temp0.toUByte()
    //> and #%00011111              ;nullify all but 5 LSB and use as Y
    temp2 = temp0 and 0x1F
    //> tay
    //> lda Enemy_ID,x              ;check for mushroom retainer/princess object
    temp0 = enemyId[X]
    //> cmp #RetainerObject
    //> bne CheckForBulletBillCV    ;if not found, branch
    temp1 = temp2
    if (temp0 == RetainerObject) {
        //> ldy #$00                    ;if found, nullify saved state in Y
        temp1 = 0x00
        //> lda #$01                    ;set value that will not be used
        temp0 = 0x01
        //> sta $03
        memory[0x3] = temp0.toUByte()
        //> lda #$15                    ;set value $15 as code for mushroom retainer/princess object
        temp0 = 0x15
    }
    //> CheckForBulletBillCV:
    //> cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
    //> bne CheckForJumpspring      ;if not found, branch again
    if (temp0 == BulletBill_CannonVar) {
        //> dec $02                     ;decrement saved vertical position
        memory[0x2] = ((memory[0x2].toInt() - 1) and 0xFF).toUByte()
        //> lda #$03
        temp0 = 0x03
        //> ldy EnemyFrameTimer,x       ;get timer for enemy object
        temp1 = enemyFrameTimer[X]
        //> beq SBBAt                   ;if expired, do not set priority bit
        if (temp1 != 0) {
            //> ora #%00100000              ;otherwise do so
            temp3 = temp0 or 0x20
        }
        //> SBBAt: sta $04                     ;set new sprite attributes
        memory[0x4] = temp0.toUByte()
        //> ldy #$00                    ;nullify saved enemy state both in Y and in
        temp1 = 0x00
        //> sty $ed                     ;memory location here
        memory[0xED] = temp1.toUByte()
        //> lda #$08                    ;set specific value to unconditionally branch once
        temp0 = 0x08
    }
    //> CheckForJumpspring:
    //> cmp #JumpspringObject        ;check for jumpspring object
    //> bne CheckForPodoboo
    if (temp0 == JumpspringObject) {
        //> ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
        temp1 = 0x03
        //> ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
        //> lda JumpspringFrameOffsets,x ;load data using frame number as offset
        temp0 = jumpspringFrameOffsets[jumpspringAnimCtrl]
    }
    //> CheckForPodoboo:
    //> sta $ef                 ;store saved enemy object value here
    memory[0xEF] = temp0.toUByte()
    //> sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
    memory[0xEC] = temp1.toUByte()
    //> ldx ObjectOffset        ;get enemy object offset
    //> cmp #$0c                ;check for podoboo object
    //> bne CheckBowserGfxFlag  ;branch if not found
    temp4 = objectOffset
    if (temp0 == 0x0C) {
        //> lda Enemy_Y_Speed,x     ;if moving upwards, branch
        temp0 = enemyYSpeed[temp4]
        //> bmi CheckBowserGfxFlag
        if ((temp0 and 0x80) == 0) {
            //> inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
            verticalFlipFlag = (verticalFlipFlag + 1) and 0xFF
        }
    }
    //> CheckBowserGfxFlag:
    //> lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
    temp0 = bowserGfxFlag
    //> beq CheckForGoomba
    if (temp0 != 0) {
        //> ldy #$16            ;if set to 1, draw bowser's front
        temp1 = 0x16
        //> cmp #$01
        //> beq SBwsrGfxOfs
        if (temp0 != 0x01) {
            //> iny                 ;otherwise draw bowser's rear
            temp1 = (temp1 + 1) and 0xFF
        }
        //> SBwsrGfxOfs: sty $ef
        memory[0xEF] = temp1.toUByte()
    }
    //> CheckForGoomba:
    //> ldy $ef               ;check value for goomba object
    temp1 = memory[0xEF].toInt()
    //> cpy #Goomba
    //> bne CheckBowserFront  ;branch if not found
    if (temp1 == Goomba) {
        //> lda Enemy_State,x
        temp0 = enemyState[temp4]
        //> cmp #$02              ;check for defeated state
        //> bcc GmbaAnim          ;if not defeated, go ahead and animate
        if (temp0 >= 0x02) {
            //> ldx #$04              ;if defeated, write new value here
            temp4 = 0x04
            //> stx $ec
            memory[0xEC] = temp4.toUByte()
        }
        //> GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
        temp5 = temp0 and 0x20
        //> ora TimerControl      ;or timer disable flag set
        temp6 = temp5 or timerControl
        //> bne CheckBowserFront  ;if either condition true, do not animate goomba
        temp0 = temp6
        if (temp6 == 0) {
            //> lda FrameCounter
            temp0 = frameCounter
            //> and #%00001000        ;check for every eighth frame
            temp7 = temp0 and 0x08
            //> bne CheckBowserFront
            temp0 = temp7
            if (temp7 == 0) {
                //> lda $03
                temp0 = memory[0x3].toInt()
                //> eor #%00000011        ;invert bits to flip horizontally every eight frames
                temp8 = temp0 xor 0x03
                //> sta $03               ;leave alone otherwise
                memory[0x3] = temp8.toUByte()
            }
        }
    }
    //> CheckBowserFront:
    //> lda EnemyAttributeData,y    ;load sprite attribute using enemy object
    temp0 = enemyAttributeData[temp1]
    //> ora $04                     ;as offset, and add to bits already loaded
    temp9 = temp0 or memory[0x4].toInt()
    //> sta $04
    memory[0x4] = temp9.toUByte()
    //> lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
    temp0 = enemyGfxTableOffsets[temp1]
    //> tax                         ;save as X
    //> ldy $ec                     ;get previously saved value
    temp1 = memory[0xEC].toInt()
    //> lda BowserGfxFlag
    temp0 = bowserGfxFlag
    //> beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
    temp4 = temp0
    if (temp0 != 0) {
        //> cmp #$01
        //> bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
        if (temp0 == 0x01) {
            //> lda BowserBodyControls      ;check bowser's body control bits
            temp0 = bowserBodyControls
            //> bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
            if ((temp0 and 0x80) != 0) {
                //> ldx #$de                    ;otherwise load offset for second frame
                temp4 = 0xDE
            }
            //> ChkFrontSte: lda $ed                     ;check saved enemy state
            temp0 = memory[0xED].toInt()
            //> and #%00100000              ;if bowser not defeated, do not set flag
            temp10 = temp0 and 0x20
            //> beq DrawBowser
            if (temp10 == 0) {
                //  goto DrawBowser
                return
            }
            temp0 = temp10
            if (temp10 != 0) {
                //> FlipBowserOver:
                //> stx VerticalFlipFlag  ;set vertical flip flag to nonzero
                verticalFlipFlag = temp4
            }
            //> DrawBowser:
            //> jmp DrawEnemyObject   ;draw bowser's graphics now
        }
        //> CheckBowserRear:
        //> lda BowserBodyControls  ;check bowser's body control bits
        temp0 = bowserBodyControls
        //> and #$01
        temp11 = temp0 and 0x01
        //> beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
        temp0 = temp11
        if (temp11 != 0) {
            //> ldx #$e4                ;otherwise load offset for second frame
            temp4 = 0xE4
        }
        //> ChkRearSte: lda $ed                 ;check saved enemy state
        temp0 = memory[0xED].toInt()
        //> and #%00100000          ;if bowser not defeated, do not set flag
        temp12 = temp0 and 0x20
        //> beq DrawBowser
        if (temp12 == 0) {
            //  goto DrawBowser
            return
        }
        while (true) {
            //> lda $02                 ;subtract 16 pixels from
            temp0 = memory[0x2].toInt()
            //> sec                     ;saved vertical coordinate
            //> sbc #$10
            temp13 = temp0 - 0x10
            temp0 = temp13 and 0xFF
            //> sta $02
            memory[0x2] = temp0.toUByte()
            //> jmp FlipBowserOver      ;jump to set vertical flip flag
        }
    }
    //> CheckForSpiny:
    //> cpx #$24               ;check if value loaded is for spiny
    //> bne CheckForLakitu     ;if not found, branch
    if (temp4 == 0x24) {
        //> cpy #$05               ;if enemy state set to $05, do this,
        //> bne NotEgg             ;otherwise branch
        if (!(temp1 == 0x05)) {
            //  goto NotEgg
            return
        }
        if (temp1 == 0x05) {
            //> ldx #$30               ;set to spiny egg offset
            temp4 = 0x30
            //> lda #$02
            temp0 = 0x02
            //> sta $03                ;set enemy direction to reverse sprites horizontally
            memory[0x3] = temp0.toUByte()
            //> lda #$05
            temp0 = 0x05
            //> sta $ec                ;set enemy state
            memory[0xEC] = temp0.toUByte()
        }
    } else {
        //> CheckForLakitu:
        //> cpx #$90                  ;check value for lakitu's offset loaded
        //> bne CheckUpsideDownShell  ;branch if not loaded
        if (temp4 == 0x90) {
            //> lda $ed
            temp0 = memory[0xED].toInt()
            //> and #%00100000            ;check for d5 set in enemy state
            temp14 = temp0 and 0x20
            //> bne NoLAFr                ;branch if set
            if (!(temp14 == 0)) {
                //  goto NoLAFr
                return
            }
            temp0 = temp14
            if (temp14 == 0) {
                //> lda FrenzyEnemyTimer
                temp0 = frenzyEnemyTimer
                //> cmp #$10                  ;check timer to see if we've reached a certain range
                //> bcs NoLAFr                ;branch if not
                if (temp0 >= 0x10) {
                    //  goto NoLAFr
                    return
                }
                if (!(temp0 >= 0x10)) {
                    //> ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
                    temp4 = 0x96
                }
            }
            //> NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
        }
        //> CheckUpsideDownShell:
        //> lda $ef                    ;check for enemy object => $04
        temp0 = memory[0xEF].toInt()
        //> cmp #$04
        //> bcs CheckRightSideUpShell  ;branch if true
        if (!(temp0 >= 0x04)) {
            //> cpy #$02
            //> bcc CheckRightSideUpShell  ;branch if enemy state < $02
            if (temp1 >= 0x02) {
                //> ldx #$5a                   ;set for upside-down koopa shell by default
                temp4 = 0x5A
                //> ldy $ef
                temp1 = memory[0xEF].toInt()
                //> cpy #BuzzyBeetle           ;check for buzzy beetle object
                //> bne CheckRightSideUpShell
                if (temp1 == BuzzyBeetle) {
                    //> ldx #$7e                   ;set for upside-down buzzy beetle shell if found
                    temp4 = 0x7E
                    //> inc $02                    ;increment vertical position by one pixel
                    memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
                }
            }
        }
        //> CheckRightSideUpShell:
        //> lda $ec                ;check for value set here
        temp0 = memory[0xEC].toInt()
        //> cmp #$04               ;if enemy state < $02, do not change to shell, if
        //> bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
        if (temp0 == 0x04) {
            //> ldx #$72               ;set right-side up buzzy beetle shell by default
            temp4 = 0x72
            //> inc $02                ;increment saved vertical position by one pixel
            memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
            //> ldy $ef
            temp1 = memory[0xEF].toInt()
            //> cpy #BuzzyBeetle       ;check for buzzy beetle object
            //> beq CheckForDefdGoomba ;branch if found
            if (temp1 != BuzzyBeetle) {
                //> ldx #$66               ;change to right-side up koopa shell if not found
                temp4 = 0x66
                //> inc $02                ;and increment saved vertical position again
                memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
            }
            //> CheckForDefdGoomba:
            //> cpy #Goomba            ;check for goomba object (necessary if previously
            //> bne CheckForHammerBro  ;failed buzzy beetle object test)
            if (temp1 == Goomba) {
                //> ldx #$54               ;load for regular goomba
                temp4 = 0x54
                //> lda $ed                ;note that this only gets performed if enemy state => $02
                temp0 = memory[0xED].toInt()
                //> and #%00100000         ;check saved enemy state for d5 set
                temp15 = temp0 and 0x20
                //> bne CheckForHammerBro  ;branch if set
                temp0 = temp15
                if (temp15 == 0) {
                    //> ldx #$8a               ;load offset for defeated goomba
                    temp4 = 0x8A
                    //> dec $02                ;set different value and decrement saved vertical position
                    memory[0x2] = ((memory[0x2].toInt() - 1) and 0xFF).toUByte()
                }
            }
        }
    }
    //> CheckForHammerBro:
    //> ldy ObjectOffset
    temp1 = objectOffset
    //> lda $ef                  ;check for hammer bro object
    temp0 = memory[0xEF].toInt()
    //> cmp #HammerBro
    //> bne CheckForBloober      ;branch if not found
    if (temp0 == HammerBro) {
        //> lda $ed
        temp0 = memory[0xED].toInt()
        //> beq CheckToAnimateEnemy  ;branch if not in normal enemy state
        if (temp0 != 0) {
            //> and #%00001000
            temp16 = temp0 and 0x08
            //> beq CheckDefeatedState   ;if d3 not set, branch further away
            temp0 = temp16
            if (temp16 != 0) {
                //> ldx #$b4                 ;otherwise load offset for different frame
                temp4 = 0xB4
                //> bne CheckToAnimateEnemy  ;unconditional branch
                if (temp4 == 0) {
                }
            }
        }
    }
    //> CheckForBloober:
    //> cpx #$48                 ;check for cheep-cheep offset loaded
    //> beq CheckToAnimateEnemy  ;branch if found
    if (temp4 != 0x48) {
        //> lda EnemyIntervalTimer,y
        temp0 = enemyIntervalTimer[temp1]
        //> cmp #$05
        //> bcs CheckDefeatedState   ;branch if some timer is above a certain point
        if (!(temp0 >= 0x05)) {
            //> cpx #$3c                 ;check for bloober offset loaded
            //> bne CheckToAnimateEnemy  ;branch if not found this time
            if (temp4 == 0x3C) {
                //> cmp #$01
                //> beq CheckDefeatedState   ;branch if timer is set to certain point
                if (temp0 != 0x01) {
                    //> inc $02                  ;increment saved vertical coordinate three pixels
                    memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
                    //> inc $02
                    memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
                    //> inc $02
                    memory[0x2] = ((memory[0x2].toInt() + 1) and 0xFF).toUByte()
                    //> jmp CheckAnimationStop   ;and do something else
                }
            }
        }
    } else {
        //> CheckToAnimateEnemy:
        //> lda $ef                  ;check for specific enemy objects
        temp0 = memory[0xEF].toInt()
        //> cmp #Goomba
        //> beq CheckDefeatedState   ;branch if goomba
        if (temp0 != Goomba) {
            //> cmp #$08
            //> beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
            if (temp0 != 0x08) {
                //> cmp #Podoboo
                //> beq CheckDefeatedState   ;branch if podoboo
                if (temp0 != Podoboo) {
                    //> cmp #$18                 ;branch if => $18
                    //> bcs CheckDefeatedState
                    if (!(temp0 >= 0x18)) {
                        //> ldy #$00
                        temp1 = 0x00
                        //> cmp #$15                 ;check for mushroom retainer/princess object
                        //> bne CheckForSecondFrame  ;which uses different code here, branch if not found
                        if (temp0 == 0x15) {
                            //> iny                      ;residual instruction
                            temp1 = (temp1 + 1) and 0xFF
                            //> lda WorldNumber          ;are we on world 8?
                            temp0 = worldNumber
                            //> cmp #World8
                            //> bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
                            if (!(temp0 >= World8)) {
                                //> ldx #$a2                 ;otherwise, set for mushroom retainer object instead
                                temp4 = 0xA2
                                //> lda #$03                 ;set alternate state here
                                temp0 = 0x03
                                //> sta $ec
                                memory[0xEC] = temp0.toUByte()
                                //> bne CheckDefeatedState   ;unconditional branch
                                if (temp0 == 0) {
                                }
                            }
                        }
                        //> CheckForSecondFrame:
                        //> lda FrameCounter            ;load frame counter
                        temp0 = frameCounter
                        //> and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
                        temp17 = temp0 and enemyAnimTimingBMask[temp1]
                        //> bne CheckDefeatedState      ;branch if timing is off
                        temp0 = temp17
                        if (temp17 == 0) {
                        }
                    }
                }
            }
        }
    }
    //> CheckAnimationStop:
    //> lda $ed                 ;check saved enemy state
    temp0 = memory[0xED].toInt()
    //> and #%10100000          ;for d7 or d5, or check for timers stopped
    temp18 = temp0 and 0xA0
    //> ora TimerControl
    temp19 = temp18 or timerControl
    //> bne CheckDefeatedState  ;if either condition true, branch
    temp0 = temp19
    if (temp19 == 0) {
        //> txa
        //> clc
        //> adc #$06                ;add $06 to current enemy offset
        temp20 = temp4 + 0x06
        temp0 = temp20 and 0xFF
        //> tax                     ;to animate various enemy objects
    }
    //> CheckDefeatedState:
    //> lda $ed               ;check saved enemy state
    temp0 = memory[0xED].toInt()
    //> and #%00100000        ;for d5 set
    temp21 = temp0 and 0x20
    //> beq DrawEnemyObject   ;branch if not set
    temp0 = temp21
    if (temp21 != 0) {
        //> lda $ef
        temp0 = memory[0xEF].toInt()
        //> cmp #$04              ;check for saved enemy object => $04
        //> bcc DrawEnemyObject   ;branch if less
        if (temp0 >= 0x04) {
            //> ldy #$01
            temp1 = 0x01
            //> sty VerticalFlipFlag  ;set vertical flip flag
            verticalFlipFlag = temp1
            //> dey
            temp1 = (temp1 - 1) and 0xFF
            //> sty $ec               ;init saved value here
            memory[0xEC] = temp1.toUByte()
        }
    }
    //> DrawEnemyObject:
    //> ldy $eb                    ;load sprite data offset
    temp1 = memory[0xEB].toInt()
    //> jsr DrawEnemyObjRow        ;draw six tiles of data
    drawEnemyObjRow(temp4)
    //> jsr DrawEnemyObjRow        ;into sprite data
    drawEnemyObjRow(temp4)
    //> jsr DrawEnemyObjRow
    drawEnemyObjRow(temp4)
    //> ldx ObjectOffset           ;get enemy object offset
    temp4 = objectOffset
    //> ldy Enemy_SprDataOffset,x  ;get sprite data offset
    temp1 = enemySprdataoffset[temp4]
    //> lda $ef
    temp0 = memory[0xEF].toInt()
    //> cmp #$08                   ;get saved enemy object and check
    //> bne CheckForVerticalFlip   ;for bullet bill, branch if not found
    if (temp0 == 0x08) {
    } else {
        //> CheckForVerticalFlip:
        //> lda VerticalFlipFlag       ;check if vertical flip flag is set here
        temp0 = verticalFlipFlag
        //> beq CheckForESymmetry      ;branch if not
        if (temp0 != 0) {
            //> lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
            temp0 = spriteAttributes[temp1]
            //> ora #%10000000             ;set bit for vertical flip
            temp22 = temp0 or 0x80
            //> iny
            temp1 = (temp1 + 1) and 0xFF
            //> iny                        ;increment two bytes so that we store the vertical flip
            temp1 = (temp1 + 1) and 0xFF
            //> jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
            dumpSixSpr(temp22, temp1)
            //> dey
            temp1 = (temp1 - 1) and 0xFF
            //> dey                        ;now go back to the Y coordinate offset
            temp1 = (temp1 - 1) and 0xFF
            //> tya
            //> tax                        ;give offset to X
            //> lda $ef
            temp0 = memory[0xEF].toInt()
            //> cmp #HammerBro             ;check saved enemy object for hammer bro
            //> beq FlipEnemyVertically
            temp4 = temp1
            if (temp0 != HammerBro) {
                //> cmp #Lakitu                ;check saved enemy object for lakitu
                //> beq FlipEnemyVertically    ;branch for hammer bro or lakitu
                if (temp0 != Lakitu) {
                    //> cmp #$15
                    //> bcs FlipEnemyVertically    ;also branch if enemy object => $15
                    if (!(temp0 >= 0x15)) {
                        //> txa
                        //> clc
                        //> adc #$08                   ;if not selected objects or => $15, set
                        temp23 = temp4 + 0x08
                        temp0 = temp23 and 0xFF
                        //> tax                        ;offset in X for next row
                    }
                }
            }
            //> FlipEnemyVertically:
            //> lda Sprite_Tilenumber,x     ;load first or second row tiles
            temp0 = spriteTilenumber[temp4]
            //> pha                         ;and save tiles to the stack
            push(temp0)
            //> lda Sprite_Tilenumber+4,x
            temp0 = spriteTilenumber[4 + temp4]
            //> pha
            push(temp0)
            //> lda Sprite_Tilenumber+16,y  ;exchange third row tiles
            temp0 = spriteTilenumber[16 + temp1]
            //> sta Sprite_Tilenumber,x     ;with first or second row tiles
            spriteTilenumber[temp4] = temp0
            //> lda Sprite_Tilenumber+20,y
            temp0 = spriteTilenumber[20 + temp1]
            //> sta Sprite_Tilenumber+4,x
            spriteTilenumber[4 + temp4] = temp0
            //> pla                         ;pull first or second row tiles from stack
            temp0 = pull()
            //> sta Sprite_Tilenumber+20,y  ;and save in third row
            spriteTilenumber[20 + temp1] = temp0
            //> pla
            temp0 = pull()
            //> sta Sprite_Tilenumber+16,y
            spriteTilenumber[16 + temp1] = temp0
        }
        //> CheckForESymmetry:
        //> lda BowserGfxFlag           ;are we drawing bowser at all?
        temp0 = bowserGfxFlag
        //> bne SkipToOffScrChk         ;branch if so
        if (!(temp0 == 0)) {
            //  goto SkipToOffScrChk
            return
        }
        //> lda $ef
        temp0 = memory[0xEF].toInt()
        //> ldx $ec                     ;get alternate enemy state
        temp4 = memory[0xEC].toInt()
        //> cmp #$05                    ;check for hammer bro object
        //> bne ContES
        if (temp0 == 0x05) {
        } else {
            //> ContES: cmp #Bloober                ;check for bloober object
            //> beq MirrorEnemyGfx
            if (temp0 != Bloober) {
                //> cmp #PiranhaPlant           ;check for piranha plant object
                //> beq MirrorEnemyGfx
                if (temp0 != PiranhaPlant) {
                    //> cmp #Podoboo                ;check for podoboo object
                    //> beq MirrorEnemyGfx          ;branch if either of three are found
                    if (temp0 != Podoboo) {
                        //> cmp #Spiny                  ;check for spiny object
                        //> bne ESRtnr                  ;branch closer if not found
                        if (temp0 == Spiny) {
                            //> cpx #$05                    ;check spiny's state
                            //> bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
                            if (temp4 == 0x05) {
                            }
                        }
                        //> ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
                        //> bne SpnySC
                        if (temp0 == 0x15) {
                            //> lda #$42                    ;set horizontal flip on bottom right sprite
                            temp0 = 0x42
                            //> sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
                            spriteAttributes[20 + temp1] = temp0
                        }
                        //> SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
                        //> bcc CheckToMirrorLakitu
                        if (temp4 >= 0x02) {
                        }
                    }
                }
            }
            //> MirrorEnemyGfx:
            //> lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
            temp0 = bowserGfxFlag
            //> bne CheckToMirrorLakitu
            if (temp0 == 0) {
                //> lda Sprite_Attributes,y     ;load attribute bits of first sprite
                temp0 = spriteAttributes[temp1]
                //> and #%10100011
                temp24 = temp0 and 0xA3
                //> sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
                spriteAttributes[temp1] = temp24
                //> sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
                spriteAttributes[8 + temp1] = temp24
                //> sta Sprite_Attributes+16,y
                spriteAttributes[16 + temp1] = temp24
                //> ora #%01000000              ;set horizontal flip
                temp25 = temp24 or 0x40
                //> cpx #$05                    ;check for state used by spiny's egg
                //> bne EggExc                  ;if alternate state not set to $05, branch
                temp0 = temp25
                if (temp4 == 0x05) {
                    //> ora #%10000000              ;otherwise set vertical flip
                    temp26 = temp0 or 0x80
                }
                //> EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
                spriteAttributes[4 + temp1] = temp0
                //> sta Sprite_Attributes+12,y  ;of enemy object sprite data
                spriteAttributes[12 + temp1] = temp0
                //> sta Sprite_Attributes+20,y
                spriteAttributes[20 + temp1] = temp0
                //> cpx #$04                    ;check alternate enemy state
                //> bne CheckToMirrorLakitu     ;branch if not $04
                if (temp4 == 0x04) {
                    //> lda Sprite_Attributes+8,y   ;get second row left sprite attributes
                    temp0 = spriteAttributes[8 + temp1]
                    //> ora #%10000000
                    temp27 = temp0 or 0x80
                    //> sta Sprite_Attributes+8,y   ;store bits with vertical flip in
                    spriteAttributes[8 + temp1] = temp27
                    //> sta Sprite_Attributes+16,y  ;second and third row left sprites
                    spriteAttributes[16 + temp1] = temp27
                    //> ora #%01000000
                    temp28 = temp27 or 0x40
                    //> sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
                    spriteAttributes[12 + temp1] = temp28
                    //> sta Sprite_Attributes+20,y  ;second and third row right sprites
                    spriteAttributes[20 + temp1] = temp28
                }
            }
            //> CheckToMirrorLakitu:
            //> lda $ef                     ;check for lakitu enemy object
            temp0 = memory[0xEF].toInt()
            //> cmp #Lakitu
            //> bne CheckToMirrorJSpring    ;branch if not found
            if (temp0 == Lakitu) {
                //> lda VerticalFlipFlag
                temp0 = verticalFlipFlag
                //> bne NVFLak                  ;branch if vertical flip flag not set
                if (temp0 == 0) {
                    //> lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
                    temp0 = spriteAttributes[16 + temp1]
                    //> and #%10000001              ;in third row left sprite
                    temp29 = temp0 and 0x81
                    //> sta Sprite_Attributes+16,y
                    spriteAttributes[16 + temp1] = temp29
                    //> lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
                    temp0 = spriteAttributes[20 + temp1]
                    //> ora #%01000001              ;in third row right sprite
                    temp30 = temp0 or 0x41
                    //> sta Sprite_Attributes+20,y
                    spriteAttributes[20 + temp1] = temp30
                    //> ldx FrenzyEnemyTimer        ;check timer
                    temp4 = frenzyEnemyTimer
                    //> cpx #$10
                    //> bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
                    temp0 = temp30
                    if (!(temp4 >= 0x10)) {
                        //> sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
                        spriteAttributes[12 + temp1] = temp0
                        //> and #%10000001
                        temp31 = temp0 and 0x81
                        //> sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
                        spriteAttributes[8 + temp1] = temp31
                        //> bcc SprObjectOffscrChk      ;unconditional branch
                        temp0 = temp31
                        if (temp4 >= 0x10) {
                        }
                    }
                }
                //> NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
                temp0 = spriteAttributes[temp1]
                //> and #%10000001
                temp32 = temp0 and 0x81
                //> sta Sprite_Attributes,y     ;save vertical flip and palette bits
                spriteAttributes[temp1] = temp32
                //> lda Sprite_Attributes+4,y   ;get first row right sprite attributes
                temp0 = spriteAttributes[4 + temp1]
                //> ora #%01000001              ;set horizontal flip and palette bits
                temp33 = temp0 or 0x41
                //> sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
                spriteAttributes[4 + temp1] = temp33
            }
            //> CheckToMirrorJSpring:
            //> lda $ef                     ;check for jumpspring object (any frame)
            temp0 = memory[0xEF].toInt()
            //> cmp #$18
            //> bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
            if (temp0 >= 0x18) {
                //> lda #$82
                temp0 = 0x82
                //> sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
                spriteAttributes[8 + temp1] = temp0
                //> sta Sprite_Attributes+16,y  ;second and third row left sprites
                spriteAttributes[16 + temp1] = temp0
                //> ora #%01000000
                temp34 = temp0 or 0x40
                //> sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
                spriteAttributes[12 + temp1] = temp34
                //> sta Sprite_Attributes+20,y  ;for second and third row right sprites
                spriteAttributes[20 + temp1] = temp34
            }
        }
    }
    //> SprObjectOffscrChk:
    //> ldx ObjectOffset          ;get enemy buffer offset
    temp4 = objectOffset
    //> lda Enemy_OffscreenBits   ;check offscreen information
    temp0 = enemyOffscreenbits
    //> lsr
    temp0 = temp0 shr 1
    //> lsr                       ;shift three times to the right
    temp0 = temp0 shr 1
    //> lsr                       ;which puts d2 into carry
    temp0 = temp0 shr 1
    //> pha                       ;save to stack
    push(temp0)
    //> bcc LcChk                 ;branch if not set
    if ((temp0 and 0x01) != 0) {
        //> lda #$04                  ;set for right column sprites
        temp0 = 0x04
        //> jsr MoveESprColOffscreen  ;and move them offscreen
        moveESprColOffscreen(temp0, temp4)
    }
    //> LcChk:   pla                       ;get from stack
    temp0 = pull()
    //> lsr                       ;move d3 to carry
    temp0 = temp0 shr 1
    //> pha                       ;save to stack
    push(temp0)
    //> bcc Row3C                 ;branch if not set
    if ((temp0 and 0x01) != 0) {
        //> lda #$00                  ;set for left column sprites,
        temp0 = 0x00
        //> jsr MoveESprColOffscreen  ;move them offscreen
        moveESprColOffscreen(temp0, temp4)
    }
    //> Row3C:   pla                       ;get from stack again
    temp0 = pull()
    //> lsr                       ;move d5 to carry this time
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> pha                       ;save to stack again
    push(temp0)
    //> bcc Row23C                ;branch if carry not set
    if ((temp0 and 0x01) != 0) {
        //> lda #$10                  ;set for third row of sprites
        temp0 = 0x10
        //> jsr MoveESprRowOffscreen  ;and move them offscreen
        moveESprRowOffscreen(temp0, temp4)
    }
    //> Row23C:  pla                       ;get from stack
    temp0 = pull()
    //> lsr                       ;move d6 into carry
    temp0 = temp0 shr 1
    //> pha                       ;save to stack
    push(temp0)
    //> bcc AllRowC
    if ((temp0 and 0x01) != 0) {
        //> lda #$08                  ;set for second and third rows
        temp0 = 0x08
        //> jsr MoveESprRowOffscreen  ;move them offscreen
        moveESprRowOffscreen(temp0, temp4)
    }
    //> AllRowC: pla                       ;get from stack once more
    temp0 = pull()
    //> lsr                       ;move d7 into carry
    temp0 = temp0 shr 1
    //> bcc ExEGHandler
    if ((temp0 and 0x01) != 0) {
        //> jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
        moveESprRowOffscreen(temp0, temp4)
        //> lda Enemy_ID,x
        temp0 = enemyId[temp4]
        //> cmp #Podoboo              ;check enemy identifier for podoboo
        //> beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
        if (temp0 != Podoboo) {
            //> lda Enemy_Y_HighPos,x     ;check high byte of vertical position
            temp0 = enemyYHighpos[temp4]
            //> cmp #$02                  ;if not yet past the bottom of the screen, branch
            //> bne ExEGHandler
            if (temp0 == 0x02) {
                //> jsr EraseEnemyObject      ;what it says
                eraseEnemyObject(temp4)
            }
        }
    }
    //> ExEGHandler:
    //> rts
    return
}

// Decompiled from DrawEnemyObjRow
fun drawEnemyObjRow(X: Int) {
    val enemyGraphicsTable by MemoryByteIndexed(EnemyGraphicsTable)
    //> DrawEnemyObjRow:
    //> lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
    //> sta $00
    memory[0x0] = (enemyGraphicsTable[X] and 0xFF).toUByte()
    //> lda EnemyGraphicsTable+1,x
    // Fall-through tail call to drawOneSpriteRow
    drawOneSpriteRow(enemyGraphicsTable[1 + X], X, Y)
}

// Decompiled from DrawOneSpriteRow
fun drawOneSpriteRow(A: Int, X: Int, Y: Int) {
    var X: Int = X
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawOneSpriteRow:
    //> sta $01
    memory[0x1] = A.toUByte()
    //> jmp DrawSpriteObject        ;draw them
    //> DrawSpriteObject:
    //> lda $03                    ;get saved flip control bits
    //> lsr
    //> lsr                        ;move d1 into carry
    //> lda $00
    //> bcc NoHFlip                ;if d1 not set, branch
    temp0 = memory[0x0].toInt()
    if ((memory[0x3].toInt() shr 1 and 0x01) != 0) {
        //> sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
        spriteTilenumber[4 + Y] = temp0
        //> lda $01                    ;and second into first sprite
        temp0 = memory[0x1].toInt()
        //> sta Sprite_Tilenumber,y
        spriteTilenumber[Y] = temp0
        //> lda #$40                   ;activate horizontal flip OAM attribute
        temp0 = 0x40
        //> bne SetHFAt                ;and unconditionally branch
        if (temp0 == 0) {
        } else {
            //> SetHFAt: ora $04                    ;add other OAM attributes if necessary
            temp1 = temp0 or memory[0x4].toInt()
            //> sta Sprite_Attributes,y    ;store sprite attributes
            spriteAttributes[Y] = temp1
            //> sta Sprite_Attributes+4,y
            spriteAttributes[4 + Y] = temp1
            //> lda $02                    ;now the y coordinates
            temp0 = memory[0x2].toInt()
            //> sta Sprite_Y_Position,y    ;note because they are
            spriteYPosition[Y] = temp0
            //> sta Sprite_Y_Position+4,y  ;side by side, they are the same
            spriteYPosition[4 + Y] = temp0
            //> lda $05
            temp0 = memory[0x5].toInt()
            //> sta Sprite_X_Position,y    ;store x coordinate, then
            spriteXPosition[Y] = temp0
            //> clc                        ;add 8 pixels and store another to
            //> adc #$08                   ;put them side by side
            temp2 = temp0 + 0x08
            temp0 = temp2 and 0xFF
            //> sta Sprite_X_Position+4,y
            spriteXPosition[4 + Y] = temp0
            //> lda $02                    ;add eight pixels to the next y
            temp0 = memory[0x2].toInt()
            //> clc                        ;coordinate
            //> adc #$08
            temp3 = temp0 + 0x08
            temp0 = temp3 and 0xFF
            //> sta $02
            memory[0x2] = temp0.toUByte()
            //> tya                        ;add eight to the offset in Y to
            //> clc                        ;move to the next two sprites
            //> adc #$08
            temp4 = Y + 0x08
            temp0 = temp4 and 0xFF
            //> tay
            //> inx                        ;increment offset to return it to the
            X = (X + 1) and 0xFF
            //> inx                        ;routine that called this subroutine
            X = (X + 1) and 0xFF
            //> rts
            return
        }
    }
    //> NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
    spriteTilenumber[Y] = temp0
    //> lda $01                    ;and second into second sprite
    temp0 = memory[0x1].toInt()
    //> sta Sprite_Tilenumber+4,y
    spriteTilenumber[4 + Y] = temp0
    //> lda #$00                   ;clear bit for horizontal flip
    temp0 = 0x00
}

// Decompiled from MoveESprRowOffscreen
fun moveESprRowOffscreen(A: Int, X: Int) {
    var temp0: Int = 0
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    //> MoveESprRowOffscreen:
    //> clc                         ;add A to enemy object OAM data offset
    //> adc Enemy_SprDataOffset,x
    temp0 = A + enemySprdataoffset[X]
    //> tay                         ;use as offset
    //> lda #$f8
    //> jmp DumpTwoSpr              ;move first row of sprites offscreen
}

// Decompiled from MoveESprColOffscreen
fun moveESprColOffscreen(A: Int, X: Int) {
    var temp0: Int = 0
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val spriteData by MemoryByteIndexed(Sprite_Data)
    //> MoveESprColOffscreen:
    //> clc                         ;add A to enemy object OAM data offset
    //> adc Enemy_SprDataOffset,x
    temp0 = A + enemySprdataoffset[X]
    //> tay                         ;use as offset
    //> jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
    moveColOffscreen(temp0 and 0xFF)
    //> sta Sprite_Data+16,y        ;move third row sprite in column offscreen
    spriteData[16 + (temp0 and 0xFF)] = temp0 and 0xFF
    //> rts
    return
}

// Decompiled from DrawBlock
fun drawBlock(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var areaType by MemoryByte(AreaType)
    var blockOffscreenbits by MemoryByte(Block_OffscreenBits)
    var blockRelXpos by MemoryByte(Block_Rel_XPos)
    var blockRelYpos by MemoryByte(Block_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val blockMetatile by MemoryByteIndexed(Block_Metatile)
    val blockSprdataoffset by MemoryByteIndexed(Block_SprDataOffset)
    val defaultBlockObjTiles by MemoryByteIndexed(DefaultBlockObjTiles)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawBlock:
    //> lda Block_Rel_YPos            ;get relative vertical coordinate of block object
    //> sta $02                       ;store here
    memory[0x2] = blockRelYpos.toUByte()
    //> lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
    //> sta $05                       ;store here
    memory[0x5] = blockRelXpos.toUByte()
    //> lda #$03
    //> sta $04                       ;set attribute byte here
    memory[0x4] = 0x03.toUByte()
    //> lsr
    //> sta $03                       ;set horizontal flip bit here (will not be used)
    memory[0x3] = ((0x03 shr 1) and 0xFF).toUByte()
    //> ldy Block_SprDataOffset,x     ;get sprite data offset
    //> ldx #$00                      ;reset X for use as offset to tile data
    temp0 = 0x00
    temp1 = blockSprdataoffset[X]
    do {
        //> DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
        //> sta $00                       ;set here
        memory[0x0] = (defaultBlockObjTiles[temp0] and 0xFF).toUByte()
        //> lda DefaultBlockObjTiles+1,x  ;get right tile number
        //> jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
        drawOneSpriteRow(defaultBlockObjTiles[1 + temp0], temp0, temp1)
        //> cpx #$04                      ;check incremented offset
        //> bne DBlkLoop                  ;and loop back until all four sprites are done
    } while (temp0 != 0x04)
    //> ldx ObjectOffset              ;get block object offset
    temp0 = objectOffset
    //> ldy Block_SprDataOffset,x     ;get sprite data offset
    temp1 = blockSprdataoffset[temp0]
    //> lda AreaType
    //> cmp #$01                      ;check for ground level type area
    //> beq ChkRep                    ;if found, branch to next part
    temp2 = areaType
    if (areaType != 0x01) {
        //> lda #$86
        temp2 = 0x86
        //> sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
        spriteTilenumber[temp1] = temp2
        //> sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
        spriteTilenumber[4 + temp1] = temp2
    }
    //> ChkRep:    lda Block_Metatile,x          ;check replacement metatile
    temp2 = blockMetatile[temp0]
    //> cmp #$c4                      ;if not used block metatile, then
    //> bne BlkOffscr                 ;branch ahead to use current graphics
    if (temp2 == 0xC4) {
        //> lda #$87                      ;set A for used block tile
        temp2 = 0x87
        //> iny                           ;increment Y to write to tile bytes
        temp1 = (temp1 + 1) and 0xFF
        //> jsr DumpFourSpr               ;do sub to dump into all four sprites
        dumpFourSpr(temp2, temp1)
        //> dey                           ;return Y to original offset
        temp1 = (temp1 - 1) and 0xFF
        //> lda #$03                      ;set palette bits
        temp2 = 0x03
        //> ldx AreaType
        temp0 = areaType
        //> dex                           ;check for ground level type area again
        temp0 = (temp0 - 1) and 0xFF
        //> beq SetBFlip                  ;if found, use current palette bits
        if (temp0 != 0) {
            //> lsr                           ;otherwise set to $01
            temp2 = temp2 shr 1
        }
        //> SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
        temp0 = objectOffset
        //> sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
        spriteAttributes[temp1] = temp2
        //> ora #%01000000
        temp3 = temp2 or 0x40
        //> sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
        spriteAttributes[4 + temp1] = temp3
        //> ora #%10000000
        temp4 = temp3 or 0x80
        //> sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
        spriteAttributes[12 + temp1] = temp4
        //> and #%10000011
        temp5 = temp4 and 0x83
        //> sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
        spriteAttributes[8 + temp1] = temp5
    }
    //> BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
    temp2 = blockOffscreenbits
    //> pha                           ;save to stack
    push(temp2)
    //> and #%00000100                ;check to see if d2 in offscreen bits are set
    temp6 = temp2 and 0x04
    //> beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
    temp2 = temp6
    if (temp6 != 0) {
        //> lda #$f8                      ;move offscreen two OAMs
        temp2 = 0xF8
        //> sta Sprite_Y_Position+4,y     ;on the right side
        spriteYPosition[4 + temp1] = temp2
        //> sta Sprite_Y_Position+12,y
        spriteYPosition[12 + temp1] = temp2
    }
    //> PullOfsB:  pla                           ;pull offscreen bits from stack
    temp2 = pull()
    // Fall-through tail call to chkLeftCo
    chkLeftCo(temp2)
}

// Decompiled from ChkLeftCo
fun chkLeftCo(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    //> ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
    temp0 = A and 0x08
    //> beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
    if (temp0 == 0) {
        //  goto ExDBlk
        return
    }
    temp1 = temp0
    if (temp0 != 0) {
    }
    //> ExDBlk: rts
    return
}

// Decompiled from MoveColOffscreen
fun moveColOffscreen(Y: Int): Int {
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> MoveColOffscreen:
    //> lda #$f8                   ;move offscreen two OAMs
    //> sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
    spriteYPosition[Y] = 0xF8
    //> sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
    spriteYPosition[8 + Y] = 0xF8
    //> ExDBlk: rts
    return A
}

// Decompiled from DrawBrickChunks
fun drawBrickChunks(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var blockOffscreenbits by MemoryByte(Block_OffscreenBits)
    var frameCounter by MemoryByte(FrameCounter)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val blockOrigXpos by MemoryByteIndexed(Block_Orig_XPos)
    val blockRelXpos by MemoryByteIndexed(Block_Rel_XPos)
    val blockRelYpos by MemoryByteIndexed(Block_Rel_YPos)
    val blockSprdataoffset by MemoryByteIndexed(Block_SprDataOffset)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawBrickChunks:
    //> lda #$02                   ;set palette bits here
    //> sta $00
    memory[0x0] = 0x02.toUByte()
    //> lda #$75                   ;set tile number for ball (something residual, likely)
    //> ldy GameEngineSubroutine
    //> cpy #$05                   ;if end-of-level routine running,
    //> beq DChunks                ;use palette and tile number assigned
    temp0 = 0x75
    temp1 = gameEngineSubroutine
    if (gameEngineSubroutine != 0x05) {
        //> lda #$03                   ;otherwise set different palette bits
        temp0 = 0x03
        //> sta $00
        memory[0x0] = temp0.toUByte()
        //> lda #$84                   ;and set tile number for brick chunks
        temp0 = 0x84
    }
    //> DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
    temp1 = blockSprdataoffset[X]
    //> iny                        ;increment to start with tile bytes in OAM
    temp1 = (temp1 + 1) and 0xFF
    //> jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
    dumpFourSpr(temp0, temp1)
    //> lda FrameCounter           ;get frame counter
    temp0 = frameCounter
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> asl                        ;move low nybble to high
    temp0 = (temp0 shl 1) and 0xFF
    //> asl
    temp0 = (temp0 shl 1) and 0xFF
    //> and #$c0                   ;get what was originally d3-d2 of low nybble
    temp2 = temp0 and 0xC0
    //> ora $00                    ;add palette bits
    temp3 = temp2 or memory[0x0].toInt()
    //> iny                        ;increment offset for attribute bytes
    temp1 = (temp1 + 1) and 0xFF
    //> jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
    dumpFourSpr(temp3, temp1)
    //> dey
    temp1 = (temp1 - 1) and 0xFF
    //> dey                        ;decrement offset to Y coordinate
    temp1 = (temp1 - 1) and 0xFF
    //> lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
    temp0 = blockRelYpos[0]
    //> jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
    dumpTwoSpr(temp0, temp1)
    //> lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
    temp0 = blockRelXpos[0]
    //> sta Sprite_X_Position,y    ;save into X coordinate of first sprite
    spriteXPosition[temp1] = temp0
    //> lda Block_Orig_XPos,x      ;get original horizontal coordinate
    temp0 = blockOrigXpos[X]
    //> sec
    //> sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
    temp4 = temp0 - screenleftXPos
    temp0 = temp4 and 0xFF
    //> sta $00                    ;store result as relative horizontal coordinate of original
    memory[0x0] = temp0.toUByte()
    //> sec
    //> sbc Block_Rel_XPos         ;get difference of relative positions of original - current
    temp5 = temp0 - blockRelXpos[0]
    temp0 = temp5 and 0xFF
    //> adc $00                    ;add original relative position to result
    temp6 = temp0 + memory[0x0].toInt() + (if (temp5 >= 0) 1 else 0)
    temp0 = temp6 and 0xFF
    //> adc #$06                   ;plus 6 pixels to position second brick chunk correctly
    temp7 = temp0 + 0x06 + (if (temp6 > 0xFF) 1 else 0)
    temp0 = temp7 and 0xFF
    //> sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
    spriteXPosition[4 + temp1] = temp0
    //> lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
    temp0 = blockRelYpos[1]
    //> sta Sprite_Y_Position+8,y
    spriteYPosition[8 + temp1] = temp0
    //> sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
    spriteYPosition[12 + temp1] = temp0
    //> lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
    temp0 = blockRelXpos[1]
    //> sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
    spriteXPosition[8 + temp1] = temp0
    //> lda $00                    ;use original relative horizontal position
    temp0 = memory[0x0].toInt()
    //> sec
    //> sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
    temp8 = temp0 - blockRelXpos[1]
    temp0 = temp8 and 0xFF
    //> adc $00                    ;add original relative position to result
    temp9 = temp0 + memory[0x0].toInt() + (if (temp8 >= 0) 1 else 0)
    temp0 = temp9 and 0xFF
    //> adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
    temp10 = temp0 + 0x06 + (if (temp9 > 0xFF) 1 else 0)
    temp0 = temp10 and 0xFF
    //> sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
    spriteXPosition[12 + temp1] = temp0
    //> lda Block_OffscreenBits    ;get offscreen bits for block object
    temp0 = blockOffscreenbits
    //> jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
    chkLeftCo(temp0)
    //> lda Block_OffscreenBits    ;get offscreen bits again
    temp0 = blockOffscreenbits
    //> asl                        ;shift d7 into carry
    temp0 = (temp0 shl 1) and 0xFF
    //> bcc ChnkOfs                ;if d7 not set, branch to last part
    if ((temp0 and 0x80) != 0) {
        //> lda #$f8
        temp0 = 0xF8
        //> jsr DumpTwoSpr             ;otherwise move top sprites offscreen
        dumpTwoSpr(temp0, temp1)
    }
    //> ChnkOfs: lda $00                    ;if relative position on left side of screen,
    temp0 = memory[0x0].toInt()
    //> bpl ExBCDr                 ;go ahead and leave
    if ((temp0 and 0x80) != 0) {
        //> lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
        temp0 = spriteXPosition[temp1]
        //> cmp Sprite_X_Position+4,y  ;to right-side X coordinate
        //> bcc ExBCDr                 ;branch to leave if less
        if (temp0 >= spriteXPosition[4 + temp1]) {
            //> lda #$f8                   ;otherwise move right half of sprites offscreen
            temp0 = 0xF8
            //> sta Sprite_Y_Position+4,y
            spriteYPosition[4 + temp1] = temp0
            //> sta Sprite_Y_Position+12,y
            spriteYPosition[12 + temp1] = temp0
        }
    }
    //> ExBCDr:  rts                        ;leave
    return
}

// Decompiled from DrawFirebar
fun drawFirebar(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    //> DrawFirebar:
    //> lda FrameCounter         ;get frame counter
    //> lsr                      ;divide by four
    frameCounter = frameCounter shr 1
    //> lsr
    frameCounter = frameCounter shr 1
    //> pha                      ;save result to stack
    push(frameCounter)
    //> and #$01                 ;mask out all but last bit
    temp0 = frameCounter and 0x01
    //> eor #$64                 ;set either tile $64 or $65 as fireball tile
    temp1 = temp0 xor 0x64
    //> sta Sprite_Tilenumber,y  ;thus tile changes every four frames
    spriteTilenumber[Y] = temp1
    //> pla                      ;get from stack
    temp2 = pull()
    //> lsr                      ;divide by four again
    temp2 = temp2 shr 1
    //> lsr
    temp2 = temp2 shr 1
    //> lda #$02                 ;load value $02 to set palette in attrib byte
    //> bcc FireA                ;if last bit shifted out was not set, skip this
    temp3 = 0x02
    if ((temp2 and 0x01) != 0) {
        //> ora #%11000000           ;otherwise flip both ways every eight frames
        temp4 = temp3 or 0xC0
    }
    //> FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
    spriteAttributes[Y] = temp3
    //> rts
    return
}

// Decompiled from DrawExplosion_Fireworks
fun drawexplosionFireworks(A: Int, Y: Int) {
    var Y: Int = Y
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var fireballRelXpos by MemoryByte(Fireball_Rel_XPos)
    var fireballRelYpos by MemoryByte(Fireball_Rel_YPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val explosionTiles by MemoryByteIndexed(ExplosionTiles)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawExplosion_Fireworks:
    //> tax                         ;use whatever's in A for offset
    //> lda ExplosionTiles,x        ;get tile number using offset
    //> iny                         ;increment Y (contains sprite data offset)
    Y = (Y + 1) and 0xFF
    //> jsr DumpFourSpr             ;and dump into tile number part of sprite data
    dumpFourSpr(explosionTiles[A], Y)
    //> dey                         ;decrement Y so we have the proper offset again
    Y = (Y - 1) and 0xFF
    //> ldx ObjectOffset            ;return enemy object buffer offset to X
    //> lda Fireball_Rel_YPos       ;get relative vertical coordinate
    //> sec                         ;subtract four pixels vertically
    //> sbc #$04                    ;for first and third sprites
    temp0 = fireballRelYpos - 0x04
    //> sta Sprite_Y_Position,y
    spriteYPosition[Y] = temp0 and 0xFF
    //> sta Sprite_Y_Position+8,y
    spriteYPosition[8 + Y] = temp0 and 0xFF
    //> clc                         ;add eight pixels vertically
    //> adc #$08                    ;for second and fourth sprites
    temp1 = (temp0 and 0xFF) + 0x08
    //> sta Sprite_Y_Position+4,y
    spriteYPosition[4 + Y] = temp1 and 0xFF
    //> sta Sprite_Y_Position+12,y
    spriteYPosition[12 + Y] = temp1 and 0xFF
    //> lda Fireball_Rel_XPos       ;get relative horizontal coordinate
    //> sec                         ;subtract four pixels horizontally
    //> sbc #$04                    ;for first and second sprites
    temp2 = fireballRelXpos - 0x04
    //> sta Sprite_X_Position,y
    spriteXPosition[Y] = temp2 and 0xFF
    //> sta Sprite_X_Position+4,y
    spriteXPosition[4 + Y] = temp2 and 0xFF
    //> clc                         ;add eight pixels horizontally
    //> adc #$08                    ;for third and fourth sprites
    temp3 = (temp2 and 0xFF) + 0x08
    //> sta Sprite_X_Position+8,y
    spriteXPosition[8 + Y] = temp3 and 0xFF
    //> sta Sprite_X_Position+12,y
    spriteXPosition[12 + Y] = temp3 and 0xFF
    //> lda #$02                    ;set palette attributes for all sprites, but
    //> sta Sprite_Attributes,y     ;set no flip at all for first sprite
    spriteAttributes[Y] = 0x02
    //> lda #$82
    //> sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
    spriteAttributes[4 + Y] = 0x82
    //> lda #$42
    //> sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
    spriteAttributes[8 + Y] = 0x42
    //> lda #$c2
    //> sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
    spriteAttributes[12 + Y] = 0xC2
    //> rts                         ;we are done
    return
}

// Decompiled from DrawSmallPlatform
fun drawSmallPlatform(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var enemyOffscreenbits by MemoryByte(Enemy_OffscreenBits)
    var enemyRelXpos by MemoryByte(Enemy_Rel_XPos)
    var objectOffset by MemoryByte(ObjectOffset)
    val enemySprdataoffset by MemoryByteIndexed(Enemy_SprDataOffset)
    val enemyYPosition by MemoryByteIndexed(Enemy_Y_Position)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawSmallPlatform:
    //> ldy Enemy_SprDataOffset,x   ;get OAM data offset
    //> lda #$5b                    ;load tile number for small platforms
    //> iny                         ;increment offset for tile numbers
    temp0 = enemySprdataoffset[X]
    temp0 = (temp0 + 1) and 0xFF
    //> jsr DumpSixSpr              ;dump tile number into all six sprites
    dumpSixSpr(0x5B, temp0)
    //> iny                         ;increment offset for attributes
    temp0 = (temp0 + 1) and 0xFF
    //> lda #$02                    ;load palette controls
    //> jsr DumpSixSpr              ;dump attributes into all six sprites
    dumpSixSpr(0x02, temp0)
    //> dey                         ;decrement for original offset
    temp0 = (temp0 - 1) and 0xFF
    //> dey
    temp0 = (temp0 - 1) and 0xFF
    //> lda Enemy_Rel_XPos          ;get relative horizontal coordinate
    //> sta Sprite_X_Position,y
    spriteXPosition[temp0] = enemyRelXpos
    //> sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
    spriteXPosition[12 + temp0] = enemyRelXpos
    //> clc
    //> adc #$08                    ;add eight pixels
    temp1 = enemyRelXpos + 0x08
    //> sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
    spriteXPosition[4 + temp0] = temp1 and 0xFF
    //> sta Sprite_X_Position+16,y
    spriteXPosition[16 + temp0] = temp1 and 0xFF
    //> clc
    //> adc #$08                    ;add eight more pixels
    temp2 = (temp1 and 0xFF) + 0x08
    //> sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
    spriteXPosition[8 + temp0] = temp2 and 0xFF
    //> sta Sprite_X_Position+20,y
    spriteXPosition[20 + temp0] = temp2 and 0xFF
    //> lda Enemy_Y_Position,x      ;get vertical coordinate
    //> tax
    //> pha                         ;save to stack
    push(enemyYPosition[X])
    //> cpx #$20                    ;if vertical coordinate below status bar,
    //> bcs TopSP                   ;do not mess with it
    temp3 = enemyYPosition[X]
    temp4 = enemyYPosition[X]
    if (!(enemyYPosition[X] >= 0x20)) {
        //> lda #$f8                    ;otherwise move first three sprites offscreen
        temp3 = 0xF8
    }
    //> TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
    dumpThreeSpr(temp3, temp0)
    //> pla                         ;pull from stack
    temp3 = pull()
    //> clc
    //> adc #$80                    ;add 128 pixels
    temp5 = temp3 + 0x80
    temp3 = temp5 and 0xFF
    //> tax
    //> cpx #$20                    ;if below status bar (taking wrap into account)
    //> bcs BotSP                   ;then do not change altered coordinate
    temp4 = temp3
    if (!(temp3 >= 0x20)) {
        //> lda #$f8                    ;otherwise move last three sprites offscreen
        temp3 = 0xF8
    }
    //> BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
    spriteYPosition[12 + temp0] = temp3
    //> sta Sprite_Y_Position+16,y  ;into Y coordinates
    spriteYPosition[16 + temp0] = temp3
    //> sta Sprite_Y_Position+20,y
    spriteYPosition[20 + temp0] = temp3
    //> lda Enemy_OffscreenBits     ;get offscreen bits
    temp3 = enemyOffscreenbits
    //> pha                         ;save to stack
    push(temp3)
    //> and #%00001000              ;check d3
    temp6 = temp3 and 0x08
    //> beq SOfs
    temp3 = temp6
    if (temp6 != 0) {
        //> lda #$f8                    ;if d3 was set, move first and
        temp3 = 0xF8
        //> sta Sprite_Y_Position,y     ;fourth sprites offscreen
        spriteYPosition[temp0] = temp3
        //> sta Sprite_Y_Position+12,y
        spriteYPosition[12 + temp0] = temp3
    }
    //> SOfs:  pla                         ;move out and back into stack
    temp3 = pull()
    //> pha
    push(temp3)
    //> and #%00000100              ;check d2
    temp7 = temp3 and 0x04
    //> beq SOfs2
    temp3 = temp7
    if (temp7 != 0) {
        //> lda #$f8                    ;if d2 was set, move second and
        temp3 = 0xF8
        //> sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
        spriteYPosition[4 + temp0] = temp3
        //> sta Sprite_Y_Position+16,y
        spriteYPosition[16 + temp0] = temp3
    }
    //> SOfs2: pla                         ;get from stack
    temp3 = pull()
    //> and #%00000010              ;check d1
    temp8 = temp3 and 0x02
    //> beq ExSPl
    temp3 = temp8
    if (temp8 != 0) {
        //> lda #$f8                    ;if d1 was set, move third and
        temp3 = 0xF8
        //> sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
        spriteYPosition[8 + temp0] = temp3
        //> sta Sprite_Y_Position+20,y
        spriteYPosition[20 + temp0] = temp3
    }
    //> ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
    temp4 = objectOffset
    //> rts
    return
}

// Decompiled from DrawBubble
fun drawBubble(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var bubbleOffscreenbits by MemoryByte(Bubble_OffscreenBits)
    var bubbleRelXpos by MemoryByte(Bubble_Rel_XPos)
    var bubbleRelYpos by MemoryByte(Bubble_Rel_YPos)
    var playerYHighpos by MemoryByte(Player_Y_HighPos)
    val bubbleSprdataoffset by MemoryByteIndexed(Bubble_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val spriteXPosition by MemoryByteIndexed(Sprite_X_Position)
    val spriteYPosition by MemoryByteIndexed(Sprite_Y_Position)
    //> DrawBubble:
    //> ldy Player_Y_HighPos        ;if player's vertical high position
    //> dey                         ;not within screen, skip all of this
    playerYHighpos = (playerYHighpos - 1) and 0xFF
    //> bne ExDBub
    temp0 = playerYHighpos
    if (playerYHighpos == 0) {
        //> lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
        //> and #%00001000
        temp1 = bubbleOffscreenbits and 0x08
        //> bne ExDBub                  ;if bit set, branch to leave
        temp2 = temp1
        if (temp1 == 0) {
            //> ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
            temp0 = bubbleSprdataoffset[X]
            //> lda Bubble_Rel_XPos         ;get relative horizontal coordinate
            temp2 = bubbleRelXpos
            //> sta Sprite_X_Position,y     ;store as X coordinate here
            spriteXPosition[temp0] = temp2
            //> lda Bubble_Rel_YPos         ;get relative vertical coordinate
            temp2 = bubbleRelYpos
            //> sta Sprite_Y_Position,y     ;store as Y coordinate here
            spriteYPosition[temp0] = temp2
            //> lda #$74
            temp2 = 0x74
            //> sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
            spriteTilenumber[temp0] = temp2
            //> lda #$02
            temp2 = 0x02
            //> sta Sprite_Attributes,y     ;set attribute byte
            spriteAttributes[temp0] = temp2
        }
    }
    //> ExDBub: rts                         ;leave
    return
}

// Decompiled from PlayerGfxHandler
fun playerGfxHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var fireballThrowingTimer by MemoryByte(FireballThrowingTimer)
    var frameCounter by MemoryByte(FrameCounter)
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var injuryTimer by MemoryByte(InjuryTimer)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerSize by MemoryByte(PlayerSize)
    var playerOffscreenbits by MemoryByte(Player_OffscreenBits)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    var playerState by MemoryByte(Player_State)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var swimTileRepOffset by MemoryByte(SwimTileRepOffset)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    val spriteTilenumber by MemoryByteIndexed(Sprite_Tilenumber)
    val swimKickTileNum by MemoryByteIndexed(SwimKickTileNum)
    //> PlayerGfxHandler:
    //> lda InjuryTimer             ;if player's injured invincibility timer
    //> beq CntPl                   ;not set, skip checkpoint and continue code
    temp0 = injuryTimer
    if (injuryTimer != 0) {
        //> lda FrameCounter
        temp0 = frameCounter
        //> lsr                         ;otherwise check frame counter and branch
        temp0 = temp0 shr 1
        //> bcs ExPGH                   ;to leave on every other frame (when d0 is set)
        if ((temp0 and 0x01) == 0) {
        } else {
            //> ExPGH:  rts                         ;then leave
            return
        }
    }
    //> CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
    temp0 = gameEngineSubroutine
    //> cmp #$0b                    ;branch ahead to some other part
    //> beq PlayerKilled
    if (temp0 != 0x0B) {
        //> lda PlayerChangeSizeFlag    ;if grow/shrink flag set
        temp0 = playerChangeSizeFlag
        //> bne DoChangeSize            ;then branch to some other code
        if (!(temp0 == 0)) {
            //  goto DoChangeSize
            return
        }
        if (temp0 == 0) {
            //> ldy SwimmingFlag            ;if swimming flag set, branch to
            //> beq FindPlayerAction        ;different part, do not return
            if (swimmingFlag == 0) {
                //  goto FindPlayerAction
                return
            }
            //> lda Player_State
            temp0 = playerState
            //> cmp #$00                    ;if player status normal,
            //> beq FindPlayerAction        ;branch and do not return
            if (temp0 == 0) {
                //  goto FindPlayerAction
                return
            }
            //> jsr FindPlayerAction        ;otherwise jump and return
            findPlayerAction(temp0)
            //> lda FrameCounter
            temp0 = frameCounter
            //> and #%00000100              ;check frame counter for d2 set (8 frames every
            temp1 = temp0 and 0x04
            //> bne ExPGH                   ;eighth frame), and branch if set to leave
            temp0 = temp1
            temp2 = swimmingFlag
            if (temp1 == 0) {
                //> tax                         ;initialize X to zero
                //> ldy Player_SprDataOffset    ;get player sprite data offset
                temp2 = playerSprdataoffset
                //> lda PlayerFacingDir         ;get player's facing direction
                temp0 = playerFacingDir
                //> lsr
                temp0 = temp0 shr 1
                //> bcs SwimKT                  ;if player facing to the right, use current offset
                temp3 = temp0
                if ((temp0 and 0x01) == 0) {
                    //> iny
                    temp2 = (temp2 + 1) and 0xFF
                    //> iny                         ;otherwise move to next OAM data
                    temp2 = (temp2 + 1) and 0xFF
                    //> iny
                    temp2 = (temp2 + 1) and 0xFF
                    //> iny
                    temp2 = (temp2 + 1) and 0xFF
                }
                //> SwimKT: lda PlayerSize              ;check player's size
                temp0 = playerSize
                //> beq BigKTS                  ;if big, use first tile
                if (temp0 != 0) {
                    //> lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
                    temp0 = spriteTilenumber[24 + temp2]
                    //> cmp SwimTileRepOffset       ;against tile number in player graphics table
                    //> beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
                    if (temp0 != swimTileRepOffset) {
                        //> inx                         ;otherwise increment X for second tile
                        temp3 = (temp3 + 1) and 0xFF
                    }
                }
                //> BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
                temp0 = swimKickTileNum[temp3]
                //> sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
                spriteTilenumber[24 + temp2] = temp0
            }
        }
        //> DoChangeSize:
        //> jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
        handleChangeSize()
        //> jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
    } else {
        //> PlayerKilled:
        //> ldy #$0e                      ;load offset for player killed
        temp2 = 0x0E
        //> lda PlayerGfxTblOffsets,y     ;get offset to graphics table
        temp0 = playerGfxTblOffsets[temp2]
    }
    //> PlayerGfxProcessing:
    //> sta PlayerGfxOffset           ;store offset to graphics table here
    playerGfxOffset = temp0
    //> lda #$04
    temp0 = 0x04
    //> jsr RenderPlayerSub           ;draw player based on offset loaded
    renderPlayerSub(temp0)
    //> jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
    chkForPlayerAttrib()
    //> lda FireballThrowingTimer
    temp0 = fireballThrowingTimer
    //> beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
    if (temp0 != 0) {
        //> ldy #$00                      ;set value to initialize by default
        temp2 = 0x00
        //> lda PlayerAnimTimer           ;get animation frame timer
        temp0 = playerAnimTimer
        //> cmp FireballThrowingTimer     ;compare to fireball throw timer
        //> sty FireballThrowingTimer     ;initialize fireball throw timer
        fireballThrowingTimer = temp2
        //> bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
        if (!(temp0 >= fireballThrowingTimer)) {
            //> sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
            fireballThrowingTimer = temp0
            //> ldy #$07                      ;load offset for throwing
            temp2 = 0x07
            //> lda PlayerGfxTblOffsets,y     ;get offset to graphics table
            temp0 = playerGfxTblOffsets[temp2]
            //> sta PlayerGfxOffset           ;store it for use later
            playerGfxOffset = temp0
            //> ldy #$04                      ;set to update four sprite rows by default
            temp2 = 0x04
            //> lda Player_X_Speed
            temp0 = playerXSpeed
            //> ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
            temp4 = temp0 or leftRightButtons
            //> beq SUpdR                     ;if no speed or button press, branch using set value in Y
            temp0 = temp4
            if (temp4 != 0) {
                //> dey                           ;otherwise set to update only three sprite rows
                temp2 = (temp2 - 1) and 0xFF
            }
            //> SUpdR: tya                           ;save in A for use
            //> jsr RenderPlayerSub           ;in sub, draw player object again
            renderPlayerSub(temp2)
        }
    }
    //> PlayerOffscreenChk:
    //> lda Player_OffscreenBits      ;get player's offscreen bits
    temp0 = playerOffscreenbits
    //> lsr
    temp0 = temp0 shr 1
    //> lsr                           ;move vertical bits to low nybble
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> sta $00                       ;store here
    memory[0x0] = temp0.toUByte()
    //> ldx #$03                      ;check all four rows of player sprites
    temp3 = 0x03
    //> lda Player_SprDataOffset      ;get player's sprite data offset
    temp0 = playerSprdataoffset
    //> clc
    //> adc #$18                      ;add 24 bytes to start at bottom row
    temp5 = temp0 + 0x18
    temp0 = temp5 and 0xFF
    //> tay                           ;set as offset here
    temp2 = temp0
    do {
        //> PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
        temp0 = 0xF8
        //> lsr $00                       ;shift bit into carry
        memory[0x0] = ((memory[0x0].toInt() shr 1) and 0xFF).toUByte()
        //> bcc NPROffscr                 ;if bit not set, skip, do not move sprites
        if ((memory[0x0].toInt() and 0x01) != 0) {
            //> jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
            dumpTwoSpr(temp0, temp2)
        }
        //> NPROffscr: tya
        //> sec                           ;subtract eight bytes to do
        //> sbc #$08                      ;next row up
        temp6 = temp2 - 0x08
        temp0 = temp6 and 0xFF
        //> tay
        //> dex                           ;decrement row counter
        temp3 = (temp3 - 1) and 0xFF
        //> bpl PROfsLoop                 ;do this until all sprite rows are checked
    } while ((temp3 and 0x80) == 0)
    //> rts                           ;then we are done!
    return
}

// Decompiled from FindPlayerAction
fun findPlayerAction(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var fireballThrowingTimer by MemoryByte(FireballThrowingTimer)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerOffscreenbits by MemoryByte(Player_OffscreenBits)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> FindPlayerAction:
    //> jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
    processPlayerAction()
    //> jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
    //> PlayerGfxProcessing:
    //> sta PlayerGfxOffset           ;store offset to graphics table here
    playerGfxOffset = A
    //> lda #$04
    //> jsr RenderPlayerSub           ;draw player based on offset loaded
    renderPlayerSub(0x04)
    //> jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
    chkForPlayerAttrib()
    //> lda FireballThrowingTimer
    //> beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
    temp0 = fireballThrowingTimer
    if (fireballThrowingTimer != 0) {
        //> ldy #$00                      ;set value to initialize by default
        //> lda PlayerAnimTimer           ;get animation frame timer
        temp0 = playerAnimTimer
        //> cmp FireballThrowingTimer     ;compare to fireball throw timer
        //> sty FireballThrowingTimer     ;initialize fireball throw timer
        fireballThrowingTimer = 0x00
        //> bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
        temp1 = 0x00
        if (!(temp0 >= fireballThrowingTimer)) {
            //> sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
            fireballThrowingTimer = temp0
            //> ldy #$07                      ;load offset for throwing
            temp1 = 0x07
            //> lda PlayerGfxTblOffsets,y     ;get offset to graphics table
            temp0 = playerGfxTblOffsets[temp1]
            //> sta PlayerGfxOffset           ;store it for use later
            playerGfxOffset = temp0
            //> ldy #$04                      ;set to update four sprite rows by default
            temp1 = 0x04
            //> lda Player_X_Speed
            temp0 = playerXSpeed
            //> ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
            temp2 = temp0 or leftRightButtons
            //> beq SUpdR                     ;if no speed or button press, branch using set value in Y
            temp0 = temp2
            if (temp2 != 0) {
                //> dey                           ;otherwise set to update only three sprite rows
                temp1 = (temp1 - 1) and 0xFF
            }
            //> SUpdR: tya                           ;save in A for use
            //> jsr RenderPlayerSub           ;in sub, draw player object again
            renderPlayerSub(temp1)
        }
    }
    //> PlayerOffscreenChk:
    //> lda Player_OffscreenBits      ;get player's offscreen bits
    temp0 = playerOffscreenbits
    //> lsr
    temp0 = temp0 shr 1
    //> lsr                           ;move vertical bits to low nybble
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> lsr
    temp0 = temp0 shr 1
    //> sta $00                       ;store here
    memory[0x0] = temp0.toUByte()
    //> ldx #$03                      ;check all four rows of player sprites
    //> lda Player_SprDataOffset      ;get player's sprite data offset
    temp0 = playerSprdataoffset
    //> clc
    //> adc #$18                      ;add 24 bytes to start at bottom row
    temp3 = temp0 + 0x18
    temp0 = temp3 and 0xFF
    //> tay                           ;set as offset here
    temp4 = 0x03
    temp1 = temp0
    do {
        //> PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
        temp0 = 0xF8
        //> lsr $00                       ;shift bit into carry
        memory[0x0] = ((memory[0x0].toInt() shr 1) and 0xFF).toUByte()
        //> bcc NPROffscr                 ;if bit not set, skip, do not move sprites
        if ((memory[0x0].toInt() and 0x01) != 0) {
            //> jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
            dumpTwoSpr(temp0, temp1)
        }
        //> NPROffscr: tya
        //> sec                           ;subtract eight bytes to do
        //> sbc #$08                      ;next row up
        temp5 = temp1 - 0x08
        temp0 = temp5 and 0xFF
        //> tay
        //> dex                           ;decrement row counter
        temp4 = (temp4 - 1) and 0xFF
        //> bpl PROfsLoop                 ;do this until all sprite rows are checked
    } while ((temp4 and 0x80) == 0)
    //> rts                           ;then we are done!
    return
}

// Decompiled from DrawPlayer_Intermediate
fun drawplayerIntermediate() {
    var temp0: Int = 0
    var temp1: Int = 0
    val intermediatePlayerData by MemoryByteIndexed(IntermediatePlayerData)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    //> DrawPlayer_Intermediate:
    //> ldx #$05                       ;store data into zero page memory
    temp0 = 0x05
    do {
        //> PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
        //> sta $02,x                      ;appears on world/lives display
        memory[0x2 + temp0] = (intermediatePlayerData[temp0] and 0xFF).toUByte()
        //> dex
        temp0 = (temp0 - 1) and 0xFF
        //> bpl PIntLoop                   ;do this until all data is loaded
    } while ((temp0 and 0x80) == 0)
    //> ldx #$b8                       ;load offset for small standing
    temp0 = 0xB8
    //> ldy #$04                       ;load sprite data offset
    //> jsr DrawPlayerLoop             ;draw player accordingly
    drawPlayerLoop(temp0)
    //> lda Sprite_Attributes+36       ;get empty sprite attributes
    //> ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
    temp1 = spriteAttributes[36] or 0x40
    //> sta Sprite_Attributes+32       ;store and leave
    spriteAttributes[32] = temp1
    //> rts
    return
}

// Decompiled from RenderPlayerSub
fun renderPlayerSub(A: Int) {
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerPosForscroll by MemoryByte(Player_Pos_ForScroll)
    var playerRelXpos by MemoryByte(Player_Rel_XPos)
    var playerRelYpos by MemoryByte(Player_Rel_YPos)
    var playerSprattrib by MemoryByte(Player_SprAttrib)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    //> RenderPlayerSub:
    //> sta $07                      ;store number of rows of sprites to draw
    memory[0x7] = A.toUByte()
    //> lda Player_Rel_XPos
    //> sta Player_Pos_ForScroll     ;store player's relative horizontal position
    playerPosForscroll = playerRelXpos
    //> sta $05                      ;store it here also
    memory[0x5] = playerRelXpos.toUByte()
    //> lda Player_Rel_YPos
    //> sta $02                      ;store player's vertical position
    memory[0x2] = playerRelYpos.toUByte()
    //> lda PlayerFacingDir
    //> sta $03                      ;store player's facing direction
    memory[0x3] = playerFacingDir.toUByte()
    //> lda Player_SprAttrib
    //> sta $04                      ;store player's sprite attributes
    memory[0x4] = playerSprattrib.toUByte()
    //> ldx PlayerGfxOffset          ;load graphics table offset
    //> ldy Player_SprDataOffset     ;get player's sprite data offset
    // Fall-through tail call to drawPlayerLoop
    drawPlayerLoop(playerGfxOffset)
}

// Decompiled from DrawPlayerLoop
fun drawPlayerLoop(X: Int) {
    var Y: Int = 0
    val playerGraphicsTable by MemoryByteIndexed(PlayerGraphicsTable)
    do {
        //> DrawPlayerLoop:
        //> lda PlayerGraphicsTable,x    ;load player's left side
        //> sta $00
        memory[0x0] = (playerGraphicsTable[X] and 0xFF).toUByte()
        //> lda PlayerGraphicsTable+1,x  ;now load right side
        //> jsr DrawOneSpriteRow
        drawOneSpriteRow(playerGraphicsTable[1 + X], X, Y)
        //> dec $07                      ;decrement rows of sprites to draw
        memory[0x7] = ((memory[0x7].toInt() - 1) and 0xFF).toUByte()
        //> bne DrawPlayerLoop           ;do this until all rows are drawn
    } while (memory[0x7].toInt() != 0)
    //> rts
    return
}

// Decompiled from ProcessPlayerAction
fun processPlayerAction() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var aBButtons by MemoryByte(A_B_Buttons)
    var crouchingFlag by MemoryByte(CrouchingFlag)
    var jumpSwimTimer by MemoryByte(JumpSwimTimer)
    var leftRightButtons by MemoryByte(Left_Right_Buttons)
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerAnimTimer by MemoryByte(PlayerAnimTimer)
    var playerAnimTimerSet by MemoryByte(PlayerAnimTimerSet)
    var playerFacingDir by MemoryByte(PlayerFacingDir)
    var playerMovingdir by MemoryByte(Player_MovingDir)
    var playerState by MemoryByte(Player_State)
    var playerXspeedabsolute by MemoryByte(Player_XSpeedAbsolute)
    var playerXSpeed by MemoryByte(Player_X_Speed)
    var playerYSpeed by MemoryByte(Player_Y_Speed)
    var swimmingFlag by MemoryByte(SwimmingFlag)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> ProcessPlayerAction:
    //> lda Player_State      ;get player's state
    //> cmp #$03
    //> beq ActionClimbing    ;if climbing, branch here
    temp0 = playerState
    if (playerState != 0x03) {
        //> cmp #$02
        //> beq ActionFalling     ;if falling, branch here
        if (temp0 - 0x02 == 0) {
            //  goto ActionFalling
            return
        }
        if (temp0 != 0x02) {
            //> cmp #$01
            //> bne ProcOnGroundActs  ;if not jumping, branch here
            if (temp0 == 0x01) {
                //> lda SwimmingFlag
                temp0 = swimmingFlag
                //> bne ActionSwimming    ;if swimming flag set, branch elsewhere
                if (temp0 == 0) {
                    //> ldy #$06              ;load offset for crouching
                    //> lda CrouchingFlag     ;get crouching flag
                    temp0 = crouchingFlag
                    //> bne NonAnimatedActs   ;if set, branch to get offset for graphics table
                    temp1 = 0x06
                    if (temp0 == 0) {
                        //> ldy #$00              ;otherwise load offset for jumping
                        temp1 = 0x00
                        //> jmp NonAnimatedActs   ;go to get offset to graphics table
                    } else {
                        //> NonAnimatedActs:
                        //> jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
                        getGfxOffsetAdder(temp1)
                        //> lda #$00
                        temp0 = 0x00
                        //> sta PlayerAnimCtrl         ;initialize animation frame control
                        playerAnimCtrl = temp0
                        //> lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
                        temp0 = playerGfxTblOffsets[temp1]
                        //> rts
                        return
                    }
                }
            } else {
                //> ProcOnGroundActs:
                //> ldy #$06                   ;load offset for crouching
                temp1 = 0x06
                //> lda CrouchingFlag          ;get crouching flag
                temp0 = crouchingFlag
                //> bne NonAnimatedActs        ;if set, branch to get offset for graphics table
                if (temp0 == 0) {
                    //> ldy #$02                   ;load offset for standing
                    temp1 = 0x02
                    //> lda Player_X_Speed         ;check player's horizontal speed
                    temp0 = playerXSpeed
                    //> ora Left_Right_Buttons     ;and left/right controller bits
                    temp2 = temp0 or leftRightButtons
                    //> beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
                    temp0 = temp2
                    if (temp2 != 0) {
                        //> lda Player_XSpeedAbsolute  ;load walking/running speed
                        temp0 = playerXspeedabsolute
                        //> cmp #$09
                        //> bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
                        if (!(temp0 >= 0x09)) {
                            //  goto ActionWalkRun
                            return
                        }
                        if (temp0 >= 0x09) {
                            //> lda Player_MovingDir       ;otherwise check to see if moving direction
                            temp0 = playerMovingdir
                            //> and PlayerFacingDir        ;and facing direction are the same
                            temp3 = temp0 and playerFacingDir
                            //> bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
                            if (!(temp3 == 0)) {
                                //  goto ActionWalkRun
                                return
                            }
                            temp0 = temp3
                            if (temp3 == 0) {
                                //> iny                        ;otherwise increment to skid offset ($03)
                                temp1 = (temp1 + 1) and 0xFF
                            }
                        }
                    }
                }
            }
        }
        //> ActionFalling:
        //> ldy #$04                  ;load offset for walking/running
        temp1 = 0x04
        //> jsr GetGfxOffsetAdder     ;get offset to graphics table
        getGfxOffsetAdder(temp1)
        //> jmp GetCurrentAnimOffset  ;execute instructions for falling state
        //> ActionWalkRun:
        //> ldy #$04               ;load offset for walking/running
        temp1 = 0x04
        //> jsr GetGfxOffsetAdder  ;get offset to graphics table
        getGfxOffsetAdder(temp1)
        //> jmp FourFrameExtent    ;execute instructions for normal state
    } else {
        do {
            //> ActionClimbing:
            //> ldy #$05               ;load offset for climbing
            temp1 = 0x05
            //> lda Player_Y_Speed     ;check player's vertical speed
            temp0 = playerYSpeed
            //> beq NonAnimatedActs    ;if no speed, branch, use offset as-is
        } while (temp0 == 0)
        //> jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
        getGfxOffsetAdder(temp1)
        //> jmp ThreeFrameExtent   ;then skip ahead to more code
        //> ActionSwimming:
        //> ldy #$01               ;load offset for swimming
        temp1 = 0x01
        //> jsr GetGfxOffsetAdder
        getGfxOffsetAdder(temp1)
        //> lda JumpSwimTimer      ;check jump/swim timer
        temp0 = jumpSwimTimer
        //> ora PlayerAnimCtrl     ;and animation frame control
        temp4 = temp0 or playerAnimCtrl
        //> bne FourFrameExtent    ;if any one of these set, branch ahead
        if (!(temp4 == 0)) {
            //  goto FourFrameExtent
            return
        }
        temp0 = temp4
        if (temp4 == 0) {
            //> lda A_B_Buttons
            temp0 = aBButtons
            //> asl                    ;check for A button pressed
            temp0 = (temp0 shl 1) and 0xFF
            //> bcs FourFrameExtent    ;branch to same place if A button pressed
            if ((temp0 and 0x80) != 0) {
                //  goto FourFrameExtent
                return
            }
            if ((temp0 and 0x80) == 0) {
            }
        }
    }
    //> FourFrameExtent:
    //> lda #$03              ;load upper extent for frame control
    temp0 = 0x03
    //> jmp AnimationControl  ;jump to get offset and animate player object
    //> ThreeFrameExtent:
    //> lda #$02              ;load upper extent for frame control for climbing
    temp0 = 0x02
    //> AnimationControl:
    //> sta $00                   ;store upper extent here
    memory[0x0] = temp0.toUByte()
    //> jsr GetCurrentAnimOffset  ;get proper offset to graphics table
    getCurrentAnimOffset(temp1)
    //> pha                       ;save offset to stack
    push(temp0)
    //> lda PlayerAnimTimer       ;load animation frame timer
    temp0 = playerAnimTimer
    //> bne ExAnimC               ;branch if not expired
    if (temp0 == 0) {
        //> lda PlayerAnimTimerSet    ;get animation frame timer amount
        temp0 = playerAnimTimerSet
        //> sta PlayerAnimTimer       ;and set timer accordingly
        playerAnimTimer = temp0
        //> lda PlayerAnimCtrl
        temp0 = playerAnimCtrl
        //> clc                       ;add one to animation frame control
        //> adc #$01
        temp5 = temp0 + 0x01
        temp0 = temp5 and 0xFF
        //> cmp $00                   ;compare to upper extent
        //> bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
        if (temp0 >= memory[0x0].toInt()) {
            //> lda #$00                  ;otherwise initialize frame control
            temp0 = 0x00
        }
        //> SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
        playerAnimCtrl = temp0
    }
    //> ExAnimC:  pla                       ;get offset to graphics table from stack and leave
    temp0 = pull()
    //> rts
    return
}

// Decompiled from GetCurrentAnimOffset
fun getCurrentAnimOffset(Y: Int): Int {
    var temp0: Int = 0
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> GetCurrentAnimOffset:
    //> lda PlayerAnimCtrl         ;get animation frame control
    //> jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
    //> GetOffsetFromAnimCtrl:
    //> asl                        ;multiply animation frame control
    playerAnimCtrl = (playerAnimCtrl shl 1) and 0xFF
    //> asl                        ;by eight to get proper amount
    playerAnimCtrl = (playerAnimCtrl shl 1) and 0xFF
    //> asl                        ;to add to our offset
    playerAnimCtrl = (playerAnimCtrl shl 1) and 0xFF
    //> adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
    temp0 = playerAnimCtrl + playerGfxTblOffsets[Y] + (if ((playerAnimCtrl and 0x80) != 0) 1 else 0)
    //> rts                        ;and return with result in A
    return A
}

// Decompiled from GetGfxOffsetAdder
fun getGfxOffsetAdder(Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var playerSize by MemoryByte(PlayerSize)
    //> GetGfxOffsetAdder:
    //> lda PlayerSize  ;get player's size
    //> beq SzOfs       ;if player big, use current offset as-is
    temp0 = playerSize
    if (playerSize != 0) {
        //> tya             ;for big player
        //> clc             ;otherwise add eight bytes to offset
        //> adc #$08        ;for small player
        temp1 = Y + 0x08
        temp0 = temp1 and 0xFF
        //> tay
    }
    //> SzOfs:  rts             ;go back
    return
}

// Decompiled from HandleChangeSize
fun handleChangeSize() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var frameCounter by MemoryByte(FrameCounter)
    var playerAnimCtrl by MemoryByte(PlayerAnimCtrl)
    var playerChangeSizeFlag by MemoryByte(PlayerChangeSizeFlag)
    var playerSize by MemoryByte(PlayerSize)
    val changeSizeOffsetAdder by MemoryByteIndexed(ChangeSizeOffsetAdder)
    val playerGfxTblOffsets by MemoryByteIndexed(PlayerGfxTblOffsets)
    //> HandleChangeSize:
    //> ldy PlayerAnimCtrl           ;get animation frame control
    //> lda FrameCounter
    //> and #%00000011               ;get frame counter and execute this code every
    temp0 = frameCounter and 0x03
    //> bne GorSLog                  ;fourth frame, otherwise branch ahead
    temp1 = temp0
    temp2 = playerAnimCtrl
    if (temp0 == 0) {
        //> iny                          ;increment frame control
        temp2 = (temp2 + 1) and 0xFF
        //> cpy #$0a                     ;check for preset upper extent
        //> bcc CSzNext                  ;if not there yet, skip ahead to use
        if (temp2 >= 0x0A) {
            //> ldy #$00                     ;otherwise initialize both grow/shrink flag
            temp2 = 0x00
            //> sty PlayerChangeSizeFlag     ;and animation frame control
            playerChangeSizeFlag = temp2
        }
        //> CSzNext: sty PlayerAnimCtrl           ;store proper frame control
        playerAnimCtrl = temp2
    }
    //> GorSLog: lda PlayerSize               ;get player's size
    temp1 = playerSize
    //> bne ShrinkPlayer             ;if player small, skip ahead to next part
    if (temp1 == 0) {
        //> lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
        temp1 = changeSizeOffsetAdder[temp2]
        //> ldy #$0f                     ;load offset for player growing
        temp2 = 0x0F
        //> GetOffsetFromAnimCtrl:
        //> asl                        ;multiply animation frame control
        temp1 = (temp1 shl 1) and 0xFF
        //> asl                        ;by eight to get proper amount
        temp1 = (temp1 shl 1) and 0xFF
        //> asl                        ;to add to our offset
        temp1 = (temp1 shl 1) and 0xFF
        //> adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
        temp3 = temp1 + playerGfxTblOffsets[temp2] + (if ((temp1 and 0x80) != 0) 1 else 0)
        temp1 = temp3 and 0xFF
        //> rts                        ;and return with result in A
        return
    } else {
        //> ShrinkPlayer:
        //> tya                          ;add ten bytes to frame control as offset
        //> clc
        //> adc #$0a                     ;this thing apparently uses two of the swimming frames
        temp4 = temp2 + 0x0A
        temp1 = temp4 and 0xFF
        //> tax                          ;to draw the player shrinking
        //> ldy #$09                     ;load offset for small player swimming
        temp2 = 0x09
        //> lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
        temp1 = changeSizeOffsetAdder[temp1]
        //> bne ShrPlF                   ;and branch to use offset if nonzero
        temp5 = temp1
        if (temp1 == 0) {
            //> ldy #$01                     ;otherwise load offset for big player swimming
            temp2 = 0x01
        }
    }
    //> ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
    temp1 = playerGfxTblOffsets[temp2]
    //> rts                          ;and leave
    return
}

// Decompiled from ChkForPlayerAttrib
fun chkForPlayerAttrib() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var gameEngineSubroutine by MemoryByte(GameEngineSubroutine)
    var playerGfxOffset by MemoryByte(PlayerGfxOffset)
    var playerSprdataoffset by MemoryByte(Player_SprDataOffset)
    val spriteAttributes by MemoryByteIndexed(Sprite_Attributes)
    //> ChkForPlayerAttrib:
    //> ldy Player_SprDataOffset    ;get sprite data offset
    //> lda GameEngineSubroutine
    //> cmp #$0b                    ;if executing specific game engine routine,
    //> beq KilledAtt               ;branch to change third and fourth row OAM attributes
    temp0 = gameEngineSubroutine
    temp1 = playerSprdataoffset
    if (gameEngineSubroutine != 0x0B) {
        //> lda PlayerGfxOffset         ;get graphics table offset
        temp0 = playerGfxOffset
        //> cmp #$50
        //> beq C_S_IGAtt               ;if crouch offset, either standing offset,
        if (temp0 != 0x50) {
            //> cmp #$b8                    ;or intermediate growing offset,
            //> beq C_S_IGAtt               ;go ahead and execute code to change
            if (temp0 != 0xB8) {
                //> cmp #$c0                    ;fourth row OAM attributes only
                //> beq C_S_IGAtt
                if (temp0 != 0xC0) {
                    //> cmp #$c8
                    //> bne ExPlyrAt                ;if none of these, branch to leave
                    if (temp0 == 0xC8) {
                    } else {
                        //> ExPlyrAt:  rts                         ;leave
                        return
                    }
                }
            }
        }
    }
    //> KilledAtt: lda Sprite_Attributes+16,y
    temp0 = spriteAttributes[16 + temp1]
    //> and #%00111111              ;mask out horizontal and vertical flip bits
    temp2 = temp0 and 0x3F
    //> sta Sprite_Attributes+16,y  ;for third row sprites and save
    spriteAttributes[16 + temp1] = temp2
    //> lda Sprite_Attributes+20,y
    temp0 = spriteAttributes[20 + temp1]
    //> and #%00111111
    temp3 = temp0 and 0x3F
    //> ora #%01000000              ;set horizontal flip bit for second
    temp4 = temp3 or 0x40
    //> sta Sprite_Attributes+20,y  ;sprite in the third row
    spriteAttributes[20 + temp1] = temp4
    //> C_S_IGAtt: lda Sprite_Attributes+24,y
    temp0 = spriteAttributes[24 + temp1]
    //> and #%00111111              ;mask out horizontal and vertical flip bits
    temp5 = temp0 and 0x3F
    //> sta Sprite_Attributes+24,y  ;for fourth row sprites and save
    spriteAttributes[24 + temp1] = temp5
    //> lda Sprite_Attributes+28,y
    temp0 = spriteAttributes[28 + temp1]
    //> and #%00111111
    temp6 = temp0 and 0x3F
    //> ora #%01000000              ;set horizontal flip bit for second
    temp7 = temp6 or 0x40
    //> sta Sprite_Attributes+28,y  ;sprite in the fourth row
    spriteAttributes[28 + temp1] = temp7
}

// Decompiled from RelativePlayerPosition
fun relativePlayerPosition() {
    var objectOffset by MemoryByte(ObjectOffset)
    //> RelativePlayerPosition:
    //> ldx #$00      ;set offsets for relative cooordinates
    //> ldy #$00      ;routine to correspond to player object
    //> jmp RelWOfs   ;get the coordinates
    //> RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
    getObjRelativePosition(0x00, 0x00)
    //> ldx ObjectOffset            ;return original offset
    //> rts                         ;leave
    return
}

// Decompiled from RelativeBubblePosition
fun relativeBubblePosition() {
    var X: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> RelativeBubblePosition:
    //> ldy #$01                ;set for air bubble offsets
    //> jsr GetProperObjOffset  ;modify X to get proper air bubble offset
    getProperObjOffset(X, 0x01)
    //> ldy #$03
    //> jmp RelWOfs             ;get the coordinates
    //> RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
    getObjRelativePosition(X, 0x03)
    //> ldx ObjectOffset            ;return original offset
    //> rts                         ;leave
    return
}

// Decompiled from RelativeFireballPosition
fun relativeFireballPosition() {
    var X: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> RelativeFireballPosition:
    //> ldy #$00                    ;set for fireball offsets
    //> jsr GetProperObjOffset      ;modify X to get proper fireball offset
    getProperObjOffset(X, 0x00)
    //> ldy #$02
    //> RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
    getObjRelativePosition(X, 0x02)
    //> ldx ObjectOffset            ;return original offset
    //> rts                         ;leave
    return
}

// Decompiled from RelativeMiscPosition
fun relativeMiscPosition() {
    var X: Int = 0
    var Y: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
    getObjRelativePosition(X, Y)
    //> ldx ObjectOffset            ;return original offset
    //> rts                         ;leave
    return
}

// Decompiled from RelativeEnemyPosition
fun relativeEnemyPosition() {
    //> RelativeEnemyPosition:
    //> lda #$01                     ;get coordinates of enemy object
    //> ldy #$01                     ;relative to the screen
    //> jmp VariableObjOfsRelPos
}

// Decompiled from RelativeBlockPosition
fun relativeBlockPosition(X: Int) {
    var X: Int = X
    var temp0: Int = 0
    //> RelativeBlockPosition:
    //> lda #$09                     ;get coordinates of one block object
    //> ldy #$04                     ;relative to the screen
    //> jsr VariableObjOfsRelPos
    variableObjOfsRelPos(0x09, X)
    //> inx                          ;adjust offset for other block object if any
    X = (X + 1) and 0xFF
    //> inx
    X = (X + 1) and 0xFF
    //> lda #$09
    //> iny                          ;adjust other and get coordinates for other one
    temp0 = 0x04
    temp0 = (temp0 + 1) and 0xFF
    // Fall-through tail call to variableObjOfsRelPos
    variableObjOfsRelPos(0x09, X)
}

// Decompiled from VariableObjOfsRelPos
fun variableObjOfsRelPos(A: Int, X: Int) {
    var Y: Int = 0
    var temp0: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    //> VariableObjOfsRelPos:
    //> stx $00                     ;store value to add to A here
    memory[0x0] = X.toUByte()
    //> clc
    //> adc $00                     ;add A to value stored
    temp0 = A + memory[0x0].toInt()
    //> tax                         ;use as enemy offset
    //> jsr GetObjRelativePosition
    getObjRelativePosition(temp0 and 0xFF, Y)
    //> ldx ObjectOffset            ;reload old object offset and leave
    //> rts
    return
}

// Decompiled from GetObjRelativePosition
fun getObjRelativePosition(X: Int, Y: Int) {
    var temp0: Int = 0
    var screenleftXPos by MemoryByte(ScreenLeft_X_Pos)
    val sprobjectRelXpos by MemoryByteIndexed(SprObject_Rel_XPos)
    val sprobjectRelYpos by MemoryByteIndexed(SprObject_Rel_YPos)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    //> GetObjRelativePosition:
    //> lda SprObject_Y_Position,x  ;load vertical coordinate low
    //> sta SprObject_Rel_YPos,y    ;store here
    sprobjectRelYpos[Y] = sprobjectYPosition[X]
    //> lda SprObject_X_Position,x  ;load horizontal coordinate
    //> sec                         ;subtract left edge coordinate
    //> sbc ScreenLeft_X_Pos
    temp0 = sprobjectXPosition[X] - screenleftXPos
    //> sta SprObject_Rel_XPos,y    ;store result here
    sprobjectRelXpos[Y] = temp0 and 0xFF
    //> rts
    return
}

// Decompiled from GetPlayerOffscreenBits
fun getPlayerOffscreenBits() {
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetPlayerOffscreenBits:
    //> ldx #$00                 ;set offsets for player-specific variables
    //> ldy #$00                 ;and get offscreen information about player
    //> jmp GetOffScreenBitsSet
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    //> pha
    push(0x00)
    //> jsr RunOffscrBitsSubs
    runOffscrBitsSubs(0x00, 0x00)
    //> asl                         ;move low nybble to high nybble
    //> asl
    //> asl
    //> asl
    //> ora $00                     ;mask together with previously saved low nybble
    temp0 = (((((((0x00 shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp0.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp1 = pull()
    //> tay
    //> lda $00                     ;get value here and store elsewhere
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[temp1] = memory[0x0].toInt()
    //> ldx ObjectOffset
    //> rts
    return
}

// Decompiled from GetFireballOffscreenBits
fun getFireballOffscreenBits() {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetFireballOffscreenBits:
    //> ldy #$00                 ;set for fireball offsets
    //> jsr GetProperObjOffset   ;modify X to get proper fireball offset
    getProperObjOffset(X, 0x00)
    //> ldy #$02                 ;set other offset for fireball's offscreen bits
    //> jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    //> pha
    push(0x02)
    //> jsr RunOffscrBitsSubs
    runOffscrBitsSubs(0x02, X)
    //> asl                         ;move low nybble to high nybble
    //> asl
    //> asl
    //> asl
    //> ora $00                     ;mask together with previously saved low nybble
    temp0 = (((((((0x02 shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp0.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp1 = pull()
    //> tay
    //> lda $00                     ;get value here and store elsewhere
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[temp1] = memory[0x0].toInt()
    //> ldx ObjectOffset
    //> rts
    return
}

// Decompiled from GetBubbleOffscreenBits
fun getBubbleOffscreenBits() {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetBubbleOffscreenBits:
    //> ldy #$01                 ;set for air bubble offsets
    //> jsr GetProperObjOffset   ;modify X to get proper air bubble offset
    getProperObjOffset(X, 0x01)
    //> ldy #$03                 ;set other offset for airbubble's offscreen bits
    //> jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    //> pha
    push(0x03)
    //> jsr RunOffscrBitsSubs
    runOffscrBitsSubs(0x03, X)
    //> asl                         ;move low nybble to high nybble
    //> asl
    //> asl
    //> asl
    //> ora $00                     ;mask together with previously saved low nybble
    temp0 = (((((((0x03 shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp0.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp1 = pull()
    //> tay
    //> lda $00                     ;get value here and store elsewhere
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[temp1] = memory[0x0].toInt()
    //> ldx ObjectOffset
    //> rts
    return
}

// Decompiled from GetMiscOffscreenBits
fun getMiscOffscreenBits() {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetMiscOffscreenBits:
    //> ldy #$02                 ;set for misc object offsets
    //> jsr GetProperObjOffset   ;modify X to get proper misc object offset
    getProperObjOffset(X, 0x02)
    //> ldy #$06                 ;set other offset for misc object's offscreen bits
    //> jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    //> pha
    push(0x06)
    //> jsr RunOffscrBitsSubs
    runOffscrBitsSubs(0x06, X)
    //> asl                         ;move low nybble to high nybble
    //> asl
    //> asl
    //> asl
    //> ora $00                     ;mask together with previously saved low nybble
    temp0 = (((((((0x06 shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp0.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp1 = pull()
    //> tay
    //> lda $00                     ;get value here and store elsewhere
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[temp1] = memory[0x0].toInt()
    //> ldx ObjectOffset
    //> rts
    return
}

// Decompiled from GetProperObjOffset
fun getProperObjOffset(X: Int, Y: Int) {
    var temp0: Int = 0
    val objOffsetData by MemoryByteIndexed(ObjOffsetData)
    //> GetProperObjOffset:
    //> txa                  ;move offset to A
    //> clc
    //> adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
    temp0 = X + objOffsetData[Y]
    //> tax                  ;put back in X and leave
    //> rts
    return
}

// Decompiled from GetEnemyOffscreenBits
fun getEnemyOffscreenBits(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetEnemyOffscreenBits:
    //> lda #$01                 ;set A to add 1 byte in order to get enemy offset
    //> ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
    //> jmp SetOffscrBitsOffset
    //> SetOffscrBitsOffset:
    //> stx $00
    memory[0x0] = X.toUByte()
    //> clc           ;add contents of X to A to get
    //> adc $00       ;appropriate offset, then give back to X
    temp0 = 0x01 + memory[0x0].toInt()
    //> tax
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    //> pha
    push(0x01)
    //> jsr RunOffscrBitsSubs
    runOffscrBitsSubs(0x01, temp0 and 0xFF)
    //> asl                         ;move low nybble to high nybble
    //> asl
    //> asl
    //> asl
    //> ora $00                     ;mask together with previously saved low nybble
    temp1 = (((((((0x01 shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp1.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp2 = pull()
    //> tay
    //> lda $00                     ;get value here and store elsewhere
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[temp2] = memory[0x0].toInt()
    //> ldx ObjectOffset
    //> rts
    return
}

// Decompiled from GetBlockOffscreenBits
fun getBlockOffscreenBits(X: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var objectOffset by MemoryByte(ObjectOffset)
    val sprobjectOffscrbits by MemoryByteIndexed(SprObject_OffscrBits)
    //> GetBlockOffscreenBits:
    //> lda #$09       ;set A to add 9 bytes in order to get block obj offset
    //> ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
    //> SetOffscrBitsOffset:
    //> stx $00
    memory[0x0] = X.toUByte()
    //> clc           ;add contents of X to A to get
    //> adc $00       ;appropriate offset, then give back to X
    temp0 = 0x09 + memory[0x0].toInt()
    //> tax
    //> GetOffScreenBitsSet:
    //> tya                         ;save offscreen bits offset to stack for now
    //> pha
    push(0x04)
    //> jsr RunOffscrBitsSubs
    runOffscrBitsSubs(0x04, temp0 and 0xFF)
    //> asl                         ;move low nybble to high nybble
    //> asl
    //> asl
    //> asl
    //> ora $00                     ;mask together with previously saved low nybble
    temp1 = (((((((0x04 shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF) shl 1) and 0xFF or memory[0x0].toInt()
    //> sta $00                     ;store both here
    memory[0x0] = temp1.toUByte()
    //> pla                         ;get offscreen bits offset from stack
    temp2 = pull()
    //> tay
    //> lda $00                     ;get value here and store elsewhere
    //> sta SprObject_OffscrBits,y
    sprobjectOffscrbits[temp2] = memory[0x0].toInt()
    //> ldx ObjectOffset
    //> rts
    return
}

// Decompiled from RunOffscrBitsSubs
fun runOffscrBitsSubs(A: Int, X: Int): Int {
    var A: Int = A
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    val defaultYOnscreenOfs by MemoryByteIndexed(DefaultYOnscreenOfs)
    val highPosUnitData by MemoryByteIndexed(HighPosUnitData)
    val sprobjectYHighpos by MemoryByteIndexed(SprObject_Y_HighPos)
    val sprobjectYPosition by MemoryByteIndexed(SprObject_Y_Position)
    val yOffscreenBitsData by MemoryByteIndexed(YOffscreenBitsData)
    //> RunOffscrBitsSubs:
    //> jsr GetXOffscreenBits  ;do subroutine here
    getXOffscreenBits(X)
    //> lsr                    ;move high nybble to low
    A = A shr 1
    //> lsr
    A = A shr 1
    //> lsr
    A = A shr 1
    //> lsr
    A = A shr 1
    //> sta $00                ;store here
    memory[0x0] = A.toUByte()
    //> jmp GetYOffscreenBits
    //> GetYOffscreenBits:
    //> stx $04                      ;save position in buffer to here
    memory[0x4] = X.toUByte()
    //> ldy #$01                     ;start with top of screen
    temp0 = 0x01
    do {
        //> YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
        //> sec
        //> sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
        temp1 = highPosUnitData[temp0] - sprobjectYPosition[X]
        //> sta $07                      ;store here
        memory[0x7] = (temp1 and 0xFF).toUByte()
        //> lda #$01                     ;subtract one from vertical high byte of object
        //> sbc SprObject_Y_HighPos,x
        temp2 = 0x01 - sprobjectYHighpos[X] - (if (temp1 >= 0) 0 else 1)
        //> ldx DefaultYOnscreenOfs,y    ;load offset value here
        //> cmp #$00
        //> bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
        temp3 = temp2 and 0xFF
        temp4 = defaultYOnscreenOfs[temp0]
        if (!((temp2 and 0xFF) < 0)) {
            //> ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
            temp4 = defaultYOnscreenOfs[1 + temp0]
            //> cmp #$01
            //> bpl YLdBData                 ;if one vertical unit or more above the screen, branch
            if (temp3 - 0x01 < 0) {
                //> lda #$20                     ;if no branching, load value here and store
                temp3 = 0x20
                //> sta $06
                memory[0x6] = temp3.toUByte()
                //> lda #$04                     ;load some other value and execute subroutine
                temp3 = 0x04
                //> jsr DividePDiff
                dividePDiff(temp3, temp0)
            }
        }
        //> YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
        temp3 = yOffscreenBitsData[temp4]
        //> ldx $04                      ;reobtain position in buffer
        temp4 = memory[0x4].toInt()
        //> cmp #$00
        //> bne ExYOfsBS                 ;if bits not zero, branch to leave
        if (temp3 == 0) {
            //> dey                          ;otherwise, do bottom of the screen now
            temp0 = (temp0 - 1) and 0xFF
            //> bpl YOfsLoop
        }
    } while (!flagN)
    //> ExYOfsBS: rts
    return A
}

// Decompiled from GetXOffscreenBits
fun getXOffscreenBits(X: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    val defaultXOnscreenOfs by MemoryByteIndexed(DefaultXOnscreenOfs)
    val screenedgePageloc by MemoryByteIndexed(ScreenEdge_PageLoc)
    val screenedgeXPos by MemoryByteIndexed(ScreenEdge_X_Pos)
    val sprobjectPageloc by MemoryByteIndexed(SprObject_PageLoc)
    val sprobjectXPosition by MemoryByteIndexed(SprObject_X_Position)
    val xOffscreenBitsData by MemoryByteIndexed(XOffscreenBitsData)
    //> GetXOffscreenBits:
    //> stx $04                     ;save position in buffer to here
    memory[0x4] = X.toUByte()
    //> ldy #$01                    ;start with right side of screen
    temp0 = 0x01
    do {
        //> XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
        //> sec                         ;get difference between pixel coordinate of edge
        //> sbc SprObject_X_Position,x  ;and pixel coordinate of object position
        temp1 = screenedgeXPos[temp0] - sprobjectXPosition[X]
        //> sta $07                     ;store here
        memory[0x7] = (temp1 and 0xFF).toUByte()
        //> lda ScreenEdge_PageLoc,y    ;get page location of edge
        //> sbc SprObject_PageLoc,x     ;subtract from page location of object position
        temp2 = screenedgePageloc[temp0] - sprobjectPageloc[X] - (if (temp1 >= 0) 0 else 1)
        //> ldx DefaultXOnscreenOfs,y   ;load offset value here
        //> cmp #$00
        //> bmi XLdBData                ;if beyond right edge or in front of left edge, branch
        temp3 = temp2 and 0xFF
        temp4 = defaultXOnscreenOfs[temp0]
        if (!((temp2 and 0xFF) < 0)) {
            //> ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
            temp4 = defaultXOnscreenOfs[1 + temp0]
            //> cmp #$01
            //> bpl XLdBData                ;if one page or more to the left of either edge, branch
            if (temp3 - 0x01 < 0) {
                //> lda #$38                    ;if no branching, load value here and store
                temp3 = 0x38
                //> sta $06
                memory[0x6] = temp3.toUByte()
                //> lda #$08                    ;load some other value and execute subroutine
                temp3 = 0x08
                //> jsr DividePDiff
                dividePDiff(temp3, temp0)
            }
        }
        //> XLdBData: lda XOffscreenBitsData,x    ;get bits here
        temp3 = xOffscreenBitsData[temp4]
        //> ldx $04                     ;reobtain position in buffer
        temp4 = memory[0x4].toInt()
        //> cmp #$00                    ;if bits not zero, branch to leave
        //> bne ExXOfsBS
        if (temp3 == 0) {
            //> dey                         ;otherwise, do left side of screen now
            temp0 = (temp0 - 1) and 0xFF
            //> bpl XOfsLoop                ;branch if not already done with left side
        }
    } while (!flagN)
    //> ExXOfsBS: rts
    return A
}

// Decompiled from DividePDiff
fun dividePDiff(A: Int, Y: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    //> DividePDiff:
    //> sta $05       ;store current value in A here
    memory[0x5] = A.toUByte()
    //> lda $07       ;get pixel difference
    //> cmp $06       ;compare to preset value
    //> bcs ExDivPD   ;if pixel difference >= preset value, branch
    temp0 = memory[0x7].toInt()
    if (!(memory[0x7].toInt() >= memory[0x6].toInt())) {
        //> lsr           ;divide by eight
        temp0 = temp0 shr 1
        //> lsr
        temp0 = temp0 shr 1
        //> lsr
        temp0 = temp0 shr 1
        //> and #$07      ;mask out all but 3 LSB
        temp1 = temp0 and 0x07
        //> cpy #$01      ;right side of the screen or top?
        //> bcs SetOscrO  ;if so, branch, use difference / 8 as offset
        temp0 = temp1
        if (!(Y >= 0x01)) {
            //> adc $05       ;if not, add value to difference / 8
            temp2 = temp0 + memory[0x5].toInt() + (if (Y >= 0x01) 1 else 0)
            temp0 = temp2 and 0xFF
        }
        //> SetOscrO: tax           ;use as offset
    }
    //> ExDivPD:  rts           ;leave
    return
}

// Decompiled from SoundEngine
fun soundEngine() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var dacCounter by MemoryByte(DAC_Counter)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var joypadPort2 by MemoryByte(JOYPAD_PORT2)
    var noiseSoundBuffer by MemoryByte(NoiseSoundBuffer)
    var noiseSoundQueue by MemoryByte(NoiseSoundQueue)
    var operMode by MemoryByte(OperMode)
    var pauseModeFlag by MemoryByte(PauseModeFlag)
    var pauseSoundBuffer by MemoryByte(PauseSoundBuffer)
    var pauseSoundQueue by MemoryByte(PauseSoundQueue)
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    var square1SoundBuffer by MemoryByte(Square1SoundBuffer)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    var square2SoundQueue by MemoryByte(Square2SoundQueue)
    val sndDeltaReg by MemoryByteIndexed(SND_DELTA_REG)
    //> SoundEngine:
    //> lda OperMode              ;are we in title screen mode?
    //> bne SndOn
    temp0 = operMode
    if (operMode == 0) {
        //> sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
        sndMasterctrlReg = temp0
        //> rts
        return
    } else {
        //> SndOn:   lda #$ff
        temp0 = 0xFF
        //> sta JOYPAD_PORT2          ;disable irqs and set frame counter mode???
        joypadPort2 = temp0
        //> lda #$0f
        temp0 = 0x0F
        //> sta SND_MASTERCTRL_REG    ;enable first four channels
        sndMasterctrlReg = temp0
        //> lda PauseModeFlag         ;is sound already in pause mode?
        temp0 = pauseModeFlag
        //> bne InPause
        if (temp0 == 0) {
            //> lda PauseSoundQueue       ;if not, check pause sfx queue
            temp0 = pauseSoundQueue
            //> cmp #$01
            //> bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
            if (temp0 == 0x01) {
            }
        }
    }
    //> InPause: lda PauseSoundBuffer      ;check pause sfx buffer
    temp0 = pauseSoundBuffer
    //> bne ContPau
    if (temp0 == 0) {
        //> lda PauseSoundQueue       ;check pause queue
        temp0 = pauseSoundQueue
        //> beq SkipSoundSubroutines
        if (temp0 != 0) {
            //> sta PauseSoundBuffer      ;if queue full, store in buffer and activate
            pauseSoundBuffer = temp0
            //> sta PauseModeFlag         ;pause mode to interrupt game sounds
            pauseModeFlag = temp0
            //> lda #$00                  ;disable sound and clear sfx buffers
            temp0 = 0x00
            //> sta SND_MASTERCTRL_REG
            sndMasterctrlReg = temp0
            //> sta Square1SoundBuffer
            square1SoundBuffer = temp0
            //> sta Square2SoundBuffer
            square2SoundBuffer = temp0
            //> sta NoiseSoundBuffer
            noiseSoundBuffer = temp0
            //> lda #$0f
            temp0 = 0x0F
            //> sta SND_MASTERCTRL_REG    ;enable sound again
            sndMasterctrlReg = temp0
            //> lda #$2a                  ;store length of sound in pause counter
            temp0 = 0x2A
            //> sta Squ1_SfxLenCounter
            squ1Sfxlencounter = temp0
            //> PTone1F: lda #$44                  ;play first tone
            temp0 = 0x44
            //> bne PTRegC                ;unconditional branch
            if (temp0 == 0) {
            }
        }
    }
    //> ContPau: lda Squ1_SfxLenCounter    ;check pause length left
    temp0 = squ1Sfxlencounter
    //> cmp #$24                  ;time to play second?
    //> beq PTone2F
    if (temp0 != 0x24) {
        do {
            //> cmp #$1e                  ;time to play first again?
            //> beq PTone1F
        } while (temp0 == 0x1E)
        //> cmp #$18                  ;time to play second again?
        //> bne DecPauC               ;only load regs during times, otherwise skip
        if (temp0 == 0x18) {
        }
    }
    //> PTone2F: lda #$64                  ;store reg contents and play the pause sfx
    temp0 = 0x64
    //> PTRegC:  ldx #$84
    //> ldy #$7f
    //> jsr PlaySqu1Sfx
    playSqu1Sfx()
    //> DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
    squ1Sfxlencounter = (squ1Sfxlencounter - 1) and 0xFF
    //> bne SkipSoundSubroutines
    temp1 = 0x84
    temp2 = 0x7F
    if (squ1Sfxlencounter == 0) {
        //> lda #$00                  ;disable sound if in pause mode and
        temp0 = 0x00
        //> sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
        sndMasterctrlReg = temp0
        //> lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
        temp0 = pauseSoundBuffer
        //> cmp #$02                  ;if we need to be playing sound again
        //> bne SkipPIn
        if (temp0 == 0x02) {
            //> lda #$00                  ;clear pause mode to allow game sounds again
            temp0 = 0x00
            //> sta PauseModeFlag
            pauseModeFlag = temp0
        }
        //> SkipPIn: lda #$00                  ;clear pause sfx buffer
        temp0 = 0x00
        //> sta PauseSoundBuffer
        pauseSoundBuffer = temp0
        //> beq SkipSoundSubroutines
        if (temp0 != 0) {
            //> RunSoundSubroutines:
            //> jsr Square1SfxHandler  ;play sfx on square channel 1
            square1SfxHandler()
            //> jsr Square2SfxHandler  ; ''  ''  '' square channel 2
            square2SfxHandler()
            //> jsr NoiseSfxHandler    ; ''  ''  '' noise channel
            noiseSfxHandler()
            //> jsr MusicHandler       ;play music on all channels
            musicHandler()
            //> lda #$00               ;clear the music queues
            temp0 = 0x00
            //> sta AreaMusicQueue
            areaMusicQueue = temp0
            //> sta EventMusicQueue
            eventMusicQueue = temp0
        }
    }
    //> SkipSoundSubroutines:
    //> lda #$00               ;clear the sound effects queues
    temp0 = 0x00
    //> sta Square1SoundQueue
    square1SoundQueue = temp0
    //> sta Square2SoundQueue
    square2SoundQueue = temp0
    //> sta NoiseSoundQueue
    noiseSoundQueue = temp0
    //> sta PauseSoundQueue
    pauseSoundQueue = temp0
    //> ldy DAC_Counter        ;load some sort of counter
    temp2 = dacCounter
    //> lda AreaMusicBuffer
    temp0 = areaMusicBuffer
    //> and #%00000011         ;check for specific music
    temp3 = temp0 and 0x03
    //> beq NoIncDAC
    temp0 = temp3
    if (temp3 != 0) {
        //> inc DAC_Counter        ;increment and check counter
        dacCounter = (dacCounter + 1) and 0xFF
        //> cpy #$30
        //> bcc StrWave            ;if not there yet, just store it
        if (temp2 >= 0x30) {
        } else {
            //> StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
            sndDeltaReg[1] = temp2
            //> rts                    ;we are done here
            return
        }
    }
    //> NoIncDAC: tya
    //> beq StrWave            ;if we are at zero, do not decrement
    temp0 = temp2
    if (temp2 != 0) {
        //> dec DAC_Counter        ;decrement counter
        dacCounter = (dacCounter - 1) and 0xFF
    }
}

// Decompiled from Dump_Squ1_Regs
fun dumpSqu1Regs(X: Int, Y: Int) {
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    //> Dump_Squ1_Regs:
    //> sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
    sndSquare1Reg[1] = Y
    //> stx SND_SQUARE1_REG
    sndSquare1Reg[0] = X
    //> rts
    return
}

// Decompiled from PlaySqu1Sfx
fun playSqu1Sfx() {
    var X: Int = 0
    var Y: Int = 0
    //> PlaySqu1Sfx:
    //> jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
    dumpSqu1Regs(X, Y)
    // Fall-through tail call to setfreqSqu1
    setfreqSqu1(A)
}

// Decompiled from SetFreq_Squ1
fun setfreqSqu1(A: Int) {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    val freqRegLookupTbl by MemoryByteIndexed(FreqRegLookupTbl)
    val sndRegister by MemoryByteIndexed(SND_REGISTER)
    //> SetFreq_Squ1:
    //> ldx #$00               ;set frequency reg offset for square 1 sound channel
    //> Dump_Freq_Regs:
    //> tay
    //> lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
    //> beq NoTone                ;if zero, then do not load
    temp0 = freqRegLookupTbl[1 + A]
    temp1 = 0x00
    temp2 = A
    if (freqRegLookupTbl[1 + A] != 0) {
        //> sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
        sndRegister[2 + temp1] = temp0
        //> lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
        temp0 = freqRegLookupTbl[temp2]
        //> ora #%00001000            ;length counter
        temp3 = temp0 or 0x08
        //> sta SND_REGISTER+3,x
        sndRegister[3 + temp1] = temp3
    }
    //> NoTone: rts
    return
}

// Decompiled from Dump_Sq2_Regs
fun dumpSq2Regs(X: Int, Y: Int) {
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    //> Dump_Sq2_Regs:
    //> stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
    sndSquare2Reg[0] = X
    //> sty SND_SQUARE2_REG+1
    sndSquare2Reg[1] = Y
    //> rts
    return
}

// Decompiled from PlaySqu2Sfx
fun playSqu2Sfx() {
    var X: Int = 0
    var Y: Int = 0
    //> PlaySqu2Sfx:
    //> jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
    dumpSq2Regs(X, Y)
    // Fall-through tail call to setfreqSqu2
    setfreqSqu2(A)
}

// Decompiled from SetFreq_Squ2
fun setfreqSqu2(A: Int) {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val freqRegLookupTbl by MemoryByteIndexed(FreqRegLookupTbl)
    val sndRegister by MemoryByteIndexed(SND_REGISTER)
    //> Dump_Freq_Regs:
    //> tay
    //> lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
    //> beq NoTone                ;if zero, then do not load
    temp0 = freqRegLookupTbl[1 + A]
    temp1 = A
    if (freqRegLookupTbl[1 + A] != 0) {
        //> sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
        sndRegister[2 + X] = temp0
        //> lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
        temp0 = freqRegLookupTbl[temp1]
        //> ora #%00001000            ;length counter
        temp2 = temp0 or 0x08
        //> sta SND_REGISTER+3,x
        sndRegister[3 + X] = temp2
    }
    //> NoTone: rts
    return
}

// Decompiled from SetFreq_Tri
fun setfreqTri(A: Int) {
    var X: Int = 0
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    val freqRegLookupTbl by MemoryByteIndexed(FreqRegLookupTbl)
    val sndRegister by MemoryByteIndexed(SND_REGISTER)
    //> Dump_Freq_Regs:
    //> tay
    //> lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
    //> beq NoTone                ;if zero, then do not load
    temp0 = freqRegLookupTbl[1 + A]
    temp1 = A
    if (freqRegLookupTbl[1 + A] != 0) {
        //> sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
        sndRegister[2 + X] = temp0
        //> lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
        temp0 = freqRegLookupTbl[temp1]
        //> ora #%00001000            ;length counter
        temp2 = temp0 or 0x08
        //> sta SND_REGISTER+3,x
        sndRegister[3 + X] = temp2
    }
    //> NoTone: rts
    return
}

// Decompiled from Square1SfxHandler
fun square1SfxHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var squ1Sfxlencounter by MemoryByte(Squ1_SfxLenCounter)
    var square1SoundBuffer by MemoryByte(Square1SoundBuffer)
    var square1SoundQueue by MemoryByte(Square1SoundQueue)
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    val swimStompEnvelopeData by MemoryByteIndexed(SwimStompEnvelopeData)
    do {
        //> PlayFlagpoleSlide:
        //> lda #$40               ;store length of flagpole sound
        //> sta Squ1_SfxLenCounter
        squ1Sfxlencounter = 0x40
        //> lda #$62               ;load part of reg contents for flagpole sound
        //> jsr SetFreq_Squ1
        setfreqSqu1(0x62)
        //> ldx #$99               ;now load the rest
        //> bne FPS2nd
        temp0 = 0x62
        temp1 = 0x99
        if (0x99 == 0) {
            //> PlaySmallJump:
            //> lda #$26               ;branch here for small mario jumping sound
            temp0 = 0x26
            //> bne JumpRegContents
            if (temp0 == 0) {
                //> PlayBigJump:
                //> lda #$18               ;branch here for big mario jumping sound
                temp0 = 0x18
            }
            //> JumpRegContents:
            //> ldx #$82               ;note that small and big jump borrow each others' reg contents
            temp1 = 0x82
            //> ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
            //> jsr PlaySqu1Sfx
            playSqu1Sfx()
            //> lda #$28               ;store length of sfx for both jumping sounds
            temp0 = 0x28
            //> sta Squ1_SfxLenCounter ;then continue on here
            squ1Sfxlencounter = temp0
            //> ContinueSndJump:
            //> lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
            temp0 = squ1Sfxlencounter
            //> cmp #$25               ;check for time to play second part yet
            //> bne N2Prt
            temp2 = 0xA7
            if (temp0 == 0x25) {
                //> ldx #$5f               ;load second part
                temp1 = 0x5F
                //> ldy #$f6
                temp2 = 0xF6
                //> bne DmpJpFPS           ;unconditional branch
                if (temp2 == 0) {
                }
            }
            //> N2Prt:    cmp #$20               ;check for third part
            //> bne DecJpFPS
            if (temp0 == 0x20) {
                //> ldx #$48               ;load third part
                temp1 = 0x48
            }
        }
        //> FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
        temp2 = 0xBC
        //> DmpJpFPS: jsr Dump_Squ1_Regs
        dumpSqu1Regs(temp1, temp2)
        //> bne DecJpFPS           ;unconditional branch outta here
        if (temp2 == 0) {
            //> PlayFireballThrow:
            //> lda #$05
            temp0 = 0x05
            //> ldy #$99                 ;load reg contents for fireball throw sound
            temp2 = 0x99
            //> bne Fthrow               ;unconditional branch
            if (temp2 == 0) {
                //> PlayBump:
                //> lda #$0a                ;load length of sfx and reg contents for bump sound
                temp0 = 0x0A
                //> ldy #$93
                temp2 = 0x93
            }
            //> Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
            temp1 = 0x9E
            //> sta Squ1_SfxLenCounter
            squ1Sfxlencounter = temp0
            //> lda #$0c                ;load offset for bump sound
            temp0 = 0x0C
            //> jsr PlaySqu1Sfx
            playSqu1Sfx()
            //> ContinueBumpThrow:
            //> lda Squ1_SfxLenCounter  ;check for second part of bump sound
            temp0 = squ1Sfxlencounter
            //> cmp #$06
            //> bne DecJpFPS
            if (temp0 == 0x06) {
                //> lda #$bb                ;load second part directly
                temp0 = 0xBB
                //> sta SND_SQUARE1_REG+1
                sndSquare1Reg[1] = temp0
            }
        }
        //> DecJpFPS: bne BranchToDecLength1  ;unconditional branch
        if (flagZ) {
            //> Square1SfxHandler:
            //> ldy Square1SoundQueue   ;check for sfx in queue
            temp2 = square1SoundQueue
            //> beq CheckSfx1Buffer
            if (temp2 != 0) {
                //> sty Square1SoundBuffer  ;if found, put in buffer
                square1SoundBuffer = temp2
                //> bmi PlaySmallJump       ;small jump
                //> lsr Square1SoundQueue
                square1SoundQueue = square1SoundQueue shr 1
                //> bcs PlayBigJump         ;big jump
                do {
                    //> lsr Square1SoundQueue
                    square1SoundQueue = square1SoundQueue shr 1
                    //> bcs PlayBump            ;bump
                } while ((square1SoundQueue and 0x01) != 0)
                //> lsr Square1SoundQueue
                square1SoundQueue = square1SoundQueue shr 1
                //> bcs PlaySwimStomp       ;swim/stomp
                if ((square1SoundQueue and 0x01) == 0) {
                    //> lsr Square1SoundQueue
                    square1SoundQueue = square1SoundQueue shr 1
                    //> bcs PlaySmackEnemy      ;smack enemy
                    if ((square1SoundQueue and 0x01) == 0) {
                        //> lsr Square1SoundQueue
                        square1SoundQueue = square1SoundQueue shr 1
                        //> bcs PlayPipeDownInj     ;pipedown/injury
                        if ((square1SoundQueue and 0x01) == 0) {
                            //> lsr Square1SoundQueue
                            square1SoundQueue = square1SoundQueue shr 1
                            //> bcs PlayFireballThrow   ;fireball throw
                            //> lsr Square1SoundQueue
                            square1SoundQueue = square1SoundQueue shr 1
                            //> bcs PlayFlagpoleSlide   ;slide flagpole
                        }
                    }
                }
            }
            //> CheckSfx1Buffer:
            //> lda Square1SoundBuffer   ;check for sfx in buffer
            temp0 = square1SoundBuffer
            //> beq ExS1H                ;if not found, exit sub
            if (temp0 != 0) {
                //> bmi ContinueSndJump      ;small mario jump
                //> lsr
                temp0 = temp0 shr 1
                //> bcs ContinueSndJump      ;big mario jump
                //> lsr
                temp0 = temp0 shr 1
                //> bcs ContinueBumpThrow    ;bump
                //> lsr
                temp0 = temp0 shr 1
                //> bcs ContinueSwimStomp    ;swim/stomp
                if ((temp0 and 0x01) == 0) {
                    //> lsr
                    temp0 = temp0 shr 1
                    //> bcs ContinueSmackEnemy   ;smack enemy
                    if ((temp0 and 0x01) == 0) {
                        //> lsr
                        temp0 = temp0 shr 1
                        //> bcs ContinuePipeDownInj  ;pipedown/injury
                        if ((temp0 and 0x01) == 0) {
                            //> lsr
                            temp0 = temp0 shr 1
                            //> bcs ContinueBumpThrow    ;fireball throw
                        }
                    }
                }
            } else {
                //> ExS1H: rts
                return
            }
        }
    } while (flagC)
    //> lsr
    temp0 = temp0 shr 1
    //> bcs DecrementSfx1Length  ;slide flagpole
    if ((temp0 and 0x01) == 0) {
        //> PlaySwimStomp:
        //> lda #$0e               ;store length of swim/stomp sound
        temp0 = 0x0E
        //> sta Squ1_SfxLenCounter
        squ1Sfxlencounter = temp0
        //> ldy #$9c               ;store reg contents for swim/stomp sound
        temp2 = 0x9C
        //> ldx #$9e
        temp1 = 0x9E
        //> lda #$26
        temp0 = 0x26
        //> jsr PlaySqu1Sfx
        playSqu1Sfx()
        //> ContinueSwimStomp:
        //> ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
        temp2 = squ1Sfxlencounter
        //> lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
        temp0 = swimStompEnvelopeData[-1 + temp2]
        //> sta SND_SQUARE1_REG           ;envelope
        sndSquare1Reg[0] = temp0
        //> cpy #$06
        //> bne BranchToDecLength1
        if (temp2 == 0x06) {
            //> lda #$9e                      ;when the length counts down to a certain point, put this
            temp0 = 0x9E
            //> sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
            sndSquare1Reg[2] = temp0
        }
        //> BranchToDecLength1:
        //> bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
        if (flagZ) {
            //> PlaySmackEnemy:
            //> lda #$0e                 ;store length of smack enemy sound
            temp0 = 0x0E
            //> ldy #$cb
            temp2 = 0xCB
            //> ldx #$9f
            temp1 = 0x9F
            //> sta Squ1_SfxLenCounter
            squ1Sfxlencounter = temp0
            //> lda #$28                 ;store reg contents for smack enemy sound
            temp0 = 0x28
            //> jsr PlaySqu1Sfx
            playSqu1Sfx()
            //> bne DecrementSfx1Length  ;unconditional branch
            if (temp0 == 0) {
                //> ContinueSmackEnemy:
                //> ldy Squ1_SfxLenCounter  ;check about halfway through
                temp2 = squ1Sfxlencounter
                //> cpy #$08
                //> bne SmSpc
                if (temp2 == 0x08) {
                    //> lda #$a0                ;if we're at the about-halfway point, make the second tone
                    temp0 = 0xA0
                    //> sta SND_SQUARE1_REG+2   ;in the smack enemy sound
                    sndSquare1Reg[2] = temp0
                    //> lda #$9f
                    temp0 = 0x9F
                    //> bne SmTick
                    if (temp0 == 0) {
                    }
                }
                //> SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
                temp0 = 0x90
                //> SmTick: sta SND_SQUARE1_REG
                sndSquare1Reg[0] = temp0
            }
        }
    }
    //> DecrementSfx1Length:
    //> dec Squ1_SfxLenCounter    ;decrement length of sfx
    squ1Sfxlencounter = (squ1Sfxlencounter - 1) and 0xFF
    //> bne ExSfx1
    if (squ1Sfxlencounter == 0) {
    }
    //> ExSfx1: rts
    return
}

// Decompiled from StopSquare1Sfx
fun stopSquare1Sfx() {
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    //> StopSquare1Sfx:
    //> ldx #$00                ;if end of sfx reached, clear buffer
    //> stx $f1                 ;and stop making the sfx
    memory[0xF1] = 0x00.toUByte()
    //> ldx #$0e
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = 0x0E
    //> ldx #$0f
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = 0x0F
    //> ExSfx1: rts
    return
}

// Decompiled from StopSquare2Sfx
fun stopSquare2Sfx() {
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    //> StopSquare2Sfx:
    //> ldx #$0d                ;stop playing the sfx
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = 0x0D
    //> ldx #$0f
    //> stx SND_MASTERCTRL_REG
    sndMasterctrlReg = 0x0F
    //> ExSfx2: rts
    return
}

// Decompiled from Square2SfxHandler
fun square2SfxHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var squ2Sfxlencounter by MemoryByte(Squ2_SfxLenCounter)
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    val extraLifeFreqData by MemoryByteIndexed(ExtraLifeFreqData)
    val pupVgrowFreqdata by MemoryByteIndexed(PUp_VGrow_FreqData)
    val powerUpGrabFreqData by MemoryByteIndexed(PowerUpGrabFreqData)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    //> PlayCoinGrab:
    //> lda #$35             ;load length of coin grab sound
    //> ldx #$8d             ;and part of reg contents
    //> bne CGrab_TTickRegL
    temp0 = 0x35
    temp1 = 0x8D
    if (0x8D == 0) {
        //> PlayTimerTick:
        //> lda #$06             ;load length of timer tick sound
        temp0 = 0x06
        //> ldx #$98             ;and part of reg contents
        temp1 = 0x98
    }
    //> CGrab_TTickRegL:
    //> sta Squ2_SfxLenCounter
    squ2Sfxlencounter = temp0
    //> ldy #$7f                ;load the rest of reg contents
    //> lda #$42                ;of coin grab and timer tick sound
    temp0 = 0x42
    //> jsr PlaySqu2Sfx
    playSqu2Sfx()
    //> ContinueCGrabTTick:
    //> lda Squ2_SfxLenCounter  ;check for time to play second tone yet
    temp0 = squ2Sfxlencounter
    //> cmp #$30                ;timer tick sound also executes this, not sure why
    //> bne N2Tone
    temp2 = 0x7F
    if (temp0 == 0x30) {
        //> lda #$54                ;if so, load the tone directly into the reg
        temp0 = 0x54
        //> sta SND_SQUARE2_REG+2
        sndSquare2Reg[2] = temp0
    }
    //> N2Tone: bne DecrementSfx2Length
    if (flagZ) {
        //> PlayBlast:
        //> lda #$20                ;load length of fireworks/gunfire sound
        temp0 = 0x20
        //> sta Squ2_SfxLenCounter
        squ2Sfxlencounter = temp0
        //> ldy #$94                ;load reg contents of fireworks/gunfire sound
        temp2 = 0x94
        //> lda #$5e
        temp0 = 0x5E
        //> bne SBlasJ
        if (temp0 == 0) {
            //> ContinueBlast:
            //> lda Squ2_SfxLenCounter  ;check for time to play second part
            temp0 = squ2Sfxlencounter
            //> cmp #$18
            //> bne DecrementSfx2Length
            if (temp0 == 0x18) {
                //> ldy #$93                ;load second part reg contents then
                temp2 = 0x93
                //> lda #$18
                temp0 = 0x18
            }
        }
        //> SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
        if (flagZ) {
            //> PlayPowerUpGrab:
            //> lda #$36                    ;load length of power-up grab sound
            temp0 = 0x36
            //> sta Squ2_SfxLenCounter
            squ2Sfxlencounter = temp0
            //> ContinuePowerUpGrab:
            //> lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
            temp0 = squ2Sfxlencounter
            //> lsr                         ;divide by 2
            temp0 = temp0 shr 1
            //> bcs DecrementSfx2Length     ;alter frequency every other frame
            if ((temp0 and 0x01) == 0) {
                //> tay
                //> lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
                temp0 = powerUpGrabFreqData[-1 + temp0]
                //> ldx #$5d                    ;store reg contents of power-up grab sound
                temp1 = 0x5D
                //> ldy #$7f
                temp2 = 0x7F
                //> LoadSqu2Regs:
                //> jsr PlaySqu2Sfx
                playSqu2Sfx()
            }
        }
    }
    //> DecrementSfx2Length:
    //> dec Squ2_SfxLenCounter   ;decrement length of sfx
    squ2Sfxlencounter = (squ2Sfxlencounter - 1) and 0xFF
    //> bne ExSfx2
    if (squ2Sfxlencounter == 0) {
        //> EmptySfx2Buffer:
        //> ldx #$00                ;initialize square 2's sound effects buffer
        temp1 = 0x00
        //> stx Square2SoundBuffer
        square2SoundBuffer = temp1
    }
    //> ExSfx2: rts
    return
}

// Decompiled from NoiseSfxHandler
fun noiseSfxHandler() {
    var temp0: Int = 0
    var noiseSoundBuffer by MemoryByte(NoiseSoundBuffer)
    var noiseSfxlencounter by MemoryByte(Noise_SfxLenCounter)
    val bowserFlameEnvData by MemoryByteIndexed(BowserFlameEnvData)
    val brickShatterEnvData by MemoryByteIndexed(BrickShatterEnvData)
    val brickShatterFreqData by MemoryByteIndexed(BrickShatterFreqData)
    val musicHeaderData by MemoryByteIndexed(MusicHeaderData)
    val musicHeaderOffsetData by MemoryByteIndexed(MusicHeaderOffsetData)
    val sndNoiseReg by MemoryByteIndexed(SND_NOISE_REG)
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    val sndTriangleReg by MemoryByteIndexed(SND_TRIANGLE_REG)
    //> PlayBrickShatter:
    //> lda #$20                 ;load length of brick shatter sound
    //> sta Noise_SfxLenCounter
    noiseSfxlencounter = 0x20
    //> ContinueBrickShatter:
    //> lda Noise_SfxLenCounter
    //> lsr                         ;divide by 2 and check for bit set to use offset
    noiseSfxlencounter = noiseSfxlencounter shr 1
    //> bcc DecrementSfx3Length
    temp0 = noiseSfxlencounter
    if ((noiseSfxlencounter and 0x01) != 0) {
        //> tay
        //> ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
        //> lda BrickShatterEnvData,y
        temp0 = brickShatterEnvData[temp0]
        //> PlayNoiseSfx:
        //> sta SND_NOISE_REG        ;play the sfx
        sndNoiseReg[0] = temp0
        //> stx SND_NOISE_REG+2
        sndNoiseReg[2] = brickShatterFreqData[temp0]
        //> lda #$18
        temp0 = 0x18
        //> sta SND_NOISE_REG+3
        sndNoiseReg[3] = temp0
    }
    //> DecrementSfx3Length:
    //> dec Noise_SfxLenCounter  ;decrement length of sfx
    noiseSfxlencounter = (noiseSfxlencounter - 1) and 0xFF
    //> bne ExSfx3
    if (noiseSfxlencounter == 0) {
        //> lda #$f0                 ;if done, stop playing the sfx
        temp0 = 0xF0
        //> sta SND_NOISE_REG
        sndNoiseReg[0] = temp0
        //> lda #$00
        temp0 = 0x00
        //> sta NoiseSoundBuffer
        noiseSoundBuffer = temp0
    }
    //> ExSfx3: rts
    return
}

// Decompiled from MusicHandler
fun musicHandler() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp10: Int = 0
    var temp11: Int = 0
    var temp12: Int = 0
    var temp13: Int = 0
    var temp14: Int = 0
    var temp2: Int = 0
    var temp3: Int = 0
    var temp4: Int = 0
    var temp5: Int = 0
    var temp6: Int = 0
    var temp7: Int = 0
    var temp8: Int = 0
    var temp9: Int = 0
    var altRegContentFlag by MemoryByte(AltRegContentFlag)
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var areamusicbufferAlt by MemoryByte(AreaMusicBuffer_Alt)
    var areaMusicQueue by MemoryByte(AreaMusicQueue)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    var eventMusicQueue by MemoryByte(EventMusicQueue)
    var groundMusicHeaderOfs by MemoryByte(GroundMusicHeaderOfs)
    var musicDataHigh by MemoryByte(MusicDataHigh)
    var musicDataLow by MemoryByte(MusicDataLow)
    var musicoffsetNoise by MemoryByte(MusicOffset_Noise)
    var musicoffsetSquare1 by MemoryByte(MusicOffset_Square1)
    var musicoffsetSquare2 by MemoryByte(MusicOffset_Square2)
    var musicoffsetTriangle by MemoryByte(MusicOffset_Triangle)
    var noiseDataLoopbackOfs by MemoryByte(NoiseDataLoopbackOfs)
    var noiseBeatlencounter by MemoryByte(Noise_BeatLenCounter)
    var noteLenLookupTblOfs by MemoryByte(NoteLenLookupTblOfs)
    var noteLengthTblAdder by MemoryByte(NoteLengthTblAdder)
    var sndMasterctrlReg by MemoryByte(SND_MASTERCTRL_REG)
    var squ1Envelopedatactrl by MemoryByte(Squ1_EnvelopeDataCtrl)
    var squ1Notelencounter by MemoryByte(Squ1_NoteLenCounter)
    var squ2Envelopedatactrl by MemoryByte(Squ2_EnvelopeDataCtrl)
    var squ2Notelenbuffer by MemoryByte(Squ2_NoteLenBuffer)
    var squ2Notelencounter by MemoryByte(Squ2_NoteLenCounter)
    var square1SoundBuffer by MemoryByte(Square1SoundBuffer)
    var square2SoundBuffer by MemoryByte(Square2SoundBuffer)
    var triNotelenbuffer by MemoryByte(Tri_NoteLenBuffer)
    var triNotelencounter by MemoryByte(Tri_NoteLenCounter)
    val musicHeaderData by MemoryByteIndexed(MusicHeaderData)
    val musicHeaderOffsetData by MemoryByteIndexed(MusicHeaderOffsetData)
    val sndNoiseReg by MemoryByteIndexed(SND_NOISE_REG)
    val sndSquare1Reg by MemoryByteIndexed(SND_SQUARE1_REG)
    val sndSquare2Reg by MemoryByteIndexed(SND_SQUARE2_REG)
    val sndTriangleReg by MemoryByteIndexed(SND_TRIANGLE_REG)
    //> ContinueMusic:
    //> jmp HandleSquare2Music  ;if we have music, start with square 2 channel
    //> MusicHandler:
    //> lda EventMusicQueue     ;check event music queue
    //> bne LoadEventMusic
    if (!(eventMusicQueue == 0)) {
        //  goto LoadEventMusic
        return
    }
    temp0 = eventMusicQueue
    if (eventMusicQueue == 0) {
        //> lda AreaMusicQueue      ;check area music queue
        temp0 = areaMusicQueue
        //> bne LoadAreaMusic
        if (!(temp0 == 0)) {
            //  goto LoadAreaMusic
            return
        }
        if (temp0 == 0) {
            //> lda EventMusicBuffer    ;check both buffers
            temp0 = eventMusicBuffer
            //> ora AreaMusicBuffer
            temp1 = temp0 or areaMusicBuffer
            //> bne ContinueMusic
            if (!(temp1 == 0)) {
                //  goto ContinueMusic
                return
            }
            //> rts                     ;no music, then leave
            return
        }
    }
    //> LoadEventMusic:
    //> sta EventMusicBuffer      ;copy event music queue contents to buffer
    eventMusicBuffer = temp0
    //> cmp #DeathMusic           ;is it death music?
    //> bne NoStopSfx             ;if not, jump elsewhere
    if (temp0 == DeathMusic) {
        //> jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
        stopSquare1Sfx()
        //> jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
        stopSquare2Sfx()
    }
    //> NoStopSfx: ldx AreaMusicBuffer
    //> stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
    areamusicbufferAlt = areaMusicBuffer
    //> ldy #$00
    //> sty NoteLengthTblAdder    ;default value for additional length byte offset
    noteLengthTblAdder = 0x00
    //> sty AreaMusicBuffer       ;clear area music buffer
    areaMusicBuffer = 0x00
    //> cmp #TimeRunningOutMusic  ;is it time running out music?
    //> bne FindEventMusicHeader
    temp2 = areaMusicBuffer
    temp3 = 0x00
    if (temp0 == TimeRunningOutMusic) {
        //> ldx #$08                  ;load offset to be added to length byte of header
        temp2 = 0x08
        //> stx NoteLengthTblAdder
        noteLengthTblAdder = temp2
        //> bne FindEventMusicHeader  ;unconditional branch
        if (temp2 == 0) {
            //> LoadAreaMusic:
            //> cmp #$04                  ;is it underground music?
            //> bne NoStop1               ;no, do not stop square 1 sfx
            if (temp0 == 0x04) {
                //> jsr StopSquare1Sfx
                stopSquare1Sfx()
            }
            //> NoStop1: ldy #$10                  ;start counter used only by ground level music
            temp3 = 0x10
            while (temp3 != 0) {
                //> GMLoopB: sty GroundMusicHeaderOfs
                groundMusicHeaderOfs = temp3
                //> HandleAreaMusicLoopB:
                //> ldy #$00                  ;clear event music buffer
                temp3 = 0x00
                //> sty EventMusicBuffer
                eventMusicBuffer = temp3
                //> sta AreaMusicBuffer       ;copy area music queue contents to buffer
                areaMusicBuffer = temp0
                //> cmp #$01                  ;is it ground level music?
                //> bne FindAreaMusicHeader
                //> inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
                groundMusicHeaderOfs = (groundMusicHeaderOfs + 1) and 0xFF
                //> ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
                temp3 = groundMusicHeaderOfs
                //> cpy #$32
                //> bne LoadHeader            ;branch ahead with alternate offset
                //> ldy #$11
                temp3 = 0x11
                //> bne GMLoopB               ;unconditional branch
            }
            //> FindAreaMusicHeader:
            //> ldy #$08                   ;load Y for offset of area music
            temp3 = 0x08
            //> sty MusicOffset_Square2    ;residual instruction here
            musicoffsetSquare2 = temp3
        }
    }
    do {
        //> FindEventMusicHeader:
        //> iny                       ;increment Y pointer based on previously loaded queue contents
        temp3 = (temp3 + 1) and 0xFF
        //> lsr                       ;bit shift and increment until we find a set bit for music
        temp0 = temp0 shr 1
        //> bcc FindEventMusicHeader
    } while ((temp0 and 0x01) == 0)
    //> LoadHeader:
    //> lda MusicHeaderOffsetData,y  ;load offset for header
    temp0 = musicHeaderOffsetData[temp3]
    //> tay
    //> lda MusicHeaderData,y        ;now load the header
    temp0 = musicHeaderData[temp0]
    //> sta NoteLenLookupTblOfs
    noteLenLookupTblOfs = temp0
    //> lda MusicHeaderData+1,y
    temp0 = musicHeaderData[1 + temp0]
    //> sta MusicDataLow
    musicDataLow = temp0
    //> lda MusicHeaderData+2,y
    temp0 = musicHeaderData[2 + temp0]
    //> sta MusicDataHigh
    musicDataHigh = temp0
    //> lda MusicHeaderData+3,y
    temp0 = musicHeaderData[3 + temp0]
    //> sta MusicOffset_Triangle
    musicoffsetTriangle = temp0
    //> lda MusicHeaderData+4,y
    temp0 = musicHeaderData[4 + temp0]
    //> sta MusicOffset_Square1
    musicoffsetSquare1 = temp0
    //> lda MusicHeaderData+5,y
    temp0 = musicHeaderData[5 + temp0]
    //> sta MusicOffset_Noise
    musicoffsetNoise = temp0
    //> sta NoiseDataLoopbackOfs
    noiseDataLoopbackOfs = temp0
    //> lda #$01                     ;initialize music note counters
    temp0 = 0x01
    //> sta Squ2_NoteLenCounter
    squ2Notelencounter = temp0
    //> sta Squ1_NoteLenCounter
    squ1Notelencounter = temp0
    //> sta Tri_NoteLenCounter
    triNotelencounter = temp0
    //> sta Noise_BeatLenCounter
    noiseBeatlencounter = temp0
    //> lda #$00                     ;initialize music data offset for square 2
    temp0 = 0x00
    //> sta MusicOffset_Square2
    musicoffsetSquare2 = temp0
    //> sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
    altRegContentFlag = temp0
    //> lda #$0b                     ;disable triangle channel and reenable it
    temp0 = 0x0B
    //> sta SND_MASTERCTRL_REG
    sndMasterctrlReg = temp0
    //> lda #$0f
    temp0 = 0x0F
    //> sta SND_MASTERCTRL_REG
    sndMasterctrlReg = temp0
    //> HandleSquare2Music:
    //> dec Squ2_NoteLenCounter  ;decrement square 2 note length
    squ2Notelencounter = (squ2Notelencounter - 1) and 0xFF
    //> bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
    temp3 = temp0
    if (squ2Notelencounter == 0) {
        //> ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
        temp3 = musicoffsetSquare2
        //> inc MusicOffset_Square2
        musicoffsetSquare2 = (musicoffsetSquare2 + 1) and 0xFF
        //> lda (MusicData),y
        temp0 = memory[readWord(MusicData) + temp3].toInt()
        //> beq EndOfMusicData       ;if zero, the data is a null terminator
        if (temp0 != 0) {
            //> bpl Squ2NoteHandler      ;if non-negative, data is a note
            if ((temp0 and 0x80) != 0) {
                //> bne Squ2LengthHandler    ;otherwise it is length data
                if (temp0 == 0) {
                }
            }
        }
        //> EndOfMusicData:
        //> lda EventMusicBuffer     ;check secondary buffer for time running out music
        temp0 = eventMusicBuffer
        //> cmp #TimeRunningOutMusic
        //> bne NotTRO
        if (temp0 == TimeRunningOutMusic) {
            //> lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
            temp0 = areamusicbufferAlt
            //> bne MusicLoopBack        ;and start playing the song again if there is one
            if (!(temp0 == 0)) {
                //  goto MusicLoopBack
                return
            }
            if (temp0 == 0) {
            }
        }
        //> NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
        temp4 = temp0 and VictoryMusic
        //> bne VictoryMLoopBack
        if (!(temp4 == 0)) {
            //  goto VictoryMLoopBack
            return
        }
        temp0 = temp4
        if (temp4 == 0) {
            //> lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
            temp0 = areaMusicBuffer
            //> and #%01011111
            temp5 = temp0 and 0x5F
            //> bne MusicLoopBack        ;if any area music except pipe intro, music loops
            if (!(temp5 == 0)) {
                //  goto MusicLoopBack
                return
            }
            temp0 = temp5
            if (temp5 == 0) {
                //> lda #$00                 ;clear primary and secondary buffers and initialize
                temp0 = 0x00
                //> sta AreaMusicBuffer      ;control regs of square and triangle channels
                areaMusicBuffer = temp0
                //> sta EventMusicBuffer
                eventMusicBuffer = temp0
                //> sta SND_TRIANGLE_REG
                sndTriangleReg[0] = temp0
                //> lda #$90
                temp0 = 0x90
                //> sta SND_SQUARE1_REG
                sndSquare1Reg[0] = temp0
                //> sta SND_SQUARE2_REG
                sndSquare2Reg[0] = temp0
                //> rts
                return
            }
            while (true) {
                //> MusicLoopBack:
                //> jmp HandleAreaMusicLoopB
            }
        }
        while (true) {
            //> VictoryMLoopBack:
            //> jmp LoadEventMusic
        }
        //> Squ2LengthHandler:
        //> jsr ProcessLengthData    ;store length of note
        processLengthData(temp0)
        //> sta Squ2_NoteLenBuffer
        squ2Notelenbuffer = temp0
        //> ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
        temp3 = musicoffsetSquare2
        //> inc MusicOffset_Square2
        musicoffsetSquare2 = (musicoffsetSquare2 + 1) and 0xFF
        //> lda (MusicData),y
        temp0 = memory[readWord(MusicData) + temp3].toInt()
        //> Squ2NoteHandler:
        //> ldx Square2SoundBuffer     ;is there a sound playing on this channel?
        temp2 = square2SoundBuffer
        //> bne SkipFqL1
        if (temp2 == 0) {
            //> jsr SetFreq_Squ2           ;no, then play the note
            setfreqSqu2(temp0)
            //> beq Rest                   ;check to see if note is rest
            if (temp2 != 0) {
                //> jsr LoadControlRegs        ;if not, load control regs for square 2
                loadControlRegs()
            }
            //> Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
            squ2Envelopedatactrl = temp0
            //> jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
            dumpSq2Regs(temp2, temp3)
        }
        //> SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
        temp0 = squ2Notelenbuffer
        //> sta Squ2_NoteLenCounter
        squ2Notelencounter = temp0
    }
    //> MiscSqu2MusicTasks:
    //> lda Square2SoundBuffer     ;is there a sound playing on square 2?
    temp0 = square2SoundBuffer
    //> bne HandleSquare1Music
    if (temp0 == 0) {
        //> lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
        temp0 = eventMusicBuffer
        //> and #%10010001             ;note that regs for death music or d4 are loaded by default
        temp6 = temp0 and 0x91
        //> bne HandleSquare1Music
        temp0 = temp6
        if (temp6 == 0) {
            //> ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
            temp3 = squ2Envelopedatactrl
            //> beq NoDecEnv1
            if (temp3 != 0) {
                //> dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
                squ2Envelopedatactrl = (squ2Envelopedatactrl - 1) and 0xFF
            }
            //> NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
            loadEnvelopeData(temp3)
            //> sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
            sndSquare2Reg[0] = temp0
            //> ldx #$7f                   ;death music or d4 set on secondary buffer
            temp2 = 0x7F
            //> stx SND_SQUARE2_REG+1
            sndSquare2Reg[1] = temp2
        }
    }
    //> HandleSquare1Music:
    //> ldy MusicOffset_Square1    ;is there a nonzero offset here?
    temp3 = musicoffsetSquare1
    //> beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
    if (temp3 != 0) {
        //> dec Squ1_NoteLenCounter    ;decrement square 1 note length
        squ1Notelencounter = (squ1Notelencounter - 1) and 0xFF
        //> bne MiscSqu1MusicTasks     ;is it time for more data?
        if (squ1Notelencounter == 0) {
            while (temp0 != 0) {
                //> lda #$83
                temp0 = 0x83
                //> sta SND_SQUARE1_REG        ;store some data into control regs for square 1
                sndSquare1Reg[0] = temp0
                //> lda #$94                   ;and fetch another byte of data, used to give
                temp0 = 0x94
                //> sta SND_SQUARE1_REG+1      ;death music its unique sound
                sndSquare1Reg[1] = temp0
                //> sta AltRegContentFlag
                altRegContentFlag = temp0
                //> bne FetchSqu1MusicData     ;unconditional branch
            }
            //> Squ1NoteHandler:
            //> jsr AlternateLengthHandler
            alternateLengthHandler(temp0)
            //> sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
            squ1Notelencounter = temp0
            //> ldy Square1SoundBuffer     ;is there a sound playing on square 1?
            temp3 = square1SoundBuffer
            //> bne HandleTriangleMusic
            if (temp3 == 0) {
                //> txa
                //> and #%00111110             ;change saved data to appropriate note format
                temp7 = temp2 and 0x3E
                //> jsr SetFreq_Squ1           ;play the note
                setfreqSqu1(temp7)
                //> beq SkipCtrlL
                temp0 = temp7
                if (temp7 != 0) {
                    //> jsr LoadControlRegs
                    loadControlRegs()
                }
                //> SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
                squ1Envelopedatactrl = temp0
                //> jsr Dump_Squ1_Regs
                dumpSqu1Regs(temp2, temp3)
            }
        }
        //> MiscSqu1MusicTasks:
        //> lda Square1SoundBuffer     ;is there a sound playing on square 1?
        temp0 = square1SoundBuffer
        //> bne HandleTriangleMusic
        if (temp0 == 0) {
            //> lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
            temp0 = eventMusicBuffer
            //> and #%10010001
            temp8 = temp0 and 0x91
            //> bne DeathMAltReg
            temp0 = temp8
            if (temp8 == 0) {
                //> ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
                temp3 = squ1Envelopedatactrl
                //> beq NoDecEnv2
                if (temp3 != 0) {
                    //> dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
                    squ1Envelopedatactrl = (squ1Envelopedatactrl - 1) and 0xFF
                }
                //> NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
                loadEnvelopeData(temp3)
                //> sta SND_SQUARE1_REG        ;based on offset set by first load
                sndSquare1Reg[0] = temp0
            }
            //> DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
            temp0 = altRegContentFlag
            //> bne DoAltLoad
            if (temp0 == 0) {
                //> lda #$7f                   ;load this value if zero, the alternate value
                temp0 = 0x7F
            }
            //> DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
            sndSquare1Reg[1] = temp0
        }
    }
    //> HandleTriangleMusic:
    //> lda MusicOffset_Triangle
    temp0 = musicoffsetTriangle
    //> dec Tri_NoteLenCounter    ;decrement triangle note length
    triNotelencounter = (triNotelencounter - 1) and 0xFF
    //> bne HandleNoiseMusic      ;is it time for more data?
    if (triNotelencounter == 0) {
        //> ldy MusicOffset_Triangle  ;increment square 1 music offset and fetch data
        temp3 = musicoffsetTriangle
        //> inc MusicOffset_Triangle
        musicoffsetTriangle = (musicoffsetTriangle + 1) and 0xFF
        //> lda (MusicData),y
        temp0 = memory[readWord(MusicData) + temp3].toInt()
        //> beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise
        if (temp0 != 0) {
            //> bpl TriNoteHandler        ;if non-negative, data is note
            if ((temp0 and 0x80) != 0) {
                //> jsr ProcessLengthData     ;otherwise, it is length data
                processLengthData(temp0)
                //> sta Tri_NoteLenBuffer     ;save contents of A
                triNotelenbuffer = temp0
                //> lda #$1f
                temp0 = 0x1F
                //> sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
                sndTriangleReg[0] = temp0
                //> ldy MusicOffset_Triangle  ;fetch another byte
                temp3 = musicoffsetTriangle
                //> inc MusicOffset_Triangle
                musicoffsetTriangle = (musicoffsetTriangle + 1) and 0xFF
                //> lda (MusicData),y
                temp0 = memory[readWord(MusicData) + temp3].toInt()
                //> beq LoadTriCtrlReg        ;check once more for nonzero data
                if (temp0 != 0) {
                }
            }
            //> TriNoteHandler:
            //> jsr SetFreq_Tri
            setfreqTri(temp0)
            //> ldx Tri_NoteLenBuffer   ;save length in triangle note counter
            temp2 = triNotelenbuffer
            //> stx Tri_NoteLenCounter
            triNotelencounter = temp2
            //> lda EventMusicBuffer
            temp0 = eventMusicBuffer
            //> and #%01101110          ;check for death music or d4 set on secondary buffer
            temp9 = temp0 and 0x6E
            //> bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
            temp0 = temp9
            if (temp9 == 0) {
                //> lda AreaMusicBuffer     ;check primary buffer for water or castle level music
                temp0 = areaMusicBuffer
                //> and #%00001010
                temp10 = temp0 and 0x0A
                //> beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
                temp0 = temp10
                if (temp10 != 0) {
                }
            }
            //> NotDOrD4: txa                     ;if playing water or castle music or any secondary
            //> cmp #$12                ;besides death music or d4 set, check length of note
            //> bcs LongN
            temp0 = temp2
            if (!(temp2 >= 0x12)) {
                //> lda EventMusicBuffer    ;check for win castle music again if not playing a long note
                temp0 = eventMusicBuffer
                //> and #EndOfCastleMusic
                temp11 = temp0 and EndOfCastleMusic
                //> beq MediN
                temp0 = temp11
                if (temp11 != 0) {
                    //> lda #$0f                ;load value $0f if playing the win castle music and playing a short
                    temp0 = 0x0F
                    //> bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
                    if (temp0 == 0) {
                    }
                }
                //> MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
                temp0 = 0x1F
                //> bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
                if (temp0 == 0) {
                }
            }
            //> LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
            temp0 = 0xFF
        }
        //> LoadTriCtrlReg:
        //> sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
        sndTriangleReg[0] = temp0
    }
    //> HandleNoiseMusic:
    //> lda AreaMusicBuffer       ;check if playing underground or castle music
    temp0 = areaMusicBuffer
    //> and #%11110011
    temp12 = temp0 and 0xF3
    //> beq ExitMusicHandler      ;if so, skip the noise routine
    temp0 = temp12
    if (temp12 != 0) {
        //> dec Noise_BeatLenCounter  ;decrement noise beat length
        noiseBeatlencounter = (noiseBeatlencounter - 1) and 0xFF
        //> bne ExitMusicHandler      ;is it time for more data?
        if (noiseBeatlencounter == 0) {
            while (temp0 != 0) {
                //> lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
                temp0 = noiseDataLoopbackOfs
                //> sta MusicOffset_Noise       ;and loopback next time around
                musicoffsetNoise = temp0
                //> bne FetchNoiseBeatData      ;unconditional branch
            }
            //> NoiseBeatHandler:
            //> jsr AlternateLengthHandler
            alternateLengthHandler(temp0)
            //> sta Noise_BeatLenCounter    ;store length in noise beat counter
            noiseBeatlencounter = temp0
            //> txa
            //> and #%00111110              ;reload data and erase length bits
            temp13 = temp2 and 0x3E
            //> beq SilentBeat              ;if no beat data, silence
            temp0 = temp13
            if (temp13 != 0) {
                //> cmp #$30                    ;check the beat data and play the appropriate
                //> beq LongBeat                ;noise accordingly
                if (temp0 != 0x30) {
                    //> cmp #$20
                    //> beq StrongBeat
                    if (temp0 != 0x20) {
                        //> and #%00010000
                        temp14 = temp0 and 0x10
                        //> beq SilentBeat
                        temp0 = temp14
                        if (temp14 != 0) {
                            //> lda #$1c        ;short beat data
                            temp0 = 0x1C
                            //> ldx #$03
                            temp2 = 0x03
                            //> ldy #$18
                            temp3 = 0x18
                            //> bne PlayBeat
                            if (temp3 == 0) {
                            }
                        }
                    }
                    //> StrongBeat:
                    //> lda #$1c        ;strong beat data
                    temp0 = 0x1C
                    //> ldx #$0c
                    temp2 = 0x0C
                    //> ldy #$18
                    temp3 = 0x18
                    //> bne PlayBeat
                    if (temp3 == 0) {
                    }
                }
                //> LongBeat:
                //> lda #$1c        ;long beat data
                temp0 = 0x1C
                //> ldx #$03
                temp2 = 0x03
                //> ldy #$58
                temp3 = 0x58
                //> bne PlayBeat
                if (temp3 == 0) {
                }
            }
            //> SilentBeat:
            //> lda #$10        ;silence
            temp0 = 0x10
            //> PlayBeat:
            //> sta SND_NOISE_REG    ;load beat data into noise regs
            sndNoiseReg[0] = temp0
            //> stx SND_NOISE_REG+2
            sndNoiseReg[2] = temp2
            //> sty SND_NOISE_REG+3
            sndNoiseReg[3] = temp3
        }
    }
    //> ExitMusicHandler:
    //> rts
    return
}

// Decompiled from AlternateLengthHandler
fun alternateLengthHandler(A: Int): Int {
    var A: Int = A
    //> AlternateLengthHandler:
    //> tax            ;save a copy of original byte into X
    //> ror            ;save LSB from original byte into carry
    A = A shr 1 or if (flagC) 0x80 else 0
    //> txa            ;reload original byte and rotate three times
    //> rol            ;turning xx00000x into 00000xxx, with the
    A = (A shl 1) and 0xFE or if ((A and 0x01) != 0) 1 else 0
    //> rol            ;bit in carry as the MSB here
    A = (A shl 1) and 0xFE or if ((A and 0x80) != 0) 1 else 0
    //> rol
    A = (A shl 1) and 0xFE or if ((A and 0x80) != 0) 1 else 0
    // Fall-through tail call to processLengthData
    processLengthData(A)
    return A
}

// Decompiled from ProcessLengthData
fun processLengthData(A: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var noteLengthTblAdder by MemoryByte(NoteLengthTblAdder)
    val musicLengthLookupTbl by MemoryByteIndexed(MusicLengthLookupTbl)
    //> ProcessLengthData:
    //> and #%00000111              ;clear all but the three LSBs
    temp0 = A and 0x07
    //> clc
    //> adc $f0                     ;add offset loaded from first header byte
    temp1 = temp0 + memory[0xF0].toInt()
    //> adc NoteLengthTblAdder      ;add extra if time running out music
    temp2 = (temp1 and 0xFF) + noteLengthTblAdder + (if (temp1 > 0xFF) 1 else 0)
    //> tay
    //> lda MusicLengthLookupTbl,y  ;load length
    //> rts
    return A
}

// Decompiled from LoadControlRegs
fun loadControlRegs() {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    //> LoadControlRegs:
    //> lda EventMusicBuffer  ;check secondary buffer for win castle music
    //> and #EndOfCastleMusic
    temp0 = eventMusicBuffer and EndOfCastleMusic
    //> beq NotECstlM
    temp1 = temp0
    if (temp0 != 0) {
        //> lda #$04              ;this value is only used for win castle music
        temp1 = 0x04
        //> bne AllMus            ;unconditional branch
        if (temp1 == 0) {
        } else {
            //> AllMus:    ldx #$82              ;load contents of other sound regs for square 2
            //> ldy #$7f
            //> rts
            return
        }
    }
    //> NotECstlM: lda AreaMusicBuffer
    temp1 = areaMusicBuffer
    //> and #%01111101        ;check primary buffer for water music
    temp2 = temp1 and 0x7D
    //> beq WaterMus
    temp1 = temp2
    if (temp2 != 0) {
        //> lda #$08              ;this is the default value for all other music
        temp1 = 0x08
        //> bne AllMus
        if (temp1 == 0) {
        }
    }
    //> WaterMus:  lda #$28              ;this value is used for water music and all other event music
    temp1 = 0x28
}

// Decompiled from LoadEnvelopeData
fun loadEnvelopeData(Y: Int): Int {
    var temp0: Int = 0
    var temp1: Int = 0
    var temp2: Int = 0
    var areaMusicBuffer by MemoryByte(AreaMusicBuffer)
    var eventMusicBuffer by MemoryByte(EventMusicBuffer)
    val areaMusicEnvData by MemoryByteIndexed(AreaMusicEnvData)
    val endOfCastleMusicEnvData by MemoryByteIndexed(EndOfCastleMusicEnvData)
    val waterEventMusEnvData by MemoryByteIndexed(WaterEventMusEnvData)
    //> LoadEnvelopeData:
    //> lda EventMusicBuffer           ;check secondary buffer for win castle music
    //> and #EndOfCastleMusic
    temp0 = eventMusicBuffer and EndOfCastleMusic
    //> beq LoadUsualEnvData
    temp1 = temp0
    if (temp0 != 0) {
        //> lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
        temp1 = endOfCastleMusicEnvData[Y]
        //> rts
        return A
    } else {
        //> LoadUsualEnvData:
        //> lda AreaMusicBuffer            ;check primary buffer for water music
        temp1 = areaMusicBuffer
        //> and #%01111101
        temp2 = temp1 and 0x7D
        //> beq LoadWaterEventMusEnvData
        temp1 = temp2
        if (temp2 != 0) {
            //> lda AreaMusicEnvData,y         ;load default data from offset for all other music
            temp1 = areaMusicEnvData[Y]
            //> rts
            return A
        }
    }
    //> LoadWaterEventMusEnvData:
    //> lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
    temp1 = waterEventMusEnvData[Y]
    //> rts
    return A
}


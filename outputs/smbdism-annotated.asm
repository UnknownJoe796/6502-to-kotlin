                              ; SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY          ; fun():  B
                              ; by doppelganger (doppelheathen@gmail.com)                           ; 
                                                                                                    ; 
                              ; This file is provided for your own use as-is.  It will require the character rom data; 
                              ; and an iNES file header to get it to work.                          ; 
                                                                                                    ; 
                              ; There are so many people I have to thank for this, that taking all the credit for; 
                              ; myself would be an unforgivable act of arrogance. Without their help this would; 
                              ; probably not be possible.  So I thank all the peeps in the nesdev scene whose insight into; 
                              ; the 6502 and the NES helped me learn how it works (you guys know who you are, there's no; 
                              ; way I could have done this without your help), as well as the authors of x816 and SMB; 
                              ; Utility, and the reverse-engineers who did the original Super Mario Bros. Hacking Project,; 
                              ; which I compared notes with but did not copy from.  Last but certainly not least, I thank; 
                              ; Nintendo for creating this game and the NES, without which this disassembly would; 
                              ; only be theory.                                                     ; 
                                                                                                    ; 
                              ; Assembles with x816.                                                ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; DEFINES                                                             ; 
                                                                                                    ; 
                              ; NES specific hardware defines                                       ; 
                                                                                                    ; 
PPU_CTRL_REG1 = #$2000                                                                              ; 
PPU_CTRL_REG2 = #$2001                                                                              ; 
PPU_STATUS = #$2002                                                                                 ; 
PPU_SPR_ADDR = #$2003                                                                               ; 
PPU_SPR_DATA = #$2004                                                                               ; 
PPU_SCROLL_REG = #$2005                                                                             ; 
PPU_ADDRESS = #$2006                                                                                ; 
PPU_DATA = #$2007                                                                                   ; 
                                                                                                    ; 
SND_REGISTER = #$4000                                                                               ; 
SND_SQUARE1_REG = #$4000                                                                            ; 
SND_SQUARE2_REG = #$4004                                                                            ; 
SND_TRIANGLE_REG = #$4008                                                                           ; 
SND_NOISE_REG = #$400c                                                                              ; 
SND_DELTA_REG = #$4010                                                                              ; 
SND_MASTERCTRL_REG = #$4015                                                                         ; 
                                                                                                    ; 
SPR_DMA = #$4014                                                                                    ; 
JOYPAD_PORT = #$4016                                                                                ; 
JOYPAD_PORT1 = #$4016                                                                               ; 
JOYPAD_PORT2 = #$4017                                                                               ; 
                                                                                                    ; 
                              ; GAME SPECIFIC DEFINES                                               ; 
                                                                                                    ; 
ObjectOffset = #$08                                                                                 ; 
                                                                                                    ; 
FrameCounter = #$09                                                                                 ; 
                                                                                                    ; 
SavedJoypadBits = #$6fc                                                                             ; 
SavedJoypad1Bits = #$6fc                                                                            ; 
SavedJoypad2Bits = #$6fd                                                                            ; 
JoypadBitMask = #$74a                                                                               ; 
JoypadOverride = #$758                                                                              ; 
                                                                                                    ; 
A_B_Buttons = #$0a                                                                                  ; 
PreviousA_B_Buttons = #$0d                                                                          ; 
Up_Down_Buttons = #$0b                                                                              ; 
Left_Right_Buttons = #$0c                                                                           ; 
                                                                                                    ; 
GameEngineSubroutine = #$0e                                                                         ; 
                                                                                                    ; 
Mirror_PPU_CTRL_REG1 = #$778                                                                        ; 
Mirror_PPU_CTRL_REG2 = #$779                                                                        ; 
                                                                                                    ; 
OperMode = #$770                                                                                    ; 
OperMode_Task = #$772                                                                               ; 
ScreenRoutineTask = #$73c                                                                           ; 
                                                                                                    ; 
GamePauseStatus = #$776                                                                             ; 
GamePauseTimer = #$777                                                                              ; 
                                                                                                    ; 
DemoAction = #$717                                                                                  ; 
DemoActionTimer = #$718                                                                             ; 
                                                                                                    ; 
TimerControl = #$747                                                                                ; 
IntervalTimerControl = #$77f                                                                        ; 
                                                                                                    ; 
Timers = #$780                                                                                      ; 
SelectTimer = #$780                                                                                 ; 
PlayerAnimTimer = #$781                                                                             ; 
JumpSwimTimer = #$782                                                                               ; 
RunningTimer = #$783                                                                                ; 
BlockBounceTimer = #$784                                                                            ; 
SideCollisionTimer = #$785                                                                          ; 
JumpspringTimer = #$786                                                                             ; 
GameTimerCtrlTimer = #$787                                                                          ; 
ClimbSideTimer = #$789                                                                              ; 
EnemyFrameTimer = #$78a                                                                             ; 
FrenzyEnemyTimer = #$78f                                                                            ; 
BowserFireBreathTimer = #$790                                                                       ; 
StompTimer = #$791                                                                                  ; 
AirBubbleTimer = #$792                                                                              ; 
ScrollIntervalTimer = #$795                                                                         ; 
EnemyIntervalTimer = #$796                                                                          ; 
BrickCoinTimer = #$79d                                                                              ; 
InjuryTimer = #$79e                                                                                 ; 
StarInvincibleTimer = #$79f                                                                         ; 
ScreenTimer = #$7a0                                                                                 ; 
WorldEndTimer = #$7a1                                                                               ; 
DemoTimer = #$7a2                                                                                   ; 
                                                                                                    ; 
Sprite_Data = #$200                                                                                 ; 
                                                                                                    ; 
Sprite_Y_Position = #$200                                                                           ; 
Sprite_Tilenumber = #$201                                                                           ; 
Sprite_Attributes = #$202                                                                           ; 
Sprite_X_Position = #$203                                                                           ; 
                                                                                                    ; 
ScreenEdge_PageLoc = #$71a                                                                          ; 
ScreenEdge_X_Pos = #$71c                                                                            ; 
ScreenLeft_PageLoc = #$71a                                                                          ; 
ScreenRight_PageLoc = #$71b                                                                         ; 
ScreenLeft_X_Pos = #$71c                                                                            ; 
ScreenRight_X_Pos = #$71d                                                                           ; 
                                                                                                    ; 
PlayerFacingDir = #$33                                                                              ; 
DestinationPageLoc = #$34                                                                           ; 
VictoryWalkControl = #$35                                                                           ; 
ScrollFractional = #$768                                                                            ; 
PrimaryMsgCounter = #$719                                                                           ; 
SecondaryMsgCounter = #$749                                                                         ; 
                                                                                                    ; 
HorizontalScroll = #$73f                                                                            ; 
VerticalScroll = #$740                                                                              ; 
ScrollLock = #$723                                                                                  ; 
ScrollThirtyTwo = #$73d                                                                             ; 
Player_X_Scroll = #$6ff                                                                             ; 
Player_Pos_ForScroll = #$755                                                                        ; 
ScrollAmount = #$775                                                                                ; 
                                                                                                    ; 
AreaData = #$e7                                                                                     ; 
AreaDataLow = #$e7                                                                                  ; 
AreaDataHigh = #$e8                                                                                 ; 
EnemyData = #$e9                                                                                    ; 
EnemyDataLow = #$e9                                                                                 ; 
EnemyDataHigh = #$ea                                                                                ; 
                                                                                                    ; 
AreaParserTaskNum = #$71f                                                                           ; 
ColumnSets = #$71e                                                                                  ; 
CurrentPageLoc = #$725                                                                              ; 
CurrentColumnPos = #$726                                                                            ; 
BackloadingFlag = #$728                                                                             ; 
BehindAreaParserFlag = #$729                                                                        ; 
AreaObjectPageLoc = #$72a                                                                           ; 
AreaObjectPageSel = #$72b                                                                           ; 
AreaDataOffset = #$72c                                                                              ; 
AreaObjOffsetBuffer = #$72d                                                                         ; 
AreaObjectLength = #$730                                                                            ; 
StaircaseControl = #$734                                                                            ; 
AreaObjectHeight = #$735                                                                            ; 
MushroomLedgeHalfLen = #$736                                                                        ; 
EnemyDataOffset = #$739                                                                             ; 
EnemyObjectPageLoc = #$73a                                                                          ; 
EnemyObjectPageSel = #$73b                                                                          ; 
MetatileBuffer = #$6a1                                                                              ; 
BlockBufferColumnPos = #$6a0                                                                        ; 
CurrentNTAddr_Low = #$721                                                                           ; 
CurrentNTAddr_High = #$720                                                                          ; 
AttributeBuffer = #$3f9                                                                             ; 
                                                                                                    ; 
LoopCommand = #$745                                                                                 ; 
                                                                                                    ; 
DisplayDigits = #$7d7                                                                               ; 
TopScoreDisplay = #$7d7                                                                             ; 
ScoreAndCoinDisplay = #$7dd                                                                         ; 
PlayerScoreDisplay = #$7dd                                                                          ; 
GameTimerDisplay = #$7f8                                                                            ; 
DigitModifier = #$134                                                                               ; 
                                                                                                    ; 
VerticalFlipFlag = #$109                                                                            ; 
FloateyNum_Control = #$110                                                                          ; 
ShellChainCounter = #$125                                                                           ; 
FloateyNum_Timer = #$12c                                                                            ; 
FloateyNum_X_Pos = #$117                                                                            ; 
FloateyNum_Y_Pos = #$11e                                                                            ; 
FlagpoleFNum_Y_Pos = #$10d                                                                          ; 
FlagpoleFNum_YMFDummy = #$10e                                                                       ; 
FlagpoleScore = #$10f                                                                               ; 
FlagpoleCollisionYPos = #$70f                                                                       ; 
StompChainCounter = #$484                                                                           ; 
                                                                                                    ; 
VRAM_Buffer1_Offset = #$300                                                                         ; 
VRAM_Buffer1 = #$301                                                                                ; 
VRAM_Buffer2_Offset = #$340                                                                         ; 
VRAM_Buffer2 = #$341                                                                                ; 
VRAM_Buffer_AddrCtrl = #$773                                                                        ; 
Sprite0HitDetectFlag = #$722                                                                        ; 
DisableScreenFlag = #$774                                                                           ; 
DisableIntermediate = #$769                                                                         ; 
ColorRotateOffset = #$6d4                                                                           ; 
                                                                                                    ; 
TerrainControl = #$727                                                                              ; 
AreaStyle = #$733                                                                                   ; 
ForegroundScenery = #$741                                                                           ; 
BackgroundScenery = #$742                                                                           ; 
CloudTypeOverride = #$743                                                                           ; 
BackgroundColorCtrl = #$744                                                                         ; 
AreaType = #$74e                                                                                    ; 
AreaAddrsLOffset = #$74f                                                                            ; 
AreaPointer = #$750                                                                                 ; 
                                                                                                    ; 
PlayerEntranceCtrl = #$710                                                                          ; 
GameTimerSetting = #$715                                                                            ; 
AltEntranceControl = #$752                                                                          ; 
EntrancePage = #$751                                                                                ; 
NumberOfPlayers = #$77a                                                                             ; 
WarpZoneControl = #$6d6                                                                             ; 
ChangeAreaTimer = #$6de                                                                             ; 
                                                                                                    ; 
MultiLoopCorrectCntr = #$6d9                                                                        ; 
MultiLoopPassCntr = #$6da                                                                           ; 
                                                                                                    ; 
FetchNewGameTimerFlag = #$757                                                                       ; 
GameTimerExpiredFlag = #$759                                                                        ; 
                                                                                                    ; 
PrimaryHardMode = #$76a                                                                             ; 
SecondaryHardMode = #$6cc                                                                           ; 
WorldSelectNumber = #$76b                                                                           ; 
WorldSelectEnableFlag = #$7fc                                                                       ; 
ContinueWorld = #$7fd                                                                               ; 
                                                                                                    ; 
CurrentPlayer = #$753                                                                               ; 
PlayerSize = #$754                                                                                  ; 
PlayerStatus = #$756                                                                                ; 
                                                                                                    ; 
OnscreenPlayerInfo = #$75a                                                                          ; 
NumberofLives = #$75a         ; used by current player                                              ; 
HalfwayPage = #$75b                                                                                 ; 
LevelNumber = #$75c           ; the actual dash number                                              ; 
Hidden1UpFlag = #$75d                                                                               ; 
CoinTally = #$75e                                                                                   ; 
WorldNumber = #$75f                                                                                 ; 
AreaNumber = #$760            ; internal number used to find areas                                  ; 
                                                                                                    ; 
CoinTallyFor1Ups = #$748                                                                            ; 
                                                                                                    ; 
OffscreenPlayerInfo = #$761                                                                         ; 
OffScr_NumberofLives = #$761  ; used by offscreen player                                            ; 
OffScr_HalfwayPage = #$762                                                                          ; 
OffScr_LevelNumber = #$763                                                                          ; 
OffScr_Hidden1UpFlag = #$764                                                                        ; 
OffScr_CoinTally = #$765                                                                            ; 
OffScr_WorldNumber = #$766                                                                          ; 
OffScr_AreaNumber = #$767                                                                           ; 
                                                                                                    ; 
BalPlatformAlignment = #$3a0                                                                        ; 
Platform_X_Scroll = #$3a1                                                                           ; 
PlatformCollisionFlag = #$3a2                                                                       ; 
YPlatformTopYPos = #$401                                                                            ; 
YPlatformCenterYPos = #$58                                                                          ; 
                                                                                                    ; 
BrickCoinTimerFlag = #$6bc                                                                          ; 
StarFlagTaskControl = #$746                                                                         ; 
                                                                                                    ; 
PseudoRandomBitReg = #$7a7                                                                          ; 
WarmBootValidation = #$7ff                                                                          ; 
                                                                                                    ; 
SprShuffleAmtOffset = #$6e0                                                                         ; 
SprShuffleAmt = #$6e1                                                                               ; 
SprDataOffset = #$6e4                                                                               ; 
Player_SprDataOffset = #$6e4                                                                        ; 
Enemy_SprDataOffset = #$6e5                                                                         ; 
Block_SprDataOffset = #$6ec                                                                         ; 
Alt_SprDataOffset = #$6ec                                                                           ; 
Bubble_SprDataOffset = #$6ee                                                                        ; 
FBall_SprDataOffset = #$6f1                                                                         ; 
Misc_SprDataOffset = #$6f3                                                                          ; 
SprDataOffset_Ctrl = #$3ee                                                                          ; 
                                                                                                    ; 
Player_State = #$1d                                                                                 ; 
Enemy_State = #$1e                                                                                  ; 
Fireball_State = #$24                                                                               ; 
Block_State = #$26                                                                                  ; 
Misc_State = #$2a                                                                                   ; 
                                                                                                    ; 
Player_MovingDir = #$45                                                                             ; 
Enemy_MovingDir = #$46                                                                              ; 
                                                                                                    ; 
SprObject_X_Speed = #$57                                                                            ; 
Player_X_Speed = #$57                                                                               ; 
Enemy_X_Speed = #$58                                                                                ; 
Fireball_X_Speed = #$5e                                                                             ; 
Block_X_Speed = #$60                                                                                ; 
Misc_X_Speed = #$64                                                                                 ; 
                                                                                                    ; 
Jumpspring_FixedYPos = #$58                                                                         ; 
JumpspringAnimCtrl = #$70e                                                                          ; 
JumpspringForce = #$6db                                                                             ; 
                                                                                                    ; 
SprObject_PageLoc = #$6d                                                                            ; 
Player_PageLoc = #$6d                                                                               ; 
Enemy_PageLoc = #$6e                                                                                ; 
Fireball_PageLoc = #$74                                                                             ; 
Block_PageLoc = #$76                                                                                ; 
Misc_PageLoc = #$7a                                                                                 ; 
Bubble_PageLoc = #$83                                                                               ; 
                                                                                                    ; 
SprObject_X_Position = #$86                                                                         ; 
Player_X_Position = #$86                                                                            ; 
Enemy_X_Position = #$87                                                                             ; 
Fireball_X_Position = #$8d                                                                          ; 
Block_X_Position = #$8f                                                                             ; 
Misc_X_Position = #$93                                                                              ; 
Bubble_X_Position = #$9c                                                                            ; 
                                                                                                    ; 
SprObject_Y_Speed = #$9f                                                                            ; 
Player_Y_Speed = #$9f                                                                               ; 
Enemy_Y_Speed = #$a0                                                                                ; 
Fireball_Y_Speed = #$a6                                                                             ; 
Block_Y_Speed = #$a8                                                                                ; 
Misc_Y_Speed = #$ac                                                                                 ; 
                                                                                                    ; 
SprObject_Y_HighPos = #$b5                                                                          ; 
Player_Y_HighPos = #$b5                                                                             ; 
Enemy_Y_HighPos = #$b6                                                                              ; 
Fireball_Y_HighPos = #$bc                                                                           ; 
Block_Y_HighPos = #$be                                                                              ; 
Misc_Y_HighPos = #$c2                                                                               ; 
Bubble_Y_HighPos = #$cb                                                                             ; 
                                                                                                    ; 
SprObject_Y_Position = #$ce                                                                         ; 
Player_Y_Position = #$ce                                                                            ; 
Enemy_Y_Position = #$cf                                                                             ; 
Fireball_Y_Position = #$d5                                                                          ; 
Block_Y_Position = #$d7                                                                             ; 
Misc_Y_Position = #$db                                                                              ; 
Bubble_Y_Position = #$e4                                                                            ; 
                                                                                                    ; 
SprObject_Rel_XPos = #$3ad                                                                          ; 
Player_Rel_XPos = #$3ad                                                                             ; 
Enemy_Rel_XPos = #$3ae                                                                              ; 
Fireball_Rel_XPos = #$3af                                                                           ; 
Bubble_Rel_XPos = #$3b0                                                                             ; 
Block_Rel_XPos = #$3b1                                                                              ; 
Misc_Rel_XPos = #$3b3                                                                               ; 
                                                                                                    ; 
SprObject_Rel_YPos = #$3b8                                                                          ; 
Player_Rel_YPos = #$3b8                                                                             ; 
Enemy_Rel_YPos = #$3b9                                                                              ; 
Fireball_Rel_YPos = #$3ba                                                                           ; 
Bubble_Rel_YPos = #$3bb                                                                             ; 
Block_Rel_YPos = #$3bc                                                                              ; 
Misc_Rel_YPos = #$3be                                                                               ; 
                                                                                                    ; 
SprObject_SprAttrib = #$3c4                                                                         ; 
Player_SprAttrib = #$3c4                                                                            ; 
Enemy_SprAttrib = #$3c5                                                                             ; 
                                                                                                    ; 
SprObject_X_MoveForce = #$400                                                                       ; 
Enemy_X_MoveForce = #$401                                                                           ; 
                                                                                                    ; 
SprObject_YMF_Dummy = #$416                                                                         ; 
Player_YMF_Dummy = #$416                                                                            ; 
Enemy_YMF_Dummy = #$417                                                                             ; 
Bubble_YMF_Dummy = #$42c                                                                            ; 
                                                                                                    ; 
SprObject_Y_MoveForce = #$433                                                                       ; 
Player_Y_MoveForce = #$433                                                                          ; 
Enemy_Y_MoveForce = #$434                                                                           ; 
Block_Y_MoveForce = #$43c                                                                           ; 
                                                                                                    ; 
DisableCollisionDet = #$716                                                                         ; 
Player_CollisionBits = #$490                                                                        ; 
Enemy_CollisionBits = #$491                                                                         ; 
                                                                                                    ; 
SprObj_BoundBoxCtrl = #$499                                                                         ; 
Player_BoundBoxCtrl = #$499                                                                         ; 
Enemy_BoundBoxCtrl = #$49a                                                                          ; 
Fireball_BoundBoxCtrl = #$4a0                                                                       ; 
Misc_BoundBoxCtrl = #$4a2                                                                           ; 
                                                                                                    ; 
EnemyFrenzyBuffer = #$6cb                                                                           ; 
EnemyFrenzyQueue = #$6cd                                                                            ; 
Enemy_Flag = #$0f                                                                                   ; 
Enemy_ID = #$16                                                                                     ; 
                                                                                                    ; 
PlayerGfxOffset = #$6d5                                                                             ; 
Player_XSpeedAbsolute = #$700                                                                       ; 
FrictionAdderHigh = #$701                                                                           ; 
FrictionAdderLow = #$702                                                                            ; 
RunningSpeed = #$703                                                                                ; 
SwimmingFlag = #$704                                                                                ; 
Player_X_MoveForce = #$705                                                                          ; 
DiffToHaltJump = #$706                                                                              ; 
JumpOrigin_Y_HighPos = #$707                                                                        ; 
JumpOrigin_Y_Position = #$708                                                                       ; 
VerticalForce = #$709                                                                               ; 
VerticalForceDown = #$70a                                                                           ; 
PlayerChangeSizeFlag = #$70b                                                                        ; 
PlayerAnimTimerSet = #$70c                                                                          ; 
PlayerAnimCtrl = #$70d                                                                              ; 
DeathMusicLoaded = #$712                                                                            ; 
FlagpoleSoundQueue = #$713                                                                          ; 
CrouchingFlag = #$714                                                                               ; 
MaximumLeftSpeed = #$450                                                                            ; 
MaximumRightSpeed = #$456                                                                           ; 
                                                                                                    ; 
SprObject_OffscrBits = #$3d0                                                                        ; 
Player_OffscreenBits = #$3d0                                                                        ; 
Enemy_OffscreenBits = #$3d1                                                                         ; 
FBall_OffscreenBits = #$3d2                                                                         ; 
Bubble_OffscreenBits = #$3d3                                                                        ; 
Block_OffscreenBits = #$3d4                                                                         ; 
Misc_OffscreenBits = #$3d6                                                                          ; 
EnemyOffscrBitsMasked = #$3d8                                                                       ; 
                                                                                                    ; 
Cannon_Offset = #$46a                                                                               ; 
Cannon_PageLoc = #$46b                                                                              ; 
Cannon_X_Position = #$471                                                                           ; 
Cannon_Y_Position = #$477                                                                           ; 
Cannon_Timer = #$47d                                                                                ; 
                                                                                                    ; 
Whirlpool_Offset = #$46a                                                                            ; 
Whirlpool_PageLoc = #$46b                                                                           ; 
Whirlpool_LeftExtent = #$471                                                                        ; 
Whirlpool_Length = #$477                                                                            ; 
Whirlpool_Flag = #$47d                                                                              ; 
                                                                                                    ; 
VineFlagOffset = #$398                                                                              ; 
VineHeight = #$399                                                                                  ; 
VineObjOffset = #$39a                                                                               ; 
VineStart_Y_Position = #$39d                                                                        ; 
                                                                                                    ; 
Block_Orig_YPos = #$3e4                                                                             ; 
Block_BBuf_Low = #$3e6                                                                              ; 
Block_Metatile = #$3e8                                                                              ; 
Block_PageLoc2 = #$3ea                                                                              ; 
Block_RepFlag = #$3ec                                                                               ; 
Block_ResidualCounter = #$3f0                                                                       ; 
Block_Orig_XPos = #$3f1                                                                             ; 
                                                                                                    ; 
BoundingBox_UL_XPos = #$4ac                                                                         ; 
BoundingBox_UL_YPos = #$4ad                                                                         ; 
BoundingBox_DR_XPos = #$4ae                                                                         ; 
BoundingBox_DR_YPos = #$4af                                                                         ; 
BoundingBox_UL_Corner = #$4ac                                                                       ; 
BoundingBox_LR_Corner = #$4ae                                                                       ; 
EnemyBoundingBoxCoord = #$4b0                                                                       ; 
                                                                                                    ; 
PowerUpType = #$39                                                                                  ; 
                                                                                                    ; 
FireballBouncingFlag = #$3a                                                                         ; 
FireballCounter = #$6ce                                                                             ; 
FireballThrowingTimer = #$711                                                                       ; 
                                                                                                    ; 
HammerEnemyOffset = #$6ae                                                                           ; 
JumpCoinMiscOffset = #$6b7                                                                          ; 
                                                                                                    ; 
Block_Buffer_1 = #$500                                                                              ; 
Block_Buffer_2 = #$5d0                                                                              ; 
                                                                                                    ; 
HammerThrowingTimer = #$3a2                                                                         ; 
HammerBroJumpTimer = #$3c                                                                           ; 
Misc_Collision_Flag = #$6be                                                                         ; 
                                                                                                    ; 
RedPTroopaOrigXPos = #$401                                                                          ; 
RedPTroopaCenterYPos = #$58                                                                         ; 
                                                                                                    ; 
XMovePrimaryCounter = #$a0                                                                          ; 
XMoveSecondaryCounter = #$58                                                                        ; 
                                                                                                    ; 
CheepCheepMoveMFlag = #$58                                                                          ; 
CheepCheepOrigYPos = #$434                                                                          ; 
BitMFilter = #$6dd                                                                                  ; 
                                                                                                    ; 
LakituReappearTimer = #$6d1                                                                         ; 
LakituMoveSpeed = #$58                                                                              ; 
LakituMoveDirection = #$a0                                                                          ; 
                                                                                                    ; 
FirebarSpinState_Low = #$58                                                                         ; 
FirebarSpinState_High = #$a0                                                                        ; 
FirebarSpinSpeed = #$388                                                                            ; 
FirebarSpinDirection = #$34                                                                         ; 
                                                                                                    ; 
DuplicateObj_Offset = #$6cf                                                                         ; 
NumberofGroupEnemies = #$6d3                                                                        ; 
                                                                                                    ; 
BlooperMoveCounter = #$a0                                                                           ; 
BlooperMoveSpeed = #$58                                                                             ; 
                                                                                                    ; 
BowserBodyControls = #$363                                                                          ; 
BowserFeetCounter = #$364                                                                           ; 
BowserMovementSpeed = #$365                                                                         ; 
BowserOrigXPos = #$366                                                                              ; 
BowserFlameTimerCtrl = #$367                                                                        ; 
BowserFront_Offset = #$368                                                                          ; 
BridgeCollapseOffset = #$369                                                                        ; 
BowserGfxFlag = #$36a                                                                               ; 
BowserHitPoints = #$483                                                                             ; 
MaxRangeFromOrigin = #$6dc                                                                          ; 
                                                                                                    ; 
BowserFlamePRandomOfs = #$417                                                                       ; 
                                                                                                    ; 
PiranhaPlantUpYPos = #$417                                                                          ; 
PiranhaPlantDownYPos = #$434                                                                        ; 
PiranhaPlant_Y_Speed = #$58                                                                         ; 
PiranhaPlant_MoveFlag = #$a0                                                                        ; 
                                                                                                    ; 
FireworksCounter = #$6d7                                                                            ; 
ExplosionGfxCounter = #$58                                                                          ; 
ExplosionTimerCounter = #$a0                                                                        ; 
                                                                                                    ; 
                              ; sound related defines                                               ; 
Squ2_NoteLenBuffer = #$7b3                                                                          ; 
Squ2_NoteLenCounter = #$7b4                                                                         ; 
Squ2_EnvelopeDataCtrl = #$7b5                                                                       ; 
Squ1_NoteLenCounter = #$7b6                                                                         ; 
Squ1_EnvelopeDataCtrl = #$7b7                                                                       ; 
Tri_NoteLenBuffer = #$7b8                                                                           ; 
Tri_NoteLenCounter = #$7b9                                                                          ; 
Noise_BeatLenCounter = #$7ba                                                                        ; 
Squ1_SfxLenCounter = #$7bb                                                                          ; 
Squ2_SfxLenCounter = #$7bd                                                                          ; 
Sfx_SecondaryCounter = #$7be                                                                        ; 
Noise_SfxLenCounter = #$7bf                                                                         ; 
                                                                                                    ; 
PauseSoundQueue = #$fa                                                                              ; 
Square1SoundQueue = #$ff                                                                            ; 
Square2SoundQueue = #$fe                                                                            ; 
NoiseSoundQueue = #$fd                                                                              ; 
AreaMusicQueue = #$fb                                                                               ; 
EventMusicQueue = #$fc                                                                              ; 
                                                                                                    ; 
Square1SoundBuffer = #$f1                                                                           ; 
Square2SoundBuffer = #$f2                                                                           ; 
NoiseSoundBuffer = #$f3                                                                             ; 
AreaMusicBuffer = #$f4                                                                              ; 
EventMusicBuffer = #$7b1                                                                            ; 
PauseSoundBuffer = #$7b2                                                                            ; 
                                                                                                    ; 
MusicData = #$f5                                                                                    ; 
MusicDataLow = #$f5                                                                                 ; 
MusicDataHigh = #$f6                                                                                ; 
MusicOffset_Square2 = #$f7                                                                          ; 
MusicOffset_Square1 = #$f8                                                                          ; 
MusicOffset_Triangle = #$f9                                                                         ; 
MusicOffset_Noise = #$7b0                                                                           ; 
                                                                                                    ; 
NoteLenLookupTblOfs = #$f0                                                                          ; 
DAC_Counter = #$7c0                                                                                 ; 
NoiseDataLoopbackOfs = #$7c1                                                                        ; 
NoteLengthTblAdder = #$7c4                                                                          ; 
AreaMusicBuffer_Alt = #$7c5                                                                         ; 
PauseModeFlag = #$7c6                                                                               ; 
GroundMusicHeaderOfs = #$7c7                                                                        ; 
AltRegContentFlag = #$7ca                                                                           ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; CONSTANTS                                                           ; 
                                                                                                    ; 
                              ; sound effects constants                                             ; 
Sfx_SmallJump = #%10000000                                                                          ; 
Sfx_Flagpole = #%01000000                                                                           ; 
Sfx_Fireball = #%00100000                                                                           ; 
Sfx_PipeDown_Injury = #%00010000                                                                    ; 
Sfx_EnemySmack = #%00001000                                                                         ; 
Sfx_EnemyStomp = #%00000100                                                                         ; 
Sfx_Bump = #%00000010                                                                               ; 
Sfx_BigJump = #%00000001                                                                            ; 
                                                                                                    ; 
Sfx_BowserFall = #%10000000                                                                         ; 
Sfx_ExtraLife = #%01000000                                                                          ; 
Sfx_PowerUpGrab = #%00100000                                                                        ; 
Sfx_TimerTick = #%00010000                                                                          ; 
Sfx_Blast = #%00001000                                                                              ; 
Sfx_GrowVine = #%00000100                                                                           ; 
Sfx_GrowPowerUp = #%00000010                                                                        ; 
Sfx_CoinGrab = #%00000001                                                                           ; 
                                                                                                    ; 
Sfx_BowserFlame = #%00000010                                                                        ; 
Sfx_BrickShatter = #%00000001                                                                       ; 
                                                                                                    ; 
                              ; music constants                                                     ; 
Silence = #%10000000                                                                                ; 
                                                                                                    ; 
StarPowerMusic = #%01000000                                                                         ; 
PipeIntroMusic = #%00100000                                                                         ; 
CloudMusic = #%00010000                                                                             ; 
CastleMusic = #%00001000                                                                            ; 
UndergroundMusic = #%00000100                                                                       ; 
WaterMusic = #%00000010                                                                             ; 
GroundMusic = #%00000001                                                                            ; 
                                                                                                    ; 
TimeRunningOutMusic = #%01000000                                                                    ; 
EndOfLevelMusic = #%00100000                                                                        ; 
AltGameOverMusic = #%00010000                                                                       ; 
EndOfCastleMusic = #%00001000                                                                       ; 
VictoryMusic = #%00000100                                                                           ; 
GameOverMusic = #%00000010                                                                          ; 
DeathMusic = #%00000001                                                                             ; 
                                                                                                    ; 
                              ; enemy object constants                                              ; 
GreenKoopa = #$00                                                                                   ; 
BuzzyBeetle = #$02                                                                                  ; 
RedKoopa = #$03                                                                                     ; 
HammerBro = #$05                                                                                    ; 
Goomba = #$06                                                                                       ; 
Bloober = #$07                                                                                      ; 
BulletBill_FrenzyVar = #$08                                                                         ; 
GreyCheepCheep = #$0a                                                                               ; 
RedCheepCheep = #$0b                                                                                ; 
Podoboo = #$0c                                                                                      ; 
PiranhaPlant = #$0d                                                                                 ; 
GreenParatroopaJump = #$0e                                                                          ; 
RedParatroopa = #$0f                                                                                ; 
GreenParatroopaFly = #$10                                                                           ; 
Lakitu = #$11                                                                                       ; 
Spiny = #$12                                                                                        ; 
FlyCheepCheepFrenzy = #$14                                                                          ; 
FlyingCheepCheep = #$14                                                                             ; 
BowserFlame = #$15                                                                                  ; 
Fireworks = #$16                                                                                    ; 
BBill_CCheep_Frenzy = #$17                                                                          ; 
Stop_Frenzy = #$18                                                                                  ; 
Bowser = #$2d                                                                                       ; 
PowerUpObject = #$2e                                                                                ; 
VineObject = #$2f                                                                                   ; 
FlagpoleFlagObject = #$30                                                                           ; 
StarFlagObject = #$31                                                                               ; 
JumpspringObject = #$32                                                                             ; 
BulletBill_CannonVar = #$33                                                                         ; 
RetainerObject = #$35                                                                               ; 
TallEnemy = #$09                                                                                    ; 
                                                                                                    ; 
                              ; other constants                                                     ; 
World1 = #0                                                                                         ; 
World2 = #1                                                                                         ; 
World3 = #2                                                                                         ; 
World4 = #3                                                                                         ; 
World5 = #4                                                                                         ; 
World6 = #5                                                                                         ; 
World7 = #6                                                                                         ; 
World8 = #7                                                                                         ; 
Level1 = #0                                                                                         ; 
Level2 = #1                                                                                         ; 
Level3 = #2                                                                                         ; 
Level4 = #3                                                                                         ; 
                                                                                                    ; 
WarmBootOffset = #<$7d6                                                                             ; 
ColdBootOffset = #<$7fe                                                                             ; 
TitleScreenDataOffset = #$1ec0                                                                      ; 
SoundMemory = #$7b0                                                                                 ; 
SwimTileRepOffset = #PlayerGraphicsTable + $9e                                                      ; 
MusicHeaderOffsetData = #MusicHeaderData - 1                                                        ; 
MHD = #MusicHeaderData                                                                              ; 
                                                                                                    ; 
A_Button = #%10000000                                                                               ; 
B_Button = #%01000000                                                                               ; 
Select_Button = #%00100000                                                                          ; 
Start_Button = #%00010000                                                                           ; 
Up_Dir = #%00001000                                                                                 ; 
Down_Dir = #%00000100                                                                               ; 
Left_Dir = #%00000010                                                                               ; 
Right_Dir = #%00000001                                                                              ; 
                                                                                                    ; 
TitleScreenModeValue = #0                                                                           ; 
GameModeValue = #1                                                                                  ; 
VictoryModeValue = #2                                                                               ; 
GameOverModeValue = #3                                                                              ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; DIRECTIVES                                                          ; 
                                                                                                    ; 
                                                                                                    ; 
                                                                                                    ; 
                                                                                                    ; 
                                                                                                    ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
Start:                                                                                              ;  B
SEI                           ; pretty standard 6502 type init here                                 ; 
CLD                                                                                                 ; 
LDA #%00010000                ; init PPU control register 1                                         ; 
STA PPU_CTRL_REG1                                                                                   ; 
LDX #$ff                      ; reset stack pointer                                                 ; 
TXS                                                                                                 ; 
VBlank1:  LDA PPU_STATUS      ; wait two frames                                                     ;  B
BPL VBlank1                                                                                         ; 
VBlank2:  LDA PPU_STATUS                                                                            ;  B
BPL VBlank2                                                                                         ; 
LDY #ColdBootOffset           ; load default cold boot pointer                                      ;  B
LDX #$05                      ; this is where we check for a warm boot                              ; 
WBootCheck:  LDA TopScoreDisplay,X; check each score digit in the top score                         ;  B
CMP #10                       ; to see if we have a valid digit                                     ; 
BCS ColdBoot                  ; if not, give up and proceed with cold boot                          ; 
DEX                                                                                                 ;  B
BPL WBootCheck                                                                                      ; 
LDA WarmBootValidation        ; second checkpoint, check to see if                                  ;  B
CMP #$a5                      ; another location has a specific value                               ; 
BNE ColdBoot                                                                                        ; 
LDY #WarmBootOffset           ; if passed both, load warm boot pointer                              ;  B
ColdBoot:  JSR InitializeMemory; clear memory using pointer in Y                                    ;  B
STA SND_DELTA_REG+1           ; reset delta counter load register                                   ; 
STA OperMode                  ; reset primary mode of operation                                     ; 
LDA #$a5                      ; set warm boot flag                                                  ; 
STA WarmBootValidation                                                                              ; 
STA PseudoRandomBitReg        ; set seed for pseudorandom register                                  ; 
LDA #%00001111                                                                                      ; 
STA SND_MASTERCTRL_REG        ; enable all sound channels except dmc                                ; 
LDA #%00000110                                                                                      ; 
STA PPU_CTRL_REG2             ; turn off clipping for OAM and background                            ; 
JSR MoveAllSpritesOffscreen                                                                         ; 
JSR InitializeNameTables      ; initialize both name tables                                         ; 
INC DisableScreenFlag         ; set flag to disable screen output                                   ; 
LDA Mirror_PPU_CTRL_REG1                                                                            ; 
ORA #%10000000                ; enable NMIs                                                         ; 
JSR WritePPUReg1                                                                                    ; 
EndlessLoop:  JMP EndlessLoop ; endless loop, need I say more?                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - vram buffer address table low, also used for pseudorandom bit ; 
                              ; $01 - vram buffer address table high                                ; 
                                                                                                    ; 
VRAM_AddrTable_Low:                                                                                 ;  B
DATA: Expr(expr=<VRAM_Buffer1), Expr(expr=<WaterPaletteData), Expr(expr=<GroundPaletteData)         ; 
DATA: Expr(expr=<UndergroundPaletteData), Expr(expr=<CastlePaletteData), Expr(expr=<VRAM_Buffer1_Offset); 
DATA: Expr(expr=<VRAM_Buffer2), Expr(expr=<VRAM_Buffer2), Expr(expr=<BowserPaletteData)             ; 
DATA: Expr(expr=<DaySnowPaletteData), Expr(expr=<NightSnowPaletteData), Expr(expr=<MushroomPaletteData); 
DATA: Expr(expr=<MarioThanksMessage), Expr(expr=<LuigiThanksMessage), Expr(expr=<MushroomRetainerSaved); 
DATA: Expr(expr=<PrincessSaved1), Expr(expr=<PrincessSaved2), Expr(expr=<WorldSelectMessage1)       ; 
DATA: Expr(expr=<WorldSelectMessage2)                                                               ; 
                                                                                                    ; 
VRAM_AddrTable_High:                                                                                ;  B
DATA: Expr(expr=>VRAM_Buffer1), Expr(expr=>WaterPaletteData), Expr(expr=>GroundPaletteData)         ; 
DATA: Expr(expr=>UndergroundPaletteData), Expr(expr=>CastlePaletteData), Expr(expr=>VRAM_Buffer1_Offset); 
DATA: Expr(expr=>VRAM_Buffer2), Expr(expr=>VRAM_Buffer2), Expr(expr=>BowserPaletteData)             ; 
DATA: Expr(expr=>DaySnowPaletteData), Expr(expr=>NightSnowPaletteData), Expr(expr=>MushroomPaletteData); 
DATA: Expr(expr=>MarioThanksMessage), Expr(expr=>LuigiThanksMessage), Expr(expr=>MushroomRetainerSaved); 
DATA: Expr(expr=>PrincessSaved1), Expr(expr=>PrincessSaved2), Expr(expr=>WorldSelectMessage1)       ; 
DATA: Expr(expr=>WorldSelectMessage2)                                                               ; 
                                                                                                    ; 
VRAM_Buffer_Offset:                                                                                 ;  B
DATA: Expr(expr=<VRAM_Buffer1_Offset), Expr(expr=<VRAM_Buffer2_Offset)                              ; 
                                                                                                    ; 
NonMaskableInterrupt:                                                                               ;  B
LDA Mirror_PPU_CTRL_REG1      ; disable NMIs in mirror reg                                          ; 
AND #%01111111                ; save all other bits                                                 ; 
STA Mirror_PPU_CTRL_REG1                                                                            ; 
AND #%01111110                ; alter name table address to be $2800                                ; 
STA PPU_CTRL_REG1             ; (essentially $2000) but save other bits                             ; 
LDA Mirror_PPU_CTRL_REG2      ; disable OAM and background display by default                       ; 
AND #%11100110                                                                                      ; 
LDY DisableScreenFlag         ; get screen disable flag                                             ; 
BNE ScreenOff                 ; if set, used bits as-is                                             ; 
LDA Mirror_PPU_CTRL_REG2      ; otherwise reenable bits and save them                               ;  B
ORA #%00011110                                                                                      ; 
ScreenOff:  STA Mirror_PPU_CTRL_REG2; save bits for later but not in register at the moment         ;  B
AND #%11100111                ; disable screen for now                                              ; 
STA PPU_CTRL_REG2                                                                                   ; 
LDX PPU_STATUS                ; reset flip-flop and reset scroll registers to zero                  ; 
LDA #$00                                                                                            ; 
JSR InitScroll                                                                                      ; 
STA PPU_SPR_ADDR              ; reset spr-ram address register                                      ; 
LDA #$02                      ; perform spr-ram DMA access on $0200-$02ff                           ; 
STA SPR_DMA                                                                                         ; 
LDX VRAM_Buffer_AddrCtrl      ; load control for pointer to buffer contents                         ; 
LDA VRAM_AddrTable_Low,X      ; set indirect at $00 to pointer                                      ; 
STA $00                                                                                             ; 
LDA VRAM_AddrTable_High,X                                                                           ; 
STA $01                                                                                             ; 
JSR UpdateScreen              ; update screen with buffer contents                                  ; 
LDY #$00                                                                                            ; 
LDX VRAM_Buffer_AddrCtrl      ; check for usage of $0341                                            ; 
CPX #$06                                                                                            ; 
BNE InitBuffer                                                                                      ; 
INY                           ; get offset based on usage                                           ;  B
InitBuffer:  LDX VRAM_Buffer_Offset,Y                                                               ;  B
LDA #$00                      ; clear buffer header at last location                                ; 
STA VRAM_Buffer1_Offset,X                                                                           ; 
STA VRAM_Buffer1,X                                                                                  ; 
STA VRAM_Buffer_AddrCtrl      ; reinit address control to $0301                                     ; 
LDA Mirror_PPU_CTRL_REG2      ; copy mirror of $2001 to register                                    ; 
STA PPU_CTRL_REG2                                                                                   ; 
JSR SoundEngine               ; play sound                                                          ; 
JSR ReadJoypads               ; read joypads                                                        ; 
JSR PauseRoutine              ; handle pause                                                        ; 
JSR UpdateTopScore                                                                                  ; 
LDA GamePauseStatus           ; check for pause status                                              ; 
LSR                                                                                                 ; 
BCS PauseSkip                                                                                       ; 
LDA TimerControl              ; if master timer control not set, decrement                          ;  B
BEQ DecTimers                 ; all frame and interval timers                                       ; 
DEC TimerControl                                                                                    ;  B
BNE NoDecTimers                                                                                     ; 
DecTimers:  LDX #$14          ; load end offset for end of frame timers                             ;  B
DEC IntervalTimerControl      ; decrement interval timer control,                                   ; 
BPL DecTimersLoop             ; if not expired, only frame timers will decrement                    ; 
LDA #$14                                                                                            ;  B
STA IntervalTimerControl      ; if control for interval timers expired,                             ; 
LDX #$23                      ; interval timers will decrement along with frame timers              ; 
DecTimersLoop:  LDA Timers,X  ; check current timer                                                 ;  B
BEQ SkipExpTimer              ; if current timer expired, branch to skip,                           ; 
DEC Timers,X                  ; otherwise decrement the current timer                               ;  B
SkipExpTimer:  DEX            ; move onto next timer                                                ;  B
BPL DecTimersLoop             ; do this until all timers are dealt with                             ; 
NoDecTimers:  INC FrameCounter; increment frame counter                                             ;  B
PauseSkip:  LDX #$00                                                                                ;  B
LDY #$07                                                                                            ; 
LDA PseudoRandomBitReg        ; get first memory location of LSFR bytes                             ; 
AND #%00000010                ; mask out all but d1                                                 ; 
STA $00                       ; save here                                                           ; 
LDA PseudoRandomBitReg+1      ; get second memory location                                          ; 
AND #%00000010                ; mask out all but d1                                                 ; 
EOR $00                       ; perform exclusive-OR on d1 from first and second bytes              ; 
CLC                           ; if neither or both are set, carry will be clear                     ; 
BEQ RotPRandomBit                                                                                   ; 
SEC                           ; if one or the other is set, carry will be set                       ;  B
RotPRandomBit:  ROR PseudoRandomBitReg,X; rotate carry into d7, and rotate last bit into carry      ;  B
INX                           ; increment to next byte                                              ; 
DEY                           ; decrement for loop                                                  ; 
BNE RotPRandomBit                                                                                   ; 
LDA Sprite0HitDetectFlag      ; check for flag here                                                 ;  B
BEQ SkipSprite0                                                                                     ; 
Sprite0Clr:  LDA PPU_STATUS   ; wait for sprite 0 flag to clear, which will                         ;  B
AND #%01000000                ; not happen until vblank has ended                                   ; 
BNE Sprite0Clr                                                                                      ; 
LDA GamePauseStatus           ; if in pause mode, do not bother with sprites at all                 ;  B
LSR                                                                                                 ; 
BCS Sprite0Hit                                                                                      ; 
JSR MoveSpritesOffscreen                                                                            ;  B
JSR SpriteShuffler                                                                                  ; 
Sprite0Hit:  LDA PPU_STATUS   ; do sprite #0 hit detection                                          ;  B
AND #%01000000                                                                                      ; 
BEQ Sprite0Hit                                                                                      ; 
LDY #$14                      ; small delay, to wait until we hit horizontal blank time             ;  B
HBlankDelay:  DEY                                                                                   ;  B
BNE HBlankDelay                                                                                     ; 
SkipSprite0:  LDA HorizontalScroll; set scroll registers from variables                             ;  B
STA PPU_SCROLL_REG                                                                                  ; 
LDA VerticalScroll                                                                                  ; 
STA PPU_SCROLL_REG                                                                                  ; 
LDA Mirror_PPU_CTRL_REG1      ; load saved mirror of $2000                                          ; 
PHA                                                                                                 ; 
STA PPU_CTRL_REG1                                                                                   ; 
LDA GamePauseStatus           ; if in pause mode, do not perform operation mode stuff               ; 
LSR                                                                                                 ; 
BCS SkipMainOper                                                                                    ; 
JSR OperModeExecutionTree     ; otherwise do one of many, many possible subroutines                 ;  B
SkipMainOper:  LDA PPU_STATUS ; reset flip-flop                                                     ;  B
PLA                                                                                                 ; 
ORA #%10000000                ; reactivate NMIs                                                     ; 
STA PPU_CTRL_REG1                                                                                   ; 
RTI                           ; we are done until the next frame!                                   ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PauseRoutine:                                                                                       ; fun():  B
LDA OperMode                  ; are we in victory mode?                                             ; 
CMP #VictoryModeValue         ; if so, go ahead                                                     ; 
BEQ ChkPauseTimer                                                                                   ; 
CMP #GameModeValue            ; are we in game mode?                                                ;  B
BNE ExitPause                 ; if not, leave                                                       ; 
LDA OperMode_Task             ; if we are in game mode, are we running game engine?                 ;  B
CMP #$03                                                                                            ; 
BNE ExitPause                 ; if not, leave                                                       ; 
ChkPauseTimer:  LDA GamePauseTimer; check if pause timer is still counting down                     ;  B
BEQ ChkStart                                                                                        ; 
DEC GamePauseTimer            ; if so, decrement and leave                                          ;  B
RTS                                                                                                 ; 
ChkStart:  LDA SavedJoypad1Bits; check to see if start is pressed                                   ;  B
AND #Start_Button             ; on controller 1                                                     ; 
BEQ ClrPauseTimer                                                                                   ; 
LDA GamePauseStatus           ; check to see if timer flag is set                                   ;  B
AND #%10000000                ; and if so, do not reset timer (residual,                            ; 
BNE ExitPause                 ; joypad reading routine makes this unnecessary)                      ; 
LDA #$2b                      ; set pause timer                                                     ;  B
STA GamePauseTimer                                                                                  ; 
LDA GamePauseStatus                                                                                 ; 
TAY                                                                                                 ; 
INY                           ; set pause sfx queue for next pause mode                             ; 
STY PauseSoundQueue                                                                                 ; 
EOR #%00000001                ; invert d0 and set d7                                                ; 
ORA #%10000000                                                                                      ; 
BNE SetPause                  ; unconditional branch                                                ; 
ClrPauseTimer:  LDA GamePauseStatus; clear timer flag if timer is at zero and start button          ;  B
AND #%01111111                ; is not pressed                                                      ; 
SetPause:  STA GamePauseStatus                                                                      ;  B
ExitPause:  RTS                                                                                     ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used for preset value                                         ; 
                                                                                                    ; 
SpriteShuffler:                                                                                     ; fun():  B
LDY AreaType                  ; load level type, likely residual code                               ; 
LDA #$28                      ; load preset value which will put it at                              ; 
STA $00                       ; sprite #10                                                          ; 
LDX #$0e                      ; start at the end of OAM data offsets                                ; 
ShuffleLoop:  LDA SprDataOffset,X; check for offset value against                                   ;  B
CMP $00                       ; the preset value                                                    ; 
BCC NextSprOffset             ; if less, skip this part                                             ; 
LDY SprShuffleAmtOffset       ; get current offset to preset value we want to add                   ;  B
CLC                                                                                                 ; 
ADC SprShuffleAmt,Y           ; get shuffle amount, add to current sprite offset                    ; 
BCC StrSprOffset              ; if not exceeded $ff, skip second add                                ; 
CLC                                                                                                 ;  B
ADC $00                       ; otherwise add preset value $28 to offset                            ; 
StrSprOffset:  STA SprDataOffset,X; store new offset here or old one if branched to here            ;  B
NextSprOffset:  DEX           ; move backwards to next one                                          ;  B
BPL ShuffleLoop                                                                                     ; 
LDX SprShuffleAmtOffset       ; load offset                                                         ;  B
INX                                                                                                 ; 
CPX #$03                      ; check if offset + 1 goes to 3                                       ; 
BNE SetAmtOffset              ; if offset + 1 not 3, store                                          ; 
LDX #$00                      ; otherwise, init to 0                                                ;  B
SetAmtOffset:  STX SprShuffleAmtOffset                                                              ;  B
LDX #$08                      ; load offsets for values and storage                                 ; 
LDY #$02                                                                                            ; 
SetMiscOffset:  LDA SprDataOffset+5,Y; load one of three OAM data offsets                           ;  B
STA Misc_SprDataOffset-2,X    ; store first one unmodified, but                                     ; 
CLC                           ; add eight to the second and eight                                   ; 
ADC #$08                      ; more to the third one                                               ; 
STA Misc_SprDataOffset-1,X    ; note that due to the way X is set up,                               ; 
CLC                           ; this code loads into the misc sprite offsets                        ; 
ADC #$08                                                                                            ; 
STA Misc_SprDataOffset,X                                                                            ; 
DEX                                                                                                 ; 
DEX                                                                                                 ; 
DEX                                                                                                 ; 
DEY                                                                                                 ; 
BPL SetMiscOffset             ; do this until all misc spr offsets are loaded                       ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
OperModeExecutionTree:                                                                              ; fun():  B
LDA OperMode                  ; this is the heart of the entire program,                            ; 
JSR JumpEngine                ; most of what goes on starts here                                    ; 
                                                                                                    ; 
DATA: Expr(expr=TitleScreenMode)                                                                    ; 
DATA: Expr(expr=GameMode)                                                                           ; 
DATA: Expr(expr=VictoryMode)                                                                        ; 
DATA: Expr(expr=GameOverMode)                                                                       ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
MoveAllSpritesOffscreen:                                                                            ; fun():  B
LDY #$00                      ; this routine moves all sprites off the screen                       ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
MoveSpritesOffscreen:                                                                               ; fun():  B
LDY #$04                      ; this routine moves all but sprite 0                                 ; 
LDA #$f8                      ; off the screen                                                      ; 
SprInitLoop:  STA Sprite_Y_Position,Y; write 248 into OAM data's Y coordinate                       ;  B
INY                           ; which will move it off the screen                                   ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
BNE SprInitLoop                                                                                     ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
TitleScreenMode:                                                                                    ;  B
LDA OperMode_Task                                                                                   ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=InitializeGame)                                                                     ; 
DATA: Expr(expr=ScreenRoutines)                                                                     ; 
DATA: Expr(expr=PrimaryGameSetup)                                                                   ; 
DATA: Expr(expr=GameMenuRoutine)                                                                    ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
WSelectBufferTemplate:                                                                              ;  B
DATA: ByteValue(value=4), ByteValue(value=32), ByteValue(value=115), ByteValue(value=1), ByteValue(value=0), ByteValue(value=0); 
                                                                                                    ; 
GameMenuRoutine:                                                                                    ;  B
LDY #$00                                                                                            ; 
LDA SavedJoypad1Bits          ; check to see if either player pressed                               ; 
ORA SavedJoypad2Bits          ; only the start button (either joypad)                               ; 
CMP #Start_Button                                                                                   ; 
BEQ StartGame                                                                                       ; 
CMP #A_Button+Start_Button    ; check to see if A + start was pressed                               ;  B
BNE ChkSelect                 ; if not, branch to check select button                               ; 
StartGame:  JMP ChkContinue   ; if either start or A + start, execute here                          ;  B
ChkSelect:  CMP #Select_Button; check to see if the select button was pressed                       ;  B
BEQ SelectBLogic              ; if so, branch reset demo timer                                      ; 
LDX DemoTimer                 ; otherwise check demo timer                                          ;  B
BNE ChkWorldSel               ; if demo timer not expired, branch to check world selection          ; 
STA SelectTimer               ; set controller bits here if running demo                            ;  B
JSR DemoEngine                ; run through the demo actions                                        ; 
BCS ResetTitle                ; if carry flag set, demo over, thus branch                           ; 
JMP RunDemo                   ; otherwise, run game engine for demo                                 ;  B
ChkWorldSel:  LDX WorldSelectEnableFlag; check to see if world selection has been enabled           ;  B
BEQ NullJoypad                                                                                      ; 
CMP #B_Button                 ; if so, check to see if the B button was pressed                     ;  B
BNE NullJoypad                                                                                      ; 
INY                           ; if so, increment Y and execute same code as select                  ;  B
SelectBLogic:  LDA DemoTimer  ; if select or B pressed, check demo timer one last time              ;  B
BEQ ResetTitle                ; if demo timer expired, branch to reset title screen mode            ; 
LDA #$18                      ; otherwise reset demo timer                                          ;  B
STA DemoTimer                                                                                       ; 
LDA SelectTimer               ; check select/B button timer                                         ; 
BNE NullJoypad                ; if not expired, branch                                              ; 
LDA #$10                      ; otherwise reset select button timer                                 ;  B
STA SelectTimer                                                                                     ; 
CPY #$01                      ; was the B button pressed earlier?  if so, branch                    ; 
BEQ IncWorldSel               ; note this will not be run if world selection is disabled            ; 
LDA NumberOfPlayers           ; if no, must have been the select button, therefore                  ;  B
EOR #%00000001                ; change number of players and draw icon accordingly                  ; 
STA NumberOfPlayers                                                                                 ; 
JSR DrawMushroomIcon                                                                                ; 
JMP NullJoypad                                                                                      ; 
IncWorldSel:  LDX WorldSelectNumber; increment world select number                                  ;  B
INX                                                                                                 ; 
TXA                                                                                                 ; 
AND #%00000111                ; mask out higher bits                                                ; 
STA WorldSelectNumber         ; store as current world select number                                ; 
JSR GoContinue                                                                                      ; 
UpdateShroom:  LDA WSelectBufferTemplate,X; write template for world select in vram buffer          ;  B
STA VRAM_Buffer1-1,X          ; do this until all bytes are written                                 ; 
INX                                                                                                 ; 
CPX #$06                                                                                            ; 
BMI UpdateShroom                                                                                    ; 
LDY WorldNumber               ; get world number from variable and increment for                    ;  B
INY                           ; proper display, and put in blank byte before                        ; 
STY VRAM_Buffer1+3            ; null terminator                                                     ; 
NullJoypad:  LDA #$00         ; clear joypad bits for player 1                                      ;  B
STA SavedJoypad1Bits                                                                                ; 
RunDemo:  JSR GameCoreRoutine ; run game engine                                                     ;  B
LDA GameEngineSubroutine      ; check to see if we're running lose life routine                     ; 
CMP #$06                                                                                            ; 
BNE ExitMenu                  ; if not, do not do all the resetting below                           ; 
ResetTitle:  LDA #$00         ; reset game modes, disable                                           ;  B
STA OperMode                  ; sprite 0 check and disable                                          ; 
STA OperMode_Task             ; screen output                                                       ; 
STA Sprite0HitDetectFlag                                                                            ; 
INC DisableScreenFlag                                                                               ; 
RTS                                                                                                 ; 
ChkContinue:  LDY DemoTimer   ; if timer for demo has expired, reset modes                          ;  B
BEQ ResetTitle                                                                                      ; 
ASL                           ; check to see if A button was also pushed                            ;  B
BCC StartWorld1               ; if not, don't load continue function's world number                 ; 
LDA ContinueWorld             ; load previously saved world number for secret                       ;  B
JSR GoContinue                ; continue function when pressing A + start                           ; 
StartWorld1:  JSR LoadAreaPointer                                                                   ;  B
INC Hidden1UpFlag             ; set 1-up box flag for both players                                  ; 
INC OffScr_Hidden1UpFlag                                                                            ; 
INC FetchNewGameTimerFlag     ; set fetch new game timer flag                                       ; 
INC OperMode                  ; set next game mode                                                  ; 
LDA WorldSelectEnableFlag     ; if world select flag is on, then primary                            ; 
STA PrimaryHardMode           ; hard mode must be on as well                                        ; 
LDA #$00                                                                                            ; 
STA OperMode_Task             ; set game mode here, and clear demo timer                            ; 
STA DemoTimer                                                                                       ; 
LDX #$17                                                                                            ; 
LDA #$00                                                                                            ; 
InitScores:  STA ScoreAndCoinDisplay,X; clear player scores and coin displays                       ;  B
DEX                                                                                                 ; 
BPL InitScores                                                                                      ; 
ExitMenu:  RTS                                                                                      ;  B
GoContinue:  STA WorldNumber  ; start both players at the first area                                ; fun(A):  B
STA OffScr_WorldNumber        ; of the previously saved world number                                ; 
LDX #$00                      ; note that on power-up using this function                           ; 
STX AreaNumber                ; will make no difference                                             ; 
STX OffScr_AreaNumber                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
MushroomIconData:                                                                                   ;  B
DATA: ByteValue(value=7), ByteValue(value=34), ByteValue(value=73), ByteValue(value=131), ByteValue(value=206), ByteValue(value=36), ByteValue(value=36), ByteValue(value=0); 
                                                                                                    ; 
DrawMushroomIcon:                                                                                   ; fun():  B
LDY #$07                      ; read eight bytes to be read by transfer routine                     ; 
IconDataRead:  LDA MushroomIconData,Y; note that the default position is set for a                  ;  B
STA VRAM_Buffer1-1,Y          ; 1-player game                                                       ; 
DEY                                                                                                 ; 
BPL IconDataRead                                                                                    ; 
LDA NumberOfPlayers           ; check number of players                                             ;  B
BEQ ExitIcon                  ; if set to 1-player game, we're done                                 ; 
LDA #$24                      ; otherwise, load blank tile in 1-player position                     ;  B
STA VRAM_Buffer1+3                                                                                  ; 
LDA #$ce                      ; then load shroom icon tile in 2-player position                     ; 
STA VRAM_Buffer1+5                                                                                  ; 
ExitIcon:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DemoActionData:                                                                                     ;  B
DATA: ByteValue(value=1), ByteValue(value=128), ByteValue(value=2), ByteValue(value=129), ByteValue(value=65), ByteValue(value=128), ByteValue(value=1); 
DATA: ByteValue(value=66), ByteValue(value=194), ByteValue(value=2), ByteValue(value=128), ByteValue(value=65), ByteValue(value=193), ByteValue(value=65), ByteValue(value=193); 
DATA: ByteValue(value=1), ByteValue(value=193), ByteValue(value=1), ByteValue(value=2), ByteValue(value=128), ByteValue(value=0); 
                                                                                                    ; 
DemoTimingData:                                                                                     ;  B
DATA: ByteValue(value=155), ByteValue(value=16), ByteValue(value=24), ByteValue(value=5), ByteValue(value=44), ByteValue(value=32), ByteValue(value=36); 
DATA: ByteValue(value=21), ByteValue(value=90), ByteValue(value=16), ByteValue(value=32), ByteValue(value=40), ByteValue(value=48), ByteValue(value=32), ByteValue(value=16); 
DATA: ByteValue(value=128), ByteValue(value=32), ByteValue(value=48), ByteValue(value=48), ByteValue(value=1), ByteValue(value=255), ByteValue(value=0); 
                                                                                                    ; 
DemoEngine:                                                                                         ; fun(): CarryFlag B
LDX DemoAction                ; load current demo action                                            ; 
LDA DemoActionTimer           ; load current action timer                                           ; 
BNE DoAction                  ; if timer still counting down, skip                                  ; 
INX                                                                                                 ;  B
INC DemoAction                ; if expired, increment action, X, and                                ; 
SEC                           ; set carry by default for demo over                                  ; 
LDA DemoTimingData-1,X        ; get next timer                                                      ; 
STA DemoActionTimer           ; store as current timer                                              ; 
BEQ DemoOver                  ; if timer already at zero, skip                                      ; 
DoAction:  LDA DemoActionData-1,X; get and perform action (current or next)                         ;  B
STA SavedJoypad1Bits                                                                                ; 
DEC DemoActionTimer           ; decrement action timer                                              ; 
CLC                           ; clear carry if demo still going                                     ; 
DemoOver:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
VictoryMode:                                                                                        ;  B
JSR VictoryModeSubroutines    ; run victory mode subroutines                                        ; 
LDA OperMode_Task             ; get current task of victory mode                                    ; 
BEQ AutoPlayer                ; if on bridge collapse, skip enemy processing                        ; 
LDX #$00                                                                                            ;  B
STX ObjectOffset              ; otherwise reset enemy object offset                                 ; 
JSR EnemiesAndLoopsCore       ; and run enemy code                                                  ; 
AutoPlayer:  JSR RelativePlayerPosition; get player's relative coordinates                          ;  B
JMP PlayerGfxHandler          ; draw the player, then leave                                         ; 
                                                                                                    ;  B
VictoryModeSubroutines:                                                                             ; fun():  B
LDA OperMode_Task                                                                                   ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=BridgeCollapse)                                                                     ; 
DATA: Expr(expr=SetupVictoryMode)                                                                   ; 
DATA: Expr(expr=PlayerVictoryWalk)                                                                  ; 
DATA: Expr(expr=PrintVictoryMessages)                                                               ; 
DATA: Expr(expr=PlayerEndWorld)                                                                     ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
SetupVictoryMode:                                                                                   ;  B
LDX ScreenRight_PageLoc       ; get page location of right side of screen                           ; 
INX                           ; increment to next page                                              ; 
STX DestinationPageLoc        ; store here                                                          ; 
LDA #EndOfCastleMusic                                                                               ; 
STA EventMusicQueue           ; play win castle music                                               ; 
JMP IncModeTask_B             ; jump to set next major task in victory mode                         ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerVictoryWalk:                                                                                  ;  B
LDY #$00                      ; set value here to not walk player by default                        ; 
STY VictoryWalkControl                                                                              ; 
LDA Player_PageLoc            ; get player's page location                                          ; 
CMP DestinationPageLoc        ; compare with destination page location                              ; 
BNE PerformWalk               ; if page locations don't match, branch                               ; 
LDA Player_X_Position         ; otherwise get player's horizontal position                          ;  B
CMP #$60                      ; compare with preset horizontal position                             ; 
BCS DontWalk                  ; if still on other page, branch ahead                                ; 
PerformWalk:  INC VictoryWalkControl; otherwise increment value and Y                               ;  B
INY                           ; note Y will be used to walk the player                              ; 
DontWalk:  TYA                ; put contents of Y in A and                                          ;  B
JSR AutoControlPlayer         ; use A to move player to the right or not                            ; 
LDA ScreenLeft_PageLoc        ; check page location of left side of screen                          ; 
CMP DestinationPageLoc        ; against set value here                                              ; 
BEQ ExitVWalk                 ; branch if equal to change modes if necessary                        ; 
LDA ScrollFractional                                                                                ;  B
CLC                           ; do fixed point math on fractional part of scroll                    ; 
ADC #$80                                                                                            ; 
STA ScrollFractional          ; save fractional movement amount                                     ; 
LDA #$01                      ; set 1 pixel per frame                                               ; 
ADC #$00                      ; add carry from previous addition                                    ; 
TAY                           ; use as scroll amount                                                ; 
JSR ScrollScreen              ; do sub to scroll the screen                                         ; 
JSR UpdScrollVar              ; do another sub to update screen and scroll variables                ; 
INC VictoryWalkControl        ; increment value to stay in this routine                             ; 
ExitVWalk:  LDA VictoryWalkControl; load value set here                                             ;  B
BEQ IncModeTask_A             ; if zero, branch to change modes                                     ; 
RTS                           ; otherwise leave                                                     ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PrintVictoryMessages:                                                                               ;  B
LDA SecondaryMsgCounter       ; load secondary message counter                                      ; 
BNE IncMsgCounter             ; if set, branch to increment message counters                        ; 
LDA PrimaryMsgCounter         ; otherwise load primary message counter                              ;  B
BEQ ThankPlayer               ; if set to zero, branch to print first message                       ; 
CMP #$09                      ; if at 9 or above, branch elsewhere (this comparison                 ;  B
BCS IncMsgCounter             ; is residual code, counter never reaches 9)                          ; 
LDY WorldNumber               ; check world number                                                  ;  B
CPY #World8                                                                                         ; 
BNE MRetainerMsg              ; if not at world 8, skip to next part                                ; 
CMP #$03                      ; check primary message counter again                                 ;  B
BCC IncMsgCounter             ; if not at 3 yet (world 8 only), branch to increment                 ; 
SBC #$01                      ; otherwise subtract one                                              ;  B
JMP ThankPlayer               ; and skip to next part                                               ; 
MRetainerMsg:  CMP #$02       ; check primary message counter                                       ;  B
BCC IncMsgCounter             ; if not at 2 yet (world 1-7 only), branch                            ; 
ThankPlayer:  TAY             ; put primary message counter into Y                                  ;  B
BNE SecondPartMsg             ; if counter nonzero, skip this part, do not print first message      ; 
LDA CurrentPlayer             ; otherwise get player currently on the screen                        ;  B
BEQ EvalForMusic              ; if mario, branch                                                    ; 
INY                           ; otherwise increment Y once for luigi and                            ;  B
BNE EvalForMusic              ; do an unconditional branch to the same place                        ; 
SecondPartMsg:  INY           ; increment Y to do world 8's message                                 ;  B
LDA WorldNumber                                                                                     ; 
CMP #World8                   ; check world number                                                  ; 
BEQ EvalForMusic              ; if at world 8, branch to next part                                  ; 
DEY                           ; otherwise decrement Y for world 1-7's message                       ;  B
CPY #$04                      ; if counter at 4 (world 1-7 only)                                    ; 
BCS SetEndTimer               ; branch to set victory end timer                                     ; 
CPY #$03                      ; if counter at 3 (world 1-7 only)                                    ;  B
BCS IncMsgCounter             ; branch to keep counting                                             ; 
EvalForMusic:  CPY #$03       ; if counter not yet at 3 (world 8 only), branch                      ;  B
BNE PrintMsg                  ; to print message only (note world 1-7 will only                     ; 
LDA #VictoryMusic             ; reach this code if counter = 0, and will always branch)             ;  B
STA EventMusicQueue           ; otherwise load victory music first (world 8 only)                   ; 
PrintMsg:  TYA                ; put primary message counter in A                                    ;  B
CLC                           ; add $0c or 12 to counter thus giving an appropriate value,          ; 
ADC #$0c                      ; ($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)       ; 
STA VRAM_Buffer_AddrCtrl      ; write message counter to vram address controller                    ; 
IncMsgCounter:  LDA SecondaryMsgCounter                                                             ;  B
CLC                                                                                                 ; 
ADC #$04                      ; add four to secondary message counter                               ; 
STA SecondaryMsgCounter                                                                             ; 
LDA PrimaryMsgCounter                                                                               ; 
ADC #$00                      ; add carry to primary message counter                                ; 
STA PrimaryMsgCounter                                                                               ; 
CMP #$07                      ; check primary counter one more time                                 ; 
SetEndTimer:  BCC ExitMsgs    ; if not reached value yet, branch to leave                           ;  B
LDA #$06                                                                                            ;  B
STA WorldEndTimer             ; otherwise set world end timer                                       ; 
IncModeTask_A:  INC OperMode_Task; move onto next task in mode                                      ;  B
ExitMsgs:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerEndWorld:                                                                                     ;  B
LDA WorldEndTimer             ; check to see if world end timer expired                             ; 
BNE EndExitOne                ; branch to leave if not                                              ; 
LDY WorldNumber               ; check world number                                                  ;  B
CPY #World8                   ; if on world 8, player is done with game,                            ; 
BCS EndChkBButton             ; thus branch to read controller                                      ; 
LDA #$00                                                                                            ;  B
STA AreaNumber                ; otherwise initialize area number used as offset                     ; 
STA LevelNumber               ; and level number control to start at area 1                         ; 
STA OperMode_Task             ; initialize secondary mode of operation                              ; 
INC WorldNumber               ; increment world number to move onto the next world                  ; 
JSR LoadAreaPointer           ; get area address offset for the next area                           ; 
INC FetchNewGameTimerFlag     ; set flag to load game timer from header                             ; 
LDA #GameModeValue                                                                                  ; 
STA OperMode                  ; set mode of operation to game mode                                  ; 
EndExitOne:  RTS              ; and leave                                                           ;  B
EndChkBButton:  LDA SavedJoypad1Bits                                                                ;  B
ORA SavedJoypad2Bits          ; check to see if B button was pressed on                             ; 
AND #B_Button                 ; either controller                                                   ; 
BEQ EndExitTwo                ; branch to leave if not                                              ; 
LDA #$01                      ; otherwise set world selection flag                                  ;  B
STA WorldSelectEnableFlag                                                                           ; 
LDA #$ff                      ; remove onscreen player's lives                                      ; 
STA NumberofLives                                                                                   ; 
JSR TerminateGame             ; do sub to continue other player or end game                         ; 
EndExitTwo:  RTS              ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; data is used as tiles for numbers                                   ; 
                              ; that appear when you defeat enemies                                 ; 
FloateyNumTileData:                                                                                 ;  B
DATA: ByteValue(value=255), ByteValue(value=255); dummy                                             ; 
DATA: ByteValue(value=246), ByteValue(value=251); "100"                                             ; 
DATA: ByteValue(value=247), ByteValue(value=251); "200"                                             ; 
DATA: ByteValue(value=248), ByteValue(value=251); "400"                                             ; 
DATA: ByteValue(value=249), ByteValue(value=251); "500"                                             ; 
DATA: ByteValue(value=250), ByteValue(value=251); "800"                                             ; 
DATA: ByteValue(value=246), ByteValue(value=80); "1000"                                             ; 
DATA: ByteValue(value=247), ByteValue(value=80); "2000"                                             ; 
DATA: ByteValue(value=248), ByteValue(value=80); "4000"                                             ; 
DATA: ByteValue(value=249), ByteValue(value=80); "5000"                                             ; 
DATA: ByteValue(value=250), ByteValue(value=80); "8000"                                             ; 
DATA: ByteValue(value=253), ByteValue(value=254); "1-UP"                                            ; 
                                                                                                    ; 
                              ; high nybble is digit number, low nybble is number to                ; 
                              ; add to the digit of the player's score                              ; 
ScoreUpdateData:                                                                                    ;  B
DATA: ByteValue(value=255)    ; dummy                                                               ; 
DATA: ByteValue(value=65), ByteValue(value=66), ByteValue(value=68), ByteValue(value=69), ByteValue(value=72); 
DATA: ByteValue(value=49), ByteValue(value=50), ByteValue(value=52), ByteValue(value=53), ByteValue(value=56), ByteValue(value=0); 
                                                                                                    ; 
FloateyNumbersRoutine:                                                                              ; fun(): X B
LDA FloateyNum_Control,X      ; load control for floatey number                                     ; 
BEQ EndExitOne                ; if zero, branch to leave                                            ; 
CMP #$0b                      ; if less than $0b, branch                                            ;  B
BCC ChkNumTimer                                                                                     ; 
LDA #$0b                      ; otherwise set to $0b, thus keeping                                  ;  B
STA FloateyNum_Control,X      ; it in range                                                         ; 
ChkNumTimer:  TAY             ; use as Y                                                            ;  B
LDA FloateyNum_Timer,X        ; check value here                                                    ; 
BNE DecNumTimer               ; if nonzero, branch ahead                                            ; 
STA FloateyNum_Control,X      ; initialize floatey number control and leave                         ;  B
RTS                                                                                                 ; 
DecNumTimer:  DEC FloateyNum_Timer,X; decrement value here                                          ;  B
CMP #$2b                      ; if not reached a certain point, branch                              ; 
BNE ChkTallEnemy                                                                                    ; 
CPY #$0b                      ; check offset for $0b                                                ;  B
BNE LoadNumTiles              ; branch ahead if not found                                           ; 
INC NumberofLives             ; give player one extra life (1-up)                                   ;  B
LDA #Sfx_ExtraLife                                                                                  ; 
STA Square2SoundQueue         ; and play the 1-up sound                                             ; 
LoadNumTiles:  LDA ScoreUpdateData,Y; load point value here                                         ;  B
LSR                           ; move high nybble to low                                             ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
TAX                           ; use as X offset, essentially the digit                              ; 
LDA ScoreUpdateData,Y         ; load again and this time                                            ; 
AND #%00001111                ; mask out the high nybble                                            ; 
STA DigitModifier,X           ; store as amount to add to the digit                                 ; 
JSR AddToScore                ; update the score accordingly                                        ; 
ChkTallEnemy:  LDY Enemy_SprDataOffset,X; get OAM data offset for enemy object                      ;  B
LDA Enemy_ID,X                ; get enemy object identifier                                         ; 
CMP #Spiny                                                                                          ; 
BEQ FloateyPart               ; branch if spiny                                                     ; 
CMP #PiranhaPlant                                                                                   ;  B
BEQ FloateyPart               ; branch if piranha plant                                             ; 
CMP #HammerBro                                                                                      ;  B
BEQ GetAltOffset              ; branch elsewhere if hammer bro                                      ; 
CMP #GreyCheepCheep                                                                                 ;  B
BEQ FloateyPart               ; branch if cheep-cheep of either color                               ; 
CMP #RedCheepCheep                                                                                  ;  B
BEQ FloateyPart                                                                                     ; 
CMP #TallEnemy                                                                                      ;  B
BCS GetAltOffset              ; branch elsewhere if enemy object => $09                             ; 
LDA Enemy_State,X                                                                                   ;  B
CMP #$02                      ; if enemy state defeated or otherwise                                ; 
BCS FloateyPart               ; $02 or greater, branch beyond this part                             ; 
GetAltOffset:  LDX SprDataOffset_Ctrl; load some kind of control bit                                ;  B
LDY Alt_SprDataOffset,X       ; get alternate OAM data offset                                       ; 
LDX ObjectOffset              ; get enemy object offset again                                       ; 
FloateyPart:  LDA FloateyNum_Y_Pos,X; get vertical coordinate for                                   ;  B
CMP #$18                      ; floatey number, if coordinate in the                                ; 
BCC SetupNumSpr               ; status bar, branch                                                  ; 
SBC #$01                                                                                            ;  B
STA FloateyNum_Y_Pos,X        ; otherwise subtract one and store as new                             ; 
SetupNumSpr:  LDA FloateyNum_Y_Pos,X; get vertical coordinate                                       ;  B
SBC #$08                      ; subtract eight and dump into the                                    ; 
JSR DumpTwoSpr                ; left and right sprite's Y coordinates                               ; 
LDA FloateyNum_X_Pos,X        ; get horizontal coordinate                                           ; 
STA Sprite_X_Position,Y       ; store into X coordinate of left sprite                              ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels and store into X                                   ; 
STA Sprite_X_Position+4,Y     ; coordinate of right sprite                                          ; 
LDA #$02                                                                                            ; 
STA Sprite_Attributes,Y       ; set palette control in attribute bytes                              ; 
STA Sprite_Attributes+4,Y     ; of left and right sprites                                           ; 
LDA FloateyNum_Control,X                                                                            ; 
ASL                           ; multiply our floatey number control by 2                            ; 
TAX                           ; and use as offset for look-up table                                 ; 
LDA FloateyNumTileData,X                                                                            ; 
STA Sprite_Tilenumber,Y       ; display first half of number of points                              ; 
LDA FloateyNumTileData+1,X                                                                          ; 
STA Sprite_Tilenumber+4,Y     ; display the second half                                             ; 
LDX ObjectOffset              ; get enemy object offset and leave                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
ScreenRoutines:                                                                                     ;  B
LDA ScreenRoutineTask         ; run one of the following subroutines                                ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=InitScreen)                                                                         ; 
DATA: Expr(expr=SetupIntermediate)                                                                  ; 
DATA: Expr(expr=WriteTopStatusLine)                                                                 ; 
DATA: Expr(expr=WriteBottomStatusLine)                                                              ; 
DATA: Expr(expr=DisplayTimeUp)                                                                      ; 
DATA: Expr(expr=ResetSpritesAndScreenTimer)                                                         ; 
DATA: Expr(expr=DisplayIntermediate)                                                                ; 
DATA: Expr(expr=ResetSpritesAndScreenTimer)                                                         ; 
DATA: Expr(expr=AreaParserTaskControl)                                                              ; 
DATA: Expr(expr=GetAreaPalette)                                                                     ; 
DATA: Expr(expr=GetBackgroundColor)                                                                 ; 
DATA: Expr(expr=GetAlternatePalette1)                                                               ; 
DATA: Expr(expr=DrawTitleScreen)                                                                    ; 
DATA: Expr(expr=ClearBuffersDrawIcon)                                                               ; 
DATA: Expr(expr=WriteTopScore)                                                                      ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
InitScreen:                                                                                         ;  B
JSR MoveAllSpritesOffscreen   ; initialize all sprites including sprite #0                          ; 
JSR InitializeNameTables      ; and erase both name and attribute tables                            ; 
LDA OperMode                                                                                        ; 
BEQ NextSubtask               ; if mode still 0, do not load                                        ; 
LDX #$03                      ; into buffer pointer                                                 ;  B
JMP SetVRAMAddr_A                                                                                   ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
SetupIntermediate:                                                                                  ;  B
LDA BackgroundColorCtrl       ; save current background color control                               ; 
PHA                           ; and player status to stack                                          ; 
LDA PlayerStatus                                                                                    ; 
PHA                                                                                                 ; 
LDA #$00                      ; set background color to black                                       ; 
STA PlayerStatus              ; and player status to not fiery                                      ; 
LDA #$02                      ; this is the ONLY time background color control                      ; 
STA BackgroundColorCtrl       ; is set to less than 4                                               ; 
JSR GetPlayerColors                                                                                 ; 
PLA                           ; we only execute this routine for                                    ; 
STA PlayerStatus              ; the intermediate lives display                                      ; 
PLA                           ; and once we're done, we return bg                                   ; 
STA BackgroundColorCtrl       ; color ctrl and player status from stack                             ; 
JMP IncSubtask                ; then move onto the next task                                        ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
AreaPalette:                                                                                        ;  B
DATA: ByteValue(value=1), ByteValue(value=2), ByteValue(value=3), ByteValue(value=4)                ; 
                                                                                                    ; 
GetAreaPalette:                                                                                     ;  B
LDY AreaType                  ; select appropriate palette to load                                  ; 
LDX AreaPalette,Y             ; based on area type                                                  ; 
SetVRAMAddr_A:  STX VRAM_Buffer_AddrCtrl; store offset into buffer control                          ;  B
NextSubtask:  JMP IncSubtask  ; move onto next task                                                 ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used as temp counter in GetPlayerColors                       ; 
                                                                                                    ; 
BGColorCtrl_Addr:                                                                                   ;  B
DATA: ByteValue(value=0), ByteValue(value=9), ByteValue(value=10), ByteValue(value=4)               ; 
                                                                                                    ; 
BackgroundColors:                                                                                   ;  B
DATA: ByteValue(value=34), ByteValue(value=34), ByteValue(value=15), ByteValue(value=15); used by area type if bg color ctrl not set; 
DATA: ByteValue(value=15), ByteValue(value=34), ByteValue(value=15), ByteValue(value=15); used by background color control if set; 
                                                                                                    ; 
PlayerColors:                                                                                       ;  B
DATA: ByteValue(value=34), ByteValue(value=22), ByteValue(value=39), ByteValue(value=24); mario's colors; 
DATA: ByteValue(value=34), ByteValue(value=48), ByteValue(value=39), ByteValue(value=25); luigi's colors; 
DATA: ByteValue(value=34), ByteValue(value=55), ByteValue(value=39), ByteValue(value=22); fiery (used by both); 
                                                                                                    ; 
GetBackgroundColor:                                                                                 ;  B
LDY BackgroundColorCtrl       ; check background color control                                      ; 
BEQ NoBGColor                 ; if not set, increment task and fetch palette                        ; 
LDA BGColorCtrl_Addr-4,Y      ; put appropriate palette into vram                                   ;  B
STA VRAM_Buffer_AddrCtrl      ; note that if set to 5-7, $0301 will not be read                     ; 
NoBGColor:  INC ScreenRoutineTask; increment to next subtask and plod on through                    ;  B
                                                                                                    ; 
GetPlayerColors:                                                                                    ; fun():  B
LDX VRAM_Buffer1_Offset       ; get current buffer offset                                           ; 
LDY #$00                                                                                            ; 
LDA CurrentPlayer             ; check which player is on the screen                                 ; 
BEQ ChkFiery                                                                                        ; 
LDY #$04                      ; load offset for luigi                                               ;  B
ChkFiery:  LDA PlayerStatus   ; check player status                                                 ;  B
CMP #$02                                                                                            ; 
BNE StartClrGet               ; if fiery, load alternate offset for fiery player                    ; 
LDY #$08                                                                                            ;  B
StartClrGet:  LDA #$03        ; do four colors                                                      ;  B
STA $00                                                                                             ; 
ClrGetLoop:  LDA PlayerColors,Y; fetch player colors and store them                                 ;  B
STA VRAM_Buffer1+3,X          ; in the buffer                                                       ; 
INY                                                                                                 ; 
INX                                                                                                 ; 
DEC $00                                                                                             ; 
BPL ClrGetLoop                                                                                      ; 
LDX VRAM_Buffer1_Offset       ; load original offset from before                                    ;  B
LDY BackgroundColorCtrl       ; if this value is four or greater, it will be set                    ; 
BNE SetBGColor                ; therefore use it as offset to background color                      ; 
LDY AreaType                  ; otherwise use area type bits from area offset as offset             ;  B
SetBGColor:  LDA BackgroundColors,Y; to background color instead                                    ;  B
STA VRAM_Buffer1+3,X                                                                                ; 
LDA #$3f                      ; set for sprite palette address                                      ; 
STA VRAM_Buffer1,X            ; save to buffer                                                      ; 
LDA #$10                                                                                            ; 
STA VRAM_Buffer1+1,X                                                                                ; 
LDA #$04                      ; write length byte to buffer                                         ; 
STA VRAM_Buffer1+2,X                                                                                ; 
LDA #$00                      ; now the null terminator                                             ; 
STA VRAM_Buffer1+7,X                                                                                ; 
TXA                           ; move the buffer pointer ahead 7 bytes                               ; 
CLC                           ; in case we want to write anything else later                        ; 
ADC #$07                                                                                            ; 
SetVRAMOffset:  STA VRAM_Buffer1_Offset; store as new vram buffer offset                            ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GetAlternatePalette1:                                                                               ;  B
LDA AreaStyle                 ; check for mushroom level style                                      ; 
CMP #$01                                                                                            ; 
BNE NoAltPal                                                                                        ; 
LDA #$0b                      ; if found, load appropriate palette                                  ;  B
SetVRAMAddr_B:  STA VRAM_Buffer_AddrCtrl                                                            ;  B
NoAltPal:  JMP IncSubtask     ; now onto the next task                                              ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
WriteTopStatusLine:                                                                                 ;  B
LDA #$00                      ; select main status bar                                              ; 
JSR WriteGameText             ; output it                                                           ; 
JMP IncSubtask                ; onto the next task                                                  ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
WriteBottomStatusLine:                                                                              ;  B
JSR GetSBNybbles              ; write player's score and coin tally to screen                       ; 
LDX VRAM_Buffer1_Offset                                                                             ; 
LDA #$20                      ; write address for world-area number on screen                       ; 
STA VRAM_Buffer1,X                                                                                  ; 
LDA #$73                                                                                            ; 
STA VRAM_Buffer1+1,X                                                                                ; 
LDA #$03                      ; write length for it                                                 ; 
STA VRAM_Buffer1+2,X                                                                                ; 
LDY WorldNumber               ; first the world number                                              ; 
INY                                                                                                 ; 
TYA                                                                                                 ; 
STA VRAM_Buffer1+3,X                                                                                ; 
LDA #$28                      ; next the dash                                                       ; 
STA VRAM_Buffer1+4,X                                                                                ; 
LDY LevelNumber               ; next the level number                                               ; 
INY                           ; increment for proper number display                                 ; 
TYA                                                                                                 ; 
STA VRAM_Buffer1+5,X                                                                                ; 
LDA #$00                      ; put null terminator on                                              ; 
STA VRAM_Buffer1+6,X                                                                                ; 
TXA                           ; move the buffer offset up by 6 bytes                                ; 
CLC                                                                                                 ; 
ADC #$06                                                                                            ; 
STA VRAM_Buffer1_Offset                                                                             ; 
JMP IncSubtask                                                                                      ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DisplayTimeUp:                                                                                      ;  B
LDA GameTimerExpiredFlag      ; if game timer not expired, increment task                           ; 
BEQ NoTimeUp                  ; control 2 tasks forward, otherwise, stay here                       ; 
LDA #$00                                                                                            ;  B
STA GameTimerExpiredFlag      ; reset timer expiration flag                                         ; 
LDA #$02                      ; output time-up screen to buffer                                     ; 
JMP OutputInter                                                                                     ; 
NoTimeUp:  INC ScreenRoutineTask; increment control task 2 tasks forward                            ;  B
JMP IncSubtask                                                                                      ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DisplayIntermediate:                                                                                ;  B
LDA OperMode                  ; check primary mode of operation                                     ; 
BEQ NoInter                   ; if in title screen mode, skip this                                  ; 
CMP #GameOverModeValue        ; are we in game over mode?                                           ;  B
BEQ GameOverInter             ; if so, proceed to display game over screen                          ; 
LDA AltEntranceControl        ; otherwise check for mode of alternate entry                         ;  B
BNE NoInter                   ; and branch if found                                                 ; 
LDY AreaType                  ; check if we are on castle level                                     ;  B
CPY #$03                      ; and if so, branch (possibly residual)                               ; 
BEQ PlayerInter                                                                                     ; 
LDA DisableIntermediate       ; if this flag is set, skip intermediate lives display                ;  B
BNE NoInter                   ; and jump to specific task, otherwise                                ; 
PlayerInter:  JSR DrawPlayer_Intermediate; put player in appropriate place for                      ;  B
LDA #$01                      ; lives display, then output lives display to buffer                  ; 
OutputInter:  JSR WriteGameText                                                                     ;  B
JSR ResetScreenTimer                                                                                ; 
LDA #$00                                                                                            ; 
STA DisableScreenFlag         ; reenable screen output                                              ; 
RTS                                                                                                 ; 
GameOverInter:  LDA #$12      ; set screen timer                                                    ;  B
STA ScreenTimer                                                                                     ; 
LDA #$03                      ; output game over screen to buffer                                   ; 
JSR WriteGameText                                                                                   ; 
JMP IncModeTask_B                                                                                   ; 
NoInter:  LDA #$08            ; set for specific task and leave                                     ;  B
STA ScreenRoutineTask                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
AreaParserTaskControl:                                                                              ;  B
INC DisableScreenFlag         ; turn off screen                                                     ; 
TaskLoop:  JSR AreaParserTaskHandler; render column set of current area                             ;  B
LDA AreaParserTaskNum         ; check number of tasks                                               ; 
BNE TaskLoop                  ; if tasks still not all done, do another one                         ; 
DEC ColumnSets                ; do we need to render more column sets?                              ;  B
BPL OutputCol                                                                                       ; 
INC ScreenRoutineTask         ; if not, move on to the next task                                    ;  B
OutputCol:  LDA #$06          ; set vram buffer to output rendered column set                       ;  B
STA VRAM_Buffer_AddrCtrl      ; on next NMI                                                         ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; $00 - vram buffer address table low                                 ; 
                              ; $01 - vram buffer address table high                                ; 
                                                                                                    ; 
DrawTitleScreen:                                                                                    ;  B
LDA OperMode                  ; are we in title screen mode?                                        ; 
BNE IncModeTask_B             ; if not, exit                                                        ; 
LDA                           ; load address $1ec0 into                                             ;  B
STA PPU_ADDRESS               ; the vram address register                                           ; 
LDA                                                                                                 ; 
STA PPU_ADDRESS                                                                                     ; 
LDA #$03                      ; put address $0300 into                                              ; 
STA $01                       ; the indirect at $00                                                 ; 
LDY #$00                                                                                            ; 
STY $00                                                                                             ; 
LDA PPU_DATA                  ; do one garbage read                                                 ; 
OutputTScr:  LDA PPU_DATA     ; get title screen from chr-rom                                       ;  B
STA ($00),Y                   ; store 256 bytes into buffer                                         ; 
INY                                                                                                 ; 
BNE ChkHiByte                 ; if not past 256 bytes, do not increment                             ; 
INC $01                       ; otherwise increment high byte of indirect                           ;  B
ChkHiByte:  LDA $01           ; check high byte?                                                    ;  B
CMP #$04                      ; at $0400?                                                           ; 
BNE OutputTScr                ; if not, loop back and do another                                    ; 
CPY #$3a                      ; check if offset points past end of data                             ;  B
BCC OutputTScr                ; if not, loop back and do another                                    ; 
LDA #$05                      ; set buffer transfer control to $0300,                               ;  B
JMP SetVRAMAddr_B             ; increment task and exit                                             ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
ClearBuffersDrawIcon:                                                                               ;  B
LDA OperMode                  ; check game mode                                                     ; 
BNE IncModeTask_B             ; if not title screen mode, leave                                     ; 
LDX #$00                      ; otherwise, clear buffer space                                       ;  B
TScrClear:  STA VRAM_Buffer1-1,X                                                                    ;  B
                                                                                                    ; 
DEX                                                                                                 ; 
BNE TScrClear                                                                                       ; 
JSR DrawMushroomIcon          ; draw player select icon                                             ;  B
IncSubtask:  INC ScreenRoutineTask; move onto next task                                             ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
WriteTopScore:                                                                                      ;  B
LDA #$fa                      ; run display routine to display top score on title                   ; 
JSR UpdateNumber                                                                                    ; 
IncModeTask_B:  INC OperMode_Task; move onto next mode                                              ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GameText:                                                                                           ;  B
TopStatusBarLine:                                                                                   ;  B
DATA: ByteValue(value=32), ByteValue(value=67), ByteValue(value=5), ByteValue(value=22), ByteValue(value=10), ByteValue(value=27), ByteValue(value=18), ByteValue(value=24); "MARIO"; 
DATA: ByteValue(value=32), ByteValue(value=82), ByteValue(value=11), ByteValue(value=32), ByteValue(value=24), ByteValue(value=27), ByteValue(value=21), ByteValue(value=13); "WORLD  TIME"; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=29), ByteValue(value=18), ByteValue(value=22), ByteValue(value=14); 
DATA: ByteValue(value=32), ByteValue(value=104), ByteValue(value=5), ByteValue(value=0), ByteValue(value=36), ByteValue(value=36), ByteValue(value=46), ByteValue(value=41); score trailing digit and coin display; 
DATA: ByteValue(value=35), ByteValue(value=192), ByteValue(value=127), ByteValue(value=170); attribute table data, clears name table 0 to palette 2; 
DATA: ByteValue(value=35), ByteValue(value=194), ByteValue(value=1), ByteValue(value=234); attribute table data, used for coin icon in status bar; 
DATA: ByteValue(value=255)    ; end of data block                                                   ; 
                                                                                                    ; 
WorldLivesDisplay:                                                                                  ;  B
DATA: ByteValue(value=33), ByteValue(value=205), ByteValue(value=7), ByteValue(value=36), ByteValue(value=36); cross with spaces used on; 
DATA: ByteValue(value=41), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); lives display; 
DATA: ByteValue(value=33), ByteValue(value=75), ByteValue(value=9), ByteValue(value=32), ByteValue(value=24); "WORLD  - " used on lives display; 
DATA: ByteValue(value=27), ByteValue(value=21), ByteValue(value=13), ByteValue(value=36), ByteValue(value=36), ByteValue(value=40), ByteValue(value=36); 
DATA: ByteValue(value=34), ByteValue(value=12), ByteValue(value=71), ByteValue(value=36); possibly used to clear time up; 
DATA: ByteValue(value=35), ByteValue(value=220), ByteValue(value=1), ByteValue(value=186); attribute table data for crown if more than 9 lives; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
TwoPlayerTimeUp:                                                                                    ;  B
DATA: ByteValue(value=33), ByteValue(value=205), ByteValue(value=5), ByteValue(value=22), ByteValue(value=10), ByteValue(value=27), ByteValue(value=18), ByteValue(value=24); "MARIO"; 
OnePlayerTimeUp:                                                                                    ;  B
DATA: ByteValue(value=34), ByteValue(value=12), ByteValue(value=7), ByteValue(value=29), ByteValue(value=18), ByteValue(value=22), ByteValue(value=14), ByteValue(value=36), ByteValue(value=30), ByteValue(value=25); "TIME UP"; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
TwoPlayerGameOver:                                                                                  ;  B
DATA: ByteValue(value=33), ByteValue(value=205), ByteValue(value=5), ByteValue(value=22), ByteValue(value=10), ByteValue(value=27), ByteValue(value=18), ByteValue(value=24); "MARIO"; 
OnePlayerGameOver:                                                                                  ;  B
DATA: ByteValue(value=34), ByteValue(value=11), ByteValue(value=9), ByteValue(value=16), ByteValue(value=10), ByteValue(value=22), ByteValue(value=14), ByteValue(value=36); "GAME OVER"; 
DATA: ByteValue(value=24), ByteValue(value=31), ByteValue(value=14), ByteValue(value=27)            ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
WarpZoneWelcome:                                                                                    ;  B
DATA: ByteValue(value=37), ByteValue(value=132), ByteValue(value=21), ByteValue(value=32), ByteValue(value=14), ByteValue(value=21), ByteValue(value=12), ByteValue(value=24), ByteValue(value=22); "WELCOME TO WARP ZONE!"; 
DATA: ByteValue(value=14), ByteValue(value=36), ByteValue(value=29), ByteValue(value=24), ByteValue(value=36), ByteValue(value=32), ByteValue(value=10), ByteValue(value=27), ByteValue(value=25); 
DATA: ByteValue(value=36), ByteValue(value=35), ByteValue(value=24), ByteValue(value=23), ByteValue(value=14), ByteValue(value=43); 
DATA: ByteValue(value=38), ByteValue(value=37), ByteValue(value=1), ByteValue(value=36); placeholder for left pipe; 
DATA: ByteValue(value=38), ByteValue(value=45), ByteValue(value=1), ByteValue(value=36); placeholder for middle pipe; 
DATA: ByteValue(value=38), ByteValue(value=53), ByteValue(value=1), ByteValue(value=36); placeholder for right pipe; 
DATA: ByteValue(value=39), ByteValue(value=217), ByteValue(value=70), ByteValue(value=170); attribute data; 
DATA: ByteValue(value=39), ByteValue(value=225), ByteValue(value=69), ByteValue(value=170)          ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
LuigiName:                                                                                          ;  B
DATA: ByteValue(value=21), ByteValue(value=30), ByteValue(value=18), ByteValue(value=16), ByteValue(value=18); "LUIGI", no address or length; 
                                                                                                    ; 
WarpZoneNumbers:                                                                                    ;  B
DATA: ByteValue(value=4), ByteValue(value=3), ByteValue(value=2), ByteValue(value=0); warp zone numbers, note spaces on middle; 
DATA: ByteValue(value=36), ByteValue(value=5), ByteValue(value=36), ByteValue(value=0); zone, partly responsible for; 
DATA: ByteValue(value=8), ByteValue(value=7), ByteValue(value=6), ByteValue(value=0); the minus world; 
                                                                                                    ; 
GameTextOffsets:                                                                                    ;  B
DATA: Expr(expr=TopStatusBarLine-GameText), Expr(expr=TopStatusBarLine-GameText)                    ; 
DATA: Expr(expr=WorldLivesDisplay-GameText), Expr(expr=WorldLivesDisplay-GameText)                  ; 
DATA: Expr(expr=TwoPlayerTimeUp-GameText), Expr(expr=OnePlayerTimeUp-GameText)                      ; 
DATA: Expr(expr=TwoPlayerGameOver-GameText), Expr(expr=OnePlayerGameOver-GameText)                  ; 
DATA: Expr(expr=WarpZoneWelcome-GameText), Expr(expr=WarpZoneWelcome-GameText)                      ; 
                                                                                                    ; 
WriteGameText:                                                                                      ; fun(A):  B
PHA                           ; save text number to stack                                           ; 
ASL                                                                                                 ; 
TAY                           ; multiply by 2 and use as offset                                     ; 
CPY #$04                      ; if set to do top status bar or world/lives display,                 ; 
BCC LdGameText                ; branch to use current offset as-is                                  ; 
CPY #$08                      ; if set to do time-up or game over,                                  ;  B
BCC Chk2Players               ; branch to check players                                             ; 
LDY #$08                      ; otherwise warp zone, therefore set offset                           ;  B
Chk2Players:  LDA NumberOfPlayers; check for number of players                                      ;  B
BNE LdGameText                ; if there are two, use current offset to also print name             ; 
INY                           ; otherwise increment offset by one to not print name                 ;  B
LdGameText:  LDX GameTextOffsets,Y; get offset to message we want to print                          ;  B
LDY #$00                                                                                            ; 
GameTextLoop:  LDA GameText,X ; load message data                                                   ;  B
CMP #$ff                      ; check for terminator                                                ; 
BEQ EndGameText               ; branch to end text if found                                         ; 
STA VRAM_Buffer1,Y            ; otherwise write data to buffer                                      ;  B
INX                           ; and increment increment                                             ; 
INY                                                                                                 ; 
BNE GameTextLoop              ; do this for 256 bytes if no terminator found                        ; 
EndGameText:  LDA #$00        ; put null terminator at end                                          ;  B
STA VRAM_Buffer1,Y                                                                                  ; 
PLA                           ; pull original text number from stack                                ; 
TAX                                                                                                 ; 
CMP #$04                      ; are we printing warp zone?                                          ; 
BCS PrintWarpZoneNumbers                                                                            ; 
DEX                           ; are we printing the world/lives display?                            ;  B
BNE CheckPlayerName           ; if not, branch to check player's name                               ; 
LDA NumberofLives             ; otherwise, check number of lives                                    ;  B
CLC                           ; and increment by one for display                                    ; 
ADC #$01                                                                                            ; 
CMP #10                       ; more than 9 lives?                                                  ; 
BCC PutLives                                                                                        ; 
SBC #10                       ; if so, subtract 10 and put a crown tile                             ;  B
LDY #$9f                      ; next to the difference...strange things happen if                   ; 
STY VRAM_Buffer1+7            ; the number of lives exceeds 19                                      ; 
PutLives:  STA VRAM_Buffer1+8                                                                       ;  B
LDY WorldNumber               ; write world and level numbers (incremented for display)             ; 
INY                           ; to the buffer in the spaces surrounding the dash                    ; 
STY VRAM_Buffer1+19                                                                                 ; 
LDY LevelNumber                                                                                     ; 
INY                                                                                                 ; 
STY VRAM_Buffer1+21           ; we're done here                                                     ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
CheckPlayerName:                                                                                    ;  B
LDA NumberOfPlayers           ; check number of players                                             ; 
BEQ ExitChkName               ; if only 1 player, leave                                             ; 
LDA CurrentPlayer             ; load current player                                                 ;  B
DEX                           ; check to see if current message number is for time up               ; 
BNE ChkLuigi                                                                                        ; 
LDY OperMode                  ; check for game over mode                                            ;  B
CPY #GameOverModeValue                                                                              ; 
BEQ ChkLuigi                                                                                        ; 
EOR #%00000001                ; if not, must be time up, invert d0 to do other player               ;  B
ChkLuigi:  LSR                                                                                      ;  B
BCC ExitChkName               ; if mario is current player, do not change the name                  ; 
LDY #$04                                                                                            ;  B
NameLoop:  LDA LuigiName,Y    ; otherwise, replace "MARIO" with "LUIGI"                             ;  B
STA VRAM_Buffer1+3,Y                                                                                ; 
DEY                                                                                                 ; 
BPL NameLoop                  ; do this until each letter is replaced                               ; 
ExitChkName:  RTS                                                                                   ;  B
                                                                                                    ;  B
PrintWarpZoneNumbers:                                                                               ;  B
SBC #$04                      ; subtract 4 and then shift to the left                               ; 
ASL                           ; twice to get proper warp zone number                                ; 
ASL                           ; offset                                                              ; 
TAX                                                                                                 ; 
LDY #$00                                                                                            ; 
WarpNumLoop:  LDA WarpZoneNumbers,X; print warp zone numbers into the                               ;  B
STA VRAM_Buffer1+27,Y         ; placeholders from earlier                                           ; 
INX                                                                                                 ; 
INY                           ; put a number in every fourth space                                  ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
CPY #$0c                                                                                            ; 
BCC WarpNumLoop                                                                                     ; 
LDA #$2c                      ; load new buffer pointer at end of message                           ;  B
JMP SetVRAMOffset                                                                                   ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
ResetSpritesAndScreenTimer:                                                                         ;  B
LDA ScreenTimer               ; check if screen timer has expired                                   ; 
BNE NoReset                   ; if not, branch to leave                                             ; 
JSR MoveAllSpritesOffscreen   ; otherwise reset sprites now                                         ;  B
                                                                                                    ; 
ResetScreenTimer:                                                                                   ; fun():  B
LDA #$07                      ; reset timer again                                                   ; 
STA ScreenTimer                                                                                     ; 
INC ScreenRoutineTask         ; move onto next task                                                 ; 
NoReset:  RTS                                                                                       ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - temp vram buffer offset                                       ; 
                              ; $01 - temp metatile buffer offset                                   ; 
                              ; $02 - temp metatile graphics table offset                           ; 
                              ; $03 - used to store attribute bits                                  ; 
                              ; $04 - used to determine attribute table row                         ; 
                              ; $05 - used to determine attribute table column                      ; 
                              ; $06 - metatile graphics table address low                           ; 
                              ; $07 - metatile graphics table address high                          ; 
                                                                                                    ; 
RenderAreaGraphics:                                                                                 ;  B
LDA CurrentColumnPos          ; store LSB of where we're at                                         ; 
AND #$01                                                                                            ; 
STA $05                                                                                             ; 
LDY VRAM_Buffer2_Offset       ; store vram buffer offset                                            ; 
STY $00                                                                                             ; 
LDA CurrentNTAddr_Low         ; get current name table address we're supposed to render             ; 
STA VRAM_Buffer2+1,Y                                                                                ; 
LDA CurrentNTAddr_High                                                                              ; 
STA VRAM_Buffer2,Y                                                                                  ; 
LDA #$9a                      ; store length byte of 26 here with d7 set                            ; 
STA VRAM_Buffer2+2,Y          ; to increment by 32 (in columns)                                     ; 
LDA #$00                      ; init attribute row                                                  ; 
STA $04                                                                                             ; 
TAX                                                                                                 ; 
DrawMTLoop:  STX $01          ; store init value of 0 or incremented offset for buffer              ;  B
LDA MetatileBuffer,X          ; get first metatile number, and mask out all but 2 MSB               ; 
AND #%11000000                                                                                      ; 
STA $03                       ; store attribute table bits here                                     ; 
ASL                           ; note that metatile format is:                                       ; 
ROL                           ; %xx000000 - attribute table bits,                                   ; 
ROL                           ; %00xxxxxx - metatile number                                         ; 
TAY                           ; rotate bits to d1-d0 and use as offset here                         ; 
LDA MetatileGraphics_Low,Y    ; get address to graphics table from here                             ; 
STA $06                                                                                             ; 
LDA MetatileGraphics_High,Y                                                                         ; 
STA $07                                                                                             ; 
LDA MetatileBuffer,X          ; get metatile number again                                           ; 
ASL                           ; multiply by 4 and use as tile offset                                ; 
ASL                                                                                                 ; 
STA $02                                                                                             ; 
LDA AreaParserTaskNum         ; get current task number for level processing and                    ; 
AND #%00000001                ; mask out all but LSB, then invert LSB, multiply by 2                ; 
EOR #%00000001                ; to get the correct column position in the metatile,                 ; 
ASL                           ; then add to the tile offset so we can draw either side              ; 
ADC $02                       ; of the metatiles                                                    ; 
TAY                                                                                                 ; 
LDX $00                       ; use vram buffer offset from before as X                             ; 
LDA ($06),Y                                                                                         ; 
STA VRAM_Buffer2+3,X          ; get first tile number (top left or top right) and store             ; 
INY                                                                                                 ; 
LDA ($06),Y                   ; now get the second (bottom left or bottom right) and store          ; 
STA VRAM_Buffer2+4,X                                                                                ; 
LDY $04                       ; get current attribute row                                           ; 
LDA $05                       ; get LSB of current column where we're at, and                       ; 
BNE RightCheck                ; branch if set (clear = left attrib, set = right)                    ; 
LDA $01                       ; get current row we're rendering                                     ;  B
LSR                           ; branch if LSB set (clear = top left, set = bottom left)             ; 
BCS LLeft                                                                                           ; 
ROL $03                       ; rotate attribute bits 3 to the left                                 ;  B
ROL $03                       ; thus in d1-d0, for upper left square                                ; 
ROL $03                                                                                             ; 
JMP SetAttrib                                                                                       ; 
RightCheck:  LDA $01          ; get LSB of current row we're rendering                              ;  B
LSR                           ; branch if set (clear = top right, set = bottom right)               ; 
BCS NextMTRow                                                                                       ; 
LSR $03                       ; shift attribute bits 4 to the right                                 ;  B
LSR $03                       ; thus in d3-d2, for upper right square                               ; 
LSR $03                                                                                             ; 
LSR $03                                                                                             ; 
JMP SetAttrib                                                                                       ; 
LLeft:  LSR $03               ; shift attribute bits 2 to the right                                 ;  B
LSR $03                       ; thus in d5-d4 for lower left square                                 ; 
NextMTRow:  INC $04           ; move onto next attribute row                                        ;  B
SetAttrib:  LDA AttributeBuffer,Y; get previously saved bits from before                            ;  B
ORA $03                       ; if any, and put new bits, if any, onto                              ; 
STA AttributeBuffer,Y         ; the old, and store                                                  ; 
INC $00                       ; increment vram buffer offset by 2                                   ; 
INC $00                                                                                             ; 
LDX $01                       ; get current gfx buffer row, and check for                           ; 
INX                           ; the bottom of the screen                                            ; 
CPX #$0d                                                                                            ; 
BCC DrawMTLoop                ; if not there yet, loop back                                         ; 
LDY $00                       ; get current vram buffer offset, increment by 3                      ;  B
INY                           ; (for name table address and length bytes)                           ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
LDA #$00                                                                                            ; 
STA VRAM_Buffer2,Y            ; put null terminator at end of data for name table                   ; 
STY VRAM_Buffer2_Offset       ; store new buffer offset                                             ; 
INC CurrentNTAddr_Low         ; increment name table address low                                    ; 
LDA CurrentNTAddr_Low         ; check current low byte                                              ; 
AND #%00011111                ; if no wraparound, just skip this part                               ; 
BNE ExitDrawM                                                                                       ; 
LDA #$80                      ; if wraparound occurs, make sure low byte stays                      ;  B
STA CurrentNTAddr_Low         ; just under the status bar                                           ; 
LDA CurrentNTAddr_High        ; and then invert d2 of the name table address high                   ; 
EOR #%00000100                ; to move onto the next appropriate name table                        ; 
STA CurrentNTAddr_High                                                                              ; 
ExitDrawM:  JMP SetVRAMCtrl   ; jump to set buffer to $0341 and leave                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - temp attribute table address high (big endian order this time!); 
                              ; $01 - temp attribute table address low                              ; 
                                                                                                    ; 
RenderAttributeTables:                                                                              ; fun():  B
LDA CurrentNTAddr_Low         ; get low byte of next name table address                             ; 
AND #%00011111                ; to be written to, mask out all but 5 LSB,                           ; 
SEC                           ; subtract four                                                       ; 
SBC #$04                                                                                            ; 
AND #%00011111                ; mask out bits again and store                                       ; 
STA $01                                                                                             ; 
LDA CurrentNTAddr_High        ; get high byte and branch if borrow not set                          ; 
BCS SetATHigh                                                                                       ; 
EOR #%00000100                ; otherwise invert d2                                                 ;  B
SetATHigh:  AND #%00000100    ; mask out all other bits                                             ;  B
ORA #$23                      ; add $2300 to the high byte and store                                ; 
STA $00                                                                                             ; 
LDA $01                       ; get low byte - 4, divide by 4, add offset for                       ; 
LSR                           ; attribute table and store                                           ; 
LSR                                                                                                 ; 
ADC #$c0                      ; we should now have the appropriate block of                         ; 
STA $01                       ; attribute table in our temp address                                 ; 
LDX #$00                                                                                            ; 
LDY VRAM_Buffer2_Offset       ; get buffer offset                                                   ; 
AttribLoop:  LDA $00                                                                                ;  B
STA VRAM_Buffer2,Y            ; store high byte of attribute table address                          ; 
LDA $01                                                                                             ; 
CLC                           ; get low byte, add 8 because we want to start                        ; 
ADC #$08                      ; below the status bar, and store                                     ; 
STA VRAM_Buffer2+1,Y                                                                                ; 
STA $01                       ; also store in temp again                                            ; 
LDA AttributeBuffer,X         ; fetch current attribute table byte and store                        ; 
STA VRAM_Buffer2+3,Y          ; in the buffer                                                       ; 
LDA #$01                                                                                            ; 
STA VRAM_Buffer2+2,Y          ; store length of 1 in buffer                                         ; 
LSR                                                                                                 ; 
STA AttributeBuffer,X         ; clear current byte in attribute buffer                              ; 
INY                           ; increment buffer offset by 4 bytes                                  ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INX                           ; increment attribute offset and check to see                         ; 
CPX #$07                      ; if we're at the end yet                                             ; 
BCC AttribLoop                                                                                      ; 
STA VRAM_Buffer2,Y            ; put null terminator at the end                                      ;  B
STY VRAM_Buffer2_Offset       ; store offset in case we want to do any more                         ; 
SetVRAMCtrl:  LDA #$06                                                                              ;  B
STA VRAM_Buffer_AddrCtrl      ; set buffer to $0341 and leave                                       ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; $00 - used as temporary counter in ColorRotation                    ; 
                                                                                                    ; 
ColorRotatePalette:                                                                                 ;  B
DATA: ByteValue(value=39), ByteValue(value=39), ByteValue(value=39), ByteValue(value=23), ByteValue(value=7), ByteValue(value=23); 
                                                                                                    ; 
BlankPalette:                                                                                       ;  B
DATA: ByteValue(value=63), ByteValue(value=12), ByteValue(value=4), ByteValue(value=255), ByteValue(value=255), ByteValue(value=255), ByteValue(value=255), ByteValue(value=0); 
                                                                                                    ; 
                              ; used based on area type                                             ; 
Palette3Data:                                                                                       ;  B
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=18), ByteValue(value=15)             ; 
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=23), ByteValue(value=15)             ; 
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=23), ByteValue(value=28)             ; 
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=23), ByteValue(value=0)              ; 
                                                                                                    ; 
ColorRotation:                                                                                      ; fun():  B
LDA FrameCounter              ; get frame counter                                                   ; 
AND #$07                      ; mask out all but three LSB                                          ; 
BNE ExitColorRot              ; branch if not set to zero to do this every eighth frame             ; 
LDX VRAM_Buffer1_Offset       ; check vram buffer offset                                            ;  B
CPX #$31                                                                                            ; 
BCS ExitColorRot              ; if offset over 48 bytes, branch to leave                            ; 
TAY                           ; otherwise use frame counter's 3 LSB as offset here                  ;  B
GetBlankPal:  LDA BlankPalette,Y; get blank palette for palette 3                                   ;  B
STA VRAM_Buffer1,X            ; store it in the vram buffer                                         ; 
INX                           ; increment offsets                                                   ; 
INY                                                                                                 ; 
CPY #$08                                                                                            ; 
BCC GetBlankPal               ; do this until all bytes are copied                                  ; 
LDX VRAM_Buffer1_Offset       ; get current vram buffer offset                                      ;  B
LDA #$03                                                                                            ; 
STA $00                       ; set counter here                                                    ; 
LDA AreaType                  ; get area type                                                       ; 
ASL                           ; multiply by 4 to get proper offset                                  ; 
ASL                                                                                                 ; 
TAY                           ; save as offset here                                                 ; 
GetAreaPal:  LDA Palette3Data,Y; fetch palette to be written based on area type                     ;  B
STA VRAM_Buffer1+3,X          ; store it to overwrite blank palette in vram buffer                  ; 
INY                                                                                                 ; 
INX                                                                                                 ; 
DEC $00                       ; decrement counter                                                   ; 
BPL GetAreaPal                ; do this until the palette is all copied                             ; 
LDX VRAM_Buffer1_Offset       ; get current vram buffer offset                                      ;  B
LDY ColorRotateOffset         ; get color cycling offset                                            ; 
LDA ColorRotatePalette,Y                                                                            ; 
STA VRAM_Buffer1+4,X          ; get and store current color in second slot of palette               ; 
LDA VRAM_Buffer1_Offset                                                                             ; 
CLC                           ; add seven bytes to vram buffer offset                               ; 
ADC #$07                                                                                            ; 
STA VRAM_Buffer1_Offset                                                                             ; 
INC ColorRotateOffset         ; increment color cycling offset                                      ; 
LDA ColorRotateOffset                                                                               ; 
CMP #$06                      ; check to see if it's still in range                                 ; 
BCC ExitColorRot              ; if so, branch to leave                                              ; 
LDA #$00                                                                                            ;  B
STA ColorRotateOffset         ; otherwise, init to keep it in range                                 ; 
ExitColorRot:  RTS            ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - temp store for offset control bit                             ; 
                              ; $01 - temp vram buffer offset                                       ; 
                              ; $02 - temp store for vertical high nybble in block buffer routine   ; 
                              ; $03 - temp adder for high byte of name table address                ; 
                              ; $04, $05 - name table address low/high                              ; 
                              ; $06, $07 - block buffer address low/high                            ; 
                                                                                                    ; 
BlockGfxData:                                                                                       ;  B
DATA: ByteValue(value=69), ByteValue(value=69), ByteValue(value=71), ByteValue(value=71)            ; 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71)            ; 
DATA: ByteValue(value=87), ByteValue(value=88), ByteValue(value=89), ByteValue(value=90)            ; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36)            ; 
DATA: ByteValue(value=38), ByteValue(value=38), ByteValue(value=38), ByteValue(value=38)            ; 
                                                                                                    ; 
RemoveCoin_Axe:                                                                                     ; fun():  B
LDY #$41                      ; set low byte so offset points to $0341                              ; 
LDA #$03                      ; load offset for default blank metatile                              ; 
LDX AreaType                  ; check area type                                                     ; 
BNE WriteBlankMT              ; if not water type, use offset                                       ; 
LDA #$04                      ; otherwise load offset for blank metatile used in water              ;  B
WriteBlankMT:  JSR PutBlockMetatile; do a sub to write blank metatile to vram buffer                ;  B
LDA #$06                                                                                            ; 
STA VRAM_Buffer_AddrCtrl      ; set vram address controller to $0341 and leave                      ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ReplaceBlockMetatile:                                                                               ; fun():  B
JSR WriteBlockMetatile        ; write metatile to vram buffer to replace block object               ; 
INC Block_ResidualCounter     ; increment unused counter (residual code)                            ; 
DEC Block_RepFlag,X           ; decrement flag (residual code)                                      ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
DestroyBlockMetatile:                                                                               ; fun():  B
LDA #$00                      ; force blank metatile if branched/jumped to this point               ; 
                                                                                                    ; 
WriteBlockMetatile:                                                                                 ; fun(A):  B
LDY #$03                      ; load offset for blank metatile                                      ; 
CMP #$00                      ; check contents of A for blank metatile                              ; 
BEQ UseBOffset                ; branch if found (unconditional if branched from 8a6b)               ; 
LDY #$00                      ; load offset for brick metatile w/ line                              ;  B
CMP #$58                                                                                            ; 
BEQ UseBOffset                ; use offset if metatile is brick with coins (w/ line)                ; 
CMP #$51                                                                                            ;  B
BEQ UseBOffset                ; use offset if metatile is breakable brick w/ line                   ; 
INY                           ; increment offset for brick metatile w/o line                        ;  B
CMP #$5d                                                                                            ; 
BEQ UseBOffset                ; use offset if metatile is brick with coins (w/o line)               ; 
CMP #$52                                                                                            ;  B
BEQ UseBOffset                ; use offset if metatile is breakable brick w/o line                  ; 
INY                           ; if any other metatile, increment offset for empty block             ;  B
UseBOffset:  TYA              ; put Y in A                                                          ;  B
LDY VRAM_Buffer1_Offset       ; get vram buffer offset                                              ; 
INY                           ; move onto next byte                                                 ; 
JSR PutBlockMetatile          ; get appropriate block data and write to vram buffer                 ; 
MoveVOffset:  DEY             ; decrement vram buffer offset                                        ; fun(Y):  B
TYA                           ; add 10 bytes to it                                                  ; 
CLC                                                                                                 ; 
ADC #10                                                                                             ; 
JMP SetVRAMOffset             ; branch to store as new vram buffer offset                           ; 
                                                                                                    ;  B
PutBlockMetatile:                                                                                   ; fun(XYA$06$02):  B
STX $00                       ; store control bit from SprDataOffset_Ctrl                           ; 
STY $01                       ; store vram buffer offset for next byte                              ; 
ASL                                                                                                 ; 
ASL                           ; multiply A by four and use as X                                     ; 
TAX                                                                                                 ; 
LDY #$20                      ; load high byte for name table 0                                     ; 
LDA $06                       ; get low byte of block buffer pointer                                ; 
CMP #$d0                      ; check to see if we're on odd-page block buffer                      ; 
BCC SaveHAdder                ; if not, use current high byte                                       ; 
LDY #$24                      ; otherwise load high byte for name table 1                           ;  B
SaveHAdder:  STY $03          ; save high byte here                                                 ;  B
AND #$0f                      ; mask out high nybble of block buffer pointer                        ; 
ASL                           ; multiply by 2 to get appropriate name table low byte                ; 
STA $04                       ; and then store it here                                              ; 
LDA #$00                                                                                            ; 
STA $05                       ; initialize temp high byte                                           ; 
LDA $02                       ; get vertical high nybble offset used in block buffer routine        ; 
CLC                                                                                                 ; 
ADC #$20                      ; add 32 pixels for the status bar                                    ; 
ASL                                                                                                 ; 
ROL $05                       ; shift and rotate d7 onto d0 and d6 into carry                       ; 
ASL                                                                                                 ; 
ROL $05                       ; shift and rotate d6 onto d0 and d5 into carry                       ; 
ADC $04                       ; add low byte of name table and carry to vertical high nybble        ; 
STA $04                       ; and store here                                                      ; 
LDA $05                       ; get whatever was in d7 and d6 of vertical high nybble               ; 
ADC #$00                      ; add carry                                                           ; 
CLC                                                                                                 ; 
ADC $03                       ; then add high byte of name table                                    ; 
STA $05                       ; store here                                                          ; 
LDY $01                       ; get vram buffer offset to be used                                   ; 
RemBridge:  LDA BlockGfxData,X; write top left and top right                                        ; fun($04$05$00):  B
STA VRAM_Buffer1+2,Y          ; tile numbers into first spot                                        ; 
LDA BlockGfxData+1,X                                                                                ; 
STA VRAM_Buffer1+3,Y                                                                                ; 
LDA BlockGfxData+2,X          ; write bottom left and bottom                                        ; 
STA VRAM_Buffer1+7,Y          ; right tiles numbers into                                            ; 
LDA BlockGfxData+3,X          ; second spot                                                         ; 
STA VRAM_Buffer1+8,Y                                                                                ; 
LDA $04                                                                                             ; 
STA VRAM_Buffer1,Y            ; write low byte of name table                                        ; 
CLC                           ; into first slot as read                                             ; 
ADC #$20                      ; add 32 bytes to value                                               ; 
STA VRAM_Buffer1+5,Y          ; write low byte of name table                                        ; 
LDA $05                       ; plus 32 bytes into second slot                                      ; 
STA VRAM_Buffer1-1,Y          ; write high byte of name                                             ; 
STA VRAM_Buffer1+4,Y          ; table address to both slots                                         ; 
LDA #$02                                                                                            ; 
STA VRAM_Buffer1+1,Y          ; put length of 2 in                                                  ; 
STA VRAM_Buffer1+6,Y          ; both slots                                                          ; 
LDA #$00                                                                                            ; 
STA VRAM_Buffer1+9,Y          ; put null terminator at end                                          ; 
LDX $00                       ; get offset control bit here                                         ; 
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; METATILE GRAPHICS TABLE                                             ; 
                                                                                                    ; 
MetatileGraphics_Low:                                                                               ;  B
DATA: Expr(expr=<Palette0_MTiles), Expr(expr=<Palette1_MTiles), Expr(expr=<Palette2_MTiles), Expr(expr=<Palette3_MTiles); 
                                                                                                    ; 
MetatileGraphics_High:                                                                              ;  B
DATA: Expr(expr=>Palette0_MTiles), Expr(expr=>Palette1_MTiles), Expr(expr=>Palette2_MTiles), Expr(expr=>Palette3_MTiles); 
                                                                                                    ; 
Palette0_MTiles:                                                                                    ;  B
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); blank     ; 
DATA: ByteValue(value=39), ByteValue(value=39), ByteValue(value=39), ByteValue(value=39); black metatile; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=53); bush left ; 
DATA: ByteValue(value=54), ByteValue(value=37), ByteValue(value=55), ByteValue(value=37); bush middle; 
DATA: ByteValue(value=36), ByteValue(value=56), ByteValue(value=36), ByteValue(value=36); bush right; 
DATA: ByteValue(value=36), ByteValue(value=48), ByteValue(value=48), ByteValue(value=38); mountain left; 
DATA: ByteValue(value=38), ByteValue(value=38), ByteValue(value=52), ByteValue(value=38); mountain left bottom/middle center; 
DATA: ByteValue(value=36), ByteValue(value=49), ByteValue(value=36), ByteValue(value=50); mountain middle top; 
DATA: ByteValue(value=51), ByteValue(value=38), ByteValue(value=36), ByteValue(value=51); mountain right; 
DATA: ByteValue(value=52), ByteValue(value=38), ByteValue(value=38), ByteValue(value=38); mountain right bottom; 
DATA: ByteValue(value=38), ByteValue(value=38), ByteValue(value=38), ByteValue(value=38); mountain middle bottom; 
DATA: ByteValue(value=36), ByteValue(value=192), ByteValue(value=36), ByteValue(value=192); bridge guardrail; 
DATA: ByteValue(value=36), ByteValue(value=127), ByteValue(value=127), ByteValue(value=36); chain   ; 
DATA: ByteValue(value=184), ByteValue(value=186), ByteValue(value=185), ByteValue(value=187); tall tree top, top half; 
DATA: ByteValue(value=184), ByteValue(value=188), ByteValue(value=185), ByteValue(value=189); short tree top; 
DATA: ByteValue(value=186), ByteValue(value=188), ByteValue(value=187), ByteValue(value=189); tall tree top, bottom half; 
DATA: ByteValue(value=96), ByteValue(value=100), ByteValue(value=97), ByteValue(value=101); warp pipe end left, points up; 
DATA: ByteValue(value=98), ByteValue(value=102), ByteValue(value=99), ByteValue(value=103); warp pipe end right, points up; 
DATA: ByteValue(value=96), ByteValue(value=100), ByteValue(value=97), ByteValue(value=101); decoration pipe end left, points up; 
DATA: ByteValue(value=98), ByteValue(value=102), ByteValue(value=99), ByteValue(value=103); decoration pipe end right, points up; 
DATA: ByteValue(value=104), ByteValue(value=104), ByteValue(value=105), ByteValue(value=105); pipe shaft left; 
DATA: ByteValue(value=38), ByteValue(value=38), ByteValue(value=106), ByteValue(value=106); pipe shaft right; 
DATA: ByteValue(value=75), ByteValue(value=76), ByteValue(value=77), ByteValue(value=78); tree ledge left edge; 
DATA: ByteValue(value=77), ByteValue(value=79), ByteValue(value=77), ByteValue(value=79); tree ledge middle; 
DATA: ByteValue(value=77), ByteValue(value=78), ByteValue(value=80), ByteValue(value=81); tree ledge right edge; 
DATA: ByteValue(value=107), ByteValue(value=112), ByteValue(value=44), ByteValue(value=45); mushroom left edge; 
DATA: ByteValue(value=108), ByteValue(value=113), ByteValue(value=109), ByteValue(value=114); mushroom middle; 
DATA: ByteValue(value=110), ByteValue(value=115), ByteValue(value=111), ByteValue(value=116); mushroom right edge; 
DATA: ByteValue(value=134), ByteValue(value=138), ByteValue(value=135), ByteValue(value=139); sideways pipe end top; 
DATA: ByteValue(value=136), ByteValue(value=140), ByteValue(value=136), ByteValue(value=140); sideways pipe shaft top; 
DATA: ByteValue(value=137), ByteValue(value=141), ByteValue(value=105), ByteValue(value=105); sideways pipe joint top; 
DATA: ByteValue(value=142), ByteValue(value=145), ByteValue(value=143), ByteValue(value=146); sideways pipe end bottom; 
DATA: ByteValue(value=38), ByteValue(value=147), ByteValue(value=38), ByteValue(value=147); sideways pipe shaft bottom; 
DATA: ByteValue(value=144), ByteValue(value=148), ByteValue(value=105), ByteValue(value=105); sideways pipe joint bottom; 
DATA: ByteValue(value=164), ByteValue(value=233), ByteValue(value=234), ByteValue(value=235); seaplant; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); blank, used on bricks or blocks that are hit; 
DATA: ByteValue(value=36), ByteValue(value=47), ByteValue(value=36), ByteValue(value=61); flagpole ball; 
DATA: ByteValue(value=162), ByteValue(value=162), ByteValue(value=163), ByteValue(value=163); flagpole shaft; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); blank, used in conjunction with vines; 
                                                                                                    ; 
Palette1_MTiles:                                                                                    ;  B
DATA: ByteValue(value=162), ByteValue(value=162), ByteValue(value=163), ByteValue(value=163); vertical rope; 
DATA: ByteValue(value=153), ByteValue(value=36), ByteValue(value=153), ByteValue(value=36); horizontal rope; 
DATA: ByteValue(value=36), ByteValue(value=162), ByteValue(value=62), ByteValue(value=63); left pulley; 
DATA: ByteValue(value=91), ByteValue(value=92), ByteValue(value=36), ByteValue(value=163); right pulley; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); blank used for balance rope; 
DATA: ByteValue(value=157), ByteValue(value=71), ByteValue(value=158), ByteValue(value=71); castle top; 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=39), ByteValue(value=39); castle window left; 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); castle brick wall; 
DATA: ByteValue(value=39), ByteValue(value=39), ByteValue(value=71), ByteValue(value=71); castle window right; 
DATA: ByteValue(value=169), ByteValue(value=71), ByteValue(value=170), ByteValue(value=71); castle top w/ brick; 
DATA: ByteValue(value=155), ByteValue(value=39), ByteValue(value=156), ByteValue(value=39); entrance top; 
DATA: ByteValue(value=39), ByteValue(value=39), ByteValue(value=39), ByteValue(value=39); entrance bottom; 
DATA: ByteValue(value=82), ByteValue(value=82), ByteValue(value=82), ByteValue(value=82); green ledge stump; 
DATA: ByteValue(value=128), ByteValue(value=160), ByteValue(value=129), ByteValue(value=161); fence ; 
DATA: ByteValue(value=190), ByteValue(value=190), ByteValue(value=191), ByteValue(value=191); tree trunk; 
DATA: ByteValue(value=117), ByteValue(value=186), ByteValue(value=118), ByteValue(value=187); mushroom stump top; 
DATA: ByteValue(value=186), ByteValue(value=186), ByteValue(value=187), ByteValue(value=187); mushroom stump bottom; 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); breakable brick w/ line; 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); breakable brick; 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); breakable brick (not used); 
DATA: ByteValue(value=180), ByteValue(value=182), ByteValue(value=181), ByteValue(value=183); cracked rock terrain; 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); brick with line (power-up); 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); brick with line (vine); 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); brick with line (star); 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); brick with line (coins); 
DATA: ByteValue(value=69), ByteValue(value=71), ByteValue(value=69), ByteValue(value=71); brick with line (1-up); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); brick (power-up); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); brick (vine); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); brick (star); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); brick (coins); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); brick (1-up); 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); hidden block (1 coin); 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); hidden block (1-up); 
DATA: ByteValue(value=171), ByteValue(value=172), ByteValue(value=173), ByteValue(value=174); solid block (3-d block); 
DATA: ByteValue(value=93), ByteValue(value=94), ByteValue(value=93), ByteValue(value=94); solid block (white wall); 
DATA: ByteValue(value=193), ByteValue(value=36), ByteValue(value=193), ByteValue(value=36); bridge  ; 
DATA: ByteValue(value=198), ByteValue(value=200), ByteValue(value=199), ByteValue(value=201); bullet bill cannon barrel; 
DATA: ByteValue(value=202), ByteValue(value=204), ByteValue(value=203), ByteValue(value=205); bullet bill cannon top; 
DATA: ByteValue(value=42), ByteValue(value=42), ByteValue(value=64), ByteValue(value=64); bullet bill cannon bottom; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); blank used for jumpspring; 
DATA: ByteValue(value=36), ByteValue(value=71), ByteValue(value=36), ByteValue(value=71); half brick used for jumpspring; 
DATA: ByteValue(value=130), ByteValue(value=131), ByteValue(value=132), ByteValue(value=133); solid block (water level, green rock); 
DATA: ByteValue(value=36), ByteValue(value=71), ByteValue(value=36), ByteValue(value=71); half brick (???); 
DATA: ByteValue(value=134), ByteValue(value=138), ByteValue(value=135), ByteValue(value=139); water pipe top; 
DATA: ByteValue(value=142), ByteValue(value=145), ByteValue(value=143), ByteValue(value=146); water pipe bottom; 
DATA: ByteValue(value=36), ByteValue(value=47), ByteValue(value=36), ByteValue(value=61); flag ball (residual object); 
                                                                                                    ; 
Palette2_MTiles:                                                                                    ;  B
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=36), ByteValue(value=53); cloud left; 
DATA: ByteValue(value=54), ByteValue(value=37), ByteValue(value=55), ByteValue(value=37); cloud middle; 
DATA: ByteValue(value=36), ByteValue(value=56), ByteValue(value=36), ByteValue(value=36); cloud right; 
DATA: ByteValue(value=36), ByteValue(value=36), ByteValue(value=57), ByteValue(value=36); cloud bottom left; 
DATA: ByteValue(value=58), ByteValue(value=36), ByteValue(value=59), ByteValue(value=36); cloud bottom middle; 
DATA: ByteValue(value=60), ByteValue(value=36), ByteValue(value=36), ByteValue(value=36); cloud bottom right; 
DATA: ByteValue(value=65), ByteValue(value=38), ByteValue(value=65), ByteValue(value=38); water/lava top; 
DATA: ByteValue(value=38), ByteValue(value=38), ByteValue(value=38), ByteValue(value=38); water/lava; 
DATA: ByteValue(value=176), ByteValue(value=177), ByteValue(value=178), ByteValue(value=179); cloud level terrain; 
DATA: ByteValue(value=119), ByteValue(value=121), ByteValue(value=119), ByteValue(value=121); bowser's bridge; 
                                                                                                    ; 
Palette3_MTiles:                                                                                    ;  B
DATA: ByteValue(value=83), ByteValue(value=85), ByteValue(value=84), ByteValue(value=86); question block (coin); 
DATA: ByteValue(value=83), ByteValue(value=85), ByteValue(value=84), ByteValue(value=86); question block (power-up); 
DATA: ByteValue(value=165), ByteValue(value=167), ByteValue(value=166), ByteValue(value=168); coin  ; 
DATA: ByteValue(value=194), ByteValue(value=196), ByteValue(value=195), ByteValue(value=197); underwater coin; 
DATA: ByteValue(value=87), ByteValue(value=89), ByteValue(value=88), ByteValue(value=90); empty block; 
DATA: ByteValue(value=123), ByteValue(value=125), ByteValue(value=124), ByteValue(value=126); axe   ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; VRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM                           ; 
                                                                                                    ; 
WaterPaletteData:                                                                                   ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=32)                                  ; 
DATA: ByteValue(value=15), ByteValue(value=21), ByteValue(value=18), ByteValue(value=37)            ; 
DATA: ByteValue(value=15), ByteValue(value=58), ByteValue(value=26), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=18), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=39), ByteValue(value=18), ByteValue(value=15)            ; 
DATA: ByteValue(value=34), ByteValue(value=22), ByteValue(value=39), ByteValue(value=24)            ; 
DATA: ByteValue(value=15), ByteValue(value=16), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=15), ByteValue(value=15), ByteValue(value=48), ByteValue(value=16)            ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
GroundPaletteData:                                                                                  ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=32)                                  ; 
DATA: ByteValue(value=15), ByteValue(value=41), ByteValue(value=26), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=54), ByteValue(value=23), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=33), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=39), ByteValue(value=23), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=39), ByteValue(value=24)            ; 
DATA: ByteValue(value=15), ByteValue(value=26), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=15), ByteValue(value=15), ByteValue(value=54), ByteValue(value=23)            ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
UndergroundPaletteData:                                                                             ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=32)                                  ; 
DATA: ByteValue(value=15), ByteValue(value=41), ByteValue(value=26), ByteValue(value=9)             ; 
DATA: ByteValue(value=15), ByteValue(value=60), ByteValue(value=28), ByteValue(value=15)            ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=33), ByteValue(value=28)            ; 
DATA: ByteValue(value=15), ByteValue(value=39), ByteValue(value=23), ByteValue(value=28)            ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=39), ByteValue(value=24)            ; 
DATA: ByteValue(value=15), ByteValue(value=28), ByteValue(value=54), ByteValue(value=23)            ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=15), ByteValue(value=12), ByteValue(value=60), ByteValue(value=28)            ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
CastlePaletteData:                                                                                  ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=32)                                  ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=16), ByteValue(value=0)             ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=16), ByteValue(value=0)             ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=22), ByteValue(value=0)             ; 
DATA: ByteValue(value=15), ByteValue(value=39), ByteValue(value=23), ByteValue(value=0)             ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=39), ByteValue(value=24)            ; 
DATA: ByteValue(value=15), ByteValue(value=28), ByteValue(value=54), ByteValue(value=23)            ; 
DATA: ByteValue(value=15), ByteValue(value=22), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=15), ByteValue(value=0), ByteValue(value=48), ByteValue(value=16)             ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
DaySnowPaletteData:                                                                                 ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=4)                                   ; 
DATA: ByteValue(value=34), ByteValue(value=48), ByteValue(value=0), ByteValue(value=16)             ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
NightSnowPaletteData:                                                                               ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=4)                                   ; 
DATA: ByteValue(value=15), ByteValue(value=48), ByteValue(value=0), ByteValue(value=16)             ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
MushroomPaletteData:                                                                                ;  B
DATA: ByteValue(value=63), ByteValue(value=0), ByteValue(value=4)                                   ; 
DATA: ByteValue(value=34), ByteValue(value=39), ByteValue(value=22), ByteValue(value=15)            ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
BowserPaletteData:                                                                                  ;  B
DATA: ByteValue(value=63), ByteValue(value=20), ByteValue(value=4)                                  ; 
DATA: ByteValue(value=15), ByteValue(value=26), ByteValue(value=48), ByteValue(value=39)            ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
MarioThanksMessage:                                                                                 ;  B
                              ; "THANK YOU MARIO!"                                                  ; 
DATA: ByteValue(value=37), ByteValue(value=72), ByteValue(value=16)                                 ; 
DATA: ByteValue(value=29), ByteValue(value=17), ByteValue(value=10), ByteValue(value=23), ByteValue(value=20), ByteValue(value=36); 
DATA: ByteValue(value=34), ByteValue(value=24), ByteValue(value=30), ByteValue(value=36)            ; 
DATA: ByteValue(value=22), ByteValue(value=10), ByteValue(value=27), ByteValue(value=18), ByteValue(value=24), ByteValue(value=43); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
LuigiThanksMessage:                                                                                 ;  B
                              ; "THANK YOU LUIGI!"                                                  ; 
DATA: ByteValue(value=37), ByteValue(value=72), ByteValue(value=16)                                 ; 
DATA: ByteValue(value=29), ByteValue(value=17), ByteValue(value=10), ByteValue(value=23), ByteValue(value=20), ByteValue(value=36); 
DATA: ByteValue(value=34), ByteValue(value=24), ByteValue(value=30), ByteValue(value=36)            ; 
DATA: ByteValue(value=21), ByteValue(value=30), ByteValue(value=18), ByteValue(value=16), ByteValue(value=18), ByteValue(value=43); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
MushroomRetainerSaved:                                                                              ;  B
                              ; "BUT OUR PRINCESS IS IN"                                            ; 
DATA: ByteValue(value=37), ByteValue(value=197), ByteValue(value=22)                                ; 
DATA: ByteValue(value=11), ByteValue(value=30), ByteValue(value=29), ByteValue(value=36), ByteValue(value=24), ByteValue(value=30), ByteValue(value=27), ByteValue(value=36); 
DATA: ByteValue(value=25), ByteValue(value=27), ByteValue(value=18), ByteValue(value=23), ByteValue(value=12), ByteValue(value=14), ByteValue(value=28), ByteValue(value=28), ByteValue(value=36); 
DATA: ByteValue(value=18), ByteValue(value=28), ByteValue(value=36), ByteValue(value=18), ByteValue(value=23); 
                              ; "ANOTHER CASTLE!"                                                   ; 
DATA: ByteValue(value=38), ByteValue(value=5), ByteValue(value=15)                                  ; 
DATA: ByteValue(value=10), ByteValue(value=23), ByteValue(value=24), ByteValue(value=29), ByteValue(value=17), ByteValue(value=14), ByteValue(value=27), ByteValue(value=36); 
DATA: ByteValue(value=12), ByteValue(value=10), ByteValue(value=28), ByteValue(value=29), ByteValue(value=21), ByteValue(value=14), ByteValue(value=43), ByteValue(value=0); 
                                                                                                    ; 
PrincessSaved1:                                                                                     ;  B
                              ; "YOUR QUEST IS OVER."                                               ; 
DATA: ByteValue(value=37), ByteValue(value=167), ByteValue(value=19)                                ; 
DATA: ByteValue(value=34), ByteValue(value=24), ByteValue(value=30), ByteValue(value=27), ByteValue(value=36); 
DATA: ByteValue(value=26), ByteValue(value=30), ByteValue(value=14), ByteValue(value=28), ByteValue(value=29), ByteValue(value=36); 
DATA: ByteValue(value=18), ByteValue(value=28), ByteValue(value=36), ByteValue(value=24), ByteValue(value=31), ByteValue(value=14), ByteValue(value=27), ByteValue(value=175); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
PrincessSaved2:                                                                                     ;  B
                              ; "WE PRESENT YOU A NEW QUEST."                                       ; 
DATA: ByteValue(value=37), ByteValue(value=227), ByteValue(value=27)                                ; 
DATA: ByteValue(value=32), ByteValue(value=14), ByteValue(value=36)                                 ; 
DATA: ByteValue(value=25), ByteValue(value=27), ByteValue(value=14), ByteValue(value=28), ByteValue(value=14), ByteValue(value=23), ByteValue(value=29), ByteValue(value=36); 
DATA: ByteValue(value=34), ByteValue(value=24), ByteValue(value=30), ByteValue(value=36), ByteValue(value=10), ByteValue(value=36), ByteValue(value=23), ByteValue(value=14), ByteValue(value=32), ByteValue(value=36); 
DATA: ByteValue(value=26), ByteValue(value=30), ByteValue(value=14), ByteValue(value=28), ByteValue(value=29), ByteValue(value=175); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
WorldSelectMessage1:                                                                                ;  B
                              ; "PUSH BUTTON B"                                                     ; 
DATA: ByteValue(value=38), ByteValue(value=74), ByteValue(value=13)                                 ; 
DATA: ByteValue(value=25), ByteValue(value=30), ByteValue(value=28), ByteValue(value=17), ByteValue(value=36); 
DATA: ByteValue(value=11), ByteValue(value=30), ByteValue(value=29), ByteValue(value=29), ByteValue(value=24), ByteValue(value=23), ByteValue(value=36), ByteValue(value=11); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
WorldSelectMessage2:                                                                                ;  B
                              ; "TO SELECT A WORLD"                                                 ; 
DATA: ByteValue(value=38), ByteValue(value=136), ByteValue(value=17)                                ; 
DATA: ByteValue(value=29), ByteValue(value=24), ByteValue(value=36), ByteValue(value=28), ByteValue(value=14), ByteValue(value=21), ByteValue(value=14), ByteValue(value=12), ByteValue(value=29), ByteValue(value=36); 
DATA: ByteValue(value=10), ByteValue(value=36), ByteValue(value=32), ByteValue(value=24), ByteValue(value=27), ByteValue(value=21), ByteValue(value=13); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; $04 - address low to jump address                                   ; 
                              ; $05 - address high to jump address                                  ; 
                              ; $06 - jump address low                                              ; 
                              ; $07 - jump address high                                             ; 
                                                                                                    ; 
JumpEngine:                                                                                         ; fun(A):  B
ASL                           ; shift bit from contents of A                                        ; 
TAY                                                                                                 ; 
PLA                           ; pull saved return address from stack                                ; 
STA $04                       ; save to indirect                                                    ; 
PLA                                                                                                 ; 
STA $05                                                                                             ; 
INY                                                                                                 ; 
LDA ($04),Y                   ; load pointer from indirect                                          ; 
STA $06                       ; note that if an RTS is performed in next routine                    ; 
INY                           ; it will return to the execution before the sub                      ; 
LDA ($04),Y                   ; that called this routine                                            ; 
STA $07                                                                                             ; 
JMP ($06)                     ; jump to the address we loaded                                       ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
InitializeNameTables:                                                                               ; fun():  B
LDA PPU_STATUS                ; reset flip-flop                                                     ; 
LDA Mirror_PPU_CTRL_REG1      ; load mirror of ppu reg $2000                                        ; 
ORA #%00010000                ; set sprites for first 4k and background for second 4k               ; 
AND #%11110000                ; clear rest of lower nybble, leave higher alone                      ; 
JSR WritePPUReg1                                                                                    ; 
LDA #$24                      ; set vram address to start of name table 1                           ; 
JSR WriteNTAddr                                                                                     ; 
LDA #$20                      ; and then set it to name table 0                                     ; 
WriteNTAddr:  STA PPU_ADDRESS                                                                       ; fun(A):  B
LDA #$00                                                                                            ; 
STA PPU_ADDRESS                                                                                     ; 
LDX #$04                      ; clear name table with blank tile #24                                ; 
LDY #$c0                                                                                            ; 
LDA #$24                                                                                            ; 
InitNTLoop:  STA PPU_DATA     ; count out exactly 768 tiles                                         ;  B
DEY                                                                                                 ; 
BNE InitNTLoop                                                                                      ; 
DEX                                                                                                 ;  B
BNE InitNTLoop                                                                                      ; 
LDY #64                       ; now to clear the attribute table (with zero this time)              ;  B
TXA                                                                                                 ; 
STA VRAM_Buffer1_Offset       ; init vram buffer 1 offset                                           ; 
STA VRAM_Buffer1              ; init vram buffer 1                                                  ; 
InitATLoop:  STA PPU_DATA                                                                           ;  B
DEY                                                                                                 ; 
BNE InitATLoop                                                                                      ; 
STA HorizontalScroll          ; reset scroll variables                                              ;  B
STA VerticalScroll                                                                                  ; 
JMP InitScroll                ; initialize scroll registers to zero                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - temp joypad bit                                               ; 
                                                                                                    ; 
ReadJoypads:                                                                                        ; fun():  B
LDA #$01                      ; reset and clear strobe of joypad ports                              ; 
STA JOYPAD_PORT                                                                                     ; 
LSR                                                                                                 ; 
TAX                           ; start with joypad 1's port                                          ; 
STA JOYPAD_PORT                                                                                     ; 
JSR ReadPortBits                                                                                    ; 
INX                           ; increment for joypad 2's port                                       ; 
ReadPortBits:  LDY #$08                                                                             ; fun(A):  B
PortLoop:  PHA                ; push previous bit onto stack                                        ;  B
LDA JOYPAD_PORT,X             ; read current bit on joypad port                                     ; 
STA $00                       ; check d1 and d0 of port output                                      ; 
LSR                           ; this is necessary on the old                                        ; 
ORA $00                       ; famicom systems in japan                                            ; 
LSR                                                                                                 ; 
PLA                           ; read bits from stack                                                ; 
ROL                           ; rotate bit from carry flag                                          ; 
DEY                                                                                                 ; 
BNE PortLoop                  ; count down bits left                                                ; 
STA SavedJoypadBits,X         ; save controller status here always                                  ;  B
PHA                                                                                                 ; 
AND #%00110000                ; check for select or start                                           ; 
AND JoypadBitMask,X           ; if neither saved state nor current state                            ; 
BEQ Save8Bits                 ; have any of these two set, branch                                   ; 
PLA                                                                                                 ;  B
AND #%11001111                ; otherwise store without select                                      ; 
STA SavedJoypadBits,X         ; or start bits and leave                                             ; 
RTS                                                                                                 ; 
Save8Bits:  PLA                                                                                     ;  B
STA JoypadBitMask,X           ; save with all bits in another place and leave                       ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - vram buffer address table low                                 ; 
                              ; $01 - vram buffer address table high                                ; 
                                                                                                    ; 
WriteBufferToScreen:                                                                                ;  B
STA PPU_ADDRESS               ; store high byte of vram address                                     ; 
INY                                                                                                 ; 
LDA ($00),Y                   ; load next byte (second)                                             ; 
STA PPU_ADDRESS               ; store low byte of vram address                                      ; 
INY                                                                                                 ; 
LDA ($00),Y                   ; load next byte (third)                                              ; 
ASL                           ; shift to left and save in stack                                     ; 
PHA                                                                                                 ; 
LDA Mirror_PPU_CTRL_REG1      ; load mirror of $2000,                                               ; 
ORA #%00000100                ; set ppu to increment by 32 by default                               ; 
BCS SetupWrites               ; if d7 of third byte was clear, ppu will                             ; 
AND #%11111011                ; only increment by 1                                                 ;  B
SetupWrites:  JSR WritePPUReg1; write to register                                                   ;  B
PLA                           ; pull from stack and shift to left again                             ; 
ASL                                                                                                 ; 
BCC GetLength                 ; if d6 of third byte was clear, do not repeat byte                   ; 
ORA #%00000010                ; otherwise set d1 and increment Y                                    ;  B
INY                                                                                                 ; 
GetLength:  LSR               ; shift back to the right to get proper length                        ;  B
LSR                           ; note that d1 will now be in carry                                   ; 
TAX                                                                                                 ; 
OutputToVRAM:  BCS RepeatByte ; if carry set, repeat loading the same byte                          ;  B
INY                           ; otherwise increment Y to load next byte                             ;  B
RepeatByte:  LDA ($00),Y      ; load more data from buffer and write to vram                        ;  B
STA PPU_DATA                                                                                        ; 
DEX                           ; done writing?                                                       ; 
BNE OutputToVRAM                                                                                    ; 
SEC                                                                                                 ;  B
TYA                                                                                                 ; 
ADC $00                       ; add end length plus one to the indirect at $00                      ; 
STA $00                       ; to allow this routine to read another set of updates                ; 
LDA #$00                                                                                            ; 
ADC $01                                                                                             ; 
STA $01                                                                                             ; 
LDA #$3f                      ; sets vram address to $3f00                                          ; 
STA PPU_ADDRESS                                                                                     ; 
LDA #$00                                                                                            ; 
STA PPU_ADDRESS                                                                                     ; 
STA PPU_ADDRESS               ; then reinitializes it for some reason                               ; 
STA PPU_ADDRESS                                                                                     ; 
UpdateScreen:  LDX PPU_STATUS ; reset flip-flop                                                     ; fun($00$01):  B
LDY #$00                      ; load first byte from indirect as a pointer                          ; 
LDA ($00),Y                                                                                         ; 
BNE WriteBufferToScreen       ; if byte is zero we have no further updates to make here             ; 
InitScroll:  STA PPU_SCROLL_REG; store contents of A into scroll registers                          ; fun(A):  B
STA PPU_SCROLL_REG            ; and end whatever subroutine led us here                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
WritePPUReg1:                                                                                       ; fun(A):  B
STA PPU_CTRL_REG1             ; write contents of A to PPU register 1                               ; 
STA Mirror_PPU_CTRL_REG1      ; and its mirror                                                      ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to store status bar nybbles                              ; 
                              ; $02 - used as temp vram offset                                      ; 
                              ; $03 - used to store length of status bar number                     ; 
                                                                                                    ; 
                              ; status bar name table offset and length data                        ; 
StatusBarData:                                                                                      ;  B
DATA: ByteValue(value=240), ByteValue(value=6); top score display on title screen                   ; 
DATA: ByteValue(value=98), ByteValue(value=6); player score                                         ; 
DATA: ByteValue(value=98), ByteValue(value=6)                                                       ; 
DATA: ByteValue(value=109), ByteValue(value=2); coin tally                                          ; 
DATA: ByteValue(value=109), ByteValue(value=2)                                                      ; 
DATA: ByteValue(value=122), ByteValue(value=3); game timer                                          ; 
                                                                                                    ; 
StatusBarOffset:                                                                                    ;  B
DATA: ByteValue(value=6), ByteValue(value=12), ByteValue(value=18), ByteValue(value=24), ByteValue(value=30), ByteValue(value=36); 
                                                                                                    ; 
PrintStatusBarNumbers:                                                                              ; fun(A):  B
STA $00                       ; store player-specific offset                                        ; 
JSR OutputNumbers             ; use first nybble to print the coin display                          ; 
LDA $00                       ; move high nybble to low                                             ; 
LSR                           ; and print to score display                                          ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
                                                                                                    ; 
OutputNumbers:                                                                                      ; fun(A):  B
CLC                           ; add 1 to low nybble                                                 ; 
ADC #$01                                                                                            ; 
AND #%00001111                ; mask out high nybble                                                ; 
CMP #$06                                                                                            ; 
BCS ExitOutputN                                                                                     ; 
PHA                           ; save incremented value to stack for now and                         ;  B
ASL                           ; shift to left and use as offset                                     ; 
TAY                                                                                                 ; 
LDX VRAM_Buffer1_Offset       ; get current buffer pointer                                          ; 
LDA #$20                      ; put at top of screen by default                                     ; 
CPY #$00                      ; are we writing top score on title screen?                           ; 
BNE SetupNums                                                                                       ; 
LDA #$22                      ; if so, put further down on the screen                               ;  B
SetupNums:  STA VRAM_Buffer1,X                                                                      ;  B
LDA StatusBarData,Y           ; write low vram address and length of thing                          ; 
STA VRAM_Buffer1+1,X          ; we're printing to the buffer                                        ; 
LDA StatusBarData+1,Y                                                                               ; 
STA VRAM_Buffer1+2,X                                                                                ; 
STA $03                       ; save length byte in counter                                         ; 
STX $02                       ; and buffer pointer elsewhere for now                                ; 
PLA                           ; pull original incremented value from stack                          ; 
TAX                                                                                                 ; 
LDA StatusBarOffset,X         ; load offset to value we want to write                               ; 
SEC                                                                                                 ; 
SBC StatusBarData+1,Y         ; subtract from length byte we read before                            ; 
TAY                           ; use value as offset to display digits                               ; 
LDX $02                                                                                             ; 
DigitPLoop:  LDA DisplayDigits,Y; write digits to the buffer                                        ;  B
STA VRAM_Buffer1+3,X                                                                                ; 
INX                                                                                                 ; 
INY                                                                                                 ; 
DEC $03                       ; do this until all the digits are written                            ; 
BNE DigitPLoop                                                                                      ; 
LDA #$00                      ; put null terminator at end                                          ;  B
STA VRAM_Buffer1+3,X                                                                                ; 
INX                           ; increment buffer pointer by 3                                       ; 
INX                                                                                                 ; 
INX                                                                                                 ; 
STX VRAM_Buffer1_Offset       ; store it in case we want to use it again                            ; 
ExitOutputN:  RTS                                                                                   ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DigitsMathRoutine:                                                                                  ; fun(Y):  B
LDA OperMode                  ; check mode of operation                                             ; 
CMP #TitleScreenModeValue                                                                           ; 
BEQ EraseDMods                ; if in title screen mode, branch to lock score                       ; 
LDX #$05                                                                                            ;  B
AddModLoop:  LDA DigitModifier,X; load digit amount to increment                                    ;  B
CLC                                                                                                 ; 
ADC DisplayDigits,Y           ; add to current digit                                                ; 
BMI BorrowOne                 ; if result is a negative number, branch to subtract                  ; 
CMP #10                                                                                             ;  B
BCS CarryOne                  ; if digit greater than $09, branch to add                            ; 
StoreNewD:  STA DisplayDigits,Y; store as new score or game timer digit                             ;  B
DEY                           ; move onto next digits in score or game timer                        ; 
DEX                           ; and digit amounts to increment                                      ; 
BPL AddModLoop                ; loop back if we're not done yet                                     ; 
EraseDMods:  LDA #$00         ; store zero here                                                     ;  B
LDX #$06                      ; start with the last digit                                           ; 
EraseMLoop:  STA DigitModifier-1,X; initialize the digit amounts to increment                       ;  B
DEX                                                                                                 ; 
BPL EraseMLoop                ; do this until they're all reset, then leave                         ; 
RTS                                                                                                 ;  B
BorrowOne:  DEC DigitModifier-1,X; decrement the previous digit, then put $09 in                    ;  B
LDA #$09                      ; the game timer digit we're currently on to "borrow                  ; 
BNE StoreNewD                 ; the one", then do an unconditional branch back                      ; 
CarryOne:  SEC                ; subtract ten from our digit to make it a                            ;  B
SBC #10                       ; proper BCD number, then increment the digit                         ; 
INC DigitModifier-1,X         ; preceding current digit to "carry the one" properly                 ; 
JMP StoreNewD                 ; go back to just after we branched here                              ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
UpdateTopScore:                                                                                     ; fun():  B
LDX #$05                      ; start with mario's score                                            ; 
JSR TopScoreCheck                                                                                   ; 
LDX #$0b                      ; now do luigi's score                                                ; 
                                                                                                    ; 
TopScoreCheck:                                                                                      ; fun(X):  B
LDY #$05                      ; start with the lowest digit                                         ; 
SEC                                                                                                 ; 
GetScoreDiff:  LDA PlayerScoreDisplay,X; subtract each player digit from each high score digit      ;  B
SBC TopScoreDisplay,Y         ; from lowest to highest, if any top score digit exceeds              ; 
DEX                           ; any player digit, borrow will be set until a subsequent             ; 
DEY                           ; subtraction clears it (player digit is higher than top)             ; 
BPL GetScoreDiff                                                                                    ; 
BCC NoTopSc                   ; check to see if borrow is still set, if so, no new high score       ;  B
INX                           ; increment X and Y once to the start of the score                    ;  B
INY                                                                                                 ; 
CopyScore:  LDA PlayerScoreDisplay,X; store player's score digits into high score memory area       ;  B
STA TopScoreDisplay,Y                                                                               ; 
INX                                                                                                 ; 
INY                                                                                                 ; 
CPY #$06                      ; do this until we have stored them all                               ; 
BCC CopyScore                                                                                       ; 
NoTopSc:  RTS                                                                                       ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DefaultSprOffsets:                                                                                  ;  B
DATA: ByteValue(value=4), ByteValue(value=48), ByteValue(value=72), ByteValue(value=96), ByteValue(value=120), ByteValue(value=144), ByteValue(value=168), ByteValue(value=192); 
DATA: ByteValue(value=216), ByteValue(value=232), ByteValue(value=36), ByteValue(value=248), ByteValue(value=252), ByteValue(value=40), ByteValue(value=44); 
                                                                                                    ; 
Sprite0Data:                                                                                        ;  B
DATA: ByteValue(value=24), ByteValue(value=255), ByteValue(value=35), ByteValue(value=88)           ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
InitializeGame:                                                                                     ;  B
LDY #$6f                      ; clear all memory as in initialization procedure,                    ; 
JSR InitializeMemory          ; but this time, clear only as far as $076f                           ; 
LDY #$1f                                                                                            ; 
ClrSndLoop:  STA SoundMemory,Y; clear out memory used                                               ;  B
DEY                           ; by the sound engines                                                ; 
BPL ClrSndLoop                                                                                      ; 
LDA #$18                      ; set demo timer                                                      ;  B
STA DemoTimer                                                                                       ; 
JSR LoadAreaPointer                                                                                 ; 
                                                                                                    ; 
InitializeArea:                                                                                     ;  B
LDY #$4b                      ; clear all memory again, only as far as $074b                        ; 
JSR InitializeMemory          ; this is only necessary if branching from                            ; 
LDX #$21                                                                                            ; 
LDA #$00                                                                                            ; 
ClrTimersLoop:  STA Timers,X  ; clear out memory between                                            ;  B
DEX                           ; $0780 and $07a1                                                     ; 
BPL ClrTimersLoop                                                                                   ; 
LDA HalfwayPage                                                                                     ;  B
LDY AltEntranceControl        ; if AltEntranceControl not set, use halfway page, if any found       ; 
BEQ StartPage                                                                                       ; 
LDA EntrancePage              ; otherwise use saved entry page number here                          ;  B
StartPage:  STA ScreenLeft_PageLoc; set as value here                                               ;  B
STA CurrentPageLoc            ; also set as current page                                            ; 
STA BackloadingFlag           ; set flag here if halfway page or saved entry page number found      ; 
JSR GetScreenPosition         ; get pixel coordinates for screen borders                            ; 
LDY #$20                      ; if on odd numbered page, use $2480 as start of rendering            ; 
AND #%00000001                ; otherwise use $2080, this address used later as name table          ; 
BEQ SetInitNTHigh             ; address for rendering of game area                                  ; 
LDY #$24                                                                                            ;  B
SetInitNTHigh:  STY CurrentNTAddr_High; store name table address                                    ;  B
LDY #$80                                                                                            ; 
STY CurrentNTAddr_Low                                                                               ; 
ASL                           ; store LSB of page number in high nybble                             ; 
ASL                           ; of block buffer column position                                     ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
STA BlockBufferColumnPos                                                                            ; 
DEC AreaObjectLength          ; set area object lengths for all empty                               ; 
DEC AreaObjectLength+1                                                                              ; 
DEC AreaObjectLength+2                                                                              ; 
LDA #$0b                      ; set value for renderer to update 12 column sets                     ; 
STA ColumnSets                ; 12 column sets = 24 metatile columns = 1 1/2 screens                ; 
JSR GetAreaDataAddrs          ; get enemy and level addresses and load header                       ; 
LDA PrimaryHardMode           ; check to see if primary hard mode has been activated                ; 
BNE SetSecHard                ; if so, activate the secondary no matter where we're at              ; 
LDA WorldNumber               ; otherwise check world number                                        ;  B
CMP #World5                   ; if less than 5, do not activate secondary                           ; 
BCC CheckHalfway                                                                                    ; 
BNE SetSecHard                ; if not equal to, then world > 5, thus activate                      ;  B
LDA LevelNumber               ; otherwise, world 5, so check level number                           ;  B
CMP #Level3                   ; if 1 or 2, do not set secondary hard mode flag                      ; 
BCC CheckHalfway                                                                                    ; 
SetSecHard:  INC SecondaryHardMode; set secondary hard mode flag for areas 5-3 and beyond           ;  B
CheckHalfway:  LDA HalfwayPage                                                                      ;  B
BEQ DoneInitArea                                                                                    ; 
LDA #$02                      ; if halfway page set, overwrite start position from header           ;  B
STA PlayerEntranceCtrl                                                                              ; 
DoneInitArea:  LDA #Silence   ; silence music                                                       ;  B
STA AreaMusicQueue                                                                                  ; 
LDA #$01                      ; disable screen output                                               ; 
STA DisableScreenFlag                                                                               ; 
INC OperMode_Task             ; increment one of the modes                                          ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PrimaryGameSetup:                                                                                   ;  B
LDA #$01                                                                                            ; 
STA FetchNewGameTimerFlag     ; set flag to load game timer from header                             ; 
STA PlayerSize                ; set player's size to small                                          ; 
LDA #$02                                                                                            ; 
STA NumberofLives             ; give each player three lives                                        ; 
STA OffScr_NumberofLives                                                                            ; 
                                                                                                    ; 
SecondaryGameSetup:                                                                                 ;  B
LDA #$00                                                                                            ; 
STA DisableScreenFlag         ; enable screen output                                                ; 
TAY                                                                                                 ; 
ClearVRLoop:  STA VRAM_Buffer1-1,Y; clear buffer at $0300-$03ff                                     ;  B
INY                                                                                                 ; 
BNE ClearVRLoop                                                                                     ; 
STA GameTimerExpiredFlag      ; clear game timer exp flag                                           ;  B
STA DisableIntermediate       ; clear skip lives display flag                                       ; 
STA BackloadingFlag           ; clear value here                                                    ; 
LDA #$ff                                                                                            ; 
STA BalPlatformAlignment      ; initialize balance platform assignment flag                         ; 
LDA ScreenLeft_PageLoc        ; get left side page location                                         ; 
LSR Mirror_PPU_CTRL_REG1      ; shift LSB of ppu register #1 mirror out                             ; 
AND #$01                      ; mask out all but LSB of page location                               ; 
ROR                           ; rotate LSB of page location into carry then onto mirror             ; 
ROL Mirror_PPU_CTRL_REG1      ; this is to set the proper PPU name table                            ; 
JSR GetAreaMusic              ; load proper music into queue                                        ; 
LDA #$38                      ; load sprite shuffle amounts to be used later                        ; 
STA SprShuffleAmt+2                                                                                 ; 
LDA #$48                                                                                            ; 
STA SprShuffleAmt+1                                                                                 ; 
LDA #$58                                                                                            ; 
STA SprShuffleAmt                                                                                   ; 
LDX #$0e                      ; load default OAM offsets into $06e4-$06f2                           ; 
ShufAmtLoop:  LDA DefaultSprOffsets,X                                                               ;  B
STA SprDataOffset,X                                                                                 ; 
DEX                           ; do this until they're all set                                       ; 
BPL ShufAmtLoop                                                                                     ; 
LDY #$03                      ; set up sprite #0                                                    ;  B
ISpr0Loop:  LDA Sprite0Data,Y                                                                       ;  B
STA Sprite_Data,Y                                                                                   ; 
DEY                                                                                                 ; 
BPL ISpr0Loop                                                                                       ; 
JSR DoNothing2                ; these jsrs doesn't do anything useful                               ;  B
JSR DoNothing1                                                                                      ; 
INC Sprite0HitDetectFlag      ; set sprite #0 check flag                                            ; 
INC OperMode_Task             ; increment to next task                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; $06 - RAM address low                                               ; 
                              ; $07 - RAM address high                                              ; 
                                                                                                    ; 
InitializeMemory:                                                                                   ; fun(Y): A B
LDX #$07                      ; set initial high byte to $0700-$07ff                                ; 
LDA #$00                      ; set initial low byte to start of page (at $00 of page)              ; 
STA $06                                                                                             ; 
InitPageLoop:  STX $07                                                                              ;  B
InitByteLoop:  CPX #$01       ; check to see if we're on the stack ($0100-$01ff)                    ;  B
BNE InitByte                  ; if not, go ahead anyway                                             ; 
CPY #$60                      ; otherwise, check to see if we're at $0160-$01ff                     ;  B
BCS SkipByte                  ; if so, skip write                                                   ; 
InitByte:  STA ($06),Y        ; otherwise, initialize byte with current low byte in Y               ;  B
SkipByte:  DEY                                                                                      ;  B
CPY #$ff                      ; do this until all bytes in page have been erased                    ; 
BNE InitByteLoop                                                                                    ; 
DEX                           ; go onto the next page                                               ;  B
BPL InitPageLoop              ; do this until all pages of memory have been erased                  ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
MusicSelectData:                                                                                    ;  B
DATA: Expr(expr=WaterMusic), Expr(expr=GroundMusic), Expr(expr=UndergroundMusic), Expr(expr=CastleMusic); 
DATA: Expr(expr=CloudMusic), Expr(expr=PipeIntroMusic)                                              ; 
                                                                                                    ; 
GetAreaMusic:                                                                                       ; fun():  B
LDA OperMode                  ; if in title screen mode, leave                                      ; 
BEQ ExitGetM                                                                                        ; 
LDA AltEntranceControl        ; check for specific alternate mode of entry                          ;  B
CMP #$02                      ; if found, branch without checking starting position                 ; 
BEQ ChkAreaType               ; from area object data header                                        ; 
LDY #$05                      ; select music for pipe intro scene by default                        ;  B
LDA PlayerEntranceCtrl        ; check value from level header for certain values                    ; 
CMP #$06                                                                                            ; 
BEQ StoreMusic                ; load music for pipe intro scene if header                           ; 
CMP #$07                      ; start position either value $06 or $07                              ;  B
BEQ StoreMusic                                                                                      ; 
ChkAreaType:  LDY AreaType    ; load area type as offset for music bit                              ;  B
LDA CloudTypeOverride                                                                               ; 
BEQ StoreMusic                ; check for cloud type override                                       ; 
LDY #$04                      ; select music for cloud type level if found                          ;  B
StoreMusic:  LDA MusicSelectData,Y; otherwise select appropriate music for level type               ;  B
STA AreaMusicQueue            ; store in queue and leave                                            ; 
ExitGetM:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerStarting_X_Pos:                                                                               ;  B
DATA: ByteValue(value=40), ByteValue(value=24)                                                      ; 
DATA: ByteValue(value=56), ByteValue(value=40)                                                      ; 
                                                                                                    ; 
AltYPosOffset:                                                                                      ;  B
DATA: ByteValue(value=8), ByteValue(value=0)                                                        ; 
                                                                                                    ; 
PlayerStarting_Y_Pos:                                                                               ;  B
DATA: ByteValue(value=0), ByteValue(value=32), ByteValue(value=176), ByteValue(value=80), ByteValue(value=0), ByteValue(value=0), ByteValue(value=176), ByteValue(value=176); 
DATA: ByteValue(value=240)                                                                          ; 
                                                                                                    ; 
PlayerBGPriorityData:                                                                               ;  B
DATA: ByteValue(value=0), ByteValue(value=32), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0); 
                                                                                                    ; 
GameTimerData:                                                                                      ;  B
DATA: ByteValue(value=32)     ; dummy byte, used as part of bg priority data                        ; 
DATA: ByteValue(value=4), ByteValue(value=3), ByteValue(value=2)                                    ; 
                                                                                                    ; 
Entrance_GameTimerSetup:                                                                            ;  B
LDA ScreenLeft_PageLoc        ; set current page for area objects                                   ; 
STA Player_PageLoc            ; as page location for player                                         ; 
LDA #$28                      ; store value here                                                    ; 
STA VerticalForceDown         ; for fractional movement downwards if necessary                      ; 
LDA #$01                      ; set high byte of player position and                                ; 
STA PlayerFacingDir           ; set facing direction so that player faces right                     ; 
STA Player_Y_HighPos                                                                                ; 
LDA #$00                      ; set player state to on the ground by default                        ; 
STA Player_State                                                                                    ; 
DEC Player_CollisionBits      ; initialize player's collision bits                                  ; 
LDY #$00                      ; initialize halfway page                                             ; 
STY HalfwayPage                                                                                     ; 
LDA AreaType                  ; check area type                                                     ; 
BNE ChkStPos                  ; if water type, set swimming flag, otherwise do not set              ; 
INY                                                                                                 ;  B
ChkStPos:  STY SwimmingFlag                                                                         ;  B
LDX PlayerEntranceCtrl        ; get starting position loaded from header                            ; 
LDY AltEntranceControl        ; check alternate mode of entry flag for 0 or 1                       ; 
BEQ SetStPos                                                                                        ; 
CPY #$01                                                                                            ;  B
BEQ SetStPos                                                                                        ; 
LDX AltYPosOffset-2,Y         ; if not 0 or 1, override $0710 with new offset in X                  ;  B
SetStPos:  LDA PlayerStarting_X_Pos,Y; load appropriate horizontal position                         ;  B
STA Player_X_Position         ; and vertical positions for the player, using                        ; 
LDA PlayerStarting_Y_Pos,X    ; AltEntranceControl as offset for horizontal and either $0710        ; 
STA Player_Y_Position         ; or value that overwrote $0710 as offset for vertical                ; 
LDA PlayerBGPriorityData,X                                                                          ; 
STA Player_SprAttrib          ; set player sprite attributes using offset in X                      ; 
JSR GetPlayerColors           ; get appropriate player palette                                      ; 
LDY GameTimerSetting          ; get timer control value from header                                 ; 
BEQ ChkOverR                  ; if set to zero, branch (do not use dummy byte for this)             ; 
LDA FetchNewGameTimerFlag     ; do we need to set the game timer? if not, use                       ;  B
BEQ ChkOverR                  ; old game timer setting                                              ; 
LDA GameTimerData,Y           ; if game timer is set and game timer flag is also set,               ;  B
STA GameTimerDisplay          ; use value of game timer control for first digit of game timer       ; 
LDA #$01                                                                                            ; 
STA GameTimerDisplay+2        ; set last digit of game timer to 1                                   ; 
LSR                                                                                                 ; 
STA GameTimerDisplay+1        ; set second digit of game timer                                      ; 
STA FetchNewGameTimerFlag     ; clear flag for game timer reset                                     ; 
STA StarInvincibleTimer       ; clear star mario timer                                              ; 
ChkOverR:  LDY JoypadOverride ; if controller bits not set, branch to skip this part                ;  B
BEQ ChkSwimE                                                                                        ; 
LDA #$03                      ; set player state to climbing                                        ;  B
STA Player_State                                                                                    ; 
LDX #$00                      ; set offset for first slot, for block object                         ; 
JSR InitBlock_XY_Pos                                                                                ; 
LDA #$f0                      ; set vertical coordinate for block object                            ; 
STA Block_Y_Position                                                                                ; 
LDX #$05                      ; set offset in X for last enemy object buffer slot                   ; 
LDY #$00                      ; set offset in Y for object coordinates used earlier                 ; 
JSR Setup_Vine                ; do a sub to grow vine                                               ; 
ChkSwimE:  LDY AreaType       ; if level not water-type,                                            ;  B
BNE SetPESub                  ; skip this subroutine                                                ; 
JSR SetupBubble               ; otherwise, execute sub to set up air bubbles                        ;  B
SetPESub:  LDA #$07           ; set to run player entrance subroutine                               ;  B
STA GameEngineSubroutine      ; on the next frame of game engine                                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; page numbers are in order from -1 to -4                             ; 
HalfwayPageNybbles:                                                                                 ;  B
DATA: ByteValue(value=86), ByteValue(value=64)                                                      ; 
DATA: ByteValue(value=101), ByteValue(value=112)                                                    ; 
DATA: ByteValue(value=102), ByteValue(value=64)                                                     ; 
DATA: ByteValue(value=102), ByteValue(value=64)                                                     ; 
DATA: ByteValue(value=102), ByteValue(value=64)                                                     ; 
DATA: ByteValue(value=102), ByteValue(value=96)                                                     ; 
DATA: ByteValue(value=101), ByteValue(value=112)                                                    ; 
DATA: ByteValue(value=0), ByteValue(value=0)                                                        ; 
                                                                                                    ; 
PlayerLoseLife:                                                                                     ;  B
INC DisableScreenFlag         ; disable screen and sprite 0 check                                   ; 
LDA #$00                                                                                            ; 
STA Sprite0HitDetectFlag                                                                            ; 
LDA #Silence                  ; silence music                                                       ; 
STA EventMusicQueue                                                                                 ; 
DEC NumberofLives             ; take one life from player                                           ; 
BPL StillInGame               ; if player still has lives, branch                                   ; 
LDA #$00                                                                                            ;  B
STA OperMode_Task             ; initialize mode task,                                               ; 
LDA #GameOverModeValue        ; switch to game over mode                                            ; 
STA OperMode                  ; and leave                                                           ; 
RTS                                                                                                 ; 
StillInGame:  LDA WorldNumber ; multiply world number by 2 and use                                  ;  B
ASL                           ; as offset                                                           ; 
TAX                                                                                                 ; 
LDA LevelNumber               ; if in area -3 or -4, increment                                      ; 
AND #$02                      ; offset by one byte, otherwise                                       ; 
BEQ GetHalfway                ; leave offset alone                                                  ; 
INX                                                                                                 ;  B
GetHalfway:  LDY HalfwayPageNybbles,X; get halfway page number with offset                          ;  B
LDA LevelNumber               ; check area number's LSB                                             ; 
LSR                                                                                                 ; 
TYA                           ; if in area -2 or -4, use lower nybble                               ; 
BCS MaskHPNyb                                                                                       ; 
LSR                           ; move higher nybble to lower if area                                 ;  B
LSR                           ; number is -1 or -3                                                  ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
MaskHPNyb:  AND #%00001111    ; mask out all but lower nybble                                       ;  B
CMP ScreenLeft_PageLoc                                                                              ; 
BEQ SetHalfway                ; left side of screen must be at the halfway page,                    ; 
BCC SetHalfway                ; otherwise player must start at the                                  ;  B
LDA #$00                      ; beginning of the level                                              ;  B
SetHalfway:  STA HalfwayPage  ; store as halfway page for player                                    ;  B
JSR TransposePlayers          ; switch players around if 2-player game                              ; 
JMP ContinueGame              ; continue the game                                                   ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GameOverMode:                                                                                       ;  B
LDA OperMode_Task                                                                                   ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=SetupGameOver)                                                                      ; 
DATA: Expr(expr=ScreenRoutines)                                                                     ; 
DATA: Expr(expr=RunGameOver)                                                                        ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
SetupGameOver:                                                                                      ;  B
LDA #$00                      ; reset screen routine task control for title screen, game,           ; 
STA ScreenRoutineTask         ; and game over modes                                                 ; 
STA Sprite0HitDetectFlag      ; disable sprite 0 check                                              ; 
LDA #GameOverMusic                                                                                  ; 
STA EventMusicQueue           ; put game over music in secondary queue                              ; 
INC DisableScreenFlag         ; disable screen output                                               ; 
INC OperMode_Task             ; set secondary mode to 1                                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
RunGameOver:                                                                                        ;  B
LDA #$00                      ; reenable screen                                                     ; 
STA DisableScreenFlag                                                                               ; 
LDA SavedJoypad1Bits          ; check controller for start pressed                                  ; 
AND #Start_Button                                                                                   ; 
BNE TerminateGame                                                                                   ; 
LDA ScreenTimer               ; if not pressed, wait for                                            ;  B
BNE GameIsOn                  ; screen timer to expire                                              ; 
TerminateGame:                                                                                      ; fun(CarryFlag):  B
LDA #Silence                  ; silence music                                                       ; 
STA EventMusicQueue                                                                                 ; 
JSR TransposePlayers          ; check if other player can keep                                      ; 
BCC ContinueGame              ; going, and do so if possible                                        ; 
LDA WorldNumber               ; otherwise put world number of current                               ;  B
STA ContinueWorld             ; player into secret continue function variable                       ; 
LDA #$00                                                                                            ; 
ASL                           ; residual ASL instruction                                            ; 
STA OperMode_Task             ; reset all modes to title screen and                                 ; 
STA ScreenTimer               ; leave                                                               ; 
STA OperMode                                                                                        ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ContinueGame:                                                                                       ;  B
JSR LoadAreaPointer           ; update level pointer with                                           ; 
LDA #$01                      ; actual world and area numbers, then                                 ; 
STA PlayerSize                ; reset player's size, status, and                                    ; 
INC FetchNewGameTimerFlag     ; set game timer flag to reload                                       ; 
LDA #$00                      ; game timer from header                                              ; 
STA TimerControl              ; also set flag for timers to count again                             ; 
STA PlayerStatus                                                                                    ; 
STA GameEngineSubroutine      ; reset task for game core                                            ; 
STA OperMode_Task             ; set modes and leave                                                 ; 
LDA #$01                      ; if in game over mode, switch back to                                ; 
STA OperMode                  ; game mode, because game is still on                                 ; 
GameIsOn:  RTS                                                                                      ;  B
                                                                                                    ;  B
TransposePlayers:                                                                                   ; fun(): CarryFlag B
SEC                           ; set carry flag by default to end game                               ; 
LDA NumberOfPlayers           ; if only a 1 player game, leave                                      ; 
BEQ ExTrans                                                                                         ; 
LDA OffScr_NumberofLives      ; does offscreen player have any lives left?                          ;  B
BMI ExTrans                   ; branch if not                                                       ; 
LDA CurrentPlayer             ; invert bit to update                                                ;  B
EOR #%00000001                ; which player is on the screen                                       ; 
STA CurrentPlayer                                                                                   ; 
LDX #$06                                                                                            ; 
TransLoop:  LDA OnscreenPlayerInfo,X; transpose the information                                     ;  B
PHA                           ; of the onscreen player                                              ; 
LDA OffscreenPlayerInfo,X     ; with that of the offscreen player                                   ; 
STA OnscreenPlayerInfo,X                                                                            ; 
PLA                                                                                                 ; 
STA OffscreenPlayerInfo,X                                                                           ; 
DEX                                                                                                 ; 
BPL TransLoop                                                                                       ; 
CLC                           ; clear carry flag to get game going                                  ;  B
ExTrans:  RTS                                                                                       ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DoNothing1:                                                                                         ; fun():  B
LDA #$ff                      ; this is residual code, this value is                                ; 
STA $06c9                     ; not used anywhere in the program                                    ; 
DoNothing2:                                                                                         ; fun():  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
AreaParserTaskHandler:                                                                              ; fun():  B
LDY AreaParserTaskNum         ; check number of tasks here                                          ; 
BNE DoAPTasks                 ; if already set, go ahead                                            ; 
LDY #$08                                                                                            ;  B
STY AreaParserTaskNum         ; otherwise, set eight by default                                     ; 
DoAPTasks:  DEY                                                                                     ;  B
TYA                                                                                                 ; 
JSR AreaParserTasks                                                                                 ; 
DEC AreaParserTaskNum         ; if all tasks not complete do not                                    ; 
BNE SkipATRender              ; render attribute table yet                                          ; 
JSR RenderAttributeTables                                                                           ;  B
SkipATRender:  RTS                                                                                  ;  B
                                                                                                    ;  B
AreaParserTasks:                                                                                    ; fun():  B
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=IncrementColumnPos)                                                                 ; 
DATA: Expr(expr=RenderAreaGraphics)                                                                 ; 
DATA: Expr(expr=RenderAreaGraphics)                                                                 ; 
DATA: Expr(expr=AreaParserCore)                                                                     ; 
DATA: Expr(expr=IncrementColumnPos)                                                                 ; 
DATA: Expr(expr=RenderAreaGraphics)                                                                 ; 
DATA: Expr(expr=RenderAreaGraphics)                                                                 ; 
DATA: Expr(expr=AreaParserCore)                                                                     ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
IncrementColumnPos:                                                                                 ;  B
INC CurrentColumnPos          ; increment column where we're at                                     ; 
LDA CurrentColumnPos                                                                                ; 
AND #%00001111                ; mask out higher nybble                                              ; 
BNE NoColWrap                                                                                       ; 
STA CurrentColumnPos          ; if no bits left set, wrap back to zero (0-f)                        ;  B
INC CurrentPageLoc            ; and increment page number where we're at                            ; 
NoColWrap:  INC BlockBufferColumnPos; increment column offset where we're at                        ;  B
LDA BlockBufferColumnPos                                                                            ; 
AND #%00011111                ; mask out all but 5 LSB (0-1f)                                       ; 
STA BlockBufferColumnPos      ; and save                                                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used as counter, store for low nybble for background, ceiling byte for terrain; 
                              ; $01 - used to store floor byte for terrain                          ; 
                              ; $07 - used to store terrain metatile                                ; 
                              ; $06-$07 - used to store block buffer address                        ; 
                                                                                                    ; 
BSceneDataOffsets:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=48), ByteValue(value=96)                                  ; 
                                                                                                    ; 
BackSceneryData:                                                                                    ;  B
DATA: ByteValue(value=147), ByteValue(value=0), ByteValue(value=0), ByteValue(value=17), ByteValue(value=18), ByteValue(value=18), ByteValue(value=19), ByteValue(value=0); clouds; 
DATA: ByteValue(value=0), ByteValue(value=81), ByteValue(value=82), ByteValue(value=83), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0); 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=1), ByteValue(value=2), ByteValue(value=2), ByteValue(value=3), ByteValue(value=0), ByteValue(value=0); 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=145), ByteValue(value=146), ByteValue(value=147), ByteValue(value=0); 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=81), ByteValue(value=82), ByteValue(value=83), ByteValue(value=65), ByteValue(value=66); 
DATA: ByteValue(value=67), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=145), ByteValue(value=146); 
                                                                                                    ; 
DATA: ByteValue(value=151), ByteValue(value=135), ByteValue(value=136), ByteValue(value=137), ByteValue(value=153), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0); mountains and bushes; 
DATA: ByteValue(value=17), ByteValue(value=18), ByteValue(value=19), ByteValue(value=164), ByteValue(value=165), ByteValue(value=165), ByteValue(value=165), ByteValue(value=166); 
DATA: ByteValue(value=151), ByteValue(value=152), ByteValue(value=153), ByteValue(value=1), ByteValue(value=2), ByteValue(value=3), ByteValue(value=0), ByteValue(value=164); 
DATA: ByteValue(value=165), ByteValue(value=166), ByteValue(value=0), ByteValue(value=17), ByteValue(value=18), ByteValue(value=18), ByteValue(value=18), ByteValue(value=19); 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=1), ByteValue(value=2), ByteValue(value=2), ByteValue(value=3); 
DATA: ByteValue(value=0), ByteValue(value=164), ByteValue(value=165), ByteValue(value=165), ByteValue(value=166), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=17), ByteValue(value=18), ByteValue(value=18), ByteValue(value=19), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0); trees and fences; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=156), ByteValue(value=0), ByteValue(value=139), ByteValue(value=170), ByteValue(value=170); 
DATA: ByteValue(value=170), ByteValue(value=170), ByteValue(value=17), ByteValue(value=18), ByteValue(value=19), ByteValue(value=139), ByteValue(value=0), ByteValue(value=156); 
DATA: ByteValue(value=156), ByteValue(value=0), ByteValue(value=0), ByteValue(value=1), ByteValue(value=2), ByteValue(value=3), ByteValue(value=17), ByteValue(value=18); 
DATA: ByteValue(value=18), ByteValue(value=19), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=170), ByteValue(value=170); 
DATA: ByteValue(value=156), ByteValue(value=170), ByteValue(value=0), ByteValue(value=139), ByteValue(value=0), ByteValue(value=1), ByteValue(value=2), ByteValue(value=3); 
                                                                                                    ; 
BackSceneryMetatiles:                                                                               ;  B
DATA: ByteValue(value=128), ByteValue(value=131), ByteValue(value=0); cloud left                    ; 
DATA: ByteValue(value=129), ByteValue(value=132), ByteValue(value=0); cloud middle                  ; 
DATA: ByteValue(value=130), ByteValue(value=133), ByteValue(value=0); cloud right                   ; 
DATA: ByteValue(value=2), ByteValue(value=0), ByteValue(value=0); bush left                         ; 
DATA: ByteValue(value=3), ByteValue(value=0), ByteValue(value=0); bush middle                       ; 
DATA: ByteValue(value=4), ByteValue(value=0), ByteValue(value=0); bush right                        ; 
DATA: ByteValue(value=0), ByteValue(value=5), ByteValue(value=6); mountain left                     ; 
DATA: ByteValue(value=7), ByteValue(value=6), ByteValue(value=10); mountain middle                  ; 
DATA: ByteValue(value=0), ByteValue(value=8), ByteValue(value=9); mountain right                    ; 
DATA: ByteValue(value=77), ByteValue(value=0), ByteValue(value=0); fence                            ; 
DATA: ByteValue(value=13), ByteValue(value=15), ByteValue(value=78); tall tree                      ; 
DATA: ByteValue(value=14), ByteValue(value=78), ByteValue(value=78); short tree                     ; 
                                                                                                    ; 
FSceneDataOffsets:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=13), ByteValue(value=26)                                  ; 
                                                                                                    ; 
ForeSceneryData:                                                                                    ;  B
DATA: ByteValue(value=134), ByteValue(value=135), ByteValue(value=135), ByteValue(value=135), ByteValue(value=135), ByteValue(value=135), ByteValue(value=135); in water; 
DATA: ByteValue(value=135), ByteValue(value=135), ByteValue(value=135), ByteValue(value=135), ByteValue(value=105), ByteValue(value=105); 
                                                                                                    ; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=69), ByteValue(value=71); wall; 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=0), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0); over water; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=134), ByteValue(value=135); 
                                                                                                    ; 
TerrainMetatiles:                                                                                   ;  B
DATA: ByteValue(value=105), ByteValue(value=84), ByteValue(value=82), ByteValue(value=98)           ; 
                                                                                                    ; 
TerrainRenderBits:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=0); no ceiling or floor                                   ; 
DATA: ByteValue(value=0), ByteValue(value=24); no ceiling, floor 2                                  ; 
DATA: ByteValue(value=1), ByteValue(value=24); ceiling 1, floor 2                                   ; 
DATA: ByteValue(value=7), ByteValue(value=24); ceiling 3, floor 2                                   ; 
DATA: ByteValue(value=15), ByteValue(value=24); ceiling 4, floor 2                                  ; 
DATA: ByteValue(value=255), ByteValue(value=24); ceiling 8, floor 2                                 ; 
DATA: ByteValue(value=1), ByteValue(value=31); ceiling 1, floor 5                                   ; 
DATA: ByteValue(value=7), ByteValue(value=31); ceiling 3, floor 5                                   ; 
DATA: ByteValue(value=15), ByteValue(value=31); ceiling 4, floor 5                                  ; 
DATA: ByteValue(value=129), ByteValue(value=31); ceiling 1, floor 6                                 ; 
DATA: ByteValue(value=1), ByteValue(value=0); ceiling 1, no floor                                   ; 
DATA: ByteValue(value=143), ByteValue(value=31); ceiling 4, floor 6                                 ; 
DATA: ByteValue(value=241), ByteValue(value=31); ceiling 1, floor 9                                 ; 
DATA: ByteValue(value=249), ByteValue(value=24); ceiling 1, middle 5, floor 2                       ; 
DATA: ByteValue(value=241), ByteValue(value=24); ceiling 1, middle 4, floor 2                       ; 
DATA: ByteValue(value=255), ByteValue(value=31); completely solid top to bottom                     ; 
                                                                                                    ; 
AreaParserCore:                                                                                     ;  B
LDA BackloadingFlag           ; check to see if we are starting right of start                      ; 
BEQ RenderSceneryTerrain      ; if not, go ahead and render background, foreground and terrain      ; 
JSR ProcessAreaData           ; otherwise skip ahead and load level data                            ;  B
                                                                                                    ; 
RenderSceneryTerrain:                                                                               ;  B
LDX #$0c                                                                                            ; 
LDA #$00                                                                                            ; 
ClrMTBuf:  STA MetatileBuffer,X; clear out metatile buffer                                          ;  B
DEX                                                                                                 ; 
BPL ClrMTBuf                                                                                        ; 
LDY BackgroundScenery         ; do we need to render the background scenery?                        ;  B
BEQ RendFore                  ; if not, skip to check the foreground                                ; 
LDA CurrentPageLoc            ; otherwise check for every third page                                ;  B
ThirdP:  CMP #$03                                                                                   ;  B
BMI RendBack                  ; if less than three we're there                                      ; 
SEC                                                                                                 ;  B
SBC #$03                      ; if 3 or more, subtract 3 and                                        ; 
BPL ThirdP                    ; do an unconditional branch                                          ; 
RendBack:  ASL                ; move results to higher nybble                                       ;  B
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ADC BSceneDataOffsets-1,Y     ; add to it offset loaded from here                                   ; 
ADC CurrentColumnPos          ; add to the result our current column position                       ; 
TAX                                                                                                 ; 
LDA BackSceneryData,X         ; load data from sum of offsets                                       ; 
BEQ RendFore                  ; if zero, no scenery for that part                                   ; 
PHA                                                                                                 ;  B
AND #$0f                      ; save to stack and clear high nybble                                 ; 
SEC                                                                                                 ; 
SBC #$01                      ; subtract one (because low nybble is $01-$0c)                        ; 
STA $00                       ; save low nybble                                                     ; 
ASL                           ; multiply by three (shift to left and add result to old one)         ; 
ADC $00                       ; note that since d7 was nulled, the carry flag is always clear       ; 
TAX                           ; save as offset for background scenery metatile data                 ; 
PLA                           ; get high nybble from stack, move low                                ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
TAY                           ; use as second offset (used to determine height)                     ; 
LDA #$03                      ; use previously saved memory location for counter                    ; 
STA $00                                                                                             ; 
SceLoop1:  LDA BackSceneryMetatiles,X; load metatile data from offset of (lsb - 1) * 3              ;  B
STA MetatileBuffer,Y          ; store into buffer from offset of (msb / 16)                         ; 
INX                                                                                                 ; 
INY                                                                                                 ; 
CPY #$0b                      ; if at this location, leave loop                                     ; 
BEQ RendFore                                                                                        ; 
DEC $00                       ; decrement until counter expires, barring exception                  ;  B
BNE SceLoop1                                                                                        ; 
RendFore:  LDX ForegroundScenery; check for foreground data needed or not                           ;  B
BEQ RendTerr                  ; if not, skip this part                                              ; 
LDY FSceneDataOffsets-1,X     ; load offset from location offset by header value, then              ;  B
LDX #$00                      ; reinit X                                                            ; 
SceLoop2:  LDA ForeSceneryData,Y; load data until counter expires                                   ;  B
BEQ NoFore                    ; do not store if zero found                                          ; 
STA MetatileBuffer,X                                                                                ;  B
NoFore:  INY                                                                                        ;  B
INX                                                                                                 ; 
CPX #$0d                      ; store up to end of metatile buffer                                  ; 
BNE SceLoop2                                                                                        ; 
RendTerr:  LDY AreaType       ; check world type for water level                                    ;  B
BNE TerMTile                  ; if not water level, skip this part                                  ; 
LDA WorldNumber               ; check world number, if not world number eight                       ;  B
CMP #World8                   ; then skip this part                                                 ; 
BNE TerMTile                                                                                        ; 
LDA #$62                      ; if set as water level and world number eight,                       ;  B
JMP StoreMT                   ; use castle wall metatile as terrain type                            ; 
TerMTile:  LDA TerrainMetatiles,Y; otherwise get appropriate metatile for area type                 ;  B
LDY CloudTypeOverride         ; check for cloud type override                                       ; 
BEQ StoreMT                   ; if not set, keep value otherwise                                    ; 
LDA #$88                      ; use cloud block terrain                                             ;  B
StoreMT:  STA $07             ; store value here                                                    ;  B
LDX #$00                      ; initialize X, use as metatile buffer offset                         ; 
LDA TerrainControl            ; use yet another value from the header                               ; 
ASL                           ; multiply by 2 and use as yet another offset                         ; 
TAY                                                                                                 ; 
TerrLoop:  LDA TerrainRenderBits,Y; get one of the terrain rendering bit data                       ;  B
STA $00                                                                                             ; 
INY                           ; increment Y and use as offset next time around                      ; 
STY $01                                                                                             ; 
LDA CloudTypeOverride         ; skip if value here is zero                                          ; 
BEQ NoCloud2                                                                                        ; 
CPX #$00                      ; otherwise, check if we're doing the ceiling byte                    ;  B
BEQ NoCloud2                                                                                        ; 
LDA $00                       ; if not, mask out all but d3                                         ;  B
AND #%00001000                                                                                      ; 
STA $00                                                                                             ; 
NoCloud2:  LDY #$00           ; start at beginning of bitmasks                                      ;  B
TerrBChk:  LDA Bitmasks,Y     ; load bitmask, then perform AND on contents of first byte            ;  B
BIT $00                                                                                             ; 
BEQ NextTBit                  ; if not set, skip this part (do not write terrain to buffer)         ; 
LDA $07                                                                                             ;  B
STA MetatileBuffer,X          ; load terrain type metatile number and store into buffer here        ; 
NextTBit:  INX                ; continue until end of buffer                                        ;  B
CPX #$0d                                                                                            ; 
BEQ RendBBuf                  ; if we're at the end, break out of this loop                         ; 
LDA AreaType                  ; check world type for underground area                               ;  B
CMP #$02                                                                                            ; 
BNE EndUChk                   ; if not underground, skip this part                                  ; 
CPX #$0b                                                                                            ;  B
BNE EndUChk                   ; if we're at the bottom of the screen, override                      ; 
LDA #$54                      ; old terrain type with ground level terrain type                     ;  B
STA $07                                                                                             ; 
EndUChk:  INY                 ; increment bitmasks offset in Y                                      ;  B
CPY #$08                                                                                            ; 
BNE TerrBChk                  ; if not all bits checked, loop back                                  ; 
LDY $01                                                                                             ;  B
BNE TerrLoop                  ; unconditional branch, use Y to load next byte                       ; 
RendBBuf:  JSR ProcessAreaData; do the area data loading routine now                                ;  B
LDA BlockBufferColumnPos                                                                            ; 
JSR GetBlockBufferAddr        ; get block buffer address from where we're at                        ; 
LDX #$00                                                                                            ; 
LDY #$00                      ; init index regs and start at beginning of smaller buffer            ; 
ChkMTLow:  STY $00                                                                                  ;  B
LDA MetatileBuffer,X          ; load stored metatile number                                         ; 
AND #%11000000                ; mask out all but 2 MSB                                              ; 
ASL                                                                                                 ; 
ROL                           ; make %xx000000 into %000000xx                                       ; 
ROL                                                                                                 ; 
TAY                           ; use as offset in Y                                                  ; 
LDA MetatileBuffer,X          ; reload original unmasked value here                                 ; 
CMP BlockBuffLowBounds,Y      ; check for certain values depending on bits set                      ; 
BCS StrBlock                  ; if equal or greater, branch                                         ; 
LDA #$00                      ; if less, init value before storing                                  ;  B
StrBlock:  LDY $00            ; get offset for block buffer                                         ;  B
STA ($06),Y                   ; store value into block buffer                                       ; 
TYA                                                                                                 ; 
CLC                           ; add 16 (move down one row) to offset                                ; 
ADC #$10                                                                                            ; 
TAY                                                                                                 ; 
INX                           ; increment column value                                              ; 
CPX #$0d                                                                                            ; 
BCC ChkMTLow                  ; continue until we pass last row, then leave                         ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
                              ; numbers lower than these with the same attribute bits               ; 
                              ; will not be stored in the block buffer                              ; 
BlockBuffLowBounds:                                                                                 ;  B
DATA: ByteValue(value=16), ByteValue(value=81), ByteValue(value=136), ByteValue(value=192)          ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to store area object identifier                          ; 
                              ; $07 - used as adder to find proper area object code                 ; 
                                                                                                    ; 
ProcessAreaData:                                                                                    ; fun():  B
LDX #$02                      ; start at the end of area object buffer                              ; 
ProcADLoop:  STX ObjectOffset                                                                       ;  B
LDA #$00                      ; reset flag                                                          ; 
STA BehindAreaParserFlag                                                                            ; 
LDY AreaDataOffset            ; get offset of area data pointer                                     ; 
LDA (AreaData),Y              ; get first byte of area object                                       ; 
CMP #$fd                      ; if end-of-area, skip all this crap                                  ; 
BEQ RdyDecode                                                                                       ; 
LDA AreaObjectLength,X        ; check area object buffer flag                                       ;  B
BPL RdyDecode                 ; if buffer not negative, branch, otherwise                           ; 
INY                                                                                                 ;  B
LDA (AreaData),Y              ; get second byte of area object                                      ; 
ASL                           ; check for page select bit (d7), branch if not set                   ; 
BCC Chk1Row13                                                                                       ; 
LDA AreaObjectPageSel         ; check page select                                                   ;  B
BNE Chk1Row13                                                                                       ; 
INC AreaObjectPageSel         ; if not already set, set it now                                      ;  B
INC AreaObjectPageLoc         ; and increment page location                                         ; 
Chk1Row13:  DEY                                                                                     ;  B
LDA (AreaData),Y              ; reread first byte of level object                                   ; 
AND #$0f                      ; mask out high nybble                                                ; 
CMP #$0d                      ; row 13?                                                             ; 
BNE Chk1Row14                                                                                       ; 
INY                           ; if so, reread second byte of level object                           ;  B
LDA (AreaData),Y                                                                                    ; 
DEY                           ; decrement to get ready to read first byte                           ; 
AND #%01000000                ; check for d6 set (if not, object is page control)                   ; 
BNE CheckRear                                                                                       ; 
LDA AreaObjectPageSel         ; if page select is set, do not reread                                ;  B
BNE CheckRear                                                                                       ; 
INY                           ; if d6 not set, reread second byte                                   ;  B
LDA (AreaData),Y                                                                                    ; 
AND #%00011111                ; mask out all but 5 LSB and store in page control                    ; 
STA AreaObjectPageLoc                                                                               ; 
INC AreaObjectPageSel         ; increment page select                                               ; 
JMP NextAObj                                                                                        ; 
Chk1Row14:  CMP #$0e          ; row 14?                                                             ;  B
BNE CheckRear                                                                                       ; 
LDA BackloadingFlag           ; check flag for saved page number and branch if set                  ;  B
BNE RdyDecode                 ; to render the object (otherwise bg might not look right)            ; 
CheckRear:  LDA AreaObjectPageLoc; check to see if current page of level object is                  ;  B
CMP CurrentPageLoc            ; behind current page of renderer                                     ; 
BCC SetBehind                 ; if so branch                                                        ; 
RdyDecode:  JSR DecodeAreaData; do sub and do not turn on flag                                      ;  B
JMP ChkLength                                                                                       ; 
SetBehind:  INC BehindAreaParserFlag; turn on flag if object is behind renderer                     ;  B
NextAObj:  JSR IncAreaObjOffset; increment buffer offset and move on                                ;  B
ChkLength:  LDX ObjectOffset  ; get buffer offset                                                   ;  B
LDA AreaObjectLength,X        ; check object length for anything stored here                        ; 
BMI ProcLoopb                 ; if not, branch to handle loopback                                   ; 
DEC AreaObjectLength,X        ; otherwise decrement length or get rid of it                         ;  B
ProcLoopb:  DEX               ; decrement buffer offset                                             ;  B
BPL ProcADLoop                ; and loopback unless exceeded buffer                                 ; 
LDA BehindAreaParserFlag      ; check for flag set if objects were behind renderer                  ;  B
BNE ProcessAreaData           ; branch if true to load more level data, otherwise                   ; 
LDA BackloadingFlag           ; check for flag set if starting right of page $00                    ;  B
BNE ProcessAreaData           ; branch if true to load more level data, otherwise leave             ; 
EndAParse:  RTS                                                                                     ;  B
                                                                                                    ;  B
IncAreaObjOffset:                                                                                   ; fun():  B
INC AreaDataOffset            ; increment offset of level pointer                                   ; 
INC AreaDataOffset                                                                                  ; 
LDA #$00                      ; reset page select                                                   ; 
STA AreaObjectPageSel                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
DecodeAreaData:                                                                                     ; fun():  B
LDA AreaObjectLength,X        ; check current buffer flag                                           ; 
BMI Chk1stB                                                                                         ; 
LDY AreaObjOffsetBuffer,X     ; if not, get offset from buffer                                      ;  B
Chk1stB:  LDX #$10            ; load offset of 16 for special row 15                                ;  B
LDA (AreaData),Y              ; get first byte of level object again                                ; 
CMP #$fd                                                                                            ; 
BEQ EndAParse                 ; if end of level, leave this routine                                 ; 
AND #$0f                      ; otherwise, mask out low nybble                                      ;  B
CMP #$0f                      ; row 15?                                                             ; 
BEQ ChkRow14                  ; if so, keep the offset of 16                                        ; 
LDX #$08                      ; otherwise load offset of 8 for special row 12                       ;  B
CMP #$0c                      ; row 12?                                                             ; 
BEQ ChkRow14                  ; if so, keep the offset value of 8                                   ; 
LDX #$00                      ; otherwise nullify value by default                                  ;  B
ChkRow14:  STX $07            ; store whatever value we just loaded here                            ;  B
LDX ObjectOffset              ; get object offset again                                             ; 
CMP #$0e                      ; row 14?                                                             ; 
BNE ChkRow13                                                                                        ; 
LDA #$00                      ; if so, load offset with $00                                         ;  B
STA $07                                                                                             ; 
LDA #$2e                      ; and load A with another value                                       ; 
BNE NormObj                   ; unconditional branch                                                ; 
ChkRow13:  CMP #$0d           ; row 13?                                                             ;  B
BNE ChkSRows                                                                                        ; 
LDA #$22                      ; if so, load offset with 34                                          ;  B
STA $07                                                                                             ; 
INY                           ; get next byte                                                       ; 
LDA (AreaData),Y                                                                                    ; 
AND #%01000000                ; mask out all but d6 (page control obj bit)                          ; 
BEQ LeavePar                  ; if d6 clear, branch to leave (we handled this earlier)              ; 
LDA (AreaData),Y              ; otherwise, get byte again                                           ;  B
AND #%01111111                ; mask out d7                                                         ; 
CMP #$4b                      ; check for loop command in low nybble                                ; 
BNE Mask2MSB                  ; (plus d6 set for object other than page control)                    ; 
INC LoopCommand               ; if loop command, set loop command flag                              ;  B
Mask2MSB:  AND #%00111111     ; mask out d7 and d6                                                  ;  B
JMP NormObj                   ; and jump                                                            ; 
ChkSRows:  CMP #$0c           ; row 12-15?                                                          ;  B
BCS SpecObj                                                                                         ; 
INY                           ; if not, get second byte of level object                             ;  B
LDA (AreaData),Y                                                                                    ; 
AND #%01110000                ; mask out all but d6-d4                                              ; 
BNE LrgObj                    ; if any bits set, branch to handle large object                      ; 
LDA #$16                                                                                            ;  B
STA $07                       ; otherwise set offset of 24 for small object                         ; 
LDA (AreaData),Y              ; reload second byte of level object                                  ; 
AND #%00001111                ; mask out higher nybble and jump                                     ; 
JMP NormObj                                                                                         ; 
LrgObj:  STA $00              ; store value here (branch for large objects)                         ;  B
CMP #$70                      ; check for vertical pipe object                                      ; 
BNE NotWPipe                                                                                        ; 
LDA (AreaData),Y              ; if not, reload second byte                                          ;  B
AND #%00001000                ; mask out all but d3 (usage control bit)                             ; 
BEQ NotWPipe                  ; if d3 clear, branch to get original value                           ; 
LDA #$00                      ; otherwise, nullify value for warp pipe                              ;  B
STA $00                                                                                             ; 
NotWPipe:  LDA $00            ; get value and jump ahead                                            ;  B
JMP MoveAOId                                                                                        ; 
SpecObj:  INY                 ; branch here for rows 12-15                                          ;  B
LDA (AreaData),Y                                                                                    ; 
AND #%01110000                ; get next byte and mask out all but d6-d4                            ; 
MoveAOId:  LSR                ; move d6-d4 to lower nybble                                          ;  B
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
NormObj:  STA $00             ; store value here (branch for small objects and rows 13 and 14)      ;  B
LDA AreaObjectLength,X        ; is there something stored here already?                             ; 
BPL RunAObj                   ; if so, branch to do its particular sub                              ; 
LDA AreaObjectPageLoc         ; otherwise check to see if the object we've loaded is on the         ;  B
CMP CurrentPageLoc            ; same page as the renderer, and if so, branch                        ; 
BEQ InitRear                                                                                        ; 
LDY AreaDataOffset            ; if not, get old offset of level pointer                             ;  B
LDA (AreaData),Y              ; and reload first byte                                               ; 
AND #%00001111                                                                                      ; 
CMP #$0e                      ; row 14?                                                             ; 
BNE LeavePar                                                                                        ; 
LDA BackloadingFlag           ; if so, check backloading flag                                       ;  B
BNE StrAObj                   ; if set, branch to render object, else leave                         ; 
LeavePar:  RTS                                                                                      ;  B
InitRear:  LDA BackloadingFlag; check backloading flag to see if it's been initialized              ;  B
BEQ BackColC                  ; branch to column-wise check                                         ; 
LDA #$00                      ; if not, initialize both backloading and                             ;  B
STA BackloadingFlag           ; behind-renderer flags and leave                                     ; 
STA BehindAreaParserFlag                                                                            ; 
STA ObjectOffset                                                                                    ; 
LoopCmdE:  RTS                                                                                      ;  B
BackColC:  LDY AreaDataOffset ; get first byte again                                                ;  B
LDA (AreaData),Y                                                                                    ; 
AND #%11110000                ; mask out low nybble and move high to low                            ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
CMP CurrentColumnPos          ; is this where we're at?                                             ; 
BNE LeavePar                  ; if not, branch to leave                                             ; 
StrAObj:  LDA AreaDataOffset  ; if so, load area obj offset and store in buffer                     ;  B
STA AreaObjOffsetBuffer,X                                                                           ; 
JSR IncAreaObjOffset          ; do sub to increment to next object data                             ; 
RunAObj:  LDA $00             ; get stored value and add offset to it                               ;  B
CLC                           ; then use the jump engine with current contents of A                 ; 
ADC $07                                                                                             ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
                              ; large objects (rows $00-$0b or 00-11, d6-d4 set)                    ; 
DATA: Expr(expr=VerticalPipe) ; used by warp pipes                                                  ; 
DATA: Expr(expr=AreaStyleObject)                                                                    ; 
DATA: Expr(expr=RowOfBricks)                                                                        ; 
DATA: Expr(expr=RowOfSolidBlocks)                                                                   ; 
DATA: Expr(expr=RowOfCoins)                                                                         ; 
DATA: Expr(expr=ColumnOfBricks)                                                                     ; 
DATA: Expr(expr=ColumnOfSolidBlocks)                                                                ; 
DATA: Expr(expr=VerticalPipe) ; used by decoration pipes                                            ; 
                                                                                                    ; 
                              ; objects for special row $0c or 12                                   ; 
DATA: Expr(expr=Hole_Empty)                                                                         ; 
DATA: Expr(expr=PulleyRopeObject)                                                                   ; 
DATA: Expr(expr=Bridge_High)                                                                        ; 
DATA: Expr(expr=Bridge_Middle)                                                                      ; 
DATA: Expr(expr=Bridge_Low)                                                                         ; 
DATA: Expr(expr=Hole_Water)                                                                         ; 
DATA: Expr(expr=QuestionBlockRow_High)                                                              ; 
DATA: Expr(expr=QuestionBlockRow_Low)                                                               ; 
                                                                                                    ; 
                              ; objects for special row $0f or 15                                   ; 
DATA: Expr(expr=EndlessRope)                                                                        ; 
DATA: Expr(expr=BalancePlatRope)                                                                    ; 
DATA: Expr(expr=CastleObject)                                                                       ; 
DATA: Expr(expr=StaircaseObject)                                                                    ; 
DATA: Expr(expr=ExitPipe)                                                                           ; 
DATA: Expr(expr=FlagBalls_Residual)                                                                 ; 
                                                                                                    ; 
                              ; small objects (rows $00-$0b or 00-11, d6-d4 all clear)              ; 
DATA: Expr(expr=QuestionBlock); power-up                                                            ; 
DATA: Expr(expr=QuestionBlock); coin                                                                ; 
DATA: Expr(expr=QuestionBlock); hidden, coin                                                        ; 
DATA: Expr(expr=Hidden1UpBlock); hidden, 1-up                                                       ; 
DATA: Expr(expr=BrickWithItem); brick, power-up                                                     ; 
DATA: Expr(expr=BrickWithItem); brick, vine                                                         ; 
DATA: Expr(expr=BrickWithItem); brick, star                                                         ; 
DATA: Expr(expr=BrickWithCoins); brick, coins                                                       ; 
DATA: Expr(expr=BrickWithItem); brick, 1-up                                                         ; 
DATA: Expr(expr=WaterPipe)                                                                          ; 
DATA: Expr(expr=EmptyBlock)                                                                         ; 
DATA: Expr(expr=Jumpspring)                                                                         ; 
                                                                                                    ; 
                              ; objects for special row $0d or 13 (d6 set)                          ; 
DATA: Expr(expr=IntroPipe)                                                                          ; 
DATA: Expr(expr=FlagpoleObject)                                                                     ; 
DATA: Expr(expr=AxeObj)                                                                             ; 
DATA: Expr(expr=ChainObj)                                                                           ; 
DATA: Expr(expr=CastleBridgeObj)                                                                    ; 
DATA: Expr(expr=ScrollLockObject_Warp)                                                              ; 
DATA: Expr(expr=ScrollLockObject)                                                                   ; 
DATA: Expr(expr=ScrollLockObject)                                                                   ; 
DATA: Expr(expr=AreaFrenzy)   ; flying cheep-cheeps                                                 ; 
DATA: Expr(expr=AreaFrenzy)   ; bullet bills or swimming cheep-cheeps                               ; 
DATA: Expr(expr=AreaFrenzy)   ; stop frenzy                                                         ; 
DATA: Expr(expr=LoopCmdE)                                                                           ; 
                                                                                                    ; 
                              ; object for special row $0e or 14                                    ; 
DATA: Expr(expr=AlterAreaAttributes)                                                                ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; (these apply to all area object subroutines in this section unless otherwise stated); 
                              ; $00 - used to store offset used to find object code                 ; 
                              ; $07 - starts with adder from area parser, used to store row offset  ; 
                                                                                                    ; 
AlterAreaAttributes:                                                                                ;  B
LDY AreaObjOffsetBuffer,X     ; load offset for level object data saved in buffer                   ; 
INY                           ; load second byte                                                    ; 
LDA (AreaData),Y                                                                                    ; 
PHA                           ; save in stack for now                                               ; 
AND #%01000000                                                                                      ; 
BNE Alter2                    ; branch if d6 is set                                                 ; 
PLA                                                                                                 ;  B
PHA                           ; pull and push offset to copy to A                                   ; 
AND #%00001111                ; mask out high nybble and store as                                   ; 
STA TerrainControl            ; new terrain height type bits                                        ; 
PLA                                                                                                 ; 
AND #%00110000                ; pull and mask out all but d5 and d4                                 ; 
LSR                           ; move bits to lower nybble and store                                 ; 
LSR                           ; as new background scenery bits                                      ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
STA BackgroundScenery         ; then leave                                                          ; 
RTS                                                                                                 ; 
Alter2:  PLA                                                                                        ;  B
AND #%00000111                ; mask out all but 3 LSB                                              ; 
CMP #$04                      ; if four or greater, set color control bits                          ; 
BCC SetFore                   ; and nullify foreground scenery bits                                 ; 
STA BackgroundColorCtrl                                                                             ;  B
LDA #$00                                                                                            ; 
SetFore:  STA ForegroundScenery; otherwise set new foreground scenery bits                          ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ScrollLockObject_Warp:                                                                              ;  B
LDX #$04                      ; load value of 4 for game text routine as default                    ; 
LDA WorldNumber               ; warp zone (4-3-2), then check world number                          ; 
BEQ WarpNum                                                                                         ; 
INX                           ; if world number > 1, increment for next warp zone (5)               ;  B
LDY AreaType                  ; check area type                                                     ; 
DEY                                                                                                 ; 
BNE WarpNum                   ; if ground area type, increment for last warp zone                   ; 
INX                           ; (8-7-6) and move on                                                 ;  B
WarpNum:  TXA                                                                                       ;  B
STA WarpZoneControl           ; store number here to be used by warp zone routine                   ; 
JSR WriteGameText             ; print text and warp zone numbers                                    ; 
LDA #PiranhaPlant                                                                                   ; 
JSR KillEnemies               ; load identifier for piranha plants and do sub                       ; 
                                                                                                    ; 
ScrollLockObject:                                                                                   ;  B
LDA ScrollLock                ; invert scroll lock to turn it on                                    ; 
EOR #%00000001                                                                                      ; 
STA ScrollLock                                                                                      ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to store enemy identifier in KillEnemies                 ; 
                                                                                                    ; 
KillEnemies:                                                                                        ; fun(A):  B
STA $00                       ; store identifier here                                               ; 
LDA #$00                                                                                            ; 
LDX #$04                      ; check for identifier in enemy object buffer                         ; 
KillELoop:  LDY Enemy_ID,X                                                                          ;  B
CPY $00                       ; if not found, branch                                                ; 
BNE NoKillE                                                                                         ; 
STA Enemy_Flag,X              ; if found, deactivate enemy object flag                              ;  B
NoKillE:  DEX                 ; do this until all slots are checked                                 ;  B
BPL KillELoop                                                                                       ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FrenzyIDData:                                                                                       ;  B
DATA: Expr(expr=FlyCheepCheepFrenzy), Expr(expr=BBill_CCheep_Frenzy), Expr(expr=Stop_Frenzy)        ; 
                                                                                                    ; 
AreaFrenzy:  LDX $00          ; use area object identifier bit as offset                            ;  B
LDA FrenzyIDData-8,X          ; note that it starts at 8, thus weird address here                   ; 
LDY #$05                                                                                            ; 
FreCompLoop:  DEY             ; check regular slots of enemy object buffer                          ;  B
BMI ExitAFrenzy               ; if all slots checked and enemy object not found, branch to store    ; 
CMP Enemy_ID,Y                ; check for enemy object in buffer versus frenzy object               ;  B
BNE FreCompLoop                                                                                     ; 
LDA #$00                      ; if enemy object already present, nullify queue and leave            ;  B
ExitAFrenzy:  STA EnemyFrenzyQueue; store enemy into frenzy queue                                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $06 - used by MushroomLedge to store length                         ; 
                                                                                                    ; 
AreaStyleObject:                                                                                    ;  B
LDA AreaStyle                 ; load level object style and jump to the right sub                   ; 
JSR JumpEngine                                                                                      ; 
DATA: Expr(expr=TreeLedge)    ; also used for cloud type levels                                     ; 
DATA: Expr(expr=MushroomLedge)                                                                      ; 
DATA: Expr(expr=BulletBillCannon)                                                                   ; 
                                                                                                    ; 
TreeLedge:                                                                                          ;  B
JSR GetLrgObjAttrib           ; get row and length of green ledge                                   ; 
LDA AreaObjectLength,X        ; check length counter for expiration                                 ; 
BEQ EndTreeL                                                                                        ; 
BPL MidTreeL                                                                                        ;  B
TYA                                                                                                 ;  B
STA AreaObjectLength,X        ; store lower nybble into buffer flag as length of ledge              ; 
LDA CurrentPageLoc                                                                                  ; 
ORA CurrentColumnPos          ; are we at the start of the level?                                   ; 
BEQ MidTreeL                                                                                        ; 
LDA #$16                      ; render start of tree ledge                                          ;  B
JMP NoUnder                                                                                         ; 
MidTreeL:  LDX $07                                                                                  ;  B
LDA #$17                      ; render middle of tree ledge                                         ; 
STA MetatileBuffer,X          ; note that this is also used if ledge position is                    ; 
LDA #$4c                      ; at the start of level for continuous effect                         ; 
JMP AllUnder                  ; now render the part underneath                                      ; 
EndTreeL:  LDA #$18           ; render end of tree ledge                                            ;  B
JMP NoUnder                                                                                         ; 
                                                                                                    ;  B
MushroomLedge:                                                                                      ;  B
JSR ChkLrgObjLength           ; get shroom dimensions                                               ; 
STY $06                       ; store length here for now                                           ; 
BCC EndMushL                                                                                        ; 
LDA AreaObjectLength,X        ; divide length by 2 and store elsewhere                              ;  B
LSR                                                                                                 ; 
STA MushroomLedgeHalfLen,X                                                                          ; 
LDA #$19                      ; render start of mushroom                                            ; 
JMP NoUnder                                                                                         ; 
EndMushL:  LDA #$1b           ; if at the end, render end of mushroom                               ;  B
LDY AreaObjectLength,X                                                                              ; 
BEQ NoUnder                                                                                         ; 
LDA MushroomLedgeHalfLen,X    ; get divided length and store where length                           ;  B
STA $06                       ; was stored originally                                               ; 
LDX $07                                                                                             ; 
LDA #$1a                                                                                            ; 
STA MetatileBuffer,X          ; render middle of mushroom                                           ; 
CPY $06                       ; are we smack dab in the center?                                     ; 
BNE MushLExit                 ; if not, branch to leave                                             ; 
INX                                                                                                 ;  B
LDA #$4f                                                                                            ; 
STA MetatileBuffer,X          ; render stem top of mushroom underneath the middle                   ; 
LDA #$50                                                                                            ; 
AllUnder:  INX                                                                                      ;  B
LDY #$0f                      ; set $0f to render all way down                                      ; 
JMP RenderUnderPart           ; now render the stem of mushroom                                     ; 
NoUnder:  LDX $07             ; load row of ledge                                                   ;  B
LDY #$00                      ; set 0 for no bottom on this part                                    ; 
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
                              ; tiles used by pulleys and rope object                               ; 
PulleyRopeMetatiles:                                                                                ;  B
DATA: ByteValue(value=66), ByteValue(value=65), ByteValue(value=67)                                 ; 
                                                                                                    ; 
PulleyRopeObject:                                                                                   ;  B
JSR ChkLrgObjLength           ; get length of pulley/rope object                                    ; 
LDY #$00                      ; initialize metatile offset                                          ; 
BCS RenderPul                 ; if starting, render left pulley                                     ; 
INY                                                                                                 ;  B
LDA AreaObjectLength,X        ; if not at the end, render rope                                      ; 
BNE RenderPul                                                                                       ; 
INY                           ; otherwise render right pulley                                       ;  B
RenderPul:  LDA PulleyRopeMetatiles,Y                                                               ;  B
STA MetatileBuffer            ; render at the top of the screen                                     ; 
MushLExit:  RTS               ; and leave                                                           ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $06 - used to store upper limit of rows for CastleObject            ; 
                                                                                                    ; 
CastleMetatiles:                                                                                    ;  B
DATA: ByteValue(value=0), ByteValue(value=69), ByteValue(value=69), ByteValue(value=69), ByteValue(value=0); 
DATA: ByteValue(value=0), ByteValue(value=72), ByteValue(value=71), ByteValue(value=70), ByteValue(value=0); 
DATA: ByteValue(value=69), ByteValue(value=73), ByteValue(value=73), ByteValue(value=73), ByteValue(value=69); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=74), ByteValue(value=71), ByteValue(value=71); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=75), ByteValue(value=71), ByteValue(value=71); 
DATA: ByteValue(value=73), ByteValue(value=73), ByteValue(value=73), ByteValue(value=73), ByteValue(value=73); 
DATA: ByteValue(value=71), ByteValue(value=74), ByteValue(value=71), ByteValue(value=74), ByteValue(value=71); 
DATA: ByteValue(value=71), ByteValue(value=75), ByteValue(value=71), ByteValue(value=75), ByteValue(value=71); 
DATA: ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71), ByteValue(value=71); 
DATA: ByteValue(value=74), ByteValue(value=71), ByteValue(value=74), ByteValue(value=71), ByteValue(value=74); 
DATA: ByteValue(value=75), ByteValue(value=71), ByteValue(value=75), ByteValue(value=71), ByteValue(value=75); 
                                                                                                    ; 
CastleObject:                                                                                       ;  B
JSR GetLrgObjAttrib           ; save lower nybble as starting row                                   ; 
STY $07                       ; if starting row is above $0a, game will crash!!!                    ; 
LDY #$04                                                                                            ; 
JSR ChkLrgObjFixedLength      ; load length of castle if not already loaded                         ; 
TXA                                                                                                 ; 
PHA                           ; save obj buffer offset to stack                                     ; 
LDY AreaObjectLength,X        ; use current length as offset for castle data                        ; 
LDX $07                       ; begin at starting row                                               ; 
LDA #$0b                                                                                            ; 
STA $06                       ; load upper limit of number of rows to print                         ; 
CRendLoop:  LDA CastleMetatiles,Y; load current byte using offset                                   ;  B
STA MetatileBuffer,X                                                                                ; 
INX                           ; store in buffer and increment buffer offset                         ; 
LDA $06                                                                                             ; 
BEQ ChkCFloor                 ; have we reached upper limit yet?                                    ; 
INY                           ; if not, increment column-wise                                       ;  B
INY                           ; to byte in next row                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
DEC $06                       ; move closer to upper limit                                          ; 
ChkCFloor:  CPX #$0b          ; have we reached the row just before floor?                          ;  B
BNE CRendLoop                 ; if not, go back and do another row                                  ; 
PLA                                                                                                 ;  B
TAX                           ; get obj buffer offset from before                                   ; 
LDA CurrentPageLoc                                                                                  ; 
BEQ ExitCastle                ; if we're at page 0, we do not need to do anything else              ; 
LDA AreaObjectLength,X        ; check length                                                        ;  B
CMP #$01                      ; if length almost about to expire, put brick at floor                ; 
BEQ PlayerStop                                                                                      ; 
LDY $07                       ; check starting row for tall castle ($00)                            ;  B
BNE NotTall                                                                                         ; 
CMP #$03                      ; if found, then check to see if we're at the second column           ;  B
BEQ PlayerStop                                                                                      ; 
NotTall:  CMP #$02            ; if not tall castle, check to see if we're at the third column       ;  B
BNE ExitCastle                ; if we aren't and the castle is tall, don't create flag yet          ; 
JSR GetAreaObjXPosition       ; otherwise, obtain and save horizontal pixel coordinate              ;  B
PHA                                                                                                 ; 
JSR FindEmptyEnemySlot        ; find an empty place on the enemy object buffer                      ; 
PLA                                                                                                 ; 
STA Enemy_X_Position,X        ; then write horizontal coordinate for star flag                      ; 
LDA CurrentPageLoc                                                                                  ; 
STA Enemy_PageLoc,X           ; set page location for star flag                                     ; 
LDA #$01                                                                                            ; 
STA Enemy_Y_HighPos,X         ; set vertical high byte                                              ; 
STA Enemy_Flag,X              ; set flag for buffer                                                 ; 
LDA #$90                                                                                            ; 
STA Enemy_Y_Position,X        ; set vertical coordinate                                             ; 
LDA #StarFlagObject           ; set star flag value in buffer itself                                ; 
STA Enemy_ID,X                                                                                      ; 
RTS                                                                                                 ; 
PlayerStop:  LDY #$52         ; put brick at floor to stop player at end of level                   ;  B
STY MetatileBuffer+10         ; this is only done if we're on the second column                     ; 
ExitCastle:  RTS                                                                                    ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
WaterPipe:                                                                                          ;  B
JSR GetLrgObjAttrib           ; get row and lower nybble                                            ; 
LDY AreaObjectLength,X        ; get length (residual code, water pipe is 1 col thick)               ; 
LDX $07                       ; get row                                                             ; 
LDA #$6b                                                                                            ; 
STA MetatileBuffer,X          ; draw something here and below it                                    ; 
LDA #$6c                                                                                            ; 
STA MetatileBuffer+1,X                                                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $05 - used to store length of vertical shaft in RenderSidewaysPipe  ; 
                              ; $06 - used to store leftover horizontal length in RenderSidewaysPipe; 
                              ; and vertical length in VerticalPipe and GetPipeHeight               ; 
                                                                                                    ; 
IntroPipe:                                                                                          ;  B
LDY #$03                      ; check if length set, if not set, set it                             ; 
JSR ChkLrgObjFixedLength                                                                            ; 
LDY #$0a                      ; set fixed value and render the sideways part                        ; 
JSR RenderSidewaysPipe                                                                              ; 
BCS NoBlankP                  ; if carry flag set, not time to draw vertical pipe part              ; 
LDX #$06                      ; blank everything above the vertical pipe part                       ;  B
VPipeSectLoop:  LDA #$00      ; all the way to the top of the screen                                ;  B
STA MetatileBuffer,X          ; because otherwise it will look like exit pipe                       ; 
DEX                                                                                                 ; 
BPL VPipeSectLoop                                                                                   ; 
LDA VerticalPipeData,Y        ; draw the end of the vertical pipe part                              ;  B
STA MetatileBuffer+7                                                                                ; 
NoBlankP:  RTS                                                                                      ;  B
                                                                                                    ;  B
SidePipeShaftData:                                                                                  ;  B
DATA: ByteValue(value=21), ByteValue(value=20); used to control whether or not vertical pipe shaft  ; 
DATA: ByteValue(value=0), ByteValue(value=0); is drawn, and if so, controls the metatile number     ; 
SidePipeTopPart:                                                                                    ;  B
DATA: ByteValue(value=21), ByteValue(value=30); top part of sideways part of pipe                   ; 
DATA: ByteValue(value=29), ByteValue(value=28)                                                      ; 
SidePipeBottomPart:                                                                                 ;  B
DATA: ByteValue(value=21), ByteValue(value=33); bottom part of sideways part of pipe                ; 
DATA: ByteValue(value=32), ByteValue(value=31)                                                      ; 
                                                                                                    ; 
ExitPipe:                                                                                           ;  B
LDY #$03                      ; check if length set, if not set, set it                             ; 
JSR ChkLrgObjFixedLength                                                                            ; 
JSR GetLrgObjAttrib           ; get vertical length, then plow on through RenderSidewaysPipe        ; 
                                                                                                    ; 
RenderSidewaysPipe:                                                                                 ; fun(Y): CarryFlag B
DEY                           ; decrement twice to make room for shaft at bottom                    ; 
DEY                           ; and store here for now as vertical length                           ; 
STY $05                                                                                             ; 
LDY AreaObjectLength,X        ; get length left over and store here                                 ; 
STY $06                                                                                             ; 
LDX $05                       ; get vertical length plus one, use as buffer offset                  ; 
INX                                                                                                 ; 
LDA SidePipeShaftData,Y       ; check for value $00 based on horizontal offset                      ; 
CMP #$00                                                                                            ; 
BEQ DrawSidePart              ; if found, do not draw the vertical pipe shaft                       ; 
LDX #$00                                                                                            ;  B
LDY $05                       ; init buffer offset and get vertical length                          ; 
JSR RenderUnderPart           ; and render vertical shaft using tile number in A                    ; 
CLC                           ; clear carry flag to be used by IntroPipe                            ; 
DrawSidePart:  LDY $06        ; render side pipe part at the bottom                                 ;  B
LDA SidePipeTopPart,Y                                                                               ; 
STA MetatileBuffer,X          ; note that the pipe parts are stored                                 ; 
LDA SidePipeBottomPart,Y      ; backwards horizontally                                              ; 
STA MetatileBuffer+1,X                                                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
VerticalPipeData:                                                                                   ;  B
DATA: ByteValue(value=17), ByteValue(value=16); used by pipes that lead somewhere                   ; 
DATA: ByteValue(value=21), ByteValue(value=20)                                                      ; 
DATA: ByteValue(value=19), ByteValue(value=18); used by decoration pipes                            ; 
DATA: ByteValue(value=21), ByteValue(value=20)                                                      ; 
                                                                                                    ; 
VerticalPipe:                                                                                       ;  B
JSR GetPipeHeight                                                                                   ; 
LDA $00                       ; check to see if value was nullified earlier                         ; 
BEQ WarpPipe                  ; (if d3, the usage control bit of second byte, was set)              ; 
INY                                                                                                 ;  B
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                           ; add four if usage control bit was not set                           ; 
WarpPipe:  TYA                ; save value in stack                                                 ;  B
PHA                                                                                                 ; 
LDA AreaNumber                                                                                      ; 
ORA WorldNumber               ; if at world 1-1, do not add piranha plant ever                      ; 
BEQ DrawPipe                                                                                        ; 
LDY AreaObjectLength,X        ; if on second column of pipe, branch                                 ;  B
BEQ DrawPipe                  ; (because we only need to do this once)                              ; 
JSR FindEmptyEnemySlot        ; check for an empty moving data buffer space                         ;  B
BCS DrawPipe                  ; if not found, too many enemies, thus skip                           ; 
JSR GetAreaObjXPosition       ; get horizontal pixel coordinate                                     ;  B
CLC                                                                                                 ; 
ADC #$08                      ; add eight to put the piranha plant in the center                    ; 
STA Enemy_X_Position,X        ; store as enemy's horizontal coordinate                              ; 
LDA CurrentPageLoc            ; add carry to current page number                                    ; 
ADC #$00                                                                                            ; 
STA Enemy_PageLoc,X           ; store as enemy's page coordinate                                    ; 
LDA #$01                                                                                            ; 
STA Enemy_Y_HighPos,X                                                                               ; 
STA Enemy_Flag,X              ; activate enemy flag                                                 ; 
JSR GetAreaObjYPosition       ; get piranha plant's vertical coordinate and store here              ; 
STA Enemy_Y_Position,X                                                                              ; 
LDA #PiranhaPlant             ; write piranha plant's value into buffer                             ; 
STA Enemy_ID,X                                                                                      ; 
JSR InitPiranhaPlant                                                                                ; 
DrawPipe:  PLA                ; get value saved earlier and use as Y                                ;  B
TAY                                                                                                 ; 
LDX $07                       ; get buffer offset                                                   ; 
LDA VerticalPipeData,Y        ; draw the appropriate pipe with the Y we loaded earlier              ; 
STA MetatileBuffer,X          ; render the top of the pipe                                          ; 
INX                                                                                                 ; 
LDA VerticalPipeData+2,Y      ; render the rest of the pipe                                         ; 
LDY $06                       ; subtract one from length and render the part underneath             ; 
DEY                                                                                                 ; 
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
GetPipeHeight:                                                                                      ; fun():  B
LDY #$01                      ; check for length loaded, if not, load                               ; 
JSR ChkLrgObjFixedLength      ; pipe length of 2 (horizontal)                                       ; 
JSR GetLrgObjAttrib                                                                                 ; 
TYA                           ; get saved lower nybble as height                                    ; 
AND #$07                      ; save only the three lower bits as                                   ; 
STA $06                       ; vertical length, then load Y with                                   ; 
LDY AreaObjectLength,X        ; length left over                                                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
FindEmptyEnemySlot:                                                                                 ; fun(): CarryFlagA B
LDX #$00                      ; start at first enemy slot                                           ; 
EmptyChkLoop:  CLC            ; clear carry flag by default                                         ;  B
LDA Enemy_Flag,X              ; check enemy buffer for nonzero                                      ; 
BEQ ExitEmptyChk              ; if zero, leave                                                      ; 
INX                                                                                                 ;  B
CPX #$05                      ; if nonzero, check next value                                        ; 
BNE EmptyChkLoop                                                                                    ; 
ExitEmptyChk:  RTS            ; if all values nonzero, carry flag is set                            ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
Hole_Water:                                                                                         ;  B
JSR ChkLrgObjLength           ; get low nybble and save as length                                   ; 
LDA #$86                      ; render waves                                                        ; 
STA MetatileBuffer+10                                                                               ; 
LDX #$0b                                                                                            ; 
LDY #$01                      ; now render the water underneath                                     ; 
LDA #$87                                                                                            ; 
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
QuestionBlockRow_High:                                                                              ;  B
LDA #$03                      ; start on the fourth row                                             ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
QuestionBlockRow_Low:                                                                               ;  B
LDA #$07                      ; start on the eighth row                                             ; 
PHA                           ; save whatever row to the stack for now                              ; 
JSR ChkLrgObjLength           ; get low nybble and save as length                                   ; 
PLA                                                                                                 ; 
TAX                           ; render question boxes with coins                                    ; 
LDA #$c0                                                                                            ; 
STA MetatileBuffer,X                                                                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
Bridge_High:                                                                                        ;  B
LDA #$06                      ; start on the seventh row from top of screen                         ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
Bridge_Middle:                                                                                      ;  B
LDA #$07                      ; start on the eighth row                                             ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
Bridge_Low:                                                                                         ;  B
LDA #$09                      ; start on the tenth row                                              ; 
PHA                           ; save whatever row to the stack for now                              ; 
JSR ChkLrgObjLength           ; get low nybble and save as length                                   ; 
PLA                                                                                                 ; 
TAX                           ; render bridge railing                                               ; 
LDA #$0b                                                                                            ; 
STA MetatileBuffer,X                                                                                ; 
INX                                                                                                 ; 
LDY #$00                      ; now render the bridge itself                                        ; 
LDA #$63                                                                                            ; 
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FlagBalls_Residual:                                                                                 ;  B
JSR GetLrgObjAttrib           ; get low nybble from object byte                                     ; 
LDX #$02                      ; render flag balls on third row from top                             ; 
LDA #$6d                      ; of screen downwards based on low nybble                             ; 
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FlagpoleObject:                                                                                     ;  B
LDA #$24                      ; render flagpole ball on top                                         ; 
STA MetatileBuffer                                                                                  ; 
LDX #$01                      ; now render the flagpole shaft                                       ; 
LDY #$08                                                                                            ; 
LDA #$25                                                                                            ; 
JSR RenderUnderPart                                                                                 ; 
LDA #$61                      ; render solid block at the bottom                                    ; 
STA MetatileBuffer+10                                                                               ; 
JSR GetAreaObjXPosition                                                                             ; 
SEC                           ; get pixel coordinate of where the flagpole is,                      ; 
SBC #$08                      ; subtract eight pixels and use as horizontal                         ; 
STA Enemy_X_Position+5        ; coordinate for the flag                                             ; 
LDA CurrentPageLoc                                                                                  ; 
SBC #$00                      ; subtract borrow from page location and use as                       ; 
STA Enemy_PageLoc+5           ; page location for the flag                                          ; 
LDA #$30                                                                                            ; 
STA Enemy_Y_Position+5        ; set vertical coordinate for flag                                    ; 
LDA #$b0                                                                                            ; 
STA FlagpoleFNum_Y_Pos        ; set initial vertical coordinate for flagpole's floatey number       ; 
LDA #FlagpoleFlagObject                                                                             ; 
STA Enemy_ID+5                ; set flag identifier, note that identifier and coordinates           ; 
INC Enemy_Flag+5              ; use last space in enemy object buffer                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
EndlessRope:                                                                                        ;  B
LDX #$00                      ; render rope from the top to the bottom of screen                    ; 
LDY #$0f                                                                                            ; 
JMP DrawRope                                                                                        ; 
                                                                                                    ;  B
BalancePlatRope:                                                                                    ;  B
TXA                           ; save object buffer offset for now                                   ; 
PHA                                                                                                 ; 
LDX #$01                      ; blank out all from second row to the bottom                         ; 
LDY #$0f                      ; with blank used for balance platform rope                           ; 
LDA #$44                                                                                            ; 
JSR RenderUnderPart                                                                                 ; 
PLA                           ; get back object buffer offset                                       ; 
TAX                                                                                                 ; 
JSR GetLrgObjAttrib           ; get vertical length from lower nybble                               ; 
LDX #$01                                                                                            ; 
DrawRope:  LDA #$40           ; render the actual rope                                              ;  B
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
CoinMetatileData:                                                                                   ;  B
DATA: ByteValue(value=195), ByteValue(value=194), ByteValue(value=194), ByteValue(value=194)        ; 
                                                                                                    ; 
RowOfCoins:                                                                                         ;  B
LDY AreaType                  ; get area type                                                       ; 
LDA CoinMetatileData,Y        ; load appropriate coin metatile                                      ; 
JMP GetRow                                                                                          ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
C_ObjectRow:                                                                                        ;  B
DATA: ByteValue(value=6), ByteValue(value=7), ByteValue(value=8)                                    ; 
                                                                                                    ; 
C_ObjectMetatile:                                                                                   ;  B
DATA: ByteValue(value=197), ByteValue(value=12), ByteValue(value=137)                               ; 
                                                                                                    ; 
CastleBridgeObj:                                                                                    ;  B
LDY #$0c                      ; load length of 13 columns                                           ; 
JSR ChkLrgObjFixedLength                                                                            ; 
JMP ChainObj                                                                                        ; 
                                                                                                    ;  B
AxeObj:                                                                                             ;  B
LDA #$08                      ; load bowser's palette into sprite portion of palette                ; 
STA VRAM_Buffer_AddrCtrl                                                                            ; 
                                                                                                    ; 
ChainObj:                                                                                           ;  B
LDY $00                       ; get value loaded earlier from decoder                               ; 
LDX C_ObjectRow-2,Y           ; get appropriate row and metatile for object                         ; 
LDA C_ObjectMetatile-2,Y                                                                            ; 
JMP ColObj                                                                                          ; 
                                                                                                    ;  B
EmptyBlock:                                                                                         ;  B
JSR GetLrgObjAttrib           ; get row location                                                    ; 
LDX $07                                                                                             ; 
LDA #$c4                                                                                            ; 
ColObj:  LDY #$00             ; column length of 1                                                  ;  B
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
SolidBlockMetatiles:                                                                                ;  B
DATA: ByteValue(value=105), ByteValue(value=97), ByteValue(value=97), ByteValue(value=98)           ; 
                                                                                                    ; 
BrickMetatiles:                                                                                     ;  B
DATA: ByteValue(value=34), ByteValue(value=81), ByteValue(value=82), ByteValue(value=82)            ; 
DATA: ByteValue(value=136)    ; used only by row of bricks object                                   ; 
                                                                                                    ; 
RowOfBricks:                                                                                        ;  B
LDY AreaType                  ; load area type obtained from area offset pointer                    ; 
LDA CloudTypeOverride         ; check for cloud type override                                       ; 
BEQ DrawBricks                                                                                      ; 
LDY #$04                      ; if cloud type, override area type                                   ;  B
DrawBricks:  LDA BrickMetatiles,Y; get appropriate metatile                                         ;  B
JMP GetRow                    ; and go render it                                                    ; 
                                                                                                    ;  B
RowOfSolidBlocks:                                                                                   ;  B
LDY AreaType                  ; load area type obtained from area offset pointer                    ; 
LDA SolidBlockMetatiles,Y     ; get metatile                                                        ; 
GetRow:  PHA                  ; store metatile here                                                 ;  B
JSR ChkLrgObjLength           ; get row number, load length                                         ; 
DrawRow:  LDX $07                                                                                   ;  B
LDY #$00                      ; set vertical height of 1                                            ; 
PLA                                                                                                 ; 
JMP RenderUnderPart           ; render object                                                       ; 
                                                                                                    ;  B
ColumnOfBricks:                                                                                     ;  B
LDY AreaType                  ; load area type obtained from area offset                            ; 
LDA BrickMetatiles,Y          ; get metatile (no cloud override as for row)                         ; 
JMP GetRow2                                                                                         ; 
                                                                                                    ;  B
ColumnOfSolidBlocks:                                                                                ;  B
LDY AreaType                  ; load area type obtained from area offset                            ; 
LDA SolidBlockMetatiles,Y     ; get metatile                                                        ; 
GetRow2:  PHA                 ; save metatile to stack for now                                      ;  B
JSR GetLrgObjAttrib           ; get length and row                                                  ; 
PLA                           ; restore metatile                                                    ; 
LDX $07                       ; get starting row                                                    ; 
JMP RenderUnderPart           ; now render the column                                               ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BulletBillCannon:                                                                                   ;  B
JSR GetLrgObjAttrib           ; get row and length of bullet bill cannon                            ; 
LDX $07                       ; start at first row                                                  ; 
LDA #$64                      ; render bullet bill cannon                                           ; 
STA MetatileBuffer,X                                                                                ; 
INX                                                                                                 ; 
DEY                           ; done yet?                                                           ; 
BMI SetupCannon                                                                                     ; 
LDA #$65                      ; if not, render middle part                                          ;  B
STA MetatileBuffer,X                                                                                ; 
INX                                                                                                 ; 
DEY                           ; done yet?                                                           ; 
BMI SetupCannon                                                                                     ; 
LDA #$66                      ; if not, render bottom until length expires                          ;  B
JSR RenderUnderPart                                                                                 ; 
SetupCannon:  LDX Cannon_Offset; get offset for data used by cannons and whirlpools                 ;  B
JSR GetAreaObjYPosition       ; get proper vertical coordinate for cannon                           ; 
STA Cannon_Y_Position,X       ; and store it here                                                   ; 
LDA CurrentPageLoc                                                                                  ; 
STA Cannon_PageLoc,X          ; store page number for cannon here                                   ; 
JSR GetAreaObjXPosition       ; get proper horizontal coordinate for cannon                         ; 
STA Cannon_X_Position,X       ; and store it here                                                   ; 
INX                                                                                                 ; 
CPX #$06                      ; increment and check offset                                          ; 
BCC StrCOffset                ; if not yet reached sixth cannon, branch to save offset              ; 
LDX #$00                      ; otherwise initialize it                                             ;  B
StrCOffset:  STX Cannon_Offset; save new offset and leave                                           ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
StaircaseHeightData:                                                                                ;  B
DATA: ByteValue(value=7), ByteValue(value=7), ByteValue(value=6), ByteValue(value=5), ByteValue(value=4), ByteValue(value=3), ByteValue(value=2), ByteValue(value=1), ByteValue(value=0); 
                                                                                                    ; 
StaircaseRowData:                                                                                   ;  B
DATA: ByteValue(value=3), ByteValue(value=3), ByteValue(value=4), ByteValue(value=5), ByteValue(value=6), ByteValue(value=7), ByteValue(value=8), ByteValue(value=9), ByteValue(value=10); 
                                                                                                    ; 
StaircaseObject:                                                                                    ;  B
JSR ChkLrgObjLength           ; check and load length                                               ; 
BCC NextStair                 ; if length already loaded, skip init part                            ; 
LDA #$09                      ; start past the end for the bottom                                   ;  B
STA StaircaseControl          ; of the staircase                                                    ; 
NextStair:  DEC StaircaseControl; move onto next step (or first if starting)                        ;  B
LDY StaircaseControl                                                                                ; 
LDX StaircaseRowData,Y        ; get starting row and height to render                               ; 
LDA StaircaseHeightData,Y                                                                           ; 
TAY                                                                                                 ; 
LDA #$61                      ; now render solid block staircase                                    ; 
JMP RenderUnderPart                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
Jumpspring:                                                                                         ;  B
JSR GetLrgObjAttrib                                                                                 ; 
JSR FindEmptyEnemySlot        ; find empty space in enemy object buffer                             ; 
JSR GetAreaObjXPosition       ; get horizontal coordinate for jumpspring                            ; 
STA Enemy_X_Position,X        ; and store                                                           ; 
LDA CurrentPageLoc            ; store page location of jumpspring                                   ; 
STA Enemy_PageLoc,X                                                                                 ; 
JSR GetAreaObjYPosition       ; get vertical coordinate for jumpspring                              ; 
STA Enemy_Y_Position,X        ; and store                                                           ; 
STA Jumpspring_FixedYPos,X    ; store as permanent coordinate here                                  ; 
LDA #JumpspringObject                                                                               ; 
STA Enemy_ID,X                ; write jumpspring object to enemy object buffer                      ; 
LDY #$01                                                                                            ; 
STY Enemy_Y_HighPos,X         ; store vertical high byte                                            ; 
INC Enemy_Flag,X              ; set flag for enemy object buffer                                    ; 
LDX $07                                                                                             ; 
LDA #$67                      ; draw metatiles in two rows where jumpspring is                      ; 
STA MetatileBuffer,X                                                                                ; 
LDA #$68                                                                                            ; 
STA MetatileBuffer+1,X                                                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $07 - used to save ID of brick object                               ; 
                                                                                                    ; 
Hidden1UpBlock:                                                                                     ;  B
LDA Hidden1UpFlag             ; if flag not set, do not render object                               ; 
BEQ ExitDecBlock                                                                                    ; 
LDA #$00                      ; if set, init for the next one                                       ;  B
STA Hidden1UpFlag                                                                                   ; 
JMP BrickWithItem             ; jump to code shared with unbreakable bricks                         ; 
                                                                                                    ;  B
QuestionBlock:                                                                                      ;  B
JSR GetAreaObjectID           ; get value from level decoder routine                                ; 
JMP DrawQBlk                  ; go to render it                                                     ; 
                                                                                                    ;  B
BrickWithCoins:                                                                                     ;  B
LDA #$00                      ; initialize multi-coin timer flag                                    ; 
STA BrickCoinTimerFlag                                                                              ; 
                                                                                                    ; 
BrickWithItem:                                                                                      ;  B
JSR GetAreaObjectID           ; save area object ID                                                 ; 
STY $07                                                                                             ; 
LDA #$00                      ; load default adder for bricks with lines                            ; 
LDY AreaType                  ; check level type for ground level                                   ; 
DEY                                                                                                 ; 
BEQ BWithL                    ; if ground type, do not start with 5                                 ; 
LDA #$05                      ; otherwise use adder for bricks without lines                        ;  B
BWithL:  CLC                  ; add object ID to adder                                              ;  B
ADC $07                                                                                             ; 
TAY                           ; use as offset for metatile                                          ; 
DrawQBlk:  LDA BrickQBlockMetatiles,Y; get appropriate metatile for brick (question block           ;  B
PHA                           ; if branched to here from question block routine)                    ; 
JSR GetLrgObjAttrib           ; get row from location byte                                          ; 
JMP DrawRow                   ; now render the object                                               ; 
                                                                                                    ;  B
GetAreaObjectID:                                                                                    ; fun($00): Y B
LDA $00                       ; get value saved from area parser routine                            ; 
SEC                                                                                                 ; 
SBC #$00                      ; possibly residual code                                              ; 
TAY                           ; save to Y                                                           ; 
ExitDecBlock:  RTS                                                                                  ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
HoleMetatiles:                                                                                      ;  B
DATA: ByteValue(value=135), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0)              ; 
                                                                                                    ; 
Hole_Empty:                                                                                         ;  B
JSR ChkLrgObjLength           ; get lower nybble and save as length                                 ; 
BCC NoWhirlP                  ; skip this part if length already loaded                             ; 
LDA AreaType                  ; check for water type level                                          ;  B
BNE NoWhirlP                  ; if not water type, skip this part                                   ; 
LDX Whirlpool_Offset          ; get offset for data used by cannons and whirlpools                  ;  B
JSR GetAreaObjXPosition       ; get proper vertical coordinate of where we're at                    ; 
SEC                                                                                                 ; 
SBC #$10                      ; subtract 16 pixels                                                  ; 
STA Whirlpool_LeftExtent,X    ; store as left extent of whirlpool                                   ; 
LDA CurrentPageLoc            ; get page location of where we're at                                 ; 
SBC #$00                      ; subtract borrow                                                     ; 
STA Whirlpool_PageLoc,X       ; save as page location of whirlpool                                  ; 
INY                                                                                                 ; 
INY                           ; increment length by 2                                               ; 
TYA                                                                                                 ; 
ASL                           ; multiply by 16 to get size of whirlpool                             ; 
ASL                           ; note that whirlpool will always be                                  ; 
ASL                           ; two blocks bigger than actual size of hole                          ; 
ASL                           ; and extend one block beyond each edge                               ; 
STA Whirlpool_Length,X        ; save size of whirlpool here                                         ; 
INX                                                                                                 ; 
CPX #$05                      ; increment and check offset                                          ; 
BCC StrWOffset                ; if not yet reached fifth whirlpool, branch to save offset           ; 
LDX #$00                      ; otherwise initialize it                                             ;  B
StrWOffset:  STX Whirlpool_Offset; save new offset here                                             ;  B
NoWhirlP:  LDX AreaType       ; get appropriate metatile, then                                      ;  B
LDA HoleMetatiles,X           ; render the hole proper                                              ; 
LDX #$08                                                                                            ; 
LDY #$0f                      ; start at ninth row and go to bottom, run RenderUnderPart            ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RenderUnderPart:                                                                                    ; fun(YAX):  B
STY AreaObjectHeight          ; store vertical length to render                                     ; 
LDY MetatileBuffer,X          ; check current spot to see if there's something                      ; 
BEQ DrawThisRow               ; we need to keep, if nothing, go ahead                               ; 
CPY #$17                                                                                            ;  B
BEQ WaitOneRow                ; if middle part (tree ledge), wait until next row                    ; 
CPY #$1a                                                                                            ;  B
BEQ WaitOneRow                ; if middle part (mushroom ledge), wait until next row                ; 
CPY #$c0                                                                                            ;  B
BEQ DrawThisRow               ; if question block w/ coin, overwrite                                ; 
CPY #$c0                                                                                            ;  B
BCS WaitOneRow                ; if any other metatile with palette 3, wait until next row           ; 
CPY #$54                                                                                            ;  B
BNE DrawThisRow               ; if cracked rock terrain, overwrite                                  ; 
CMP #$50                                                                                            ;  B
BEQ WaitOneRow                ; if stem top of mushroom, wait until next row                        ; 
DrawThisRow:  STA MetatileBuffer,X; render contents of A from routine that called this              ;  B
WaitOneRow:  INX                                                                                    ;  B
CPX #$0d                      ; stop rendering if we're at the bottom of the screen                 ; 
BCS ExitUPartR                                                                                      ; 
LDY AreaObjectHeight          ; decrement, and stop rendering if there is no more length            ;  B
DEY                                                                                                 ; 
BPL RenderUnderPart                                                                                 ; 
ExitUPartR:  RTS                                                                                    ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ChkLrgObjLength:                                                                                    ; fun():  B
JSR GetLrgObjAttrib           ; get row location and size (length if branched to from here)         ; 
                                                                                                    ; 
ChkLrgObjFixedLength:                                                                               ; fun(Y): CarryFlag B
LDA AreaObjectLength,X        ; check for set length counter                                        ; 
CLC                           ; clear carry flag for not just starting                              ; 
BPL LenSet                    ; if counter not set, load it, otherwise leave alone                  ; 
TYA                           ; save length into length counter                                     ;  B
STA AreaObjectLength,X                                                                              ; 
SEC                           ; set carry flag if just starting                                     ; 
LenSet:  RTS                                                                                        ;  B
                                                                                                    ;  B
                                                                                                    ; 
GetLrgObjAttrib:                                                                                    ; fun(): Y$07A B
LDY AreaObjOffsetBuffer,X     ; get offset saved from area obj decoding routine                     ; 
LDA (AreaData),Y              ; get first byte of level object                                      ; 
AND #%00001111                                                                                      ; 
STA $07                       ; save row location                                                   ; 
INY                                                                                                 ; 
LDA (AreaData),Y              ; get next byte, save lower nybble (length or height)                 ; 
AND #%00001111                ; as Y, then leave                                                    ; 
TAY                                                                                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
GetAreaObjXPosition:                                                                                ; fun(): A B
LDA CurrentColumnPos          ; multiply current offset where we're at by 16                        ; 
ASL                           ; to obtain horizontal pixel coordinate                               ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
GetAreaObjYPosition:                                                                                ; fun($07): A B
LDA $07                       ; multiply value by 16                                                ; 
ASL                                                                                                 ; 
ASL                           ; this will give us the proper vertical pixel coordinate              ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
CLC                                                                                                 ; 
ADC #32                       ; add 32 pixels for the status bar                                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $06-$07 - used to store block buffer address used as indirect       ; 
                                                                                                    ; 
BlockBufferAddr:                                                                                    ;  B
DATA: Expr(expr=<Block_Buffer_1), Expr(expr=<Block_Buffer_2)                                        ; 
DATA: Expr(expr=>Block_Buffer_1), Expr(expr=>Block_Buffer_2)                                        ; 
                                                                                                    ; 
GetBlockBufferAddr:                                                                                 ; fun(A):  B
PHA                           ; take value of A, save                                               ; 
LSR                           ; move high nybble to low                                             ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
TAY                           ; use nybble as pointer to high byte                                  ; 
LDA BlockBufferAddr+2,Y       ; of indirect here                                                    ; 
STA $07                                                                                             ; 
PLA                                                                                                 ; 
AND #%00001111                ; pull from stack, mask out high nybble                               ; 
CLC                                                                                                 ; 
ADC BlockBufferAddr,Y         ; add to low byte                                                     ; 
STA $06                       ; store here and leave                                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; unused space                                                        ; 
DATA: ByteValue(value=255), ByteValue(value=255)                                                    ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
AreaDataOfsLoopback:                                                                                ;  B
DATA: ByteValue(value=18), ByteValue(value=54), ByteValue(value=14), ByteValue(value=14), ByteValue(value=14), ByteValue(value=50), ByteValue(value=50), ByteValue(value=50), ByteValue(value=10), ByteValue(value=38), ByteValue(value=64); 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
LoadAreaPointer:                                                                                    ; fun(A):  B
JSR FindAreaPointer           ; find it and store it here                                           ; 
STA AreaPointer                                                                                     ; 
GetAreaType:  AND #%01100000  ; mask out all but d6 and d5                                          ; fun(A): A B
ASL                                                                                                 ; 
ROL                                                                                                 ; 
ROL                                                                                                 ; 
ROL                           ; make %0xx00000 into %000000xx                                       ; 
STA AreaType                  ; save 2 MSB as area type                                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
FindAreaPointer:                                                                                    ; fun(): A B
LDY WorldNumber               ; load offset from world variable                                     ; 
LDA WorldAddrOffsets,Y                                                                              ; 
CLC                           ; add area number used to find data                                   ; 
ADC AreaNumber                                                                                      ; 
TAY                                                                                                 ; 
LDA AreaAddrOffsets,Y         ; from there we have our area pointer                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                                                                                                    ; 
GetAreaDataAddrs:                                                                                   ; fun():  B
LDA AreaPointer               ; use 2 MSB for Y                                                     ; 
JSR GetAreaType                                                                                     ; 
TAY                                                                                                 ; 
LDA AreaPointer               ; mask out all but 5 LSB                                              ; 
AND #%00011111                                                                                      ; 
STA AreaAddrsLOffset          ; save as low offset                                                  ; 
LDA EnemyAddrHOffsets,Y       ; load base value with 2 altered MSB,                                 ; 
CLC                           ; then add base value to 5 LSB, result                                ; 
ADC AreaAddrsLOffset          ; becomes offset for level data                                       ; 
TAY                                                                                                 ; 
LDA EnemyDataAddrLow,Y        ; use offset to load pointer                                          ; 
STA EnemyDataLow                                                                                    ; 
LDA EnemyDataAddrHigh,Y                                                                             ; 
STA EnemyDataHigh                                                                                   ; 
LDY AreaType                  ; use area type as offset                                             ; 
LDA AreaDataHOffsets,Y        ; do the same thing but with different base value                     ; 
CLC                                                                                                 ; 
ADC AreaAddrsLOffset                                                                                ; 
TAY                                                                                                 ; 
LDA AreaDataAddrLow,Y         ; use this offset to load another pointer                             ; 
STA AreaDataLow                                                                                     ; 
LDA AreaDataAddrHigh,Y                                                                              ; 
STA AreaDataHigh                                                                                    ; 
LDY #$00                      ; load first byte of header                                           ; 
LDA (AreaData),Y                                                                                    ; 
PHA                           ; save it to the stack for now                                        ; 
AND #%00000111                ; save 3 LSB for foreground scenery or bg color control               ; 
CMP #$04                                                                                            ; 
BCC StoreFore                                                                                       ; 
STA BackgroundColorCtrl       ; if 4 or greater, save value here as bg color control                ;  B
LDA #$00                                                                                            ; 
StoreFore:  STA ForegroundScenery; if less, save value here as foreground scenery                   ;  B
PLA                           ; pull byte from stack and push it back                               ; 
PHA                                                                                                 ; 
AND #%00111000                ; save player entrance control bits                                   ; 
LSR                           ; shift bits over to LSBs                                             ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
STA PlayerEntranceCtrl        ; save value here as player entrance control                          ; 
PLA                           ; pull byte again but do not push it back                             ; 
AND #%11000000                ; save 2 MSB for game timer setting                                   ; 
CLC                                                                                                 ; 
ROL                           ; rotate bits over to LSBs                                            ; 
ROL                                                                                                 ; 
ROL                                                                                                 ; 
STA GameTimerSetting          ; save value here as game timer setting                               ; 
INY                                                                                                 ; 
LDA (AreaData),Y              ; load second byte of header                                          ; 
PHA                           ; save to stack                                                       ; 
AND #%00001111                ; mask out all but lower nybble                                       ; 
STA TerrainControl                                                                                  ; 
PLA                           ; pull and push byte to copy it to A                                  ; 
PHA                                                                                                 ; 
AND #%00110000                ; save 2 MSB for background scenery type                              ; 
LSR                                                                                                 ; 
LSR                           ; shift bits to LSBs                                                  ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
STA BackgroundScenery         ; save as background scenery                                          ; 
PLA                                                                                                 ; 
AND #%11000000                                                                                      ; 
CLC                                                                                                 ; 
ROL                           ; rotate bits over to LSBs                                            ; 
ROL                                                                                                 ; 
ROL                                                                                                 ; 
CMP #%00000011                ; if set to 3, store here                                             ; 
BNE StoreStyle                ; and nullify other value                                             ; 
STA CloudTypeOverride         ; otherwise store value in other place                                ;  B
LDA #$00                                                                                            ; 
StoreStyle:  STA AreaStyle                                                                          ;  B
LDA AreaDataLow               ; increment area data address by 2 bytes                              ; 
CLC                                                                                                 ; 
ADC #$02                                                                                            ; 
STA AreaDataLow                                                                                     ; 
LDA AreaDataHigh                                                                                    ; 
ADC #$00                                                                                            ; 
STA AreaDataHigh                                                                                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; GAME LEVELS DATA                                                    ; 
                                                                                                    ; 
WorldAddrOffsets:                                                                                   ;  B
DATA: Expr(expr=World1Areas-AreaAddrOffsets), Expr(expr=World2Areas-AreaAddrOffsets)                ; 
DATA: Expr(expr=World3Areas-AreaAddrOffsets), Expr(expr=World4Areas-AreaAddrOffsets)                ; 
DATA: Expr(expr=World5Areas-AreaAddrOffsets), Expr(expr=World6Areas-AreaAddrOffsets)                ; 
DATA: Expr(expr=World7Areas-AreaAddrOffsets), Expr(expr=World8Areas-AreaAddrOffsets)                ; 
                                                                                                    ; 
AreaAddrOffsets:                                                                                    ;  B
World1Areas:  DATA: ByteValue(value=37), ByteValue(value=41), ByteValue(value=192), ByteValue(value=38), ByteValue(value=96);  B
World2Areas:  DATA: ByteValue(value=40), ByteValue(value=41), ByteValue(value=1), ByteValue(value=39), ByteValue(value=98);  B
World3Areas:  DATA: ByteValue(value=36), ByteValue(value=53), ByteValue(value=32), ByteValue(value=99);  B
World4Areas:  DATA: ByteValue(value=34), ByteValue(value=41), ByteValue(value=65), ByteValue(value=44), ByteValue(value=97);  B
World5Areas:  DATA: ByteValue(value=42), ByteValue(value=49), ByteValue(value=38), ByteValue(value=98);  B
World6Areas:  DATA: ByteValue(value=46), ByteValue(value=35), ByteValue(value=45), ByteValue(value=96);  B
World7Areas:  DATA: ByteValue(value=51), ByteValue(value=41), ByteValue(value=1), ByteValue(value=39), ByteValue(value=100);  B
World8Areas:  DATA: ByteValue(value=48), ByteValue(value=50), ByteValue(value=33), ByteValue(value=101);  B
                                                                                                    ; 
                              ; bonus area data offsets, included here for comparison purposes      ; 
                              ; underground bonus area  - c2                                        ; 
                              ; cloud area 1 (day)      - 2b                                        ; 
                              ; cloud area 2 (night)    - 34                                        ; 
                              ; water area (5-2/6-2)    - 00                                        ; 
                              ; water area (8-4)        - 02                                        ; 
                              ; warp zone area (4-2)    - 2f                                        ; 
                                                                                                    ; 
EnemyAddrHOffsets:                                                                                  ;  B
DATA: ByteValue(value=31), ByteValue(value=6), ByteValue(value=28), ByteValue(value=0)              ; 
                                                                                                    ; 
EnemyDataAddrLow:                                                                                   ;  B
DATA: Expr(expr=<E_CastleArea1), Expr(expr=<E_CastleArea2), Expr(expr=<E_CastleArea3), Expr(expr=<E_CastleArea4), Expr(expr=<E_CastleArea5), Expr(expr=<E_CastleArea6); 
DATA: Expr(expr=<E_GroundArea1), Expr(expr=<E_GroundArea2), Expr(expr=<E_GroundArea3), Expr(expr=<E_GroundArea4), Expr(expr=<E_GroundArea5), Expr(expr=<E_GroundArea6); 
DATA: Expr(expr=<E_GroundArea7), Expr(expr=<E_GroundArea8), Expr(expr=<E_GroundArea9), Expr(expr=<E_GroundArea10), Expr(expr=<E_GroundArea11), Expr(expr=<E_GroundArea12); 
DATA: Expr(expr=<E_GroundArea13), Expr(expr=<E_GroundArea14), Expr(expr=<E_GroundArea15), Expr(expr=<E_GroundArea16), Expr(expr=<E_GroundArea17), Expr(expr=<E_GroundArea18); 
DATA: Expr(expr=<E_GroundArea19), Expr(expr=<E_GroundArea20), Expr(expr=<E_GroundArea21), Expr(expr=<E_GroundArea22), Expr(expr=<E_UndergroundArea1); 
DATA: Expr(expr=<E_UndergroundArea2), Expr(expr=<E_UndergroundArea3), Expr(expr=<E_WaterArea1), Expr(expr=<E_WaterArea2), Expr(expr=<E_WaterArea3); 
                                                                                                    ; 
EnemyDataAddrHigh:                                                                                  ;  B
DATA: Expr(expr=>E_CastleArea1), Expr(expr=>E_CastleArea2), Expr(expr=>E_CastleArea3), Expr(expr=>E_CastleArea4), Expr(expr=>E_CastleArea5), Expr(expr=>E_CastleArea6); 
DATA: Expr(expr=>E_GroundArea1), Expr(expr=>E_GroundArea2), Expr(expr=>E_GroundArea3), Expr(expr=>E_GroundArea4), Expr(expr=>E_GroundArea5), Expr(expr=>E_GroundArea6); 
DATA: Expr(expr=>E_GroundArea7), Expr(expr=>E_GroundArea8), Expr(expr=>E_GroundArea9), Expr(expr=>E_GroundArea10), Expr(expr=>E_GroundArea11), Expr(expr=>E_GroundArea12); 
DATA: Expr(expr=>E_GroundArea13), Expr(expr=>E_GroundArea14), Expr(expr=>E_GroundArea15), Expr(expr=>E_GroundArea16), Expr(expr=>E_GroundArea17), Expr(expr=>E_GroundArea18); 
DATA: Expr(expr=>E_GroundArea19), Expr(expr=>E_GroundArea20), Expr(expr=>E_GroundArea21), Expr(expr=>E_GroundArea22), Expr(expr=>E_UndergroundArea1); 
DATA: Expr(expr=>E_UndergroundArea2), Expr(expr=>E_UndergroundArea3), Expr(expr=>E_WaterArea1), Expr(expr=>E_WaterArea2), Expr(expr=>E_WaterArea3); 
                                                                                                    ; 
AreaDataHOffsets:                                                                                   ;  B
DATA: ByteValue(value=0), ByteValue(value=3), ByteValue(value=25), ByteValue(value=28)              ; 
                                                                                                    ; 
AreaDataAddrLow:                                                                                    ;  B
DATA: Expr(expr=<L_WaterArea1), Expr(expr=<L_WaterArea2), Expr(expr=<L_WaterArea3), Expr(expr=<L_GroundArea1), Expr(expr=<L_GroundArea2), Expr(expr=<L_GroundArea3); 
DATA: Expr(expr=<L_GroundArea4), Expr(expr=<L_GroundArea5), Expr(expr=<L_GroundArea6), Expr(expr=<L_GroundArea7), Expr(expr=<L_GroundArea8), Expr(expr=<L_GroundArea9); 
DATA: Expr(expr=<L_GroundArea10), Expr(expr=<L_GroundArea11), Expr(expr=<L_GroundArea12), Expr(expr=<L_GroundArea13), Expr(expr=<L_GroundArea14), Expr(expr=<L_GroundArea15); 
DATA: Expr(expr=<L_GroundArea16), Expr(expr=<L_GroundArea17), Expr(expr=<L_GroundArea18), Expr(expr=<L_GroundArea19), Expr(expr=<L_GroundArea20), Expr(expr=<L_GroundArea21); 
DATA: Expr(expr=<L_GroundArea22), Expr(expr=<L_UndergroundArea1), Expr(expr=<L_UndergroundArea2), Expr(expr=<L_UndergroundArea3), Expr(expr=<L_CastleArea1); 
DATA: Expr(expr=<L_CastleArea2), Expr(expr=<L_CastleArea3), Expr(expr=<L_CastleArea4), Expr(expr=<L_CastleArea5), Expr(expr=<L_CastleArea6); 
                                                                                                    ; 
AreaDataAddrHigh:                                                                                   ;  B
DATA: Expr(expr=>L_WaterArea1), Expr(expr=>L_WaterArea2), Expr(expr=>L_WaterArea3), Expr(expr=>L_GroundArea1), Expr(expr=>L_GroundArea2), Expr(expr=>L_GroundArea3); 
DATA: Expr(expr=>L_GroundArea4), Expr(expr=>L_GroundArea5), Expr(expr=>L_GroundArea6), Expr(expr=>L_GroundArea7), Expr(expr=>L_GroundArea8), Expr(expr=>L_GroundArea9); 
DATA: Expr(expr=>L_GroundArea10), Expr(expr=>L_GroundArea11), Expr(expr=>L_GroundArea12), Expr(expr=>L_GroundArea13), Expr(expr=>L_GroundArea14), Expr(expr=>L_GroundArea15); 
DATA: Expr(expr=>L_GroundArea16), Expr(expr=>L_GroundArea17), Expr(expr=>L_GroundArea18), Expr(expr=>L_GroundArea19), Expr(expr=>L_GroundArea20), Expr(expr=>L_GroundArea21); 
DATA: Expr(expr=>L_GroundArea22), Expr(expr=>L_UndergroundArea1), Expr(expr=>L_UndergroundArea2), Expr(expr=>L_UndergroundArea3), Expr(expr=>L_CastleArea1); 
DATA: Expr(expr=>L_CastleArea2), Expr(expr=>L_CastleArea3), Expr(expr=>L_CastleArea4), Expr(expr=>L_CastleArea5), Expr(expr=>L_CastleArea6); 
                                                                                                    ; 
                              ; ENEMY OBJECT DATA                                                   ; 
                                                                                                    ; 
                              ; level 1-4/6-4                                                       ; 
E_CastleArea1:                                                                                      ;  B
DATA: ByteValue(value=118), ByteValue(value=221), ByteValue(value=187), ByteValue(value=76), ByteValue(value=234), ByteValue(value=29), ByteValue(value=27), ByteValue(value=204), ByteValue(value=86), ByteValue(value=93); 
DATA: ByteValue(value=22), ByteValue(value=157), ByteValue(value=198), ByteValue(value=29), ByteValue(value=54), ByteValue(value=157), ByteValue(value=201), ByteValue(value=29), ByteValue(value=4), ByteValue(value=219); 
DATA: ByteValue(value=73), ByteValue(value=29), ByteValue(value=132), ByteValue(value=27), ByteValue(value=201), ByteValue(value=93), ByteValue(value=136), ByteValue(value=149), ByteValue(value=15), ByteValue(value=8); 
DATA: ByteValue(value=48), ByteValue(value=76), ByteValue(value=120), ByteValue(value=45), ByteValue(value=166), ByteValue(value=40), ByteValue(value=144), ByteValue(value=181); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 4-4                                                           ; 
E_CastleArea2:                                                                                      ;  B
DATA: ByteValue(value=15), ByteValue(value=3), ByteValue(value=86), ByteValue(value=27), ByteValue(value=201), ByteValue(value=27), ByteValue(value=15), ByteValue(value=7), ByteValue(value=54), ByteValue(value=27); 
DATA: ByteValue(value=170), ByteValue(value=27), ByteValue(value=72), ByteValue(value=149), ByteValue(value=15), ByteValue(value=10), ByteValue(value=42), ByteValue(value=27), ByteValue(value=91), ByteValue(value=12); 
DATA: ByteValue(value=120), ByteValue(value=45), ByteValue(value=144), ByteValue(value=181)         ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 2-4/5-4                                                       ; 
E_CastleArea3:                                                                                      ;  B
DATA: ByteValue(value=11), ByteValue(value=140), ByteValue(value=75), ByteValue(value=76), ByteValue(value=119), ByteValue(value=95), ByteValue(value=235), ByteValue(value=12), ByteValue(value=189), ByteValue(value=219); 
DATA: ByteValue(value=25), ByteValue(value=157), ByteValue(value=117), ByteValue(value=29), ByteValue(value=125), ByteValue(value=91), ByteValue(value=217), ByteValue(value=29), ByteValue(value=61), ByteValue(value=221); 
DATA: ByteValue(value=153), ByteValue(value=29), ByteValue(value=38), ByteValue(value=157), ByteValue(value=90), ByteValue(value=43), ByteValue(value=138), ByteValue(value=44), ByteValue(value=202), ByteValue(value=27); 
DATA: ByteValue(value=32), ByteValue(value=149), ByteValue(value=123), ByteValue(value=92), ByteValue(value=219), ByteValue(value=76), ByteValue(value=27), ByteValue(value=204), ByteValue(value=59), ByteValue(value=204); 
DATA: ByteValue(value=120), ByteValue(value=45), ByteValue(value=166), ByteValue(value=40), ByteValue(value=144), ByteValue(value=181); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 3-4                                                           ; 
E_CastleArea4:                                                                                      ;  B
DATA: ByteValue(value=11), ByteValue(value=140), ByteValue(value=59), ByteValue(value=29), ByteValue(value=139), ByteValue(value=29), ByteValue(value=171), ByteValue(value=12), ByteValue(value=219), ByteValue(value=29); 
DATA: ByteValue(value=15), ByteValue(value=3), ByteValue(value=101), ByteValue(value=29), ByteValue(value=107), ByteValue(value=27), ByteValue(value=5), ByteValue(value=157), ByteValue(value=11), ByteValue(value=27); 
DATA: ByteValue(value=5), ByteValue(value=155), ByteValue(value=11), ByteValue(value=29), ByteValue(value=139), ByteValue(value=12), ByteValue(value=27), ByteValue(value=140), ByteValue(value=112), ByteValue(value=21); 
DATA: ByteValue(value=123), ByteValue(value=12), ByteValue(value=219), ByteValue(value=12), ByteValue(value=15), ByteValue(value=8), ByteValue(value=120), ByteValue(value=45), ByteValue(value=166), ByteValue(value=40); 
DATA: ByteValue(value=144), ByteValue(value=181)                                                    ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 7-4                                                           ; 
E_CastleArea5:                                                                                      ;  B
DATA: ByteValue(value=39), ByteValue(value=169), ByteValue(value=75), ByteValue(value=12), ByteValue(value=104), ByteValue(value=41), ByteValue(value=15), ByteValue(value=6), ByteValue(value=119), ByteValue(value=27); 
DATA: ByteValue(value=15), ByteValue(value=11), ByteValue(value=96), ByteValue(value=21), ByteValue(value=75), ByteValue(value=140), ByteValue(value=120), ByteValue(value=45), ByteValue(value=144), ByteValue(value=181); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 8-4                                                           ; 
E_CastleArea6:                                                                                      ;  B
DATA: ByteValue(value=15), ByteValue(value=3), ByteValue(value=142), ByteValue(value=101), ByteValue(value=225), ByteValue(value=187), ByteValue(value=56), ByteValue(value=109), ByteValue(value=168), ByteValue(value=62), ByteValue(value=229), ByteValue(value=231); 
DATA: ByteValue(value=15), ByteValue(value=8), ByteValue(value=11), ByteValue(value=2), ByteValue(value=43), ByteValue(value=2), ByteValue(value=94), ByteValue(value=101), ByteValue(value=225), ByteValue(value=187), ByteValue(value=14); 
DATA: ByteValue(value=219), ByteValue(value=14), ByteValue(value=187), ByteValue(value=142), ByteValue(value=219), ByteValue(value=14), ByteValue(value=254), ByteValue(value=101), ByteValue(value=236), ByteValue(value=15), ByteValue(value=13); 
DATA: ByteValue(value=78), ByteValue(value=101), ByteValue(value=225), ByteValue(value=15), ByteValue(value=14), ByteValue(value=78), ByteValue(value=2), ByteValue(value=224), ByteValue(value=15), ByteValue(value=16), ByteValue(value=254), ByteValue(value=229), ByteValue(value=225); 
DATA: ByteValue(value=27), ByteValue(value=133), ByteValue(value=123), ByteValue(value=12), ByteValue(value=91), ByteValue(value=149), ByteValue(value=120), ByteValue(value=45), ByteValue(value=144), ByteValue(value=181); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 3-3                                                           ; 
E_GroundArea1:                                                                                      ;  B
DATA: ByteValue(value=165), ByteValue(value=134), ByteValue(value=228), ByteValue(value=40), ByteValue(value=24), ByteValue(value=168), ByteValue(value=69), ByteValue(value=131), ByteValue(value=105), ByteValue(value=3); 
DATA: ByteValue(value=198), ByteValue(value=41), ByteValue(value=155), ByteValue(value=131), ByteValue(value=22), ByteValue(value=164), ByteValue(value=136), ByteValue(value=36), ByteValue(value=233), ByteValue(value=40); 
DATA: ByteValue(value=5), ByteValue(value=168), ByteValue(value=123), ByteValue(value=40), ByteValue(value=36), ByteValue(value=143), ByteValue(value=200), ByteValue(value=3), ByteValue(value=232), ByteValue(value=3); 
DATA: ByteValue(value=70), ByteValue(value=168), ByteValue(value=133), ByteValue(value=36), ByteValue(value=200), ByteValue(value=36); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 8-3                                                           ; 
E_GroundArea2:                                                                                      ;  B
DATA: ByteValue(value=235), ByteValue(value=142), ByteValue(value=15), ByteValue(value=3), ByteValue(value=251), ByteValue(value=5), ByteValue(value=23), ByteValue(value=133), ByteValue(value=219), ByteValue(value=142); 
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=87), ByteValue(value=5), ByteValue(value=123), ByteValue(value=5), ByteValue(value=155), ByteValue(value=128), ByteValue(value=43), ByteValue(value=133); 
DATA: ByteValue(value=251), ByteValue(value=5), ByteValue(value=15), ByteValue(value=11), ByteValue(value=27), ByteValue(value=5), ByteValue(value=155), ByteValue(value=5); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 4-1                                                           ; 
E_GroundArea3:                                                                                      ;  B
DATA: ByteValue(value=46), ByteValue(value=194), ByteValue(value=102), ByteValue(value=226), ByteValue(value=17), ByteValue(value=15), ByteValue(value=7), ByteValue(value=2), ByteValue(value=17), ByteValue(value=15), ByteValue(value=12); 
DATA: ByteValue(value=18), ByteValue(value=17)                                                      ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 6-2                                                           ; 
E_GroundArea4:                                                                                      ;  B
DATA: ByteValue(value=14), ByteValue(value=194), ByteValue(value=168), ByteValue(value=171), ByteValue(value=0), ByteValue(value=187), ByteValue(value=142), ByteValue(value=107), ByteValue(value=130), ByteValue(value=222), ByteValue(value=0), ByteValue(value=160); 
DATA: ByteValue(value=51), ByteValue(value=134), ByteValue(value=67), ByteValue(value=6), ByteValue(value=62), ByteValue(value=180), ByteValue(value=160), ByteValue(value=203), ByteValue(value=2), ByteValue(value=15), ByteValue(value=7); 
DATA: ByteValue(value=126), ByteValue(value=66), ByteValue(value=166), ByteValue(value=131), ByteValue(value=2), ByteValue(value=15), ByteValue(value=10), ByteValue(value=59), ByteValue(value=2), ByteValue(value=203), ByteValue(value=55); 
DATA: ByteValue(value=15), ByteValue(value=12), ByteValue(value=227), ByteValue(value=14)           ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 3-1                                                           ; 
E_GroundArea5:                                                                                      ;  B
DATA: ByteValue(value=155), ByteValue(value=142), ByteValue(value=202), ByteValue(value=14), ByteValue(value=238), ByteValue(value=66), ByteValue(value=68), ByteValue(value=91), ByteValue(value=134), ByteValue(value=128), ByteValue(value=184); 
DATA: ByteValue(value=27), ByteValue(value=128), ByteValue(value=80), ByteValue(value=186), ByteValue(value=16), ByteValue(value=183), ByteValue(value=91), ByteValue(value=0), ByteValue(value=23), ByteValue(value=133); 
DATA: ByteValue(value=75), ByteValue(value=5), ByteValue(value=254), ByteValue(value=52), ByteValue(value=64), ByteValue(value=183), ByteValue(value=134), ByteValue(value=198), ByteValue(value=6), ByteValue(value=91), ByteValue(value=128); 
DATA: ByteValue(value=131), ByteValue(value=0), ByteValue(value=208), ByteValue(value=56), ByteValue(value=91), ByteValue(value=142), ByteValue(value=138), ByteValue(value=14), ByteValue(value=166), ByteValue(value=0); 
DATA: ByteValue(value=187), ByteValue(value=14), ByteValue(value=197), ByteValue(value=128), ByteValue(value=243), ByteValue(value=0); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 1-1                                                           ; 
E_GroundArea6:                                                                                      ;  B
DATA: ByteValue(value=30), ByteValue(value=194), ByteValue(value=0), ByteValue(value=107), ByteValue(value=6), ByteValue(value=139), ByteValue(value=134), ByteValue(value=99), ByteValue(value=183), ByteValue(value=15), ByteValue(value=5); 
DATA: ByteValue(value=3), ByteValue(value=6), ByteValue(value=35), ByteValue(value=6), ByteValue(value=75), ByteValue(value=183), ByteValue(value=187), ByteValue(value=0), ByteValue(value=91), ByteValue(value=183); 
DATA: ByteValue(value=251), ByteValue(value=55), ByteValue(value=59), ByteValue(value=183), ByteValue(value=15), ByteValue(value=11), ByteValue(value=27), ByteValue(value=55); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 1-3/5-3                                                       ; 
E_GroundArea7:                                                                                      ;  B
DATA: ByteValue(value=43), ByteValue(value=215), ByteValue(value=227), ByteValue(value=3), ByteValue(value=194), ByteValue(value=134), ByteValue(value=226), ByteValue(value=6), ByteValue(value=118), ByteValue(value=165); 
DATA: ByteValue(value=163), ByteValue(value=143), ByteValue(value=3), ByteValue(value=134), ByteValue(value=43), ByteValue(value=87), ByteValue(value=104), ByteValue(value=40), ByteValue(value=233), ByteValue(value=40); 
DATA: ByteValue(value=229), ByteValue(value=131), ByteValue(value=36), ByteValue(value=143), ByteValue(value=54), ByteValue(value=168), ByteValue(value=91), ByteValue(value=3); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 2-3/7-3                                                       ; 
E_GroundArea8:                                                                                      ;  B
DATA: ByteValue(value=15), ByteValue(value=2), ByteValue(value=120), ByteValue(value=64), ByteValue(value=72), ByteValue(value=206), ByteValue(value=248), ByteValue(value=195), ByteValue(value=248), ByteValue(value=195); 
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=123), ByteValue(value=67), ByteValue(value=198), ByteValue(value=208), ByteValue(value=15), ByteValue(value=138), ByteValue(value=200), ByteValue(value=80); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 2-1                                                           ; 
E_GroundArea9:                                                                                      ;  B
DATA: ByteValue(value=133), ByteValue(value=134), ByteValue(value=11), ByteValue(value=128), ByteValue(value=27), ByteValue(value=0), ByteValue(value=219), ByteValue(value=55), ByteValue(value=119), ByteValue(value=128); 
DATA: ByteValue(value=235), ByteValue(value=55), ByteValue(value=254), ByteValue(value=43), ByteValue(value=32), ByteValue(value=43), ByteValue(value=128), ByteValue(value=123), ByteValue(value=56), ByteValue(value=171), ByteValue(value=184); 
DATA: ByteValue(value=119), ByteValue(value=134), ByteValue(value=254), ByteValue(value=66), ByteValue(value=32), ByteValue(value=73), ByteValue(value=134), ByteValue(value=139), ByteValue(value=6), ByteValue(value=155), ByteValue(value=128); 
DATA: ByteValue(value=123), ByteValue(value=142), ByteValue(value=91), ByteValue(value=183), ByteValue(value=155), ByteValue(value=14), ByteValue(value=187), ByteValue(value=14), ByteValue(value=155), ByteValue(value=128); 
                              ; end of data terminator here is also used by pipe intro area         ; 
E_GroundArea10:                                                                                     ;  B
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 5-1                                                           ; 
E_GroundArea11:                                                                                     ;  B
DATA: ByteValue(value=11), ByteValue(value=128), ByteValue(value=96), ByteValue(value=56), ByteValue(value=16), ByteValue(value=184), ByteValue(value=192), ByteValue(value=59), ByteValue(value=219), ByteValue(value=142); 
DATA: ByteValue(value=64), ByteValue(value=184), ByteValue(value=240), ByteValue(value=56), ByteValue(value=123), ByteValue(value=142), ByteValue(value=160), ByteValue(value=184), ByteValue(value=192), ByteValue(value=184); 
DATA: ByteValue(value=251), ByteValue(value=0), ByteValue(value=160), ByteValue(value=184), ByteValue(value=48), ByteValue(value=187), ByteValue(value=238), ByteValue(value=66), ByteValue(value=136), ByteValue(value=15), ByteValue(value=11); 
DATA: ByteValue(value=43), ByteValue(value=14), ByteValue(value=103), ByteValue(value=14)           ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; cloud level used in levels 2-1 and 5-2                              ; 
E_GroundArea12:                                                                                     ;  B
DATA: ByteValue(value=10), ByteValue(value=170), ByteValue(value=14), ByteValue(value=40), ByteValue(value=42), ByteValue(value=14), ByteValue(value=49), ByteValue(value=136); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 4-3                                                           ; 
E_GroundArea13:                                                                                     ;  B
DATA: ByteValue(value=199), ByteValue(value=131), ByteValue(value=215), ByteValue(value=3), ByteValue(value=66), ByteValue(value=143), ByteValue(value=122), ByteValue(value=3), ByteValue(value=5), ByteValue(value=164); 
DATA: ByteValue(value=120), ByteValue(value=36), ByteValue(value=166), ByteValue(value=37), ByteValue(value=228), ByteValue(value=37), ByteValue(value=75), ByteValue(value=131), ByteValue(value=227), ByteValue(value=3); 
DATA: ByteValue(value=5), ByteValue(value=164), ByteValue(value=137), ByteValue(value=36), ByteValue(value=181), ByteValue(value=36), ByteValue(value=9), ByteValue(value=164), ByteValue(value=101), ByteValue(value=36); 
DATA: ByteValue(value=201), ByteValue(value=36), ByteValue(value=15), ByteValue(value=8), ByteValue(value=133), ByteValue(value=37); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 6-3                                                           ; 
E_GroundArea14:                                                                                     ;  B
DATA: ByteValue(value=205), ByteValue(value=165), ByteValue(value=181), ByteValue(value=168), ByteValue(value=7), ByteValue(value=168), ByteValue(value=118), ByteValue(value=40), ByteValue(value=204), ByteValue(value=37); 
DATA: ByteValue(value=101), ByteValue(value=164), ByteValue(value=169), ByteValue(value=36), ByteValue(value=229), ByteValue(value=36), ByteValue(value=25), ByteValue(value=164), ByteValue(value=15), ByteValue(value=7); 
DATA: ByteValue(value=149), ByteValue(value=40), ByteValue(value=230), ByteValue(value=36), ByteValue(value=25), ByteValue(value=164), ByteValue(value=215), ByteValue(value=41), ByteValue(value=22), ByteValue(value=169); 
DATA: ByteValue(value=88), ByteValue(value=41), ByteValue(value=151), ByteValue(value=41)           ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 6-1                                                           ; 
E_GroundArea15:                                                                                     ;  B
DATA: ByteValue(value=15), ByteValue(value=2), ByteValue(value=2), ByteValue(value=17), ByteValue(value=15), ByteValue(value=7), ByteValue(value=2), ByteValue(value=17); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; warp zone area used in level 4-2                                    ; 
E_GroundArea16:                                                                                     ;  B
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 8-1                                                           ; 
E_GroundArea17:                                                                                     ;  B
DATA: ByteValue(value=43), ByteValue(value=130), ByteValue(value=171), ByteValue(value=56), ByteValue(value=222), ByteValue(value=66), ByteValue(value=226), ByteValue(value=27), ByteValue(value=184), ByteValue(value=235); 
DATA: ByteValue(value=59), ByteValue(value=219), ByteValue(value=128), ByteValue(value=139), ByteValue(value=184), ByteValue(value=27), ByteValue(value=130), ByteValue(value=251), ByteValue(value=184), ByteValue(value=123); 
DATA: ByteValue(value=128), ByteValue(value=251), ByteValue(value=60), ByteValue(value=91), ByteValue(value=188), ByteValue(value=123), ByteValue(value=184), ByteValue(value=27), ByteValue(value=142), ByteValue(value=203); 
DATA: ByteValue(value=14), ByteValue(value=27), ByteValue(value=142), ByteValue(value=15), ByteValue(value=13), ByteValue(value=43), ByteValue(value=59), ByteValue(value=187), ByteValue(value=184), ByteValue(value=235), ByteValue(value=130); 
DATA: ByteValue(value=75), ByteValue(value=184), ByteValue(value=187), ByteValue(value=56), ByteValue(value=59), ByteValue(value=183), ByteValue(value=187), ByteValue(value=2), ByteValue(value=15), ByteValue(value=19); 
DATA: ByteValue(value=27), ByteValue(value=0), ByteValue(value=203), ByteValue(value=128), ByteValue(value=107), ByteValue(value=188); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 5-2                                                           ; 
E_GroundArea18:                                                                                     ;  B
DATA: ByteValue(value=123), ByteValue(value=128), ByteValue(value=174), ByteValue(value=0), ByteValue(value=128), ByteValue(value=139), ByteValue(value=142), ByteValue(value=232), ByteValue(value=5), ByteValue(value=249), ByteValue(value=134); 
DATA: ByteValue(value=23), ByteValue(value=134), ByteValue(value=22), ByteValue(value=133), ByteValue(value=78), ByteValue(value=43), ByteValue(value=128), ByteValue(value=171), ByteValue(value=142), ByteValue(value=135), ByteValue(value=133); 
DATA: ByteValue(value=195), ByteValue(value=5), ByteValue(value=139), ByteValue(value=130), ByteValue(value=155), ByteValue(value=2), ByteValue(value=171), ByteValue(value=2), ByteValue(value=187), ByteValue(value=134); 
DATA: ByteValue(value=203), ByteValue(value=6), ByteValue(value=211), ByteValue(value=3), ByteValue(value=59), ByteValue(value=142), ByteValue(value=107), ByteValue(value=14), ByteValue(value=167), ByteValue(value=142); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 8-2                                                           ; 
E_GroundArea19:                                                                                     ;  B
DATA: ByteValue(value=41), ByteValue(value=142), ByteValue(value=82), ByteValue(value=17), ByteValue(value=131), ByteValue(value=14), ByteValue(value=15), ByteValue(value=3), ByteValue(value=155), ByteValue(value=14); 
DATA: ByteValue(value=43), ByteValue(value=142), ByteValue(value=91), ByteValue(value=14), ByteValue(value=203), ByteValue(value=142), ByteValue(value=251), ByteValue(value=14), ByteValue(value=251), ByteValue(value=130); 
DATA: ByteValue(value=155), ByteValue(value=130), ByteValue(value=187), ByteValue(value=2), ByteValue(value=254), ByteValue(value=66), ByteValue(value=232), ByteValue(value=187), ByteValue(value=142), ByteValue(value=15), ByteValue(value=10); 
DATA: ByteValue(value=171), ByteValue(value=14), ByteValue(value=203), ByteValue(value=14), ByteValue(value=249), ByteValue(value=14), ByteValue(value=136), ByteValue(value=134), ByteValue(value=166), ByteValue(value=6); 
DATA: ByteValue(value=219), ByteValue(value=2), ByteValue(value=182), ByteValue(value=142)          ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 7-1                                                           ; 
E_GroundArea20:                                                                                     ;  B
DATA: ByteValue(value=171), ByteValue(value=206), ByteValue(value=222), ByteValue(value=66), ByteValue(value=192), ByteValue(value=203), ByteValue(value=206), ByteValue(value=91), ByteValue(value=142), ByteValue(value=27), ByteValue(value=206); 
DATA: ByteValue(value=75), ByteValue(value=133), ByteValue(value=103), ByteValue(value=69), ByteValue(value=15), ByteValue(value=7), ByteValue(value=43), ByteValue(value=0), ByteValue(value=123), ByteValue(value=133); 
DATA: ByteValue(value=151), ByteValue(value=5), ByteValue(value=15), ByteValue(value=10), ByteValue(value=146), ByteValue(value=2); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; cloud level used in levels 3-1 and 6-2                              ; 
E_GroundArea21:                                                                                     ;  B
DATA: ByteValue(value=10), ByteValue(value=170), ByteValue(value=14), ByteValue(value=36), ByteValue(value=74), ByteValue(value=30), ByteValue(value=35), ByteValue(value=170); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 3-2                                                           ; 
E_GroundArea22:                                                                                     ;  B
DATA: ByteValue(value=27), ByteValue(value=128), ByteValue(value=187), ByteValue(value=56), ByteValue(value=75), ByteValue(value=188), ByteValue(value=235), ByteValue(value=59), ByteValue(value=15), ByteValue(value=4); 
DATA: ByteValue(value=43), ByteValue(value=0), ByteValue(value=171), ByteValue(value=56), ByteValue(value=235), ByteValue(value=0), ByteValue(value=203), ByteValue(value=142), ByteValue(value=251), ByteValue(value=128); 
DATA: ByteValue(value=171), ByteValue(value=184), ByteValue(value=107), ByteValue(value=128), ByteValue(value=251), ByteValue(value=60), ByteValue(value=155), ByteValue(value=187), ByteValue(value=91), ByteValue(value=188); 
DATA: ByteValue(value=251), ByteValue(value=0), ByteValue(value=107), ByteValue(value=184), ByteValue(value=251), ByteValue(value=56); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 1-2                                                           ; 
E_UndergroundArea1:                                                                                 ;  B
DATA: ByteValue(value=11), ByteValue(value=134), ByteValue(value=26), ByteValue(value=6), ByteValue(value=219), ByteValue(value=6), ByteValue(value=222), ByteValue(value=194), ByteValue(value=2), ByteValue(value=240), ByteValue(value=59); 
DATA: ByteValue(value=187), ByteValue(value=128), ByteValue(value=235), ByteValue(value=6), ByteValue(value=11), ByteValue(value=134), ByteValue(value=147), ByteValue(value=6), ByteValue(value=240), ByteValue(value=57); 
DATA: ByteValue(value=15), ByteValue(value=6), ByteValue(value=96), ByteValue(value=184), ByteValue(value=27), ByteValue(value=134), ByteValue(value=160), ByteValue(value=185), ByteValue(value=183), ByteValue(value=39); 
DATA: ByteValue(value=189), ByteValue(value=39), ByteValue(value=43), ByteValue(value=131), ByteValue(value=161), ByteValue(value=38), ByteValue(value=169), ByteValue(value=38), ByteValue(value=238), ByteValue(value=37), ByteValue(value=11); 
DATA: ByteValue(value=39), ByteValue(value=180)                                                     ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 4-2                                                           ; 
E_UndergroundArea2:                                                                                 ;  B
DATA: ByteValue(value=15), ByteValue(value=2), ByteValue(value=30), ByteValue(value=47), ByteValue(value=96), ByteValue(value=224), ByteValue(value=58), ByteValue(value=165), ByteValue(value=167), ByteValue(value=219), ByteValue(value=128); 
DATA: ByteValue(value=59), ByteValue(value=130), ByteValue(value=139), ByteValue(value=2), ByteValue(value=254), ByteValue(value=66), ByteValue(value=104), ByteValue(value=112), ByteValue(value=187), ByteValue(value=37), ByteValue(value=167); 
DATA: ByteValue(value=44), ByteValue(value=39), ByteValue(value=178), ByteValue(value=38), ByteValue(value=185), ByteValue(value=38), ByteValue(value=155), ByteValue(value=128), ByteValue(value=168), ByteValue(value=130); 
DATA: ByteValue(value=181), ByteValue(value=39), ByteValue(value=188), ByteValue(value=39), ByteValue(value=176), ByteValue(value=187), ByteValue(value=59), ByteValue(value=130), ByteValue(value=135), ByteValue(value=52); 
DATA: ByteValue(value=238), ByteValue(value=37), ByteValue(value=107)                               ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; underground bonus rooms area used in many levels                    ; 
E_UndergroundArea3:                                                                                 ;  B
DATA: ByteValue(value=30), ByteValue(value=165), ByteValue(value=10), ByteValue(value=46), ByteValue(value=40), ByteValue(value=39), ByteValue(value=46), ByteValue(value=51), ByteValue(value=199), ByteValue(value=15), ByteValue(value=3), ByteValue(value=30), ByteValue(value=64), ByteValue(value=7); 
DATA: ByteValue(value=46), ByteValue(value=48), ByteValue(value=231), ByteValue(value=15), ByteValue(value=5), ByteValue(value=30), ByteValue(value=36), ByteValue(value=68), ByteValue(value=15), ByteValue(value=7), ByteValue(value=30), ByteValue(value=34), ByteValue(value=106); 
DATA: ByteValue(value=46), ByteValue(value=35), ByteValue(value=171), ByteValue(value=15), ByteValue(value=9), ByteValue(value=30), ByteValue(value=65), ByteValue(value=104), ByteValue(value=30), ByteValue(value=42), ByteValue(value=138), ByteValue(value=46), ByteValue(value=35), ByteValue(value=162); 
DATA: ByteValue(value=46), ByteValue(value=50), ByteValue(value=234)                                ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; water area used in levels 5-2 and 6-2                               ; 
E_WaterArea1:                                                                                       ;  B
DATA: ByteValue(value=59), ByteValue(value=135), ByteValue(value=102), ByteValue(value=39), ByteValue(value=204), ByteValue(value=39), ByteValue(value=238), ByteValue(value=49), ByteValue(value=135), ByteValue(value=238), ByteValue(value=35), ByteValue(value=167); 
DATA: ByteValue(value=59), ByteValue(value=135), ByteValue(value=219), ByteValue(value=7)           ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; level 2-2/7-2                                                       ; 
E_WaterArea2:                                                                                       ;  B
DATA: ByteValue(value=15), ByteValue(value=1), ByteValue(value=46), ByteValue(value=37), ByteValue(value=43), ByteValue(value=46), ByteValue(value=37), ByteValue(value=75), ByteValue(value=78), ByteValue(value=37), ByteValue(value=203), ByteValue(value=107), ByteValue(value=7); 
DATA: ByteValue(value=151), ByteValue(value=71), ByteValue(value=233), ByteValue(value=135), ByteValue(value=71), ByteValue(value=199), ByteValue(value=122), ByteValue(value=7), ByteValue(value=214), ByteValue(value=199); 
DATA: ByteValue(value=120), ByteValue(value=7), ByteValue(value=56), ByteValue(value=135), ByteValue(value=171), ByteValue(value=71), ByteValue(value=227), ByteValue(value=7), ByteValue(value=155), ByteValue(value=135); 
DATA: ByteValue(value=15), ByteValue(value=9), ByteValue(value=104), ByteValue(value=71), ByteValue(value=219), ByteValue(value=199), ByteValue(value=59), ByteValue(value=199); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; water area used in level 8-4                                        ; 
E_WaterArea3:                                                                                       ;  B
DATA: ByteValue(value=71), ByteValue(value=155), ByteValue(value=203), ByteValue(value=7), ByteValue(value=250), ByteValue(value=29), ByteValue(value=134), ByteValue(value=155), ByteValue(value=58), ByteValue(value=135); 
DATA: ByteValue(value=86), ByteValue(value=7), ByteValue(value=136), ByteValue(value=27), ByteValue(value=7), ByteValue(value=157), ByteValue(value=46), ByteValue(value=101), ByteValue(value=240); 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; AREA OBJECT DATA                                                    ; 
                                                                                                    ; 
                              ; level 1-4/6-4                                                       ; 
L_CastleArea1:                                                                                      ;  B
DATA: ByteValue(value=155), ByteValue(value=7)                                                      ; 
DATA: ByteValue(value=5), ByteValue(value=50), ByteValue(value=6), ByteValue(value=51), ByteValue(value=7), ByteValue(value=52), ByteValue(value=206), ByteValue(value=3), ByteValue(value=220), ByteValue(value=81); 
DATA: ByteValue(value=238), ByteValue(value=7), ByteValue(value=115), ByteValue(value=224), ByteValue(value=116), ByteValue(value=10), ByteValue(value=126), ByteValue(value=6), ByteValue(value=158), ByteValue(value=10); 
DATA: ByteValue(value=206), ByteValue(value=6), ByteValue(value=228), ByteValue(value=0), ByteValue(value=232), ByteValue(value=10), ByteValue(value=254), ByteValue(value=10), ByteValue(value=46), ByteValue(value=137); 
DATA: ByteValue(value=78), ByteValue(value=11), ByteValue(value=84), ByteValue(value=10), ByteValue(value=20), ByteValue(value=138), ByteValue(value=196), ByteValue(value=10), ByteValue(value=52), ByteValue(value=138); 
DATA: ByteValue(value=126), ByteValue(value=6), ByteValue(value=199), ByteValue(value=10), ByteValue(value=1), ByteValue(value=224), ByteValue(value=2), ByteValue(value=10), ByteValue(value=71), ByteValue(value=10); 
DATA: ByteValue(value=129), ByteValue(value=96), ByteValue(value=130), ByteValue(value=10), ByteValue(value=199), ByteValue(value=10), ByteValue(value=14), ByteValue(value=135), ByteValue(value=126), ByteValue(value=2); 
DATA: ByteValue(value=167), ByteValue(value=2), ByteValue(value=179), ByteValue(value=2), ByteValue(value=215), ByteValue(value=2), ByteValue(value=227), ByteValue(value=2), ByteValue(value=7), ByteValue(value=130); 
DATA: ByteValue(value=19), ByteValue(value=2), ByteValue(value=62), ByteValue(value=6), ByteValue(value=126), ByteValue(value=2), ByteValue(value=174), ByteValue(value=7), ByteValue(value=254), ByteValue(value=10); 
DATA: ByteValue(value=13), ByteValue(value=196), ByteValue(value=205), ByteValue(value=67), ByteValue(value=206), ByteValue(value=9), ByteValue(value=222), ByteValue(value=11), ByteValue(value=221), ByteValue(value=66); 
DATA: ByteValue(value=254), ByteValue(value=2), ByteValue(value=93), ByteValue(value=199)           ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 4-4                                                           ; 
L_CastleArea2:                                                                                      ;  B
DATA: ByteValue(value=91), ByteValue(value=7)                                                       ; 
DATA: ByteValue(value=5), ByteValue(value=50), ByteValue(value=6), ByteValue(value=51), ByteValue(value=7), ByteValue(value=52), ByteValue(value=94), ByteValue(value=10), ByteValue(value=104), ByteValue(value=100); 
DATA: ByteValue(value=152), ByteValue(value=100), ByteValue(value=168), ByteValue(value=100), ByteValue(value=206), ByteValue(value=6), ByteValue(value=254), ByteValue(value=2), ByteValue(value=13), ByteValue(value=1); 
DATA: ByteValue(value=30), ByteValue(value=14), ByteValue(value=126), ByteValue(value=2), ByteValue(value=148), ByteValue(value=99), ByteValue(value=180), ByteValue(value=99), ByteValue(value=212), ByteValue(value=99); 
DATA: ByteValue(value=244), ByteValue(value=99), ByteValue(value=20), ByteValue(value=227), ByteValue(value=46), ByteValue(value=14), ByteValue(value=94), ByteValue(value=2), ByteValue(value=100), ByteValue(value=53); 
DATA: ByteValue(value=136), ByteValue(value=114), ByteValue(value=190), ByteValue(value=14), ByteValue(value=13), ByteValue(value=4), ByteValue(value=174), ByteValue(value=2), ByteValue(value=206), ByteValue(value=8); 
DATA: ByteValue(value=205), ByteValue(value=75), ByteValue(value=254), ByteValue(value=2), ByteValue(value=13), ByteValue(value=5), ByteValue(value=104), ByteValue(value=49), ByteValue(value=126), ByteValue(value=10); 
DATA: ByteValue(value=150), ByteValue(value=49), ByteValue(value=169), ByteValue(value=99), ByteValue(value=168), ByteValue(value=51), ByteValue(value=213), ByteValue(value=48), ByteValue(value=238), ByteValue(value=2); 
DATA: ByteValue(value=230), ByteValue(value=98), ByteValue(value=244), ByteValue(value=97), ByteValue(value=4), ByteValue(value=177), ByteValue(value=8), ByteValue(value=63), ByteValue(value=68), ByteValue(value=51); 
DATA: ByteValue(value=148), ByteValue(value=99), ByteValue(value=164), ByteValue(value=49), ByteValue(value=228), ByteValue(value=49), ByteValue(value=4), ByteValue(value=191), ByteValue(value=8), ByteValue(value=63); 
DATA: ByteValue(value=4), ByteValue(value=191), ByteValue(value=8), ByteValue(value=63), ByteValue(value=205), ByteValue(value=75), ByteValue(value=3), ByteValue(value=228), ByteValue(value=14), ByteValue(value=3); 
DATA: ByteValue(value=46), ByteValue(value=1), ByteValue(value=126), ByteValue(value=6), ByteValue(value=190), ByteValue(value=2), ByteValue(value=222), ByteValue(value=6), ByteValue(value=254), ByteValue(value=10); 
DATA: ByteValue(value=13), ByteValue(value=196), ByteValue(value=205), ByteValue(value=67), ByteValue(value=206), ByteValue(value=9), ByteValue(value=222), ByteValue(value=11), ByteValue(value=221), ByteValue(value=66); 
DATA: ByteValue(value=254), ByteValue(value=2), ByteValue(value=93), ByteValue(value=199)           ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 2-4/5-4                                                       ; 
L_CastleArea3:                                                                                      ;  B
DATA: ByteValue(value=155), ByteValue(value=7)                                                      ; 
DATA: ByteValue(value=5), ByteValue(value=50), ByteValue(value=6), ByteValue(value=51), ByteValue(value=7), ByteValue(value=52), ByteValue(value=254), ByteValue(value=0), ByteValue(value=39), ByteValue(value=177); 
DATA: ByteValue(value=101), ByteValue(value=50), ByteValue(value=117), ByteValue(value=10), ByteValue(value=113), ByteValue(value=0), ByteValue(value=183), ByteValue(value=49), ByteValue(value=8), ByteValue(value=228); 
DATA: ByteValue(value=24), ByteValue(value=100), ByteValue(value=30), ByteValue(value=4), ByteValue(value=87), ByteValue(value=59), ByteValue(value=187), ByteValue(value=10), ByteValue(value=23), ByteValue(value=138); 
DATA: ByteValue(value=39), ByteValue(value=58), ByteValue(value=115), ByteValue(value=10), ByteValue(value=123), ByteValue(value=10), ByteValue(value=215), ByteValue(value=10), ByteValue(value=231), ByteValue(value=58); 
DATA: ByteValue(value=59), ByteValue(value=138), ByteValue(value=151), ByteValue(value=10), ByteValue(value=254), ByteValue(value=8), ByteValue(value=36), ByteValue(value=138), ByteValue(value=46), ByteValue(value=0); 
DATA: ByteValue(value=62), ByteValue(value=64), ByteValue(value=56), ByteValue(value=100), ByteValue(value=111), ByteValue(value=0), ByteValue(value=159), ByteValue(value=0), ByteValue(value=190), ByteValue(value=67); 
DATA: ByteValue(value=200), ByteValue(value=10), ByteValue(value=201), ByteValue(value=99), ByteValue(value=206), ByteValue(value=7), ByteValue(value=254), ByteValue(value=7), ByteValue(value=46), ByteValue(value=129); 
DATA: ByteValue(value=102), ByteValue(value=66), ByteValue(value=106), ByteValue(value=66), ByteValue(value=121), ByteValue(value=10), ByteValue(value=190), ByteValue(value=0), ByteValue(value=200), ByteValue(value=100); 
DATA: ByteValue(value=248), ByteValue(value=100), ByteValue(value=8), ByteValue(value=228), ByteValue(value=46), ByteValue(value=7), ByteValue(value=126), ByteValue(value=3), ByteValue(value=158), ByteValue(value=7); 
DATA: ByteValue(value=190), ByteValue(value=3), ByteValue(value=222), ByteValue(value=7), ByteValue(value=254), ByteValue(value=10), ByteValue(value=3), ByteValue(value=165), ByteValue(value=13), ByteValue(value=68); 
DATA: ByteValue(value=205), ByteValue(value=67), ByteValue(value=206), ByteValue(value=9), ByteValue(value=221), ByteValue(value=66), ByteValue(value=222), ByteValue(value=11), ByteValue(value=254), ByteValue(value=2); 
DATA: ByteValue(value=93), ByteValue(value=199)                                                     ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 3-4                                                           ; 
L_CastleArea4:                                                                                      ;  B
DATA: ByteValue(value=155), ByteValue(value=7)                                                      ; 
DATA: ByteValue(value=5), ByteValue(value=50), ByteValue(value=6), ByteValue(value=51), ByteValue(value=7), ByteValue(value=52), ByteValue(value=254), ByteValue(value=6), ByteValue(value=12), ByteValue(value=129); 
DATA: ByteValue(value=57), ByteValue(value=10), ByteValue(value=92), ByteValue(value=1), ByteValue(value=137), ByteValue(value=10), ByteValue(value=172), ByteValue(value=1), ByteValue(value=217), ByteValue(value=10); 
DATA: ByteValue(value=252), ByteValue(value=1), ByteValue(value=46), ByteValue(value=131), ByteValue(value=167), ByteValue(value=1), ByteValue(value=183), ByteValue(value=0), ByteValue(value=199), ByteValue(value=1); 
DATA: ByteValue(value=222), ByteValue(value=10), ByteValue(value=254), ByteValue(value=2), ByteValue(value=78), ByteValue(value=131), ByteValue(value=90), ByteValue(value=50), ByteValue(value=99), ByteValue(value=10); 
DATA: ByteValue(value=105), ByteValue(value=10), ByteValue(value=126), ByteValue(value=2), ByteValue(value=238), ByteValue(value=3), ByteValue(value=250), ByteValue(value=50), ByteValue(value=3), ByteValue(value=138); 
DATA: ByteValue(value=9), ByteValue(value=10), ByteValue(value=30), ByteValue(value=2), ByteValue(value=238), ByteValue(value=3), ByteValue(value=250), ByteValue(value=50), ByteValue(value=3), ByteValue(value=138); 
DATA: ByteValue(value=9), ByteValue(value=10), ByteValue(value=20), ByteValue(value=66), ByteValue(value=30), ByteValue(value=2), ByteValue(value=126), ByteValue(value=10), ByteValue(value=158), ByteValue(value=7); 
DATA: ByteValue(value=254), ByteValue(value=10), ByteValue(value=46), ByteValue(value=134), ByteValue(value=94), ByteValue(value=10), ByteValue(value=142), ByteValue(value=6), ByteValue(value=190), ByteValue(value=10); 
DATA: ByteValue(value=238), ByteValue(value=7), ByteValue(value=62), ByteValue(value=131), ByteValue(value=94), ByteValue(value=7), ByteValue(value=254), ByteValue(value=10), ByteValue(value=13), ByteValue(value=196); 
DATA: ByteValue(value=65), ByteValue(value=82), ByteValue(value=81), ByteValue(value=82), ByteValue(value=205), ByteValue(value=67), ByteValue(value=206), ByteValue(value=9), ByteValue(value=222), ByteValue(value=11); 
DATA: ByteValue(value=221), ByteValue(value=66), ByteValue(value=254), ByteValue(value=2), ByteValue(value=93), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 7-4                                                           ; 
L_CastleArea5:                                                                                      ;  B
DATA: ByteValue(value=91), ByteValue(value=7)                                                       ; 
DATA: ByteValue(value=5), ByteValue(value=50), ByteValue(value=6), ByteValue(value=51), ByteValue(value=7), ByteValue(value=52), ByteValue(value=254), ByteValue(value=10), ByteValue(value=174), ByteValue(value=134); 
DATA: ByteValue(value=190), ByteValue(value=7), ByteValue(value=254), ByteValue(value=2), ByteValue(value=13), ByteValue(value=2), ByteValue(value=39), ByteValue(value=50), ByteValue(value=70), ByteValue(value=97); 
DATA: ByteValue(value=85), ByteValue(value=98), ByteValue(value=94), ByteValue(value=14), ByteValue(value=30), ByteValue(value=130), ByteValue(value=104), ByteValue(value=60), ByteValue(value=116), ByteValue(value=58); 
DATA: ByteValue(value=125), ByteValue(value=75), ByteValue(value=94), ByteValue(value=142), ByteValue(value=125), ByteValue(value=75), ByteValue(value=126), ByteValue(value=130), ByteValue(value=132), ByteValue(value=98); 
DATA: ByteValue(value=148), ByteValue(value=97), ByteValue(value=164), ByteValue(value=49), ByteValue(value=189), ByteValue(value=75), ByteValue(value=206), ByteValue(value=6), ByteValue(value=254), ByteValue(value=2); 
DATA: ByteValue(value=13), ByteValue(value=6), ByteValue(value=52), ByteValue(value=49), ByteValue(value=62), ByteValue(value=10), ByteValue(value=100), ByteValue(value=50), ByteValue(value=117), ByteValue(value=10); 
DATA: ByteValue(value=123), ByteValue(value=97), ByteValue(value=164), ByteValue(value=51), ByteValue(value=174), ByteValue(value=2), ByteValue(value=222), ByteValue(value=14), ByteValue(value=62), ByteValue(value=130); 
DATA: ByteValue(value=100), ByteValue(value=50), ByteValue(value=120), ByteValue(value=50), ByteValue(value=180), ByteValue(value=54), ByteValue(value=200), ByteValue(value=54), ByteValue(value=221), ByteValue(value=75); 
DATA: ByteValue(value=68), ByteValue(value=178), ByteValue(value=88), ByteValue(value=50), ByteValue(value=148), ByteValue(value=99), ByteValue(value=164), ByteValue(value=62), ByteValue(value=186), ByteValue(value=48); 
DATA: ByteValue(value=201), ByteValue(value=97), ByteValue(value=206), ByteValue(value=6), ByteValue(value=221), ByteValue(value=75), ByteValue(value=206), ByteValue(value=134), ByteValue(value=221), ByteValue(value=75); 
DATA: ByteValue(value=254), ByteValue(value=2), ByteValue(value=46), ByteValue(value=134), ByteValue(value=94), ByteValue(value=2), ByteValue(value=126), ByteValue(value=6), ByteValue(value=254), ByteValue(value=2); 
DATA: ByteValue(value=30), ByteValue(value=134), ByteValue(value=62), ByteValue(value=2), ByteValue(value=94), ByteValue(value=6), ByteValue(value=126), ByteValue(value=2), ByteValue(value=158), ByteValue(value=6); 
DATA: ByteValue(value=254), ByteValue(value=10), ByteValue(value=13), ByteValue(value=196), ByteValue(value=205), ByteValue(value=67), ByteValue(value=206), ByteValue(value=9), ByteValue(value=222), ByteValue(value=11); 
DATA: ByteValue(value=221), ByteValue(value=66), ByteValue(value=254), ByteValue(value=2), ByteValue(value=93), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 8-4                                                           ; 
L_CastleArea6:                                                                                      ;  B
DATA: ByteValue(value=91), ByteValue(value=6)                                                       ; 
DATA: ByteValue(value=5), ByteValue(value=50), ByteValue(value=6), ByteValue(value=51), ByteValue(value=7), ByteValue(value=52), ByteValue(value=94), ByteValue(value=10), ByteValue(value=174), ByteValue(value=2); 
DATA: ByteValue(value=13), ByteValue(value=1), ByteValue(value=57), ByteValue(value=115), ByteValue(value=13), ByteValue(value=3), ByteValue(value=57), ByteValue(value=123), ByteValue(value=77), ByteValue(value=75); 
DATA: ByteValue(value=222), ByteValue(value=6), ByteValue(value=30), ByteValue(value=138), ByteValue(value=174), ByteValue(value=6), ByteValue(value=196), ByteValue(value=51), ByteValue(value=22), ByteValue(value=254); 
DATA: ByteValue(value=165), ByteValue(value=119), ByteValue(value=254), ByteValue(value=2), ByteValue(value=254), ByteValue(value=130), ByteValue(value=13), ByteValue(value=7), ByteValue(value=57), ByteValue(value=115); 
DATA: ByteValue(value=168), ByteValue(value=116), ByteValue(value=237), ByteValue(value=75), ByteValue(value=73), ByteValue(value=251), ByteValue(value=232), ByteValue(value=116), ByteValue(value=254), ByteValue(value=10); 
DATA: ByteValue(value=46), ByteValue(value=130), ByteValue(value=103), ByteValue(value=2), ByteValue(value=132), ByteValue(value=122), ByteValue(value=135), ByteValue(value=49), ByteValue(value=13), ByteValue(value=11); 
DATA: ByteValue(value=254), ByteValue(value=2), ByteValue(value=13), ByteValue(value=12), ByteValue(value=57), ByteValue(value=115), ByteValue(value=94), ByteValue(value=6), ByteValue(value=198), ByteValue(value=118); 
DATA: ByteValue(value=69), ByteValue(value=255), ByteValue(value=190), ByteValue(value=10), ByteValue(value=221), ByteValue(value=72), ByteValue(value=254), ByteValue(value=6), ByteValue(value=61), ByteValue(value=203); 
DATA: ByteValue(value=70), ByteValue(value=126), ByteValue(value=173), ByteValue(value=74), ByteValue(value=254), ByteValue(value=130), ByteValue(value=57), ByteValue(value=243), ByteValue(value=169), ByteValue(value=123); 
DATA: ByteValue(value=78), ByteValue(value=138), ByteValue(value=158), ByteValue(value=7), ByteValue(value=254), ByteValue(value=10), ByteValue(value=13), ByteValue(value=196), ByteValue(value=205), ByteValue(value=67); 
DATA: ByteValue(value=206), ByteValue(value=9), ByteValue(value=222), ByteValue(value=11), ByteValue(value=221), ByteValue(value=66), ByteValue(value=254), ByteValue(value=2), ByteValue(value=93), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 3-3                                                           ; 
L_GroundArea1:                                                                                      ;  B
DATA: ByteValue(value=148), ByteValue(value=17)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=254), ByteValue(value=16), ByteValue(value=40), ByteValue(value=148), ByteValue(value=101), ByteValue(value=21), ByteValue(value=235), ByteValue(value=18); 
DATA: ByteValue(value=250), ByteValue(value=65), ByteValue(value=74), ByteValue(value=150), ByteValue(value=84), ByteValue(value=64), ByteValue(value=164), ByteValue(value=66), ByteValue(value=183), ByteValue(value=19); 
DATA: ByteValue(value=233), ByteValue(value=25), ByteValue(value=245), ByteValue(value=21), ByteValue(value=17), ByteValue(value=128), ByteValue(value=71), ByteValue(value=66), ByteValue(value=113), ByteValue(value=19); 
DATA: ByteValue(value=128), ByteValue(value=65), ByteValue(value=21), ByteValue(value=146), ByteValue(value=27), ByteValue(value=31), ByteValue(value=36), ByteValue(value=64), ByteValue(value=85), ByteValue(value=18); 
DATA: ByteValue(value=100), ByteValue(value=64), ByteValue(value=149), ByteValue(value=18), ByteValue(value=164), ByteValue(value=64), ByteValue(value=210), ByteValue(value=18), ByteValue(value=225), ByteValue(value=64); 
DATA: ByteValue(value=19), ByteValue(value=192), ByteValue(value=44), ByteValue(value=23), ByteValue(value=47), ByteValue(value=18), ByteValue(value=73), ByteValue(value=19), ByteValue(value=131), ByteValue(value=64); 
DATA: ByteValue(value=159), ByteValue(value=20), ByteValue(value=163), ByteValue(value=64), ByteValue(value=23), ByteValue(value=146), ByteValue(value=131), ByteValue(value=19), ByteValue(value=146), ByteValue(value=65); 
DATA: ByteValue(value=185), ByteValue(value=20), ByteValue(value=197), ByteValue(value=18), ByteValue(value=200), ByteValue(value=64), ByteValue(value=212), ByteValue(value=64), ByteValue(value=75), ByteValue(value=146); 
DATA: ByteValue(value=120), ByteValue(value=27), ByteValue(value=156), ByteValue(value=148), ByteValue(value=159), ByteValue(value=17), ByteValue(value=223), ByteValue(value=20), ByteValue(value=254), ByteValue(value=17); 
DATA: ByteValue(value=125), ByteValue(value=193), ByteValue(value=158), ByteValue(value=66), ByteValue(value=207), ByteValue(value=32); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 8-3                                                           ; 
L_GroundArea2:                                                                                      ;  B
DATA: ByteValue(value=144), ByteValue(value=177)                                                    ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=41), ByteValue(value=145), ByteValue(value=126), ByteValue(value=66), ByteValue(value=254), ByteValue(value=64), ByteValue(value=40), ByteValue(value=146); 
DATA: ByteValue(value=78), ByteValue(value=66), ByteValue(value=46), ByteValue(value=192), ByteValue(value=87), ByteValue(value=115), ByteValue(value=195), ByteValue(value=37), ByteValue(value=199), ByteValue(value=39); 
DATA: ByteValue(value=35), ByteValue(value=132), ByteValue(value=51), ByteValue(value=32), ByteValue(value=92), ByteValue(value=1), ByteValue(value=119), ByteValue(value=99), ByteValue(value=136), ByteValue(value=98); 
DATA: ByteValue(value=153), ByteValue(value=97), ByteValue(value=170), ByteValue(value=96), ByteValue(value=188), ByteValue(value=1), ByteValue(value=238), ByteValue(value=66), ByteValue(value=78), ByteValue(value=192); 
DATA: ByteValue(value=105), ByteValue(value=17), ByteValue(value=126), ByteValue(value=66), ByteValue(value=222), ByteValue(value=64), ByteValue(value=248), ByteValue(value=98), ByteValue(value=14), ByteValue(value=194); 
DATA: ByteValue(value=174), ByteValue(value=64), ByteValue(value=215), ByteValue(value=99), ByteValue(value=231), ByteValue(value=99), ByteValue(value=51), ByteValue(value=167), ByteValue(value=55), ByteValue(value=39); 
DATA: ByteValue(value=67), ByteValue(value=4), ByteValue(value=204), ByteValue(value=1), ByteValue(value=231), ByteValue(value=115), ByteValue(value=12), ByteValue(value=129), ByteValue(value=62), ByteValue(value=66); 
DATA: ByteValue(value=13), ByteValue(value=10), ByteValue(value=94), ByteValue(value=64), ByteValue(value=136), ByteValue(value=114), ByteValue(value=190), ByteValue(value=66), ByteValue(value=231), ByteValue(value=135); 
DATA: ByteValue(value=254), ByteValue(value=64), ByteValue(value=57), ByteValue(value=225), ByteValue(value=78), ByteValue(value=0), ByteValue(value=105), ByteValue(value=96), ByteValue(value=135), ByteValue(value=96); 
DATA: ByteValue(value=165), ByteValue(value=96), ByteValue(value=195), ByteValue(value=49), ByteValue(value=254), ByteValue(value=49), ByteValue(value=109), ByteValue(value=193), ByteValue(value=190), ByteValue(value=66); 
DATA: ByteValue(value=239), ByteValue(value=32)                                                     ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 4-1                                                           ; 
L_GroundArea3:                                                                                      ;  B
DATA: ByteValue(value=82), ByteValue(value=33)                                                      ; 
DATA: ByteValue(value=15), ByteValue(value=32), ByteValue(value=110), ByteValue(value=64), ByteValue(value=88), ByteValue(value=242), ByteValue(value=147), ByteValue(value=1), ByteValue(value=151), ByteValue(value=0); 
DATA: ByteValue(value=12), ByteValue(value=129), ByteValue(value=151), ByteValue(value=64), ByteValue(value=166), ByteValue(value=65), ByteValue(value=199), ByteValue(value=64), ByteValue(value=13), ByteValue(value=4); 
DATA: ByteValue(value=3), ByteValue(value=1), ByteValue(value=7), ByteValue(value=1), ByteValue(value=35), ByteValue(value=1), ByteValue(value=39), ByteValue(value=1), ByteValue(value=236), ByteValue(value=3); 
DATA: ByteValue(value=172), ByteValue(value=243), ByteValue(value=195), ByteValue(value=3), ByteValue(value=120), ByteValue(value=226), ByteValue(value=148), ByteValue(value=67), ByteValue(value=71), ByteValue(value=243); 
DATA: ByteValue(value=116), ByteValue(value=67), ByteValue(value=71), ByteValue(value=251), ByteValue(value=116), ByteValue(value=67), ByteValue(value=44), ByteValue(value=241), ByteValue(value=76), ByteValue(value=99); 
DATA: ByteValue(value=71), ByteValue(value=0), ByteValue(value=87), ByteValue(value=33), ByteValue(value=92), ByteValue(value=1), ByteValue(value=124), ByteValue(value=114), ByteValue(value=57), ByteValue(value=241); 
DATA: ByteValue(value=236), ByteValue(value=2), ByteValue(value=76), ByteValue(value=129), ByteValue(value=216), ByteValue(value=98), ByteValue(value=236), ByteValue(value=1), ByteValue(value=13), ByteValue(value=13); 
DATA: ByteValue(value=15), ByteValue(value=56), ByteValue(value=199), ByteValue(value=7), ByteValue(value=237), ByteValue(value=74), ByteValue(value=29), ByteValue(value=193), ByteValue(value=95), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 6-2                                                           ; 
L_GroundArea4:                                                                                      ;  B
DATA: ByteValue(value=84), ByteValue(value=33)                                                      ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=167), ByteValue(value=34), ByteValue(value=55), ByteValue(value=251), ByteValue(value=115), ByteValue(value=32), ByteValue(value=131), ByteValue(value=7); 
DATA: ByteValue(value=135), ByteValue(value=2), ByteValue(value=147), ByteValue(value=32), ByteValue(value=199), ByteValue(value=115), ByteValue(value=4), ByteValue(value=241), ByteValue(value=6), ByteValue(value=49); 
DATA: ByteValue(value=57), ByteValue(value=113), ByteValue(value=89), ByteValue(value=113), ByteValue(value=231), ByteValue(value=115), ByteValue(value=55), ByteValue(value=160), ByteValue(value=71), ByteValue(value=4); 
DATA: ByteValue(value=134), ByteValue(value=124), ByteValue(value=229), ByteValue(value=113), ByteValue(value=231), ByteValue(value=49), ByteValue(value=51), ByteValue(value=164), ByteValue(value=57), ByteValue(value=113); 
DATA: ByteValue(value=169), ByteValue(value=113), ByteValue(value=211), ByteValue(value=35), ByteValue(value=8), ByteValue(value=242), ByteValue(value=19), ByteValue(value=5), ByteValue(value=39), ByteValue(value=2); 
DATA: ByteValue(value=73), ByteValue(value=113), ByteValue(value=117), ByteValue(value=117), ByteValue(value=232), ByteValue(value=114), ByteValue(value=103), ByteValue(value=243), ByteValue(value=153), ByteValue(value=113); 
DATA: ByteValue(value=231), ByteValue(value=32), ByteValue(value=244), ByteValue(value=114), ByteValue(value=247), ByteValue(value=49), ByteValue(value=23), ByteValue(value=160), ByteValue(value=51), ByteValue(value=32); 
DATA: ByteValue(value=57), ByteValue(value=113), ByteValue(value=115), ByteValue(value=40), ByteValue(value=188), ByteValue(value=5), ByteValue(value=57), ByteValue(value=241), ByteValue(value=121), ByteValue(value=113); 
DATA: ByteValue(value=166), ByteValue(value=33), ByteValue(value=195), ByteValue(value=6), ByteValue(value=211), ByteValue(value=32), ByteValue(value=220), ByteValue(value=0), ByteValue(value=252), ByteValue(value=0); 
DATA: ByteValue(value=7), ByteValue(value=162), ByteValue(value=19), ByteValue(value=33), ByteValue(value=95), ByteValue(value=50), ByteValue(value=140), ByteValue(value=0), ByteValue(value=152), ByteValue(value=122); 
DATA: ByteValue(value=199), ByteValue(value=99), ByteValue(value=217), ByteValue(value=97), ByteValue(value=3), ByteValue(value=162), ByteValue(value=7), ByteValue(value=34), ByteValue(value=116), ByteValue(value=114); 
DATA: ByteValue(value=119), ByteValue(value=49), ByteValue(value=231), ByteValue(value=115), ByteValue(value=57), ByteValue(value=241), ByteValue(value=88), ByteValue(value=114), ByteValue(value=119), ByteValue(value=115); 
DATA: ByteValue(value=216), ByteValue(value=114), ByteValue(value=127), ByteValue(value=177), ByteValue(value=151), ByteValue(value=115), ByteValue(value=182), ByteValue(value=100), ByteValue(value=197), ByteValue(value=101); 
DATA: ByteValue(value=212), ByteValue(value=102), ByteValue(value=227), ByteValue(value=103), ByteValue(value=243), ByteValue(value=103), ByteValue(value=141), ByteValue(value=193), ByteValue(value=207), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 3-1                                                           ; 
L_GroundArea5:                                                                                      ;  B
DATA: ByteValue(value=82), ByteValue(value=49)                                                      ; 
DATA: ByteValue(value=15), ByteValue(value=32), ByteValue(value=110), ByteValue(value=102), ByteValue(value=7), ByteValue(value=129), ByteValue(value=54), ByteValue(value=1), ByteValue(value=102), ByteValue(value=0); 
DATA: ByteValue(value=167), ByteValue(value=34), ByteValue(value=8), ByteValue(value=242), ByteValue(value=103), ByteValue(value=123), ByteValue(value=220), ByteValue(value=2), ByteValue(value=152), ByteValue(value=242); 
DATA: ByteValue(value=215), ByteValue(value=32), ByteValue(value=57), ByteValue(value=241), ByteValue(value=159), ByteValue(value=51), ByteValue(value=220), ByteValue(value=39), ByteValue(value=220), ByteValue(value=87); 
DATA: ByteValue(value=35), ByteValue(value=131), ByteValue(value=87), ByteValue(value=99), ByteValue(value=108), ByteValue(value=81), ByteValue(value=135), ByteValue(value=99), ByteValue(value=153), ByteValue(value=97); 
DATA: ByteValue(value=163), ByteValue(value=6), ByteValue(value=179), ByteValue(value=33), ByteValue(value=119), ByteValue(value=243), ByteValue(value=243), ByteValue(value=33), ByteValue(value=247), ByteValue(value=42); 
DATA: ByteValue(value=19), ByteValue(value=129), ByteValue(value=35), ByteValue(value=34), ByteValue(value=83), ByteValue(value=0), ByteValue(value=99), ByteValue(value=34), ByteValue(value=233), ByteValue(value=11); 
DATA: ByteValue(value=12), ByteValue(value=131), ByteValue(value=19), ByteValue(value=33), ByteValue(value=22), ByteValue(value=34), ByteValue(value=51), ByteValue(value=5), ByteValue(value=143), ByteValue(value=53); 
DATA: ByteValue(value=236), ByteValue(value=1), ByteValue(value=99), ByteValue(value=160), ByteValue(value=103), ByteValue(value=32), ByteValue(value=115), ByteValue(value=1), ByteValue(value=119), ByteValue(value=1); 
DATA: ByteValue(value=131), ByteValue(value=32), ByteValue(value=135), ByteValue(value=32), ByteValue(value=179), ByteValue(value=32), ByteValue(value=183), ByteValue(value=32), ByteValue(value=195), ByteValue(value=1); 
DATA: ByteValue(value=199), ByteValue(value=0), ByteValue(value=211), ByteValue(value=32), ByteValue(value=215), ByteValue(value=32), ByteValue(value=103), ByteValue(value=160), ByteValue(value=119), ByteValue(value=7); 
DATA: ByteValue(value=135), ByteValue(value=34), ByteValue(value=232), ByteValue(value=98), ByteValue(value=245), ByteValue(value=101), ByteValue(value=28), ByteValue(value=130), ByteValue(value=127), ByteValue(value=56); 
DATA: ByteValue(value=141), ByteValue(value=193), ByteValue(value=207), ByteValue(value=38)         ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 1-1                                                           ; 
L_GroundArea6:                                                                                      ;  B
DATA: ByteValue(value=80), ByteValue(value=33)                                                      ; 
DATA: ByteValue(value=7), ByteValue(value=129), ByteValue(value=71), ByteValue(value=36), ByteValue(value=87), ByteValue(value=0), ByteValue(value=99), ByteValue(value=1), ByteValue(value=119), ByteValue(value=1); 
DATA: ByteValue(value=201), ByteValue(value=113), ByteValue(value=104), ByteValue(value=242), ByteValue(value=231), ByteValue(value=115), ByteValue(value=151), ByteValue(value=251), ByteValue(value=6), ByteValue(value=131); 
DATA: ByteValue(value=92), ByteValue(value=1), ByteValue(value=215), ByteValue(value=34), ByteValue(value=231), ByteValue(value=0), ByteValue(value=3), ByteValue(value=167), ByteValue(value=108), ByteValue(value=2); 
DATA: ByteValue(value=179), ByteValue(value=34), ByteValue(value=227), ByteValue(value=1), ByteValue(value=231), ByteValue(value=7), ByteValue(value=71), ByteValue(value=160), ByteValue(value=87), ByteValue(value=6); 
DATA: ByteValue(value=167), ByteValue(value=1), ByteValue(value=211), ByteValue(value=0), ByteValue(value=215), ByteValue(value=1), ByteValue(value=7), ByteValue(value=129), ByteValue(value=103), ByteValue(value=32); 
DATA: ByteValue(value=147), ByteValue(value=34), ByteValue(value=3), ByteValue(value=163), ByteValue(value=28), ByteValue(value=97), ByteValue(value=23), ByteValue(value=33), ByteValue(value=111), ByteValue(value=51); 
DATA: ByteValue(value=199), ByteValue(value=99), ByteValue(value=216), ByteValue(value=98), ByteValue(value=233), ByteValue(value=97), ByteValue(value=250), ByteValue(value=96), ByteValue(value=79), ByteValue(value=179); 
DATA: ByteValue(value=135), ByteValue(value=99), ByteValue(value=156), ByteValue(value=1), ByteValue(value=183), ByteValue(value=99), ByteValue(value=200), ByteValue(value=98), ByteValue(value=217), ByteValue(value=97); 
DATA: ByteValue(value=234), ByteValue(value=96), ByteValue(value=57), ByteValue(value=241), ByteValue(value=135), ByteValue(value=33), ByteValue(value=167), ByteValue(value=1), ByteValue(value=183), ByteValue(value=32); 
DATA: ByteValue(value=57), ByteValue(value=241), ByteValue(value=95), ByteValue(value=56), ByteValue(value=109), ByteValue(value=193), ByteValue(value=175), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 1-3/5-3                                                       ; 
L_GroundArea7:                                                                                      ;  B
DATA: ByteValue(value=144), ByteValue(value=17)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=254), ByteValue(value=16), ByteValue(value=42), ByteValue(value=147), ByteValue(value=135), ByteValue(value=23), ByteValue(value=163), ByteValue(value=20); 
DATA: ByteValue(value=178), ByteValue(value=66), ByteValue(value=10), ByteValue(value=146), ByteValue(value=25), ByteValue(value=64), ByteValue(value=54), ByteValue(value=20), ByteValue(value=80), ByteValue(value=65); 
DATA: ByteValue(value=130), ByteValue(value=22), ByteValue(value=43), ByteValue(value=147), ByteValue(value=36), ByteValue(value=65), ByteValue(value=187), ByteValue(value=20), ByteValue(value=184), ByteValue(value=0); 
DATA: ByteValue(value=194), ByteValue(value=67), ByteValue(value=195), ByteValue(value=19), ByteValue(value=27), ByteValue(value=148), ByteValue(value=103), ByteValue(value=18), ByteValue(value=196), ByteValue(value=21); 
DATA: ByteValue(value=83), ByteValue(value=193), ByteValue(value=210), ByteValue(value=65), ByteValue(value=18), ByteValue(value=193), ByteValue(value=41), ByteValue(value=19), ByteValue(value=133), ByteValue(value=23); 
DATA: ByteValue(value=27), ByteValue(value=146), ByteValue(value=26), ByteValue(value=66), ByteValue(value=71), ByteValue(value=19), ByteValue(value=131), ByteValue(value=65), ByteValue(value=167), ByteValue(value=19); 
DATA: ByteValue(value=14), ByteValue(value=145), ByteValue(value=167), ByteValue(value=99), ByteValue(value=183), ByteValue(value=99), ByteValue(value=197), ByteValue(value=101), ByteValue(value=213), ByteValue(value=101); 
DATA: ByteValue(value=221), ByteValue(value=74), ByteValue(value=227), ByteValue(value=103), ByteValue(value=243), ByteValue(value=103), ByteValue(value=141), ByteValue(value=193), ByteValue(value=174), ByteValue(value=66); 
DATA: ByteValue(value=223), ByteValue(value=32)                                                     ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 2-3/7-3                                                       ; 
L_GroundArea8:                                                                                      ;  B
DATA: ByteValue(value=144), ByteValue(value=17)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=110), ByteValue(value=16), ByteValue(value=139), ByteValue(value=23), ByteValue(value=175), ByteValue(value=50), ByteValue(value=216), ByteValue(value=98); 
DATA: ByteValue(value=232), ByteValue(value=98), ByteValue(value=252), ByteValue(value=63), ByteValue(value=173), ByteValue(value=200), ByteValue(value=248), ByteValue(value=100), ByteValue(value=12), ByteValue(value=190); 
DATA: ByteValue(value=67), ByteValue(value=67), ByteValue(value=248), ByteValue(value=100), ByteValue(value=12), ByteValue(value=191), ByteValue(value=115), ByteValue(value=64), ByteValue(value=132), ByteValue(value=64); 
DATA: ByteValue(value=147), ByteValue(value=64), ByteValue(value=164), ByteValue(value=64), ByteValue(value=179), ByteValue(value=64), ByteValue(value=248), ByteValue(value=100), ByteValue(value=72), ByteValue(value=228); 
DATA: ByteValue(value=92), ByteValue(value=57), ByteValue(value=131), ByteValue(value=64), ByteValue(value=146), ByteValue(value=65), ByteValue(value=179), ByteValue(value=64), ByteValue(value=248), ByteValue(value=100); 
DATA: ByteValue(value=72), ByteValue(value=228), ByteValue(value=92), ByteValue(value=57), ByteValue(value=248), ByteValue(value=100), ByteValue(value=19), ByteValue(value=194), ByteValue(value=55), ByteValue(value=101); 
DATA: ByteValue(value=76), ByteValue(value=36), ByteValue(value=99), ByteValue(value=0), ByteValue(value=151), ByteValue(value=101), ByteValue(value=195), ByteValue(value=66), ByteValue(value=11), ByteValue(value=151); 
DATA: ByteValue(value=172), ByteValue(value=50), ByteValue(value=248), ByteValue(value=100), ByteValue(value=12), ByteValue(value=190), ByteValue(value=83), ByteValue(value=69), ByteValue(value=157), ByteValue(value=72); 
DATA: ByteValue(value=248), ByteValue(value=100), ByteValue(value=42), ByteValue(value=226), ByteValue(value=60), ByteValue(value=71), ByteValue(value=86), ByteValue(value=67), ByteValue(value=186), ByteValue(value=98); 
DATA: ByteValue(value=248), ByteValue(value=100), ByteValue(value=12), ByteValue(value=183), ByteValue(value=136), ByteValue(value=100), ByteValue(value=188), ByteValue(value=49), ByteValue(value=212), ByteValue(value=69); 
DATA: ByteValue(value=252), ByteValue(value=49), ByteValue(value=60), ByteValue(value=177), ByteValue(value=120), ByteValue(value=100), ByteValue(value=140), ByteValue(value=56), ByteValue(value=11), ByteValue(value=156); 
DATA: ByteValue(value=26), ByteValue(value=51), ByteValue(value=24), ByteValue(value=97), ByteValue(value=40), ByteValue(value=97), ByteValue(value=57), ByteValue(value=96), ByteValue(value=93), ByteValue(value=74); 
DATA: ByteValue(value=238), ByteValue(value=17), ByteValue(value=15), ByteValue(value=184), ByteValue(value=29), ByteValue(value=193), ByteValue(value=62), ByteValue(value=66), ByteValue(value=111), ByteValue(value=32); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 2-1                                                           ; 
L_GroundArea9:                                                                                      ;  B
DATA: ByteValue(value=82), ByteValue(value=49)                                                      ; 
DATA: ByteValue(value=15), ByteValue(value=32), ByteValue(value=110), ByteValue(value=64), ByteValue(value=247), ByteValue(value=32), ByteValue(value=7), ByteValue(value=132), ByteValue(value=23), ByteValue(value=32); 
DATA: ByteValue(value=79), ByteValue(value=52), ByteValue(value=195), ByteValue(value=3), ByteValue(value=199), ByteValue(value=2), ByteValue(value=211), ByteValue(value=34), ByteValue(value=39), ByteValue(value=227); 
DATA: ByteValue(value=57), ByteValue(value=97), ByteValue(value=231), ByteValue(value=115), ByteValue(value=92), ByteValue(value=228), ByteValue(value=87), ByteValue(value=0), ByteValue(value=108), ByteValue(value=115); 
DATA: ByteValue(value=71), ByteValue(value=160), ByteValue(value=83), ByteValue(value=6), ByteValue(value=99), ByteValue(value=34), ByteValue(value=167), ByteValue(value=115), ByteValue(value=252), ByteValue(value=115); 
DATA: ByteValue(value=19), ByteValue(value=161), ByteValue(value=51), ByteValue(value=5), ByteValue(value=67), ByteValue(value=33), ByteValue(value=92), ByteValue(value=114), ByteValue(value=195), ByteValue(value=35); 
DATA: ByteValue(value=204), ByteValue(value=3), ByteValue(value=119), ByteValue(value=251), ByteValue(value=172), ByteValue(value=2), ByteValue(value=57), ByteValue(value=241), ByteValue(value=167), ByteValue(value=115); 
DATA: ByteValue(value=211), ByteValue(value=4), ByteValue(value=232), ByteValue(value=114), ByteValue(value=227), ByteValue(value=34), ByteValue(value=38), ByteValue(value=244), ByteValue(value=188), ByteValue(value=2); 
DATA: ByteValue(value=140), ByteValue(value=129), ByteValue(value=168), ByteValue(value=98), ByteValue(value=23), ByteValue(value=135), ByteValue(value=67), ByteValue(value=36), ByteValue(value=167), ByteValue(value=1); 
DATA: ByteValue(value=195), ByteValue(value=4), ByteValue(value=8), ByteValue(value=242), ByteValue(value=151), ByteValue(value=33), ByteValue(value=163), ByteValue(value=2), ByteValue(value=201), ByteValue(value=11); 
DATA: ByteValue(value=225), ByteValue(value=105), ByteValue(value=241), ByteValue(value=105), ByteValue(value=141), ByteValue(value=193), ByteValue(value=207), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; pipe intro area                                                     ; 
L_GroundArea10:                                                                                     ;  B
DATA: ByteValue(value=56), ByteValue(value=17)                                                      ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=173), ByteValue(value=64), ByteValue(value=61), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 5-1                                                           ; 
L_GroundArea11:                                                                                     ;  B
DATA: ByteValue(value=149), ByteValue(value=177)                                                    ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=13), ByteValue(value=2), ByteValue(value=200), ByteValue(value=114), ByteValue(value=28), ByteValue(value=129), ByteValue(value=56), ByteValue(value=114); 
DATA: ByteValue(value=13), ByteValue(value=5), ByteValue(value=151), ByteValue(value=52), ByteValue(value=152), ByteValue(value=98), ByteValue(value=163), ByteValue(value=32), ByteValue(value=179), ByteValue(value=6); 
DATA: ByteValue(value=195), ByteValue(value=32), ByteValue(value=204), ByteValue(value=3), ByteValue(value=249), ByteValue(value=145), ByteValue(value=44), ByteValue(value=129), ByteValue(value=72), ByteValue(value=98); 
DATA: ByteValue(value=13), ByteValue(value=9), ByteValue(value=55), ByteValue(value=99), ByteValue(value=71), ByteValue(value=3), ByteValue(value=87), ByteValue(value=33), ByteValue(value=140), ByteValue(value=2); 
DATA: ByteValue(value=197), ByteValue(value=121), ByteValue(value=199), ByteValue(value=49), ByteValue(value=249), ByteValue(value=17), ByteValue(value=57), ByteValue(value=241), ByteValue(value=169), ByteValue(value=17); 
DATA: ByteValue(value=111), ByteValue(value=180), ByteValue(value=211), ByteValue(value=101), ByteValue(value=227), ByteValue(value=101), ByteValue(value=125), ByteValue(value=193), ByteValue(value=191), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; cloud level used in levels 2-1 and 5-2                              ; 
L_GroundArea12:                                                                                     ;  B
DATA: ByteValue(value=0), ByteValue(value=193)                                                      ; 
DATA: ByteValue(value=76), ByteValue(value=0), ByteValue(value=244), ByteValue(value=79), ByteValue(value=13), ByteValue(value=2), ByteValue(value=2), ByteValue(value=66), ByteValue(value=67), ByteValue(value=79); 
DATA: ByteValue(value=82), ByteValue(value=194), ByteValue(value=222), ByteValue(value=0), ByteValue(value=90), ByteValue(value=194), ByteValue(value=77), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 4-3                                                           ; 
L_GroundArea13:                                                                                     ;  B
DATA: ByteValue(value=144), ByteValue(value=81)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=238), ByteValue(value=16), ByteValue(value=11), ByteValue(value=148), ByteValue(value=51), ByteValue(value=20), ByteValue(value=66), ByteValue(value=66); 
DATA: ByteValue(value=119), ByteValue(value=22), ByteValue(value=134), ByteValue(value=68), ByteValue(value=2), ByteValue(value=146), ByteValue(value=74), ByteValue(value=22), ByteValue(value=105), ByteValue(value=66); 
DATA: ByteValue(value=115), ByteValue(value=20), ByteValue(value=176), ByteValue(value=0), ByteValue(value=199), ByteValue(value=18), ByteValue(value=5), ByteValue(value=192), ByteValue(value=28), ByteValue(value=23); 
DATA: ByteValue(value=31), ByteValue(value=17), ByteValue(value=54), ByteValue(value=18), ByteValue(value=143), ByteValue(value=20), ByteValue(value=145), ByteValue(value=64), ByteValue(value=27), ByteValue(value=148); 
DATA: ByteValue(value=53), ByteValue(value=18), ByteValue(value=52), ByteValue(value=66), ByteValue(value=96), ByteValue(value=66), ByteValue(value=97), ByteValue(value=18), ByteValue(value=135), ByteValue(value=18); 
DATA: ByteValue(value=150), ByteValue(value=64), ByteValue(value=163), ByteValue(value=20), ByteValue(value=28), ByteValue(value=152), ByteValue(value=31), ByteValue(value=17), ByteValue(value=71), ByteValue(value=18); 
DATA: ByteValue(value=159), ByteValue(value=21), ByteValue(value=204), ByteValue(value=21), ByteValue(value=207), ByteValue(value=17), ByteValue(value=5), ByteValue(value=192), ByteValue(value=31), ByteValue(value=21); 
DATA: ByteValue(value=57), ByteValue(value=18), ByteValue(value=124), ByteValue(value=22), ByteValue(value=127), ByteValue(value=17), ByteValue(value=130), ByteValue(value=64), ByteValue(value=152), ByteValue(value=18); 
DATA: ByteValue(value=223), ByteValue(value=21), ByteValue(value=22), ByteValue(value=196), ByteValue(value=23), ByteValue(value=20), ByteValue(value=84), ByteValue(value=18), ByteValue(value=155), ByteValue(value=22); 
DATA: ByteValue(value=40), ByteValue(value=148), ByteValue(value=206), ByteValue(value=1), ByteValue(value=61), ByteValue(value=193), ByteValue(value=94), ByteValue(value=66), ByteValue(value=143), ByteValue(value=32); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 6-3                                                           ; 
L_GroundArea14:                                                                                     ;  B
DATA: ByteValue(value=151), ByteValue(value=17)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=254), ByteValue(value=16), ByteValue(value=43), ByteValue(value=146), ByteValue(value=87), ByteValue(value=18), ByteValue(value=139), ByteValue(value=18); 
DATA: ByteValue(value=192), ByteValue(value=65), ByteValue(value=247), ByteValue(value=19), ByteValue(value=91), ByteValue(value=146), ByteValue(value=105), ByteValue(value=11), ByteValue(value=187), ByteValue(value=18); 
DATA: ByteValue(value=178), ByteValue(value=70), ByteValue(value=25), ByteValue(value=147), ByteValue(value=113), ByteValue(value=0), ByteValue(value=23), ByteValue(value=148), ByteValue(value=124), ByteValue(value=20); 
DATA: ByteValue(value=127), ByteValue(value=17), ByteValue(value=147), ByteValue(value=65), ByteValue(value=191), ByteValue(value=21), ByteValue(value=252), ByteValue(value=19), ByteValue(value=255), ByteValue(value=17); 
DATA: ByteValue(value=47), ByteValue(value=149), ByteValue(value=80), ByteValue(value=66), ByteValue(value=81), ByteValue(value=18), ByteValue(value=88), ByteValue(value=20), ByteValue(value=166), ByteValue(value=18); 
DATA: ByteValue(value=219), ByteValue(value=18), ByteValue(value=27), ByteValue(value=147), ByteValue(value=70), ByteValue(value=67), ByteValue(value=123), ByteValue(value=18), ByteValue(value=141), ByteValue(value=73); 
DATA: ByteValue(value=183), ByteValue(value=20), ByteValue(value=27), ByteValue(value=148), ByteValue(value=73), ByteValue(value=11), ByteValue(value=187), ByteValue(value=18), ByteValue(value=252), ByteValue(value=19); 
DATA: ByteValue(value=255), ByteValue(value=18), ByteValue(value=3), ByteValue(value=193), ByteValue(value=47), ByteValue(value=21), ByteValue(value=67), ByteValue(value=18), ByteValue(value=75), ByteValue(value=19); 
DATA: ByteValue(value=119), ByteValue(value=19), ByteValue(value=157), ByteValue(value=74), ByteValue(value=21), ByteValue(value=193), ByteValue(value=161), ByteValue(value=65), ByteValue(value=195), ByteValue(value=18); 
DATA: ByteValue(value=254), ByteValue(value=1), ByteValue(value=125), ByteValue(value=193), ByteValue(value=158), ByteValue(value=66), ByteValue(value=207), ByteValue(value=32); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 6-1                                                           ; 
L_GroundArea15:                                                                                     ;  B
DATA: ByteValue(value=82), ByteValue(value=33)                                                      ; 
DATA: ByteValue(value=15), ByteValue(value=32), ByteValue(value=110), ByteValue(value=68), ByteValue(value=12), ByteValue(value=241), ByteValue(value=76), ByteValue(value=1), ByteValue(value=170), ByteValue(value=53); 
DATA: ByteValue(value=217), ByteValue(value=52), ByteValue(value=238), ByteValue(value=32), ByteValue(value=8), ByteValue(value=179), ByteValue(value=55), ByteValue(value=50), ByteValue(value=67), ByteValue(value=4); 
DATA: ByteValue(value=78), ByteValue(value=33), ByteValue(value=83), ByteValue(value=32), ByteValue(value=124), ByteValue(value=1), ByteValue(value=151), ByteValue(value=33), ByteValue(value=183), ByteValue(value=7); 
DATA: ByteValue(value=156), ByteValue(value=129), ByteValue(value=231), ByteValue(value=66), ByteValue(value=95), ByteValue(value=179), ByteValue(value=151), ByteValue(value=99), ByteValue(value=172), ByteValue(value=2); 
DATA: ByteValue(value=197), ByteValue(value=65), ByteValue(value=73), ByteValue(value=224), ByteValue(value=88), ByteValue(value=97), ByteValue(value=118), ByteValue(value=100), ByteValue(value=133), ByteValue(value=101); 
DATA: ByteValue(value=148), ByteValue(value=102), ByteValue(value=164), ByteValue(value=34), ByteValue(value=166), ByteValue(value=3), ByteValue(value=200), ByteValue(value=34), ByteValue(value=220), ByteValue(value=2); 
DATA: ByteValue(value=104), ByteValue(value=242), ByteValue(value=150), ByteValue(value=66), ByteValue(value=19), ByteValue(value=130), ByteValue(value=23), ByteValue(value=2), ByteValue(value=175), ByteValue(value=52); 
DATA: ByteValue(value=246), ByteValue(value=33), ByteValue(value=252), ByteValue(value=6), ByteValue(value=38), ByteValue(value=128), ByteValue(value=42), ByteValue(value=36), ByteValue(value=54), ByteValue(value=1); 
DATA: ByteValue(value=140), ByteValue(value=0), ByteValue(value=255), ByteValue(value=53), ByteValue(value=78), ByteValue(value=160), ByteValue(value=85), ByteValue(value=33), ByteValue(value=119), ByteValue(value=32); 
DATA: ByteValue(value=135), ByteValue(value=7), ByteValue(value=137), ByteValue(value=34), ByteValue(value=174), ByteValue(value=33), ByteValue(value=76), ByteValue(value=130), ByteValue(value=159), ByteValue(value=52); 
DATA: ByteValue(value=236), ByteValue(value=1), ByteValue(value=3), ByteValue(value=231), ByteValue(value=19), ByteValue(value=103), ByteValue(value=141), ByteValue(value=74), ByteValue(value=173), ByteValue(value=65); 
DATA: ByteValue(value=15), ByteValue(value=166)                                                     ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; warp zone area used in level 4-2                                    ; 
L_GroundArea16:                                                                                     ;  B
DATA: ByteValue(value=16), ByteValue(value=81)                                                      ; 
DATA: ByteValue(value=76), ByteValue(value=0), ByteValue(value=199), ByteValue(value=18), ByteValue(value=198), ByteValue(value=66), ByteValue(value=3), ByteValue(value=146), ByteValue(value=2), ByteValue(value=66); 
DATA: ByteValue(value=41), ByteValue(value=18), ByteValue(value=99), ByteValue(value=18), ByteValue(value=98), ByteValue(value=66), ByteValue(value=105), ByteValue(value=20), ByteValue(value=165), ByteValue(value=18); 
DATA: ByteValue(value=164), ByteValue(value=66), ByteValue(value=226), ByteValue(value=20), ByteValue(value=225), ByteValue(value=68), ByteValue(value=248), ByteValue(value=22), ByteValue(value=55), ByteValue(value=193); 
DATA: ByteValue(value=143), ByteValue(value=56), ByteValue(value=2), ByteValue(value=187), ByteValue(value=40), ByteValue(value=122), ByteValue(value=104), ByteValue(value=122), ByteValue(value=168), ByteValue(value=122); 
DATA: ByteValue(value=224), ByteValue(value=106), ByteValue(value=240), ByteValue(value=106), ByteValue(value=109), ByteValue(value=197); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 8-1                                                           ; 
L_GroundArea17:                                                                                     ;  B
DATA: ByteValue(value=146), ByteValue(value=49)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=32), ByteValue(value=110), ByteValue(value=64), ByteValue(value=13), ByteValue(value=2), ByteValue(value=55), ByteValue(value=115), ByteValue(value=236), ByteValue(value=0); 
DATA: ByteValue(value=12), ByteValue(value=128), ByteValue(value=60), ByteValue(value=0), ByteValue(value=108), ByteValue(value=0), ByteValue(value=156), ByteValue(value=0), ByteValue(value=6), ByteValue(value=192); 
DATA: ByteValue(value=199), ByteValue(value=115), ByteValue(value=6), ByteValue(value=131), ByteValue(value=40), ByteValue(value=114), ByteValue(value=150), ByteValue(value=64), ByteValue(value=231), ByteValue(value=115); 
DATA: ByteValue(value=38), ByteValue(value=192), ByteValue(value=135), ByteValue(value=123), ByteValue(value=210), ByteValue(value=65), ByteValue(value=57), ByteValue(value=241), ByteValue(value=200), ByteValue(value=242); 
DATA: ByteValue(value=151), ByteValue(value=227), ByteValue(value=163), ByteValue(value=35), ByteValue(value=231), ByteValue(value=2), ByteValue(value=227), ByteValue(value=7), ByteValue(value=243), ByteValue(value=34); 
DATA: ByteValue(value=55), ByteValue(value=227), ByteValue(value=156), ByteValue(value=0), ByteValue(value=188), ByteValue(value=0), ByteValue(value=236), ByteValue(value=0), ByteValue(value=12), ByteValue(value=128); 
DATA: ByteValue(value=60), ByteValue(value=0), ByteValue(value=134), ByteValue(value=33), ByteValue(value=166), ByteValue(value=6), ByteValue(value=182), ByteValue(value=36), ByteValue(value=92), ByteValue(value=128); 
DATA: ByteValue(value=124), ByteValue(value=0), ByteValue(value=156), ByteValue(value=0), ByteValue(value=41), ByteValue(value=225), ByteValue(value=220), ByteValue(value=5), ByteValue(value=246), ByteValue(value=65); 
DATA: ByteValue(value=220), ByteValue(value=128), ByteValue(value=232), ByteValue(value=114), ByteValue(value=12), ByteValue(value=129), ByteValue(value=39), ByteValue(value=115), ByteValue(value=76), ByteValue(value=1); 
DATA: ByteValue(value=102), ByteValue(value=116), ByteValue(value=13), ByteValue(value=17), ByteValue(value=63), ByteValue(value=53), ByteValue(value=182), ByteValue(value=65), ByteValue(value=44), ByteValue(value=130); 
DATA: ByteValue(value=54), ByteValue(value=64), ByteValue(value=124), ByteValue(value=2), ByteValue(value=134), ByteValue(value=64), ByteValue(value=249), ByteValue(value=97), ByteValue(value=57), ByteValue(value=225); 
DATA: ByteValue(value=172), ByteValue(value=4), ByteValue(value=198), ByteValue(value=65), ByteValue(value=12), ByteValue(value=131), ByteValue(value=22), ByteValue(value=65), ByteValue(value=136), ByteValue(value=242); 
DATA: ByteValue(value=57), ByteValue(value=241), ByteValue(value=124), ByteValue(value=0), ByteValue(value=137), ByteValue(value=97), ByteValue(value=156), ByteValue(value=0), ByteValue(value=167), ByteValue(value=99); 
DATA: ByteValue(value=188), ByteValue(value=0), ByteValue(value=197), ByteValue(value=101), ByteValue(value=220), ByteValue(value=0), ByteValue(value=227), ByteValue(value=103), ByteValue(value=243), ByteValue(value=103); 
DATA: ByteValue(value=141), ByteValue(value=193), ByteValue(value=207), ByteValue(value=38)         ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 5-2                                                           ; 
L_GroundArea18:                                                                                     ;  B
DATA: ByteValue(value=85), ByteValue(value=177)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=207), ByteValue(value=51), ByteValue(value=7), ByteValue(value=178), ByteValue(value=21), ByteValue(value=17), ByteValue(value=82), ByteValue(value=66); 
DATA: ByteValue(value=153), ByteValue(value=11), ByteValue(value=172), ByteValue(value=2), ByteValue(value=211), ByteValue(value=36), ByteValue(value=214), ByteValue(value=66), ByteValue(value=215), ByteValue(value=37); 
DATA: ByteValue(value=35), ByteValue(value=132), ByteValue(value=207), ByteValue(value=51), ByteValue(value=7), ByteValue(value=227), ByteValue(value=25), ByteValue(value=97), ByteValue(value=120), ByteValue(value=122); 
DATA: ByteValue(value=239), ByteValue(value=51), ByteValue(value=44), ByteValue(value=129), ByteValue(value=70), ByteValue(value=100), ByteValue(value=85), ByteValue(value=101), ByteValue(value=101), ByteValue(value=101); 
DATA: ByteValue(value=236), ByteValue(value=116), ByteValue(value=71), ByteValue(value=130), ByteValue(value=83), ByteValue(value=5), ByteValue(value=99), ByteValue(value=33), ByteValue(value=98), ByteValue(value=65); 
DATA: ByteValue(value=150), ByteValue(value=34), ByteValue(value=154), ByteValue(value=65), ByteValue(value=204), ByteValue(value=3), ByteValue(value=185), ByteValue(value=145), ByteValue(value=57), ByteValue(value=241); 
DATA: ByteValue(value=99), ByteValue(value=38), ByteValue(value=103), ByteValue(value=39), ByteValue(value=211), ByteValue(value=6), ByteValue(value=252), ByteValue(value=1), ByteValue(value=24), ByteValue(value=226); 
DATA: ByteValue(value=217), ByteValue(value=7), ByteValue(value=233), ByteValue(value=4), ByteValue(value=12), ByteValue(value=134), ByteValue(value=55), ByteValue(value=34), ByteValue(value=147), ByteValue(value=36); 
DATA: ByteValue(value=135), ByteValue(value=132), ByteValue(value=172), ByteValue(value=2), ByteValue(value=194), ByteValue(value=65), ByteValue(value=195), ByteValue(value=35), ByteValue(value=217), ByteValue(value=113); 
DATA: ByteValue(value=252), ByteValue(value=1), ByteValue(value=127), ByteValue(value=177), ByteValue(value=156), ByteValue(value=0), ByteValue(value=167), ByteValue(value=99), ByteValue(value=182), ByteValue(value=100); 
DATA: ByteValue(value=204), ByteValue(value=0), ByteValue(value=212), ByteValue(value=102), ByteValue(value=227), ByteValue(value=103), ByteValue(value=243), ByteValue(value=103), ByteValue(value=141), ByteValue(value=193); 
DATA: ByteValue(value=207), ByteValue(value=38)                                                     ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 8-2                                                           ; 
L_GroundArea19:                                                                                     ;  B
DATA: ByteValue(value=80), ByteValue(value=177)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=252), ByteValue(value=0), ByteValue(value=31), ByteValue(value=179), ByteValue(value=92), ByteValue(value=0), ByteValue(value=101), ByteValue(value=101); 
DATA: ByteValue(value=116), ByteValue(value=102), ByteValue(value=131), ByteValue(value=103), ByteValue(value=147), ByteValue(value=103), ByteValue(value=220), ByteValue(value=115), ByteValue(value=76), ByteValue(value=128); 
DATA: ByteValue(value=179), ByteValue(value=32), ByteValue(value=201), ByteValue(value=11), ByteValue(value=195), ByteValue(value=8), ByteValue(value=211), ByteValue(value=47), ByteValue(value=220), ByteValue(value=0); 
DATA: ByteValue(value=44), ByteValue(value=128), ByteValue(value=76), ByteValue(value=0), ByteValue(value=140), ByteValue(value=0), ByteValue(value=211), ByteValue(value=46), ByteValue(value=237), ByteValue(value=74); 
DATA: ByteValue(value=252), ByteValue(value=0), ByteValue(value=215), ByteValue(value=161), ByteValue(value=236), ByteValue(value=1), ByteValue(value=76), ByteValue(value=128), ByteValue(value=89), ByteValue(value=17); 
DATA: ByteValue(value=216), ByteValue(value=17), ByteValue(value=218), ByteValue(value=16), ByteValue(value=55), ByteValue(value=160), ByteValue(value=71), ByteValue(value=4), ByteValue(value=153), ByteValue(value=17); 
DATA: ByteValue(value=231), ByteValue(value=33), ByteValue(value=58), ByteValue(value=144), ByteValue(value=103), ByteValue(value=32), ByteValue(value=118), ByteValue(value=16), ByteValue(value=119), ByteValue(value=96); 
DATA: ByteValue(value=135), ByteValue(value=7), ByteValue(value=216), ByteValue(value=18), ByteValue(value=57), ByteValue(value=241), ByteValue(value=172), ByteValue(value=0), ByteValue(value=233), ByteValue(value=113); 
DATA: ByteValue(value=12), ByteValue(value=128), ByteValue(value=44), ByteValue(value=0), ByteValue(value=76), ByteValue(value=5), ByteValue(value=199), ByteValue(value=123), ByteValue(value=57), ByteValue(value=241); 
DATA: ByteValue(value=236), ByteValue(value=0), ByteValue(value=249), ByteValue(value=17), ByteValue(value=12), ByteValue(value=130), ByteValue(value=111), ByteValue(value=52), ByteValue(value=248), ByteValue(value=17); 
DATA: ByteValue(value=250), ByteValue(value=16), ByteValue(value=127), ByteValue(value=178), ByteValue(value=172), ByteValue(value=0), ByteValue(value=182), ByteValue(value=100), ByteValue(value=204), ByteValue(value=1); 
DATA: ByteValue(value=227), ByteValue(value=103), ByteValue(value=243), ByteValue(value=103), ByteValue(value=141), ByteValue(value=193), ByteValue(value=207), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 7-1                                                           ; 
L_GroundArea20:                                                                                     ;  B
DATA: ByteValue(value=82), ByteValue(value=177)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=32), ByteValue(value=110), ByteValue(value=69), ByteValue(value=57), ByteValue(value=145), ByteValue(value=179), ByteValue(value=4), ByteValue(value=195), ByteValue(value=33); 
DATA: ByteValue(value=200), ByteValue(value=17), ByteValue(value=202), ByteValue(value=16), ByteValue(value=73), ByteValue(value=145), ByteValue(value=124), ByteValue(value=115), ByteValue(value=232), ByteValue(value=18); 
DATA: ByteValue(value=136), ByteValue(value=145), ByteValue(value=138), ByteValue(value=16), ByteValue(value=231), ByteValue(value=33), ByteValue(value=5), ByteValue(value=145), ByteValue(value=7), ByteValue(value=48); 
DATA: ByteValue(value=23), ByteValue(value=7), ByteValue(value=39), ByteValue(value=32), ByteValue(value=73), ByteValue(value=17), ByteValue(value=156), ByteValue(value=1), ByteValue(value=200), ByteValue(value=114); 
DATA: ByteValue(value=35), ByteValue(value=166), ByteValue(value=39), ByteValue(value=38), ByteValue(value=211), ByteValue(value=3), ByteValue(value=216), ByteValue(value=122), ByteValue(value=137), ByteValue(value=145); 
DATA: ByteValue(value=216), ByteValue(value=114), ByteValue(value=57), ByteValue(value=241), ByteValue(value=169), ByteValue(value=17), ByteValue(value=9), ByteValue(value=241), ByteValue(value=99), ByteValue(value=36); 
DATA: ByteValue(value=103), ByteValue(value=36), ByteValue(value=216), ByteValue(value=98), ByteValue(value=40), ByteValue(value=145), ByteValue(value=42), ByteValue(value=16), ByteValue(value=86), ByteValue(value=33); 
DATA: ByteValue(value=112), ByteValue(value=4), ByteValue(value=121), ByteValue(value=11), ByteValue(value=140), ByteValue(value=0), ByteValue(value=148), ByteValue(value=33), ByteValue(value=159), ByteValue(value=53); 
DATA: ByteValue(value=47), ByteValue(value=184), ByteValue(value=61), ByteValue(value=193), ByteValue(value=127), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; cloud level used in levels 3-1 and 6-2                              ; 
L_GroundArea21:                                                                                     ;  B
DATA: ByteValue(value=6), ByteValue(value=193)                                                      ; 
DATA: ByteValue(value=76), ByteValue(value=0), ByteValue(value=244), ByteValue(value=79), ByteValue(value=13), ByteValue(value=2), ByteValue(value=6), ByteValue(value=32), ByteValue(value=36), ByteValue(value=79); 
DATA: ByteValue(value=53), ByteValue(value=160), ByteValue(value=54), ByteValue(value=32), ByteValue(value=83), ByteValue(value=70), ByteValue(value=213), ByteValue(value=32), ByteValue(value=214), ByteValue(value=32); 
DATA: ByteValue(value=52), ByteValue(value=161), ByteValue(value=115), ByteValue(value=73), ByteValue(value=116), ByteValue(value=32), ByteValue(value=148), ByteValue(value=32), ByteValue(value=180), ByteValue(value=32); 
DATA: ByteValue(value=212), ByteValue(value=32), ByteValue(value=244), ByteValue(value=32), ByteValue(value=46), ByteValue(value=128), ByteValue(value=89), ByteValue(value=66), ByteValue(value=77), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 3-2                                                           ; 
L_GroundArea22:                                                                                     ;  B
DATA: ByteValue(value=150), ByteValue(value=49)                                                     ; 
DATA: ByteValue(value=15), ByteValue(value=38), ByteValue(value=13), ByteValue(value=3), ByteValue(value=26), ByteValue(value=96), ByteValue(value=119), ByteValue(value=66), ByteValue(value=196), ByteValue(value=0); 
DATA: ByteValue(value=200), ByteValue(value=98), ByteValue(value=185), ByteValue(value=225), ByteValue(value=211), ByteValue(value=6), ByteValue(value=215), ByteValue(value=7), ByteValue(value=249), ByteValue(value=97); 
DATA: ByteValue(value=12), ByteValue(value=129), ByteValue(value=78), ByteValue(value=177), ByteValue(value=142), ByteValue(value=177), ByteValue(value=188), ByteValue(value=1), ByteValue(value=228), ByteValue(value=80); 
DATA: ByteValue(value=233), ByteValue(value=97), ByteValue(value=12), ByteValue(value=129), ByteValue(value=13), ByteValue(value=10), ByteValue(value=132), ByteValue(value=67), ByteValue(value=152), ByteValue(value=114); 
DATA: ByteValue(value=13), ByteValue(value=12), ByteValue(value=15), ByteValue(value=56), ByteValue(value=29), ByteValue(value=193), ByteValue(value=95), ByteValue(value=38); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 1-2                                                           ; 
L_UndergroundArea1:                                                                                 ;  B
DATA: ByteValue(value=72), ByteValue(value=15)                                                      ; 
DATA: ByteValue(value=14), ByteValue(value=1), ByteValue(value=94), ByteValue(value=2), ByteValue(value=167), ByteValue(value=0), ByteValue(value=188), ByteValue(value=115), ByteValue(value=26), ByteValue(value=224); 
DATA: ByteValue(value=57), ByteValue(value=97), ByteValue(value=88), ByteValue(value=98), ByteValue(value=119), ByteValue(value=99), ByteValue(value=151), ByteValue(value=99), ByteValue(value=184), ByteValue(value=98); 
DATA: ByteValue(value=214), ByteValue(value=7), ByteValue(value=248), ByteValue(value=98), ByteValue(value=25), ByteValue(value=225), ByteValue(value=117), ByteValue(value=82), ByteValue(value=134), ByteValue(value=64); 
DATA: ByteValue(value=135), ByteValue(value=80), ByteValue(value=149), ByteValue(value=82), ByteValue(value=147), ByteValue(value=67), ByteValue(value=165), ByteValue(value=33), ByteValue(value=197), ByteValue(value=82); 
DATA: ByteValue(value=214), ByteValue(value=64), ByteValue(value=215), ByteValue(value=32), ByteValue(value=229), ByteValue(value=6), ByteValue(value=230), ByteValue(value=81), ByteValue(value=62), ByteValue(value=141); 
DATA: ByteValue(value=94), ByteValue(value=3), ByteValue(value=103), ByteValue(value=82), ByteValue(value=119), ByteValue(value=82), ByteValue(value=126), ByteValue(value=2), ByteValue(value=158), ByteValue(value=3); 
DATA: ByteValue(value=166), ByteValue(value=67), ByteValue(value=167), ByteValue(value=35), ByteValue(value=222), ByteValue(value=5), ByteValue(value=254), ByteValue(value=2), ByteValue(value=30), ByteValue(value=131); 
DATA: ByteValue(value=51), ByteValue(value=84), ByteValue(value=70), ByteValue(value=64), ByteValue(value=71), ByteValue(value=33), ByteValue(value=86), ByteValue(value=4), ByteValue(value=94), ByteValue(value=2); 
DATA: ByteValue(value=131), ByteValue(value=84), ByteValue(value=147), ByteValue(value=82), ByteValue(value=150), ByteValue(value=7), ByteValue(value=151), ByteValue(value=80), ByteValue(value=190), ByteValue(value=3); 
DATA: ByteValue(value=199), ByteValue(value=35), ByteValue(value=254), ByteValue(value=2), ByteValue(value=12), ByteValue(value=130), ByteValue(value=67), ByteValue(value=69), ByteValue(value=69), ByteValue(value=36); 
DATA: ByteValue(value=70), ByteValue(value=36), ByteValue(value=144), ByteValue(value=8), ByteValue(value=149), ByteValue(value=81), ByteValue(value=120), ByteValue(value=250), ByteValue(value=215), ByteValue(value=115); 
DATA: ByteValue(value=57), ByteValue(value=241), ByteValue(value=140), ByteValue(value=1), ByteValue(value=168), ByteValue(value=82), ByteValue(value=184), ByteValue(value=82), ByteValue(value=204), ByteValue(value=1); 
DATA: ByteValue(value=95), ByteValue(value=179), ByteValue(value=151), ByteValue(value=99), ByteValue(value=158), ByteValue(value=0), ByteValue(value=14), ByteValue(value=129), ByteValue(value=22), ByteValue(value=36); 
DATA: ByteValue(value=102), ByteValue(value=4), ByteValue(value=142), ByteValue(value=0), ByteValue(value=254), ByteValue(value=1), ByteValue(value=8), ByteValue(value=210), ByteValue(value=14), ByteValue(value=6); 
DATA: ByteValue(value=111), ByteValue(value=71), ByteValue(value=158), ByteValue(value=15), ByteValue(value=14), ByteValue(value=130), ByteValue(value=45), ByteValue(value=71), ByteValue(value=40), ByteValue(value=122); 
DATA: ByteValue(value=104), ByteValue(value=122), ByteValue(value=168), ByteValue(value=122), ByteValue(value=174), ByteValue(value=1), ByteValue(value=222), ByteValue(value=15), ByteValue(value=109), ByteValue(value=197); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 4-2                                                           ; 
L_UndergroundArea2:                                                                                 ;  B
DATA: ByteValue(value=72), ByteValue(value=15)                                                      ; 
DATA: ByteValue(value=14), ByteValue(value=1), ByteValue(value=94), ByteValue(value=2), ByteValue(value=188), ByteValue(value=1), ByteValue(value=252), ByteValue(value=1), ByteValue(value=44), ByteValue(value=130); 
DATA: ByteValue(value=65), ByteValue(value=82), ByteValue(value=78), ByteValue(value=4), ByteValue(value=103), ByteValue(value=37), ByteValue(value=104), ByteValue(value=36), ByteValue(value=105), ByteValue(value=36); 
DATA: ByteValue(value=186), ByteValue(value=66), ByteValue(value=199), ByteValue(value=4), ByteValue(value=222), ByteValue(value=11), ByteValue(value=178), ByteValue(value=135), ByteValue(value=254), ByteValue(value=2); 
DATA: ByteValue(value=44), ByteValue(value=225), ByteValue(value=44), ByteValue(value=113), ByteValue(value=103), ByteValue(value=1), ByteValue(value=119), ByteValue(value=0), ByteValue(value=135), ByteValue(value=1); 
DATA: ByteValue(value=142), ByteValue(value=0), ByteValue(value=238), ByteValue(value=1), ByteValue(value=246), ByteValue(value=2), ByteValue(value=3), ByteValue(value=133), ByteValue(value=5), ByteValue(value=2); 
DATA: ByteValue(value=19), ByteValue(value=33), ByteValue(value=22), ByteValue(value=2), ByteValue(value=39), ByteValue(value=2), ByteValue(value=46), ByteValue(value=2), ByteValue(value=136), ByteValue(value=114); 
DATA: ByteValue(value=199), ByteValue(value=32), ByteValue(value=215), ByteValue(value=7), ByteValue(value=228), ByteValue(value=118), ByteValue(value=7), ByteValue(value=160), ByteValue(value=23), ByteValue(value=6); 
DATA: ByteValue(value=72), ByteValue(value=122), ByteValue(value=118), ByteValue(value=32), ByteValue(value=152), ByteValue(value=114), ByteValue(value=121), ByteValue(value=225), ByteValue(value=136), ByteValue(value=98); 
DATA: ByteValue(value=156), ByteValue(value=1), ByteValue(value=183), ByteValue(value=115), ByteValue(value=220), ByteValue(value=1), ByteValue(value=248), ByteValue(value=98), ByteValue(value=254), ByteValue(value=1); 
DATA: ByteValue(value=8), ByteValue(value=226), ByteValue(value=14), ByteValue(value=0), ByteValue(value=110), ByteValue(value=2), ByteValue(value=115), ByteValue(value=32), ByteValue(value=119), ByteValue(value=35); 
DATA: ByteValue(value=131), ByteValue(value=4), ByteValue(value=147), ByteValue(value=32), ByteValue(value=174), ByteValue(value=0), ByteValue(value=254), ByteValue(value=10), ByteValue(value=14), ByteValue(value=130); 
DATA: ByteValue(value=57), ByteValue(value=113), ByteValue(value=168), ByteValue(value=114), ByteValue(value=231), ByteValue(value=115), ByteValue(value=12), ByteValue(value=129), ByteValue(value=143), ByteValue(value=50); 
DATA: ByteValue(value=174), ByteValue(value=0), ByteValue(value=254), ByteValue(value=4), ByteValue(value=4), ByteValue(value=209), ByteValue(value=23), ByteValue(value=4), ByteValue(value=38), ByteValue(value=73); 
DATA: ByteValue(value=39), ByteValue(value=41), ByteValue(value=223), ByteValue(value=51), ByteValue(value=254), ByteValue(value=2), ByteValue(value=68), ByteValue(value=246), ByteValue(value=124), ByteValue(value=1); 
DATA: ByteValue(value=142), ByteValue(value=6), ByteValue(value=191), ByteValue(value=71), ByteValue(value=238), ByteValue(value=15), ByteValue(value=77), ByteValue(value=199), ByteValue(value=14), ByteValue(value=130); 
DATA: ByteValue(value=104), ByteValue(value=122), ByteValue(value=174), ByteValue(value=1), ByteValue(value=222), ByteValue(value=15), ByteValue(value=109), ByteValue(value=197); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; underground bonus rooms area used in many levels                    ; 
L_UndergroundArea3:                                                                                 ;  B
DATA: ByteValue(value=72), ByteValue(value=1)                                                       ; 
DATA: ByteValue(value=14), ByteValue(value=1), ByteValue(value=0), ByteValue(value=90), ByteValue(value=62), ByteValue(value=6), ByteValue(value=69), ByteValue(value=70), ByteValue(value=71), ByteValue(value=70); 
DATA: ByteValue(value=83), ByteValue(value=68), ByteValue(value=174), ByteValue(value=1), ByteValue(value=223), ByteValue(value=74), ByteValue(value=77), ByteValue(value=199), ByteValue(value=14), ByteValue(value=129); 
DATA: ByteValue(value=0), ByteValue(value=90), ByteValue(value=46), ByteValue(value=4), ByteValue(value=55), ByteValue(value=40), ByteValue(value=58), ByteValue(value=72), ByteValue(value=70), ByteValue(value=71); 
DATA: ByteValue(value=199), ByteValue(value=7), ByteValue(value=206), ByteValue(value=15), ByteValue(value=223), ByteValue(value=74), ByteValue(value=77), ByteValue(value=199), ByteValue(value=14), ByteValue(value=129); 
DATA: ByteValue(value=0), ByteValue(value=90), ByteValue(value=51), ByteValue(value=83), ByteValue(value=67), ByteValue(value=81), ByteValue(value=70), ByteValue(value=64), ByteValue(value=71), ByteValue(value=80); 
DATA: ByteValue(value=83), ByteValue(value=4), ByteValue(value=85), ByteValue(value=64), ByteValue(value=86), ByteValue(value=80), ByteValue(value=98), ByteValue(value=67), ByteValue(value=100), ByteValue(value=64); 
DATA: ByteValue(value=101), ByteValue(value=80), ByteValue(value=113), ByteValue(value=65), ByteValue(value=115), ByteValue(value=81), ByteValue(value=131), ByteValue(value=81), ByteValue(value=148), ByteValue(value=64); 
DATA: ByteValue(value=149), ByteValue(value=80), ByteValue(value=163), ByteValue(value=80), ByteValue(value=165), ByteValue(value=64), ByteValue(value=166), ByteValue(value=80), ByteValue(value=179), ByteValue(value=81); 
DATA: ByteValue(value=182), ByteValue(value=64), ByteValue(value=183), ByteValue(value=80), ByteValue(value=195), ByteValue(value=83), ByteValue(value=223), ByteValue(value=74), ByteValue(value=77), ByteValue(value=199); 
DATA: ByteValue(value=14), ByteValue(value=129), ByteValue(value=0), ByteValue(value=90), ByteValue(value=46), ByteValue(value=2), ByteValue(value=54), ByteValue(value=71), ByteValue(value=55), ByteValue(value=82); 
DATA: ByteValue(value=58), ByteValue(value=73), ByteValue(value=71), ByteValue(value=37), ByteValue(value=167), ByteValue(value=82), ByteValue(value=215), ByteValue(value=4), ByteValue(value=223), ByteValue(value=74); 
DATA: ByteValue(value=77), ByteValue(value=199), ByteValue(value=14), ByteValue(value=129), ByteValue(value=0), ByteValue(value=90), ByteValue(value=62), ByteValue(value=2), ByteValue(value=68), ByteValue(value=81); 
DATA: ByteValue(value=83), ByteValue(value=68), ByteValue(value=84), ByteValue(value=68), ByteValue(value=85), ByteValue(value=36), ByteValue(value=161), ByteValue(value=84), ByteValue(value=174), ByteValue(value=1); 
DATA: ByteValue(value=180), ByteValue(value=33), ByteValue(value=223), ByteValue(value=74), ByteValue(value=229), ByteValue(value=7), ByteValue(value=77), ByteValue(value=199); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; water area used in levels 5-2 and 6-2                               ; 
L_WaterArea1:                                                                                       ;  B
DATA: ByteValue(value=65), ByteValue(value=1)                                                       ; 
DATA: ByteValue(value=180), ByteValue(value=52), ByteValue(value=200), ByteValue(value=82), ByteValue(value=242), ByteValue(value=81), ByteValue(value=71), ByteValue(value=211), ByteValue(value=108), ByteValue(value=3); 
DATA: ByteValue(value=101), ByteValue(value=73), ByteValue(value=158), ByteValue(value=7), ByteValue(value=190), ByteValue(value=1), ByteValue(value=204), ByteValue(value=3), ByteValue(value=254), ByteValue(value=7); 
DATA: ByteValue(value=13), ByteValue(value=201), ByteValue(value=30), ByteValue(value=1), ByteValue(value=108), ByteValue(value=1), ByteValue(value=98), ByteValue(value=53), ByteValue(value=99), ByteValue(value=83); 
DATA: ByteValue(value=138), ByteValue(value=65), ByteValue(value=172), ByteValue(value=1), ByteValue(value=179), ByteValue(value=83), ByteValue(value=233), ByteValue(value=81), ByteValue(value=38), ByteValue(value=195); 
DATA: ByteValue(value=39), ByteValue(value=51), ByteValue(value=99), ByteValue(value=67), ByteValue(value=100), ByteValue(value=51), ByteValue(value=186), ByteValue(value=96), ByteValue(value=201), ByteValue(value=97); 
DATA: ByteValue(value=206), ByteValue(value=11), ByteValue(value=229), ByteValue(value=9), ByteValue(value=238), ByteValue(value=15), ByteValue(value=125), ByteValue(value=202), ByteValue(value=125), ByteValue(value=71); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; level 2-2/7-2                                                       ; 
L_WaterArea2:                                                                                       ;  B
DATA: ByteValue(value=65), ByteValue(value=1)                                                       ; 
DATA: ByteValue(value=184), ByteValue(value=82), ByteValue(value=234), ByteValue(value=65), ByteValue(value=39), ByteValue(value=178), ByteValue(value=179), ByteValue(value=66), ByteValue(value=22), ByteValue(value=212); 
DATA: ByteValue(value=74), ByteValue(value=66), ByteValue(value=165), ByteValue(value=81), ByteValue(value=167), ByteValue(value=49), ByteValue(value=39), ByteValue(value=211), ByteValue(value=8), ByteValue(value=226); 
DATA: ByteValue(value=22), ByteValue(value=100), ByteValue(value=44), ByteValue(value=4), ByteValue(value=56), ByteValue(value=66), ByteValue(value=118), ByteValue(value=100), ByteValue(value=136), ByteValue(value=98); 
DATA: ByteValue(value=222), ByteValue(value=7), ByteValue(value=254), ByteValue(value=1), ByteValue(value=13), ByteValue(value=201), ByteValue(value=35), ByteValue(value=50), ByteValue(value=49), ByteValue(value=81); 
DATA: ByteValue(value=152), ByteValue(value=82), ByteValue(value=13), ByteValue(value=201), ByteValue(value=89), ByteValue(value=66), ByteValue(value=99), ByteValue(value=83), ByteValue(value=103), ByteValue(value=49); 
DATA: ByteValue(value=20), ByteValue(value=194), ByteValue(value=54), ByteValue(value=49), ByteValue(value=135), ByteValue(value=83), ByteValue(value=23), ByteValue(value=227), ByteValue(value=41), ByteValue(value=97); 
DATA: ByteValue(value=48), ByteValue(value=98), ByteValue(value=60), ByteValue(value=8), ByteValue(value=66), ByteValue(value=55), ByteValue(value=89), ByteValue(value=64), ByteValue(value=106), ByteValue(value=66); 
DATA: ByteValue(value=153), ByteValue(value=64), ByteValue(value=201), ByteValue(value=97), ByteValue(value=215), ByteValue(value=99), ByteValue(value=57), ByteValue(value=209), ByteValue(value=88), ByteValue(value=82); 
DATA: ByteValue(value=195), ByteValue(value=103), ByteValue(value=211), ByteValue(value=49), ByteValue(value=220), ByteValue(value=6), ByteValue(value=247), ByteValue(value=66), ByteValue(value=250), ByteValue(value=66); 
DATA: ByteValue(value=35), ByteValue(value=177), ByteValue(value=67), ByteValue(value=103), ByteValue(value=195), ByteValue(value=52), ByteValue(value=199), ByteValue(value=52), ByteValue(value=209), ByteValue(value=81); 
DATA: ByteValue(value=67), ByteValue(value=179), ByteValue(value=71), ByteValue(value=51), ByteValue(value=154), ByteValue(value=48), ByteValue(value=169), ByteValue(value=97), ByteValue(value=184), ByteValue(value=98); 
DATA: ByteValue(value=190), ByteValue(value=11), ByteValue(value=213), ByteValue(value=9), ByteValue(value=222), ByteValue(value=15), ByteValue(value=13), ByteValue(value=202), ByteValue(value=125), ByteValue(value=71); 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; water area used in level 8-4                                        ; 
L_WaterArea3:                                                                                       ;  B
DATA: ByteValue(value=73), ByteValue(value=15)                                                      ; 
DATA: ByteValue(value=30), ByteValue(value=1), ByteValue(value=57), ByteValue(value=115), ByteValue(value=94), ByteValue(value=7), ByteValue(value=174), ByteValue(value=11), ByteValue(value=30), ByteValue(value=130); 
DATA: ByteValue(value=110), ByteValue(value=136), ByteValue(value=158), ByteValue(value=2), ByteValue(value=13), ByteValue(value=4), ByteValue(value=46), ByteValue(value=11), ByteValue(value=69), ByteValue(value=9); 
DATA: ByteValue(value=78), ByteValue(value=15), ByteValue(value=237), ByteValue(value=71)           ; 
DATA: ByteValue(value=253)                                                                          ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; unused space                                                        ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; indirect jump routine called when                                   ; 
                              ; $0770 is set to 1                                                   ; 
GameMode:                                                                                           ;  B
LDA OperMode_Task                                                                                   ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=InitializeArea)                                                                     ; 
DATA: Expr(expr=ScreenRoutines)                                                                     ; 
DATA: Expr(expr=SecondaryGameSetup)                                                                 ; 
DATA: Expr(expr=GameCoreRoutine)                                                                    ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GameCoreRoutine:                                                                                    ; fun():  B
LDX CurrentPlayer             ; get which player is on the screen                                   ; 
LDA SavedJoypadBits,X         ; use appropriate player's controller bits                            ; 
STA SavedJoypadBits           ; as the master controller bits                                       ; 
JSR GameRoutines              ; execute one of many possible subs                                   ; 
LDA OperMode_Task             ; check major task of operating mode                                  ; 
CMP #$03                      ; if we are supposed to be here,                                      ; 
BCS GameEngine                ; branch to the game engine itself                                    ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
GameEngine:                                                                                         ;  B
JSR ProcFireball_Bubble       ; process fireballs and air bubbles                                   ; 
LDX #$00                                                                                            ; 
ProcELoop:  STX ObjectOffset  ; put incremented offset in X as enemy object offset                  ;  B
JSR EnemiesAndLoopsCore       ; process enemy objects                                               ; 
JSR FloateyNumbersRoutine     ; process floatey numbers                                             ; 
INX                                                                                                 ; 
CPX #$06                      ; do these two subroutines until the whole buffer is done             ; 
BNE ProcELoop                                                                                       ; 
JSR GetPlayerOffscreenBits    ; get offscreen bits for player object                                ;  B
JSR RelativePlayerPosition    ; get relative coordinates for player object                          ; 
JSR PlayerGfxHandler          ; draw the player                                                     ; 
JSR BlockObjMT_Updater        ; replace block objects with metatiles if necessary                   ; 
LDX #$01                                                                                            ; 
STX ObjectOffset              ; set offset for second                                               ; 
JSR BlockObjectsCore          ; process second block object                                         ; 
DEX                                                                                                 ; 
STX ObjectOffset              ; set offset for first                                                ; 
JSR BlockObjectsCore          ; process first block object                                          ; 
JSR MiscObjectsCore           ; process misc objects (hammer, jumping coins)                        ; 
JSR ProcessCannons            ; process bullet bill cannons                                         ; 
JSR ProcessWhirlpools         ; process whirlpools                                                  ; 
JSR FlagpoleRoutine           ; process the flagpole                                                ; 
JSR RunGameTimer              ; count down the game timer                                           ; 
JSR ColorRotation             ; cycle one of the background colors                                  ; 
LDA Player_Y_HighPos                                                                                ; 
CMP #$02                      ; if player is below the screen, don't bother with the music          ; 
BPL NoChgMus                                                                                        ; 
LDA StarInvincibleTimer       ; if star mario invincibility timer at zero,                          ;  B
BEQ ClrPlrPal                 ; skip this part                                                      ; 
CMP #$04                                                                                            ;  B
BNE NoChgMus                  ; if not yet at a certain point, continue                             ; 
LDA IntervalTimerControl      ; if interval timer not yet expired,                                  ;  B
BNE NoChgMus                  ; branch ahead, don't bother with the music                           ; 
JSR GetAreaMusic              ; to re-attain appropriate level music                                ;  B
NoChgMus:  LDY StarInvincibleTimer; get invincibility timer                                         ;  B
LDA FrameCounter              ; get frame counter                                                   ; 
CPY #$08                      ; if timer still above certain point,                                 ; 
BCS CycleTwo                  ; branch to cycle player's palette quickly                            ; 
LSR                           ; otherwise, divide by 8 to cycle every eighth frame                  ;  B
LSR                                                                                                 ; 
CycleTwo:  LSR                ; if branched here, divide by 2 to cycle every other frame            ;  B
JSR CyclePlayerPalette        ; do sub to cycle the palette (note: shares fire flower code)         ; 
JMP SaveAB                    ; then skip this sub to finish up the game engine                     ; 
ClrPlrPal:  JSR ResetPalStar  ; do sub to clear player's palette bits in attributes                 ;  B
SaveAB:  LDA A_B_Buttons      ; save current A and B button                                         ;  B
STA PreviousA_B_Buttons       ; into temp variable to be used on next frame                         ; 
LDA #$00                                                                                            ; 
STA Left_Right_Buttons        ; nullify left and right buttons temp variable                        ; 
UpdScrollVar:  LDA VRAM_Buffer_AddrCtrl                                                             ; fun():  B
CMP #$06                      ; if vram address controller set to 6 (one of two $0341s)             ; 
BEQ ExitEng                   ; then branch to leave                                                ; 
LDA AreaParserTaskNum         ; otherwise check number of tasks                                     ;  B
BNE RunParser                                                                                       ; 
LDA ScrollThirtyTwo           ; get horizontal scroll in 0-31 or $00-$20 range                      ;  B
CMP #$20                      ; check to see if exceeded $21                                        ; 
BMI ExitEng                   ; branch to leave if not                                              ; 
LDA ScrollThirtyTwo                                                                                 ;  B
SBC #$20                      ; otherwise subtract $20 to set appropriately                         ; 
STA ScrollThirtyTwo           ; and store                                                           ; 
LDA #$00                      ; reset vram buffer offset used in conjunction with                   ; 
STA VRAM_Buffer2_Offset       ; level graphics buffer at $0341-$035f                                ; 
RunParser:  JSR AreaParserTaskHandler; update the name table with more level graphics               ;  B
ExitEng:  RTS                 ; and after all that, we're finally done!                             ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
ScrollHandler:                                                                                      ; fun():  B
LDA Player_X_Scroll           ; load value saved here                                               ; 
CLC                                                                                                 ; 
ADC Platform_X_Scroll         ; add value used by left/right platforms                              ; 
STA Player_X_Scroll           ; save as new value here to impose force on scroll                    ; 
LDA ScrollLock                ; check scroll lock flag                                              ; 
BNE InitScrlAmt               ; skip a bunch of code here if set                                    ; 
LDA Player_Pos_ForScroll                                                                            ;  B
CMP #$50                      ; check player's horizontal screen position                           ; 
BCC InitScrlAmt               ; if less than 80 pixels to the right, branch                         ; 
LDA SideCollisionTimer        ; if timer related to player's side collision                         ;  B
BNE InitScrlAmt               ; not expired, branch                                                 ; 
LDY Player_X_Scroll           ; get value and decrement by one                                      ;  B
DEY                           ; if value originally set to zero or otherwise                        ; 
BMI InitScrlAmt               ; negative for left movement, branch                                  ; 
INY                                                                                                 ;  B
CPY #$02                      ; if value $01, branch and do not decrement                           ; 
BCC ChkNearMid                                                                                      ; 
DEY                           ; otherwise decrement by one                                          ;  B
ChkNearMid:  LDA Player_Pos_ForScroll                                                               ;  B
CMP #$70                      ; check player's horizontal screen position                           ; 
BCC ScrollScreen              ; if less than 112 pixels to the right, branch                        ; 
LDY Player_X_Scroll           ; otherwise get original value undecremented                          ;  B
                                                                                                    ; 
ScrollScreen:                                                                                       ; fun(Y):  B
TYA                                                                                                 ; 
STA ScrollAmount              ; save value here                                                     ; 
CLC                                                                                                 ; 
ADC ScrollThirtyTwo           ; add to value already set here                                       ; 
STA ScrollThirtyTwo           ; save as new value here                                              ; 
TYA                                                                                                 ; 
CLC                                                                                                 ; 
ADC ScreenLeft_X_Pos          ; add to left side coordinate                                         ; 
STA ScreenLeft_X_Pos          ; save as new left side coordinate                                    ; 
STA HorizontalScroll          ; save here also                                                      ; 
LDA ScreenLeft_PageLoc                                                                              ; 
ADC #$00                      ; add carry to page location for left                                 ; 
STA ScreenLeft_PageLoc        ; side of the screen                                                  ; 
AND #$01                      ; get LSB of page location                                            ; 
STA $00                       ; save as temp variable for PPU register 1 mirror                     ; 
LDA Mirror_PPU_CTRL_REG1      ; get PPU register 1 mirror                                           ; 
AND #%11111110                ; save all bits except d0                                             ; 
ORA $00                       ; get saved bit here and save in PPU register 1                       ; 
STA Mirror_PPU_CTRL_REG1      ; mirror to be used to set name table later                           ; 
JSR GetScreenPosition         ; figure out where the right side is                                  ; 
LDA #$08                                                                                            ; 
STA ScrollIntervalTimer       ; set scroll timer (residual, not used elsewhere)                     ; 
JMP ChkPOffscr                ; skip this part                                                      ; 
InitScrlAmt:  LDA #$00                                                                              ;  B
STA ScrollAmount              ; initialize value here                                               ; 
ChkPOffscr:  LDX #$00         ; set X for player offset                                             ;  B
JSR GetXOffscreenBits         ; get horizontal offscreen bits for player                            ; 
STA $00                       ; save them here                                                      ; 
LDY #$00                      ; load default offset (left side)                                     ; 
ASL                           ; if d7 of offscreen bits are set,                                    ; 
BCS KeepOnscr                 ; branch with default offset                                          ; 
INY                           ; otherwise use different offset (right side)                         ;  B
LDA $00                                                                                             ; 
AND #%00100000                ; check offscreen bits for d5 set                                     ; 
BEQ InitPlatScrl              ; if not set, branch ahead of this part                               ; 
KeepOnscr:  LDA ScreenEdge_X_Pos,Y; get left or right side coordinate based on offset               ;  B
SEC                                                                                                 ; 
SBC X_SubtracterData,Y        ; subtract amount based on offset                                     ; 
STA Player_X_Position         ; store as player position to prevent movement further                ; 
LDA ScreenEdge_PageLoc,Y      ; get left or right page location based on offset                     ; 
SBC #$00                      ; subtract borrow                                                     ; 
STA Player_PageLoc            ; save as player's page location                                      ; 
LDA Left_Right_Buttons        ; check saved controller bits                                         ; 
CMP OffscrJoypadBitsData,Y    ; against bits based on offset                                        ; 
BEQ InitPlatScrl              ; if not equal, branch                                                ; 
LDA #$00                                                                                            ;  B
STA Player_X_Speed            ; otherwise nullify horizontal speed of player                        ; 
InitPlatScrl:  LDA #$00       ; nullify platform force imposed on scroll                            ;  B
STA Platform_X_Scroll                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
X_SubtracterData:                                                                                   ;  B
DATA: ByteValue(value=0), ByteValue(value=16)                                                       ; 
                                                                                                    ; 
OffscrJoypadBitsData:                                                                               ;  B
DATA: ByteValue(value=1), ByteValue(value=2)                                                        ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GetScreenPosition:                                                                                  ; fun(): A B
LDA ScreenLeft_X_Pos          ; get coordinate of screen's left boundary                            ; 
CLC                                                                                                 ; 
ADC #$ff                      ; add 255 pixels                                                      ; 
STA ScreenRight_X_Pos         ; store as coordinate of screen's right boundary                      ; 
LDA ScreenLeft_PageLoc        ; get page number where left boundary is                              ; 
ADC #$00                      ; add carry from before                                               ; 
STA ScreenRight_PageLoc       ; store as page number where right boundary is                        ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GameRoutines:                                                                                       ; fun():  B
LDA GameEngineSubroutine      ; run routine based on number (a few of these routines are            ; 
JSR JumpEngine                ; merely placeholders as conditions for other routines)               ; 
                                                                                                    ; 
DATA: Expr(expr=Entrance_GameTimerSetup)                                                            ; 
DATA: Expr(expr=Vine_AutoClimb)                                                                     ; 
DATA: Expr(expr=SideExitPipeEntry)                                                                  ; 
DATA: Expr(expr=VerticalPipeEntry)                                                                  ; 
DATA: Expr(expr=FlagpoleSlide)                                                                      ; 
DATA: Expr(expr=PlayerEndLevel)                                                                     ; 
DATA: Expr(expr=PlayerLoseLife)                                                                     ; 
DATA: Expr(expr=PlayerEntrance)                                                                     ; 
DATA: Expr(expr=PlayerCtrlRoutine)                                                                  ; 
DATA: Expr(expr=PlayerChangeSize)                                                                   ; 
DATA: Expr(expr=PlayerInjuryBlink)                                                                  ; 
DATA: Expr(expr=PlayerDeath)                                                                        ; 
DATA: Expr(expr=PlayerFireFlower)                                                                   ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerEntrance:                                                                                     ;  B
LDA AltEntranceControl        ; check for mode of alternate entry                                   ; 
CMP #$02                                                                                            ; 
BEQ EntrMode2                 ; if found, branch to enter from pipe or with vine                    ; 
LDA #$00                                                                                            ;  B
LDY Player_Y_Position         ; if vertical position above a certain                                ; 
CPY #$30                      ; point, nullify controller bits and continue                         ; 
BCC AutoControlPlayer         ; with player movement code, do not return                            ; 
LDA PlayerEntranceCtrl        ; check player entry bits from header                                 ;  B
CMP #$06                                                                                            ; 
BEQ ChkBehPipe                ; if set to 6 or 7, execute pipe intro code                           ; 
CMP #$07                      ; otherwise branch to normal entry                                    ;  B
BNE PlayerRdy                                                                                       ; 
ChkBehPipe:  LDA Player_SprAttrib; check for sprite attributes                                      ;  B
BNE IntroEntr                 ; branch if found                                                     ; 
LDA #$01                                                                                            ;  B
JMP AutoControlPlayer         ; force player to walk to the right                                   ; 
IntroEntr:  JSR EnterSidePipe ; execute sub to move player to the right                             ;  B
DEC ChangeAreaTimer           ; decrement timer for change of area                                  ; 
BNE ExitEntr                  ; branch to exit if not yet expired                                   ; 
INC DisableIntermediate       ; set flag to skip world and lives display                            ;  B
JMP NextArea                  ; jump to increment to next area and set modes                        ; 
EntrMode2:  LDA JoypadOverride; if controller override bits set here,                               ;  B
BNE VineEntr                  ; branch to enter with vine                                           ; 
LDA #$ff                      ; otherwise, set value here then execute sub                          ;  B
JSR MovePlayerYAxis           ; to move player upwards (note $ff = -1)                              ; 
LDA Player_Y_Position         ; check to see if player is at a specific coordinate                  ; 
CMP #$91                      ; if player risen to a certain point (this requires pipes             ; 
BCC PlayerRdy                 ; to be at specific height to look/function right) branch             ; 
RTS                           ; to the last part, otherwise leave                                   ;  B
VineEntr:  LDA VineHeight                                                                           ;  B
CMP #$60                      ; check vine height                                                   ; 
BNE ExitEntr                  ; if vine not yet reached maximum height, branch to leave             ; 
LDA Player_Y_Position         ; get player's vertical coordinate                                    ;  B
CMP #$99                      ; check player's vertical coordinate against preset value             ; 
LDY #$00                      ; load default values to be written to                                ; 
LDA #$01                      ; this value moves player to the right off the vine                   ; 
BCC OffVine                   ; if vertical coordinate < preset value, use defaults                 ; 
LDA #$03                                                                                            ;  B
STA Player_State              ; otherwise set player state to climbing                              ; 
INY                           ; increment value in Y                                                ; 
LDA #$08                      ; set block in block buffer to cover hole, then                       ; 
                              ; use same value to force player to climb                             ; 
OffVine:  STY DisableCollisionDet; set collision detection disable flag                             ;  B
JSR AutoControlPlayer         ; use contents of A to move player up or right, execute sub           ; 
LDA Player_X_Position                                                                               ; 
CMP #$48                      ; check player's horizontal position                                  ; 
BCC ExitEntr                  ; if not far enough to the right, branch to leave                     ; 
PlayerRdy:  LDA #$08          ; set routine to be executed by game engine next frame                ;  B
STA GameEngineSubroutine                                                                            ; 
LDA #$01                      ; set to face player to the right                                     ; 
STA PlayerFacingDir                                                                                 ; 
LSR                           ; init A                                                              ; 
STA AltEntranceControl        ; init mode of entry                                                  ; 
STA DisableCollisionDet       ; init collision detection disable flag                               ; 
STA JoypadOverride            ; nullify controller override bits                                    ; 
ExitEntr:  RTS                ; leave!                                                              ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $07 - used to hold upper limit of high byte when player falls down hole; 
                                                                                                    ; 
AutoControlPlayer:                                                                                  ; fun(A):  B
STA SavedJoypadBits           ; override controller bits with contents of A if executing here       ; 
                                                                                                    ; 
PlayerCtrlRoutine:                                                                                  ;  B
LDA GameEngineSubroutine      ; check task here                                                     ; 
CMP #$0b                      ; if certain value is set, branch to skip controller bit loading      ; 
BEQ SizeChk                                                                                         ; 
LDA AreaType                  ; are we in a water type area?                                        ;  B
BNE SaveJoyp                  ; if not, branch                                                      ; 
LDY Player_Y_HighPos                                                                                ;  B
DEY                           ; if not in vertical area between                                     ; 
BNE DisJoyp                   ; status bar and bottom, branch                                       ; 
LDA Player_Y_Position                                                                               ;  B
CMP #$d0                      ; if nearing the bottom of the screen or                              ; 
BCC SaveJoyp                  ; not in the vertical area between status bar or bottom,              ; 
DisJoyp:  LDA #$00            ; disable controller bits                                             ;  B
STA SavedJoypadBits                                                                                 ; 
SaveJoyp:  LDA SavedJoypadBits; otherwise store A and B buttons in $0a                              ;  B
AND #%11000000                                                                                      ; 
STA A_B_Buttons                                                                                     ; 
LDA SavedJoypadBits           ; store left and right buttons in $0c                                 ; 
AND #%00000011                                                                                      ; 
STA Left_Right_Buttons                                                                              ; 
LDA SavedJoypadBits           ; store up and down buttons in $0b                                    ; 
AND #%00001100                                                                                      ; 
STA Up_Down_Buttons                                                                                 ; 
AND #%00000100                ; check for pressing down                                             ; 
BEQ SizeChk                   ; if not, branch                                                      ; 
LDA Player_State              ; check player's state                                                ;  B
BNE SizeChk                   ; if not on the ground, branch                                        ; 
LDY Left_Right_Buttons        ; check left and right                                                ;  B
BEQ SizeChk                   ; if neither pressed, branch                                          ; 
LDA #$00                                                                                            ;  B
STA Left_Right_Buttons        ; if pressing down while on the ground,                               ; 
STA Up_Down_Buttons           ; nullify directional bits                                            ; 
SizeChk:  JSR PlayerMovementSubs; run movement subroutines                                          ;  B
LDY #$01                      ; is player small?                                                    ; 
LDA PlayerSize                                                                                      ; 
BNE ChkMoveDir                                                                                      ; 
LDY #$00                      ; check for if crouching                                              ;  B
LDA CrouchingFlag                                                                                   ; 
BEQ ChkMoveDir                ; if not, branch ahead                                                ; 
LDY #$02                      ; if big and crouching, load y with 2                                 ;  B
ChkMoveDir:  STY Player_BoundBoxCtrl; set contents of Y as player's bounding box size control       ;  B
LDA #$01                      ; set moving direction to right by default                            ; 
LDY Player_X_Speed            ; check player's horizontal speed                                     ; 
BEQ PlayerSubs                ; if not moving at all horizontally, skip this part                   ; 
BPL SetMoveDir                ; if moving to the right, use default moving direction                ;  B
ASL                           ; otherwise change to move to the left                                ;  B
SetMoveDir:  STA Player_MovingDir; set moving direction                                             ;  B
PlayerSubs:  JSR ScrollHandler; move the screen if necessary                                        ;  B
JSR GetPlayerOffscreenBits    ; get player's offscreen bits                                         ; 
JSR RelativePlayerPosition    ; get coordinates relative to the screen                              ; 
LDX #$00                      ; set offset for player object                                        ; 
JSR BoundingBoxCore           ; get player's bounding box coordinates                               ; 
JSR PlayerBGCollision         ; do collision detection and process                                  ; 
LDA Player_Y_Position                                                                               ; 
CMP #$40                      ; check to see if player is higher than 64th pixel                    ; 
BCC PlayerHole                ; if so, branch ahead                                                 ; 
LDA GameEngineSubroutine                                                                            ;  B
CMP #$05                      ; if running end-of-level routine, branch ahead                       ; 
BEQ PlayerHole                                                                                      ; 
CMP #$07                      ; if running player entrance routine, branch ahead                    ;  B
BEQ PlayerHole                                                                                      ; 
CMP #$04                      ; if running routines $00-$03, branch ahead                           ;  B
BCC PlayerHole                                                                                      ; 
LDA Player_SprAttrib                                                                                ;  B
AND #%11011111                ; otherwise nullify player's                                          ; 
STA Player_SprAttrib          ; background priority flag                                            ; 
PlayerHole:  LDA Player_Y_HighPos; check player's vertical high byte                                ;  B
CMP #$02                      ; for below the screen                                                ; 
BMI ExitCtrl                  ; branch to leave if not that far down                                ; 
LDX #$01                                                                                            ;  B
STX ScrollLock                ; set scroll lock                                                     ; 
LDY #$04                                                                                            ; 
STY $07                       ; set value here                                                      ; 
LDX #$00                      ; use X as flag, and clear for cloud level                            ; 
LDY GameTimerExpiredFlag      ; check game timer expiration flag                                    ; 
BNE HoleDie                   ; if set, branch                                                      ; 
LDY CloudTypeOverride         ; check for cloud type override                                       ;  B
BNE ChkHoleX                  ; skip to last part if found                                          ; 
HoleDie:  INX                 ; set flag in X for player death                                      ;  B
LDY GameEngineSubroutine                                                                            ; 
CPY #$0b                      ; check for some other routine running                                ; 
BEQ ChkHoleX                  ; if so, branch ahead                                                 ; 
LDY DeathMusicLoaded          ; check value here                                                    ;  B
BNE HoleBottom                ; if already set, branch to next part                                 ; 
INY                                                                                                 ;  B
STY EventMusicQueue           ; otherwise play death music                                          ; 
STY DeathMusicLoaded          ; and set value here                                                  ; 
HoleBottom:  LDY #$06                                                                               ;  B
STY $07                       ; change value here                                                   ; 
ChkHoleX:  CMP $07            ; compare vertical high byte with value set here                      ;  B
BMI ExitCtrl                  ; if less, branch to leave                                            ; 
DEX                           ; otherwise decrement flag in X                                       ;  B
BMI CloudExit                 ; if flag was clear, branch to set modes and other values             ; 
LDY EventMusicBuffer          ; check to see if music is still playing                              ;  B
BNE ExitCtrl                  ; branch to leave if so                                               ; 
LDA #$06                      ; otherwise set to run lose life routine                              ;  B
STA GameEngineSubroutine      ; on next frame                                                       ; 
ExitCtrl:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
CloudExit:                                                                                          ;  B
LDA #$00                                                                                            ; 
STA JoypadOverride            ; clear controller override bits if any are set                       ; 
JSR SetEntr                   ; do sub to set secondary mode                                        ; 
INC AltEntranceControl        ; set mode of entry to 3                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
Vine_AutoClimb:                                                                                     ;  B
LDA Player_Y_HighPos          ; check to see whether player reached position                        ; 
BNE AutoClimb                 ; above the status bar yet and if so, set modes                       ; 
LDA Player_Y_Position                                                                               ;  B
CMP #$e4                                                                                            ; 
BCC SetEntr                                                                                         ; 
AutoClimb:  LDA #%00001000    ; set controller bits override to up                                  ;  B
STA JoypadOverride                                                                                  ; 
LDY #$03                      ; set player state to climbing                                        ; 
STY Player_State                                                                                    ; 
JMP AutoControlPlayer                                                                               ; 
SetEntr:  LDA #$02            ; set starting position to override                                   ; fun():  B
STA AltEntranceControl                                                                              ; 
JMP ChgAreaMode               ; set modes                                                           ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
VerticalPipeEntry:                                                                                  ;  B
LDA #$01                      ; set 1 as movement amount                                            ; 
JSR MovePlayerYAxis           ; do sub to move player downwards                                     ; 
JSR ScrollHandler             ; do sub to scroll screen with saved force if necessary               ; 
LDY #$00                      ; load default mode of entry                                          ; 
LDA WarpZoneControl           ; check warp zone control variable/flag                               ; 
BNE ChgAreaPipe               ; if set, branch to use mode 0                                        ; 
INY                                                                                                 ;  B
LDA AreaType                  ; check for castle level type                                         ; 
CMP #$03                                                                                            ; 
BNE ChgAreaPipe               ; if not castle type level, use mode 1                                ; 
INY                                                                                                 ;  B
JMP ChgAreaPipe               ; otherwise use mode 2                                                ; 
                                                                                                    ;  B
MovePlayerYAxis:                                                                                    ; fun(A):  B
CLC                                                                                                 ; 
ADC Player_Y_Position         ; add contents of A to player position                                ; 
STA Player_Y_Position                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
SideExitPipeEntry:                                                                                  ;  B
JSR EnterSidePipe             ; execute sub to move player to the right                             ; 
LDY #$02                                                                                            ; 
ChgAreaPipe:  DEC ChangeAreaTimer; decrement timer for change of area                               ;  B
BNE ExitCAPipe                                                                                      ; 
STY AltEntranceControl        ; when timer expires set mode of alternate entry                      ;  B
ChgAreaMode:  INC DisableScreenFlag; set flag to disable screen output                              ; fun(): A B
LDA #$00                                                                                            ; 
STA OperMode_Task             ; set secondary mode of operation                                     ; 
STA Sprite0HitDetectFlag      ; disable sprite 0 check                                              ; 
ExitCAPipe:  RTS              ; leave                                                               ;  B
                                                                                                    ;  B
EnterSidePipe:                                                                                      ; fun():  B
LDA #$08                      ; set player's horizontal speed                                       ; 
STA Player_X_Speed                                                                                  ; 
LDY #$01                      ; set controller right button by default                              ; 
LDA Player_X_Position         ; mask out higher nybble of player's                                  ; 
AND #%00001111                ; horizontal position                                                 ; 
BNE RightPipe                                                                                       ; 
STA Player_X_Speed            ; if lower nybble = 0, set as horizontal speed                        ;  B
TAY                           ; and nullify controller bit override here                            ; 
RightPipe:  TYA               ; use contents of Y to                                                ;  B
JSR AutoControlPlayer         ; execute player control routine with ctrl bits nulled                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerChangeSize:                                                                                   ;  B
LDA TimerControl              ; check master timer control                                          ; 
CMP #$f8                      ; for specific moment in time                                         ; 
BNE EndChgSize                ; branch if before or after that point                                ; 
JMP InitChangeSize            ; otherwise run code to get growing/shrinking going                   ;  B
EndChgSize:  CMP #$c4         ; check again for another specific moment                             ;  B
BNE ExitChgSize               ; and branch to leave if before or after that point                   ; 
JSR DonePlayerTask            ; otherwise do sub to init timer control and set routine              ;  B
ExitChgSize:  RTS             ; and then leave                                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerInjuryBlink:                                                                                  ;  B
LDA TimerControl              ; check master timer control                                          ; 
CMP #$f0                      ; for specific moment in time                                         ; 
BCS ExitBlink                 ; branch if before that point                                         ; 
CMP #$c8                      ; check again for another specific point                              ;  B
BEQ DonePlayerTask            ; branch if at that point, and not before or after                    ; 
JMP PlayerCtrlRoutine         ; otherwise run player control routine                                ;  B
ExitBlink:  BNE ExitBoth      ; do unconditional branch to leave                                    ;  B
                                                                                                    ;  B
InitChangeSize:                                                                                     ;  B
LDY PlayerChangeSizeFlag      ; if growing/shrinking flag already set                               ; 
BNE ExitBoth                  ; then branch to leave                                                ; 
STY PlayerAnimCtrl            ; otherwise initialize player's animation frame control               ;  B
INC PlayerChangeSizeFlag      ; set growing/shrinking flag                                          ; 
LDA PlayerSize                                                                                      ; 
EOR #$01                      ; invert player's size                                                ; 
STA PlayerSize                                                                                      ; 
ExitBoth:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used in CyclePlayerPalette to store current palette to cycle  ; 
                                                                                                    ; 
PlayerDeath:                                                                                        ;  B
LDA TimerControl              ; check master timer control                                          ; 
CMP #$f0                      ; for specific moment in time                                         ; 
BCS ExitDeath                 ; branch to leave if before that point                                ; 
JMP PlayerCtrlRoutine         ; otherwise run player control routine                                ;  B
                                                                                                    ;  B
DonePlayerTask:                                                                                     ; fun():  B
LDA #$00                                                                                            ; 
STA TimerControl              ; initialize master timer control to continue timers                  ; 
LDA #$08                                                                                            ; 
STA GameEngineSubroutine      ; set player control routine to run next frame                        ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
PlayerFireFlower:                                                                                   ;  B
LDA TimerControl              ; check master timer control                                          ; 
CMP #$c0                      ; for specific moment in time                                         ; 
BEQ ResetPalFireFlower        ; branch if at moment, not before or after                            ; 
LDA FrameCounter              ; get frame counter                                                   ;  B
LSR                                                                                                 ; 
LSR                           ; divide by four to change every four frames                          ; 
                                                                                                    ; 
CyclePlayerPalette:                                                                                 ; fun(A):  B
AND #$03                      ; mask out all but d1-d0 (previously d3-d2)                           ; 
STA $00                       ; store result here to use as palette bits                            ; 
LDA Player_SprAttrib          ; get player attributes                                               ; 
AND #%11111100                ; save any other bits but palette bits                                ; 
ORA $00                       ; add palette bits                                                    ; 
STA Player_SprAttrib          ; store as new player attributes                                      ; 
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
ResetPalFireFlower:                                                                                 ;  B
JSR DonePlayerTask            ; do sub to init timer control and run player control routine         ; 
                                                                                                    ; 
ResetPalStar:                                                                                       ; fun():  B
LDA Player_SprAttrib          ; get player attributes                                               ; 
AND #%11111100                ; mask out palette bits to force palette 0                            ; 
STA Player_SprAttrib          ; store as new player attributes                                      ; 
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
ExitDeath:                                                                                          ;  B
RTS                           ; leave from death routine                                            ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
FlagpoleSlide:                                                                                      ;  B
LDA Enemy_ID+5                ; check special use enemy slot                                        ; 
CMP #FlagpoleFlagObject       ; for flagpole flag object                                            ; 
BNE NoFPObj                   ; if not found, branch to something residual                          ; 
LDA FlagpoleSoundQueue        ; load flagpole sound                                                 ;  B
STA Square1SoundQueue         ; into square 1's sfx queue                                           ; 
LDA #$00                                                                                            ; 
STA FlagpoleSoundQueue        ; init flagpole sound queue                                           ; 
LDY Player_Y_Position                                                                               ; 
CPY #$9e                      ; check to see if player has slid down                                ; 
BCS SlidePlayer               ; far enough, and if so, branch with no controller bits set           ; 
LDA #$04                      ; otherwise force player to climb down (to slide)                     ;  B
SlidePlayer:  JMP AutoControlPlayer; jump to player control routine                                 ;  B
NoFPObj:  INC GameEngineSubroutine; increment to next routine (this may                             ;  B
RTS                           ; be residual code)                                                   ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
Hidden1UpCoinAmts:                                                                                  ;  B
DATA: ByteValue(value=21), ByteValue(value=35), ByteValue(value=22), ByteValue(value=27), ByteValue(value=23), ByteValue(value=24), ByteValue(value=35), ByteValue(value=99); 
                                                                                                    ; 
PlayerEndLevel:                                                                                     ;  B
LDA #$01                      ; force player to walk to the right                                   ; 
JSR AutoControlPlayer                                                                               ; 
LDA Player_Y_Position         ; check player's vertical position                                    ; 
CMP #$ae                                                                                            ; 
BCC ChkStop                   ; if player is not yet off the flagpole, skip this part               ; 
LDA ScrollLock                ; if scroll lock not set, branch ahead to next part                   ;  B
BEQ ChkStop                   ; because we only need to do this part once                           ; 
LDA #EndOfLevelMusic                                                                                ;  B
STA EventMusicQueue           ; load win level music in event music queue                           ; 
LDA #$00                                                                                            ; 
STA ScrollLock                ; turn off scroll lock to skip this part later                        ; 
ChkStop:  LDA Player_CollisionBits; get player collision bits                                       ;  B
LSR                           ; check for d0 set                                                    ; 
BCS RdyNextA                  ; if d0 set, skip to next part                                        ; 
LDA StarFlagTaskControl       ; if star flag task control already set,                              ;  B
BNE InCastle                  ; go ahead with the rest of the code                                  ; 
INC StarFlagTaskControl       ; otherwise set task control now (this gets ball rolling!)            ;  B
InCastle:  LDA #%00100000     ; set player's background priority bit to                             ;  B
STA Player_SprAttrib          ; give illusion of being inside the castle                            ; 
RdyNextA:  LDA StarFlagTaskControl                                                                  ;  B
CMP #$05                      ; if star flag task control not yet set                               ; 
BNE ExitNA                    ; beyond last valid task number, branch to leave                      ; 
INC LevelNumber               ; increment level number used for game logic                          ;  B
LDA LevelNumber                                                                                     ; 
CMP #$03                      ; check to see if we have yet reached level -4                        ; 
BNE NextArea                  ; and skip this last part here if not                                 ; 
LDY WorldNumber               ; get world number as offset                                          ;  B
LDA CoinTallyFor1Ups          ; check third area coin tally for bonus 1-ups                         ; 
CMP Hidden1UpCoinAmts,Y       ; against minimum value, if player has not collected                  ; 
BCC NextArea                  ; at least this number of coins, leave flag clear                     ; 
INC Hidden1UpFlag             ; otherwise set hidden 1-up box control flag                          ;  B
NextArea:  INC AreaNumber     ; increment area number used for address loader                       ;  B
JSR LoadAreaPointer           ; get new level pointer                                               ; 
INC FetchNewGameTimerFlag     ; set flag to load new game timer                                     ; 
JSR ChgAreaMode               ; do sub to set secondary mode, disable screen and sprite 0           ; 
STA HalfwayPage               ; reset halfway page to 0 (beginning)                                 ; 
LDA #Silence                                                                                        ; 
STA EventMusicQueue           ; silence music and leave                                             ; 
ExitNA:  RTS                                                                                        ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerMovementSubs:                                                                                 ; fun():  B
LDA #$00                      ; set A to init crouch flag by default                                ; 
LDY PlayerSize                ; is player small?                                                    ; 
BNE SetCrouch                 ; if so, branch                                                       ; 
LDA Player_State              ; check state of player                                               ;  B
BNE ProcMove                  ; if not on the ground, branch                                        ; 
LDA Up_Down_Buttons           ; load controller bits for up and down                                ;  B
AND #%00000100                ; single out bit for down button                                      ; 
SetCrouch:  STA CrouchingFlag ; store value in crouch flag                                          ;  B
ProcMove:  JSR PlayerPhysicsSub; run sub related to jumping and swimming                            ;  B
LDA PlayerChangeSizeFlag      ; if growing/shrinking flag set,                                      ; 
BNE NoMoveSub                 ; branch to leave                                                     ; 
LDA Player_State                                                                                    ;  B
CMP #$03                      ; get player state                                                    ; 
BEQ MoveSubs                  ; if climbing, branch ahead, leave timer unset                        ; 
LDY #$18                                                                                            ;  B
STY ClimbSideTimer            ; otherwise reset timer now                                           ; 
MoveSubs:  JSR JumpEngine                                                                           ;  B
                                                                                                    ; 
DATA: Expr(expr=OnGroundStateSub)                                                                   ; 
DATA: Expr(expr=JumpSwimSub)                                                                        ; 
DATA: Expr(expr=FallingSub)                                                                         ; 
DATA: Expr(expr=ClimbingSub)                                                                        ; 
                                                                                                    ; 
NoMoveSub:  RTS                                                                                     ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used by ClimbingSub to store high vertical adder              ; 
                                                                                                    ; 
OnGroundStateSub:                                                                                   ;  B
JSR GetPlayerAnimSpeed        ; do a sub to set animation frame timing                              ; 
LDA Left_Right_Buttons                                                                              ; 
BEQ GndMove                   ; if left/right controller bits not set, skip instruction             ; 
STA PlayerFacingDir           ; otherwise set new facing direction                                  ;  B
GndMove:  JSR ImposeFriction  ; do a sub to impose friction on player's walk/run                    ;  B
JSR MovePlayerHorizontally    ; do another sub to move player horizontally                          ; 
STA Player_X_Scroll           ; set returned value as player's movement speed for scroll            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FallingSub:                                                                                         ;  B
LDA VerticalForceDown                                                                               ; 
STA VerticalForce             ; dump vertical movement force for falling into main one              ; 
JMP LRAir                     ; movement force, then skip ahead to process left/right movement      ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
JumpSwimSub:                                                                                        ;  B
LDY Player_Y_Speed            ; if player's vertical speed zero                                     ; 
BPL DumpFall                  ; or moving downwards, branch to falling                              ; 
LDA A_B_Buttons                                                                                     ;  B
AND #A_Button                 ; check to see if A button is being pressed                           ; 
AND PreviousA_B_Buttons       ; and was pressed in previous frame                                   ; 
BNE ProcSwim                  ; if so, branch elsewhere                                             ; 
LDA JumpOrigin_Y_Position     ; get vertical position player jumped from                            ;  B
SEC                                                                                                 ; 
SBC Player_Y_Position         ; subtract current from original vertical coordinate                  ; 
CMP DiffToHaltJump            ; compare to value set here to see if player is in mid-jump           ; 
BCC ProcSwim                  ; or just starting to jump, if just starting, skip ahead              ; 
DumpFall:  LDA VerticalForceDown; otherwise dump falling into main fractional                       ;  B
STA VerticalForce                                                                                   ; 
ProcSwim:  LDA SwimmingFlag   ; if swimming flag not set,                                           ;  B
BEQ LRAir                     ; branch ahead to last part                                           ; 
JSR GetPlayerAnimSpeed        ; do a sub to get animation frame timing                              ;  B
LDA Player_Y_Position                                                                               ; 
CMP #$14                      ; check vertical position against preset value                        ; 
BCS LRWater                   ; if not yet reached a certain position, branch ahead                 ; 
LDA #$18                                                                                            ;  B
STA VerticalForce             ; otherwise set fractional                                            ; 
LRWater:  LDA Left_Right_Buttons; check left/right controller bits (check for swimming)             ;  B
BEQ LRAir                     ; if not pressing any, skip                                           ; 
STA PlayerFacingDir           ; otherwise set facing direction accordingly                          ;  B
LRAir:  LDA Left_Right_Buttons; check left/right controller bits (check for jumping/falling)        ;  B
BEQ JSMove                    ; if not pressing any, skip                                           ; 
JSR ImposeFriction            ; otherwise process horizontal movement                               ;  B
JSMove:  JSR MovePlayerHorizontally; do a sub to move player horizontally                           ;  B
STA Player_X_Scroll           ; set player's speed here, to be used for scroll later                ; 
LDA GameEngineSubroutine                                                                            ; 
CMP #$0b                      ; check for specific routine selected                                 ; 
BNE ExitMov1                  ; branch if not set to run                                            ; 
LDA #$28                                                                                            ;  B
STA VerticalForce             ; otherwise set fractional                                            ; 
ExitMov1:  JMP MovePlayerVertically; jump to move player vertically, then leave                     ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ClimbAdderLow:                                                                                      ;  B
DATA: ByteValue(value=14), ByteValue(value=4), ByteValue(value=252), ByteValue(value=242)           ; 
ClimbAdderHigh:                                                                                     ;  B
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=255), ByteValue(value=255)            ; 
                                                                                                    ; 
ClimbingSub:                                                                                        ;  B
LDA Player_YMF_Dummy                                                                                ; 
CLC                           ; add movement force to dummy variable                                ; 
ADC Player_Y_MoveForce        ; save with carry                                                     ; 
STA Player_YMF_Dummy                                                                                ; 
LDY #$00                      ; set default adder here                                              ; 
LDA Player_Y_Speed            ; get player's vertical speed                                         ; 
BPL MoveOnVine                ; if not moving upwards, branch                                       ; 
DEY                           ; otherwise set adder to $ff                                          ;  B
MoveOnVine:  STY $00          ; store adder here                                                    ;  B
ADC Player_Y_Position         ; add carry to player's vertical position                             ; 
STA Player_Y_Position         ; and store to move player up or down                                 ; 
LDA Player_Y_HighPos                                                                                ; 
ADC $00                       ; add carry to player's page location                                 ; 
STA Player_Y_HighPos          ; and store                                                           ; 
LDA Left_Right_Buttons        ; compare left/right controller bits                                  ; 
AND Player_CollisionBits      ; to collision flag                                                   ; 
BEQ InitCSTimer               ; if not set, skip to end                                             ; 
LDY ClimbSideTimer            ; otherwise check timer                                               ;  B
BNE ExitCSub                  ; if timer not expired, branch to leave                               ; 
LDY #$18                                                                                            ;  B
STY ClimbSideTimer            ; otherwise set timer now                                             ; 
LDX #$00                      ; set default offset here                                             ; 
LDY PlayerFacingDir           ; get facing direction                                                ; 
LSR                           ; move right button controller bit to carry                           ; 
BCS ClimbFD                   ; if controller right pressed, branch ahead                           ; 
INX                                                                                                 ;  B
INX                           ; otherwise increment offset by 2 bytes                               ; 
ClimbFD:  DEY                 ; check to see if facing right                                        ;  B
BEQ CSetFDir                  ; if so, branch, do not increment                                     ; 
INX                           ; otherwise increment by 1 byte                                       ;  B
CSetFDir:  LDA Player_X_Position                                                                    ;  B
CLC                           ; add or subtract from player's horizontal position                   ; 
ADC ClimbAdderLow,X           ; using value here as adder and X as offset                           ; 
STA Player_X_Position                                                                               ; 
LDA Player_PageLoc            ; add or subtract carry or borrow using value here                    ; 
ADC ClimbAdderHigh,X          ; from the player's page location                                     ; 
STA Player_PageLoc                                                                                  ; 
LDA Left_Right_Buttons        ; get left/right controller bits again                                ; 
EOR #%00000011                ; invert them and store them while player                             ; 
STA PlayerFacingDir           ; is on vine to face player in opposite direction                     ; 
ExitCSub:  RTS                ; then leave                                                          ;  B
InitCSTimer:  STA ClimbSideTimer; initialize timer here                                             ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to store offset to friction data                         ; 
                                                                                                    ; 
JumpMForceData:                                                                                     ;  B
DATA: ByteValue(value=32), ByteValue(value=32), ByteValue(value=30), ByteValue(value=40), ByteValue(value=40), ByteValue(value=13), ByteValue(value=4); 
                                                                                                    ; 
FallMForceData:                                                                                     ;  B
DATA: ByteValue(value=112), ByteValue(value=112), ByteValue(value=96), ByteValue(value=144), ByteValue(value=144), ByteValue(value=10), ByteValue(value=9); 
                                                                                                    ; 
PlayerYSpdData:                                                                                     ;  B
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=251), ByteValue(value=251), ByteValue(value=254), ByteValue(value=255); 
                                                                                                    ; 
InitMForceData:                                                                                     ;  B
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=0), ByteValue(value=128), ByteValue(value=0); 
                                                                                                    ; 
MaxLeftXSpdData:                                                                                    ;  B
DATA: ByteValue(value=216), ByteValue(value=232), ByteValue(value=240)                              ; 
                                                                                                    ; 
MaxRightXSpdData:                                                                                   ;  B
DATA: ByteValue(value=40), ByteValue(value=24), ByteValue(value=16)                                 ; 
DATA: ByteValue(value=12)     ; used for pipe intros                                                ; 
                                                                                                    ; 
FrictionData:                                                                                       ;  B
DATA: ByteValue(value=228), ByteValue(value=152), ByteValue(value=208)                              ; 
                                                                                                    ; 
Climb_Y_SpeedData:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=255), ByteValue(value=1)                                  ; 
                                                                                                    ; 
Climb_Y_MForceData:                                                                                 ;  B
DATA: ByteValue(value=0), ByteValue(value=32), ByteValue(value=255)                                 ; 
                                                                                                    ; 
PlayerPhysicsSub:                                                                                   ; fun():  B
LDA Player_State              ; check player state                                                  ; 
CMP #$03                                                                                            ; 
BNE CheckForJumping           ; if not climbing, branch                                             ; 
LDY #$00                                                                                            ;  B
LDA Up_Down_Buttons           ; get controller bits for up/down                                     ; 
AND Player_CollisionBits      ; check against player's collision detection bits                     ; 
BEQ ProcClimb                 ; if not pressing up or down, branch                                  ; 
INY                                                                                                 ;  B
AND #%00001000                ; check for pressing up                                               ; 
BNE ProcClimb                                                                                       ; 
INY                                                                                                 ;  B
ProcClimb:  LDX Climb_Y_MForceData,Y; load value here                                               ;  B
STX Player_Y_MoveForce        ; store as vertical movement force                                    ; 
LDA #$08                      ; load default animation timing                                       ; 
LDX Climb_Y_SpeedData,Y       ; load some other value here                                          ; 
STX Player_Y_Speed            ; store as vertical speed                                             ; 
BMI SetCAnim                  ; if climbing down, use default animation timing value                ; 
LSR                           ; otherwise divide timer setting by 2                                 ;  B
SetCAnim:  STA PlayerAnimTimerSet; store animation timer setting and leave                          ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
CheckForJumping:                                                                                    ;  B
LDA JumpspringAnimCtrl        ; if jumpspring animating,                                            ; 
BNE NoJump                    ; skip ahead to something else                                        ; 
LDA A_B_Buttons               ; check for A button press                                            ;  B
AND #A_Button                                                                                       ; 
BEQ NoJump                    ; if not, branch to something else                                    ; 
AND PreviousA_B_Buttons       ; if button not pressed in previous frame, branch                     ;  B
BEQ ProcJumping                                                                                     ; 
NoJump:  JMP X_Physics        ; otherwise, jump to something else                                   ;  B
                                                                                                    ;  B
ProcJumping:                                                                                        ;  B
LDA Player_State              ; check player state                                                  ; 
BEQ InitJS                    ; if on the ground, branch                                            ; 
LDA SwimmingFlag              ; if swimming flag not set, jump to do something else                 ;  B
BEQ NoJump                    ; to prevent midair jumping, otherwise continue                       ; 
LDA JumpSwimTimer             ; if jump/swim timer nonzero, branch                                  ;  B
BNE InitJS                                                                                          ; 
LDA Player_Y_Speed            ; check player's vertical speed                                       ;  B
BPL InitJS                    ; if player's vertical speed motionless or down, branch               ; 
JMP X_Physics                 ; if timer at zero and player still rising, do not swim               ;  B
InitJS:  LDA #$20             ; set jump/swim timer                                                 ;  B
STA JumpSwimTimer                                                                                   ; 
LDY #$00                      ; initialize vertical force and dummy variable                        ; 
STY Player_YMF_Dummy                                                                                ; 
STY Player_Y_MoveForce                                                                              ; 
LDA Player_Y_HighPos          ; get vertical high and low bytes of jump origin                      ; 
STA JumpOrigin_Y_HighPos      ; and store them next to each other here                              ; 
LDA Player_Y_Position                                                                               ; 
STA JumpOrigin_Y_Position                                                                           ; 
LDA #$01                      ; set player state to jumping/swimming                                ; 
STA Player_State                                                                                    ; 
LDA Player_XSpeedAbsolute     ; check value related to walking/running speed                        ; 
CMP #$09                                                                                            ; 
BCC ChkWtr                    ; branch if below certain values, increment Y                         ; 
INY                           ; for each amount equal or exceeded                                   ;  B
CMP #$10                                                                                            ; 
BCC ChkWtr                                                                                          ; 
INY                                                                                                 ;  B
CMP #$19                                                                                            ; 
BCC ChkWtr                                                                                          ; 
INY                                                                                                 ;  B
CMP #$1c                                                                                            ; 
BCC ChkWtr                    ; note that for jumping, range is 0-4 for Y                           ; 
INY                                                                                                 ;  B
ChkWtr:  LDA #$01             ; set value here (apparently always set to 1)                         ;  B
STA DiffToHaltJump                                                                                  ; 
LDA SwimmingFlag              ; if swimming flag disabled, branch                                   ; 
BEQ GetYPhy                                                                                         ; 
LDY #$05                      ; otherwise set Y to 5, range is 5-6                                  ;  B
LDA Whirlpool_Flag            ; if whirlpool flag not set, branch                                   ; 
BEQ GetYPhy                                                                                         ; 
INY                           ; otherwise increment to 6                                            ;  B
GetYPhy:  LDA JumpMForceData,Y; store appropriate jump/swim                                         ;  B
STA VerticalForce             ; data here                                                           ; 
LDA FallMForceData,Y                                                                                ; 
STA VerticalForceDown                                                                               ; 
LDA InitMForceData,Y                                                                                ; 
STA Player_Y_MoveForce                                                                              ; 
LDA PlayerYSpdData,Y                                                                                ; 
STA Player_Y_Speed                                                                                  ; 
LDA SwimmingFlag              ; if swimming flag disabled, branch                                   ; 
BEQ PJumpSnd                                                                                        ; 
LDA #Sfx_EnemyStomp           ; load swim/goomba stomp sound into                                   ;  B
STA Square1SoundQueue         ; square 1's sfx queue                                                ; 
LDA Player_Y_Position                                                                               ; 
CMP #$14                      ; check vertical low byte of player position                          ; 
BCS X_Physics                 ; if below a certain point, branch                                    ; 
LDA #$00                      ; otherwise reset player's vertical speed                             ;  B
STA Player_Y_Speed            ; and jump to something else to keep player                           ; 
JMP X_Physics                 ; from swimming above water level                                     ; 
PJumpSnd:  LDA #Sfx_BigJump   ; load big mario's jump sound by default                              ;  B
LDY PlayerSize                ; is mario big?                                                       ; 
BEQ SJumpSnd                                                                                        ; 
LDA #Sfx_SmallJump            ; if not, load small mario's jump sound                               ;  B
SJumpSnd:  STA Square1SoundQueue; store appropriate jump sound in square 1 sfx queue                ;  B
X_Physics:  LDY #$00                                                                                ;  B
STY $00                       ; init value here                                                     ; 
LDA Player_State              ; if mario is on the ground, branch                                   ; 
BEQ ProcPRun                                                                                        ; 
LDA Player_XSpeedAbsolute     ; check something that seems to be related                            ;  B
CMP #$19                      ; to mario's speed                                                    ; 
BCS GetXPhy                   ; if =>$19 branch here                                                ; 
BCC ChkRFast                  ; if not branch elsewhere                                             ;  B
ProcPRun:  INY                ; if mario on the ground, increment Y                                 ;  B
LDA AreaType                  ; check area type                                                     ; 
BEQ ChkRFast                  ; if water type, branch                                               ; 
DEY                           ; decrement Y by default for non-water type area                      ;  B
LDA Left_Right_Buttons        ; get left/right controller bits                                      ; 
CMP Player_MovingDir          ; check against moving direction                                      ; 
BNE ChkRFast                  ; if controller bits <> moving direction, skip this part              ; 
LDA A_B_Buttons               ; check for b button pressed                                          ;  B
AND #B_Button                                                                                       ; 
BNE SetRTmr                   ; if pressed, skip ahead to set timer                                 ; 
LDA RunningTimer              ; check for running timer set                                         ;  B
BNE GetXPhy                   ; if set, branch                                                      ; 
ChkRFast:  INY                ; if running timer not set or level type is water,                    ;  B
INC $00                       ; increment Y again and temp variable in memory                       ; 
LDA RunningSpeed                                                                                    ; 
BNE FastXSp                   ; if running speed set here, branch                                   ; 
LDA Player_XSpeedAbsolute                                                                           ;  B
CMP #$21                      ; otherwise check player's walking/running speed                      ; 
BCC GetXPhy                   ; if less than a certain amount, branch ahead                         ; 
FastXSp:  INC $00             ; if running speed set or speed => $21 increment $00                  ;  B
JMP GetXPhy                   ; and jump ahead                                                      ; 
SetRTmr:  LDA #$0a            ; if b button pressed, set running timer                              ;  B
STA RunningTimer                                                                                    ; 
GetXPhy:  LDA MaxLeftXSpdData,Y; get maximum speed to the left                                      ;  B
STA MaximumLeftSpeed                                                                                ; 
LDA GameEngineSubroutine      ; check for specific routine running                                  ; 
CMP #$07                      ; (player entrance)                                                   ; 
BNE GetXPhy2                  ; if not running, skip and use old value of Y                         ; 
LDY #$03                      ; otherwise set Y to 3                                                ;  B
GetXPhy2:  LDA MaxRightXSpdData,Y; get maximum speed to the right                                   ;  B
STA MaximumRightSpeed                                                                               ; 
LDY $00                       ; get other value in memory                                           ; 
LDA FrictionData,Y            ; get value using value in memory as offset                           ; 
STA FrictionAdderLow                                                                                ; 
LDA #$00                                                                                            ; 
STA FrictionAdderHigh         ; init something here                                                 ; 
LDA PlayerFacingDir                                                                                 ; 
CMP Player_MovingDir          ; check facing direction against moving direction                     ; 
BEQ ExitPhy                   ; if the same, branch to leave                                        ; 
ASL FrictionAdderLow          ; otherwise shift d7 of friction adder low into carry                 ;  B
ROL FrictionAdderHigh         ; then rotate carry onto d0 of friction adder high                    ; 
ExitPhy:  RTS                 ; and then leave                                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerAnimTmrData:                                                                                  ;  B
DATA: ByteValue(value=2), ByteValue(value=4), ByteValue(value=7)                                    ; 
                                                                                                    ; 
GetPlayerAnimSpeed:                                                                                 ; fun():  B
LDY #$00                      ; initialize offset in Y                                              ; 
LDA Player_XSpeedAbsolute     ; check player's walking/running speed                                ; 
CMP #$1c                      ; against preset amount                                               ; 
BCS SetRunSpd                 ; if greater than a certain amount, branch ahead                      ; 
INY                           ; otherwise increment Y                                               ;  B
CMP #$0e                      ; compare against lower amount                                        ; 
BCS ChkSkid                   ; if greater than this but not greater than first, skip increment     ; 
INY                           ; otherwise increment Y again                                         ;  B
ChkSkid:  LDA SavedJoypadBits ; get controller bits                                                 ;  B
AND #%01111111                ; mask out A button                                                   ; 
BEQ SetAnimSpd                ; if no other buttons pressed, branch ahead of all this               ; 
AND #$03                      ; mask out all others except left and right                           ;  B
CMP Player_MovingDir          ; check against moving direction                                      ; 
BNE ProcSkid                  ; if left/right controller bits <> moving direction, branch           ; 
LDA #$00                      ; otherwise set zero value here                                       ;  B
SetRunSpd:  STA RunningSpeed  ; store zero or running speed here                                    ;  B
JMP SetAnimSpd                                                                                      ; 
ProcSkid:  LDA Player_XSpeedAbsolute; check player's walking/running speed                          ;  B
CMP #$0b                      ; against one last amount                                             ; 
BCS SetAnimSpd                ; if greater than this amount, branch                                 ; 
LDA PlayerFacingDir                                                                                 ;  B
STA Player_MovingDir          ; otherwise use facing direction to set moving direction              ; 
LDA #$00                                                                                            ; 
STA Player_X_Speed            ; nullify player's horizontal speed                                   ; 
STA Player_X_MoveForce        ; and dummy variable for player                                       ; 
SetAnimSpd:  LDA PlayerAnimTmrData,Y; get animation timer setting using Y as offset                 ;  B
STA PlayerAnimTimerSet                                                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
ImposeFriction:                                                                                     ; fun(A): A B
AND Player_CollisionBits      ; perform AND between left/right controller bits and collision flag   ; 
CMP #$00                      ; then compare to zero (this instruction is redundant)                ; 
BNE JoypFrict                 ; if any bits set, branch to next part                                ; 
LDA Player_X_Speed                                                                                  ;  B
BEQ SetAbsSpd                 ; if player has no horizontal speed, branch ahead to last part        ; 
BPL RghtFrict                 ; if player moving to the right, branch to slow                       ;  B
BMI LeftFrict                 ; otherwise logic dictates player moving left, branch to slow         ;  B
JoypFrict:  LSR               ; put right controller bit into carry                                 ;  B
BCC RghtFrict                 ; if left button pressed, carry = 0, thus branch                      ; 
LeftFrict:  LDA Player_X_MoveForce; load value set here                                             ;  B
CLC                                                                                                 ; 
ADC FrictionAdderLow          ; add to it another value set here                                    ; 
STA Player_X_MoveForce        ; store here                                                          ; 
LDA Player_X_Speed                                                                                  ; 
ADC FrictionAdderHigh         ; add value plus carry to horizontal speed                            ; 
STA Player_X_Speed            ; set as new horizontal speed                                         ; 
CMP MaximumRightSpeed         ; compare against maximum value for right movement                    ; 
BMI XSpdSign                  ; if horizontal speed greater negatively, branch                      ; 
LDA MaximumRightSpeed         ; otherwise set preset value as horizontal speed                      ;  B
STA Player_X_Speed            ; thus slowing the player's left movement down                        ; 
JMP SetAbsSpd                 ; skip to the end                                                     ; 
RghtFrict:  LDA Player_X_MoveForce; load value set here                                             ;  B
SEC                                                                                                 ; 
SBC FrictionAdderLow          ; subtract from it another value set here                             ; 
STA Player_X_MoveForce        ; store here                                                          ; 
LDA Player_X_Speed                                                                                  ; 
SBC FrictionAdderHigh         ; subtract value plus borrow from horizontal speed                    ; 
STA Player_X_Speed            ; set as new horizontal speed                                         ; 
CMP MaximumLeftSpeed          ; compare against maximum value for left movement                     ; 
BPL XSpdSign                  ; if horizontal speed greater positively, branch                      ; 
LDA MaximumLeftSpeed          ; otherwise set preset value as horizontal speed                      ;  B
STA Player_X_Speed            ; thus slowing the player's right movement down                       ; 
XSpdSign:  CMP #$00           ; if player not moving or moving to the right,                        ;  B
BPL SetAbsSpd                 ; branch and leave horizontal speed value unmodified                  ; 
EOR #$ff                                                                                            ;  B
CLC                           ; otherwise get two's compliment to get absolute                      ; 
ADC #$01                      ; unsigned walking/running speed                                      ; 
SetAbsSpd:  STA Player_XSpeedAbsolute; store walking/running speed here and leave                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to store downward movement force in FireballObjCore      ; 
                              ; $02 - used to store maximum vertical speed in FireballObjCore       ; 
                              ; $07 - used to store pseudorandom bit in BubbleCheck                 ; 
                                                                                                    ; 
ProcFireball_Bubble:                                                                                ; fun():  B
LDA PlayerStatus              ; check player's status                                               ; 
CMP #$02                                                                                            ; 
BCC ProcAirBubbles            ; if not fiery, branch                                                ; 
LDA A_B_Buttons                                                                                     ;  B
AND #B_Button                 ; check for b button pressed                                          ; 
BEQ ProcFireballs             ; branch if not pressed                                               ; 
AND PreviousA_B_Buttons                                                                             ;  B
BNE ProcFireballs             ; if button pressed in previous frame, branch                         ; 
LDA FireballCounter           ; load fireball counter                                               ;  B
AND #%00000001                ; get LSB and use as offset for buffer                                ; 
TAX                                                                                                 ; 
LDA Fireball_State,X          ; load fireball state                                                 ; 
BNE ProcFireballs             ; if not inactive, branch                                             ; 
LDY Player_Y_HighPos          ; if player too high or too low, branch                               ;  B
DEY                                                                                                 ; 
BNE ProcFireballs                                                                                   ; 
LDA CrouchingFlag             ; if player crouching, branch                                         ;  B
BNE ProcFireballs                                                                                   ; 
LDA Player_State              ; if player's state = climbing, branch                                ;  B
CMP #$03                                                                                            ; 
BEQ ProcFireballs                                                                                   ; 
LDA #Sfx_Fireball             ; play fireball sound effect                                          ;  B
STA Square1SoundQueue                                                                               ; 
LDA #$02                      ; load state                                                          ; 
STA Fireball_State,X                                                                                ; 
LDY PlayerAnimTimerSet        ; copy animation frame timer setting                                  ; 
STY FireballThrowingTimer     ; into fireball throwing timer                                        ; 
DEY                                                                                                 ; 
STY PlayerAnimTimer           ; decrement and store in player's animation timer                     ; 
INC FireballCounter           ; increment fireball counter                                          ; 
                                                                                                    ; 
ProcFireballs:                                                                                      ;  B
LDX #$00                                                                                            ; 
JSR FireballObjCore           ; process first fireball object                                       ; 
LDX #$01                                                                                            ; 
JSR FireballObjCore           ; process second fireball object, then do air bubbles                 ; 
                                                                                                    ; 
ProcAirBubbles:                                                                                     ;  B
LDA AreaType                  ; if not water type level, skip the rest of this                      ; 
BNE BublExit                                                                                        ; 
LDX #$02                      ; otherwise load counter and use as offset                            ;  B
BublLoop:  STX ObjectOffset   ; store offset                                                        ;  B
JSR BubbleCheck               ; check timers and coordinates, create air bubble                     ; 
JSR RelativeBubblePosition    ; get relative coordinates                                            ; 
JSR GetBubbleOffscreenBits    ; get offscreen information                                           ; 
JSR DrawBubble                ; draw the air bubble                                                 ; 
DEX                                                                                                 ; 
BPL BublLoop                  ; do this until all three are handled                                 ; 
BublExit:  RTS                ; then leave                                                          ;  B
                                                                                                    ;  B
FireballXSpdData:                                                                                   ;  B
DATA: ByteValue(value=64), ByteValue(value=192)                                                     ; 
                                                                                                    ; 
FireballObjCore:                                                                                    ; fun(X):  B
STX ObjectOffset              ; store offset as current object                                      ; 
LDA Fireball_State,X          ; check for d7 = 1                                                    ; 
ASL                                                                                                 ; 
BCS FireballExplosion         ; if so, branch to get relative coordinates and draw explosion        ; 
LDY Fireball_State,X          ; if fireball inactive, branch to leave                               ;  B
BEQ NoFBall                                                                                         ; 
DEY                           ; if fireball state set to 1, skip this part and just run it          ;  B
BEQ RunFB                                                                                           ; 
LDA Player_X_Position         ; get player's horizontal position                                    ;  B
ADC #$04                      ; add four pixels and store as fireball's horizontal position         ; 
STA Fireball_X_Position,X                                                                           ; 
LDA Player_PageLoc            ; get player's page location                                          ; 
ADC #$00                      ; add carry and store as fireball's page location                     ; 
STA Fireball_PageLoc,X                                                                              ; 
LDA Player_Y_Position         ; get player's vertical position and store                            ; 
STA Fireball_Y_Position,X                                                                           ; 
LDA #$01                      ; set high byte of vertical position                                  ; 
STA Fireball_Y_HighPos,X                                                                            ; 
LDY PlayerFacingDir           ; get player's facing direction                                       ; 
DEY                           ; decrement to use as offset here                                     ; 
LDA FireballXSpdData,Y        ; set horizontal speed of fireball accordingly                        ; 
STA Fireball_X_Speed,X                                                                              ; 
LDA #$04                      ; set vertical speed of fireball                                      ; 
STA Fireball_Y_Speed,X                                                                              ; 
LDA #$07                                                                                            ; 
STA Fireball_BoundBoxCtrl,X   ; set bounding box size control for fireball                          ; 
DEC Fireball_State,X          ; decrement state to 1 to skip this part from now on                  ; 
RunFB:  TXA                   ; add 7 to offset to use                                              ;  B
CLC                           ; as fireball offset for next routines                                ; 
ADC #$07                                                                                            ; 
TAX                                                                                                 ; 
LDA #$50                      ; set downward movement force here                                    ; 
STA $00                                                                                             ; 
LDA #$03                      ; set maximum speed here                                              ; 
STA $02                                                                                             ; 
LDA #$00                                                                                            ; 
JSR ImposeGravity             ; do sub here to impose gravity on fireball and move vertically       ; 
JSR MoveObjectHorizontally    ; do another sub to move it horizontally                              ; 
LDX ObjectOffset              ; return fireball offset to X                                         ; 
JSR RelativeFireballPosition  ; get relative coordinates                                            ; 
JSR GetFireballOffscreenBits  ; get offscreen information                                           ; 
JSR GetFireballBoundBox       ; get bounding box coordinates                                        ; 
JSR FireballBGCollision       ; do fireball to background collision detection                       ; 
LDA FBall_OffscreenBits       ; get fireball offscreen bits                                         ; 
AND #%11001100                ; mask out certain bits                                               ; 
BNE EraseFB                   ; if any bits still set, branch to kill fireball                      ; 
JSR FireballEnemyCollision    ; do fireball to enemy collision detection and deal with collisions   ;  B
JMP DrawFireball              ; draw fireball appropriately and leave                               ; 
EraseFB:  LDA #$00            ; erase fireball state                                                ;  B
STA Fireball_State,X                                                                                ; 
NoFBall:  RTS                 ; leave                                                               ;  B
                                                                                                    ;  B
FireballExplosion:                                                                                  ;  B
JSR RelativeFireballPosition                                                                        ; 
JMP DrawExplosion_Fireball                                                                          ; 
                                                                                                    ;  B
BubbleCheck:                                                                                        ; fun():  B
LDA PseudoRandomBitReg+1,X    ; get part of LSFR                                                    ; 
AND #$01                                                                                            ; 
STA $07                       ; store pseudorandom bit here                                         ; 
LDA Bubble_Y_Position,X       ; get vertical coordinate for air bubble                              ; 
CMP #$f8                      ; if offscreen coordinate not set,                                    ; 
BNE MoveBubl                  ; branch to move air bubble                                           ; 
LDA AirBubbleTimer            ; if air bubble timer not expired,                                    ;  B
BNE ExitBubl                  ; branch to leave, otherwise create new air bubble                    ; 
                                                                                                    ;  B
SetupBubble:                                                                                        ; fun($07):  B
LDY #$00                      ; load default value here                                             ; 
LDA PlayerFacingDir           ; get player's facing direction                                       ; 
LSR                           ; move d0 to carry                                                    ; 
BCC PosBubl                   ; branch to use default value if facing left                          ; 
LDY #$08                      ; otherwise load alternate value here                                 ;  B
PosBubl:  TYA                 ; use value loaded as adder                                           ;  B
ADC Player_X_Position         ; add to player's horizontal position                                 ; 
STA Bubble_X_Position,X       ; save as horizontal position for airbubble                           ; 
LDA Player_PageLoc                                                                                  ; 
ADC #$00                      ; add carry to player's page location                                 ; 
STA Bubble_PageLoc,X          ; save as page location for airbubble                                 ; 
LDA Player_Y_Position                                                                               ; 
CLC                           ; add eight pixels to player's vertical position                      ; 
ADC #$08                                                                                            ; 
STA Bubble_Y_Position,X       ; save as vertical position for air bubble                            ; 
LDA #$01                                                                                            ; 
STA Bubble_Y_HighPos,X        ; set vertical high byte for air bubble                               ; 
LDY $07                       ; get pseudorandom bit, use as offset                                 ; 
LDA BubbleTimerData,Y         ; get data for air bubble timer                                       ; 
STA AirBubbleTimer            ; set air bubble timer                                                ; 
MoveBubl:  LDY $07            ; get pseudorandom bit again, use as offset                           ;  B
LDA Bubble_YMF_Dummy,X                                                                              ; 
SEC                           ; subtract pseudorandom amount from dummy variable                    ; 
SBC Bubble_MForceData,Y                                                                             ; 
STA Bubble_YMF_Dummy,X        ; save dummy variable                                                 ; 
LDA Bubble_Y_Position,X                                                                             ; 
SBC #$00                      ; subtract borrow from airbubble's vertical coordinate                ; 
CMP #$20                      ; if below the status bar,                                            ; 
BCS Y_Bubl                    ; branch to go ahead and use to move air bubble upwards               ; 
LDA #$f8                      ; otherwise set offscreen coordinate                                  ;  B
Y_Bubl:  STA Bubble_Y_Position,X; store as new vertical coordinate for air bubble                   ;  B
ExitBubl:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
Bubble_MForceData:                                                                                  ;  B
DATA: ByteValue(value=255), ByteValue(value=80)                                                     ; 
                                                                                                    ; 
BubbleTimerData:                                                                                    ;  B
DATA: ByteValue(value=64), ByteValue(value=32)                                                      ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
RunGameTimer:                                                                                       ; fun():  B
LDA OperMode                  ; get primary mode of operation                                       ; 
BEQ ExGTimer                  ; branch to leave if in title screen mode                             ; 
LDA GameEngineSubroutine                                                                            ;  B
CMP #$08                      ; if routine number less than eight running,                          ; 
BCC ExGTimer                  ; branch to leave                                                     ; 
CMP #$0b                      ; if running death routine,                                           ;  B
BEQ ExGTimer                  ; branch to leave                                                     ; 
LDA Player_Y_HighPos                                                                                ;  B
CMP #$02                      ; if player below the screen,                                         ; 
BCS ExGTimer                  ; branch to leave regardless of level type                            ; 
LDA GameTimerCtrlTimer        ; if game timer control not yet expired,                              ;  B
BNE ExGTimer                  ; branch to leave                                                     ; 
LDA GameTimerDisplay                                                                                ;  B
ORA GameTimerDisplay+1        ; otherwise check game timer digits                                   ; 
ORA GameTimerDisplay+2                                                                              ; 
BEQ TimeUpOn                  ; if game timer digits at 000, branch to time-up code                 ; 
LDY GameTimerDisplay          ; otherwise check first digit                                         ;  B
DEY                           ; if first digit not on 1,                                            ; 
BNE ResGTCtrl                 ; branch to reset game timer control                                  ; 
LDA GameTimerDisplay+1        ; otherwise check second and third digits                             ;  B
ORA GameTimerDisplay+2                                                                              ; 
BNE ResGTCtrl                 ; if timer not at 100, branch to reset game timer control             ; 
LDA #TimeRunningOutMusic                                                                            ;  B
STA EventMusicQueue           ; otherwise load time running out music                               ; 
ResGTCtrl:  LDA #$18          ; reset game timer control                                            ;  B
STA GameTimerCtrlTimer                                                                              ; 
LDY #$23                      ; set offset for last digit                                           ; 
LDA #$ff                      ; set value to decrement game timer digit                             ; 
STA DigitModifier+5                                                                                 ; 
JSR DigitsMathRoutine         ; do sub to decrement game timer slowly                               ; 
LDA #$a4                      ; set status nybbles to update game timer display                     ; 
JMP PrintStatusBarNumbers     ; do sub to update the display                                        ; 
TimeUpOn:  STA PlayerStatus   ; init player status (note A will always be zero here)                ;  B
JSR ForceInjury               ; do sub to kill the player (note player is small here)               ; 
INC GameTimerExpiredFlag      ; set game timer expiration flag                                      ; 
ExGTimer:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
WarpZoneObject:                                                                                     ;  B
LDA ScrollLock                ; check for scroll lock flag                                          ; 
BEQ ExGTimer                  ; branch if not set to leave                                          ; 
LDA Player_Y_Position         ; check to see if player's vertical coordinate has                    ;  B
AND Player_Y_HighPos          ; same bits set as in vertical high byte (why?)                       ; 
BNE ExGTimer                  ; if so, branch to leave                                              ; 
STA ScrollLock                ; otherwise nullify scroll lock flag                                  ;  B
INC WarpZoneControl           ; increment warp zone flag to make warp pipes for warp zone           ; 
JMP EraseEnemyObject          ; kill this object                                                    ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool; 
                              ; and also to store movement force exerted on player                  ; 
                              ; $01 - used in ProcessWhirlpools to store page location of right extent of whirlpool; 
                              ; and in WhirlpoolActivate to store center of whirlpool               ; 
                              ; $02 - used in ProcessWhirlpools to store right extent of whirlpool and in; 
                              ; WhirlpoolActivate to store maximum vertical speed                   ; 
                                                                                                    ; 
ProcessWhirlpools:                                                                                  ; fun():  B
LDA AreaType                  ; check for water type level                                          ; 
BNE ExitWh                    ; branch to leave if not found                                        ; 
STA Whirlpool_Flag            ; otherwise initialize whirlpool flag                                 ;  B
LDA TimerControl              ; if master timer control set,                                        ; 
BNE ExitWh                    ; branch to leave                                                     ; 
LDY #$04                      ; otherwise start with last whirlpool data                            ;  B
WhLoop:  LDA Whirlpool_LeftExtent,Y; get left extent of whirlpool                                   ;  B
CLC                                                                                                 ; 
ADC Whirlpool_Length,Y        ; add length of whirlpool                                             ; 
STA $02                       ; store result as right extent here                                   ; 
LDA Whirlpool_PageLoc,Y       ; get page location                                                   ; 
BEQ NextWh                    ; if none or page 0, branch to get next data                          ; 
ADC #$00                      ; add carry                                                           ;  B
STA $01                       ; store result as page location of right extent here                  ; 
LDA Player_X_Position         ; get player's horizontal position                                    ; 
SEC                                                                                                 ; 
SBC Whirlpool_LeftExtent,Y    ; subtract left extent                                                ; 
LDA Player_PageLoc            ; get player's page location                                          ; 
SBC Whirlpool_PageLoc,Y       ; subtract borrow                                                     ; 
BMI NextWh                    ; if player too far left, branch to get next data                     ; 
LDA $02                       ; otherwise get right extent                                          ;  B
SEC                                                                                                 ; 
SBC Player_X_Position         ; subtract player's horizontal coordinate                             ; 
LDA $01                       ; get right extent's page location                                    ; 
SBC Player_PageLoc            ; subtract borrow                                                     ; 
BPL WhirlpoolActivate         ; if player within right extent, branch to whirlpool code             ; 
NextWh:  DEY                  ; move onto next whirlpool data                                       ;  B
BPL WhLoop                    ; do this until all whirlpools are checked                            ; 
ExitWh:  RTS                  ; leave                                                               ;  B
                                                                                                    ;  B
WhirlpoolActivate:                                                                                  ;  B
LDA Whirlpool_Length,Y        ; get length of whirlpool                                             ; 
LSR                           ; divide by 2                                                         ; 
STA $00                       ; save here                                                           ; 
LDA Whirlpool_LeftExtent,Y    ; get left extent of whirlpool                                        ; 
CLC                                                                                                 ; 
ADC $00                       ; add length divided by 2                                             ; 
STA $01                       ; save as center of whirlpool                                         ; 
LDA Whirlpool_PageLoc,Y       ; get page location                                                   ; 
ADC #$00                      ; add carry                                                           ; 
STA $00                       ; save as page location of whirlpool center                           ; 
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; shift d0 into carry (to run on every other frame)                   ; 
BCC WhPull                    ; if d0 not set, branch to last part of code                          ; 
LDA $01                       ; get center                                                          ;  B
SEC                                                                                                 ; 
SBC Player_X_Position         ; subtract player's horizontal coordinate                             ; 
LDA $00                       ; get page location of center                                         ; 
SBC Player_PageLoc            ; subtract borrow                                                     ; 
BPL LeftWh                    ; if player to the left of center, branch                             ; 
LDA Player_X_Position         ; otherwise slowly pull player left, towards the center               ;  B
SEC                                                                                                 ; 
SBC #$01                      ; subtract one pixel                                                  ; 
STA Player_X_Position         ; set player's new horizontal coordinate                              ; 
LDA Player_PageLoc                                                                                  ; 
SBC #$00                      ; subtract borrow                                                     ; 
JMP SetPWh                    ; jump to set player's new page location                              ; 
LeftWh:  LDA Player_CollisionBits; get player's collision bits                                      ;  B
LSR                           ; shift d0 into carry                                                 ; 
BCC WhPull                    ; if d0 not set, branch                                               ; 
LDA Player_X_Position         ; otherwise slowly pull player right, towards the center              ;  B
CLC                                                                                                 ; 
ADC #$01                      ; add one pixel                                                       ; 
STA Player_X_Position         ; set player's new horizontal coordinate                              ; 
LDA Player_PageLoc                                                                                  ; 
ADC #$00                      ; add carry                                                           ; 
SetPWh:  STA Player_PageLoc   ; set player's new page location                                      ;  B
WhPull:  LDA #$10                                                                                   ;  B
STA $00                       ; set vertical movement force                                         ; 
LDA #$01                                                                                            ; 
STA Whirlpool_Flag            ; set whirlpool flag to be used later                                 ; 
STA $02                       ; also set maximum vertical speed                                     ; 
LSR                                                                                                 ; 
TAX                           ; set X for player offset                                             ; 
JMP ImposeGravity             ; jump to put whirlpool effect on player vertically, do not return    ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
FlagpoleScoreMods:                                                                                  ;  B
DATA: ByteValue(value=5), ByteValue(value=2), ByteValue(value=8), ByteValue(value=4), ByteValue(value=1); 
                                                                                                    ; 
FlagpoleScoreDigits:                                                                                ;  B
DATA: ByteValue(value=3), ByteValue(value=3), ByteValue(value=4), ByteValue(value=4), ByteValue(value=4); 
                                                                                                    ; 
FlagpoleRoutine:                                                                                    ; fun():  B
LDX #$05                      ; set enemy object offset                                             ; 
STX ObjectOffset              ; to special use slot                                                 ; 
LDA Enemy_ID,X                                                                                      ; 
CMP #FlagpoleFlagObject       ; if flagpole flag not found,                                         ; 
BNE ExitFlagP                 ; branch to leave                                                     ; 
LDA GameEngineSubroutine                                                                            ;  B
CMP #$04                      ; if flagpole slide routine not running,                              ; 
BNE SkipScore                 ; branch to near the end of code                                      ; 
LDA Player_State                                                                                    ;  B
CMP #$03                      ; if player state not climbing,                                       ; 
BNE SkipScore                 ; branch to near the end of code                                      ; 
LDA Enemy_Y_Position,X        ; check flagpole flag's vertical coordinate                           ;  B
CMP #$aa                      ; if flagpole flag down to a certain point,                           ; 
BCS GiveFPScr                 ; branch to end the level                                             ; 
LDA Player_Y_Position         ; check player's vertical coordinate                                  ;  B
CMP #$a2                      ; if player down to a certain point,                                  ; 
BCS GiveFPScr                 ; branch to end the level                                             ; 
LDA Enemy_YMF_Dummy,X                                                                               ;  B
ADC #$ff                      ; add movement amount to dummy variable                               ; 
STA Enemy_YMF_Dummy,X         ; save dummy variable                                                 ; 
LDA Enemy_Y_Position,X        ; get flag's vertical coordinate                                      ; 
ADC #$01                      ; add 1 plus carry to move flag, and                                  ; 
STA Enemy_Y_Position,X        ; store vertical coordinate                                           ; 
LDA FlagpoleFNum_YMFDummy                                                                           ; 
SEC                           ; subtract movement amount from dummy variable                        ; 
SBC #$ff                                                                                            ; 
STA FlagpoleFNum_YMFDummy     ; save dummy variable                                                 ; 
LDA FlagpoleFNum_Y_Pos                                                                              ; 
SBC #$01                      ; subtract one plus borrow to move floatey number,                    ; 
STA FlagpoleFNum_Y_Pos        ; and store vertical coordinate here                                  ; 
SkipScore:  JMP FPGfx         ; jump to skip ahead and draw flag and floatey number                 ;  B
GiveFPScr:  LDY FlagpoleScore ; get score offset from earlier (when player touched flagpole)        ;  B
LDA FlagpoleScoreMods,Y       ; get amount to award player points                                   ; 
LDX FlagpoleScoreDigits,Y     ; get digit with which to award points                                ; 
STA DigitModifier,X           ; store in digit modifier                                             ; 
JSR AddToScore                ; do sub to award player points depending on height of collision      ; 
LDA #$05                                                                                            ; 
STA GameEngineSubroutine      ; set to run end-of-level subroutine on next frame                    ; 
FPGfx:  JSR GetEnemyOffscreenBits; get offscreen information                                        ;  B
JSR RelativeEnemyPosition     ; get relative coordinates                                            ; 
JSR FlagpoleGfxHandler        ; draw flagpole flag and floatey number                               ; 
ExitFlagP:  RTS                                                                                     ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
Jumpspring_Y_PosData:                                                                               ;  B
DATA: ByteValue(value=8), ByteValue(value=16), ByteValue(value=8), ByteValue(value=0)               ; 
                                                                                                    ; 
JumpspringHandler:                                                                                  ;  B
JSR GetEnemyOffscreenBits     ; get offscreen information                                           ; 
LDA TimerControl              ; check master timer control                                          ; 
BNE DrawJSpr                  ; branch to last section if set                                       ; 
LDA JumpspringAnimCtrl        ; check jumpspring frame control                                      ;  B
BEQ DrawJSpr                  ; branch to last section if not set                                   ; 
TAY                                                                                                 ;  B
DEY                           ; subtract one from frame control,                                    ; 
TYA                           ; the only way a poor nmos 6502 can                                   ; 
AND #%00000010                ; mask out all but d1, original value still in Y                      ; 
BNE DownJSpr                  ; if set, branch to move player up                                    ; 
INC Player_Y_Position                                                                               ;  B
INC Player_Y_Position         ; move player's vertical position down two pixels                     ; 
JMP PosJSpr                   ; skip to next part                                                   ; 
DownJSpr:  DEC Player_Y_Position; move player's vertical position up two pixels                     ;  B
DEC Player_Y_Position                                                                               ; 
PosJSpr:  LDA Jumpspring_FixedYPos,X; get permanent vertical position                               ;  B
CLC                                                                                                 ; 
ADC Jumpspring_Y_PosData,Y    ; add value using frame control as offset                             ; 
STA Enemy_Y_Position,X        ; store as new vertical position                                      ; 
CPY #$01                      ; check frame control offset (second frame is $00)                    ; 
BCC BounceJS                  ; if offset not yet at third frame ($01), skip to next part           ; 
LDA A_B_Buttons                                                                                     ;  B
AND #A_Button                 ; check saved controller bits for A button press                      ; 
BEQ BounceJS                  ; skip to next part if A not pressed                                  ; 
AND PreviousA_B_Buttons       ; check for A button pressed in previous frame                        ;  B
BNE BounceJS                  ; skip to next part if so                                             ; 
LDA #$f4                                                                                            ;  B
STA JumpspringForce           ; otherwise write new jumpspring force here                           ; 
BounceJS:  CPY #$03           ; check frame control offset again                                    ;  B
BNE DrawJSpr                  ; skip to last part if not yet at fifth frame ($03)                   ; 
LDA JumpspringForce                                                                                 ;  B
STA Player_Y_Speed            ; store jumpspring force as player's new vertical speed               ; 
LDA #$00                                                                                            ; 
STA JumpspringAnimCtrl        ; initialize jumpspring frame control                                 ; 
DrawJSpr:  JSR RelativeEnemyPosition; get jumpspring's relative coordinates                         ;  B
JSR EnemyGfxHandler           ; draw jumpspring                                                     ; 
JSR OffscreenBoundsCheck      ; check to see if we need to kill it                                  ; 
LDA JumpspringAnimCtrl        ; if frame control at zero, don't bother                              ; 
BEQ ExJSpring                 ; trying to animate it, just leave                                    ; 
LDA JumpspringTimer                                                                                 ;  B
BNE ExJSpring                 ; if jumpspring timer not expired yet, leave                          ; 
LDA #$04                                                                                            ;  B
STA JumpspringTimer           ; otherwise initialize jumpspring timer                               ; 
INC JumpspringAnimCtrl        ; increment frame control to animate jumpspring                       ; 
ExJSpring:  RTS               ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
Setup_Vine:                                                                                         ; fun(X):  B
LDA #VineObject               ; load identifier for vine object                                     ; 
STA Enemy_ID,X                ; store in buffer                                                     ; 
LDA #$01                                                                                            ; 
STA Enemy_Flag,X              ; set flag for enemy object buffer                                    ; 
LDA Block_PageLoc,Y                                                                                 ; 
STA Enemy_PageLoc,X           ; copy page location from previous object                             ; 
LDA Block_X_Position,Y                                                                              ; 
STA Enemy_X_Position,X        ; copy horizontal coordinate from previous object                     ; 
LDA Block_Y_Position,Y                                                                              ; 
STA Enemy_Y_Position,X        ; copy vertical coordinate from previous object                       ; 
LDY VineFlagOffset            ; load vine flag/offset to next available vine slot                   ; 
BNE NextVO                    ; if set at all, don't bother to store vertical                       ; 
STA VineStart_Y_Position      ; otherwise store vertical coordinate here                            ;  B
NextVO:  TXA                  ; store object offset to next available vine slot                     ;  B
STA VineObjOffset,Y           ; using vine flag as offset                                           ; 
INC VineFlagOffset            ; increment vine flag offset                                          ; 
LDA #Sfx_GrowVine                                                                                   ; 
STA Square2SoundQueue         ; load vine grow sound                                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $06-$07 - used as address to block buffer data                      ; 
                              ; $02 - used as vertical high nybble of block buffer offset           ; 
                                                                                                    ; 
VineHeightData:                                                                                     ;  B
DATA: ByteValue(value=48), ByteValue(value=96)                                                      ; 
                                                                                                    ; 
VineObjectHandler:                                                                                  ;  B
CPX #$05                      ; check enemy offset for special use slot                             ; 
BNE ExitVH                    ; if not in last slot, branch to leave                                ; 
LDY VineFlagOffset                                                                                  ;  B
DEY                           ; decrement vine flag in Y, use as offset                             ; 
LDA VineHeight                                                                                      ; 
CMP VineHeightData,Y          ; if vine has reached certain height,                                 ; 
BEQ RunVSubs                  ; branch ahead to skip this part                                      ; 
LDA FrameCounter              ; get frame counter                                                   ;  B
LSR                           ; shift d1 into carry                                                 ; 
LSR                                                                                                 ; 
BCC RunVSubs                  ; if d1 not set (2 frames every 4) skip this part                     ; 
LDA Enemy_Y_Position+5                                                                              ;  B
SBC #$01                      ; subtract vertical position of vine                                  ; 
STA Enemy_Y_Position+5        ; one pixel every frame it's time                                     ; 
INC VineHeight                ; increment vine height                                               ; 
RunVSubs:  LDA VineHeight     ; if vine still very small,                                           ;  B
CMP #$08                      ; branch to leave                                                     ; 
BCC ExitVH                                                                                          ; 
JSR RelativeEnemyPosition     ; get relative coordinates of vine,                                   ;  B
JSR GetEnemyOffscreenBits     ; and any offscreen bits                                              ; 
LDY #$00                      ; initialize offset used in draw vine sub                             ; 
VDrawLoop:  JSR DrawVine      ; draw vine                                                           ;  B
INY                           ; increment offset                                                    ; 
CPY VineFlagOffset            ; if offset in Y and offset here                                      ; 
BNE VDrawLoop                 ; do not yet match, loop back to draw more vine                       ; 
LDA Enemy_OffscreenBits                                                                             ;  B
AND #%00001100                ; mask offscreen bits                                                 ; 
BEQ WrCMTile                  ; if none of the saved offscreen bits set, skip ahead                 ; 
DEY                           ; otherwise decrement Y to get proper offset again                    ;  B
KillVine:  LDX VineObjOffset,Y; get enemy object offset for this vine object                        ;  B
JSR EraseEnemyObject          ; kill this vine object                                               ; 
DEY                           ; decrement Y                                                         ; 
BPL KillVine                  ; if any vine objects left, loop back to kill it                      ; 
STA VineFlagOffset            ; initialize vine flag/offset                                         ;  B
STA VineHeight                ; initialize vine height                                              ; 
WrCMTile:  LDA VineHeight     ; check vine height                                                   ;  B
CMP #$20                      ; if vine small (less than 32 pixels tall)                            ; 
BCC ExitVH                    ; then branch ahead to leave                                          ; 
LDX #$06                      ; set offset in X to last enemy slot                                  ;  B
LDA #$01                      ; set A to obtain horizontal in $04, but we don't care                ; 
LDY #$1b                      ; set Y to offset to get block at ($04, $10) of coordinates           ; 
JSR BlockBufferCollision      ; do a sub to get block buffer address set, return contents           ; 
LDY $02                                                                                             ; 
CPY #$d0                      ; if vertical high nybble offset beyond extent of                     ; 
BCS ExitVH                    ; current block buffer, branch to leave, do not write                 ; 
LDA ($06),Y                   ; otherwise check contents of block buffer at                         ;  B
BNE ExitVH                    ; current offset, if not empty, branch to leave                       ; 
LDA #$26                                                                                            ;  B
STA ($06),Y                   ; otherwise, write climbing metatile to block buffer                  ; 
ExitVH:  LDX ObjectOffset     ; get enemy object offset and leave                                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
CannonBitmasks:                                                                                     ;  B
DATA: ByteValue(value=15), ByteValue(value=7)                                                       ; 
                                                                                                    ; 
ProcessCannons:                                                                                     ; fun():  B
LDA AreaType                  ; get area type                                                       ; 
BEQ ExCannon                  ; if water type area, branch to leave                                 ; 
LDX #$02                                                                                            ;  B
ThreeSChk:  STX ObjectOffset  ; start at third enemy slot                                           ;  B
LDA Enemy_Flag,X              ; check enemy buffer flag                                             ; 
BNE Chk_BB                    ; if set, branch to check enemy                                       ; 
LDA PseudoRandomBitReg+1,X    ; otherwise get part of LSFR                                          ;  B
LDY SecondaryHardMode         ; get secondary hard mode flag, use as offset                         ; 
AND CannonBitmasks,Y          ; mask out bits of LSFR as decided by flag                            ; 
CMP #$06                      ; check to see if lower nybble is above certain value                 ; 
BCS Chk_BB                    ; if so, branch to check enemy                                        ; 
TAY                           ; transfer masked contents of LSFR to Y as pseudorandom offset        ;  B
LDA Cannon_PageLoc,Y          ; get page location                                                   ; 
BEQ Chk_BB                    ; if not set or on page 0, branch to check enemy                      ; 
LDA Cannon_Timer,Y            ; get cannon timer                                                    ;  B
BEQ FireCannon                ; if expired, branch to fire cannon                                   ; 
SBC #$00                      ; otherwise subtract borrow (note carry will always be clear here)    ;  B
STA Cannon_Timer,Y            ; to count timer down                                                 ; 
JMP Chk_BB                    ; then jump ahead to check enemy                                      ; 
                                                                                                    ;  B
FireCannon:                                                                                         ;  B
LDA TimerControl              ; if master timer control set,                                        ; 
BNE Chk_BB                    ; branch to check enemy                                               ; 
LDA #$0e                      ; otherwise we start creating one                                     ;  B
STA Cannon_Timer,Y            ; first, reset cannon timer                                           ; 
LDA Cannon_PageLoc,Y          ; get page location of cannon                                         ; 
STA Enemy_PageLoc,X           ; save as page location of bullet bill                                ; 
LDA Cannon_X_Position,Y       ; get horizontal coordinate of cannon                                 ; 
STA Enemy_X_Position,X        ; save as horizontal coordinate of bullet bill                        ; 
LDA Cannon_Y_Position,Y       ; get vertical coordinate of cannon                                   ; 
SEC                                                                                                 ; 
SBC #$08                      ; subtract eight pixels (because enemies are 24 pixels tall)          ; 
STA Enemy_Y_Position,X        ; save as vertical coordinate of bullet bill                          ; 
LDA #$01                                                                                            ; 
STA Enemy_Y_HighPos,X         ; set vertical high byte of bullet bill                               ; 
STA Enemy_Flag,X              ; set buffer flag                                                     ; 
LSR                           ; shift right once to init A                                          ; 
STA Enemy_State,X             ; then initialize enemy's state                                       ; 
LDA #$09                                                                                            ; 
STA Enemy_BoundBoxCtrl,X      ; set bounding box size control for bullet bill                       ; 
LDA #BulletBill_CannonVar                                                                           ; 
STA Enemy_ID,X                ; load identifier for bullet bill (cannon variant)                    ; 
JMP Next3Slt                  ; move onto next slot                                                 ; 
Chk_BB:  LDA Enemy_ID,X       ; check enemy identifier for bullet bill (cannon variant)             ;  B
CMP #BulletBill_CannonVar                                                                           ; 
BNE Next3Slt                  ; if not found, branch to get next slot                               ; 
JSR OffscreenBoundsCheck      ; otherwise, check to see if it went offscreen                        ;  B
LDA Enemy_Flag,X              ; check enemy buffer flag                                             ; 
BEQ Next3Slt                  ; if not set, branch to get next slot                                 ; 
JSR GetEnemyOffscreenBits     ; otherwise, get offscreen information                                ;  B
JSR BulletBillHandler         ; then do sub to handle bullet bill                                   ; 
Next3Slt:  DEX                ; move onto next slot                                                 ;  B
BPL ThreeSChk                 ; do this until first three slots are checked                         ; 
ExCannon:  RTS                ; then leave                                                          ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BulletBillXSpdData:                                                                                 ;  B
DATA: ByteValue(value=24), ByteValue(value=232)                                                     ; 
                                                                                                    ; 
BulletBillHandler:                                                                                  ; fun($00):  B
LDA TimerControl              ; if master timer control set,                                        ; 
BNE RunBBSubs                 ; branch to run subroutines except movement sub                       ; 
LDA Enemy_State,X                                                                                   ;  B
BNE ChkDSte                   ; if bullet bill's state set, branch to check defeated state          ; 
LDA Enemy_OffscreenBits       ; otherwise load offscreen bits                                       ;  B
AND #%00001100                ; mask out bits                                                       ; 
CMP #%00001100                ; check to see if all bits are set                                    ; 
BEQ KillBB                    ; if so, branch to kill this object                                   ; 
LDY #$01                      ; set to move right by default                                        ;  B
JSR PlayerEnemyDiff           ; get horizontal difference between player and bullet bill            ; 
BMI SetupBB                   ; if enemy to the left of player, branch                              ; 
INY                           ; otherwise increment to move left                                    ;  B
SetupBB:  STY Enemy_MovingDir,X; set bullet bill's moving direction                                 ;  B
DEY                           ; decrement to use as offset                                          ; 
LDA BulletBillXSpdData,Y      ; get horizontal speed based on moving direction                      ; 
STA Enemy_X_Speed,X           ; and store it                                                        ; 
LDA $00                       ; get horizontal difference                                           ; 
ADC #$28                      ; add 40 pixels                                                       ; 
CMP #$50                      ; if less than a certain amount, player is too close                  ; 
BCC KillBB                    ; to cannon either on left or right side, thus branch                 ; 
LDA #$01                                                                                            ;  B
STA Enemy_State,X             ; otherwise set bullet bill's state                                   ; 
LDA #$0a                                                                                            ; 
STA EnemyFrameTimer,X         ; set enemy frame timer                                               ; 
LDA #Sfx_Blast                                                                                      ; 
STA Square2SoundQueue         ; play fireworks/gunfire sound                                        ; 
ChkDSte:  LDA Enemy_State,X   ; check enemy state for d5 set                                        ;  B
AND #%00100000                                                                                      ; 
BEQ BBFly                     ; if not set, skip to move horizontally                               ; 
JSR MoveD_EnemyVertically     ; otherwise do sub to move bullet bill vertically                     ;  B
BBFly:  JSR MoveEnemyHorizontally; do sub to move bullet bill horizontally                          ;  B
RunBBSubs:  JSR GetEnemyOffscreenBits; get offscreen information                                    ;  B
JSR RelativeEnemyPosition     ; get relative coordinates                                            ; 
JSR GetEnemyBoundBox          ; get bounding box coordinates                                        ; 
JSR PlayerEnemyCollision      ; handle player to enemy collisions                                   ; 
JMP EnemyGfxHandler           ; draw the bullet bill and leave                                      ; 
KillBB:  JSR EraseEnemyObject ; kill bullet bill and leave                                          ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
HammerEnemyOfsData:                                                                                 ;  B
DATA: ByteValue(value=4), ByteValue(value=4), ByteValue(value=4), ByteValue(value=5), ByteValue(value=5), ByteValue(value=5); 
DATA: ByteValue(value=6), ByteValue(value=6), ByteValue(value=6)                                    ; 
                                                                                                    ; 
HammerXSpdData:                                                                                     ;  B
DATA: ByteValue(value=16), ByteValue(value=240)                                                     ; 
                                                                                                    ; 
SpawnHammerObj:                                                                                     ; fun(): CarryFlag B
LDA PseudoRandomBitReg+1      ; get pseudorandom bits from                                          ; 
AND #%00000111                ; second part of LSFR                                                 ; 
BNE SetMOfs                   ; if any bits are set, branch and use as offset                       ; 
LDA PseudoRandomBitReg+1                                                                            ;  B
AND #%00001000                ; get d3 from same part of LSFR                                       ; 
SetMOfs:  TAY                 ; use either d3 or d2-d0 for offset here                              ;  B
LDA Misc_State,Y              ; if any values loaded in                                             ; 
BNE NoHammer                  ; $2a-$32 where offset is then leave with carry clear                 ; 
LDX HammerEnemyOfsData,Y      ; get offset of enemy slot to check using Y as offset                 ;  B
LDA Enemy_Flag,X              ; check enemy buffer flag at offset                                   ; 
BNE NoHammer                  ; if buffer flag set, branch to leave with carry clear                ; 
LDX ObjectOffset              ; get original enemy object offset                                    ;  B
TXA                                                                                                 ; 
STA HammerEnemyOffset,Y       ; save here                                                           ; 
LDA #$90                                                                                            ; 
STA Misc_State,Y              ; save hammer's state here                                            ; 
LDA #$07                                                                                            ; 
STA Misc_BoundBoxCtrl,Y       ; set something else entirely, here                                   ; 
SEC                           ; return with carry set                                               ; 
RTS                                                                                                 ; 
NoHammer:  LDX ObjectOffset   ; get original enemy object offset                                    ;  B
CLC                           ; return with carry clear                                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to set downward force                                    ; 
                              ; $01 - used to set upward force (residual)                           ; 
                              ; $02 - used to set maximum speed                                     ; 
                                                                                                    ; 
ProcHammerObj:                                                                                      ; fun():  B
LDA TimerControl              ; if master timer control set                                         ; 
BNE RunHSubs                  ; skip all of this code and go to last subs at the end                ; 
LDA Misc_State,X              ; otherwise get hammer's state                                        ;  B
AND #%01111111                ; mask out d7                                                         ; 
LDY HammerEnemyOffset,X       ; get enemy object offset that spawned this hammer                    ; 
CMP #$02                      ; check hammer's state                                                ; 
BEQ SetHSpd                   ; if currently at 2, branch                                           ; 
BCS SetHPos                   ; if greater than 2, branch elsewhere                                 ;  B
TXA                                                                                                 ;  B
CLC                           ; add 13 bytes to use                                                 ; 
ADC #$0d                      ; proper misc object                                                  ; 
TAX                           ; return offset to X                                                  ; 
LDA #$10                                                                                            ; 
STA $00                       ; set downward movement force                                         ; 
LDA #$0f                                                                                            ; 
STA $01                       ; set upward movement force (not used)                                ; 
LDA #$04                                                                                            ; 
STA $02                       ; set maximum vertical speed                                          ; 
LDA #$00                      ; set A to impose gravity on hammer                                   ; 
JSR ImposeGravity             ; do sub to impose gravity on hammer and move vertically              ; 
JSR MoveObjectHorizontally    ; do sub to move it horizontally                                      ; 
LDX ObjectOffset              ; get original misc object offset                                     ; 
JMP RunAllH                   ; branch to essential subroutines                                     ; 
SetHSpd:  LDA #$fe                                                                                  ;  B
STA Misc_Y_Speed,X            ; set hammer's vertical speed                                         ; 
LDA Enemy_State,Y             ; get enemy object state                                              ; 
AND #%11110111                ; mask out d3                                                         ; 
STA Enemy_State,Y             ; store new state                                                     ; 
LDX Enemy_MovingDir,Y         ; get enemy's moving direction                                        ; 
DEX                           ; decrement to use as offset                                          ; 
LDA HammerXSpdData,X          ; get proper speed to use based on moving direction                   ; 
LDX ObjectOffset              ; reobtain hammer's buffer offset                                     ; 
STA Misc_X_Speed,X            ; set hammer's horizontal speed                                       ; 
SetHPos:  DEC Misc_State,X    ; decrement hammer's state                                            ;  B
LDA Enemy_X_Position,Y        ; get enemy's horizontal position                                     ; 
CLC                                                                                                 ; 
ADC #$02                      ; set position 2 pixels to the right                                  ; 
STA Misc_X_Position,X         ; store as hammer's horizontal position                               ; 
LDA Enemy_PageLoc,Y           ; get enemy's page location                                           ; 
ADC #$00                      ; add carry                                                           ; 
STA Misc_PageLoc,X            ; store as hammer's page location                                     ; 
LDA Enemy_Y_Position,Y        ; get enemy's vertical position                                       ; 
SEC                                                                                                 ; 
SBC #$0a                      ; move position 10 pixels upward                                      ; 
STA Misc_Y_Position,X         ; store as hammer's vertical position                                 ; 
LDA #$01                                                                                            ; 
STA Misc_Y_HighPos,X          ; set hammer's vertical high byte                                     ; 
BNE RunHSubs                  ; unconditional branch to skip first routine                          ; 
RunAllH:  JSR PlayerHammerCollision; handle collisions                                              ;  B
RunHSubs:  JSR GetMiscOffscreenBits; get offscreen information                                      ;  B
JSR RelativeMiscPosition      ; get relative coordinates                                            ; 
JSR GetMiscBoundBox           ; get bounding box coordinates                                        ; 
JSR DrawHammer                ; draw the hammer                                                     ; 
RTS                           ; and we are done here                                                ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $02 - used to store vertical high nybble offset from block buffer routine; 
                              ; $06 - used to store low byte of block buffer address                ; 
                                                                                                    ; 
CoinBlock:                                                                                          ;  B
JSR FindEmptyMiscSlot         ; set offset for empty or last misc object buffer slot                ; 
LDA Block_PageLoc,X           ; get page location of block object                                   ; 
STA Misc_PageLoc,Y            ; store as page location of misc object                               ; 
LDA Block_X_Position,X        ; get horizontal coordinate of block object                           ; 
ORA #$05                      ; add 5 pixels                                                        ; 
STA Misc_X_Position,Y         ; store as horizontal coordinate of misc object                       ; 
LDA Block_Y_Position,X        ; get vertical coordinate of block object                             ; 
SBC #$10                      ; subtract 16 pixels                                                  ; 
STA Misc_Y_Position,Y         ; store as vertical coordinate of misc object                         ; 
JMP JCoinC                    ; jump to rest of code as applies to this misc object                 ; 
                                                                                                    ;  B
SetupJumpCoin:                                                                                      ; fun($06$02X):  B
JSR FindEmptyMiscSlot         ; set offset for empty or last misc object buffer slot                ; 
LDA Block_PageLoc2,X          ; get page location saved earlier                                     ; 
STA Misc_PageLoc,Y            ; and save as page location for misc object                           ; 
LDA $06                       ; get low byte of block buffer offset                                 ; 
ASL                                                                                                 ; 
ASL                           ; multiply by 16 to use lower nybble                                  ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ORA #$05                      ; add five pixels                                                     ; 
STA Misc_X_Position,Y         ; save as horizontal coordinate for misc object                       ; 
LDA $02                       ; get vertical high nybble offset from earlier                        ; 
ADC #$20                      ; add 32 pixels for the status bar                                    ; 
STA Misc_Y_Position,Y         ; store as vertical coordinate                                        ; 
JCoinC:  LDA #$fb                                                                                   ;  B
STA Misc_Y_Speed,Y            ; set vertical speed                                                  ; 
LDA #$01                                                                                            ; 
STA Misc_Y_HighPos,Y          ; set vertical high byte                                              ; 
STA Misc_State,Y              ; set state for misc object                                           ; 
STA Square2SoundQueue         ; load coin grab sound                                                ; 
STX ObjectOffset              ; store current control bit as misc object offset                     ; 
JSR GiveOneCoin               ; update coin tally on the screen and coin amount variable            ; 
INC CoinTallyFor1Ups          ; increment coin tally used to activate 1-up block flag               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
FindEmptyMiscSlot:                                                                                  ; fun(): CarryFlag B
LDY #$08                      ; start at end of misc objects buffer                                 ; 
FMiscLoop:  LDA Misc_State,Y  ; get misc object state                                               ;  B
BEQ UseMiscS                  ; branch if none found to use current offset                          ; 
DEY                           ; decrement offset                                                    ;  B
CPY #$05                      ; do this for three slots                                             ; 
BNE FMiscLoop                 ; do this until all slots are checked                                 ; 
LDY #$08                      ; if no empty slots found, use last slot                              ;  B
UseMiscS:  STY JumpCoinMiscOffset; store offset of misc object buffer here (residual)               ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
MiscObjectsCore:                                                                                    ; fun():  B
LDX #$08                      ; set at end of misc object buffer                                    ; 
MiscLoop:  STX ObjectOffset   ; store misc object offset here                                       ;  B
LDA Misc_State,X              ; check misc object state                                             ; 
BEQ MiscLoopBack              ; branch to check next slot                                           ; 
ASL                           ; otherwise shift d7 into carry                                       ;  B
BCC ProcJumpCoin              ; if d7 not set, jumping coin, thus skip to rest of code here         ; 
JSR ProcHammerObj             ; otherwise go to process hammer,                                     ;  B
JMP MiscLoopBack              ; then check next slot                                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to set downward force                                    ; 
                              ; $01 - used to set upward force (residual)                           ; 
                              ; $02 - used to set maximum speed                                     ; 
                                                                                                    ; 
ProcJumpCoin:                                                                                       ;  B
LDY Misc_State,X              ; check misc object state                                             ; 
DEY                           ; decrement to see if it's set to 1                                   ; 
BEQ JCoinRun                  ; if so, branch to handle jumping coin                                ; 
INC Misc_State,X              ; otherwise increment state to either start off or as timer           ;  B
LDA Misc_X_Position,X         ; get horizontal coordinate for misc object                           ; 
CLC                           ; whether its jumping coin (state 0 only) or floatey number           ; 
ADC ScrollAmount              ; add current scroll speed                                            ; 
STA Misc_X_Position,X         ; store as new horizontal coordinate                                  ; 
LDA Misc_PageLoc,X            ; get page location                                                   ; 
ADC #$00                      ; add carry                                                           ; 
STA Misc_PageLoc,X            ; store as new page location                                          ; 
LDA Misc_State,X                                                                                    ; 
CMP #$30                      ; check state of object for preset value                              ; 
BNE RunJCSubs                 ; if not yet reached, branch to subroutines                           ; 
LDA #$00                                                                                            ;  B
STA Misc_State,X              ; otherwise nullify object state                                      ; 
JMP MiscLoopBack              ; and move onto next slot                                             ; 
JCoinRun:  TXA                                                                                      ;  B
CLC                           ; add 13 bytes to offset for next subroutine                          ; 
ADC #$0d                                                                                            ; 
TAX                                                                                                 ; 
LDA #$50                      ; set downward movement amount                                        ; 
STA $00                                                                                             ; 
LDA #$06                      ; set maximum vertical speed                                          ; 
STA $02                                                                                             ; 
LSR                           ; divide by 2 and set                                                 ; 
STA $01                       ; as upward movement amount (apparently residual)                     ; 
LDA #$00                      ; set A to impose gravity on jumping coin                             ; 
JSR ImposeGravity             ; do sub to move coin vertically and impose gravity on it             ; 
LDX ObjectOffset              ; get original misc object offset                                     ; 
LDA Misc_Y_Speed,X            ; check vertical speed                                                ; 
CMP #$05                                                                                            ; 
BNE RunJCSubs                 ; if not moving downward fast enough, keep state as-is                ; 
INC Misc_State,X              ; otherwise increment state to change to floatey number               ;  B
RunJCSubs:  JSR RelativeMiscPosition; get relative coordinates                                      ;  B
JSR GetMiscOffscreenBits      ; get offscreen information                                           ; 
JSR GetMiscBoundBox           ; get bounding box coordinates (why?)                                 ; 
JSR JCoinGfxHandler           ; draw the coin or floatey number                                     ; 
                                                                                                    ; 
MiscLoopBack:                                                                                       ;  B
DEX                           ; decrement misc object offset                                        ; 
BPL MiscLoop                  ; loop back until all misc objects handled                            ; 
RTS                           ; then leave                                                          ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
CoinTallyOffsets:                                                                                   ;  B
DATA: ByteValue(value=23), ByteValue(value=29)                                                      ; 
                                                                                                    ; 
ScoreOffsets:                                                                                       ;  B
DATA: ByteValue(value=11), ByteValue(value=17)                                                      ; 
                                                                                                    ; 
StatusBarNybbles:                                                                                   ;  B
DATA: ByteValue(value=2), ByteValue(value=19)                                                       ; 
                                                                                                    ; 
GiveOneCoin:                                                                                        ; fun():  B
LDA #$01                      ; set digit modifier to add 1 coin                                    ; 
STA DigitModifier+5           ; to the current player's coin tally                                  ; 
LDX CurrentPlayer             ; get current player on the screen                                    ; 
LDY CoinTallyOffsets,X        ; get offset for player's coin tally                                  ; 
JSR DigitsMathRoutine         ; update the coin tally                                               ; 
INC CoinTally                 ; increment onscreen player's coin amount                             ; 
LDA CoinTally                                                                                       ; 
CMP #100                      ; does player have 100 coins yet?                                     ; 
BNE CoinPoints                ; if not, skip all of this                                            ; 
LDA #$00                                                                                            ;  B
STA CoinTally                 ; otherwise, reinitialize coin amount                                 ; 
INC NumberofLives             ; give the player an extra life                                       ; 
LDA #Sfx_ExtraLife                                                                                  ; 
STA Square2SoundQueue         ; play 1-up sound                                                     ; 
                                                                                                    ; 
CoinPoints:                                                                                         ;  B
LDA #$02                      ; set digit modifier to award                                         ; 
STA DigitModifier+4           ; 200 points to the player                                            ; 
                                                                                                    ; 
AddToScore:                                                                                         ; fun():  B
LDX CurrentPlayer             ; get current player                                                  ; 
LDY ScoreOffsets,X            ; get offset for player's score                                       ; 
JSR DigitsMathRoutine         ; update the score internally with value in digit modifier            ; 
                                                                                                    ; 
GetSBNybbles:                                                                                       ; fun():  B
LDY CurrentPlayer             ; get current player                                                  ; 
LDA StatusBarNybbles,Y        ; get nybbles based on player, use to update score and coins          ; 
                                                                                                    ; 
UpdateNumber:                                                                                       ; fun():  B
JSR PrintStatusBarNumbers     ; print status bar numbers based on nybbles, whatever they be         ; 
LDY VRAM_Buffer1_Offset                                                                             ; 
LDA VRAM_Buffer1-6,Y          ; check highest digit of score                                        ; 
BNE NoZSup                    ; if zero, overwrite with space tile for zero suppression             ; 
LDA #$24                                                                                            ;  B
STA VRAM_Buffer1-6,Y                                                                                ; 
NoZSup:  LDX ObjectOffset     ; get enemy object buffer offset                                      ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
SetupPowerUp:                                                                                       ;  B
LDA #PowerUpObject            ; load power-up identifier into                                       ; 
STA Enemy_ID+5                ; special use slot of enemy object buffer                             ; 
LDA Block_PageLoc,X           ; store page location of block object                                 ; 
STA Enemy_PageLoc+5           ; as page location of power-up object                                 ; 
LDA Block_X_Position,X        ; store horizontal coordinate of block object                         ; 
STA Enemy_X_Position+5        ; as horizontal coordinate of power-up object                         ; 
LDA #$01                                                                                            ; 
STA Enemy_Y_HighPos+5         ; set vertical high byte of power-up object                           ; 
LDA Block_Y_Position,X        ; get vertical coordinate of block object                             ; 
SEC                                                                                                 ; 
SBC #$08                      ; subtract 8 pixels                                                   ; 
STA Enemy_Y_Position+5        ; and use as vertical coordinate of power-up object                   ; 
PwrUpJmp:  LDA #$01           ; this is a residual jump point in enemy object jump table            ;  B
STA Enemy_State+5             ; set power-up object's state                                         ; 
STA Enemy_Flag+5              ; set buffer flag                                                     ; 
LDA #$03                                                                                            ; 
STA Enemy_BoundBoxCtrl+5      ; set bounding box size control for power-up object                   ; 
LDA PowerUpType                                                                                     ; 
CMP #$02                      ; check currently loaded power-up type                                ; 
BCS PutBehind                 ; if star or 1-up, branch ahead                                       ; 
LDA PlayerStatus              ; otherwise check player's current status                             ;  B
CMP #$02                                                                                            ; 
BCC StrType                   ; if player not fiery, use status as power-up type                    ; 
LSR                           ; otherwise shift right to force fire flower type                     ;  B
StrType:  STA PowerUpType     ; store type here                                                     ;  B
PutBehind:  LDA #%00100000                                                                          ;  B
STA Enemy_SprAttrib+5         ; set background priority bit                                         ; 
LDA #Sfx_GrowPowerUp                                                                                ; 
STA Square2SoundQueue         ; load power-up reveal sound and leave                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PowerUpObjHandler:                                                                                  ;  B
LDX #$05                      ; set object offset for last slot in enemy object buffer              ; 
STX ObjectOffset                                                                                    ; 
LDA Enemy_State+5             ; check power-up object's state                                       ; 
BEQ ExitPUp                   ; if not set, branch to leave                                         ; 
ASL                           ; shift to check if d7 was set in object state                        ;  B
BCC GrowThePowerUp            ; if not set, branch ahead to skip this part                          ; 
LDA TimerControl              ; if master timer control set,                                        ;  B
BNE RunPUSubs                 ; branch ahead to enemy object routines                               ; 
LDA PowerUpType               ; check power-up type                                                 ;  B
BEQ ShroomM                   ; if normal mushroom, branch ahead to move it                         ; 
CMP #$03                                                                                            ;  B
BEQ ShroomM                   ; if 1-up mushroom, branch ahead to move it                           ; 
CMP #$02                                                                                            ;  B
BNE RunPUSubs                 ; if not star, branch elsewhere to skip movement                      ; 
JSR MoveJumpingEnemy          ; otherwise impose gravity on star power-up and make it jump          ;  B
JSR EnemyJump                 ; note that green paratroopa shares the same code here                ; 
JMP RunPUSubs                 ; then jump to other power-up subroutines                             ; 
ShroomM:  JSR MoveNormalEnemy ; do sub to make mushrooms move                                       ;  B
JSR EnemyToBGCollisionDet     ; deal with collisions                                                ; 
JMP RunPUSubs                 ; run the other subroutines                                           ; 
                                                                                                    ;  B
GrowThePowerUp:                                                                                     ;  B
LDA FrameCounter              ; get frame counter                                                   ; 
AND #$03                      ; mask out all but 2 LSB                                              ; 
BNE ChkPUSte                  ; if any bits set here, branch                                        ; 
DEC Enemy_Y_Position+5        ; otherwise decrement vertical coordinate slowly                      ;  B
LDA Enemy_State+5             ; load power-up object state                                          ; 
INC Enemy_State+5             ; increment state for next frame (to make power-up rise)              ; 
CMP #$11                      ; if power-up object state not yet past 16th pixel,                   ; 
BCC ChkPUSte                  ; branch ahead to last part here                                      ; 
LDA #$10                                                                                            ;  B
STA Enemy_X_Speed,X           ; otherwise set horizontal speed                                      ; 
LDA #%10000000                                                                                      ; 
STA Enemy_State+5             ; and then set d7 in power-up object's state                          ; 
ASL                           ; shift once to init A                                                ; 
STA Enemy_SprAttrib+5         ; initialize background priority bit set here                         ; 
ROL                           ; rotate A to set right moving direction                              ; 
STA Enemy_MovingDir,X         ; set moving direction                                                ; 
ChkPUSte:  LDA Enemy_State+5  ; check power-up object's state                                       ;  B
CMP #$06                      ; for if power-up has risen enough                                    ; 
BCC ExitPUp                   ; if not, don't even bother running these routines                    ; 
RunPUSubs:  JSR RelativeEnemyPosition; get coordinates relative to screen                           ;  B
JSR GetEnemyOffscreenBits     ; get offscreen bits                                                  ; 
JSR GetEnemyBoundBox          ; get bounding box coordinates                                        ; 
JSR DrawPowerUp               ; draw the power-up object                                            ; 
JSR PlayerEnemyCollision      ; check for collision with player                                     ; 
JSR OffscreenBoundsCheck      ; check to see if it went offscreen                                   ; 
ExitPUp:  RTS                 ; and we're done                                                      ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; These apply to all routines in this section unless otherwise noted: ; 
                              ; $00 - used to store metatile from block buffer routine              ; 
                              ; $02 - used to store vertical high nybble offset from block buffer routine; 
                              ; $05 - used to store metatile stored in A at beginning of PlayerHeadCollision; 
                              ; $06-$07 - used as block buffer address indirect                     ; 
                                                                                                    ; 
BlockYPosAdderData:                                                                                 ;  B
DATA: ByteValue(value=4), ByteValue(value=18)                                                       ; 
                                                                                                    ; 
PlayerHeadCollision:                                                                                ; fun(A$02$06CarryFlag):  B
PHA                           ; store metatile number to stack                                      ; 
LDA #$11                      ; load unbreakable block object state by default                      ; 
LDX SprDataOffset_Ctrl        ; load offset control bit here                                        ; 
LDY PlayerSize                ; check player's size                                                 ; 
BNE DBlockSte                 ; if small, branch                                                    ; 
LDA #$12                      ; otherwise load breakable block object state                         ;  B
DBlockSte:  STA Block_State,X ; store into block object buffer                                      ;  B
JSR DestroyBlockMetatile      ; store blank metatile in vram buffer to write to name table          ; 
LDX SprDataOffset_Ctrl        ; load offset control bit                                             ; 
LDA $02                       ; get vertical high nybble offset used in block buffer routine        ; 
STA Block_Orig_YPos,X         ; set as vertical coordinate for block object                         ; 
TAY                                                                                                 ; 
LDA $06                       ; get low byte of block buffer address used in same routine           ; 
STA Block_BBuf_Low,X          ; save as offset here to be used later                                ; 
LDA ($06),Y                   ; get contents of block buffer at old address at $06, $07             ; 
JSR BlockBumpedChk            ; do a sub to check which block player bumped head on                 ; 
STA $00                       ; store metatile here                                                 ; 
LDY PlayerSize                ; check player's size                                                 ; 
BNE ChkBrick                  ; if small, use metatile itself as contents of A                      ; 
TYA                           ; otherwise init A (note: big = 0)                                    ;  B
ChkBrick:  BCC PutMTileB      ; if no match was found in previous sub, skip ahead                   ;  B
LDY #$11                      ; otherwise load unbreakable state into block object buffer           ;  B
STY Block_State,X             ; note this applies to both player sizes                              ; 
LDA #$c4                      ; load empty block metatile into A for now                            ; 
LDY $00                       ; get metatile from before                                            ; 
CPY #$58                      ; is it brick with coins (with line)?                                 ; 
BEQ StartBTmr                 ; if so, branch                                                       ; 
CPY #$5d                      ; is it brick with coins (without line)?                              ;  B
BNE PutMTileB                 ; if not, branch ahead to store empty block metatile                  ; 
StartBTmr:  LDA BrickCoinTimerFlag; check brick coin timer flag                                     ;  B
BNE ContBTmr                  ; if set, timer expired or counting down, thus branch                 ; 
LDA #$0b                                                                                            ;  B
STA BrickCoinTimer            ; if not set, set brick coin timer                                    ; 
INC BrickCoinTimerFlag        ; and set flag linked to it                                           ; 
ContBTmr:  LDA BrickCoinTimer ; check brick coin timer                                              ;  B
BNE PutOldMT                  ; if not yet expired, branch to use current metatile                  ; 
LDY #$c4                      ; otherwise use empty block metatile                                  ;  B
PutOldMT:  TYA                ; put metatile into A                                                 ;  B
PutMTileB:  STA Block_Metatile,X; store whatever metatile be appropriate here                       ;  B
JSR InitBlock_XY_Pos          ; get block object horizontal coordinates saved                       ; 
LDY $02                       ; get vertical high nybble offset                                     ; 
LDA #$23                                                                                            ; 
STA ($06),Y                   ; write blank metatile $23 to block buffer                            ; 
LDA #$10                                                                                            ; 
STA BlockBounceTimer          ; set block bounce timer                                              ; 
PLA                           ; pull original metatile from stack                                   ; 
STA $05                       ; and save here                                                       ; 
LDY #$00                      ; set default offset                                                  ; 
LDA CrouchingFlag             ; is player crouching?                                                ; 
BNE SmallBP                   ; if so, branch to increment offset                                   ; 
LDA PlayerSize                ; is player big?                                                      ;  B
BEQ BigBP                     ; if so, branch to use default offset                                 ; 
SmallBP:  INY                 ; increment for small or big and crouching                            ;  B
BigBP:  LDA Player_Y_Position ; get player's vertical coordinate                                    ;  B
CLC                                                                                                 ; 
ADC BlockYPosAdderData,Y      ; add value determined by size                                        ; 
AND #$f0                      ; mask out low nybble to get 16-pixel correspondence                  ; 
STA Block_Y_Position,X        ; save as vertical coordinate for block object                        ; 
LDY Block_State,X             ; get block object state                                              ; 
CPY #$11                                                                                            ; 
BEQ Unbreak                   ; if set to value loaded for unbreakable, branch                      ; 
JSR BrickShatter              ; execute code for breakable brick                                    ;  B
JMP InvOBit                   ; skip subroutine to do last part of code here                        ; 
Unbreak:  JSR BumpBlock       ; execute code for unbreakable brick or question block                ;  B
InvOBit:  LDA SprDataOffset_Ctrl; invert control bit used by block objects                          ;  B
EOR #$01                      ; and floatey numbers                                                 ; 
STA SprDataOffset_Ctrl                                                                              ; 
RTS                           ; leave!                                                              ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitBlock_XY_Pos:                                                                                   ; fun():  B
LDA Player_X_Position         ; get player's horizontal coordinate                                  ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
AND #$f0                      ; mask out low nybble to give 16-pixel correspondence                 ; 
STA Block_X_Position,X        ; save as horizontal coordinate for block object                      ; 
LDA Player_PageLoc                                                                                  ; 
ADC #$00                      ; add carry to page location of player                                ; 
STA Block_PageLoc,X           ; save as page location of block object                               ; 
STA Block_PageLoc2,X          ; save elsewhere to be used later                                     ; 
LDA Player_Y_HighPos                                                                                ; 
STA Block_Y_HighPos,X         ; save vertical high byte of player into                              ; 
RTS                           ; vertical high byte of block object and leave                        ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BumpBlock:                                                                                          ; fun($05CarryFlagY):  B
JSR CheckTopOfBlock           ; check to see if there's a coin directly above this block            ; 
LDA #Sfx_Bump                                                                                       ; 
STA Square1SoundQueue         ; play bump sound                                                     ; 
LDA #$00                                                                                            ; 
STA Block_X_Speed,X           ; initialize horizontal speed for block object                        ; 
STA Block_Y_MoveForce,X       ; init fractional movement force                                      ; 
STA Player_Y_Speed            ; init player's vertical speed                                        ; 
LDA #$fe                                                                                            ; 
STA Block_Y_Speed,X           ; set vertical speed for block object                                 ; 
LDA $05                       ; get original metatile from stack                                    ; 
JSR BlockBumpedChk            ; do a sub to check which block player bumped head on                 ; 
BCC ExitBlockChk              ; if no match was found, branch to leave                              ; 
TYA                           ; move block number to A                                              ;  B
CMP #$09                      ; if block number was within 0-8 range,                               ; 
BCC BlockCode                 ; branch to use current number                                        ; 
SBC #$05                      ; otherwise subtract 5 for second set to get proper number            ;  B
BlockCode:  JSR JumpEngine    ; run appropriate subroutine depending on block number                ;  B
                                                                                                    ; 
DATA: Expr(expr=MushFlowerBlock)                                                                    ; 
DATA: Expr(expr=CoinBlock)                                                                          ; 
DATA: Expr(expr=CoinBlock)                                                                          ; 
DATA: Expr(expr=ExtraLifeMushBlock)                                                                 ; 
DATA: Expr(expr=MushFlowerBlock)                                                                    ; 
DATA: Expr(expr=VineBlock)                                                                          ; 
DATA: Expr(expr=StarBlock)                                                                          ; 
DATA: Expr(expr=CoinBlock)                                                                          ; 
DATA: Expr(expr=ExtraLifeMushBlock)                                                                 ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MushFlowerBlock:                                                                                    ;  B
LDA #$00                      ; load mushroom/fire flower into power-up type                        ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
StarBlock:                                                                                          ;  B
LDA #$02                      ; load star into power-up type                                        ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
ExtraLifeMushBlock:                                                                                 ;  B
LDA #$03                      ; load 1-up mushroom into power-up type                               ; 
STA $39                       ; store correct power-up type                                         ; 
JMP SetupPowerUp                                                                                    ; 
                                                                                                    ;  B
VineBlock:                                                                                          ;  B
LDX #$05                      ; load last slot for enemy object buffer                              ; 
LDY SprDataOffset_Ctrl        ; get control bit                                                     ; 
JSR Setup_Vine                ; set up vine object                                                  ; 
                                                                                                    ; 
ExitBlockChk:                                                                                       ;  B
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BrickQBlockMetatiles:                                                                               ;  B
DATA: ByteValue(value=193), ByteValue(value=192), ByteValue(value=95), ByteValue(value=96); used by question blocks; 
                                                                                                    ; 
                              ; these two sets are functionally identical, but look different       ; 
DATA: ByteValue(value=85), ByteValue(value=86), ByteValue(value=87), ByteValue(value=88), ByteValue(value=89); used by ground level types; 
DATA: ByteValue(value=90), ByteValue(value=91), ByteValue(value=92), ByteValue(value=93), ByteValue(value=94); used by other level types; 
                                                                                                    ; 
BlockBumpedChk:                                                                                     ; fun(A): CarryFlag B
LDY #$0d                      ; start at end of metatile data                                       ; 
BumpChkLoop:  CMP BrickQBlockMetatiles,Y; check to see if current metatile matches                  ;  B
BEQ MatchBump                 ; metatile found in block buffer, branch if so                        ; 
DEY                           ; otherwise move onto next metatile                                   ;  B
BPL BumpChkLoop               ; do this until all metatiles are checked                             ; 
CLC                           ; if none match, return with carry clear                              ;  B
MatchBump:  RTS               ; note carry is set if found match                                    ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BrickShatter:                                                                                       ; fun():  B
JSR CheckTopOfBlock           ; check to see if there's a coin directly above this block            ; 
LDA #Sfx_BrickShatter                                                                               ; 
STA Block_RepFlag,X           ; set flag for block object to immediately replace metatile           ; 
STA NoiseSoundQueue           ; load brick shatter sound                                            ; 
JSR SpawnBrickChunks          ; create brick chunk objects                                          ; 
LDA #$fe                                                                                            ; 
STA Player_Y_Speed            ; set vertical speed for player                                       ; 
LDA #$05                                                                                            ; 
STA DigitModifier+5           ; set digit modifier to give player 50 points                         ; 
JSR AddToScore                ; do sub to update the score                                          ; 
LDX SprDataOffset_Ctrl        ; load control bit and leave                                          ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
CheckTopOfBlock:                                                                                    ; fun($02): CarryFlag B
LDX SprDataOffset_Ctrl        ; load control bit                                                    ; 
LDY $02                       ; get vertical high nybble offset used in block buffer                ; 
BEQ TopEx                     ; branch to leave if set to zero, because we're at the top            ; 
TYA                           ; otherwise set to A                                                  ;  B
SEC                                                                                                 ; 
SBC #$10                      ; subtract $10 to move up one row in the block buffer                 ; 
STA $02                       ; store as new vertical high nybble offset                            ; 
TAY                                                                                                 ; 
LDA ($06),Y                   ; get contents of block buffer in same column, one row up             ; 
CMP #$c2                      ; is it a coin? (not underwater)                                      ; 
BNE TopEx                     ; if not, branch to leave                                             ; 
LDA #$00                                                                                            ;  B
STA ($06),Y                   ; otherwise put blank metatile where coin was                         ; 
JSR RemoveCoin_Axe            ; write blank metatile to vram buffer                                 ; 
LDX SprDataOffset_Ctrl        ; get control bit                                                     ; 
JSR SetupJumpCoin             ; create jumping coin object and update coin variables                ; 
TopEx:  RTS                   ; leave!                                                              ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
SpawnBrickChunks:                                                                                   ; fun():  B
LDA Block_X_Position,X        ; set horizontal coordinate of block object                           ; 
STA Block_Orig_XPos,X         ; as original horizontal coordinate here                              ; 
LDA #$f0                                                                                            ; 
STA Block_X_Speed,X           ; set horizontal speed for brick chunk objects                        ; 
STA Block_X_Speed+2,X                                                                               ; 
LDA #$fa                                                                                            ; 
STA Block_Y_Speed,X           ; set vertical speed for one                                          ; 
LDA #$fc                                                                                            ; 
STA Block_Y_Speed+2,X         ; set lower vertical speed for the other                              ; 
LDA #$00                                                                                            ; 
STA Block_Y_MoveForce,X       ; init fractional movement force for both                             ; 
STA Block_Y_MoveForce+2,X                                                                           ; 
LDA Block_PageLoc,X                                                                                 ; 
STA Block_PageLoc+2,X         ; copy page location                                                  ; 
LDA Block_X_Position,X                                                                              ; 
STA Block_X_Position+2,X      ; copy horizontal coordinate                                          ; 
LDA Block_Y_Position,X                                                                              ; 
CLC                           ; add 8 pixels to vertical coordinate                                 ; 
ADC #$08                      ; and save as vertical coordinate for one of them                     ; 
STA Block_Y_Position+2,X                                                                            ; 
LDA #$fa                                                                                            ; 
STA Block_Y_Speed,X           ; set vertical speed...again??? (redundant)                           ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
BlockObjectsCore:                                                                                   ; fun(X): X B
LDA Block_State,X             ; get state of block object                                           ; 
BEQ UpdSte                    ; if not set, branch to leave                                         ; 
AND #$0f                      ; mask out high nybble                                                ;  B
PHA                           ; push to stack                                                       ; 
TAY                           ; put in Y for now                                                    ; 
TXA                                                                                                 ; 
CLC                                                                                                 ; 
ADC #$09                      ; add 9 bytes to offset (note two block objects are created           ; 
TAX                           ; when using brick chunks, but only one offset for both)              ; 
DEY                           ; decrement Y to check for solid block state                          ; 
BEQ BouncingBlockHandler      ; branch if found, otherwise continue for brick chunks                ; 
JSR ImposeGravityBlock        ; do sub to impose gravity on one block object object                 ;  B
JSR MoveObjectHorizontally    ; do another sub to move horizontally                                 ; 
TXA                                                                                                 ; 
CLC                           ; move onto next block object                                         ; 
ADC #$02                                                                                            ; 
TAX                                                                                                 ; 
JSR ImposeGravityBlock        ; do sub to impose gravity on other block object                      ; 
JSR MoveObjectHorizontally    ; do another sub to move horizontally                                 ; 
LDX ObjectOffset              ; get block object offset used for both                               ; 
JSR RelativeBlockPosition     ; get relative coordinates                                            ; 
JSR GetBlockOffscreenBits     ; get offscreen information                                           ; 
JSR DrawBrickChunks           ; draw the brick chunks                                               ; 
PLA                           ; get lower nybble of saved state                                     ; 
LDY Block_Y_HighPos,X         ; check vertical high byte of block object                            ; 
BEQ UpdSte                    ; if above the screen, branch to kill it                              ; 
PHA                           ; otherwise save state back into stack                                ;  B
LDA #$f0                                                                                            ; 
CMP Block_Y_Position+2,X      ; check to see if bottom block object went                            ; 
BCS ChkTop                    ; to the bottom of the screen, and branch if not                      ; 
STA Block_Y_Position+2,X      ; otherwise set offscreen coordinate                                  ;  B
ChkTop:  LDA Block_Y_Position,X; get top block object's vertical coordinate                         ;  B
CMP #$f0                      ; see if it went to the bottom of the screen                          ; 
PLA                           ; pull block object state from stack                                  ; 
BCC UpdSte                    ; if not, branch to save state                                        ; 
BCS KillBlock                 ; otherwise do unconditional branch to kill it                        ;  B
                                                                                                    ;  B
BouncingBlockHandler:                                                                               ;  B
JSR ImposeGravityBlock        ; do sub to impose gravity on block object                            ; 
LDX ObjectOffset              ; get block object offset                                             ; 
JSR RelativeBlockPosition     ; get relative coordinates                                            ; 
JSR GetBlockOffscreenBits     ; get offscreen information                                           ; 
JSR DrawBlock                 ; draw the block                                                      ; 
LDA Block_Y_Position,X        ; get vertical coordinate                                             ; 
AND #$0f                      ; mask out high nybble                                                ; 
CMP #$05                      ; check to see if low nybble wrapped around                           ; 
PLA                           ; pull state from stack                                               ; 
BCS UpdSte                    ; if still above amount, not time to kill block yet, thus branch      ; 
LDA #$01                                                                                            ;  B
STA Block_RepFlag,X           ; otherwise set flag to replace metatile                              ; 
KillBlock:  LDA #$00          ; if branched here, nullify object state                              ;  B
UpdSte:  STA Block_State,X    ; store contents of A in block object state                           ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $02 - used to store offset to block buffer                          ; 
                              ; $06-$07 - used to store block buffer address                        ; 
                                                                                                    ; 
BlockObjMT_Updater:                                                                                 ; fun():  B
LDX #$01                      ; set offset to start with second block object                        ; 
UpdateLoop:  STX ObjectOffset ; set offset here                                                     ;  B
LDA VRAM_Buffer1              ; if vram buffer already being used here,                             ; 
BNE NextBUpd                  ; branch to move onto next block object                               ; 
LDA Block_RepFlag,X           ; if flag for block object already clear,                             ;  B
BEQ NextBUpd                  ; branch to move onto next block object                               ; 
LDA Block_BBuf_Low,X          ; get low byte of block buffer                                        ;  B
STA $06                       ; store into block buffer address                                     ; 
LDA #$05                                                                                            ; 
STA $07                       ; set high byte of block buffer address                               ; 
LDA Block_Orig_YPos,X         ; get original vertical coordinate of block object                    ; 
STA $02                       ; store here and use as offset to block buffer                        ; 
TAY                                                                                                 ; 
LDA Block_Metatile,X          ; get metatile to be written                                          ; 
STA ($06),Y                   ; write it to the block buffer                                        ; 
JSR ReplaceBlockMetatile      ; do sub to replace metatile where block object is                    ; 
LDA #$00                                                                                            ; 
STA Block_RepFlag,X           ; clear block object flag                                             ; 
NextBUpd:  DEX                ; decrement block object offset                                       ;  B
BPL UpdateLoop                ; do this until both block objects are dealt with                     ; 
RTS                           ; then leave                                                          ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to store high nybble of horizontal speed as adder        ; 
                              ; $01 - used to store low nybble of horizontal speed                  ; 
                              ; $02 - used to store adder to page location                          ; 
                                                                                                    ; 
MoveEnemyHorizontally:                                                                              ; fun(X):  B
INX                           ; increment offset for enemy offset                                   ; 
JSR MoveObjectHorizontally    ; position object horizontally according to                           ; 
LDX ObjectOffset              ; counters, return with saved value in A,                             ; 
RTS                           ; put enemy offset back in X and leave                                ; 
                                                                                                    ;  B
MovePlayerHorizontally:                                                                             ; fun(): A B
LDA JumpspringAnimCtrl        ; if jumpspring currently animating,                                  ; 
BNE ExXMove                   ; branch to leave                                                     ; 
TAX                           ; otherwise set zero for offset to use player's stuff                 ;  B
                                                                                                    ; 
MoveObjectHorizontally:                                                                             ; fun():  B
LDA SprObject_X_Speed,X       ; get currently saved value (horizontal                               ; 
ASL                           ; speed, secondary counter, whatever)                                 ; 
ASL                           ; and move low nybble to high                                         ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
STA $01                       ; store result here                                                   ; 
LDA SprObject_X_Speed,X       ; get saved value again                                               ; 
LSR                           ; move high nybble to low                                             ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
CMP #$08                      ; if < 8, branch, do not change                                       ; 
BCC SaveXSpd                                                                                        ; 
ORA #%11110000                ; otherwise alter high nybble                                         ;  B
SaveXSpd:  STA $00            ; save result here                                                    ;  B
LDY #$00                      ; load default Y value here                                           ; 
CMP #$00                      ; if result positive, leave Y alone                                   ; 
BPL UseAdder                                                                                        ; 
DEY                           ; otherwise decrement Y                                               ;  B
UseAdder:  STY $02            ; save Y here                                                         ;  B
LDA SprObject_X_MoveForce,X   ; get whatever number's here                                          ; 
CLC                                                                                                 ; 
ADC $01                       ; add low nybble moved to high                                        ; 
STA SprObject_X_MoveForce,X   ; store result here                                                   ; 
LDA #$00                      ; init A                                                              ; 
ROL                           ; rotate carry into d0                                                ; 
PHA                           ; push onto stack                                                     ; 
ROR                           ; rotate d0 back onto carry                                           ; 
LDA SprObject_X_Position,X                                                                          ; 
ADC $00                       ; add carry plus saved value (high nybble moved to low                ; 
STA SprObject_X_Position,X    ; plus $f0 if necessary) to object's horizontal position              ; 
LDA SprObject_PageLoc,X                                                                             ; 
ADC $02                       ; add carry plus other saved value to the                             ; 
STA SprObject_PageLoc,X       ; object's page location and save                                     ; 
PLA                                                                                                 ; 
CLC                           ; pull old carry from stack and add                                   ; 
ADC $00                       ; to high nybble moved to low                                         ; 
ExXMove:  RTS                 ; and leave                                                           ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used for downward force                                       ; 
                              ; $01 - used for upward force                                         ; 
                              ; $02 - used for maximum vertical speed                               ; 
                                                                                                    ; 
MovePlayerVertically:                                                                               ;  B
LDX #$00                      ; set X for player offset                                             ; 
LDA TimerControl                                                                                    ; 
BNE NoJSChk                   ; if master timer control set, branch ahead                           ; 
LDA JumpspringAnimCtrl        ; otherwise check to see if jumpspring is animating                   ;  B
BNE ExXMove                   ; branch to leave if so                                               ; 
NoJSChk:  LDA VerticalForce   ; dump vertical force                                                 ;  B
STA $00                                                                                             ; 
LDA #$04                      ; set maximum vertical speed here                                     ; 
JMP ImposeGravitySprObj       ; then jump to move player vertically                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveD_EnemyVertically:                                                                              ; fun():  B
LDY #$3d                      ; set quick movement amount downwards                                 ; 
LDA Enemy_State,X             ; then check enemy state                                              ; 
CMP #$05                      ; if not set to unique state for spiny's egg, go ahead                ; 
BNE ContVMove                 ; and use, otherwise set different movement amount, continue on       ; 
                                                                                                    ;  B
MoveFallingPlatform:                                                                                ; fun():  B
LDY #$20                      ; set movement amount                                                 ; 
ContVMove:  JMP SetHiMax      ; jump to skip the rest of this                                       ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveRedPTroopaDown:                                                                                 ;  B
LDY #$00                      ; set Y to move downwards                                             ; 
JMP MoveRedPTroopa            ; skip to movement routine                                            ; 
                                                                                                    ;  B
MoveRedPTroopaUp:                                                                                   ;  B
LDY #$01                      ; set Y to move upwards                                               ; 
                                                                                                    ; 
MoveRedPTroopa:                                                                                     ;  B
INX                           ; increment X for enemy offset                                        ; 
LDA #$03                                                                                            ; 
STA $00                       ; set downward movement amount here                                   ; 
LDA #$06                                                                                            ; 
STA $01                       ; set upward movement amount here                                     ; 
LDA #$02                                                                                            ; 
STA $02                       ; set maximum speed here                                              ; 
TYA                           ; set movement direction in A, and                                    ; 
JMP RedPTroopaGrav            ; jump to move this thing                                             ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveDropPlatform:                                                                                   ; fun():  B
LDY #$7f                      ; set movement amount for drop platform                               ; 
BNE SetMdMax                  ; skip ahead of other value set here                                  ; 
                                                                                                    ;  B
MoveEnemySlowVert:                                                                                  ; fun():  B
LDY #$0f                      ; set movement amount for bowser/other objects                        ; 
SetMdMax:  LDA #$02           ; set maximum speed in A                                              ;  B
BNE SetXMoveAmt               ; unconditional branch                                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveJ_EnemyVertically:                                                                              ; fun():  B
LDY #$1c                      ; set movement amount for podoboo/other objects                       ; 
SetHiMax:  LDA #$03           ; set maximum speed in A                                              ;  B
SetXMoveAmt:  STY $00         ; set movement amount here                                            ; fun(YX):  B
INX                           ; increment X for enemy offset                                        ; 
JSR ImposeGravitySprObj       ; do a sub to move enemy object downwards                             ; 
LDX ObjectOffset              ; get enemy object buffer offset and leave                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MaxSpdBlockData:                                                                                    ;  B
DATA: ByteValue(value=6), ByteValue(value=8)                                                        ; 
                                                                                                    ; 
ResidualGravityCode:                                                                                ;  B
LDY #$00                      ; this part appears to be residual,                                   ; 
DATA: ByteValue(value=44)     ; no code branches or jumps to it...                                  ; 
                                                                                                    ; 
ImposeGravityBlock:                                                                                 ; fun():  B
LDY #$01                      ; set offset for maximum speed                                        ; 
LDA #$50                      ; set movement amount here                                            ; 
STA $00                                                                                             ; 
LDA MaxSpdBlockData,Y         ; get maximum speed                                                   ; 
                                                                                                    ; 
ImposeGravitySprObj:                                                                                ; fun(A):  B
STA $02                       ; set maximum speed here                                              ; 
LDA #$00                      ; set value to move downwards                                         ; 
JMP ImposeGravity             ; jump to the code that actually moves it                             ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MovePlatformDown:                                                                                   ; fun():  B
LDA #$00                      ; save value to stack (if branching here, execute next                ; 
DATA: ByteValue(value=44)     ; part as BIT instruction)                                            ; 
                                                                                                    ; 
MovePlatformUp:                                                                                     ; fun(X):  B
LDA #$01                      ; save value to stack                                                 ; 
PHA                                                                                                 ; 
LDY Enemy_ID,X                ; get enemy object identifier                                         ; 
INX                           ; increment offset for enemy object                                   ; 
LDA #$05                      ; load default value here                                             ; 
CPY #$29                      ; residual comparison, object #29 never executes                      ; 
BNE SetDplSpd                 ; this code, thus unconditional branch here                           ; 
LDA #$09                      ; residual code                                                       ;  B
SetDplSpd:  STA $00           ; save downward movement amount here                                  ;  B
LDA #$0a                      ; save upward movement amount here                                    ; 
STA $01                                                                                             ; 
LDA #$03                      ; save maximum vertical speed here                                    ; 
STA $02                                                                                             ; 
PLA                           ; get value from stack                                                ; 
TAY                           ; use as Y, then move onto code shared by red koopa                   ; 
                                                                                                    ; 
RedPTroopaGrav:                                                                                     ;  B
JSR ImposeGravity             ; do a sub to move object gradually                                   ; 
LDX ObjectOffset              ; get enemy object offset and leave                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used for downward force                                       ; 
                              ; $01 - used for upward force                                         ; 
                              ; $07 - used as adder for vertical position                           ; 
                                                                                                    ; 
ImposeGravity:                                                                                      ; fun(A$00$02$01):  B
PHA                           ; push value to stack                                                 ; 
LDA SprObject_YMF_Dummy,X                                                                           ; 
CLC                           ; add value in movement force to contents of dummy variable           ; 
ADC SprObject_Y_MoveForce,X                                                                         ; 
STA SprObject_YMF_Dummy,X                                                                           ; 
LDY #$00                      ; set Y to zero by default                                            ; 
LDA SprObject_Y_Speed,X       ; get current vertical speed                                          ; 
BPL AlterYP                   ; if currently moving downwards, do not decrement Y                   ; 
DEY                           ; otherwise decrement Y                                               ;  B
AlterYP:  STY $07             ; store Y here                                                        ;  B
ADC SprObject_Y_Position,X    ; add vertical position to vertical speed plus carry                  ; 
STA SprObject_Y_Position,X    ; store as new vertical position                                      ; 
LDA SprObject_Y_HighPos,X                                                                           ; 
ADC $07                       ; add carry plus contents of $07 to vertical high byte                ; 
STA SprObject_Y_HighPos,X     ; store as new vertical high byte                                     ; 
LDA SprObject_Y_MoveForce,X                                                                         ; 
CLC                                                                                                 ; 
ADC $00                       ; add downward movement amount to contents of $0433                   ; 
STA SprObject_Y_MoveForce,X                                                                         ; 
LDA SprObject_Y_Speed,X       ; add carry to vertical speed and store                               ; 
ADC #$00                                                                                            ; 
STA SprObject_Y_Speed,X                                                                             ; 
CMP $02                       ; compare to maximum speed                                            ; 
BMI ChkUpM                    ; if less than preset value, skip this part                           ; 
LDA SprObject_Y_MoveForce,X                                                                         ;  B
CMP #$80                      ; if less positively than preset maximum, skip this part              ; 
BCC ChkUpM                                                                                          ; 
LDA $02                                                                                             ;  B
STA SprObject_Y_Speed,X       ; keep vertical speed within maximum value                            ; 
LDA #$00                                                                                            ; 
STA SprObject_Y_MoveForce,X   ; clear fractional                                                    ; 
ChkUpM:  PLA                  ; get value from stack                                                ;  B
BEQ ExVMove                   ; if set to zero, branch to leave                                     ; 
LDA $02                                                                                             ;  B
EOR #%11111111                ; otherwise get two's compliment of maximum speed                     ; 
TAY                                                                                                 ; 
INY                                                                                                 ; 
STY $07                       ; store two's compliment here                                         ; 
LDA SprObject_Y_MoveForce,X                                                                         ; 
SEC                           ; subtract upward movement amount from contents                       ; 
SBC $01                       ; of movement force, note that $01 is twice as large as $00,          ; 
STA SprObject_Y_MoveForce,X   ; thus it effectively undoes add we did earlier                       ; 
LDA SprObject_Y_Speed,X                                                                             ; 
SBC #$00                      ; subtract borrow from vertical speed and store                       ; 
STA SprObject_Y_Speed,X                                                                             ; 
CMP $07                       ; compare vertical speed to two's compliment                          ; 
BPL ExVMove                   ; if less negatively than preset maximum, skip this part              ; 
LDA SprObject_Y_MoveForce,X                                                                         ;  B
CMP #$80                      ; check if fractional part is above certain amount,                   ; 
BCS ExVMove                   ; and if so, branch to leave                                          ; 
LDA $07                                                                                             ;  B
STA SprObject_Y_Speed,X       ; keep vertical speed within maximum value                            ; 
LDA #$ff                                                                                            ; 
STA SprObject_Y_MoveForce,X   ; clear fractional                                                    ; 
ExVMove:  RTS                 ; leave!                                                              ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
EnemiesAndLoopsCore:                                                                                ; fun(): X B
LDA Enemy_Flag,X              ; check data here for MSB set                                         ; 
PHA                           ; save in stack                                                       ; 
ASL                                                                                                 ; 
BCS ChkBowserF                ; if MSB set in enemy flag, branch ahead of jumps                     ; 
PLA                           ; get from stack                                                      ;  B
BEQ ChkAreaTsk                ; if data zero, branch                                                ; 
JMP RunEnemyObjectsCore       ; otherwise, jump to run enemy subroutines                            ;  B
ChkAreaTsk:  LDA AreaParserTaskNum; check number of tasks to perform                                ;  B
AND #$07                                                                                            ; 
CMP #$07                      ; if at a specific task, jump and leave                               ; 
BEQ ExitELCore                                                                                      ; 
JMP ProcLoopCommand           ; otherwise, jump to process loop command/load enemies                ;  B
ChkBowserF:  PLA              ; get data from stack                                                 ;  B
AND #%00001111                ; mask out high nybble                                                ; 
TAY                                                                                                 ; 
LDA Enemy_Flag,Y              ; use as pointer and load same place with different offset            ; 
BNE ExitELCore                                                                                      ; 
STA Enemy_Flag,X              ; if second enemy flag not set, also clear first one                  ;  B
ExitELCore:  RTS                                                                                    ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
                              ; loop command data                                                   ; 
LoopCmdWorldNumber:                                                                                 ;  B
DATA: ByteValue(value=3), ByteValue(value=3), ByteValue(value=6), ByteValue(value=6), ByteValue(value=6), ByteValue(value=6), ByteValue(value=6), ByteValue(value=6), ByteValue(value=7), ByteValue(value=7), ByteValue(value=7); 
                                                                                                    ; 
LoopCmdPageNumber:                                                                                  ;  B
DATA: ByteValue(value=5), ByteValue(value=9), ByteValue(value=4), ByteValue(value=5), ByteValue(value=6), ByteValue(value=8), ByteValue(value=9), ByteValue(value=10), ByteValue(value=6), ByteValue(value=11), ByteValue(value=16); 
                                                                                                    ; 
LoopCmdYPosition:                                                                                   ;  B
DATA: ByteValue(value=64), ByteValue(value=176), ByteValue(value=176), ByteValue(value=128), ByteValue(value=64), ByteValue(value=64), ByteValue(value=128), ByteValue(value=64), ByteValue(value=240), ByteValue(value=240), ByteValue(value=240); 
                                                                                                    ; 
ExecGameLoopback:                                                                                   ; fun():  B
LDA Player_PageLoc            ; send player back four pages                                         ; 
SEC                                                                                                 ; 
SBC #$04                                                                                            ; 
STA Player_PageLoc                                                                                  ; 
LDA CurrentPageLoc            ; send current page back four pages                                   ; 
SEC                                                                                                 ; 
SBC #$04                                                                                            ; 
STA CurrentPageLoc                                                                                  ; 
LDA ScreenLeft_PageLoc        ; subtract four from page location                                    ; 
SEC                           ; of screen's left border                                             ; 
SBC #$04                                                                                            ; 
STA ScreenLeft_PageLoc                                                                              ; 
LDA ScreenRight_PageLoc       ; do the same for the page location                                   ; 
SEC                           ; of screen's right border                                            ; 
SBC #$04                                                                                            ; 
STA ScreenRight_PageLoc                                                                             ; 
LDA AreaObjectPageLoc         ; subtract four from page control                                     ; 
SEC                           ; for area objects                                                    ; 
SBC #$04                                                                                            ; 
STA AreaObjectPageLoc                                                                               ; 
LDA #$00                      ; initialize page select for both                                     ; 
STA EnemyObjectPageSel        ; area and enemy objects                                              ; 
STA AreaObjectPageSel                                                                               ; 
STA EnemyDataOffset           ; initialize enemy object data offset                                 ; 
STA EnemyObjectPageLoc        ; and enemy object page control                                       ; 
LDA AreaDataOfsLoopback,Y     ; adjust area object offset based on                                  ; 
STA AreaDataOffset            ; which loop command we encountered                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ProcLoopCommand:                                                                                    ;  B
LDA LoopCommand               ; check if loop command was found                                     ; 
BEQ ChkEnemyFrenzy                                                                                  ; 
LDA CurrentColumnPos          ; check to see if we're still on the first page                       ;  B
BNE ChkEnemyFrenzy            ; if not, do not loop yet                                             ; 
LDY #$0b                      ; start at the end of each set of loop data                           ;  B
FindLoop:  DEY                                                                                      ;  B
BMI ChkEnemyFrenzy            ; if all data is checked and not match, do not loop                   ; 
LDA WorldNumber               ; check to see if one of the world numbers                            ;  B
CMP LoopCmdWorldNumber,Y      ; matches our current world number                                    ; 
BNE FindLoop                                                                                        ; 
LDA CurrentPageLoc            ; check to see if one of the page numbers                             ;  B
CMP LoopCmdPageNumber,Y       ; matches the page we're currently on                                 ; 
BNE FindLoop                                                                                        ; 
LDA Player_Y_Position         ; check to see if the player is at the correct position               ;  B
CMP LoopCmdYPosition,Y        ; if not, branch to check for world 7                                 ; 
BNE WrongChk                                                                                        ; 
LDA Player_State              ; check to see if the player is                                       ;  B
CMP #$00                      ; on solid ground (i.e. not jumping or falling)                       ; 
BNE WrongChk                  ; if not, player fails to pass loop, and loopback                     ; 
LDA WorldNumber               ; are we in world 7? (check performed on correct                      ;  B
CMP #World7                   ; vertical position and on solid ground)                              ; 
BNE InitMLp                   ; if not, initialize flags used there, otherwise                      ; 
INC MultiLoopCorrectCntr      ; increment counter for correct progression                           ;  B
IncMLoop:  INC MultiLoopPassCntr; increment master multi-part counter                               ;  B
LDA MultiLoopPassCntr         ; have we done all three parts?                                       ; 
CMP #$03                                                                                            ; 
BNE InitLCmd                  ; if not, skip this part                                              ; 
LDA MultiLoopCorrectCntr      ; if so, have we done them all correctly?                             ;  B
CMP #$03                                                                                            ; 
BEQ InitMLp                   ; if so, branch past unnecessary check here                           ; 
BNE DoLpBack                  ; unconditional branch if previous branch fails                       ;  B
WrongChk:  LDA WorldNumber    ; are we in world 7? (check performed on                              ;  B
CMP #World7                   ; incorrect vertical position or not on solid ground)                 ; 
BEQ IncMLoop                                                                                        ; 
DoLpBack:  JSR ExecGameLoopback; if player is not in right place, loop back                         ;  B
JSR KillAllEnemies                                                                                  ; 
InitMLp:  LDA #$00            ; initialize counters used for multi-part loop commands               ;  B
STA MultiLoopPassCntr                                                                               ; 
STA MultiLoopCorrectCntr                                                                            ; 
InitLCmd:  LDA #$00           ; initialize loop command flag                                        ;  B
STA LoopCommand                                                                                     ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ChkEnemyFrenzy:                                                                                     ;  B
LDA EnemyFrenzyQueue          ; check for enemy object in frenzy queue                              ; 
BEQ ProcessEnemyData          ; if not, skip this part                                              ; 
STA Enemy_ID,X                ; store as enemy object identifier here                               ;  B
LDA #$01                                                                                            ; 
STA Enemy_Flag,X              ; activate enemy object flag                                          ; 
LDA #$00                                                                                            ; 
STA Enemy_State,X             ; initialize state and frenzy queue                                   ; 
STA EnemyFrenzyQueue                                                                                ; 
JMP InitEnemyObject           ; and then jump to deal with this enemy                               ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $06 - used to hold page location of extended right boundary         ; 
                              ; $07 - used to hold high nybble of position of extended right boundary; 
                                                                                                    ; 
ProcessEnemyData:                                                                                   ;  B
LDY EnemyDataOffset           ; get offset of enemy object data                                     ; 
LDA (EnemyData),Y             ; load first byte                                                     ; 
CMP #$ff                      ; check for EOD terminator                                            ; 
BNE CheckEndofBuffer                                                                                ; 
JMP CheckFrenzyBuffer         ; if found, jump to check frenzy buffer, otherwise                    ;  B
                                                                                                    ;  B
CheckEndofBuffer:                                                                                   ;  B
AND #%00001111                ; check for special row $0e                                           ; 
CMP #$0e                                                                                            ; 
BEQ CheckRightBounds          ; if found, branch, otherwise                                         ; 
CPX #$05                      ; check for end of buffer                                             ;  B
BCC CheckRightBounds          ; if not at end of buffer, branch                                     ; 
INY                                                                                                 ;  B
LDA (EnemyData),Y             ; check for specific value here                                       ; 
AND #%00111111                ; not sure what this was intended for, exactly                        ; 
CMP #$2e                      ; this part is quite possibly residual code                           ; 
BEQ CheckRightBounds          ; but it has the effect of keeping enemies out of                     ; 
RTS                           ; the sixth slot                                                      ;  B
                                                                                                    ;  B
CheckRightBounds:                                                                                   ;  B
LDA ScreenRight_X_Pos         ; add 48 to pixel coordinate of right boundary                        ; 
CLC                                                                                                 ; 
ADC #$30                                                                                            ; 
AND #%11110000                ; store high nybble                                                   ; 
STA $07                                                                                             ; 
LDA ScreenRight_PageLoc       ; add carry to page location of right boundary                        ; 
ADC #$00                                                                                            ; 
STA $06                       ; store page location + carry                                         ; 
LDY EnemyDataOffset                                                                                 ; 
INY                                                                                                 ; 
LDA (EnemyData),Y             ; if MSB of enemy object is clear, branch to check for row $0f        ; 
ASL                                                                                                 ; 
BCC CheckPageCtrlRow                                                                                ; 
LDA EnemyObjectPageSel        ; if page select already set, do not set again                        ;  B
BNE CheckPageCtrlRow                                                                                ; 
INC EnemyObjectPageSel        ; otherwise, if MSB is set, set page select                           ;  B
INC EnemyObjectPageLoc        ; and increment page control                                          ; 
                                                                                                    ; 
CheckPageCtrlRow:                                                                                   ;  B
DEY                                                                                                 ; 
LDA (EnemyData),Y             ; reread first byte                                                   ; 
AND #$0f                                                                                            ; 
CMP #$0f                      ; check for special row $0f                                           ; 
BNE PositionEnemyObj          ; if not found, branch to position enemy object                       ; 
LDA EnemyObjectPageSel        ; if page select set,                                                 ;  B
BNE PositionEnemyObj          ; branch without reading second byte                                  ; 
INY                                                                                                 ;  B
LDA (EnemyData),Y             ; otherwise, get second byte, mask out 2 MSB                          ; 
AND #%00111111                                                                                      ; 
STA EnemyObjectPageLoc        ; store as page control for enemy object data                         ; 
INC EnemyDataOffset           ; increment enemy object data offset 2 bytes                          ; 
INC EnemyDataOffset                                                                                 ; 
INC EnemyObjectPageSel        ; set page select for enemy object data and                           ; 
JMP ProcLoopCommand           ; jump back to process loop commands again                            ; 
                                                                                                    ;  B
PositionEnemyObj:                                                                                   ;  B
LDA EnemyObjectPageLoc        ; store page control as page location                                 ; 
STA Enemy_PageLoc,X           ; for enemy object                                                    ; 
LDA (EnemyData),Y             ; get first byte of enemy object                                      ; 
AND #%11110000                                                                                      ; 
STA Enemy_X_Position,X        ; store column position                                               ; 
CMP ScreenRight_X_Pos         ; check column position against right boundary                        ; 
LDA Enemy_PageLoc,X           ; without subtracting, then subtract borrow                           ; 
SBC ScreenRight_PageLoc       ; from page location                                                  ; 
BCS CheckRightExtBounds       ; if enemy object beyond or at boundary, branch                       ; 
LDA (EnemyData),Y                                                                                   ;  B
AND #%00001111                ; check for special row $0e                                           ; 
CMP #$0e                      ; if found, jump elsewhere                                            ; 
BEQ ParseRow0e                                                                                      ; 
JMP CheckThreeBytes           ; if not found, unconditional jump                                    ;  B
                                                                                                    ;  B
CheckRightExtBounds:                                                                                ;  B
LDA $07                       ; check right boundary + 48 against                                   ; 
CMP Enemy_X_Position,X        ; column position without subtracting,                                ; 
LDA $06                       ; then subtract borrow from page control temp                         ; 
SBC Enemy_PageLoc,X           ; plus carry                                                          ; 
BCC CheckFrenzyBuffer         ; if enemy object beyond extended boundary, branch                    ; 
LDA #$01                      ; store value in vertical high byte                                   ;  B
STA Enemy_Y_HighPos,X                                                                               ; 
LDA (EnemyData),Y             ; get first byte again                                                ; 
ASL                           ; multiply by four to get the vertical                                ; 
ASL                           ; coordinate                                                          ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
STA Enemy_Y_Position,X                                                                              ; 
CMP #$e0                      ; do one last check for special row $0e                               ; 
BEQ ParseRow0e                ; (necessary if branched to $c1cb)                                    ; 
INY                                                                                                 ;  B
LDA (EnemyData),Y             ; get second byte of object                                           ; 
AND #%01000000                ; check to see if hard mode bit is set                                ; 
BEQ CheckForEnemyGroup        ; if not, branch to check for group enemy objects                     ; 
LDA SecondaryHardMode         ; if set, check to see if secondary hard mode flag                    ;  B
BEQ Inc2B                     ; is on, and if not, branch to skip this object completely            ; 
                                                                                                    ;  B
CheckForEnemyGroup:                                                                                 ;  B
LDA (EnemyData),Y             ; get second byte and mask out 2 MSB                                  ; 
AND #%00111111                                                                                      ; 
CMP #$37                      ; check for value below $37                                           ; 
BCC BuzzyBeetleMutate                                                                               ; 
CMP #$3f                      ; if $37 or greater, check for value                                  ;  B
BCC DoGroup                   ; below $3f, branch if below $3f                                      ; 
                                                                                                    ;  B
BuzzyBeetleMutate:                                                                                  ;  B
CMP #Goomba                   ; if below $37, check for goomba                                      ; 
BNE StrID                     ; value ($3f or more always fails)                                    ; 
LDY PrimaryHardMode           ; check if primary hard mode flag is set                              ;  B
BEQ StrID                     ; and if so, change goomba to buzzy beetle                            ; 
LDA #BuzzyBeetle                                                                                    ;  B
StrID:  STA Enemy_ID,X        ; store enemy object number into buffer                               ;  B
LDA #$01                                                                                            ; 
STA Enemy_Flag,X              ; set flag for enemy in buffer                                        ; 
JSR InitEnemyObject                                                                                 ; 
LDA Enemy_Flag,X              ; check to see if flag is set                                         ; 
BNE Inc2B                     ; if not, leave, otherwise branch                                     ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
CheckFrenzyBuffer:                                                                                  ;  B
LDA EnemyFrenzyBuffer         ; if enemy object stored in frenzy buffer                             ; 
BNE StrFre                    ; then branch ahead to store in enemy object buffer                   ; 
LDA VineFlagOffset            ; otherwise check vine flag offset                                    ;  B
CMP #$01                                                                                            ; 
BNE ExEPar                    ; if other value <> 1, leave                                          ; 
LDA #VineObject               ; otherwise put vine in enemy identifier                              ;  B
StrFre:  STA Enemy_ID,X       ; store contents of frenzy buffer into enemy identifier value         ;  B
                                                                                                    ; 
InitEnemyObject:                                                                                    ; fun():  B
LDA #$00                      ; initialize enemy state                                              ; 
STA Enemy_State,X                                                                                   ; 
JSR CheckpointEnemyID         ; jump ahead to run jump engine and subroutines                       ; 
ExEPar:  RTS                  ; then leave                                                          ;  B
                                                                                                    ;  B
DoGroup:                                                                                            ;  B
JMP HandleGroupEnemies        ; handle enemy group objects                                          ; 
                                                                                                    ;  B
ParseRow0e:                                                                                         ;  B
INY                           ; increment Y to load third byte of object                            ; 
INY                                                                                                 ; 
LDA (EnemyData),Y                                                                                   ; 
LSR                           ; move 3 MSB to the bottom, effectively                               ; 
LSR                           ; making %xxx00000 into %00000xxx                                     ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
CMP WorldNumber               ; is it the same world number as we're on?                            ; 
BNE NotUse                    ; if not, do not use (this allows multiple uses                       ; 
DEY                           ; of the same area, like the underground bonus areas)                 ;  B
LDA (EnemyData),Y             ; otherwise, get second byte and use as offset                        ; 
STA AreaPointer               ; to addresses for level and enemy object data                        ; 
INY                                                                                                 ; 
LDA (EnemyData),Y             ; get third byte again, and this time mask out                        ; 
AND #%00011111                ; the 3 MSB from before, save as page number to be                    ; 
STA EntrancePage              ; used upon entry to area, if area is entered                         ; 
NotUse:  JMP Inc3B                                                                                  ;  B
                                                                                                    ;  B
CheckThreeBytes:                                                                                    ;  B
LDY EnemyDataOffset           ; load current offset for enemy object data                           ; 
LDA (EnemyData),Y             ; get first byte                                                      ; 
AND #%00001111                ; check for special row $0e                                           ; 
CMP #$0e                                                                                            ; 
BNE Inc2B                                                                                           ; 
Inc3B:  INC EnemyDataOffset   ; if row = $0e, increment three bytes                                 ;  B
Inc2B:  INC EnemyDataOffset   ; otherwise increment two bytes                                       ;  B
INC EnemyDataOffset                                                                                 ; 
LDA #$00                      ; init page select for enemy objects                                  ; 
STA EnemyObjectPageSel                                                                              ; 
LDX ObjectOffset              ; reload current offset in enemy buffers                              ; 
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
CheckpointEnemyID:                                                                                  ; fun():  B
LDA Enemy_ID,X                                                                                      ; 
CMP #$15                      ; check enemy object identifier for $15 or greater                    ; 
BCS InitEnemyRoutines         ; and branch straight to the jump engine if found                     ; 
TAY                           ; save identifier in Y register for now                               ;  B
LDA Enemy_Y_Position,X                                                                              ; 
ADC #$08                      ; add eight pixels to what will eventually be the                     ; 
STA Enemy_Y_Position,X        ; enemy object's vertical coordinate ($00-$14 only)                   ; 
LDA #$01                                                                                            ; 
STA EnemyOffscrBitsMasked,X   ; set offscreen masked bit                                            ; 
TYA                           ; get identifier back and use as offset for jump engine               ; 
                                                                                                    ; 
InitEnemyRoutines:                                                                                  ;  B
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
                              ; jump engine table for newly loaded enemy objects                    ; 
                                                                                                    ; 
DATA: Expr(expr=InitNormalEnemy); for objects $00-$0f                                               ; 
DATA: Expr(expr=InitNormalEnemy)                                                                    ; 
DATA: Expr(expr=InitNormalEnemy)                                                                    ; 
DATA: Expr(expr=InitRedKoopa)                                                                       ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=InitHammerBro)                                                                      ; 
DATA: Expr(expr=InitGoomba)                                                                         ; 
DATA: Expr(expr=InitBloober)                                                                        ; 
DATA: Expr(expr=InitBulletBill)                                                                     ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=InitCheepCheep)                                                                     ; 
DATA: Expr(expr=InitCheepCheep)                                                                     ; 
DATA: Expr(expr=InitPodoboo)                                                                        ; 
DATA: Expr(expr=InitPiranhaPlant)                                                                   ; 
DATA: Expr(expr=InitJumpGPTroopa)                                                                   ; 
DATA: Expr(expr=InitRedPTroopa)                                                                     ; 
                                                                                                    ; 
DATA: Expr(expr=InitHorizFlySwimEnemy); for objects $10-$1f                                         ; 
DATA: Expr(expr=InitLakitu)                                                                         ; 
DATA: Expr(expr=InitEnemyFrenzy)                                                                    ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=InitEnemyFrenzy)                                                                    ; 
DATA: Expr(expr=InitEnemyFrenzy)                                                                    ; 
DATA: Expr(expr=InitEnemyFrenzy)                                                                    ; 
DATA: Expr(expr=InitEnemyFrenzy)                                                                    ; 
DATA: Expr(expr=EndFrenzy)                                                                          ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=InitShortFirebar)                                                                   ; 
DATA: Expr(expr=InitShortFirebar)                                                                   ; 
DATA: Expr(expr=InitShortFirebar)                                                                   ; 
DATA: Expr(expr=InitShortFirebar)                                                                   ; 
DATA: Expr(expr=InitLongFirebar)                                                                    ; 
                                                                                                    ; 
DATA: Expr(expr=NoInitCode)   ; for objects $20-$2f                                                 ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=InitBalPlatform)                                                                    ; 
DATA: Expr(expr=InitVertPlatform)                                                                   ; 
DATA: Expr(expr=LargeLiftUp)                                                                        ; 
DATA: Expr(expr=LargeLiftDown)                                                                      ; 
DATA: Expr(expr=InitHoriPlatform)                                                                   ; 
DATA: Expr(expr=InitDropPlatform)                                                                   ; 
DATA: Expr(expr=InitHoriPlatform)                                                                   ; 
DATA: Expr(expr=PlatLiftUp)                                                                         ; 
DATA: Expr(expr=PlatLiftDown)                                                                       ; 
DATA: Expr(expr=InitBowser)                                                                         ; 
DATA: Expr(expr=PwrUpJmp)     ; possibly dummy value                                                ; 
DATA: Expr(expr=Setup_Vine)                                                                         ; 
                                                                                                    ; 
DATA: Expr(expr=NoInitCode)   ; for objects $30-$36                                                 ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=NoInitCode)                                                                         ; 
DATA: Expr(expr=InitRetainerObj)                                                                    ; 
DATA: Expr(expr=EndOfEnemyInitCode)                                                                 ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
NoInitCode:                                                                                         ;  B
RTS                           ; this executed when enemy object has no init code                    ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitGoomba:                                                                                         ;  B
JSR InitNormalEnemy           ; set appropriate horizontal speed                                    ; 
JMP SmallBBox                 ; set $09 as bounding box control, set other values                   ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitPodoboo:                                                                                        ; fun():  B
LDA #$02                      ; set enemy position to below                                         ; 
STA Enemy_Y_HighPos,X         ; the bottom of the screen                                            ; 
STA Enemy_Y_Position,X                                                                              ; 
LSR                                                                                                 ; 
STA EnemyIntervalTimer,X      ; set timer for enemy                                                 ; 
LSR                                                                                                 ; 
STA Enemy_State,X             ; initialize enemy state, then jump to use                            ; 
JMP SmallBBox                 ; $09 as bounding box size and set other things                       ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitRetainerObj:                                                                                    ;  B
LDA #$b8                      ; set fixed vertical position for                                     ; 
STA Enemy_Y_Position,X        ; princess/mushroom retainer object                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
NormalXSpdData:                                                                                     ;  B
DATA: ByteValue(value=248), ByteValue(value=244)                                                    ; 
                                                                                                    ; 
InitNormalEnemy:                                                                                    ; fun():  B
LDY #$01                      ; load offset of 1 by default                                         ; 
LDA PrimaryHardMode           ; check for primary hard mode flag set                                ; 
BNE GetESpd                                                                                         ; 
DEY                           ; if not set, decrement offset                                        ;  B
GetESpd:  LDA NormalXSpdData,Y; get appropriate horizontal speed                                    ;  B
SetESpd:  STA Enemy_X_Speed,X ; store as speed for enemy object                                     ;  B
JMP TallBBox                  ; branch to set bounding box control and other data                   ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitRedKoopa:                                                                                       ;  B
JSR InitNormalEnemy           ; load appropriate horizontal speed                                   ; 
LDA #$01                      ; set enemy state for red koopa troopa $03                            ; 
STA Enemy_State,X                                                                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
HBroWalkingTimerData:                                                                               ;  B
DATA: ByteValue(value=128), ByteValue(value=80)                                                     ; 
                                                                                                    ; 
InitHammerBro:                                                                                      ;  B
LDA #$00                      ; init horizontal speed and timer used by hammer bro                  ; 
STA HammerThrowingTimer,X     ; apparently to time hammer throwing                                  ; 
STA Enemy_X_Speed,X                                                                                 ; 
LDY SecondaryHardMode         ; get secondary hard mode flag                                        ; 
LDA HBroWalkingTimerData,Y                                                                          ; 
STA EnemyIntervalTimer,X      ; set value as delay for hammer bro to walk left                      ; 
LDA #$0b                      ; set specific value for bounding box size control                    ; 
JMP SetBBox                                                                                         ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitHorizFlySwimEnemy:                                                                              ; fun():  B
LDA #$00                      ; initialize horizontal speed                                         ; 
JMP SetESpd                                                                                         ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitBloober:                                                                                        ;  B
LDA #$00                      ; initialize horizontal speed                                         ; 
STA BlooperMoveSpeed,X                                                                              ; 
SmallBBox:  LDA #$09          ; set specific bounding box size control                              ; fun(CarryFlag): A B
BNE SetBBox                   ; unconditional branch                                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitRedPTroopa:                                                                                     ;  B
LDY #$30                      ; load central position adder for 48 pixels down                      ; 
LDA Enemy_Y_Position,X        ; set vertical coordinate into location to                            ; 
STA RedPTroopaOrigXPos,X      ; be used as original vertical coordinate                             ; 
BPL GetCent                   ; if vertical coordinate < $80                                        ; 
LDY #$e0                      ; if => $80, load position adder for 32 pixels up                     ;  B
GetCent:  TYA                 ; send central position adder to A                                    ;  B
ADC Enemy_Y_Position,X        ; add to current vertical coordinate                                  ; 
STA RedPTroopaCenterYPos,X    ; store as central vertical coordinate                                ; 
TallBBox:  LDA #$03           ; set specific bounding box size control                              ;  B
SetBBox:  STA Enemy_BoundBoxCtrl,X; set bounding box control here                                   ;  B
LDA #$02                      ; set moving direction for left                                       ; 
STA Enemy_MovingDir,X                                                                               ; 
InitVStf:  LDA #$00           ; initialize vertical speed                                           ; fun(): A B
STA Enemy_Y_Speed,X           ; and movement force                                                  ; 
STA Enemy_Y_MoveForce,X                                                                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitBulletBill:                                                                                     ;  B
LDA #$02                      ; set moving direction for left                                       ; 
STA Enemy_MovingDir,X                                                                               ; 
LDA #$09                      ; set bounding box control for $09                                    ; 
STA Enemy_BoundBoxCtrl,X                                                                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitCheepCheep:                                                                                     ;  B
JSR SmallBBox                 ; set vertical bounding box, speed, init others                       ; 
LDA PseudoRandomBitReg,X      ; check one portion of LSFR                                           ; 
AND #%00010000                ; get d4 from it                                                      ; 
STA CheepCheepMoveMFlag,X     ; save as movement flag of some sort                                  ; 
LDA Enemy_Y_Position,X                                                                              ; 
STA CheepCheepOrigYPos,X      ; save original vertical coordinate here                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitLakitu:                                                                                         ;  B
LDA EnemyFrenzyBuffer         ; check to see if an enemy is already in                              ; 
BNE KillLakitu                ; the frenzy buffer, and branch to kill lakitu if so                  ; 
                                                                                                    ;  B
SetupLakitu:                                                                                        ; fun():  B
LDA #$00                      ; erase counter for lakitu's reappearance                             ; 
STA LakituReappearTimer                                                                             ; 
JSR InitHorizFlySwimEnemy     ; set $03 as bounding box, set other attributes                       ; 
JMP TallBBox2                 ; set $03 as bounding box again (not necessary) and leave             ; 
                                                                                                    ;  B
KillLakitu:                                                                                         ;  B
JMP EraseEnemyObject                                                                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $01-$03 - used to hold pseudorandom difference adjusters            ; 
                                                                                                    ; 
PRDiffAdjustData:                                                                                   ;  B
DATA: ByteValue(value=38), ByteValue(value=44), ByteValue(value=50), ByteValue(value=56)            ; 
DATA: ByteValue(value=32), ByteValue(value=34), ByteValue(value=36), ByteValue(value=38)            ; 
DATA: ByteValue(value=19), ByteValue(value=20), ByteValue(value=21), ByteValue(value=22)            ; 
                                                                                                    ; 
LakituAndSpinyHandler:                                                                              ;  B
LDA FrenzyEnemyTimer          ; if timer here not expired, leave                                    ; 
BNE ExLSHand                                                                                        ; 
CPX #$05                      ; if we are on the special use slot, leave                            ;  B
BCS ExLSHand                                                                                        ; 
LDA #$80                      ; set timer                                                           ;  B
STA FrenzyEnemyTimer                                                                                ; 
LDY #$04                      ; start with the last enemy slot                                      ; 
ChkLak:  LDA Enemy_ID,Y       ; check all enemy slots to see                                        ;  B
CMP #Lakitu                   ; if lakitu is on one of them                                         ; 
BEQ CreateSpiny               ; if so, branch out of this loop                                      ; 
DEY                           ; otherwise check another slot                                        ;  B
BPL ChkLak                    ; loop until all slots are checked                                    ; 
INC LakituReappearTimer       ; increment reappearance timer                                        ;  B
LDA LakituReappearTimer                                                                             ; 
CMP #$07                      ; check to see if we're up to a certain value yet                     ; 
BCC ExLSHand                  ; if not, leave                                                       ; 
LDX #$04                      ; start with the last enemy slot again                                ;  B
ChkNoEn:  LDA Enemy_Flag,X    ; check enemy buffer flag for non-active enemy slot                   ;  B
BEQ CreateL                   ; branch out of loop if found                                         ; 
DEX                           ; otherwise check next slot                                           ;  B
BPL ChkNoEn                   ; branch until all slots are checked                                  ; 
BMI RetEOfs                   ; if no empty slots were found, branch to leave                       ;  B
CreateL:  LDA #$00            ; initialize enemy state                                              ;  B
STA Enemy_State,X                                                                                   ; 
LDA #Lakitu                   ; create lakitu enemy object                                          ; 
STA Enemy_ID,X                                                                                      ; 
JSR SetupLakitu               ; do a sub to set up lakitu                                           ; 
LDA #$20                                                                                            ; 
JSR PutAtRightExtent          ; finish setting up lakitu                                            ; 
RetEOfs:  LDX ObjectOffset    ; get enemy object buffer offset again and leave                      ;  B
ExLSHand:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
CreateSpiny:                                                                                        ;  B
LDA Player_Y_Position         ; if player above a certain point, branch to leave                    ; 
CMP #$2c                                                                                            ; 
BCC ExLSHand                                                                                        ; 
LDA Enemy_State,Y             ; if lakitu is not in normal state, branch to leave                   ;  B
BNE ExLSHand                                                                                        ; 
LDA Enemy_PageLoc,Y           ; store horizontal coordinates (high and low) of lakitu               ;  B
STA Enemy_PageLoc,X           ; into the coordinates of the spiny we're going to create             ; 
LDA Enemy_X_Position,Y                                                                              ; 
STA Enemy_X_Position,X                                                                              ; 
LDA #$01                      ; put spiny within vertical screen unit                               ; 
STA Enemy_Y_HighPos,X                                                                               ; 
LDA Enemy_Y_Position,Y        ; put spiny eight pixels above where lakitu is                        ; 
SEC                                                                                                 ; 
SBC #$08                                                                                            ; 
STA Enemy_Y_Position,X                                                                              ; 
LDA PseudoRandomBitReg,X      ; get 2 LSB of LSFR and save to Y                                     ; 
AND #%00000011                                                                                      ; 
TAY                                                                                                 ; 
LDX #$02                                                                                            ; 
DifLoop:  LDA PRDiffAdjustData,Y; get three values and save them                                    ;  B
STA $01,X                     ; to $01-$03                                                          ; 
INY                                                                                                 ; 
INY                           ; increment Y four bytes for each value                               ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
DEX                           ; decrement X for each one                                            ; 
BPL DifLoop                   ; loop until all three are written                                    ; 
LDX ObjectOffset              ; get enemy object buffer offset                                      ;  B
JSR PlayerLakituDiff          ; move enemy, change direction, get value - difference                ; 
LDY Player_X_Speed            ; check player's horizontal speed                                     ; 
CPY #$08                                                                                            ; 
BCS SetSpSpd                  ; if moving faster than a certain amount, branch elsewhere            ; 
TAY                           ; otherwise save value in A to Y for now                              ;  B
LDA PseudoRandomBitReg+1,X                                                                          ; 
AND #%00000011                ; get one of the LSFR parts and save the 2 LSB                        ; 
BEQ UsePosv                   ; branch if neither bits are set                                      ; 
TYA                                                                                                 ;  B
EOR #%11111111                ; otherwise get two's compliment of Y                                 ; 
TAY                                                                                                 ; 
INY                                                                                                 ; 
UsePosv:  TYA                 ; put value from A in Y back to A (they will be lost anyway)          ;  B
SetSpSpd:  JSR SmallBBox      ; set bounding box control, init attributes, lose contents of A       ;  B
LDY #$02                                                                                            ; 
STA Enemy_X_Speed,X           ; set horizontal speed to zero because previous contents              ; 
CMP #$00                      ; of A were lost...branch here will never be taken for                ; 
BMI SpinyRte                  ; the same reason                                                     ; 
DEY                                                                                                 ;  B
SpinyRte:  STY Enemy_MovingDir,X; set moving direction to the right                                 ;  B
LDA #$fd                                                                                            ; 
STA Enemy_Y_Speed,X           ; set vertical speed to move upwards                                  ; 
LDA #$01                                                                                            ; 
STA Enemy_Flag,X              ; enable enemy object by setting flag                                 ; 
LDA #$05                                                                                            ; 
STA Enemy_State,X             ; put spiny in egg state and leave                                    ; 
ChpChpEx:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FirebarSpinSpdData:                                                                                 ;  B
DATA: ByteValue(value=40), ByteValue(value=56), ByteValue(value=40), ByteValue(value=56), ByteValue(value=40); 
                                                                                                    ; 
FirebarSpinDirData:                                                                                 ;  B
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=16), ByteValue(value=16), ByteValue(value=0); 
                                                                                                    ; 
InitLongFirebar:                                                                                    ;  B
JSR DuplicateEnemyObj         ; create enemy object for long firebar                                ; 
                                                                                                    ; 
InitShortFirebar:                                                                                   ;  B
LDA #$00                      ; initialize low byte of spin state                                   ; 
STA FirebarSpinState_Low,X                                                                          ; 
LDA Enemy_ID,X                ; subtract $1b from enemy identifier                                  ; 
SEC                           ; to get proper offset for firebar data                               ; 
SBC #$1b                                                                                            ; 
TAY                                                                                                 ; 
LDA FirebarSpinSpdData,Y      ; get spinning speed of firebar                                       ; 
STA FirebarSpinSpeed,X                                                                              ; 
LDA FirebarSpinDirData,Y      ; get spinning direction of firebar                                   ; 
STA FirebarSpinDirection,X                                                                          ; 
LDA Enemy_Y_Position,X                                                                              ; 
CLC                           ; add four pixels to vertical coordinate                              ; 
ADC #$04                                                                                            ; 
STA Enemy_Y_Position,X                                                                              ; 
LDA Enemy_X_Position,X                                                                              ; 
CLC                           ; add four pixels to horizontal coordinate                            ; 
ADC #$04                                                                                            ; 
STA Enemy_X_Position,X                                                                              ; 
LDA Enemy_PageLoc,X                                                                                 ; 
ADC #$00                      ; add carry to page location                                          ; 
STA Enemy_PageLoc,X                                                                                 ; 
JMP TallBBox2                 ; set bounding box control (not used) and leave                       ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00-$01 - used to hold pseudorandom bits                            ; 
                                                                                                    ; 
FlyCCXPositionData:                                                                                 ;  B
DATA: ByteValue(value=128), ByteValue(value=48), ByteValue(value=64), ByteValue(value=128)          ; 
DATA: ByteValue(value=48), ByteValue(value=80), ByteValue(value=80), ByteValue(value=112)           ; 
DATA: ByteValue(value=32), ByteValue(value=64), ByteValue(value=128), ByteValue(value=160)          ; 
DATA: ByteValue(value=112), ByteValue(value=64), ByteValue(value=144), ByteValue(value=104)         ; 
                                                                                                    ; 
FlyCCXSpeedData:                                                                                    ;  B
DATA: ByteValue(value=14), ByteValue(value=5), ByteValue(value=6), ByteValue(value=14)              ; 
DATA: ByteValue(value=28), ByteValue(value=32), ByteValue(value=16), ByteValue(value=12)            ; 
DATA: ByteValue(value=30), ByteValue(value=34), ByteValue(value=24), ByteValue(value=20)            ; 
                                                                                                    ; 
FlyCCTimerData:                                                                                     ;  B
DATA: ByteValue(value=16), ByteValue(value=96), ByteValue(value=32), ByteValue(value=72)            ; 
                                                                                                    ; 
InitFlyingCheepCheep:                                                                               ;  B
LDA FrenzyEnemyTimer          ; if timer here not expired yet, branch to leave                      ; 
BNE ChpChpEx                                                                                        ; 
JSR SmallBBox                 ; jump to set bounding box size $09 and init other values             ;  B
LDA PseudoRandomBitReg+1,X                                                                          ; 
AND #%00000011                ; set pseudorandom offset here                                        ; 
TAY                                                                                                 ; 
LDA FlyCCTimerData,Y          ; load timer with pseudorandom offset                                 ; 
STA FrenzyEnemyTimer                                                                                ; 
LDY #$03                      ; load Y with default value                                           ; 
LDA SecondaryHardMode                                                                               ; 
BEQ MaxCC                     ; if secondary hard mode flag not set, do not increment Y             ; 
INY                           ; otherwise, increment Y to allow as many as four onscreen            ;  B
MaxCC:  STY $00               ; store whatever pseudorandom bits are in Y                           ;  B
CPX $00                       ; compare enemy object buffer offset with Y                           ; 
BCS ChpChpEx                  ; if X => Y, branch to leave                                          ; 
LDA PseudoRandomBitReg,X                                                                            ;  B
AND #%00000011                ; get last two bits of LSFR, first part                               ; 
STA $00                       ; and store in two places                                             ; 
STA $01                                                                                             ; 
LDA #$fb                      ; set vertical speed for cheep-cheep                                  ; 
STA Enemy_Y_Speed,X                                                                                 ; 
LDA #$00                      ; load default value                                                  ; 
LDY Player_X_Speed            ; check player's horizontal speed                                     ; 
BEQ GSeed                     ; if player not moving left or right, skip this part                  ; 
LDA #$04                                                                                            ;  B
CPY #$19                      ; if moving to the right but not very quickly,                        ; 
BCC GSeed                     ; do not change A                                                     ; 
ASL                           ; otherwise, multiply A by 2                                          ;  B
GSeed:  PHA                   ; save to stack                                                       ;  B
CLC                                                                                                 ; 
ADC $00                       ; add to last two bits of LSFR we saved earlier                       ; 
STA $00                       ; save it there                                                       ; 
LDA PseudoRandomBitReg+1,X                                                                          ; 
AND #%00000011                ; if neither of the last two bits of second LSFR set,                 ; 
BEQ RSeed                     ; skip this part and save contents of $00                             ; 
LDA PseudoRandomBitReg+2,X                                                                          ;  B
AND #%00001111                ; otherwise overwrite with lower nybble of                            ; 
STA $00                       ; third LSFR part                                                     ; 
RSeed:  PLA                   ; get value from stack we saved earlier                               ;  B
CLC                                                                                                 ; 
ADC $01                       ; add to last two bits of LSFR we saved in other place                ; 
TAY                           ; use as pseudorandom offset here                                     ; 
LDA FlyCCXSpeedData,Y         ; get horizontal speed using pseudorandom offset                      ; 
STA Enemy_X_Speed,X                                                                                 ; 
LDA #$01                      ; set to move towards the right                                       ; 
STA Enemy_MovingDir,X                                                                               ; 
LDA Player_X_Speed            ; if player moving left or right, branch ahead of this part           ; 
BNE D2XPos1                                                                                         ; 
LDY $00                       ; get first LSFR or third LSFR lower nybble                           ;  B
TYA                           ; and check for d1 set                                                ; 
AND #%00000010                                                                                      ; 
BEQ D2XPos1                   ; if d1 not set, branch                                               ; 
LDA Enemy_X_Speed,X                                                                                 ;  B
EOR #$ff                      ; if d1 set, change horizontal speed                                  ; 
CLC                           ; into two's compliment, thus moving in the opposite                  ; 
ADC #$01                      ; direction                                                           ; 
STA Enemy_X_Speed,X                                                                                 ; 
INC Enemy_MovingDir,X         ; increment to move towards the left                                  ; 
D2XPos1:  TYA                 ; get first LSFR or third LSFR lower nybble again                     ;  B
AND #%00000010                                                                                      ; 
BEQ D2XPos2                   ; check for d1 set again, branch again if not set                     ; 
LDA Player_X_Position         ; get player's horizontal position                                    ;  B
CLC                                                                                                 ; 
ADC FlyCCXPositionData,Y      ; if d1 set, add value obtained from pseudorandom offset              ; 
STA Enemy_X_Position,X        ; and save as enemy's horizontal position                             ; 
LDA Player_PageLoc            ; get player's page location                                          ; 
ADC #$00                      ; add carry and jump past this part                                   ; 
JMP FinCCSt                                                                                         ; 
D2XPos2:  LDA Player_X_Position; get player's horizontal position                                   ;  B
SEC                                                                                                 ; 
SBC FlyCCXPositionData,Y      ; if d1 not set, subtract value obtained from pseudorandom            ; 
STA Enemy_X_Position,X        ; offset and save as enemy's horizontal position                      ; 
LDA Player_PageLoc            ; get player's page location                                          ; 
SBC #$00                      ; subtract borrow                                                     ; 
FinCCSt:  STA Enemy_PageLoc,X ; save as enemy's page location                                       ;  B
LDA #$01                                                                                            ; 
STA Enemy_Flag,X              ; set enemy's buffer flag                                             ; 
STA Enemy_Y_HighPos,X         ; set enemy's high vertical byte                                      ; 
LDA #$f8                                                                                            ; 
STA Enemy_Y_Position,X        ; put enemy below the screen, and we are done                         ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitBowser:                                                                                         ;  B
JSR DuplicateEnemyObj         ; jump to create another bowser object                                ; 
STX BowserFront_Offset        ; save offset of first here                                           ; 
LDA #$00                                                                                            ; 
STA BowserBodyControls        ; initialize bowser's body controls                                   ; 
STA BridgeCollapseOffset      ; and bridge collapse offset                                          ; 
LDA Enemy_X_Position,X                                                                              ; 
STA BowserOrigXPos            ; store original horizontal position here                             ; 
LDA #$df                                                                                            ; 
STA BowserFireBreathTimer     ; store something here                                                ; 
STA Enemy_MovingDir,X         ; and in moving direction                                             ; 
LDA #$20                                                                                            ; 
STA BowserFeetCounter         ; set bowser's feet timer and in enemy timer                          ; 
STA EnemyFrameTimer,X                                                                               ; 
LDA #$05                                                                                            ; 
STA BowserHitPoints           ; give bowser 5 hit points                                            ; 
LSR                                                                                                 ; 
STA BowserMovementSpeed       ; set default movement speed here                                     ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
DuplicateEnemyObj:                                                                                  ; fun(X):  B
LDY #$ff                      ; start at beginning of enemy slots                                   ; 
FSLoop:  INY                  ; increment one slot                                                  ;  B
LDA Enemy_Flag,Y              ; check enemy buffer flag for empty slot                              ; 
BNE FSLoop                    ; if set, branch and keep checking                                    ; 
STY DuplicateObj_Offset       ; otherwise set offset here                                           ;  B
TXA                           ; transfer original enemy buffer offset                               ; 
ORA #%10000000                ; store with d7 set as flag in new enemy                              ; 
STA Enemy_Flag,Y              ; slot as well as enemy offset                                        ; 
LDA Enemy_PageLoc,X                                                                                 ; 
STA Enemy_PageLoc,Y           ; copy page location and horizontal coordinates                       ; 
LDA Enemy_X_Position,X        ; from original enemy to new enemy                                    ; 
STA Enemy_X_Position,Y                                                                              ; 
LDA #$01                                                                                            ; 
STA Enemy_Flag,X              ; set flag as normal for original enemy                               ; 
STA Enemy_Y_HighPos,Y         ; set high vertical byte for new enemy                                ; 
LDA Enemy_Y_Position,X                                                                              ; 
STA Enemy_Y_Position,Y        ; copy vertical coordinate from original to new                       ; 
FlmEx:  RTS                   ; and then leave                                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FlameYPosData:                                                                                      ;  B
DATA: ByteValue(value=144), ByteValue(value=128), ByteValue(value=112), ByteValue(value=144)        ; 
                                                                                                    ; 
FlameYMFAdderData:                                                                                  ;  B
DATA: ByteValue(value=255), ByteValue(value=1)                                                      ; 
                                                                                                    ; 
InitBowserFlame:                                                                                    ;  B
LDA FrenzyEnemyTimer          ; if timer not expired yet, branch to leave                           ; 
BNE FlmEx                                                                                           ; 
STA Enemy_Y_MoveForce,X       ; reset something here                                                ;  B
LDA NoiseSoundQueue                                                                                 ; 
ORA #Sfx_BowserFlame          ; load bowser's flame sound into queue                                ; 
STA NoiseSoundQueue                                                                                 ; 
LDY BowserFront_Offset        ; get bowser's buffer offset                                          ; 
LDA Enemy_ID,Y                ; check for bowser                                                    ; 
CMP #Bowser                                                                                         ; 
BEQ SpawnFromMouth            ; branch if found                                                     ; 
JSR SetFlameTimer             ; get timer data based on flame counter                               ;  B
CLC                                                                                                 ; 
ADC #$20                      ; add 32 frames by default                                            ; 
LDY SecondaryHardMode                                                                               ; 
BEQ SetFrT                    ; if secondary mode flag not set, use as timer setting                ; 
SEC                                                                                                 ;  B
SBC #$10                      ; otherwise subtract 16 frames for secondary hard mode                ; 
SetFrT:  STA FrenzyEnemyTimer ; set timer accordingly                                               ;  B
LDA PseudoRandomBitReg,X                                                                            ; 
AND #%00000011                ; get 2 LSB from first part of LSFR                                   ; 
STA BowserFlamePRandomOfs,X   ; set here                                                            ; 
TAY                           ; use as offset                                                       ; 
LDA FlameYPosData,Y           ; load vertical position based on pseudorandom offset                 ; 
                                                                                                    ; 
PutAtRightExtent:                                                                                   ; fun(A): A B
STA Enemy_Y_Position,X        ; set vertical position                                               ; 
LDA ScreenRight_X_Pos                                                                               ; 
CLC                                                                                                 ; 
ADC #$20                      ; place enemy 32 pixels beyond right side of screen                   ; 
STA Enemy_X_Position,X                                                                              ; 
LDA ScreenRight_PageLoc                                                                             ; 
ADC #$00                      ; add carry                                                           ; 
STA Enemy_PageLoc,X                                                                                 ; 
JMP FinishFlame               ; skip this part to finish setting values                             ; 
                                                                                                    ;  B
SpawnFromMouth:                                                                                     ;  B
LDA Enemy_X_Position,Y        ; get bowser's horizontal position                                    ; 
SEC                                                                                                 ; 
SBC #$0e                      ; subtract 14 pixels                                                  ; 
STA Enemy_X_Position,X        ; save as flame's horizontal position                                 ; 
LDA Enemy_PageLoc,Y                                                                                 ; 
STA Enemy_PageLoc,X           ; copy page location from bowser to flame                             ; 
LDA Enemy_Y_Position,Y                                                                              ; 
CLC                           ; add 8 pixels to bowser's vertical position                          ; 
ADC #$08                                                                                            ; 
STA Enemy_Y_Position,X        ; save as flame's vertical position                                   ; 
LDA PseudoRandomBitReg,X                                                                            ; 
AND #%00000011                ; get 2 LSB from first part of LSFR                                   ; 
STA Enemy_YMF_Dummy,X         ; save here                                                           ; 
TAY                           ; use as offset                                                       ; 
LDA FlameYPosData,Y           ; get value here using bits as offset                                 ; 
LDY #$00                      ; load default offset                                                 ; 
CMP Enemy_Y_Position,X        ; compare value to flame's current vertical position                  ; 
BCC SetMF                     ; if less, do not increment offset                                    ; 
INY                           ; otherwise increment now                                             ;  B
SetMF:  LDA FlameYMFAdderData,Y; get value here and save                                            ;  B
STA Enemy_Y_MoveForce,X       ; to vertical movement force                                          ; 
LDA #$00                                                                                            ; 
STA EnemyFrenzyBuffer         ; clear enemy frenzy buffer                                           ; 
                                                                                                    ; 
FinishFlame:                                                                                        ;  B
LDA #$08                      ; set $08 for bounding box control                                    ; 
STA Enemy_BoundBoxCtrl,X                                                                            ; 
LDA #$01                      ; set high byte of vertical and                                       ; 
STA Enemy_Y_HighPos,X         ; enemy buffer flag                                                   ; 
STA Enemy_Flag,X                                                                                    ; 
LSR                                                                                                 ; 
STA Enemy_X_MoveForce,X       ; initialize horizontal movement force, and                           ; 
STA Enemy_State,X             ; enemy state                                                         ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
FireworksXPosData:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=48), ByteValue(value=96), ByteValue(value=96), ByteValue(value=0), ByteValue(value=32); 
                                                                                                    ; 
FireworksYPosData:                                                                                  ;  B
DATA: ByteValue(value=96), ByteValue(value=64), ByteValue(value=112), ByteValue(value=64), ByteValue(value=96), ByteValue(value=48); 
                                                                                                    ; 
InitFireworks:                                                                                      ;  B
LDA FrenzyEnemyTimer          ; if timer not expired yet, branch to leave                           ; 
BNE ExitFWk                                                                                         ; 
LDA #$20                      ; otherwise reset timer                                               ;  B
STA FrenzyEnemyTimer                                                                                ; 
DEC FireworksCounter          ; decrement for each explosion                                        ; 
LDY #$06                      ; start at last slot                                                  ; 
StarFChk:  DEY                                                                                      ;  B
LDA Enemy_ID,Y                ; check for presence of star flag object                              ; 
CMP #StarFlagObject           ; if there isn't a star flag object,                                  ; 
BNE StarFChk                  ; routine goes into infinite loop = crash                             ; 
LDA Enemy_X_Position,Y                                                                              ;  B
SEC                           ; get horizontal coordinate of star flag object, then                 ; 
SBC #$30                      ; subtract 48 pixels from it and save to                              ; 
PHA                           ; the stack                                                           ; 
LDA Enemy_PageLoc,Y                                                                                 ; 
SBC #$00                      ; subtract the carry from the page location                           ; 
STA $00                       ; of the star flag object                                             ; 
LDA FireworksCounter          ; get fireworks counter                                               ; 
CLC                                                                                                 ; 
ADC Enemy_State,Y             ; add state of star flag object (possibly not necessary)              ; 
TAY                           ; use as offset                                                       ; 
PLA                           ; get saved horizontal coordinate of star flag - 48 pixels            ; 
CLC                                                                                                 ; 
ADC FireworksXPosData,Y       ; add number based on offset of fireworks counter                     ; 
STA Enemy_X_Position,X        ; store as the fireworks object horizontal coordinate                 ; 
LDA $00                                                                                             ; 
ADC #$00                      ; add carry and store as page location for                            ; 
STA Enemy_PageLoc,X           ; the fireworks object                                                ; 
LDA FireworksYPosData,Y       ; get vertical position using same offset                             ; 
STA Enemy_Y_Position,X        ; and store as vertical coordinate for fireworks object               ; 
LDA #$01                                                                                            ; 
STA Enemy_Y_HighPos,X         ; store in vertical high byte                                         ; 
STA Enemy_Flag,X              ; and activate enemy buffer flag                                      ; 
LSR                                                                                                 ; 
STA ExplosionGfxCounter,X     ; initialize explosion counter                                        ; 
LDA #$08                                                                                            ; 
STA ExplosionTimerCounter,X   ; set explosion timing counter                                        ; 
ExitFWk:  RTS                                                                                       ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
Bitmasks:                                                                                           ;  B
DATA: ByteValue(value=1), ByteValue(value=2), ByteValue(value=4), ByteValue(value=8), ByteValue(value=16), ByteValue(value=32), ByteValue(value=64), ByteValue(value=128); 
                                                                                                    ; 
Enemy17YPosData:                                                                                    ;  B
DATA: ByteValue(value=64), ByteValue(value=48), ByteValue(value=144), ByteValue(value=80), ByteValue(value=32), ByteValue(value=96), ByteValue(value=160), ByteValue(value=112); 
                                                                                                    ; 
SwimCC_IDData:                                                                                      ;  B
DATA: ByteValue(value=10), ByteValue(value=11)                                                      ; 
                                                                                                    ; 
BulletBillCheepCheep:                                                                               ;  B
LDA FrenzyEnemyTimer          ; if timer not expired yet, branch to leave                           ; 
BNE ExF17                                                                                           ; 
LDA AreaType                  ; are we in a water-type level?                                       ;  B
BNE DoBulletBills             ; if not, branch elsewhere                                            ; 
CPX #$03                      ; are we past third enemy slot?                                       ;  B
BCS ExF17                     ; if so, branch to leave                                              ; 
LDY #$00                      ; load default offset                                                 ;  B
LDA PseudoRandomBitReg,X                                                                            ; 
CMP #$aa                      ; check first part of LSFR against preset value                       ; 
BCC ChkW2                     ; if less than preset, do not increment offset                        ; 
INY                           ; otherwise increment                                                 ;  B
ChkW2:  LDA WorldNumber       ; check world number                                                  ;  B
CMP #World2                                                                                         ; 
BEQ Get17ID                   ; if we're on world 2, do not increment offset                        ; 
INY                           ; otherwise increment                                                 ;  B
Get17ID:  TYA                                                                                       ;  B
AND #%00000001                ; mask out all but last bit of offset                                 ; 
TAY                                                                                                 ; 
LDA SwimCC_IDData,Y           ; load identifier for cheep-cheeps                                    ; 
Set17ID:  STA Enemy_ID,X      ; store whatever's in A as enemy identifier                           ;  B
LDA BitMFilter                                                                                      ; 
CMP #$ff                      ; if not all bits set, skip init part and compare bits                ; 
BNE GetRBit                                                                                         ; 
LDA #$00                      ; initialize vertical position filter                                 ;  B
STA BitMFilter                                                                                      ; 
GetRBit:  LDA PseudoRandomBitReg,X; get first part of LSFR                                          ;  B
AND #%00000111                ; mask out all but 3 LSB                                              ; 
ChkRBit:  TAY                 ; use as offset                                                       ;  B
LDA Bitmasks,Y                ; load bitmask                                                        ; 
BIT BitMFilter                ; perform AND on filter without changing it                           ; 
BEQ AddFBit                                                                                         ; 
INY                           ; increment offset                                                    ;  B
TYA                                                                                                 ; 
AND #%00000111                ; mask out all but 3 LSB thus keeping it 0-7                          ; 
JMP ChkRBit                   ; do another check                                                    ; 
AddFBit:  ORA BitMFilter      ; add bit to already set bits in filter                               ;  B
STA BitMFilter                ; and store                                                           ; 
LDA Enemy17YPosData,Y         ; load vertical position using offset                                 ; 
JSR PutAtRightExtent          ; set vertical position and other values                              ; 
STA Enemy_YMF_Dummy,X         ; initialize dummy variable                                           ; 
LDA #$20                      ; set timer                                                           ; 
STA FrenzyEnemyTimer                                                                                ; 
JMP CheckpointEnemyID         ; process our new enemy object                                        ; 
                                                                                                    ;  B
DoBulletBills:                                                                                      ;  B
LDY #$ff                      ; start at beginning of enemy slots                                   ; 
BB_SLoop:  INY                ; move onto the next slot                                             ;  B
CPY #$05                      ; branch to play sound if we've done all slots                        ; 
BCS FireBulletBill                                                                                  ; 
LDA Enemy_Flag,Y              ; if enemy buffer flag not set,                                       ;  B
BEQ BB_SLoop                  ; loop back and check another slot                                    ; 
LDA Enemy_ID,Y                                                                                      ;  B
CMP #BulletBill_FrenzyVar     ; check enemy identifier for                                          ; 
BNE BB_SLoop                  ; bullet bill object (frenzy variant)                                 ; 
ExF17:  RTS                   ; if found, leave                                                     ;  B
                                                                                                    ;  B
FireBulletBill:                                                                                     ;  B
LDA Square2SoundQueue                                                                               ; 
ORA #Sfx_Blast                ; play fireworks/gunfire sound                                        ; 
STA Square2SoundQueue                                                                               ; 
LDA #BulletBill_FrenzyVar     ; load identifier for bullet bill object                              ; 
BNE Set17ID                   ; unconditional branch                                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to store Y position of group enemies                     ; 
                              ; $01 - used to store enemy ID                                        ; 
                              ; $02 - used to store page location of right side of screen           ; 
                              ; $03 - used to store X position of right side of screen              ; 
                                                                                                    ; 
HandleGroupEnemies:                                                                                 ;  B
LDY #$00                      ; load value for green koopa troopa                                   ; 
SEC                                                                                                 ; 
SBC #$37                      ; subtract $37 from second byte read                                  ; 
PHA                           ; save result in stack for now                                        ; 
CMP #$04                      ; was byte in $3b-$3e range?                                          ; 
BCS SnglID                    ; if so, branch                                                       ; 
PHA                           ; save another copy to stack                                          ;  B
LDY #Goomba                   ; load value for goomba enemy                                         ; 
LDA PrimaryHardMode           ; if primary hard mode flag not set,                                  ; 
BEQ PullID                    ; branch, otherwise change to value                                   ; 
LDY #BuzzyBeetle              ; for buzzy beetle                                                    ;  B
PullID:  PLA                  ; get second copy from stack                                          ;  B
SnglID:  STY $01              ; save enemy id here                                                  ;  B
LDY #$b0                      ; load default y coordinate                                           ; 
AND #$02                      ; check to see if d1 was set                                          ; 
BEQ SetYGp                    ; if so, move y coordinate up,                                        ; 
LDY #$70                      ; otherwise branch and use default                                    ;  B
SetYGp:  STY $00              ; save y coordinate here                                              ;  B
LDA ScreenRight_PageLoc       ; get page number of right edge of screen                             ; 
STA $02                       ; save here                                                           ; 
LDA ScreenRight_X_Pos         ; get pixel coordinate of right edge                                  ; 
STA $03                       ; save here                                                           ; 
LDY #$02                      ; load two enemies by default                                         ; 
PLA                           ; get first copy from stack                                           ; 
LSR                           ; check to see if d0 was set                                          ; 
BCC CntGrp                    ; if not, use default value                                           ; 
INY                           ; otherwise increment to three enemies                                ;  B
CntGrp:  STY NumberofGroupEnemies; save number of enemies here                                      ;  B
GrLoop:  LDX #$ff             ; start at beginning of enemy buffers                                 ;  B
GSltLp:  INX                  ; increment and branch if past                                        ;  B
CPX #$05                      ; end of buffers                                                      ; 
BCS NextED                                                                                          ; 
LDA Enemy_Flag,X              ; check to see if enemy is already                                    ;  B
BNE GSltLp                    ; stored in buffer, and branch if so                                  ; 
LDA $01                                                                                             ;  B
STA Enemy_ID,X                ; store enemy object identifier                                       ; 
LDA $02                                                                                             ; 
STA Enemy_PageLoc,X           ; store page location for enemy object                                ; 
LDA $03                                                                                             ; 
STA Enemy_X_Position,X        ; store x coordinate for enemy object                                 ; 
CLC                                                                                                 ; 
ADC #$18                      ; add 24 pixels for next enemy                                        ; 
STA $03                                                                                             ; 
LDA $02                       ; add carry to page location for                                      ; 
ADC #$00                      ; next enemy                                                          ; 
STA $02                                                                                             ; 
LDA $00                       ; store y coordinate for enemy object                                 ; 
STA Enemy_Y_Position,X                                                                              ; 
LDA #$01                      ; activate flag for buffer, and                                       ; 
STA Enemy_Y_HighPos,X         ; put enemy within the screen vertically                              ; 
STA Enemy_Flag,X                                                                                    ; 
JSR CheckpointEnemyID         ; process each enemy object separately                                ; 
DEC NumberofGroupEnemies      ; do this until we run out of enemy objects                           ; 
BNE GrLoop                                                                                          ; 
NextED:  JMP Inc2B            ; jump to increment data offset and leave                             ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitPiranhaPlant:                                                                                   ; fun():  B
LDA #$01                      ; set initial speed                                                   ; 
STA PiranhaPlant_Y_Speed,X                                                                          ; 
LSR                                                                                                 ; 
STA Enemy_State,X             ; initialize enemy state and what would normally                      ; 
STA PiranhaPlant_MoveFlag,X   ; be used as vertical speed, but not in this case                     ; 
LDA Enemy_Y_Position,X                                                                              ; 
STA PiranhaPlantDownYPos,X    ; save original vertical coordinate here                              ; 
SEC                                                                                                 ; 
SBC #$18                                                                                            ; 
STA PiranhaPlantUpYPos,X      ; save original vertical coordinate - 24 pixels here                  ; 
LDA #$09                                                                                            ; 
JMP SetBBox2                  ; set specific value for bounding box control                         ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitEnemyFrenzy:                                                                                    ;  B
LDA Enemy_ID,X                ; load enemy identifier                                               ; 
STA EnemyFrenzyBuffer         ; save in enemy frenzy buffer                                         ; 
SEC                                                                                                 ; 
SBC #$12                      ; subtract 12 and use as offset for jump engine                       ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
                              ; frenzy object jump table                                            ; 
DATA: Expr(expr=LakituAndSpinyHandler)                                                              ; 
DATA: Expr(expr=NoFrenzyCode)                                                                       ; 
DATA: Expr(expr=InitFlyingCheepCheep)                                                               ; 
DATA: Expr(expr=InitBowserFlame)                                                                    ; 
DATA: Expr(expr=InitFireworks)                                                                      ; 
DATA: Expr(expr=BulletBillCheepCheep)                                                               ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
NoFrenzyCode:                                                                                       ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
EndFrenzy:                                                                                          ;  B
LDY #$05                      ; start at last slot                                                  ; 
LakituChk:  LDA Enemy_ID,Y    ; check enemy identifiers                                             ;  B
CMP #Lakitu                   ; for lakitu                                                          ; 
BNE NextFSlot                                                                                       ; 
LDA #$01                      ; if found, set state                                                 ;  B
STA Enemy_State,Y                                                                                   ; 
NextFSlot:  DEY               ; move onto the next slot                                             ;  B
BPL LakituChk                 ; do this until all slots are checked                                 ; 
LDA #$00                                                                                            ;  B
STA EnemyFrenzyBuffer         ; empty enemy frenzy buffer                                           ; 
STA Enemy_Flag,X              ; disable enemy buffer flag for this object                           ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitJumpGPTroopa:                                                                                   ;  B
LDA #$02                      ; set for movement to the left                                        ; 
STA Enemy_MovingDir,X                                                                               ; 
LDA #$f8                      ; set horizontal speed                                                ; 
STA Enemy_X_Speed,X                                                                                 ; 
TallBBox2:  LDA #$03          ; set specific value for bounding box control                         ;  B
SetBBox2:  STA Enemy_BoundBoxCtrl,X; set bounding box control then leave                            ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitBalPlatform:                                                                                    ;  B
DEC Enemy_Y_Position,X        ; raise vertical position by two pixels                               ; 
DEC Enemy_Y_Position,X                                                                              ; 
LDY SecondaryHardMode         ; if secondary hard mode flag not set,                                ; 
BNE AlignP                    ; branch ahead                                                        ; 
LDY #$02                      ; otherwise set value here                                            ;  B
JSR PosPlatform               ; do a sub to add or subtract pixels                                  ; 
AlignP:  LDY #$ff             ; set default value here for now                                      ;  B
LDA BalPlatformAlignment      ; get current balance platform alignment                              ; 
STA Enemy_State,X             ; set platform alignment to object state here                         ; 
BPL SetBPA                    ; if old alignment $ff, put $ff as alignment for negative             ; 
TXA                           ; if old contents already $ff, put                                    ;  B
TAY                           ; object offset as alignment to make next positive                    ; 
SetBPA:  STY BalPlatformAlignment; store whatever value's in Y here                                 ;  B
LDA #$00                                                                                            ; 
STA Enemy_MovingDir,X         ; init moving direction                                               ; 
TAY                           ; init Y                                                              ; 
JSR PosPlatform               ; do a sub to add 8 pixels, then run shared code here                 ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitDropPlatform:                                                                                   ;  B
LDA #$ff                                                                                            ; 
STA PlatformCollisionFlag,X   ; set some value here                                                 ; 
JMP CommonPlatCode            ; then jump ahead to execute more code                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitHoriPlatform:                                                                                   ;  B
LDA #$00                                                                                            ; 
STA XMoveSecondaryCounter,X   ; init one of the moving counters                                     ; 
JMP CommonPlatCode            ; jump ahead to execute more code                                     ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
InitVertPlatform:                                                                                   ;  B
LDY #$40                      ; set default value here                                              ; 
LDA Enemy_Y_Position,X        ; check vertical position                                             ; 
BPL SetYO                     ; if above a certain point, skip this part                            ; 
EOR #$ff                                                                                            ;  B
CLC                           ; otherwise get two's compliment                                      ; 
ADC #$01                                                                                            ; 
LDY #$c0                      ; get alternate value to add to vertical position                     ; 
SetYO:  STA YPlatformTopYPos,X; save as top vertical position                                       ;  B
TYA                                                                                                 ; 
CLC                           ; load value from earlier, add number of pixels                       ; 
ADC Enemy_Y_Position,X        ; to vertical position                                                ; 
STA YPlatformCenterYPos,X     ; save result as central vertical position                            ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
CommonPlatCode:                                                                                     ;  B
JSR InitVStf                  ; do a sub to init certain other values                               ; 
SPBBox:  LDA #$05             ; set default bounding box size control                               ;  B
LDY AreaType                                                                                        ; 
CPY #$03                      ; check for castle-type level                                         ; 
BEQ CasPBB                    ; use default value if found                                          ; 
LDY SecondaryHardMode         ; otherwise check for secondary hard mode flag                        ;  B
BNE CasPBB                    ; if set, use default value                                           ; 
LDA #$06                      ; use alternate value if not castle or secondary not set              ;  B
CasPBB:  STA Enemy_BoundBoxCtrl,X; set bounding box size control here and leave                     ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
LargeLiftUp:                                                                                        ;  B
JSR PlatLiftUp                ; execute code for platforms going up                                 ; 
JMP LargeLiftBBox             ; overwrite bounding box for large platforms                          ; 
                                                                                                    ;  B
LargeLiftDown:                                                                                      ;  B
JSR PlatLiftDown              ; execute code for platforms going down                               ; 
                                                                                                    ; 
LargeLiftBBox:                                                                                      ;  B
JMP SPBBox                    ; jump to overwrite bounding box size control                         ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
PlatLiftUp:                                                                                         ; fun():  B
LDA #$10                      ; set movement amount here                                            ; 
STA Enemy_Y_MoveForce,X                                                                             ; 
LDA #$ff                      ; set moving speed for platforms going up                             ; 
STA Enemy_Y_Speed,X                                                                                 ; 
JMP CommonSmallLift           ; skip ahead to part we should be executing                           ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
PlatLiftDown:                                                                                       ; fun():  B
LDA #$f0                      ; set movement amount here                                            ; 
STA Enemy_Y_MoveForce,X                                                                             ; 
LDA #$00                      ; set moving speed for platforms going down                           ; 
STA Enemy_Y_Speed,X                                                                                 ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
CommonSmallLift:                                                                                    ;  B
LDY #$01                                                                                            ; 
JSR PosPlatform               ; do a sub to add 12 pixels due to preset value                       ; 
LDA #$04                                                                                            ; 
STA Enemy_BoundBoxCtrl,X      ; set bounding box control for small platforms                        ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
PlatPosDataLow:                                                                                     ;  B
DATA: ByteValue(value=8), ByteValue(value=12), ByteValue(value=248)                                 ; 
                                                                                                    ; 
PlatPosDataHigh:                                                                                    ;  B
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=255)                                  ; 
                                                                                                    ; 
PosPlatform:                                                                                        ; fun():  B
LDA Enemy_X_Position,X        ; get horizontal coordinate                                           ; 
CLC                                                                                                 ; 
ADC PlatPosDataLow,Y          ; add or subtract pixels depending on offset                          ; 
STA Enemy_X_Position,X        ; store as new horizontal coordinate                                  ; 
LDA Enemy_PageLoc,X                                                                                 ; 
ADC PlatPosDataHigh,Y         ; add or subtract page location depending on offset                   ; 
STA Enemy_PageLoc,X           ; store as new page location                                          ; 
RTS                           ; and go back                                                         ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
EndOfEnemyInitCode:                                                                                 ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
RunEnemyObjectsCore:                                                                                ;  B
LDX ObjectOffset              ; get offset for enemy object buffer                                  ; 
LDA #$00                      ; load value 0 for jump engine by default                             ; 
LDY Enemy_ID,X                                                                                      ; 
CPY #$15                      ; if enemy object < $15, use default value                            ; 
BCC JmpEO                                                                                           ; 
TYA                           ; otherwise subtract $14 from the value and use                       ;  B
SBC #$14                      ; as value for jump engine                                            ; 
JmpEO:  JSR JumpEngine                                                                              ;  B
                                                                                                    ; 
DATA: Expr(expr=RunNormalEnemies); for objects $00-$14                                              ; 
                                                                                                    ; 
DATA: Expr(expr=RunBowserFlame); for objects $15-$1f                                                ; 
DATA: Expr(expr=RunFireworks)                                                                       ; 
DATA: Expr(expr=NoRunCode)                                                                          ; 
DATA: Expr(expr=NoRunCode)                                                                          ; 
DATA: Expr(expr=NoRunCode)                                                                          ; 
DATA: Expr(expr=NoRunCode)                                                                          ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=RunFirebarObj); for objects $20-$2f                                                 ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
DATA: Expr(expr=RunFirebarObj)                                                                      ; 
DATA: Expr(expr=NoRunCode)                                                                          ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunLargePlatform)                                                                   ; 
DATA: Expr(expr=RunSmallPlatform)                                                                   ; 
DATA: Expr(expr=RunSmallPlatform)                                                                   ; 
DATA: Expr(expr=RunBowser)                                                                          ; 
DATA: Expr(expr=PowerUpObjHandler)                                                                  ; 
DATA: Expr(expr=VineObjectHandler)                                                                  ; 
                                                                                                    ; 
DATA: Expr(expr=NoRunCode)    ; for objects $30-$35                                                 ; 
DATA: Expr(expr=RunStarFlagObj)                                                                     ; 
DATA: Expr(expr=JumpspringHandler)                                                                  ; 
DATA: Expr(expr=NoRunCode)                                                                          ; 
DATA: Expr(expr=WarpZoneObject)                                                                     ; 
DATA: Expr(expr=RunRetainerObj)                                                                     ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
NoRunCode:                                                                                          ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunRetainerObj:                                                                                     ; fun():  B
JSR GetEnemyOffscreenBits                                                                           ; 
JSR RelativeEnemyPosition                                                                           ; 
JMP EnemyGfxHandler                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunNormalEnemies:                                                                                   ;  B
LDA #$00                      ; init sprite attributes                                              ; 
STA Enemy_SprAttrib,X                                                                               ; 
JSR GetEnemyOffscreenBits                                                                           ; 
JSR RelativeEnemyPosition                                                                           ; 
JSR EnemyGfxHandler                                                                                 ; 
JSR GetEnemyBoundBox                                                                                ; 
JSR EnemyToBGCollisionDet                                                                           ; 
JSR EnemiesCollision                                                                                ; 
JSR PlayerEnemyCollision                                                                            ; 
LDY TimerControl              ; if master timer control set, skip to last routine                   ; 
BNE SkipMove                                                                                        ; 
JSR EnemyMovementSubs                                                                               ;  B
SkipMove:  JMP OffscreenBoundsCheck                                                                 ;  B
                                                                                                    ;  B
EnemyMovementSubs:                                                                                  ; fun():  B
LDA Enemy_ID,X                                                                                      ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=MoveNormalEnemy); only objects $00-$14 use this table                               ; 
DATA: Expr(expr=MoveNormalEnemy)                                                                    ; 
DATA: Expr(expr=MoveNormalEnemy)                                                                    ; 
DATA: Expr(expr=MoveNormalEnemy)                                                                    ; 
DATA: Expr(expr=MoveNormalEnemy)                                                                    ; 
DATA: Expr(expr=ProcHammerBro)                                                                      ; 
DATA: Expr(expr=MoveNormalEnemy)                                                                    ; 
DATA: Expr(expr=MoveBloober)                                                                        ; 
DATA: Expr(expr=MoveBulletBill)                                                                     ; 
DATA: Expr(expr=NoMoveCode)                                                                         ; 
DATA: Expr(expr=MoveSwimmingCheepCheep)                                                             ; 
DATA: Expr(expr=MoveSwimmingCheepCheep)                                                             ; 
DATA: Expr(expr=MovePodoboo)                                                                        ; 
DATA: Expr(expr=MovePiranhaPlant)                                                                   ; 
DATA: Expr(expr=MoveJumpingEnemy)                                                                   ; 
DATA: Expr(expr=ProcMoveRedPTroopa)                                                                 ; 
DATA: Expr(expr=MoveFlyGreenPTroopa)                                                                ; 
DATA: Expr(expr=MoveLakitu)                                                                         ; 
DATA: Expr(expr=MoveNormalEnemy)                                                                    ; 
DATA: Expr(expr=NoMoveCode)   ; dummy                                                               ; 
DATA: Expr(expr=MoveFlyingCheepCheep)                                                               ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
NoMoveCode:                                                                                         ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunBowserFlame:                                                                                     ;  B
JSR ProcBowserFlame                                                                                 ; 
JSR GetEnemyOffscreenBits                                                                           ; 
JSR RelativeEnemyPosition                                                                           ; 
JSR GetEnemyBoundBox                                                                                ; 
JSR PlayerEnemyCollision                                                                            ; 
JMP OffscreenBoundsCheck                                                                            ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunFirebarObj:                                                                                      ;  B
JSR ProcFirebar                                                                                     ; 
JMP OffscreenBoundsCheck                                                                            ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunSmallPlatform:                                                                                   ;  B
JSR GetEnemyOffscreenBits                                                                           ; 
JSR RelativeEnemyPosition                                                                           ; 
JSR SmallPlatformBoundBox                                                                           ; 
JSR SmallPlatformCollision                                                                          ; 
JSR RelativeEnemyPosition                                                                           ; 
JSR DrawSmallPlatform                                                                               ; 
JSR MoveSmallPlatform                                                                               ; 
JMP OffscreenBoundsCheck                                                                            ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunLargePlatform:                                                                                   ;  B
JSR GetEnemyOffscreenBits                                                                           ; 
JSR RelativeEnemyPosition                                                                           ; 
JSR LargePlatformBoundBox                                                                           ; 
JSR LargePlatformCollision                                                                          ; 
LDA TimerControl              ; if master timer control set,                                        ; 
BNE SkipPT                    ; skip subroutine tree                                                ; 
JSR LargePlatformSubroutines                                                                        ;  B
SkipPT:  JSR RelativeEnemyPosition                                                                  ;  B
JSR DrawLargePlatform                                                                               ; 
JMP OffscreenBoundsCheck                                                                            ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
LargePlatformSubroutines:                                                                           ; fun():  B
LDA Enemy_ID,X                ; subtract $24 to get proper offset for jump table                    ; 
SEC                                                                                                 ; 
SBC #$24                                                                                            ; 
JSR JumpEngine                                                                                      ; 
                                                                                                    ; 
DATA: Expr(expr=BalancePlatform); table used by objects $24-$2a                                     ; 
DATA: Expr(expr=YMovingPlatform)                                                                    ; 
DATA: Expr(expr=MoveLargeLiftPlat)                                                                  ; 
DATA: Expr(expr=MoveLargeLiftPlat)                                                                  ; 
DATA: Expr(expr=XMovingPlatform)                                                                    ; 
DATA: Expr(expr=DropPlatform)                                                                       ; 
DATA: Expr(expr=RightPlatform)                                                                      ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
EraseEnemyObject:                                                                                   ; fun():  B
LDA #$00                      ; clear all enemy object variables                                    ; 
STA Enemy_Flag,X                                                                                    ; 
STA Enemy_ID,X                                                                                      ; 
STA Enemy_State,X                                                                                   ; 
STA FloateyNum_Control,X                                                                            ; 
STA EnemyIntervalTimer,X                                                                            ; 
STA ShellChainCounter,X                                                                             ; 
STA Enemy_SprAttrib,X                                                                               ; 
STA EnemyFrameTimer,X                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
MovePodoboo:                                                                                        ;  B
LDA EnemyIntervalTimer,X      ; check enemy timer                                                   ; 
BNE PdbM                      ; branch to move enemy if not expired                                 ; 
JSR InitPodoboo               ; otherwise set up podoboo again                                      ;  B
LDA PseudoRandomBitReg+1,X    ; get part of LSFR                                                    ; 
ORA #%10000000                ; set d7                                                              ; 
STA Enemy_Y_MoveForce,X       ; store as movement force                                             ; 
AND #%00001111                ; mask out high nybble                                                ; 
ORA #$06                      ; set for at least six intervals                                      ; 
STA EnemyIntervalTimer,X      ; store as new enemy timer                                            ; 
LDA #$f9                                                                                            ; 
STA Enemy_Y_Speed,X           ; set vertical speed to move podoboo upwards                          ; 
PdbM:  JMP MoveJ_EnemyVertically; branch to impose gravity on podoboo                               ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used in HammerBroJumpCode as bitmask                          ; 
                                                                                                    ; 
HammerThrowTmrData:                                                                                 ;  B
DATA: ByteValue(value=48), ByteValue(value=28)                                                      ; 
                                                                                                    ; 
XSpeedAdderData:                                                                                    ;  B
DATA: ByteValue(value=0), ByteValue(value=232), ByteValue(value=0), ByteValue(value=24)             ; 
                                                                                                    ; 
RevivedXSpeed:                                                                                      ;  B
DATA: ByteValue(value=8), ByteValue(value=248), ByteValue(value=12), ByteValue(value=244)           ; 
                                                                                                    ; 
ProcHammerBro:                                                                                      ;  B
LDA Enemy_State,X             ; check hammer bro's enemy state for d5 set                           ; 
AND #%00100000                                                                                      ; 
BEQ ChkJH                     ; if not set, go ahead with code                                      ; 
JMP MoveDefeatedEnemy         ; otherwise jump to something else                                    ;  B
ChkJH:  LDA HammerBroJumpTimer,X; check jump timer                                                  ;  B
BEQ HammerBroJumpCode         ; if expired, branch to jump                                          ; 
DEC HammerBroJumpTimer,X      ; otherwise decrement jump timer                                      ;  B
LDA Enemy_OffscreenBits                                                                             ; 
AND #%00001100                ; check offscreen bits                                                ; 
BNE MoveHammerBroXDir         ; if hammer bro a little offscreen, skip to movement code             ; 
LDA HammerThrowingTimer,X     ; check hammer throwing timer                                         ;  B
BNE DecHT                     ; if not expired, skip ahead, do not throw hammer                     ; 
LDY SecondaryHardMode         ; otherwise get secondary hard mode flag                              ;  B
LDA HammerThrowTmrData,Y      ; get timer data using flag as offset                                 ; 
STA HammerThrowingTimer,X     ; set as new timer                                                    ; 
JSR SpawnHammerObj            ; do a sub here to spawn hammer object                                ; 
BCC DecHT                     ; if carry clear, hammer not spawned, skip to decrement timer         ; 
LDA Enemy_State,X                                                                                   ;  B
ORA #%00001000                ; set d3 in enemy state for hammer throw                              ; 
STA Enemy_State,X                                                                                   ; 
JMP MoveHammerBroXDir         ; jump to move hammer bro                                             ; 
DecHT:  DEC HammerThrowingTimer,X; decrement timer                                                  ;  B
JMP MoveHammerBroXDir         ; jump to move hammer bro                                             ; 
                                                                                                    ;  B
HammerBroJumpLData:                                                                                 ;  B
DATA: ByteValue(value=32), ByteValue(value=55)                                                      ; 
                                                                                                    ; 
HammerBroJumpCode:                                                                                  ;  B
LDA Enemy_State,X             ; get hammer bro's enemy state                                        ; 
AND #%00000111                ; mask out all but 3 LSB                                              ; 
CMP #$01                      ; check for d0 set (for jumping)                                      ; 
BEQ MoveHammerBroXDir         ; if set, branch ahead to moving code                                 ; 
LDA #$00                      ; load default value here                                             ;  B
STA $00                       ; save into temp variable for now                                     ; 
LDY #$fa                      ; set default vertical speed                                          ; 
LDA Enemy_Y_Position,X        ; check hammer bro's vertical coordinate                              ; 
BMI SetHJ                     ; if on the bottom half of the screen, use current speed              ; 
LDY #$fd                      ; otherwise set alternate vertical speed                              ;  B
CMP #$70                      ; check to see if hammer bro is above the middle of screen            ; 
INC $00                       ; increment preset value to $01                                       ; 
BCC SetHJ                     ; if above the middle of the screen, use current speed and $01        ; 
DEC $00                       ; otherwise return value to $00                                       ;  B
LDA PseudoRandomBitReg+1,X    ; get part of LSFR, mask out all but LSB                              ; 
AND #$01                                                                                            ; 
BNE SetHJ                     ; if d0 of LSFR set, branch and use current speed and $00             ; 
LDY #$fa                      ; otherwise reset to default vertical speed                           ;  B
SetHJ:  STY Enemy_Y_Speed,X   ; set vertical speed for jumping                                      ;  B
LDA Enemy_State,X             ; set d0 in enemy state for jumping                                   ; 
ORA #$01                                                                                            ; 
STA Enemy_State,X                                                                                   ; 
LDA $00                       ; load preset value here to use as bitmask                            ; 
AND PseudoRandomBitReg+2,X    ; and do bit-wise comparison with part of LSFR                        ; 
TAY                           ; then use as offset                                                  ; 
LDA SecondaryHardMode         ; check secondary hard mode flag                                      ; 
BNE HJump                                                                                           ; 
TAY                           ; if secondary hard mode flag clear, set offset to 0                  ;  B
HJump:  LDA HammerBroJumpLData,Y; get jump length timer data using offset from before               ;  B
STA EnemyFrameTimer,X         ; save in enemy timer                                                 ; 
LDA PseudoRandomBitReg+1,X                                                                          ; 
ORA #%11000000                ; get contents of part of LSFR, set d7 and d6, then                   ; 
STA HammerBroJumpTimer,X      ; store in jump timer                                                 ; 
                                                                                                    ; 
MoveHammerBroXDir:                                                                                  ;  B
LDY #$fc                      ; move hammer bro a little to the left                                ; 
LDA FrameCounter                                                                                    ; 
AND #%01000000                ; change hammer bro's direction every 64 frames                       ; 
BNE Shimmy                                                                                          ; 
LDY #$04                      ; if d6 set in counter, move him a little to the right                ;  B
Shimmy:  STY Enemy_X_Speed,X  ; store horizontal speed                                              ;  B
LDY #$01                      ; set to face right by default                                        ; 
JSR PlayerEnemyDiff           ; get horizontal difference between player and hammer bro             ; 
BMI SetShim                   ; if enemy to the left of player, skip this part                      ; 
INY                           ; set to face left                                                    ;  B
LDA EnemyIntervalTimer,X      ; check walking timer                                                 ; 
BNE SetShim                   ; if not yet expired, skip to set moving direction                    ; 
LDA #$f8                                                                                            ;  B
STA Enemy_X_Speed,X           ; otherwise, make the hammer bro walk left towards player             ; 
SetShim:  STY Enemy_MovingDir,X; set moving direction                                               ;  B
                                                                                                    ; 
MoveNormalEnemy:                                                                                    ; fun():  B
LDY #$00                      ; init Y to leave horizontal movement as-is                           ; 
LDA Enemy_State,X                                                                                   ; 
AND #%01000000                ; check enemy state for d6 set, if set skip                           ; 
BNE FallE                     ; to move enemy vertically, then horizontally if necessary            ; 
LDA Enemy_State,X                                                                                   ;  B
ASL                           ; check enemy state for d7 set                                        ; 
BCS SteadM                    ; if set, branch to move enemy horizontally                           ; 
LDA Enemy_State,X                                                                                   ;  B
AND #%00100000                ; check enemy state for d5 set                                        ; 
BNE MoveDefeatedEnemy         ; if set, branch to move defeated enemy object                        ; 
LDA Enemy_State,X                                                                                   ;  B
AND #%00000111                ; check d2-d0 of enemy state for any set bits                         ; 
BEQ SteadM                    ; if enemy in normal state, branch to move enemy horizontally         ; 
CMP #$05                                                                                            ;  B
BEQ FallE                     ; if enemy in state used by spiny's egg, go ahead here                ; 
CMP #$03                                                                                            ;  B
BCS ReviveStunned             ; if enemy in states $03 or $04, skip ahead to yet another part       ; 
FallE:  JSR MoveD_EnemyVertically; do a sub here to move enemy downwards                            ;  B
LDY #$00                                                                                            ; 
LDA Enemy_State,X             ; check for enemy state $02                                           ; 
CMP #$02                                                                                            ; 
BEQ MEHor                     ; if found, branch to move enemy horizontally                         ; 
AND #%01000000                ; check for d6 set                                                    ;  B
BEQ SteadM                    ; if not set, branch to something else                                ; 
LDA Enemy_ID,X                                                                                      ;  B
CMP #PowerUpObject            ; check for power-up object                                           ; 
BEQ SteadM                                                                                          ; 
BNE SlowM                     ; if any other object where d6 set, jump to set Y                     ;  B
MEHor:  JMP MoveEnemyHorizontally; jump here to move enemy horizontally for <> $2e and d6 set       ;  B
                                                                                                    ;  B
SlowM:  LDY #$01              ; if branched here, increment Y to slow horizontal movement           ;  B
SteadM:  LDA Enemy_X_Speed,X  ; get current horizontal speed                                        ;  B
PHA                           ; save to stack                                                       ; 
BPL AddHS                     ; if not moving or moving right, skip, leave Y alone                  ; 
INY                                                                                                 ;  B
INY                           ; otherwise increment Y to next data                                  ; 
AddHS:  CLC                                                                                         ;  B
ADC XSpeedAdderData,Y         ; add value here to slow enemy down if necessary                      ; 
STA Enemy_X_Speed,X           ; save as horizontal speed temporarily                                ; 
JSR MoveEnemyHorizontally     ; then do a sub to move horizontally                                  ; 
PLA                                                                                                 ; 
STA Enemy_X_Speed,X           ; get old horizontal speed from stack and return to                   ; 
RTS                           ; original memory location, then leave                                ; 
                                                                                                    ;  B
ReviveStunned:                                                                                      ;  B
LDA EnemyIntervalTimer,X      ; if enemy timer not expired yet,                                     ; 
BNE ChkKillGoomba             ; skip ahead to something else                                        ; 
STA Enemy_State,X             ; otherwise initialize enemy state to normal                          ;  B
LDA FrameCounter                                                                                    ; 
AND #$01                      ; get d0 of frame counter                                             ; 
TAY                           ; use as Y and increment for movement direction                       ; 
INY                                                                                                 ; 
STY Enemy_MovingDir,X         ; store as pseudorandom movement direction                            ; 
DEY                           ; decrement for use as pointer                                        ; 
LDA PrimaryHardMode           ; check primary hard mode flag                                        ; 
BEQ SetRSpd                   ; if not set, use pointer as-is                                       ; 
INY                                                                                                 ;  B
INY                           ; otherwise increment 2 bytes to next data                            ; 
SetRSpd:  LDA RevivedXSpeed,Y ; load and store new horizontal speed                                 ;  B
STA Enemy_X_Speed,X           ; and leave                                                           ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
MoveDefeatedEnemy:                                                                                  ;  B
JSR MoveD_EnemyVertically     ; execute sub to move defeated enemy downwards                        ; 
JMP MoveEnemyHorizontally     ; now move defeated enemy horizontally                                ; 
                                                                                                    ;  B
ChkKillGoomba:                                                                                      ;  B
CMP #$0e                      ; check to see if enemy timer has reached                             ; 
BNE NKGmba                    ; a certain point, and branch to leave if not                         ; 
LDA Enemy_ID,X                                                                                      ;  B
CMP #Goomba                   ; check for goomba object                                             ; 
BNE NKGmba                    ; branch if not found                                                 ; 
JSR EraseEnemyObject          ; otherwise, kill this goomba object                                  ;  B
NKGmba:  RTS                  ; leave!                                                              ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveJumpingEnemy:                                                                                   ; fun():  B
JSR MoveJ_EnemyVertically     ; do a sub to impose gravity on green paratroopa                      ; 
JMP MoveEnemyHorizontally     ; jump to move enemy horizontally                                     ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ProcMoveRedPTroopa:                                                                                 ;  B
LDA Enemy_Y_Speed,X                                                                                 ; 
ORA Enemy_Y_MoveForce,X       ; check for any vertical force or speed                               ; 
BNE MoveRedPTUpOrDown         ; branch if any found                                                 ; 
STA Enemy_YMF_Dummy,X         ; initialize something here                                           ;  B
LDA Enemy_Y_Position,X        ; check current vs. original vertical coordinate                      ; 
CMP RedPTroopaOrigXPos,X                                                                            ; 
BCS MoveRedPTUpOrDown         ; if current => original, skip ahead to more code                     ; 
LDA FrameCounter              ; get frame counter                                                   ;  B
AND #%00000111                ; mask out all but 3 LSB                                              ; 
BNE NoIncPT                   ; if any bits set, branch to leave                                    ; 
INC Enemy_Y_Position,X        ; otherwise increment red paratroopa's vertical position              ;  B
NoIncPT:  RTS                 ; leave                                                               ;  B
                                                                                                    ;  B
MoveRedPTUpOrDown:                                                                                  ;  B
LDA Enemy_Y_Position,X        ; check current vs. central vertical coordinate                       ; 
CMP RedPTroopaCenterYPos,X                                                                          ; 
BCC MovPTDwn                  ; if current < central, jump to move downwards                        ; 
JMP MoveRedPTroopaUp          ; otherwise jump to move upwards                                      ;  B
MovPTDwn:  JMP MoveRedPTroopaDown; move downwards                                                   ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to store adder for movement, also used as adder for platform; 
                              ; $01 - used to store maximum value for secondary counter             ; 
                                                                                                    ; 
MoveFlyGreenPTroopa:                                                                                ;  B
JSR XMoveCntr_GreenPTroopa    ; do sub to increment primary and secondary counters                  ; 
JSR MoveWithXMCntrs           ; do sub to move green paratroopa accordingly, and horizontally       ; 
LDY #$01                      ; set Y to move green paratroopa down                                 ; 
LDA FrameCounter                                                                                    ; 
AND #%00000011                ; check frame counter 2 LSB for any bits set                          ; 
BNE NoMGPT                    ; branch to leave if set to move up/down every fourth frame           ; 
LDA FrameCounter                                                                                    ;  B
AND #%01000000                ; check frame counter for d6 set                                      ; 
BNE YSway                     ; branch to move green paratroopa down if set                         ; 
LDY #$ff                      ; otherwise set Y to move green paratroopa up                         ;  B
YSway:  STY $00               ; store adder here                                                    ;  B
LDA Enemy_Y_Position,X                                                                              ; 
CLC                           ; add or subtract from vertical position                              ; 
ADC $00                       ; to give green paratroopa a wavy flight                              ; 
STA Enemy_Y_Position,X                                                                              ; 
NoMGPT:  RTS                  ; leave!                                                              ;  B
                                                                                                    ;  B
XMoveCntr_GreenPTroopa:                                                                             ; fun():  B
LDA #$13                      ; load preset maximum value for secondary counter                     ; 
                                                                                                    ; 
XMoveCntr_Platform:                                                                                 ; fun(A):  B
STA $01                       ; store value here                                                    ; 
LDA FrameCounter                                                                                    ; 
AND #%00000011                ; branch to leave if not on                                           ; 
BNE NoIncXM                   ; every fourth frame                                                  ; 
LDY XMoveSecondaryCounter,X   ; get secondary counter                                               ;  B
LDA XMovePrimaryCounter,X     ; get primary counter                                                 ; 
LSR                                                                                                 ; 
BCS DecSeXM                   ; if d0 of primary counter set, branch elsewhere                      ; 
CPY $01                       ; compare secondary counter to preset maximum value                   ;  B
BEQ IncPXM                    ; if equal, branch ahead of this part                                 ; 
INC XMoveSecondaryCounter,X   ; increment secondary counter and leave                               ;  B
NoIncXM:  RTS                                                                                       ;  B
IncPXM:  INC XMovePrimaryCounter,X; increment primary counter and leave                             ;  B
RTS                                                                                                 ; 
DecSeXM:  TYA                 ; put secondary counter in A                                          ;  B
BEQ IncPXM                    ; if secondary counter at zero, branch back                           ; 
DEC XMoveSecondaryCounter,X   ; otherwise decrement secondary counter and leave                     ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
MoveWithXMCntrs:                                                                                    ; fun():  B
LDA XMoveSecondaryCounter,X   ; save secondary counter to stack                                     ; 
PHA                                                                                                 ; 
LDY #$01                      ; set value here by default                                           ; 
LDA XMovePrimaryCounter,X                                                                           ; 
AND #%00000010                ; if d1 of primary counter is                                         ; 
BNE XMRight                   ; set, branch ahead of this part here                                 ; 
LDA XMoveSecondaryCounter,X                                                                         ;  B
EOR #$ff                      ; otherwise change secondary                                          ; 
CLC                           ; counter to two's compliment                                         ; 
ADC #$01                                                                                            ; 
STA XMoveSecondaryCounter,X                                                                         ; 
LDY #$02                      ; load alternate value here                                           ; 
XMRight:  STY Enemy_MovingDir,X; store as moving direction                                          ;  B
JSR MoveEnemyHorizontally                                                                           ; 
STA $00                       ; save value obtained from sub here                                   ; 
PLA                           ; get secondary counter from stack                                    ; 
STA XMoveSecondaryCounter,X   ; and return to original place                                        ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BlooberBitmasks:                                                                                    ;  B
DATA: ByteValue(value=63), ByteValue(value=3)                                                       ; 
                                                                                                    ; 
MoveBloober:                                                                                        ;  B
LDA Enemy_State,X                                                                                   ; 
AND #%00100000                ; check enemy state for d5 set                                        ; 
BNE MoveDefeatedBloober       ; branch if set to move defeated bloober                              ; 
LDY SecondaryHardMode         ; use secondary hard mode flag as offset                              ;  B
LDA PseudoRandomBitReg+1,X    ; get LSFR                                                            ; 
AND BlooberBitmasks,Y         ; mask out bits in LSFR using bitmask loaded with offset              ; 
BNE BlooberSwim               ; if any bits set, skip ahead to make swim                            ; 
TXA                                                                                                 ;  B
LSR                           ; check to see if on second or fourth slot (1 or 3)                   ; 
BCC FBLeft                    ; if not, branch to figure out moving direction                       ; 
LDY Player_MovingDir          ; otherwise, load player's moving direction and                       ;  B
BCS SBMDir                    ; do an unconditional branch to set                                   ; 
FBLeft:  LDY #$02             ; set left moving direction by default                                ;  B
JSR PlayerEnemyDiff           ; get horizontal difference between player and bloober                ; 
BPL SBMDir                    ; if enemy to the right of player, keep left                          ; 
DEY                           ; otherwise decrement to set right moving direction                   ;  B
SBMDir:  STY Enemy_MovingDir,X; set moving direction of bloober, then continue on here              ;  B
                                                                                                    ; 
BlooberSwim:                                                                                        ;  B
JSR ProcSwimmingB             ; execute sub to make bloober swim characteristically                 ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
SEC                                                                                                 ; 
SBC Enemy_Y_MoveForce,X       ; subtract movement force                                             ; 
CMP #$20                      ; check to see if position is above edge of status bar                ; 
BCC SwimX                     ; if so, don't do it                                                  ; 
STA Enemy_Y_Position,X        ; otherwise, set new vertical position, make bloober swim             ;  B
SwimX:  LDY Enemy_MovingDir,X ; check moving direction                                              ;  B
DEY                                                                                                 ; 
BNE LeftSwim                  ; if moving to the left, branch to second part                        ; 
LDA Enemy_X_Position,X                                                                              ;  B
CLC                           ; add movement speed to horizontal coordinate                         ; 
ADC BlooperMoveSpeed,X                                                                              ; 
STA Enemy_X_Position,X        ; store result as new horizontal coordinate                           ; 
LDA Enemy_PageLoc,X                                                                                 ; 
ADC #$00                      ; add carry to page location                                          ; 
STA Enemy_PageLoc,X           ; store as new page location and leave                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
LeftSwim:                                                                                           ;  B
LDA Enemy_X_Position,X                                                                              ; 
SEC                           ; subtract movement speed from horizontal coordinate                  ; 
SBC BlooperMoveSpeed,X                                                                              ; 
STA Enemy_X_Position,X        ; store result as new horizontal coordinate                           ; 
LDA Enemy_PageLoc,X                                                                                 ; 
SBC #$00                      ; subtract borrow from page location                                  ; 
STA Enemy_PageLoc,X           ; store as new page location and leave                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
MoveDefeatedBloober:                                                                                ;  B
JMP MoveEnemySlowVert         ; jump to move defeated bloober downwards                             ; 
                                                                                                    ;  B
ProcSwimmingB:                                                                                      ; fun():  B
LDA BlooperMoveCounter,X      ; get enemy's movement counter                                        ; 
AND #%00000010                ; check for d1 set                                                    ; 
BNE ChkForFloatdown           ; branch if set                                                       ; 
LDA FrameCounter                                                                                    ;  B
AND #%00000111                ; get 3 LSB of frame counter                                          ; 
PHA                           ; and save it to the stack                                            ; 
LDA BlooperMoveCounter,X      ; get enemy's movement counter                                        ; 
LSR                           ; check for d0 set                                                    ; 
BCS SlowSwim                  ; branch if set                                                       ; 
PLA                           ; pull 3 LSB of frame counter from the stack                          ;  B
BNE BSwimE                    ; branch to leave, execute code only every eighth frame               ; 
LDA Enemy_Y_MoveForce,X                                                                             ;  B
CLC                           ; add to movement force to speed up swim                              ; 
ADC #$01                                                                                            ; 
STA Enemy_Y_MoveForce,X       ; set movement force                                                  ; 
STA BlooperMoveSpeed,X        ; set as movement speed                                               ; 
CMP #$02                                                                                            ; 
BNE BSwimE                    ; if certain horizontal speed, branch to leave                        ; 
INC BlooperMoveCounter,X      ; otherwise increment movement counter                                ;  B
BSwimE:  RTS                                                                                        ;  B
                                                                                                    ;  B
SlowSwim:                                                                                           ;  B
PLA                           ; pull 3 LSB of frame counter from the stack                          ; 
BNE NoSSw                     ; branch to leave, execute code only every eighth frame               ; 
LDA Enemy_Y_MoveForce,X                                                                             ;  B
SEC                           ; subtract from movement force to slow swim                           ; 
SBC #$01                                                                                            ; 
STA Enemy_Y_MoveForce,X       ; set movement force                                                  ; 
STA BlooperMoveSpeed,X        ; set as movement speed                                               ; 
BNE NoSSw                     ; if any speed, branch to leave                                       ; 
INC BlooperMoveCounter,X      ; otherwise increment movement counter                                ;  B
LDA #$02                                                                                            ; 
STA EnemyIntervalTimer,X      ; set enemy's timer                                                   ; 
NoSSw:  RTS                   ; leave                                                               ;  B
                                                                                                    ;  B
ChkForFloatdown:                                                                                    ;  B
LDA EnemyIntervalTimer,X      ; get enemy timer                                                     ; 
BEQ ChkNearPlayer             ; branch if expired                                                   ; 
                                                                                                    ;  B
Floatdown:                                                                                          ;  B
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; check for d0 set                                                    ; 
BCS NoFD                      ; branch to leave on every other frame                                ; 
INC Enemy_Y_Position,X        ; otherwise increment vertical coordinate                             ;  B
NoFD:  RTS                    ; leave                                                               ;  B
                                                                                                    ;  B
ChkNearPlayer:                                                                                      ;  B
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
ADC #$10                      ; add sixteen pixels                                                  ; 
CMP Player_Y_Position         ; compare result with player's vertical coordinate                    ; 
BCC Floatdown                 ; if modified vertical less than player's, branch                     ; 
LDA #$00                                                                                            ;  B
STA BlooperMoveCounter,X      ; otherwise nullify movement counter                                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveBulletBill:                                                                                     ;  B
LDA Enemy_State,X             ; check bullet bill's enemy object state for d5 set                   ; 
AND #%00100000                                                                                      ; 
BEQ NotDefB                   ; if not set, continue with movement code                             ; 
JMP MoveJ_EnemyVertically     ; otherwise jump to move defeated bullet bill downwards               ;  B
NotDefB:  LDA #$e8            ; set bullet bill's horizontal speed                                  ;  B
STA Enemy_X_Speed,X           ; and move it accordingly (note: this bullet bill                     ; 
JMP MoveEnemyHorizontally     ; object occurs in frenzy object $17, not from cannons)               ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $02 - used to hold preset values                                    ; 
                              ; $03 - used to hold enemy state                                      ; 
                                                                                                    ; 
SwimCCXMoveData:                                                                                    ;  B
DATA: ByteValue(value=64), ByteValue(value=128)                                                     ; 
DATA: ByteValue(value=4), ByteValue(value=4); residual data, not used                               ; 
                                                                                                    ; 
MoveSwimmingCheepCheep:                                                                             ;  B
LDA Enemy_State,X             ; check cheep-cheep's enemy object state                              ; 
AND #%00100000                ; for d5 set                                                          ; 
BEQ CCSwim                    ; if not set, continue with movement code                             ; 
JMP MoveEnemySlowVert         ; otherwise jump to move defeated cheep-cheep downwards               ;  B
CCSwim:  STA $03              ; save enemy state in $03                                             ;  B
LDA Enemy_ID,X                ; get enemy identifier                                                ; 
SEC                                                                                                 ; 
SBC #$0a                      ; subtract ten for cheep-cheep identifiers                            ; 
TAY                           ; use as offset                                                       ; 
LDA SwimCCXMoveData,Y         ; load value here                                                     ; 
STA $02                                                                                             ; 
LDA Enemy_X_MoveForce,X       ; load horizontal force                                               ; 
SEC                                                                                                 ; 
SBC $02                       ; subtract preset value from horizontal force                         ; 
STA Enemy_X_MoveForce,X       ; store as new horizontal force                                       ; 
LDA Enemy_X_Position,X        ; get horizontal coordinate                                           ; 
SBC #$00                      ; subtract borrow (thus moving it slowly)                             ; 
STA Enemy_X_Position,X        ; and save as new horizontal coordinate                               ; 
LDA Enemy_PageLoc,X                                                                                 ; 
SBC #$00                      ; subtract borrow again, this time from the                           ; 
STA Enemy_PageLoc,X           ; page location, then save                                            ; 
LDA #$20                                                                                            ; 
STA $02                       ; save new value here                                                 ; 
CPX #$02                      ; check enemy object offset                                           ; 
BCC ExSwCC                    ; if in first or second slot, branch to leave                         ; 
LDA CheepCheepMoveMFlag,X     ; check movement flag                                                 ;  B
CMP #$10                      ; if movement speed set to $00,                                       ; 
BCC CCSwimUpwards             ; branch to move upwards                                              ; 
LDA Enemy_YMF_Dummy,X                                                                               ;  B
CLC                                                                                                 ; 
ADC $02                       ; add preset value to dummy variable to get carry                     ; 
STA Enemy_YMF_Dummy,X         ; and save dummy                                                      ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
ADC $03                       ; add carry to it plus enemy state to slowly move it downwards        ; 
STA Enemy_Y_Position,X        ; save as new vertical coordinate                                     ; 
LDA Enemy_Y_HighPos,X                                                                               ; 
ADC #$00                      ; add carry to page location and                                      ; 
JMP ChkSwimYPos               ; jump to end of movement code                                        ; 
                                                                                                    ;  B
CCSwimUpwards:                                                                                      ;  B
LDA Enemy_YMF_Dummy,X                                                                               ; 
SEC                                                                                                 ; 
SBC $02                       ; subtract preset value to dummy variable to get borrow               ; 
STA Enemy_YMF_Dummy,X         ; and save dummy                                                      ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
SBC $03                       ; subtract borrow to it plus enemy state to slowly move it upwards    ; 
STA Enemy_Y_Position,X        ; save as new vertical coordinate                                     ; 
LDA Enemy_Y_HighPos,X                                                                               ; 
SBC #$00                      ; subtract borrow from page location                                  ; 
                                                                                                    ; 
ChkSwimYPos:                                                                                        ;  B
STA Enemy_Y_HighPos,X         ; save new page location here                                         ; 
LDY #$00                      ; load movement speed to upwards by default                           ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
SEC                                                                                                 ; 
SBC CheepCheepOrigYPos,X      ; subtract original coordinate from current                           ; 
BPL YPDiff                    ; if result positive, skip to next part                               ; 
LDY #$10                      ; otherwise load movement speed to downwards                          ;  B
EOR #$ff                                                                                            ; 
CLC                           ; get two's compliment of result                                      ; 
ADC #$01                      ; to obtain total difference of original vs. current                  ; 
YPDiff:  CMP #$0f             ; if difference between original vs. current vertical                 ;  B
BCC ExSwCC                    ; coordinates < 15 pixels, leave movement speed alone                 ; 
TYA                                                                                                 ;  B
STA CheepCheepMoveMFlag,X     ; otherwise change movement speed                                     ; 
ExSwCC:  RTS                  ; leave                                                               ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used as counter for firebar parts                             ; 
                              ; $01 - used for oscillated high byte of spin state or to hold horizontal adder; 
                              ; $02 - used for oscillated high byte of spin state or to hold vertical adder; 
                              ; $03 - used for mirror data                                          ; 
                              ; $04 - used to store player's sprite 1 X coordinate                  ; 
                              ; $05 - used to evaluate mirror data                                  ; 
                              ; $06 - used to store either screen X coordinate or sprite data offset; 
                              ; $07 - used to store screen Y coordinate                             ; 
                              ; $ed - used to hold maximum length of firebar                        ; 
                              ; $ef - used to hold high byte of spinstate                           ; 
                                                                                                    ; 
                              ; horizontal adder is at first byte + high byte of spinstate,         ; 
                              ; vertical adder is same + 8 bytes, two's compliment                  ; 
                              ; if greater than $08 for proper oscillation                          ; 
FirebarPosLookupTbl:                                                                                ;  B
DATA: ByteValue(value=0), ByteValue(value=1), ByteValue(value=3), ByteValue(value=4), ByteValue(value=5), ByteValue(value=6), ByteValue(value=7), ByteValue(value=7), ByteValue(value=8); 
DATA: ByteValue(value=0), ByteValue(value=3), ByteValue(value=6), ByteValue(value=9), ByteValue(value=11), ByteValue(value=13), ByteValue(value=14), ByteValue(value=15), ByteValue(value=16); 
DATA: ByteValue(value=0), ByteValue(value=4), ByteValue(value=9), ByteValue(value=13), ByteValue(value=16), ByteValue(value=19), ByteValue(value=22), ByteValue(value=23), ByteValue(value=24); 
DATA: ByteValue(value=0), ByteValue(value=6), ByteValue(value=12), ByteValue(value=18), ByteValue(value=22), ByteValue(value=26), ByteValue(value=29), ByteValue(value=31), ByteValue(value=32); 
DATA: ByteValue(value=0), ByteValue(value=7), ByteValue(value=15), ByteValue(value=22), ByteValue(value=28), ByteValue(value=33), ByteValue(value=37), ByteValue(value=39), ByteValue(value=40); 
DATA: ByteValue(value=0), ByteValue(value=9), ByteValue(value=18), ByteValue(value=27), ByteValue(value=33), ByteValue(value=39), ByteValue(value=44), ByteValue(value=47), ByteValue(value=48); 
DATA: ByteValue(value=0), ByteValue(value=11), ByteValue(value=21), ByteValue(value=31), ByteValue(value=39), ByteValue(value=46), ByteValue(value=51), ByteValue(value=55), ByteValue(value=56); 
DATA: ByteValue(value=0), ByteValue(value=12), ByteValue(value=24), ByteValue(value=36), ByteValue(value=45), ByteValue(value=53), ByteValue(value=59), ByteValue(value=62), ByteValue(value=64); 
DATA: ByteValue(value=0), ByteValue(value=14), ByteValue(value=27), ByteValue(value=40), ByteValue(value=50), ByteValue(value=59), ByteValue(value=66), ByteValue(value=70), ByteValue(value=72); 
DATA: ByteValue(value=0), ByteValue(value=15), ByteValue(value=31), ByteValue(value=45), ByteValue(value=56), ByteValue(value=66), ByteValue(value=74), ByteValue(value=78), ByteValue(value=80); 
DATA: ByteValue(value=0), ByteValue(value=17), ByteValue(value=34), ByteValue(value=49), ByteValue(value=62), ByteValue(value=73), ByteValue(value=81), ByteValue(value=86), ByteValue(value=88); 
                                                                                                    ; 
FirebarMirrorData:                                                                                  ;  B
DATA: ByteValue(value=1), ByteValue(value=3), ByteValue(value=2), ByteValue(value=0)                ; 
                                                                                                    ; 
FirebarTblOffsets:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=9), ByteValue(value=18), ByteValue(value=27), ByteValue(value=36), ByteValue(value=45); 
DATA: ByteValue(value=54), ByteValue(value=63), ByteValue(value=72), ByteValue(value=81), ByteValue(value=90), ByteValue(value=99); 
                                                                                                    ; 
FirebarYPos:                                                                                        ;  B
DATA: ByteValue(value=12), ByteValue(value=24)                                                      ; 
                                                                                                    ; 
ProcFirebar:                                                                                        ; fun():  B
JSR GetEnemyOffscreenBits     ; get offscreen information                                           ; 
LDA Enemy_OffscreenBits       ; check for d3 set                                                    ; 
AND #%00001000                ; if so, branch to leave                                              ; 
BNE SkipFBar                                                                                        ; 
LDA TimerControl              ; if master timer control set, branch                                 ;  B
BNE SusFbar                   ; ahead of this part                                                  ; 
LDA FirebarSpinSpeed,X        ; load spinning speed of firebar                                      ;  B
JSR FirebarSpin               ; modify current spinstate                                            ; 
AND #%00011111                ; mask out all but 5 LSB                                              ; 
STA FirebarSpinState_High,X   ; and store as new high byte of spinstate                             ; 
SusFbar:  LDA FirebarSpinState_High,X; get high byte of spinstate                                   ;  B
LDY Enemy_ID,X                ; check enemy identifier                                              ; 
CPY #$1f                                                                                            ; 
BCC SetupGFB                  ; if < $1f (long firebar), branch                                     ; 
CMP #$08                      ; check high byte of spinstate                                        ;  B
BEQ SkpFSte                   ; if eight, branch to change                                          ; 
CMP #$18                                                                                            ;  B
BNE SetupGFB                  ; if not at twenty-four branch to not change                          ; 
SkpFSte:  CLC                                                                                       ;  B
ADC #$01                      ; add one to spinning thing to avoid horizontal state                 ; 
STA FirebarSpinState_High,X                                                                         ; 
SetupGFB:  STA $ef            ; save high byte of spinning thing, modified or otherwise             ;  B
JSR RelativeEnemyPosition     ; get relative coordinates to screen                                  ; 
JSR GetFirebarPosition        ; do a sub here (residual, too early to be used now)                  ; 
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDA Enemy_Rel_YPos            ; get relative vertical coordinate                                    ; 
STA Sprite_Y_Position,Y       ; store as Y in OAM data                                              ; 
STA $07                       ; also save here                                                      ; 
LDA Enemy_Rel_XPos            ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y       ; store as X in OAM data                                              ; 
STA $06                       ; also save here                                                      ; 
LDA #$01                                                                                            ; 
STA $00                       ; set $01 value here (not necessary)                                  ; 
JSR FirebarCollision          ; draw fireball part and do collision detection                       ; 
LDY #$05                      ; load value for short firebars by default                            ; 
LDA Enemy_ID,X                                                                                      ; 
CMP #$1f                      ; are we doing a long firebar?                                        ; 
BCC SetMFbar                  ; no, branch then                                                     ; 
LDY #$0b                      ; otherwise load value for long firebars                              ;  B
SetMFbar:  STY $ed            ; store maximum value for length of firebars                          ;  B
LDA #$00                                                                                            ; 
STA $00                       ; initialize counter here                                             ; 
DrawFbar:  LDA $ef            ; load high byte of spinstate                                         ;  B
JSR GetFirebarPosition        ; get fireball position data depending on firebar part                ; 
JSR DrawFirebar_Collision     ; position it properly, draw it and do collision detection            ; 
LDA $00                       ; check which firebar part                                            ; 
CMP #$04                                                                                            ; 
BNE NextFbar                                                                                        ; 
LDY DuplicateObj_Offset       ; if we arrive at fifth firebar part,                                 ;  B
LDA Enemy_SprDataOffset,Y     ; get offset from long firebar and load OAM data offset               ; 
STA $06                       ; using long firebar offset, then store as new one here               ; 
NextFbar:  INC $00            ; move onto the next firebar part                                     ;  B
LDA $00                                                                                             ; 
CMP $ed                       ; if we end up at the maximum part, go on and leave                   ; 
BCC DrawFbar                  ; otherwise go back and do another                                    ; 
SkipFBar:  RTS                                                                                      ;  B
                                                                                                    ;  B
DrawFirebar_Collision:                                                                              ; fun($03$06$01$02):  B
LDA $03                       ; store mirror data elsewhere                                         ; 
STA $05                                                                                             ; 
LDY $06                       ; load OAM data offset for firebar                                    ; 
LDA $01                       ; load horizontal adder we got from position loader                   ; 
LSR $05                       ; shift LSB of mirror data                                            ; 
BCS AddHA                     ; if carry was set, skip this part                                    ; 
EOR #$ff                                                                                            ;  B
ADC #$01                      ; otherwise get two's compliment of horizontal adder                  ; 
AddHA:  CLC                   ; add horizontal coordinate relative to screen to                     ;  B
ADC Enemy_Rel_XPos            ; horizontal adder, modified or otherwise                             ; 
STA Sprite_X_Position,Y       ; store as X coordinate here                                          ; 
STA $06                       ; store here for now, note offset is saved in Y still                 ; 
CMP Enemy_Rel_XPos            ; compare X coordinate of sprite to original X of firebar             ; 
BCS SubtR1                    ; if sprite coordinate => original coordinate, branch                 ; 
LDA Enemy_Rel_XPos                                                                                  ;  B
SEC                           ; otherwise subtract sprite X from the                                ; 
SBC $06                       ; original one and skip this part                                     ; 
JMP ChkFOfs                                                                                         ; 
SubtR1:  SEC                  ; subtract original X from the                                        ;  B
SBC Enemy_Rel_XPos            ; current sprite X                                                    ; 
ChkFOfs:  CMP #$59            ; if difference of coordinates within a certain range,                ;  B
BCC VAHandl                   ; continue by handling vertical adder                                 ; 
LDA #$f8                      ; otherwise, load offscreen Y coordinate                              ;  B
BNE SetVFbr                   ; and unconditionally branch to move sprite offscreen                 ; 
VAHandl:  LDA Enemy_Rel_YPos  ; if vertical relative coordinate offscreen,                          ;  B
CMP #$f8                      ; skip ahead of this part and write into sprite Y coordinate          ; 
BEQ SetVFbr                                                                                         ; 
LDA $02                       ; load vertical adder we got from position loader                     ;  B
LSR $05                       ; shift LSB of mirror data one more time                              ; 
BCS AddVA                     ; if carry was set, skip this part                                    ; 
EOR #$ff                                                                                            ;  B
ADC #$01                      ; otherwise get two's compliment of second part                       ; 
AddVA:  CLC                   ; add vertical coordinate relative to screen to                       ;  B
ADC Enemy_Rel_YPos            ; the second data, modified or otherwise                              ; 
SetVFbr:  STA Sprite_Y_Position,Y; store as Y coordinate here                                       ;  B
STA $07                       ; also store here for now                                             ; 
                                                                                                    ; 
FirebarCollision:                                                                                   ; fun(Y$07$00):  B
JSR DrawFirebar               ; run sub here to draw current tile of firebar                        ; 
TYA                           ; return OAM data offset and save                                     ; 
PHA                           ; to the stack for now                                                ; 
LDA StarInvincibleTimer       ; if star mario invincibility timer                                   ; 
ORA TimerControl              ; or master timer controls set                                        ; 
BNE NoColFB                   ; then skip all of this                                               ; 
STA $05                       ; otherwise initialize counter                                        ;  B
LDY Player_Y_HighPos                                                                                ; 
DEY                           ; if player's vertical high byte offscreen,                           ; 
BNE NoColFB                   ; skip all of this                                                    ; 
LDY Player_Y_Position         ; get player's vertical position                                      ;  B
LDA PlayerSize                ; get player's size                                                   ; 
BNE AdjSm                     ; if player small, branch to alter variables                          ; 
LDA CrouchingFlag                                                                                   ;  B
BEQ BigJp                     ; if player big and not crouching, jump ahead                         ; 
AdjSm:  INC $05               ; if small or big but crouching, execute this part                    ;  B
INC $05                       ; first increment our counter twice (setting $02 as flag)             ; 
TYA                                                                                                 ; 
CLC                           ; then add 24 pixels to the player's                                  ; 
ADC #$18                      ; vertical coordinate                                                 ; 
TAY                                                                                                 ; 
BigJp:  TYA                   ; get vertical coordinate, altered or otherwise, from Y               ;  B
FBCLoop:  SEC                 ; subtract vertical position of firebar                               ;  B
SBC $07                       ; from the vertical coordinate of the player                          ; 
BPL ChkVFBD                   ; if player lower on the screen than firebar,                         ; 
EOR #$ff                      ; skip two's compliment part                                          ;  B
CLC                           ; otherwise get two's compliment                                      ; 
ADC #$01                                                                                            ; 
ChkVFBD:  CMP #$08            ; if difference => 8 pixels, skip ahead of this part                  ;  B
BCS Chk2Ofs                                                                                         ; 
LDA $06                       ; if firebar on far right on the screen, skip this,                   ;  B
CMP #$f0                      ; because, really, what's the point?                                  ; 
BCS Chk2Ofs                                                                                         ; 
LDA Sprite_X_Position+4       ; get OAM X coordinate for sprite #1                                  ;  B
CLC                                                                                                 ; 
ADC #$04                      ; add four pixels                                                     ; 
STA $04                       ; store here                                                          ; 
SEC                           ; subtract horizontal coordinate of firebar                           ; 
SBC $06                       ; from the X coordinate of player's sprite 1                          ; 
BPL ChkFBCl                   ; if modded X coordinate to the right of firebar                      ; 
EOR #$ff                      ; skip two's compliment part                                          ;  B
CLC                           ; otherwise get two's compliment                                      ; 
ADC #$01                                                                                            ; 
ChkFBCl:  CMP #$08            ; if difference < 8 pixels, collision, thus branch                    ;  B
BCC ChgSDir                   ; to process                                                          ; 
Chk2Ofs:  LDA $05             ; if value of $02 was set earlier for whatever reason,                ;  B
CMP #$02                      ; branch to increment OAM offset and leave, no collision              ; 
BEQ NoColFB                                                                                         ; 
LDY $05                       ; otherwise get temp here and use as offset                           ;  B
LDA Player_Y_Position                                                                               ; 
CLC                                                                                                 ; 
ADC FirebarYPos,Y             ; add value loaded with offset to player's vertical coordinate        ; 
INC $05                       ; then increment temp and jump back                                   ; 
JMP FBCLoop                                                                                         ; 
ChgSDir:  LDX #$01            ; set movement direction by default                                   ;  B
LDA $04                       ; if OAM X coordinate of player's sprite 1                            ; 
CMP $06                       ; is greater than horizontal coordinate of firebar                    ; 
BCS SetSDir                   ; then do not alter movement direction                                ; 
INX                           ; otherwise increment it                                              ;  B
SetSDir:  STX Enemy_MovingDir ; store movement direction here                                       ;  B
LDX #$00                                                                                            ; 
LDA $00                       ; save value written to $00 to stack                                  ; 
PHA                                                                                                 ; 
JSR InjurePlayer              ; perform sub to hurt or kill player                                  ; 
PLA                                                                                                 ; 
STA $00                       ; get value of $00 from stack                                         ; 
NoColFB:  PLA                 ; get OAM data offset                                                 ;  B
CLC                           ; add four to it and save                                             ; 
ADC #$04                                                                                            ; 
STA $06                                                                                             ; 
LDX ObjectOffset              ; get enemy object buffer offset and leave                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
GetFirebarPosition:                                                                                 ; fun(A$00):  B
PHA                           ; save high byte of spinstate to the stack                            ; 
AND #%00001111                ; mask out low nybble                                                 ; 
CMP #$09                                                                                            ; 
BCC GetHAdder                 ; if lower than $09, branch ahead                                     ; 
EOR #%00001111                ; otherwise get two's compliment to oscillate                         ;  B
CLC                                                                                                 ; 
ADC #$01                                                                                            ; 
GetHAdder:  STA $01           ; store result, modified or not, here                                 ;  B
LDY $00                       ; load number of firebar ball where we're at                          ; 
LDA FirebarTblOffsets,Y       ; load offset to firebar position data                                ; 
CLC                                                                                                 ; 
ADC $01                       ; add oscillated high byte of spinstate                               ; 
TAY                           ; to offset here and use as new offset                                ; 
LDA FirebarPosLookupTbl,Y     ; get data here and store as horizontal adder                         ; 
STA $01                                                                                             ; 
PLA                           ; pull whatever was in A from the stack                               ; 
PHA                           ; save it again because we still need it                              ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight this time, to get vertical adder                          ; 
AND #%00001111                ; mask out high nybble                                                ; 
CMP #$09                      ; if lower than $09, branch ahead                                     ; 
BCC GetVAdder                                                                                       ; 
EOR #%00001111                ; otherwise get two's compliment                                      ;  B
CLC                                                                                                 ; 
ADC #$01                                                                                            ; 
GetVAdder:  STA $02           ; store result here                                                   ;  B
LDY $00                                                                                             ; 
LDA FirebarTblOffsets,Y       ; load offset to firebar position data again                          ; 
CLC                                                                                                 ; 
ADC $02                       ; this time add value in $02 to offset here and use as offset         ; 
TAY                                                                                                 ; 
LDA FirebarPosLookupTbl,Y     ; get data here and store as vertica adder                            ; 
STA $02                                                                                             ; 
PLA                           ; pull out whatever was in A one last time                            ; 
LSR                           ; divide by eight or shift three to the right                         ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
TAY                           ; use as offset                                                       ; 
LDA FirebarMirrorData,Y       ; load mirroring data here                                            ; 
STA $03                       ; store                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
PRandomSubtracter:                                                                                  ;  B
DATA: ByteValue(value=248), ByteValue(value=160), ByteValue(value=112), ByteValue(value=189), ByteValue(value=0); 
                                                                                                    ; 
FlyCCBPriority:                                                                                     ;  B
DATA: ByteValue(value=32), ByteValue(value=32), ByteValue(value=32), ByteValue(value=0), ByteValue(value=0); 
                                                                                                    ; 
MoveFlyingCheepCheep:                                                                               ;  B
LDA Enemy_State,X             ; check cheep-cheep's enemy state                                     ; 
AND #%00100000                ; for d5 set                                                          ; 
BEQ FlyCC                     ; branch to continue code if not set                                  ; 
LDA #$00                                                                                            ;  B
STA Enemy_SprAttrib,X         ; otherwise clear sprite attributes                                   ; 
JMP MoveJ_EnemyVertically     ; and jump to move defeated cheep-cheep downwards                     ; 
FlyCC:  JSR MoveEnemyHorizontally; move cheep-cheep horizontally based on speed and force           ;  B
LDY #$0d                      ; set vertical movement amount                                        ; 
LDA #$05                      ; set maximum speed                                                   ; 
JSR SetXMoveAmt               ; branch to impose gravity on flying cheep-cheep                      ; 
LDA Enemy_Y_MoveForce,X                                                                             ; 
LSR                           ; get vertical movement force and                                     ; 
LSR                           ; move high nybble to low                                             ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
TAY                           ; save as offset (note this tends to go into reach of code)           ; 
LDA Enemy_Y_Position,X        ; get vertical position                                               ; 
SEC                           ; subtract pseudorandom value based on offset from position           ; 
SBC PRandomSubtracter,Y                                                                             ; 
BPL AddCCF                    ; if result within top half of screen, skip this part                 ; 
EOR #$ff                                                                                            ;  B
CLC                           ; otherwise get two's compliment                                      ; 
ADC #$01                                                                                            ; 
AddCCF:  CMP #$08             ; if result or two's compliment greater than eight,                   ;  B
BCS BPGet                     ; skip to the end without changing movement force                     ; 
LDA Enemy_Y_MoveForce,X                                                                             ;  B
CLC                                                                                                 ; 
ADC #$10                      ; otherwise add to it                                                 ; 
STA Enemy_Y_MoveForce,X                                                                             ; 
LSR                           ; move high nybble to low again                                       ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
TAY                                                                                                 ; 
BPGet:  LDA FlyCCBPriority,Y  ; load bg priority data and store (this is very likely                ;  B
STA Enemy_SprAttrib,X         ; broken or residual code, value is overwritten before                ; 
RTS                           ; drawing it next frame), then leave                                  ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to hold horizontal difference                            ; 
                              ; $01-$03 - used to hold difference adjusters                         ; 
                                                                                                    ; 
LakituDiffAdj:                                                                                      ;  B
DATA: ByteValue(value=21), ByteValue(value=48), ByteValue(value=64)                                 ; 
                                                                                                    ; 
MoveLakitu:                                                                                         ;  B
LDA Enemy_State,X             ; check lakitu's enemy state                                          ; 
AND #%00100000                ; for d5 set                                                          ; 
BEQ ChkLS                     ; if not set, continue with code                                      ; 
JMP MoveD_EnemyVertically     ; otherwise jump to move defeated lakitu downwards                    ;  B
ChkLS:  LDA Enemy_State,X     ; if lakitu's enemy state not set at all,                             ;  B
BEQ Fr12S                     ; go ahead and continue with code                                     ; 
LDA #$00                                                                                            ;  B
STA LakituMoveDirection,X     ; otherwise initialize moving direction to move to left               ; 
STA EnemyFrenzyBuffer         ; initialize frenzy buffer                                            ; 
LDA #$10                                                                                            ; 
BNE SetLSpd                   ; load horizontal speed and do unconditional branch                   ; 
Fr12S:  LDA #Spiny                                                                                  ;  B
STA EnemyFrenzyBuffer         ; set spiny identifier in frenzy buffer                               ; 
LDY #$02                                                                                            ; 
LdLDa:  LDA LakituDiffAdj,Y   ; load values                                                         ;  B
STA $0001,Y                   ; store in zero page                                                  ; 
DEY                                                                                                 ; 
BPL LdLDa                     ; do this until all values are stired                                 ; 
JSR PlayerLakituDiff          ; execute sub to set speed and create spinys                          ;  B
SetLSpd:  STA LakituMoveSpeed,X; set movement speed returned from sub                               ;  B
LDY #$01                      ; set moving direction to right by default                            ; 
LDA LakituMoveDirection,X                                                                           ; 
AND #$01                      ; get LSB of moving direction                                         ; 
BNE SetLMov                   ; if set, branch to the end to use moving direction                   ; 
LDA LakituMoveSpeed,X                                                                               ;  B
EOR #$ff                      ; get two's compliment of moving speed                                ; 
CLC                                                                                                 ; 
ADC #$01                                                                                            ; 
STA LakituMoveSpeed,X         ; store as new moving speed                                           ; 
INY                           ; increment moving direction to left                                  ; 
SetLMov:  STY Enemy_MovingDir,X; store moving direction                                             ;  B
JMP MoveEnemyHorizontally     ; move lakitu horizontally                                            ; 
                                                                                                    ;  B
PlayerLakituDiff:                                                                                   ; fun($00):  B
LDY #$00                      ; set Y for default value                                             ; 
JSR PlayerEnemyDiff           ; get horizontal difference between enemy and player                  ; 
BPL ChkLakDif                 ; branch if enemy is to the right of the player                       ; 
INY                           ; increment Y for left of player                                      ;  B
LDA $00                                                                                             ; 
EOR #$ff                      ; get two's compliment of low byte of horizontal difference           ; 
CLC                                                                                                 ; 
ADC #$01                      ; store two's compliment as horizontal difference                     ; 
STA $00                                                                                             ; 
ChkLakDif:  LDA $00           ; get low byte of horizontal difference                               ;  B
CMP #$3c                      ; if within a certain distance of player, branch                      ; 
BCC ChkPSpeed                                                                                       ; 
LDA #$3c                      ; otherwise set maximum distance                                      ;  B
STA $00                                                                                             ; 
LDA Enemy_ID,X                ; check if lakitu is in our current enemy slot                        ; 
CMP #Lakitu                                                                                         ; 
BNE ChkPSpeed                 ; if not, branch elsewhere                                            ; 
TYA                           ; compare contents of Y, now in A                                     ;  B
CMP LakituMoveDirection,X     ; to what is being used as horizontal movement direction              ; 
BEQ ChkPSpeed                 ; if moving toward the player, branch, do not alter                   ; 
LDA LakituMoveDirection,X     ; if moving to the left beyond maximum distance,                      ;  B
BEQ SetLMovD                  ; branch and alter without delay                                      ; 
DEC LakituMoveSpeed,X         ; decrement horizontal speed                                          ;  B
LDA LakituMoveSpeed,X         ; if horizontal speed not yet at zero, branch to leave                ; 
BNE ExMoveLak                                                                                       ; 
SetLMovD:  TYA                ; set horizontal direction depending on horizontal                    ;  B
STA LakituMoveDirection,X     ; difference between enemy and player if necessary                    ; 
ChkPSpeed:  LDA $00                                                                                 ;  B
AND #%00111100                ; mask out all but four bits in the middle                            ; 
LSR                           ; divide masked difference by four                                    ; 
LSR                                                                                                 ; 
STA $00                       ; store as new value                                                  ; 
LDY #$00                      ; init offset                                                         ; 
LDA Player_X_Speed                                                                                  ; 
BEQ SubDifAdj                 ; if player not moving horizontally, branch                           ; 
LDA ScrollAmount                                                                                    ;  B
BEQ SubDifAdj                 ; if scroll speed not set, branch to same place                       ; 
INY                           ; otherwise increment offset                                          ;  B
LDA Player_X_Speed                                                                                  ; 
CMP #$19                      ; if player not running, branch                                       ; 
BCC ChkSpinyO                                                                                       ; 
LDA ScrollAmount                                                                                    ;  B
CMP #$02                      ; if scroll speed below a certain amount, branch                      ; 
BCC ChkSpinyO                 ; to same place                                                       ; 
INY                           ; otherwise increment once more                                       ;  B
ChkSpinyO:  LDA Enemy_ID,X    ; check for spiny object                                              ;  B
CMP #Spiny                                                                                          ; 
BNE ChkEmySpd                 ; branch if not found                                                 ; 
LDA Player_X_Speed            ; if player not moving, skip this part                                ;  B
BNE SubDifAdj                                                                                       ; 
ChkEmySpd:  LDA Enemy_Y_Speed,X; check vertical speed                                               ;  B
BNE SubDifAdj                 ; branch if nonzero                                                   ; 
LDY #$00                      ; otherwise reinit offset                                             ;  B
SubDifAdj:  LDA $0001,Y       ; get one of three saved values from earlier                          ;  B
LDY $00                       ; get saved horizontal difference                                     ; 
SPixelLak:  SEC               ; subtract one for each pixel of horizontal difference                ;  B
SBC #$01                      ; from one of three saved values                                      ; 
DEY                                                                                                 ; 
BPL SPixelLak                 ; branch until all pixels are subtracted, to adjust difference        ; 
ExMoveLak:  RTS               ; leave!!!                                                            ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $04-$05 - used to store name table address in little endian order   ; 
                                                                                                    ; 
BridgeCollapseData:                                                                                 ;  B
DATA: ByteValue(value=26)     ; axe                                                                 ; 
DATA: ByteValue(value=88)     ; chain                                                               ; 
DATA: ByteValue(value=152), ByteValue(value=150), ByteValue(value=148), ByteValue(value=146), ByteValue(value=144), ByteValue(value=142), ByteValue(value=140); bridge; 
DATA: ByteValue(value=138), ByteValue(value=136), ByteValue(value=134), ByteValue(value=132), ByteValue(value=130), ByteValue(value=128); 
                                                                                                    ; 
BridgeCollapse:                                                                                     ;  B
LDX BowserFront_Offset        ; get enemy offset for bowser                                         ; 
LDA Enemy_ID,X                ; check enemy object identifier for bowser                            ; 
CMP #Bowser                   ; if not found, branch ahead,                                         ; 
BNE SetM2                     ; metatile removal not necessary                                      ; 
STX ObjectOffset              ; store as enemy offset here                                          ;  B
LDA Enemy_State,X             ; if bowser in normal state, skip all of this                         ; 
BEQ RemoveBridge                                                                                    ; 
AND #%01000000                ; if bowser's state has d6 clear, skip to silence music               ;  B
BEQ SetM2                                                                                           ; 
LDA Enemy_Y_Position,X        ; check bowser's vertical coordinate                                  ;  B
CMP #$e0                      ; if bowser not yet low enough, skip this part ahead                  ; 
BCC MoveD_Bowser                                                                                    ; 
SetM2:  LDA #Silence          ; silence music                                                       ;  B
STA EventMusicQueue                                                                                 ; 
INC OperMode_Task             ; move onto next secondary mode in autoctrl mode                      ; 
JMP KillAllEnemies            ; jump to empty all enemy slots and then leave                        ; 
                                                                                                    ;  B
MoveD_Bowser:                                                                                       ;  B
JSR MoveEnemySlowVert         ; do a sub to move bowser downwards                                   ; 
JMP BowserGfxHandler          ; jump to draw bowser's front and rear, then leave                    ; 
                                                                                                    ;  B
RemoveBridge:                                                                                       ;  B
DEC BowserFeetCounter         ; decrement timer to control bowser's feet                            ; 
BNE NoBFall                   ; if not expired, skip all of this                                    ; 
LDA #$04                                                                                            ;  B
STA BowserFeetCounter         ; otherwise, set timer now                                            ; 
LDA BowserBodyControls                                                                              ; 
EOR #$01                      ; invert bit to control bowser's feet                                 ; 
STA BowserBodyControls                                                                              ; 
LDA #$22                      ; put high byte of name table address here for now                    ; 
STA $05                                                                                             ; 
LDY BridgeCollapseOffset      ; get bridge collapse offset here                                     ; 
LDA BridgeCollapseData,Y      ; load low byte of name table address and store here                  ; 
STA $04                                                                                             ; 
LDY VRAM_Buffer1_Offset       ; increment vram buffer offset                                        ; 
INY                                                                                                 ; 
LDX #$0c                      ; set offset for tile data for sub to draw blank metatile             ; 
JSR RemBridge                 ; do sub here to remove bowser's bridge metatiles                     ; 
LDX ObjectOffset              ; get enemy offset                                                    ; 
JSR MoveVOffset               ; set new vram buffer offset                                          ; 
LDA #Sfx_Blast                ; load the fireworks/gunfire sound into the square 2 sfx              ; 
STA Square2SoundQueue         ; queue while at the same time loading the brick                      ; 
LDA #Sfx_BrickShatter         ; shatter sound into the noise sfx queue thus                         ; 
STA NoiseSoundQueue           ; producing the unique sound of the bridge collapsing                 ; 
INC BridgeCollapseOffset      ; increment bridge collapse offset                                    ; 
LDA BridgeCollapseOffset                                                                            ; 
CMP #$0f                      ; if bridge collapse offset has not yet reached                       ; 
BNE NoBFall                   ; the end, go ahead and skip this part                                ; 
JSR InitVStf                  ; initialize whatever vertical speed bowser has                       ;  B
LDA #%01000000                                                                                      ; 
STA Enemy_State,X             ; set bowser's state to one of defeated states (d6 set)               ; 
LDA #Sfx_BowserFall                                                                                 ; 
STA Square2SoundQueue         ; play bowser defeat sound                                            ; 
NoBFall:  JMP BowserGfxHandler; jump to code that draws bowser                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
PRandomRange:                                                                                       ;  B
DATA: ByteValue(value=33), ByteValue(value=65), ByteValue(value=17), ByteValue(value=49)            ; 
                                                                                                    ; 
RunBowser:                                                                                          ;  B
LDA Enemy_State,X             ; if d5 in enemy state is not set                                     ; 
AND #%00100000                ; then branch elsewhere to run bowser                                 ; 
BEQ BowserControl                                                                                   ; 
LDA Enemy_Y_Position,X        ; otherwise check vertical position                                   ;  B
CMP #$e0                      ; if above a certain point, branch to move defeated bowser            ; 
BCC MoveD_Bowser              ; otherwise proceed to KillAllEnemies                                 ; 
                                                                                                    ;  B
KillAllEnemies:                                                                                     ; fun(A):  B
LDX #$04                      ; start with last enemy slot                                          ; 
KillLoop:  JSR EraseEnemyObject; branch to kill enemy objects                                       ;  B
DEX                           ; move onto next enemy slot                                           ; 
BPL KillLoop                  ; do this until all slots are emptied                                 ; 
STA EnemyFrenzyBuffer         ; empty frenzy buffer                                                 ;  B
LDX ObjectOffset              ; get enemy object offset and leave                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
BowserControl:                                                                                      ;  B
LDA #$00                                                                                            ; 
STA EnemyFrenzyBuffer         ; empty frenzy buffer                                                 ; 
LDA TimerControl              ; if master timer control not set,                                    ; 
BEQ ChkMouth                  ; skip jump and execute code here                                     ; 
JMP SkipToFB                  ; otherwise, jump over a bunch of code                                ;  B
ChkMouth:  LDA BowserBodyControls; check bowser's mouth                                             ;  B
BPL FeetTmr                   ; if bit clear, go ahead with code here                               ; 
JMP HammerChk                 ; otherwise skip a whole section starting here                        ;  B
FeetTmr:  DEC BowserFeetCounter; decrement timer to control bowser's feet                           ;  B
BNE ResetMDr                  ; if not expired, skip this part                                      ; 
LDA #$20                      ; otherwise, reset timer                                              ;  B
STA BowserFeetCounter                                                                               ; 
LDA BowserBodyControls        ; and invert bit used                                                 ; 
EOR #%00000001                ; to control bowser's feet                                            ; 
STA BowserBodyControls                                                                              ; 
ResetMDr:  LDA FrameCounter   ; check frame counter                                                 ;  B
AND #%00001111                ; if not on every sixteenth frame, skip                               ; 
BNE B_FaceP                   ; ahead to continue code                                              ; 
LDA #$02                      ; otherwise reset moving/facing direction every                       ;  B
STA Enemy_MovingDir,X         ; sixteen frames                                                      ; 
B_FaceP:  LDA EnemyFrameTimer,X; if timer set here expired,                                         ;  B
BEQ GetPRCmp                  ; branch to next section                                              ; 
JSR PlayerEnemyDiff           ; get horizontal difference between player and bowser,                ;  B
BPL GetPRCmp                  ; and branch if bowser to the right of the player                     ; 
LDA #$01                                                                                            ;  B
STA Enemy_MovingDir,X         ; set bowser to move and face to the right                            ; 
LDA #$02                                                                                            ; 
STA BowserMovementSpeed       ; set movement speed                                                  ; 
LDA #$20                                                                                            ; 
STA EnemyFrameTimer,X         ; set timer here                                                      ; 
STA BowserFireBreathTimer     ; set timer used for bowser's flame                                   ; 
LDA Enemy_X_Position,X                                                                              ; 
CMP #$c8                      ; if bowser to the right past a certain point,                        ; 
BCS HammerChk                 ; skip ahead to some other section                                    ; 
GetPRCmp:  LDA FrameCounter   ; get frame counter                                                   ;  B
AND #%00000011                                                                                      ; 
BNE HammerChk                 ; execute this code every fourth frame, otherwise branch              ; 
LDA Enemy_X_Position,X                                                                              ;  B
CMP BowserOrigXPos            ; if bowser not at original horizontal position,                      ; 
BNE GetDToO                   ; branch to skip this part                                            ; 
LDA PseudoRandomBitReg,X                                                                            ;  B
AND #%00000011                ; get pseudorandom offset                                             ; 
TAY                                                                                                 ; 
LDA PRandomRange,Y            ; load value using pseudorandom offset                                ; 
STA MaxRangeFromOrigin        ; and store here                                                      ; 
GetDToO:  LDA Enemy_X_Position,X                                                                    ;  B
CLC                           ; add movement speed to bowser's horizontal                           ; 
ADC BowserMovementSpeed       ; coordinate and save as new horizontal position                      ; 
STA Enemy_X_Position,X                                                                              ; 
LDY Enemy_MovingDir,X                                                                               ; 
CPY #$01                      ; if bowser moving and facing to the right, skip ahead                ; 
BEQ HammerChk                                                                                       ; 
LDY #$ff                      ; set default movement speed here (move left)                         ;  B
SEC                           ; get difference of current vs. original                              ; 
SBC BowserOrigXPos            ; horizontal position                                                 ; 
BPL CompDToO                  ; if current position to the right of original, skip ahead            ; 
EOR #$ff                                                                                            ;  B
CLC                           ; get two's compliment                                                ; 
ADC #$01                                                                                            ; 
LDY #$01                      ; set alternate movement speed here (move right)                      ; 
CompDToO:  CMP MaxRangeFromOrigin; compare difference with pseudorandom value                       ;  B
BCC HammerChk                 ; if difference < pseudorandom value, leave speed alone               ; 
STY BowserMovementSpeed       ; otherwise change bowser's movement speed                            ;  B
HammerChk:  LDA EnemyFrameTimer,X; if timer set here not expired yet, skip ahead to                 ;  B
BNE MakeBJump                 ; some other section of code                                          ; 
JSR MoveEnemySlowVert         ; otherwise start by moving bowser downwards                          ;  B
LDA WorldNumber               ; check world number                                                  ; 
CMP #World6                                                                                         ; 
BCC SetHmrTmr                 ; if world 1-5, skip this part (not time to throw hammers yet)        ; 
LDA FrameCounter                                                                                    ;  B
AND #%00000011                ; check to see if it's time to execute sub                            ; 
BNE SetHmrTmr                 ; if not, skip sub, otherwise                                         ; 
JSR SpawnHammerObj            ; execute sub on every fourth frame to spawn misc object (hammer)     ;  B
SetHmrTmr:  LDA Enemy_Y_Position,X; get current vertical position                                   ;  B
CMP #$80                      ; if still above a certain point                                      ; 
BCC ChkFireB                  ; then skip to world number check for flames                          ; 
LDA PseudoRandomBitReg,X                                                                            ;  B
AND #%00000011                ; get pseudorandom offset                                             ; 
TAY                                                                                                 ; 
LDA PRandomRange,Y            ; get value using pseudorandom offset                                 ; 
STA EnemyFrameTimer,X         ; set for timer here                                                  ; 
SkipToFB:  JMP ChkFireB       ; jump to execute flames code                                         ;  B
MakeBJump:  CMP #$01          ; if timer not yet about to expire,                                   ;  B
BNE ChkFireB                  ; skip ahead to next part                                             ; 
DEC Enemy_Y_Position,X        ; otherwise decrement vertical coordinate                             ;  B
JSR InitVStf                  ; initialize movement amount                                          ; 
LDA #$fe                                                                                            ; 
STA Enemy_Y_Speed,X           ; set vertical speed to move bowser upwards                           ; 
ChkFireB:  LDA WorldNumber    ; check world number here                                             ;  B
CMP #World8                   ; world 8?                                                            ; 
BEQ SpawnFBr                  ; if so, execute this part here                                       ; 
CMP #World6                   ; world 6-7?                                                          ;  B
BCS BowserGfxHandler          ; if so, skip this part here                                          ; 
SpawnFBr:  LDA BowserFireBreathTimer; check timer here                                              ;  B
BNE BowserGfxHandler          ; if not expired yet, skip all of this                                ; 
LDA #$20                                                                                            ;  B
STA BowserFireBreathTimer     ; set timer here                                                      ; 
LDA BowserBodyControls                                                                              ; 
EOR #%10000000                ; invert bowser's mouth bit to open                                   ; 
STA BowserBodyControls        ; and close bowser's mouth                                            ; 
BMI ChkFireB                  ; if bowser's mouth open, loop back                                   ; 
JSR SetFlameTimer             ; get timing for bowser's flame                                       ;  B
LDY SecondaryHardMode                                                                               ; 
BEQ SetFBTmr                  ; if secondary hard mode flag not set, skip this                      ; 
SEC                                                                                                 ;  B
SBC #$10                      ; otherwise subtract from value in A                                  ; 
SetFBTmr:  STA BowserFireBreathTimer; set value as timer here                                       ;  B
LDA #BowserFlame              ; put bowser's flame identifier                                       ; 
STA EnemyFrenzyBuffer         ; in enemy frenzy buffer                                              ; 
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BowserGfxHandler:                                                                                   ;  B
JSR ProcessBowserHalf         ; do a sub here to process bowser's front                             ; 
LDY #$10                      ; load default value here to position bowser's rear                   ; 
LDA Enemy_MovingDir,X         ; check moving direction                                              ; 
LSR                                                                                                 ; 
BCC CopyFToR                  ; if moving left, use default                                         ; 
LDY #$f0                      ; otherwise load alternate positioning value here                     ;  B
CopyFToR:  TYA                ; move bowser's rear object position value to A                       ;  B
CLC                                                                                                 ; 
ADC Enemy_X_Position,X        ; add to bowser's front object horizontal coordinate                  ; 
LDY DuplicateObj_Offset       ; get bowser's rear object offset                                     ; 
STA Enemy_X_Position,Y        ; store A as bowser's rear horizontal coordinate                      ; 
LDA Enemy_Y_Position,X                                                                              ; 
CLC                           ; add eight pixels to bowser's front object                           ; 
ADC #$08                      ; vertical coordinate and store as vertical coordinate                ; 
STA Enemy_Y_Position,Y        ; for bowser's rear                                                   ; 
LDA Enemy_State,X                                                                                   ; 
STA Enemy_State,Y             ; copy enemy state directly from front to rear                        ; 
LDA Enemy_MovingDir,X                                                                               ; 
STA Enemy_MovingDir,Y         ; copy moving direction also                                          ; 
LDA ObjectOffset              ; save enemy object offset of front to stack                          ; 
PHA                                                                                                 ; 
LDX DuplicateObj_Offset       ; put enemy object offset of rear as current                          ; 
STX ObjectOffset                                                                                    ; 
LDA #Bowser                   ; set bowser's enemy identifier                                       ; 
STA Enemy_ID,X                ; store in bowser's rear object                                       ; 
JSR ProcessBowserHalf         ; do a sub here to process bowser's rear                              ; 
PLA                                                                                                 ; 
STA ObjectOffset              ; get original enemy object offset                                    ; 
TAX                                                                                                 ; 
LDA #$00                      ; nullify bowser's front/rear graphics flag                           ; 
STA BowserGfxFlag                                                                                   ; 
ExBGfxH:  RTS                 ; leave!                                                              ;  B
                                                                                                    ;  B
ProcessBowserHalf:                                                                                  ; fun():  B
INC BowserGfxFlag             ; increment bowser's graphics flag, then run subroutines              ; 
JSR RunRetainerObj            ; to get offscreen bits, relative position and draw bowser (finally!) ; 
LDA Enemy_State,X                                                                                   ; 
BNE ExBGfxH                   ; if either enemy object not in normal state, branch to leave         ; 
LDA #$0a                                                                                            ;  B
STA Enemy_BoundBoxCtrl,X      ; set bounding box size control                                       ; 
JSR GetEnemyBoundBox          ; get bounding box coordinates                                        ; 
JMP PlayerEnemyCollision      ; do player-to-enemy collision detection                              ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to hold movement force and tile number                   ; 
                              ; $01 - used to hold sprite attribute data                            ; 
                                                                                                    ; 
FlameTimerData:                                                                                     ;  B
DATA: ByteValue(value=191), ByteValue(value=64), ByteValue(value=191), ByteValue(value=191), ByteValue(value=191), ByteValue(value=64), ByteValue(value=64), ByteValue(value=191); 
                                                                                                    ; 
SetFlameTimer:                                                                                      ; fun(): A B
LDY BowserFlameTimerCtrl      ; load counter as offset                                              ; 
INC BowserFlameTimerCtrl      ; increment                                                           ; 
LDA BowserFlameTimerCtrl      ; mask out all but 3 LSB                                              ; 
AND #%00000111                ; to keep in range of 0-7                                             ; 
STA BowserFlameTimerCtrl                                                                            ; 
LDA FlameTimerData,Y          ; load value to be used then leave                                    ; 
ExFl:  RTS                                                                                          ;  B
                                                                                                    ;  B
ProcBowserFlame:                                                                                    ; fun():  B
LDA TimerControl              ; if master timer control flag set,                                   ; 
BNE SetGfxF                   ; skip all of this                                                    ; 
LDA #$40                      ; load default movement force                                         ;  B
LDY SecondaryHardMode                                                                               ; 
BEQ SFlmX                     ; if secondary hard mode flag not set, use default                    ; 
LDA #$60                      ; otherwise load alternate movement force to go faster                ;  B
SFlmX:  STA $00               ; store value here                                                    ;  B
LDA Enemy_X_MoveForce,X                                                                             ; 
SEC                           ; subtract value from movement force                                  ; 
SBC $00                                                                                             ; 
STA Enemy_X_MoveForce,X       ; save new value                                                      ; 
LDA Enemy_X_Position,X                                                                              ; 
SBC #$01                      ; subtract one from horizontal position to move                       ; 
STA Enemy_X_Position,X        ; to the left                                                         ; 
LDA Enemy_PageLoc,X                                                                                 ; 
SBC #$00                      ; subtract borrow from page location                                  ; 
STA Enemy_PageLoc,X                                                                                 ; 
LDY BowserFlamePRandomOfs,X   ; get some value here and use as offset                               ; 
LDA Enemy_Y_Position,X        ; load vertical coordinate                                            ; 
CMP FlameYPosData,Y           ; compare against coordinate data using $0417,x as offset             ; 
BEQ SetGfxF                   ; if equal, branch and do not modify coordinate                       ; 
CLC                                                                                                 ;  B
ADC Enemy_Y_MoveForce,X       ; otherwise add value here to coordinate and store                    ; 
STA Enemy_Y_Position,X        ; as new vertical coordinate                                          ; 
SetGfxF:  JSR RelativeEnemyPosition; get new relative coordinates                                   ;  B
LDA Enemy_State,X             ; if bowser's flame not in normal state,                              ; 
BNE ExFl                      ; branch to leave                                                     ; 
LDA #$51                      ; otherwise, continue                                                 ;  B
STA $00                       ; write first tile number                                             ; 
LDY #$02                      ; load attributes without vertical flip by default                    ; 
LDA FrameCounter                                                                                    ; 
AND #%00000010                ; invert vertical flip bit every 2 frames                             ; 
BEQ FlmeAt                    ; if d1 not set, write default value                                  ; 
LDY #$82                      ; otherwise write value with vertical flip bit set                    ;  B
FlmeAt:  STY $01              ; set bowser's flame sprite attributes here                           ;  B
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDX #$00                                                                                            ; 
                                                                                                    ; 
DrawFlameLoop:                                                                                      ;  B
LDA Enemy_Rel_YPos            ; get Y relative coordinate of current enemy object                   ; 
STA Sprite_Y_Position,Y       ; write into Y coordinate of OAM data                                 ; 
LDA $00                                                                                             ; 
STA Sprite_Tilenumber,Y       ; write current tile number into OAM data                             ; 
INC $00                       ; increment tile number to draw more bowser's flame                   ; 
LDA $01                                                                                             ; 
STA Sprite_Attributes,Y       ; write saved attributes into OAM data                                ; 
LDA Enemy_Rel_XPos                                                                                  ; 
STA Sprite_X_Position,Y       ; write X relative coordinate of current enemy object                 ; 
CLC                                                                                                 ; 
ADC #$08                                                                                            ; 
STA Enemy_Rel_XPos            ; then add eight to it and store                                      ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                           ; increment Y four times to move onto the next OAM                    ; 
INX                           ; move onto the next OAM, and branch if three                         ; 
CPX #$03                      ; have not yet been done                                              ; 
BCC DrawFlameLoop                                                                                   ; 
LDX ObjectOffset              ; reload original enemy offset                                        ;  B
JSR GetEnemyOffscreenBits     ; get offscreen information                                           ; 
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDA Enemy_OffscreenBits       ; get enemy object offscreen bits                                     ; 
LSR                           ; move d0 to carry and result to stack                                ; 
PHA                                                                                                 ; 
BCC M3FOfs                    ; branch if carry not set                                             ; 
LDA #$f8                      ; otherwise move sprite offscreen, this part likely                   ;  B
STA Sprite_Y_Position+12,Y    ; residual since flame is only made of three sprites                  ; 
M3FOfs:  PLA                  ; get bits from stack                                                 ;  B
LSR                           ; move d1 to carry and move bits back to stack                        ; 
PHA                                                                                                 ; 
BCC M2FOfs                    ; branch if carry not set again                                       ; 
LDA #$f8                      ; otherwise move third sprite offscreen                               ;  B
STA Sprite_Y_Position+8,Y                                                                           ; 
M2FOfs:  PLA                  ; get bits from stack again                                           ;  B
LSR                           ; move d2 to carry and move bits back to stack again                  ; 
PHA                                                                                                 ; 
BCC M1FOfs                    ; branch if carry not set yet again                                   ; 
LDA #$f8                      ; otherwise move second sprite offscreen                              ;  B
STA Sprite_Y_Position+4,Y                                                                           ; 
M1FOfs:  PLA                  ; get bits from stack one last time                                   ;  B
LSR                           ; move d3 to carry                                                    ; 
BCC ExFlmeD                   ; branch if carry not set one last time                               ; 
LDA #$f8                                                                                            ;  B
STA Sprite_Y_Position,Y       ; otherwise move first sprite offscreen                               ; 
ExFlmeD:  RTS                 ; leave                                                               ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
RunFireworks:                                                                                       ;  B
DEC ExplosionTimerCounter,X   ; decrement explosion timing counter here                             ; 
BNE SetupExpl                 ; if not expired, skip this part                                      ; 
LDA #$08                                                                                            ;  B
STA ExplosionTimerCounter,X   ; reset counter                                                       ; 
INC ExplosionGfxCounter,X     ; increment explosion graphics counter                                ; 
LDA ExplosionGfxCounter,X                                                                           ; 
CMP #$03                      ; check explosion graphics counter                                    ; 
BCS FireworksSoundScore       ; if at a certain point, branch to kill this object                   ; 
SetupExpl:  JSR RelativeEnemyPosition; get relative coordinates of explosion                        ;  B
LDA Enemy_Rel_YPos            ; copy relative coordinates                                           ; 
STA Fireball_Rel_YPos         ; from the enemy object to the fireball object                        ; 
LDA Enemy_Rel_XPos            ; first vertical, then horizontal                                     ; 
STA Fireball_Rel_XPos                                                                               ; 
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDA ExplosionGfxCounter,X     ; get explosion graphics counter                                      ; 
JSR DrawExplosion_Fireworks   ; do a sub to draw the explosion then leave                           ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
FireworksSoundScore:                                                                                ;  B
LDA #$00                      ; disable enemy buffer flag                                           ; 
STA Enemy_Flag,X                                                                                    ; 
LDA #Sfx_Blast                ; play fireworks/gunfire sound                                        ; 
STA Square2SoundQueue                                                                               ; 
LDA #$05                      ; set part of score modifier for 500 points                           ; 
STA DigitModifier+4                                                                                 ; 
JMP EndAreaPoints             ; jump to award points accordingly then leave                         ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
StarFlagYPosAdder:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=8), ByteValue(value=8)                ; 
                                                                                                    ; 
StarFlagXPosAdder:                                                                                  ;  B
DATA: ByteValue(value=0), ByteValue(value=8), ByteValue(value=0), ByteValue(value=8)                ; 
                                                                                                    ; 
StarFlagTileData:                                                                                   ;  B
DATA: ByteValue(value=84), ByteValue(value=85), ByteValue(value=86), ByteValue(value=87)            ; 
                                                                                                    ; 
RunStarFlagObj:                                                                                     ;  B
LDA #$00                      ; initialize enemy frenzy buffer                                      ; 
STA EnemyFrenzyBuffer                                                                               ; 
LDA StarFlagTaskControl       ; check star flag object task number here                             ; 
CMP #$05                      ; if greater than 5, branch to exit                                   ; 
BCS StarFlagExit                                                                                    ; 
JSR JumpEngine                ; otherwise jump to appropriate sub                                   ;  B
                                                                                                    ; 
DATA: Expr(expr=StarFlagExit)                                                                       ; 
DATA: Expr(expr=GameTimerFireworks)                                                                 ; 
DATA: Expr(expr=AwardGameTimerPoints)                                                               ; 
DATA: Expr(expr=RaiseFlagSetoffFWorks)                                                              ; 
DATA: Expr(expr=DelayToAreaEnd)                                                                     ; 
                                                                                                    ; 
GameTimerFireworks:                                                                                 ;  B
LDY #$05                      ; set default state for star flag object                              ; 
LDA GameTimerDisplay+2        ; get game timer's last digit                                         ; 
CMP #$01                                                                                            ; 
BEQ SetFWC                    ; if last digit of game timer set to 1, skip ahead                    ; 
LDY #$03                      ; otherwise load new value for state                                  ;  B
CMP #$03                                                                                            ; 
BEQ SetFWC                    ; if last digit of game timer set to 3, skip ahead                    ; 
LDY #$00                      ; otherwise load one more potential value for state                   ;  B
CMP #$06                                                                                            ; 
BEQ SetFWC                    ; if last digit of game timer set to 6, skip ahead                    ; 
LDA #$ff                      ; otherwise set value for no fireworks                                ;  B
SetFWC:  STA FireworksCounter ; set fireworks counter here                                          ;  B
STY Enemy_State,X             ; set whatever state we have in star flag object                      ; 
                                                                                                    ; 
IncrementSFTask1:                                                                                   ;  B
INC StarFlagTaskControl       ; increment star flag object task number                              ; 
                                                                                                    ; 
StarFlagExit:                                                                                       ;  B
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
AwardGameTimerPoints:                                                                               ;  B
LDA GameTimerDisplay          ; check all game timer digits for any intervals left                  ; 
ORA GameTimerDisplay+1                                                                              ; 
ORA GameTimerDisplay+2                                                                              ; 
BEQ IncrementSFTask1          ; if no time left on game timer at all, branch to next task           ; 
LDA FrameCounter                                                                                    ;  B
AND #%00000100                ; check frame counter for d2 set (skip ahead                          ; 
BEQ NoTTick                   ; for four frames every four frames) branch if not set                ; 
LDA #Sfx_TimerTick                                                                                  ;  B
STA Square2SoundQueue         ; load timer tick sound                                               ; 
NoTTick:  LDY #$23            ; set offset here to subtract from game timer's last digit            ;  B
LDA #$ff                      ; set adder here to $ff, or -1, to subtract one                       ; 
STA DigitModifier+5           ; from the last digit of the game timer                               ; 
JSR DigitsMathRoutine         ; subtract digit                                                      ; 
LDA #$05                      ; set now to add 50 points                                            ; 
STA DigitModifier+5           ; per game timer interval subtracted                                  ; 
                                                                                                    ; 
EndAreaPoints:                                                                                      ;  B
LDY #$0b                      ; load offset for mario's score by default                            ; 
LDA CurrentPlayer             ; check player on the screen                                          ; 
BEQ ELPGive                   ; if mario, do not change                                             ; 
LDY #$11                      ; otherwise load offset for luigi's score                             ;  B
ELPGive:  JSR DigitsMathRoutine; award 50 points per game timer interval                            ;  B
LDA CurrentPlayer             ; get player on the screen (or 500 points per                         ; 
ASL                           ; fireworks explosion if branched here from there)                    ; 
ASL                           ; shift to high nybble                                                ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ORA #%00000100                ; add four to set nybble for game timer                               ; 
JMP UpdateNumber              ; jump to print the new score and game timer                          ; 
                                                                                                    ;  B
RaiseFlagSetoffFWorks:                                                                              ;  B
LDA Enemy_Y_Position,X        ; check star flag's vertical position                                 ; 
CMP #$72                      ; against preset value                                                ; 
BCC SetoffF                   ; if star flag higher vertically, branch to other code                ; 
DEC Enemy_Y_Position,X        ; otherwise, raise star flag by one pixel                             ;  B
JMP DrawStarFlag              ; and skip this part here                                             ; 
SetoffF:  LDA FireworksCounter; check fireworks counter                                             ;  B
BEQ DrawFlagSetTimer          ; if no fireworks left to go off, skip this part                      ; 
BMI DrawFlagSetTimer          ; if no fireworks set to go off, skip this part                       ;  B
LDA #Fireworks                                                                                      ;  B
STA EnemyFrenzyBuffer         ; otherwise set fireworks object in frenzy queue                      ; 
                                                                                                    ; 
DrawStarFlag:                                                                                       ; fun():  B
JSR RelativeEnemyPosition     ; get relative coordinates of star flag                               ; 
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDX #$03                      ; do four sprites                                                     ; 
DSFLoop:  LDA Enemy_Rel_YPos  ; get relative vertical coordinate                                    ;  B
CLC                                                                                                 ; 
ADC StarFlagYPosAdder,X       ; add Y coordinate adder data                                         ; 
STA Sprite_Y_Position,Y       ; store as Y coordinate                                               ; 
LDA StarFlagTileData,X        ; get tile number                                                     ; 
STA Sprite_Tilenumber,Y       ; store as tile number                                                ; 
LDA #$22                      ; set palette and background priority bits                            ; 
STA Sprite_Attributes,Y       ; store as attributes                                                 ; 
LDA Enemy_Rel_XPos            ; get relative horizontal coordinate                                  ; 
CLC                                                                                                 ; 
ADC StarFlagXPosAdder,X       ; add X coordinate adder data                                         ; 
STA Sprite_X_Position,Y       ; store as X coordinate                                               ; 
INY                                                                                                 ; 
INY                           ; increment OAM data offset four bytes                                ; 
INY                           ; for next sprite                                                     ; 
INY                                                                                                 ; 
DEX                           ; move onto next sprite                                               ; 
BPL DSFLoop                   ; do this until all sprites are done                                  ; 
LDX ObjectOffset              ; get enemy object offset and leave                                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
DrawFlagSetTimer:                                                                                   ;  B
JSR DrawStarFlag              ; do sub to draw star flag                                            ; 
LDA #$06                                                                                            ; 
STA EnemyIntervalTimer,X      ; set interval timer here                                             ; 
                                                                                                    ; 
IncrementSFTask2:                                                                                   ;  B
INC StarFlagTaskControl       ; move onto next task                                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
DelayToAreaEnd:                                                                                     ;  B
JSR DrawStarFlag              ; do sub to draw star flag                                            ; 
LDA EnemyIntervalTimer,X      ; if interval timer set in previous task                              ; 
BNE StarFlagExit2             ; not yet expired, branch to leave                                    ; 
LDA EventMusicBuffer          ; if event music buffer empty,                                        ;  B
BEQ IncrementSFTask2          ; branch to increment task                                            ; 
                                                                                                    ;  B
StarFlagExit2:                                                                                      ;  B
RTS                           ; otherwise leave                                                     ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to store horizontal difference between player and piranha plant; 
                                                                                                    ; 
MovePiranhaPlant:                                                                                   ;  B
LDA Enemy_State,X             ; check enemy state                                                   ; 
BNE PutinPipe                 ; if set at all, branch to leave                                      ; 
LDA EnemyFrameTimer,X         ; check enemy's timer here                                            ;  B
BNE PutinPipe                 ; branch to end if not yet expired                                    ; 
LDA PiranhaPlant_MoveFlag,X   ; check movement flag                                                 ;  B
BNE SetupToMovePPlant         ; if moving, skip to part ahead                                       ; 
LDA PiranhaPlant_Y_Speed,X    ; if currently rising, branch                                         ;  B
BMI ReversePlantSpeed         ; to move enemy upwards out of pipe                                   ; 
JSR PlayerEnemyDiff           ; get horizontal difference between player and                        ;  B
BPL ChkPlayerNearPipe         ; piranha plant, and branch if enemy to right of player               ; 
LDA $00                       ; otherwise get saved horizontal difference                           ;  B
EOR #$ff                                                                                            ; 
CLC                           ; and change to two's compliment                                      ; 
ADC #$01                                                                                            ; 
STA $00                       ; save as new horizontal difference                                   ; 
                                                                                                    ; 
ChkPlayerNearPipe:                                                                                  ;  B
LDA $00                       ; get saved horizontal difference                                     ; 
CMP #$21                                                                                            ; 
BCC PutinPipe                 ; if player within a certain distance, branch to leave                ; 
                                                                                                    ;  B
ReversePlantSpeed:                                                                                  ;  B
LDA PiranhaPlant_Y_Speed,X    ; get vertical speed                                                  ; 
EOR #$ff                                                                                            ; 
CLC                           ; change to two's compliment                                          ; 
ADC #$01                                                                                            ; 
STA PiranhaPlant_Y_Speed,X    ; save as new vertical speed                                          ; 
INC PiranhaPlant_MoveFlag,X   ; increment to set movement flag                                      ; 
                                                                                                    ; 
SetupToMovePPlant:                                                                                  ;  B
LDA PiranhaPlantDownYPos,X    ; get original vertical coordinate (lowest point)                     ; 
LDY PiranhaPlant_Y_Speed,X    ; get vertical speed                                                  ; 
BPL RiseFallPiranhaPlant      ; branch if moving downwards                                          ; 
LDA PiranhaPlantUpYPos,X      ; otherwise get other vertical coordinate (highest point)             ;  B
                                                                                                    ; 
RiseFallPiranhaPlant:                                                                               ;  B
STA $00                       ; save vertical coordinate here                                       ; 
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                                                                                                 ; 
BCC PutinPipe                 ; branch to leave if d0 set (execute code every other frame)          ; 
LDA TimerControl              ; get master timer control                                            ;  B
BNE PutinPipe                 ; branch to leave if set (likely not necessary)                       ; 
LDA Enemy_Y_Position,X        ; get current vertical coordinate                                     ;  B
CLC                                                                                                 ; 
ADC PiranhaPlant_Y_Speed,X    ; add vertical speed to move up or down                               ; 
STA Enemy_Y_Position,X        ; save as new vertical coordinate                                     ; 
CMP $00                       ; compare against low or high coordinate                              ; 
BNE PutinPipe                 ; branch to leave if not yet reached                                  ; 
LDA #$00                                                                                            ;  B
STA PiranhaPlant_MoveFlag,X   ; otherwise clear movement flag                                       ; 
LDA #$40                                                                                            ; 
STA EnemyFrameTimer,X         ; set timer to delay piranha plant movement                           ; 
                                                                                                    ; 
PutinPipe:                                                                                          ;  B
LDA #%00100000                ; set background priority bit in sprite                               ; 
STA Enemy_SprAttrib,X         ; attributes to give illusion of being inside pipe                    ; 
RTS                           ; then leave                                                          ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $07 - spinning speed                                                ; 
                                                                                                    ; 
FirebarSpin:                                                                                        ; fun(A): A B
STA $07                       ; save spinning speed here                                            ; 
LDA FirebarSpinDirection,X    ; check spinning direction                                            ; 
BNE SpinCounterClockwise      ; if moving counter-clockwise, branch to other part                   ; 
LDY #$18                      ; possibly residual ldy                                               ;  B
LDA FirebarSpinState_Low,X                                                                          ; 
CLC                           ; add spinning speed to what would normally be                        ; 
ADC $07                       ; the horizontal speed                                                ; 
STA FirebarSpinState_Low,X                                                                          ; 
LDA FirebarSpinState_High,X   ; add carry to what would normally be the vertical speed              ; 
ADC #$00                                                                                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
SpinCounterClockwise:                                                                               ;  B
LDY #$08                      ; possibly residual ldy                                               ; 
LDA FirebarSpinState_Low,X                                                                          ; 
SEC                           ; subtract spinning speed to what would normally be                   ; 
SBC $07                       ; the horizontal speed                                                ; 
STA FirebarSpinState_Low,X                                                                          ; 
LDA FirebarSpinState_High,X   ; add carry to what would normally be the vertical speed              ; 
SBC #$00                                                                                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope; 
                              ; $01 - used to hold high byte of name table for rope                 ; 
                              ; $02 - used to hold page location of rope                            ; 
                                                                                                    ; 
BalancePlatform:                                                                                    ;  B
LDA Enemy_Y_HighPos,X         ; check high byte of vertical position                                ; 
CMP #$03                                                                                            ; 
BNE DoBPl                                                                                           ; 
JMP EraseEnemyObject          ; if far below screen, kill the object                                ;  B
DoBPl:  LDA Enemy_State,X     ; get object's state (set to $ff or other platform offset)            ;  B
BPL CheckBalPlatform          ; if doing other balance platform, branch to leave                    ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
CheckBalPlatform:                                                                                   ;  B
TAY                           ; save offset from state as Y                                         ; 
LDA PlatformCollisionFlag,X   ; get collision flag of platform                                      ; 
STA $00                       ; store here                                                          ; 
LDA Enemy_MovingDir,X         ; get moving direction                                                ; 
BEQ ChkForFall                                                                                      ; 
JMP PlatformFall              ; if set, jump here                                                   ;  B
                                                                                                    ;  B
ChkForFall:                                                                                         ;  B
LDA #$2d                      ; check if platform is above a certain point                          ; 
CMP Enemy_Y_Position,X                                                                              ; 
BCC ChkOtherForFall           ; if not, branch elsewhere                                            ; 
CPY $00                       ; if collision flag is set to same value as                           ;  B
BEQ MakePlatformFall          ; enemy state, branch to make platforms fall                          ; 
CLC                                                                                                 ;  B
ADC #$02                      ; otherwise add 2 pixels to vertical position                         ; 
STA Enemy_Y_Position,X        ; of current platform and branch elsewhere                            ; 
JMP StopPlatforms             ; to make platforms stop                                              ; 
                                                                                                    ;  B
MakePlatformFall:                                                                                   ;  B
JMP InitPlatformFall          ; make platforms fall                                                 ; 
                                                                                                    ;  B
ChkOtherForFall:                                                                                    ;  B
CMP Enemy_Y_Position,Y        ; check if other platform is above a certain point                    ; 
BCC ChkToMoveBalPlat          ; if not, branch elsewhere                                            ; 
CPX $00                       ; if collision flag is set to same value as                           ;  B
BEQ MakePlatformFall          ; enemy state, branch to make platforms fall                          ; 
CLC                                                                                                 ;  B
ADC #$02                      ; otherwise add 2 pixels to vertical position                         ; 
STA Enemy_Y_Position,Y        ; of other platform and branch elsewhere                              ; 
JMP StopPlatforms             ; jump to stop movement and do not return                             ; 
                                                                                                    ;  B
ChkToMoveBalPlat:                                                                                   ;  B
LDA Enemy_Y_Position,X        ; save vertical position to stack                                     ; 
PHA                                                                                                 ; 
LDA PlatformCollisionFlag,X   ; get collision flag                                                  ; 
BPL ColFlg                    ; branch if collision                                                 ; 
LDA Enemy_Y_MoveForce,X                                                                             ;  B
CLC                           ; add $05 to contents of moveforce, whatever they be                  ; 
ADC #$05                                                                                            ; 
STA $00                       ; store here                                                          ; 
LDA Enemy_Y_Speed,X                                                                                 ; 
ADC #$00                      ; add carry to vertical speed                                         ; 
BMI PlatDn                    ; branch if moving downwards                                          ; 
BNE PlatUp                    ; branch elsewhere if moving upwards                                  ;  B
LDA $00                                                                                             ;  B
CMP #$0b                      ; check if there's still a little force left                          ; 
BCC PlatSt                    ; if not enough, branch to stop movement                              ; 
BCS PlatUp                    ; otherwise keep branch to move upwards                               ;  B
ColFlg:  CMP ObjectOffset     ; if collision flag matches                                           ;  B
BEQ PlatDn                    ; current enemy object offset, branch                                 ; 
PlatUp:  JSR MovePlatformUp   ; do a sub to move upwards                                            ;  B
JMP DoOtherPlatform           ; jump ahead to remaining code                                        ; 
PlatSt:  JSR StopPlatforms    ; do a sub to stop movement                                           ;  B
JMP DoOtherPlatform           ; jump ahead to remaining code                                        ; 
PlatDn:  JSR MovePlatformDown ; do a sub to move downwards                                          ;  B
                                                                                                    ; 
DoOtherPlatform:                                                                                    ;  B
LDY Enemy_State,X             ; get offset of other platform                                        ; 
PLA                           ; get old vertical coordinate from stack                              ; 
SEC                                                                                                 ; 
SBC Enemy_Y_Position,X        ; get difference of old vs. new coordinate                            ; 
CLC                                                                                                 ; 
ADC Enemy_Y_Position,Y        ; add difference to vertical coordinate of other                      ; 
STA Enemy_Y_Position,Y        ; platform to move it in the opposite direction                       ; 
LDA PlatformCollisionFlag,X   ; if no collision, skip this part here                                ; 
BMI DrawEraseRope                                                                                   ; 
TAX                           ; put offset which collision occurred here                            ;  B
JSR PositionPlayerOnVPlat     ; and use it to position player accordingly                           ; 
                                                                                                    ; 
DrawEraseRope:                                                                                      ;  B
LDY ObjectOffset              ; get enemy object offset                                             ; 
LDA Enemy_Y_Speed,Y           ; check to see if current platform is                                 ; 
ORA Enemy_Y_MoveForce,Y       ; moving at all                                                       ; 
BEQ ExitRp                    ; if not, skip all of this and branch to leave                        ; 
LDX VRAM_Buffer1_Offset       ; get vram buffer offset                                              ;  B
CPX #$20                      ; if offset beyond a certain point, go ahead                          ; 
BCS ExitRp                    ; and skip this, branch to leave                                      ; 
LDA Enemy_Y_Speed,Y                                                                                 ;  B
PHA                           ; save two copies of vertical speed to stack                          ; 
PHA                                                                                                 ; 
JSR SetupPlatformRope         ; do a sub to figure out where to put new bg tiles                    ; 
LDA $01                       ; write name table address to vram buffer                             ; 
STA VRAM_Buffer1,X            ; first the high byte, then the low                                   ; 
LDA $00                                                                                             ; 
STA VRAM_Buffer1+1,X                                                                                ; 
LDA #$02                      ; set length for 2 bytes                                              ; 
STA VRAM_Buffer1+2,X                                                                                ; 
LDA Enemy_Y_Speed,Y           ; if platform moving upwards, branch                                  ; 
BMI EraseR1                   ; to do something else                                                ; 
LDA #$a2                                                                                            ;  B
STA VRAM_Buffer1+3,X          ; otherwise put tile numbers for left                                 ; 
LDA #$a3                      ; and right sides of rope in vram buffer                              ; 
STA VRAM_Buffer1+4,X                                                                                ; 
JMP OtherRope                 ; jump to skip this part                                              ; 
EraseR1:  LDA #$24            ; put blank tiles in vram buffer                                      ;  B
STA VRAM_Buffer1+3,X          ; to erase rope                                                       ; 
STA VRAM_Buffer1+4,X                                                                                ; 
                                                                                                    ; 
OtherRope:                                                                                          ;  B
LDA Enemy_State,Y             ; get offset of other platform from state                             ; 
TAY                           ; use as Y here                                                       ; 
PLA                           ; pull second copy of vertical speed from stack                       ; 
EOR #$ff                      ; invert bits to reverse speed                                        ; 
JSR SetupPlatformRope         ; do sub again to figure out where to put bg tiles                    ; 
LDA $01                       ; write name table address to vram buffer                             ; 
STA VRAM_Buffer1+5,X          ; this time we're doing putting tiles for                             ; 
LDA $00                       ; the other platform                                                  ; 
STA VRAM_Buffer1+6,X                                                                                ; 
LDA #$02                                                                                            ; 
STA VRAM_Buffer1+7,X          ; set length again for 2 bytes                                        ; 
PLA                           ; pull first copy of vertical speed from stack                        ; 
BPL EraseR2                   ; if moving upwards (note inversion earlier), skip this               ; 
LDA #$a2                                                                                            ;  B
STA VRAM_Buffer1+8,X          ; otherwise put tile numbers for left                                 ; 
LDA #$a3                      ; and right sides of rope in vram                                     ; 
STA VRAM_Buffer1+9,X          ; transfer buffer                                                     ; 
JMP EndRp                     ; jump to skip this part                                              ; 
EraseR2:  LDA #$24            ; put blank tiles in vram buffer                                      ;  B
STA VRAM_Buffer1+8,X          ; to erase rope                                                       ; 
STA VRAM_Buffer1+9,X                                                                                ; 
EndRp:  LDA #$00              ; put null terminator at the end                                      ;  B
STA VRAM_Buffer1+10,X                                                                               ; 
LDA VRAM_Buffer1_Offset       ; add ten bytes to the vram buffer offset                             ; 
CLC                           ; and store                                                           ; 
ADC #10                                                                                             ; 
STA VRAM_Buffer1_Offset                                                                             ; 
ExitRp:  LDX ObjectOffset     ; get enemy object buffer offset and leave                            ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
SetupPlatformRope:                                                                                  ; fun(A): $01$00 B
PHA                           ; save second/third copy to stack                                     ; 
LDA Enemy_X_Position,Y        ; get horizontal coordinate                                           ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
LDX SecondaryHardMode         ; if secondary hard mode flag set,                                    ; 
BNE GetLRp                    ; use coordinate as-is                                                ; 
CLC                                                                                                 ;  B
ADC #$10                      ; otherwise add sixteen more pixels                                   ; 
GetLRp:  PHA                  ; save modified horizontal coordinate to stack                        ;  B
LDA Enemy_PageLoc,Y                                                                                 ; 
ADC #$00                      ; add carry to page location                                          ; 
STA $02                       ; and save here                                                       ; 
PLA                           ; pull modified horizontal coordinate                                 ; 
AND #%11110000                ; from the stack, mask out low nybble                                 ; 
LSR                           ; and shift three bits to the right                                   ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
STA $00                       ; store result here as part of name table low byte                    ; 
LDX Enemy_Y_Position,Y        ; get vertical coordinate                                             ; 
PLA                           ; get second/third copy of vertical speed from stack                  ; 
BPL GetHRp                    ; skip this part if moving downwards or not at all                    ; 
TXA                                                                                                 ;  B
CLC                                                                                                 ; 
ADC #$08                      ; add eight to vertical coordinate and                                ; 
TAX                           ; save as X                                                           ; 
GetHRp:  TXA                  ; move vertical coordinate to A                                       ;  B
LDX VRAM_Buffer1_Offset       ; get vram buffer offset                                              ; 
ASL                                                                                                 ; 
ROL                           ; rotate d7 to d0 and d6 into carry                                   ; 
PHA                           ; save modified vertical coordinate to stack                          ; 
ROL                           ; rotate carry to d0, thus d7 and d6 are at 2 LSB                     ; 
AND #%00000011                ; mask out all bits but d7 and d6, then set                           ; 
ORA #%00100000                ; d5 to get appropriate high byte of name table                       ; 
STA $01                       ; address, then store                                                 ; 
LDA $02                       ; get saved page location from earlier                                ; 
AND #$01                      ; mask out all but LSB                                                ; 
ASL                                                                                                 ; 
ASL                           ; shift twice to the left and save with the                           ; 
ORA $01                       ; rest of the bits of the high byte, to get                           ; 
STA $01                       ; the proper name table and the right place on it                     ; 
PLA                           ; get modified vertical coordinate from stack                         ; 
AND #%11100000                ; mask out low nybble and LSB of high nybble                          ; 
CLC                                                                                                 ; 
ADC $00                       ; add to horizontal part saved here                                   ; 
STA $00                       ; save as name table low byte                                         ; 
LDA Enemy_Y_Position,Y                                                                              ; 
CMP #$e8                      ; if vertical position not below the                                  ; 
BCC ExPRp                     ; bottom of the screen, we're done, branch to leave                   ; 
LDA $00                                                                                             ;  B
AND #%10111111                ; mask out d6 of low byte of name table address                       ; 
STA $00                                                                                             ; 
ExPRp:  RTS                   ; leave!                                                              ;  B
                                                                                                    ;  B
InitPlatformFall:                                                                                   ;  B
TYA                           ; move offset of other platform from Y to X                           ; 
TAX                                                                                                 ; 
JSR GetEnemyOffscreenBits     ; get offscreen bits                                                  ; 
LDA #$06                                                                                            ; 
JSR SetupFloateyNumber        ; award 1000 points to player                                         ; 
LDA Player_Rel_XPos                                                                                 ; 
STA FloateyNum_X_Pos,X        ; put floatey number coordinates where player is                      ; 
LDA Player_Y_Position                                                                               ; 
STA FloateyNum_Y_Pos,X                                                                              ; 
LDA #$01                      ; set moving direction as flag for                                    ; 
STA Enemy_MovingDir,X         ; falling platforms                                                   ; 
                                                                                                    ; 
StopPlatforms:                                                                                      ; fun(A):  B
JSR InitVStf                  ; initialize vertical speed and low byte                              ; 
STA Enemy_Y_Speed,Y           ; for both platforms and leave                                        ; 
STA Enemy_Y_MoveForce,Y                                                                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
PlatformFall:                                                                                       ;  B
TYA                           ; save offset for other platform to stack                             ; 
PHA                                                                                                 ; 
JSR MoveFallingPlatform       ; make current platform fall                                          ; 
PLA                                                                                                 ; 
TAX                           ; pull offset from stack and save to X                                ; 
JSR MoveFallingPlatform       ; make other platform fall                                            ; 
LDX ObjectOffset                                                                                    ; 
LDA PlatformCollisionFlag,X   ; if player not standing on either platform,                          ; 
BMI ExPF                      ; skip this part                                                      ; 
TAX                           ; transfer collision flag offset as offset to X                       ;  B
JSR PositionPlayerOnVPlat     ; and position player appropriately                                   ; 
ExPF:  LDX ObjectOffset       ; get enemy object buffer offset and leave                            ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
YMovingPlatform:                                                                                    ;  B
LDA Enemy_Y_Speed,X           ; if platform moving up or down, skip ahead to                        ; 
ORA Enemy_Y_MoveForce,X       ; check on other position                                             ; 
BNE ChkYCenterPos                                                                                   ; 
STA Enemy_YMF_Dummy,X         ; initialize dummy variable                                           ;  B
LDA Enemy_Y_Position,X                                                                              ; 
CMP YPlatformTopYPos,X        ; if current vertical position => top position, branch                ; 
BCS ChkYCenterPos             ; ahead of all this                                                   ; 
LDA FrameCounter                                                                                    ;  B
AND #%00000111                ; check for every eighth frame                                        ; 
BNE SkipIY                                                                                          ; 
INC Enemy_Y_Position,X        ; increase vertical position every eighth frame                       ;  B
SkipIY:  JMP ChkYPCollision   ; skip ahead to last part                                             ;  B
                                                                                                    ;  B
ChkYCenterPos:                                                                                      ;  B
LDA Enemy_Y_Position,X        ; if current vertical position < central position, branch             ; 
CMP YPlatformCenterYPos,X     ; to slow ascent/move downwards                                       ; 
BCC YMDown                                                                                          ; 
JSR MovePlatformUp            ; otherwise start slowing descent/moving upwards                      ;  B
JMP ChkYPCollision                                                                                  ; 
YMDown:  JSR MovePlatformDown ; start slowing ascent/moving downwards                               ;  B
                                                                                                    ; 
ChkYPCollision:                                                                                     ;  B
LDA PlatformCollisionFlag,X   ; if collision flag not set here, branch                              ; 
BMI ExYPl                     ; to leave                                                            ; 
JSR PositionPlayerOnVPlat     ; otherwise position player appropriately                             ;  B
ExYPl:  RTS                   ; leave                                                               ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used as adder to position player hotizontally                 ; 
                                                                                                    ; 
XMovingPlatform:                                                                                    ;  B
LDA #$0e                      ; load preset maximum value for secondary counter                     ; 
JSR XMoveCntr_Platform        ; do a sub to increment counters for movement                         ; 
JSR MoveWithXMCntrs           ; do a sub to move platform accordingly, and return value             ; 
LDA PlatformCollisionFlag,X   ; if no collision with player,                                        ; 
BMI ExXMP                     ; branch ahead to leave                                               ; 
                                                                                                    ;  B
PositionPlayerOnHPlat:                                                                              ; fun($00):  B
LDA Player_X_Position                                                                               ; 
CLC                           ; add saved value from second subroutine to                           ; 
ADC $00                       ; current player's position to position                               ; 
STA Player_X_Position         ; player accordingly in horizontal position                           ; 
LDA Player_PageLoc            ; get player's page location                                          ; 
LDY $00                       ; check to see if saved value here is positive or negative            ; 
BMI PPHSubt                   ; if negative, branch to subtract                                     ; 
ADC #$00                      ; otherwise add carry to page location                                ;  B
JMP SetPVar                   ; jump to skip subtraction                                            ; 
PPHSubt:  SBC #$00            ; subtract borrow from page location                                  ;  B
SetPVar:  STA Player_PageLoc  ; save result to player's page location                               ;  B
STY Platform_X_Scroll         ; put saved value from second sub here to be used later               ; 
JSR PositionPlayerOnVPlat     ; position player vertically and appropriately                        ; 
ExXMP:  RTS                   ; and we are done here                                                ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
DropPlatform:                                                                                       ;  B
LDA PlatformCollisionFlag,X   ; if no collision between platform and player                         ; 
BMI ExDPl                     ; occurred, just leave without moving anything                        ; 
JSR MoveDropPlatform          ; otherwise do a sub to move platform down very quickly               ;  B
JSR PositionPlayerOnVPlat     ; do a sub to position player appropriately                           ; 
ExDPl:  RTS                   ; leave                                                               ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - residual value from sub                                       ; 
                                                                                                    ; 
RightPlatform:                                                                                      ;  B
JSR MoveEnemyHorizontally     ; move platform with current horizontal speed, if any                 ; 
STA $00                       ; store saved value here (residual code)                              ; 
LDA PlatformCollisionFlag,X   ; check collision flag, if no collision between player                ; 
BMI ExRPl                     ; and platform, branch ahead, leave speed unaltered                   ; 
LDA #$10                                                                                            ;  B
STA Enemy_X_Speed,X           ; otherwise set new speed (gets moving if motionless)                 ; 
JSR PositionPlayerOnHPlat     ; use saved value from earlier sub to position player                 ; 
ExRPl:  RTS                   ; then leave                                                          ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
MoveLargeLiftPlat:                                                                                  ;  B
JSR MoveLiftPlatforms         ; execute common to all large and small lift platforms                ; 
JMP ChkYPCollision            ; branch to position player correctly                                 ; 
                                                                                                    ;  B
MoveSmallPlatform:                                                                                  ; fun():  B
JSR MoveLiftPlatforms         ; execute common to all large and small lift platforms                ; 
JMP ChkSmallPlatCollision     ; branch to position player correctly                                 ; 
                                                                                                    ;  B
MoveLiftPlatforms:                                                                                  ; fun():  B
LDA TimerControl              ; if master timer control set, skip all of this                       ; 
BNE ExLiftP                   ; and branch to leave                                                 ; 
LDA Enemy_YMF_Dummy,X                                                                               ;  B
CLC                           ; add contents of movement amount to whatever's here                  ; 
ADC Enemy_Y_MoveForce,X                                                                             ; 
STA Enemy_YMF_Dummy,X                                                                               ; 
LDA Enemy_Y_Position,X        ; add whatever vertical speed is set to current                       ; 
ADC Enemy_Y_Speed,X           ; vertical position plus carry to move up or down                     ; 
STA Enemy_Y_Position,X        ; and then leave                                                      ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ChkSmallPlatCollision:                                                                              ;  B
LDA PlatformCollisionFlag,X   ; get bounding box counter saved in collision flag                    ; 
BEQ ExLiftP                   ; if none found, leave player position alone                          ; 
JSR PositionPlayerOnS_Plat    ; use to position player correctly                                    ;  B
ExLiftP:  RTS                 ; then leave                                                          ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - page location of extended left boundary                       ; 
                              ; $01 - extended left boundary position                               ; 
                              ; $02 - page location of extended right boundary                      ; 
                              ; $03 - extended right boundary position                              ; 
                                                                                                    ; 
OffscreenBoundsCheck:                                                                               ; fun():  B
LDA Enemy_ID,X                ; check for cheep-cheep object                                        ; 
CMP #FlyingCheepCheep         ; branch to leave if found                                            ; 
BEQ ExScrnBd                                                                                        ; 
LDA ScreenLeft_X_Pos          ; get horizontal coordinate for left side of screen                   ;  B
LDY Enemy_ID,X                                                                                      ; 
CPY #HammerBro                ; check for hammer bro object                                         ; 
BEQ LimitB                                                                                          ; 
CPY #PiranhaPlant             ; check for piranha plant object                                      ;  B
BNE ExtendLB                  ; these two will be erased sooner than others if too far left         ; 
LimitB:  ADC #$38             ; add 56 pixels to coordinate if hammer bro or piranha plant          ;  B
ExtendLB:  SBC #$48           ; subtract 72 pixels regardless of enemy object                       ;  B
STA $01                       ; store result here                                                   ; 
LDA ScreenLeft_PageLoc                                                                              ; 
SBC #$00                      ; subtract borrow from page location of left side                     ; 
STA $00                       ; store result here                                                   ; 
LDA ScreenRight_X_Pos         ; add 72 pixels to the right side horizontal coordinate               ; 
ADC #$48                                                                                            ; 
STA $03                       ; store result here                                                   ; 
LDA ScreenRight_PageLoc                                                                             ; 
ADC #$00                      ; then add the carry to the page location                             ; 
STA $02                       ; and store result here                                               ; 
LDA Enemy_X_Position,X        ; compare horizontal coordinate of the enemy object                   ; 
CMP $01                       ; to modified horizontal left edge coordinate to get carry            ; 
LDA Enemy_PageLoc,X                                                                                 ; 
SBC $00                       ; then subtract it from the page coordinate of the enemy object       ; 
BMI TooFar                    ; if enemy object is too far left, branch to erase it                 ; 
LDA Enemy_X_Position,X        ; compare horizontal coordinate of the enemy object                   ;  B
CMP $03                       ; to modified horizontal right edge coordinate to get carry           ; 
LDA Enemy_PageLoc,X                                                                                 ; 
SBC $02                       ; then subtract it from the page coordinate of the enemy object       ; 
BMI ExScrnBd                  ; if enemy object is on the screen, leave, do not erase enemy         ; 
LDA Enemy_State,X             ; if at this point, enemy is offscreen to the right, so check         ;  B
CMP #HammerBro                ; if in state used by spiny's egg, do not erase                       ; 
BEQ ExScrnBd                                                                                        ; 
CPY #PiranhaPlant             ; if piranha plant, do not erase                                      ;  B
BEQ ExScrnBd                                                                                        ; 
CPY #FlagpoleFlagObject       ; if flagpole flag, do not erase                                      ;  B
BEQ ExScrnBd                                                                                        ; 
CPY #StarFlagObject           ; if star flag, do not erase                                          ;  B
BEQ ExScrnBd                                                                                        ; 
CPY #JumpspringObject         ; if jumpspring, do not erase                                         ;  B
BEQ ExScrnBd                  ; erase all others too far to the right                               ; 
TooFar:  JSR EraseEnemyObject ; erase object if necessary                                           ;  B
ExScrnBd:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; some unused space                                                   ; 
DATA: ByteValue(value=255), ByteValue(value=255), ByteValue(value=255)                              ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; $01 - enemy buffer offset                                           ; 
                                                                                                    ; 
FireballEnemyCollision:                                                                             ; fun():  B
LDA Fireball_State,X          ; check to see if fireball state is set at all                        ; 
BEQ ExitFBallEnemy            ; branch to leave if not                                              ; 
ASL                                                                                                 ;  B
BCS ExitFBallEnemy            ; branch to leave also if d7 in state is set                          ; 
LDA FrameCounter                                                                                    ;  B
LSR                           ; get LSB of frame counter                                            ; 
BCS ExitFBallEnemy            ; branch to leave if set (do routine every other frame)               ; 
TXA                                                                                                 ;  B
ASL                           ; multiply fireball offset by four                                    ; 
ASL                                                                                                 ; 
CLC                                                                                                 ; 
ADC #$1c                      ; then add $1c or 28 bytes to it                                      ; 
TAY                           ; to use fireball's bounding box coordinates                          ; 
LDX #$04                                                                                            ; 
                                                                                                    ; 
FireballEnemyCDLoop:                                                                                ;  B
STX $01                       ; store enemy object offset here                                      ; 
TYA                                                                                                 ; 
PHA                           ; push fireball offset to the stack                                   ; 
LDA Enemy_State,X                                                                                   ; 
AND #%00100000                ; check to see if d5 is set in enemy state                            ; 
BNE NoFToECol                 ; if so, skip to next enemy slot                                      ; 
LDA Enemy_Flag,X              ; check to see if buffer flag is set                                  ;  B
BEQ NoFToECol                 ; if not, skip to next enemy slot                                     ; 
LDA Enemy_ID,X                ; check enemy identifier                                              ;  B
CMP #$24                                                                                            ; 
BCC GoombaDie                 ; if < $24, branch to check further                                   ; 
CMP #$2b                                                                                            ;  B
BCC NoFToECol                 ; if in range $24-$2a, skip to next enemy slot                        ; 
GoombaDie:  CMP #Goomba       ; check for goomba identifier                                         ;  B
BNE NotGoomba                 ; if not found, continue with code                                    ; 
LDA Enemy_State,X             ; otherwise check for defeated state                                  ;  B
CMP #$02                      ; if stomped or otherwise defeated,                                   ; 
BCS NoFToECol                 ; skip to next enemy slot                                             ; 
NotGoomba:  LDA EnemyOffscrBitsMasked,X; if any masked offscreen bits set,                          ;  B
BNE NoFToECol                 ; skip to next enemy slot                                             ; 
TXA                                                                                                 ;  B
ASL                           ; otherwise multiply enemy offset by four                             ; 
ASL                                                                                                 ; 
CLC                                                                                                 ; 
ADC #$04                      ; add 4 bytes to it                                                   ; 
TAX                           ; to use enemy's bounding box coordinates                             ; 
JSR SprObjectCollisionCore    ; do fireball-to-enemy collision detection                            ; 
LDX ObjectOffset              ; return fireball's original offset                                   ; 
BCC NoFToECol                 ; if carry clear, no collision, thus do next enemy slot               ; 
LDA #%10000000                                                                                      ;  B
STA Fireball_State,X          ; set d7 in enemy state                                               ; 
LDX $01                       ; get enemy offset                                                    ; 
JSR HandleEnemyFBallCol       ; jump to handle fireball to enemy collision                          ; 
NoFToECol:  PLA               ; pull fireball offset from stack                                     ;  B
TAY                           ; put it in Y                                                         ; 
LDX $01                       ; get enemy object offset                                             ; 
DEX                           ; decrement it                                                        ; 
BPL FireballEnemyCDLoop       ; loop back until collision detection done on all enemies             ; 
                                                                                                    ;  B
ExitFBallEnemy:                                                                                     ;  B
LDX ObjectOffset              ; get original fireball offset and leave                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
BowserIdentities:                                                                                   ;  B
DATA: Expr(expr=Goomba), Expr(expr=GreenKoopa), Expr(expr=BuzzyBeetle), Expr(expr=Spiny), Expr(expr=Lakitu), Expr(expr=Bloober), Expr(expr=HammerBro), Expr(expr=Bowser); 
                                                                                                    ; 
HandleEnemyFBallCol:                                                                                ; fun($01):  B
JSR RelativeEnemyPosition     ; get relative coordinate of enemy                                    ; 
LDX $01                       ; get current enemy object offset                                     ; 
LDA Enemy_Flag,X              ; check buffer flag for d7 set                                        ; 
BPL ChkBuzzyBeetle            ; branch if not set to continue                                       ; 
AND #%00001111                ; otherwise mask out high nybble and                                  ;  B
TAX                           ; use low nybble as enemy offset                                      ; 
LDA Enemy_ID,X                                                                                      ; 
CMP #Bowser                   ; check enemy identifier for bowser                                   ; 
BEQ HurtBowser                ; branch if found                                                     ; 
LDX $01                       ; otherwise retrieve current enemy offset                             ;  B
                                                                                                    ; 
ChkBuzzyBeetle:                                                                                     ;  B
LDA Enemy_ID,X                                                                                      ; 
CMP #BuzzyBeetle              ; check for buzzy beetle                                              ; 
BEQ ExHCF                     ; branch if found to leave (buzzy beetles fireproof)                  ; 
CMP #Bowser                   ; check for bowser one more time (necessary if d7 of flag was clear)  ;  B
BNE ChkOtherEnemies           ; if not found, branch to check other enemies                         ; 
                                                                                                    ;  B
HurtBowser:                                                                                         ;  B
DEC BowserHitPoints           ; decrement bowser's hit points                                       ; 
BNE ExHCF                     ; if bowser still has hit points, branch to leave                     ; 
JSR InitVStf                  ; otherwise do sub to init vertical speed and movement force          ;  B
STA Enemy_X_Speed,X           ; initialize horizontal speed                                         ; 
STA EnemyFrenzyBuffer         ; init enemy frenzy buffer                                            ; 
LDA #$fe                                                                                            ; 
STA Enemy_Y_Speed,X           ; set vertical speed to make defeated bowser jump a little            ; 
LDY WorldNumber               ; use world number as offset                                          ; 
LDA BowserIdentities,Y        ; get enemy identifier to replace bowser with                         ; 
STA Enemy_ID,X                ; set as new enemy identifier                                         ; 
LDA #$20                      ; set A to use starting value for state                               ; 
CPY #$03                      ; check to see if using offset of 3 or more                           ; 
BCS SetDBSte                  ; branch if so                                                        ; 
ORA #$03                      ; otherwise add 3 to enemy state                                      ;  B
SetDBSte:  STA Enemy_State,X  ; set defeated enemy state                                            ;  B
LDA #Sfx_BowserFall                                                                                 ; 
STA Square2SoundQueue         ; load bowser defeat sound                                            ; 
LDX $01                       ; get enemy offset                                                    ; 
LDA #$09                      ; award 5000 points to player for defeating bowser                    ; 
BNE EnemySmackScore           ; unconditional branch to award points                                ; 
                                                                                                    ;  B
ChkOtherEnemies:                                                                                    ;  B
CMP #BulletBill_FrenzyVar                                                                           ; 
BEQ ExHCF                     ; branch to leave if bullet bill (frenzy variant)                     ; 
CMP #Podoboo                                                                                        ;  B
BEQ ExHCF                     ; branch to leave if podoboo                                          ; 
CMP #$15                                                                                            ;  B
BCS ExHCF                     ; branch to leave if identifier => $15                                ; 
                                                                                                    ;  B
ShellOrBlockDefeat:                                                                                 ; fun():  B
LDA Enemy_ID,X                ; check for piranha plant                                             ; 
CMP #PiranhaPlant                                                                                   ; 
BNE StnE                      ; branch if not found                                                 ; 
LDA Enemy_Y_Position,X                                                                              ;  B
ADC #$18                      ; add 24 pixels to enemy object's vertical position                   ; 
STA Enemy_Y_Position,X                                                                              ; 
StnE:  JSR ChkToStunEnemies   ; do yet another sub                                                  ;  B
LDA Enemy_State,X                                                                                   ; 
AND #%00011111                ; mask out 2 MSB of enemy object's state                              ; 
ORA #%00100000                ; set d5 to defeat enemy and save as new state                        ; 
STA Enemy_State,X                                                                                   ; 
LDA #$02                      ; award 200 points by default                                         ; 
LDY Enemy_ID,X                ; check for hammer bro                                                ; 
CPY #HammerBro                                                                                      ; 
BNE GoombaPoints              ; branch if not found                                                 ; 
LDA #$06                      ; award 1000 points for hammer bro                                    ;  B
                                                                                                    ; 
GoombaPoints:                                                                                       ;  B
CPY #Goomba                   ; check for goomba                                                    ; 
BNE EnemySmackScore           ; branch if not found                                                 ; 
LDA #$01                      ; award 100 points for goomba                                         ;  B
                                                                                                    ; 
EnemySmackScore:                                                                                    ;  B
JSR SetupFloateyNumber        ; update necessary score variables                                    ; 
LDA #Sfx_EnemySmack           ; play smack enemy sound                                              ; 
STA Square1SoundQueue                                                                               ; 
ExHCF:  RTS                   ; and now let's leave                                                 ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerHammerCollision:                                                                              ; fun(X):  B
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; shift d0 into carry                                                 ; 
BCC ExPHC                     ; branch to leave if d0 not set to execute every other frame          ; 
LDA TimerControl              ; if either master timer control                                      ;  B
ORA Misc_OffscreenBits        ; or any offscreen bits for hammer are set,                           ; 
BNE ExPHC                     ; branch to leave                                                     ; 
TXA                                                                                                 ;  B
ASL                           ; multiply misc object offset by four                                 ; 
ASL                                                                                                 ; 
CLC                                                                                                 ; 
ADC #$24                      ; add 36 or $24 bytes to get proper offset                            ; 
TAY                           ; for misc object bounding box coordinates                            ; 
JSR PlayerCollisionCore       ; do player-to-hammer collision detection                             ; 
LDX ObjectOffset              ; get misc object offset                                              ; 
BCC ClHCol                    ; if no collision, then branch                                        ; 
LDA Misc_Collision_Flag,X     ; otherwise read collision flag                                       ;  B
BNE ExPHC                     ; if collision flag already set, branch to leave                      ; 
LDA #$01                                                                                            ;  B
STA Misc_Collision_Flag,X     ; otherwise set collision flag now                                    ; 
LDA Misc_X_Speed,X                                                                                  ; 
EOR #$ff                      ; get two's compliment of                                             ; 
CLC                           ; hammer's horizontal speed                                           ; 
ADC #$01                                                                                            ; 
STA Misc_X_Speed,X            ; set to send hammer flying the opposite direction                    ; 
LDA StarInvincibleTimer       ; if star mario invincibility timer set,                              ; 
BNE ExPHC                     ; branch to leave                                                     ; 
JMP InjurePlayer              ; otherwise jump to hurt player, do not return                        ;  B
ClHCol:  LDA #$00             ; clear collision flag                                                ;  B
STA Misc_Collision_Flag,X                                                                           ; 
ExPHC:  RTS                                                                                         ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
HandlePowerUpCollision:                                                                             ;  B
JSR EraseEnemyObject          ; erase the power-up object                                           ; 
LDA #$06                                                                                            ; 
JSR SetupFloateyNumber        ; award 1000 points to player by default                              ; 
LDA #Sfx_PowerUpGrab                                                                                ; 
STA Square2SoundQueue         ; play the power-up sound                                             ; 
LDA PowerUpType               ; check power-up type                                                 ; 
CMP #$02                                                                                            ; 
BCC Shroom_Flower_PUp         ; if mushroom or fire flower, branch                                  ; 
CMP #$03                                                                                            ;  B
BEQ SetFor1Up                 ; if 1-up mushroom, branch                                            ; 
LDA #$23                      ; otherwise set star mario invincibility                              ;  B
STA StarInvincibleTimer       ; timer, and load the star mario music                                ; 
LDA #StarPowerMusic           ; into the area music queue, then leave                               ; 
STA AreaMusicQueue                                                                                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
Shroom_Flower_PUp:                                                                                  ;  B
LDA PlayerStatus              ; if player status = small, branch                                    ; 
BEQ UpToSuper                                                                                       ; 
CMP #$01                      ; if player status not super, leave                                   ;  B
BNE NoPUp                                                                                           ; 
LDX ObjectOffset              ; get enemy offset, not necessary                                     ;  B
LDA #$02                      ; set player status to fiery                                          ; 
STA PlayerStatus                                                                                    ; 
JSR GetPlayerColors           ; run sub to change colors of player                                  ; 
LDX ObjectOffset              ; get enemy offset again, and again not necessary                     ; 
LDA #$0c                      ; set value to be used by subroutine tree (fiery)                     ; 
JMP UpToFiery                 ; jump to set values accordingly                                      ; 
                                                                                                    ;  B
SetFor1Up:                                                                                          ;  B
LDA #$0b                      ; change 1000 points into 1-up instead                                ; 
STA FloateyNum_Control,X      ; and then leave                                                      ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
UpToSuper:                                                                                          ;  B
LDA #$01                      ; set player status to super                                          ; 
STA PlayerStatus                                                                                    ; 
LDA #$09                      ; set value to be used by subroutine tree (super)                     ; 
                                                                                                    ; 
UpToFiery:                                                                                          ;  B
LDY #$00                      ; set value to be used as new player state                            ; 
JSR SetPRout                  ; set values to stop certain things in motion                         ; 
NoPUp:  RTS                                                                                         ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ResidualXSpdData:                                                                                   ;  B
DATA: ByteValue(value=24), ByteValue(value=232)                                                     ; 
                                                                                                    ; 
KickedShellXSpdData:                                                                                ;  B
DATA: ByteValue(value=48), ByteValue(value=208)                                                     ; 
                                                                                                    ; 
DemotedKoopaXSpdData:                                                                               ;  B
DATA: ByteValue(value=8), ByteValue(value=248)                                                      ; 
                                                                                                    ; 
PlayerEnemyCollision:                                                                               ; fun():  B
LDA FrameCounter              ; check counter for d0 set                                            ; 
LSR                                                                                                 ; 
BCS NoPUp                     ; if set, branch to leave                                             ; 
JSR CheckPlayerVertical       ; if player object is completely offscreen or                         ;  B
BCS NoPECol                   ; if down past 224th pixel row, branch to leave                       ; 
LDA EnemyOffscrBitsMasked,X   ; if current enemy is offscreen by any amount,                        ;  B
BNE NoPECol                   ; go ahead and branch to leave                                        ; 
LDA GameEngineSubroutine                                                                            ;  B
CMP #$08                      ; if not set to run player control routine                            ; 
BNE NoPECol                   ; on next frame, branch to leave                                      ; 
LDA Enemy_State,X                                                                                   ;  B
AND #%00100000                ; if enemy state has d5 set, branch to leave                          ; 
BNE NoPECol                                                                                         ; 
JSR GetEnemyBoundBoxOfs       ; get bounding box offset for current enemy object                    ;  B
JSR PlayerCollisionCore       ; do collision detection on player vs. enemy                          ; 
LDX ObjectOffset              ; get enemy object buffer offset                                      ; 
BCS CheckForPUpCollision      ; if collision, branch past this part here                            ; 
LDA Enemy_CollisionBits,X                                                                           ;  B
AND #%11111110                ; otherwise, clear d0 of current enemy object's                       ; 
STA Enemy_CollisionBits,X     ; collision bit                                                       ; 
NoPECol:  RTS                                                                                       ;  B
                                                                                                    ;  B
CheckForPUpCollision:                                                                               ;  B
LDY Enemy_ID,X                                                                                      ; 
CPY #PowerUpObject            ; check for power-up object                                           ; 
BNE EColl                     ; if not found, branch to next part                                   ; 
JMP HandlePowerUpCollision    ; otherwise, unconditional jump backwards                             ;  B
EColl:  LDA StarInvincibleTimer; if star mario invincibility timer expired,                         ;  B
BEQ HandlePECollisions        ; perform task here, otherwise kill enemy like                        ; 
JMP ShellOrBlockDefeat        ; hit with a shell, or from beneath                                   ;  B
                                                                                                    ;  B
KickedShellPtsData:                                                                                 ;  B
DATA: ByteValue(value=10), ByteValue(value=6), ByteValue(value=4)                                   ; 
                                                                                                    ; 
HandlePECollisions:                                                                                 ;  B
LDA Enemy_CollisionBits,X     ; check enemy collision bits for d0 set                               ; 
AND #%00000001                ; or for being offscreen at all                                       ; 
ORA EnemyOffscrBitsMasked,X                                                                         ; 
BNE ExPEC                     ; branch to leave if either is true                                   ; 
LDA #$01                                                                                            ;  B
ORA Enemy_CollisionBits,X     ; otherwise set d0 now                                                ; 
STA Enemy_CollisionBits,X                                                                           ; 
CPY #Spiny                    ; branch if spiny                                                     ; 
BEQ ChkForPlayerInjury                                                                              ; 
CPY #PiranhaPlant             ; branch if piranha plant                                             ;  B
BEQ InjurePlayer                                                                                    ; 
CPY #Podoboo                  ; branch if podoboo                                                   ;  B
BEQ InjurePlayer                                                                                    ; 
CPY #BulletBill_CannonVar     ; branch if bullet bill                                               ;  B
BEQ ChkForPlayerInjury                                                                              ; 
CPY #$15                      ; branch if object => $15                                             ;  B
BCS InjurePlayer                                                                                    ; 
LDA AreaType                  ; branch if water type level                                          ;  B
BEQ InjurePlayer                                                                                    ; 
LDA Enemy_State,X             ; branch if d7 of enemy state was set                                 ;  B
ASL                                                                                                 ; 
BCS ChkForPlayerInjury                                                                              ; 
LDA Enemy_State,X             ; mask out all but 3 LSB of enemy state                               ;  B
AND #%00000111                                                                                      ; 
CMP #$02                      ; branch if enemy is in normal or falling state                       ; 
BCC ChkForPlayerInjury                                                                              ; 
LDA Enemy_ID,X                ; branch to leave if goomba in defeated state                         ;  B
CMP #Goomba                                                                                         ; 
BEQ ExPEC                                                                                           ; 
LDA #Sfx_EnemySmack           ; play smack enemy sound                                              ;  B
STA Square1SoundQueue                                                                               ; 
LDA Enemy_State,X             ; set d7 in enemy state, thus become moving shell                     ; 
ORA #%10000000                                                                                      ; 
STA Enemy_State,X                                                                                   ; 
JSR EnemyFacePlayer           ; set moving direction and get offset                                 ; 
LDA KickedShellXSpdData,Y     ; load and set horizontal speed data with offset                      ; 
STA Enemy_X_Speed,X                                                                                 ; 
LDA #$03                      ; add three to whatever the stomp counter contains                    ; 
CLC                           ; to give points for kicking the shell                                ; 
ADC StompChainCounter                                                                               ; 
LDY EnemyIntervalTimer,X      ; check shell enemy's timer                                           ; 
CPY #$03                      ; if above a certain point, branch using the points                   ; 
BCS KSPts                     ; data obtained from the stomp counter + 3                            ; 
LDA KickedShellPtsData,Y      ; otherwise, set points based on proximity to timer expiration        ;  B
KSPts:  JSR SetupFloateyNumber; set values for floatey number now                                   ;  B
ExPEC:  RTS                   ; leave!!!                                                            ;  B
                                                                                                    ;  B
ChkForPlayerInjury:                                                                                 ;  B
LDA Player_Y_Speed            ; check player's vertical speed                                       ; 
BMI ChkInj                    ; perform procedure below if player moving upwards                    ; 
BNE EnemyStomped              ; or not at all, and branch elsewhere if moving downwards             ;  B
ChkInj:  LDA Enemy_ID,X       ; branch if enemy object < $07                                        ;  B
CMP #Bloober                                                                                        ; 
BCC ChkETmrs                                                                                        ; 
LDA Player_Y_Position         ; add 12 pixels to player's vertical position                         ;  B
CLC                                                                                                 ; 
ADC #$0c                                                                                            ; 
CMP Enemy_Y_Position,X        ; compare modified player's position to enemy's position              ; 
BCC EnemyStomped              ; branch if this player's position above (less than) enemy's          ; 
ChkETmrs:  LDA StompTimer     ; check stomp timer                                                   ;  B
BNE EnemyStomped              ; branch if set                                                       ; 
LDA InjuryTimer               ; check to see if injured invincibility timer still                   ;  B
BNE ExInjColRoutines          ; counting down, and branch elsewhere to leave if so                  ; 
LDA Player_Rel_XPos                                                                                 ;  B
CMP Enemy_Rel_XPos            ; if player's relative position to the left of enemy's                ; 
BCC TInjE                     ; relative position, branch here                                      ; 
JMP ChkEnemyFaceRight         ; otherwise do a jump here                                            ;  B
TInjE:  LDA Enemy_MovingDir,X ; if enemy moving towards the left,                                   ;  B
CMP #$01                      ; branch, otherwise do a jump here                                    ; 
BNE InjurePlayer              ; to turn the enemy around                                            ; 
JMP LInj                                                                                            ;  B
                                                                                                    ;  B
InjurePlayer:                                                                                       ; fun():  B
LDA InjuryTimer               ; check again to see if injured invincibility timer is                ; 
BNE ExInjColRoutines          ; at zero, and branch to leave if so                                  ; 
                                                                                                    ;  B
ForceInjury:                                                                                        ; fun(A):  B
LDX PlayerStatus              ; check player's status                                               ; 
BEQ KillPlayer                ; branch if small                                                     ; 
STA PlayerStatus              ; otherwise set player's status to small                              ;  B
LDA #$08                                                                                            ; 
STA InjuryTimer               ; set injured invincibility timer                                     ; 
ASL                                                                                                 ; 
STA Square1SoundQueue         ; play pipedown/injury sound                                          ; 
JSR GetPlayerColors           ; change player's palette if necessary                                ; 
LDA #$0a                      ; set subroutine to run on next frame                                 ; 
SetKRout:  LDY #$01           ; set new player state                                                ;  B
SetPRout:  STA GameEngineSubroutine; load new value to run subroutine on next frame                 ; fun(AY):  B
STY Player_State              ; store new player state                                              ; 
LDY #$ff                                                                                            ; 
STY TimerControl              ; set master timer control flag to halt timers                        ; 
INY                                                                                                 ; 
STY ScrollAmount              ; initialize scroll speed                                             ; 
                                                                                                    ; 
ExInjColRoutines:                                                                                   ;  B
LDX ObjectOffset              ; get enemy offset and leave                                          ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
KillPlayer:                                                                                         ;  B
STX Player_X_Speed            ; halt player's horizontal movement by initializing speed             ; 
INX                                                                                                 ; 
STX EventMusicQueue           ; set event music queue to death music                                ; 
LDA #$fc                                                                                            ; 
STA Player_Y_Speed            ; set new vertical speed                                              ; 
LDA #$0b                      ; set subroutine to run on next frame                                 ; 
BNE SetKRout                  ; branch to set player's state and other things                       ; 
                                                                                                    ;  B
StompedEnemyPtsData:                                                                                ;  B
DATA: ByteValue(value=2), ByteValue(value=6), ByteValue(value=5), ByteValue(value=6)                ; 
                                                                                                    ; 
EnemyStomped:                                                                                       ;  B
LDA Enemy_ID,X                ; check for spiny, branch to hurt player                              ; 
CMP #Spiny                    ; if found                                                            ; 
BEQ InjurePlayer                                                                                    ; 
LDA #Sfx_EnemyStomp           ; otherwise play stomp/swim sound                                     ;  B
STA Square1SoundQueue                                                                               ; 
LDA Enemy_ID,X                                                                                      ; 
LDY #$00                      ; initialize points data offset for stomped enemies                   ; 
CMP #FlyingCheepCheep         ; branch for cheep-cheep                                              ; 
BEQ EnemyStompedPts                                                                                 ; 
CMP #BulletBill_FrenzyVar     ; branch for either bullet bill object                                ;  B
BEQ EnemyStompedPts                                                                                 ; 
CMP #BulletBill_CannonVar                                                                           ;  B
BEQ EnemyStompedPts                                                                                 ; 
CMP #Podoboo                  ; branch for podoboo (this branch is logically impossible             ;  B
BEQ EnemyStompedPts           ; for cpu to take due to earlier checking of podoboo)                 ; 
INY                           ; increment points data offset                                        ;  B
CMP #HammerBro                ; branch for hammer bro                                               ; 
BEQ EnemyStompedPts                                                                                 ; 
INY                           ; increment points data offset                                        ;  B
CMP #Lakitu                   ; branch for lakitu                                                   ; 
BEQ EnemyStompedPts                                                                                 ; 
INY                           ; increment points data offset                                        ;  B
CMP #Bloober                  ; branch if NOT bloober                                               ; 
BNE ChkForDemoteKoopa                                                                               ; 
                                                                                                    ;  B
EnemyStompedPts:                                                                                    ;  B
LDA StompedEnemyPtsData,Y     ; load points data using offset in Y                                  ; 
JSR SetupFloateyNumber        ; run sub to set floatey number controls                              ; 
LDA Enemy_MovingDir,X                                                                               ; 
PHA                           ; save enemy movement direction to stack                              ; 
JSR SetStun                   ; run sub to kill enemy                                               ; 
PLA                                                                                                 ; 
STA Enemy_MovingDir,X         ; return enemy movement direction from stack                          ; 
LDA #%00100000                                                                                      ; 
STA Enemy_State,X             ; set d5 in enemy state                                               ; 
JSR InitVStf                  ; nullify vertical speed, physics-related thing,                      ; 
STA Enemy_X_Speed,X           ; and horizontal speed                                                ; 
LDA #$fd                      ; set player's vertical speed, to give bounce                         ; 
STA Player_Y_Speed                                                                                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ChkForDemoteKoopa:                                                                                  ;  B
CMP #$09                      ; branch elsewhere if enemy object < $09                              ; 
BCC HandleStompedShellE                                                                             ; 
AND #%00000001                ; demote koopa paratroopas to ordinary troopas                        ;  B
STA Enemy_ID,X                                                                                      ; 
LDY #$00                      ; return enemy to normal state                                        ; 
STY Enemy_State,X                                                                                   ; 
LDA #$03                      ; award 400 points to the player                                      ; 
JSR SetupFloateyNumber                                                                              ; 
JSR InitVStf                  ; nullify physics-related thing and vertical speed                    ; 
JSR EnemyFacePlayer           ; turn enemy around if necessary                                      ; 
LDA DemotedKoopaXSpdData,Y                                                                          ; 
STA Enemy_X_Speed,X           ; set appropriate moving speed based on direction                     ; 
JMP SBnce                     ; then move onto something else                                       ; 
                                                                                                    ;  B
RevivalRateData:                                                                                    ;  B
DATA: ByteValue(value=16), ByteValue(value=11)                                                      ; 
                                                                                                    ; 
HandleStompedShellE:                                                                                ;  B
LDA #$04                      ; set defeated state for enemy                                        ; 
STA Enemy_State,X                                                                                   ; 
INC StompChainCounter         ; increment the stomp counter                                         ; 
LDA StompChainCounter         ; add whatever is in the stomp counter                                ; 
CLC                           ; to whatever is in the stomp timer                                   ; 
ADC StompTimer                                                                                      ; 
JSR SetupFloateyNumber        ; award points accordingly                                            ; 
INC StompTimer                ; increment stomp timer of some sort                                  ; 
LDY PrimaryHardMode           ; check primary hard mode flag                                        ; 
LDA RevivalRateData,Y         ; load timer setting according to flag                                ; 
STA EnemyIntervalTimer,X      ; set as enemy timer to revive stomped enemy                          ; 
SBnce:  LDA #$fc              ; set player's vertical speed for bounce                              ;  B
STA Player_Y_Speed            ; and then leave!!!                                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ChkEnemyFaceRight:                                                                                  ;  B
LDA Enemy_MovingDir,X         ; check to see if enemy is moving to the right                        ; 
CMP #$01                                                                                            ; 
BNE LInj                      ; if not, branch                                                      ; 
JMP InjurePlayer              ; otherwise go back to hurt player                                    ;  B
LInj:  JSR EnemyTurnAround    ; turn the enemy around, if necessary                                 ;  B
JMP InjurePlayer              ; go back to hurt player                                              ; 
                                                                                                    ;  B
                                                                                                    ; 
EnemyFacePlayer:                                                                                    ; fun():  B
LDY #$01                      ; set to move right by default                                        ; 
JSR PlayerEnemyDiff           ; get horizontal difference between player and enemy                  ; 
BPL SFcRt                     ; if enemy is to the right of player, do not increment                ; 
INY                           ; otherwise, increment to set to move to the left                     ;  B
SFcRt:  STY Enemy_MovingDir,X ; set moving direction here                                           ;  B
DEY                           ; then decrement to use as a proper offset                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
SetupFloateyNumber:                                                                                 ; fun(A):  B
STA FloateyNum_Control,X      ; set number of points control for floatey numbers                    ; 
LDA #$30                                                                                            ; 
STA FloateyNum_Timer,X        ; set timer for floatey numbers                                       ; 
LDA Enemy_Y_Position,X                                                                              ; 
STA FloateyNum_Y_Pos,X        ; set vertical coordinate                                             ; 
LDA Enemy_Rel_XPos                                                                                  ; 
STA FloateyNum_X_Pos,X        ; set horizontal coordinate and leave                                 ; 
ExSFN:  RTS                                                                                         ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $01 - used to hold enemy offset for second enemy                    ; 
                                                                                                    ; 
SetBitsMask:                                                                                        ;  B
DATA: ByteValue(value=128), ByteValue(value=64), ByteValue(value=32), ByteValue(value=16), ByteValue(value=8), ByteValue(value=4), ByteValue(value=2); 
                                                                                                    ; 
ClearBitsMask:                                                                                      ;  B
DATA: ByteValue(value=127), ByteValue(value=191), ByteValue(value=223), ByteValue(value=239), ByteValue(value=247), ByteValue(value=251), ByteValue(value=253); 
                                                                                                    ; 
EnemiesCollision:                                                                                   ; fun(Y):  B
LDA FrameCounter              ; check counter for d0 set                                            ; 
LSR                                                                                                 ; 
BCC ExSFN                     ; if d0 not set, leave                                                ; 
LDA AreaType                                                                                        ;  B
BEQ ExSFN                     ; if water area type, leave                                           ; 
LDA Enemy_ID,X                                                                                      ;  B
CMP #$15                      ; if enemy object => $15, branch to leave                             ; 
BCS ExitECRoutine                                                                                   ; 
CMP #Lakitu                   ; if lakitu, branch to leave                                          ;  B
BEQ ExitECRoutine                                                                                   ; 
CMP #PiranhaPlant             ; if piranha plant, branch to leave                                   ;  B
BEQ ExitECRoutine                                                                                   ; 
LDA EnemyOffscrBitsMasked,X   ; if masked offscreen bits nonzero, branch to leave                   ;  B
BNE ExitECRoutine                                                                                   ; 
JSR GetEnemyBoundBoxOfs       ; otherwise, do sub, get appropriate bounding box offset for          ;  B
DEX                           ; first enemy we're going to compare, then decrement for second       ; 
BMI ExitECRoutine             ; branch to leave if there are no other enemies                       ; 
ECLoop:  STX $01              ; save enemy object buffer offset for second enemy here               ;  B
TYA                           ; save first enemy's bounding box offset to stack                     ; 
PHA                                                                                                 ; 
LDA Enemy_Flag,X              ; check enemy object enable flag                                      ; 
BEQ ReadyNextEnemy            ; branch if flag not set                                              ; 
LDA Enemy_ID,X                                                                                      ;  B
CMP #$15                      ; check for enemy object => $15                                       ; 
BCS ReadyNextEnemy            ; branch if true                                                      ; 
CMP #Lakitu                                                                                         ;  B
BEQ ReadyNextEnemy            ; branch if enemy object is lakitu                                    ; 
CMP #PiranhaPlant                                                                                   ;  B
BEQ ReadyNextEnemy            ; branch if enemy object is piranha plant                             ; 
LDA EnemyOffscrBitsMasked,X                                                                         ;  B
BNE ReadyNextEnemy            ; branch if masked offscreen bits set                                 ; 
TXA                           ; get second enemy object's bounding box offset                       ;  B
ASL                           ; multiply by four, then add four                                     ; 
ASL                                                                                                 ; 
CLC                                                                                                 ; 
ADC #$04                                                                                            ; 
TAX                           ; use as new contents of X                                            ; 
JSR SprObjectCollisionCore    ; do collision detection using the two enemies here                   ; 
LDX ObjectOffset              ; use first enemy offset for X                                        ; 
LDY $01                       ; use second enemy offset for Y                                       ; 
BCC NoEnemyCollision          ; if carry clear, no collision, branch ahead of this                  ; 
LDA Enemy_State,X                                                                                   ;  B
ORA Enemy_State,Y             ; check both enemy states for d7 set                                  ; 
AND #%10000000                                                                                      ; 
BNE YesEC                     ; branch if at least one of them is set                               ; 
LDA Enemy_CollisionBits,Y     ; load first enemy's collision-related bits                           ;  B
AND SetBitsMask,X             ; check to see if bit connected to second enemy is                    ; 
BNE ReadyNextEnemy            ; already set, and move onto next enemy slot if set                   ; 
LDA Enemy_CollisionBits,Y                                                                           ;  B
ORA SetBitsMask,X             ; if the bit is not set, set it now                                   ; 
STA Enemy_CollisionBits,Y                                                                           ; 
YesEC:  JSR ProcEnemyCollisions; react according to the nature of collision                         ;  B
JMP ReadyNextEnemy            ; move onto next enemy slot                                           ; 
                                                                                                    ;  B
NoEnemyCollision:                                                                                   ;  B
LDA Enemy_CollisionBits,Y     ; load first enemy's collision-related bits                           ; 
AND ClearBitsMask,X           ; clear bit connected to second enemy                                 ; 
STA Enemy_CollisionBits,Y     ; then move onto next enemy slot                                      ; 
                                                                                                    ; 
ReadyNextEnemy:                                                                                     ;  B
PLA                           ; get first enemy's bounding box offset from the stack                ; 
TAY                           ; use as Y again                                                      ; 
LDX $01                       ; get and decrement second enemy's object buffer offset               ; 
DEX                                                                                                 ; 
BPL ECLoop                    ; loop until all enemy slots have been checked                        ; 
                                                                                                    ;  B
ExitECRoutine:                                                                                      ;  B
LDX ObjectOffset              ; get enemy object buffer offset                                      ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
ProcEnemyCollisions:                                                                                ; fun(Y$01):  B
LDA Enemy_State,Y             ; check both enemy states for d5 set                                  ; 
ORA Enemy_State,X                                                                                   ; 
AND #%00100000                ; if d5 is set in either state, or both, branch                       ; 
BNE ExitProcessEColl          ; to leave and do nothing else at this point                          ; 
LDA Enemy_State,X                                                                                   ;  B
CMP #$06                      ; if second enemy state < $06, branch elsewhere                       ; 
BCC ProcSecondEnemyColl                                                                             ; 
LDA Enemy_ID,X                ; check second enemy identifier for hammer bro                        ;  B
CMP #HammerBro                ; if hammer bro found in alt state, branch to leave                   ; 
BEQ ExitProcessEColl                                                                                ; 
LDA Enemy_State,Y             ; check first enemy state for d7 set                                  ;  B
ASL                                                                                                 ; 
BCC ShellCollisions           ; branch if d7 is clear                                               ; 
LDA #$06                                                                                            ;  B
JSR SetupFloateyNumber        ; award 1000 points for killing enemy                                 ; 
JSR ShellOrBlockDefeat        ; then kill enemy, then load                                          ; 
LDY $01                       ; original offset of second enemy                                     ; 
                                                                                                    ; 
ShellCollisions:                                                                                    ;  B
TYA                           ; move Y to X                                                         ; 
TAX                                                                                                 ; 
JSR ShellOrBlockDefeat        ; kill second enemy                                                   ; 
LDX ObjectOffset                                                                                    ; 
LDA ShellChainCounter,X       ; get chain counter for shell                                         ; 
CLC                                                                                                 ; 
ADC #$04                      ; add four to get appropriate point offset                            ; 
LDX $01                                                                                             ; 
JSR SetupFloateyNumber        ; award appropriate number of points for second enemy                 ; 
LDX ObjectOffset              ; load original offset of first enemy                                 ; 
INC ShellChainCounter,X       ; increment chain counter for additional enemies                      ; 
                                                                                                    ; 
ExitProcessEColl:                                                                                   ;  B
RTS                           ; leave!!!                                                            ; 
                                                                                                    ;  B
ProcSecondEnemyColl:                                                                                ;  B
LDA Enemy_State,Y             ; if first enemy state < $06, branch elsewhere                        ; 
CMP #$06                                                                                            ; 
BCC MoveEOfs                                                                                        ; 
LDA Enemy_ID,Y                ; check first enemy identifier for hammer bro                         ;  B
CMP #HammerBro                ; if hammer bro found in alt state, branch to leave                   ; 
BEQ ExitProcessEColl                                                                                ; 
JSR ShellOrBlockDefeat        ; otherwise, kill first enemy                                         ;  B
LDY $01                                                                                             ; 
LDA ShellChainCounter,Y       ; get chain counter for shell                                         ; 
CLC                                                                                                 ; 
ADC #$04                      ; add four to get appropriate point offset                            ; 
LDX ObjectOffset                                                                                    ; 
JSR SetupFloateyNumber        ; award appropriate number of points for first enemy                  ; 
LDX $01                       ; load original offset of second enemy                                ; 
INC ShellChainCounter,X       ; increment chain counter for additional enemies                      ; 
RTS                           ; leave!!!                                                            ; 
                                                                                                    ;  B
MoveEOfs:                                                                                           ;  B
TYA                           ; move Y ($01) to X                                                   ; 
TAX                                                                                                 ; 
JSR EnemyTurnAround           ; do the sub here using value from $01                                ; 
LDX ObjectOffset              ; then do it again using value from $08                               ; 
                                                                                                    ; 
EnemyTurnAround:                                                                                    ; fun():  B
LDA Enemy_ID,X                ; check for specific enemies                                          ; 
CMP #PiranhaPlant                                                                                   ; 
BEQ ExTA                      ; if piranha plant, leave                                             ; 
CMP #Lakitu                                                                                         ;  B
BEQ ExTA                      ; if lakitu, leave                                                    ; 
CMP #HammerBro                                                                                      ;  B
BEQ ExTA                      ; if hammer bro, leave                                                ; 
CMP #Spiny                                                                                          ;  B
BEQ RXSpd                     ; if spiny, turn it around                                            ; 
CMP #GreenParatroopaJump                                                                            ;  B
BEQ RXSpd                     ; if green paratroopa, turn it around                                 ; 
CMP #$07                                                                                            ;  B
BCS ExTA                      ; if any OTHER enemy object => $07, leave                             ; 
RXSpd:  LDA Enemy_X_Speed,X   ; load horizontal speed                                               ;  B
EOR #$ff                      ; get two's compliment for horizontal speed                           ; 
TAY                                                                                                 ; 
INY                                                                                                 ; 
STY Enemy_X_Speed,X           ; store as new horizontal speed                                       ; 
LDA Enemy_MovingDir,X                                                                               ; 
EOR #%00000011                ; invert moving direction and store, then leave                       ; 
STA Enemy_MovingDir,X         ; thus effectively turning the enemy around                           ; 
ExTA:  RTS                    ; leave!!!                                                            ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - vertical position of platform                                 ; 
                                                                                                    ; 
LargePlatformCollision:                                                                             ; fun():  B
LDA #$ff                      ; save value here                                                     ; 
STA PlatformCollisionFlag,X                                                                         ; 
LDA TimerControl              ; check master timer control                                          ; 
BNE ExLPC                     ; if set, branch to leave                                             ; 
LDA Enemy_State,X             ; if d7 set in object state,                                          ;  B
BMI ExLPC                     ; branch to leave                                                     ; 
LDA Enemy_ID,X                                                                                      ;  B
CMP #$24                      ; check enemy object identifier for                                   ; 
BNE ChkForPlayerC_LargeP      ; balance platform, branch if not found                               ; 
LDA Enemy_State,X                                                                                   ;  B
TAX                           ; set state as enemy offset here                                      ; 
JSR ChkForPlayerC_LargeP      ; perform code with state offset, then original offset, in X          ; 
                                                                                                    ; 
ChkForPlayerC_LargeP:                                                                               ; fun(CarryFlagX):  B
JSR CheckPlayerVertical       ; figure out if player is below a certain point                       ; 
BCS ExLPC                     ; or offscreen, branch to leave if true                               ; 
TXA                                                                                                 ;  B
JSR GetEnemyBoundBoxOfsArg    ; get bounding box offset in Y                                        ; 
LDA Enemy_Y_Position,X        ; store vertical coordinate in                                        ; 
STA $00                       ; temp variable for now                                               ; 
TXA                           ; send offset we're on to the stack                                   ; 
PHA                                                                                                 ; 
JSR PlayerCollisionCore       ; do player-to-platform collision detection                           ; 
PLA                           ; retrieve offset from the stack                                      ; 
TAX                                                                                                 ; 
BCC ExLPC                     ; if no collision, branch to leave                                    ; 
JSR ProcLPlatCollisions       ; otherwise collision, perform sub                                    ;  B
ExLPC:  LDX ObjectOffset      ; get enemy object buffer offset and leave                            ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - counter for bounding boxes                                    ; 
                                                                                                    ; 
SmallPlatformCollision:                                                                             ; fun(CarryFlag):  B
LDA TimerControl              ; if master timer control set,                                        ; 
BNE ExSPC                     ; branch to leave                                                     ; 
STA PlatformCollisionFlag,X   ; otherwise initialize collision flag                                 ;  B
JSR CheckPlayerVertical       ; do a sub to see if player is below a certain point                  ; 
BCS ExSPC                     ; or entirely offscreen, and branch to leave if true                  ; 
LDA #$02                                                                                            ;  B
STA $00                       ; load counter here for 2 bounding boxes                              ; 
                                                                                                    ; 
ChkSmallPlatLoop:                                                                                   ;  B
LDX ObjectOffset              ; get enemy object offset                                             ; 
JSR GetEnemyBoundBoxOfs       ; get bounding box offset in Y                                        ; 
AND #%00000010                ; if d1 of offscreen lower nybble bits was set                        ; 
BNE ExSPC                     ; then branch to leave                                                ; 
LDA BoundingBox_UL_YPos,Y     ; check top of platform's bounding box for being                      ;  B
CMP #$20                      ; above a specific point                                              ; 
BCC MoveBoundBox              ; if so, branch, don't do collision detection                         ; 
JSR PlayerCollisionCore       ; otherwise, perform player-to-platform collision detection           ;  B
BCS ProcSPlatCollisions       ; skip ahead if collision                                             ; 
                                                                                                    ;  B
MoveBoundBox:                                                                                       ;  B
LDA BoundingBox_UL_YPos,Y     ; move bounding box vertical coordinates                              ; 
CLC                           ; 128 pixels downwards                                                ; 
ADC #$80                                                                                            ; 
STA BoundingBox_UL_YPos,Y                                                                           ; 
LDA BoundingBox_DR_YPos,Y                                                                           ; 
CLC                                                                                                 ; 
ADC #$80                                                                                            ; 
STA BoundingBox_DR_YPos,Y                                                                           ; 
DEC $00                       ; decrement counter we set earlier                                    ; 
BNE ChkSmallPlatLoop          ; loop back until both bounding boxes are checked                     ; 
ExSPC:  LDX ObjectOffset      ; get enemy object buffer offset, then leave                          ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ProcSPlatCollisions:                                                                                ;  B
LDX ObjectOffset              ; return enemy object buffer offset to X, then continue               ; 
                                                                                                    ; 
ProcLPlatCollisions:                                                                                ; fun():  B
LDA BoundingBox_DR_YPos,Y     ; get difference by subtracting the top                               ; 
SEC                           ; of the player's bounding box from the bottom                        ; 
SBC BoundingBox_UL_YPos       ; of the platform's bounding box                                      ; 
CMP #$04                      ; if difference too large or negative,                                ; 
BCS ChkForTopCollision        ; branch, do not alter vertical speed of player                       ; 
LDA Player_Y_Speed            ; check to see if player's vertical speed is moving down              ;  B
BPL ChkForTopCollision        ; if so, don't mess with it                                           ; 
LDA #$01                      ; otherwise, set vertical                                             ;  B
STA Player_Y_Speed            ; speed of player to kill jump                                        ; 
                                                                                                    ; 
ChkForTopCollision:                                                                                 ;  B
LDA BoundingBox_DR_YPos       ; get difference by subtracting the top                               ; 
SEC                           ; of the platform's bounding box from the bottom                      ; 
SBC BoundingBox_UL_YPos,Y     ; of the player's bounding box                                        ; 
CMP #$06                                                                                            ; 
BCS PlatformSideCollisions    ; if difference not close enough, skip all of this                    ; 
LDA Player_Y_Speed                                                                                  ;  B
BMI PlatformSideCollisions    ; if player's vertical speed moving upwards, skip this                ; 
LDA $00                       ; get saved bounding box counter from earlier                         ;  B
LDY Enemy_ID,X                                                                                      ; 
CPY #$2b                      ; if either of the two small platform objects are found,              ; 
BEQ SetCollisionFlag          ; regardless of which one, branch to use bounding box counter         ; 
CPY #$2c                      ; as contents of collision flag                                       ;  B
BEQ SetCollisionFlag                                                                                ; 
TXA                           ; otherwise use enemy object buffer offset                            ;  B
                                                                                                    ; 
SetCollisionFlag:                                                                                   ;  B
LDX ObjectOffset              ; get enemy object buffer offset                                      ; 
STA PlatformCollisionFlag,X   ; save either bounding box counter or enemy offset here               ; 
LDA #$00                                                                                            ; 
STA Player_State              ; set player state to normal then leave                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
PlatformSideCollisions:                                                                             ;  B
LDA #$01                      ; set value here to indicate possible horizontal                      ; 
STA $00                       ; collision on left side of platform                                  ; 
LDA BoundingBox_DR_XPos       ; get difference by subtracting platform's left edge                  ; 
SEC                           ; from player's right edge                                            ; 
SBC BoundingBox_UL_XPos,Y                                                                           ; 
CMP #$08                      ; if difference close enough, skip all of this                        ; 
BCC SideC                                                                                           ; 
INC $00                       ; otherwise increment value set here for right side collision         ;  B
LDA BoundingBox_DR_XPos,Y     ; get difference by subtracting player's left edge                    ; 
CLC                           ; from platform's right edge                                          ; 
SBC BoundingBox_UL_XPos                                                                             ; 
CMP #$09                      ; if difference not close enough, skip subroutine                     ; 
BCS NoSideC                   ; and instead branch to leave (no collision)                          ; 
SideC:  JSR ImpedePlayerMove  ; deal with horizontal collision                                      ;  B
NoSideC:  LDX ObjectOffset    ; return with enemy object buffer offset                              ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
PlayerPosSPlatData:                                                                                 ;  B
DATA: ByteValue(value=128), ByteValue(value=0)                                                      ; 
                                                                                                    ; 
PositionPlayerOnS_Plat:                                                                             ; fun(A):  B
TAY                           ; use bounding box counter saved in collision flag                    ; 
LDA Enemy_Y_Position,X        ; for offset                                                          ; 
CLC                           ; add positioning data using offset to the vertical                   ; 
ADC PlayerPosSPlatData-1,Y    ; coordinate                                                          ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
PositionPlayerOnVPlat:                                                                              ; fun():  B
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
LDY GameEngineSubroutine                                                                            ; 
CPY #$0b                      ; if certain routine being executed on this frame,                    ; 
BEQ ExPlPos                   ; skip all of this                                                    ; 
LDY Enemy_Y_HighPos,X                                                                               ;  B
CPY #$01                      ; if vertical high byte offscreen, skip this                          ; 
BNE ExPlPos                                                                                         ; 
SEC                           ; subtract 32 pixels from vertical coordinate                         ;  B
SBC #$20                      ; for the player object's height                                      ; 
STA Player_Y_Position         ; save as player's new vertical coordinate                            ; 
TYA                                                                                                 ; 
SBC #$00                      ; subtract borrow and store as player's                               ; 
STA Player_Y_HighPos          ; new vertical high byte                                              ; 
LDA #$00                                                                                            ; 
STA Player_Y_Speed            ; initialize vertical speed and low byte of force                     ; 
STA Player_Y_MoveForce        ; and then leave                                                      ; 
ExPlPos:  RTS                                                                                       ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
CheckPlayerVertical:                                                                                ; fun(): CarryFlag B
LDA Player_OffscreenBits      ; if player object is completely offscreen                            ; 
CMP #$f0                      ; vertically, leave this routine                                      ; 
BCS ExCPV                                                                                           ; 
LDY Player_Y_HighPos          ; if player high vertical byte is not                                 ;  B
DEY                           ; within the screen, leave this routine                               ; 
BNE ExCPV                                                                                           ; 
LDA Player_Y_Position         ; if on the screen, check to see how far down                         ;  B
CMP #$d0                      ; the player is vertically                                            ; 
ExCPV:  RTS                                                                                         ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
GetEnemyBoundBoxOfs:                                                                                ; fun(): A B
LDA ObjectOffset              ; get enemy object buffer offset                                      ; 
                                                                                                    ; 
GetEnemyBoundBoxOfsArg:                                                                             ; fun(A): CarryFlag B
ASL                           ; multiply A by four, then add four                                   ; 
ASL                           ; to skip player's bounding box                                       ; 
CLC                                                                                                 ; 
ADC #$04                                                                                            ; 
TAY                           ; send to Y                                                           ; 
LDA Enemy_OffscreenBits       ; get offscreen bits for enemy object                                 ; 
AND #%00001111                ; save low nybble                                                     ; 
CMP #%00001111                ; check for all bits set                                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - used to hold many values, essentially temp variables      ; 
                              ; $04 - holds lower nybble of vertical coordinate from block buffer routine; 
                              ; $eb - used to hold block buffer adder                               ; 
                                                                                                    ; 
PlayerBGUpperExtent:                                                                                ;  B
DATA: ByteValue(value=32), ByteValue(value=16)                                                      ; 
                                                                                                    ; 
PlayerBGCollision:                                                                                  ; fun($04$06):  B
LDA DisableCollisionDet       ; if collision detection disabled flag set,                           ; 
BNE ExPBGCol                  ; branch to leave                                                     ; 
LDA GameEngineSubroutine                                                                            ;  B
CMP #$0b                      ; if running routine #11 or $0b                                       ; 
BEQ ExPBGCol                  ; branch to leave                                                     ; 
CMP #$04                                                                                            ;  B
BCC ExPBGCol                  ; if running routines $00-$03 branch to leave                         ; 
LDA #$01                      ; load default player state for swimming                              ;  B
LDY SwimmingFlag              ; if swimming flag set,                                               ; 
BNE SetPSte                   ; branch ahead to set default state                                   ; 
LDA Player_State              ; if player in normal state,                                          ;  B
BEQ SetFallS                  ; branch to set default state for falling                             ; 
CMP #$03                                                                                            ;  B
BNE ChkOnScr                  ; if in any other state besides climbing, skip to next part           ; 
SetFallS:  LDA #$02           ; load default player state for falling                               ;  B
SetPSte:  STA Player_State    ; set whatever player state is appropriate                            ;  B
ChkOnScr:  LDA Player_Y_HighPos                                                                     ;  B
CMP #$01                      ; check player's vertical high byte for still on the screen           ; 
BNE ExPBGCol                  ; branch to leave if not                                              ; 
LDA #$ff                                                                                            ;  B
STA Player_CollisionBits      ; initialize player's collision flag                                  ; 
LDA Player_Y_Position                                                                               ; 
CMP #$cf                      ; check player's vertical coordinate                                  ; 
BCC ChkCollSize               ; if not too close to the bottom of screen, continue                  ; 
ExPBGCol:  RTS                ; otherwise leave                                                     ;  B
                                                                                                    ;  B
ChkCollSize:                                                                                        ;  B
LDY #$02                      ; load default offset                                                 ; 
LDA CrouchingFlag                                                                                   ; 
BNE GBBAdr                    ; if player crouching, skip ahead                                     ; 
LDA PlayerSize                                                                                      ;  B
BNE GBBAdr                    ; if player small, skip ahead                                         ; 
DEY                           ; otherwise decrement offset for big player not crouching             ;  B
LDA SwimmingFlag                                                                                    ; 
BNE GBBAdr                    ; if swimming flag set, skip ahead                                    ; 
DEY                           ; otherwise decrement offset                                          ;  B
GBBAdr:  LDA BlockBufferAdderData,Y; get value using offset                                         ;  B
STA $eb                       ; store value here                                                    ; 
TAY                           ; put value into Y, as offset for block buffer routine                ; 
LDX PlayerSize                ; get player's size as offset                                         ; 
LDA CrouchingFlag                                                                                   ; 
BEQ HeadChk                   ; if player not crouching, branch ahead                               ; 
INX                           ; otherwise increment size as offset                                  ;  B
HeadChk:  LDA Player_Y_Position; get player's vertical coordinate                                   ;  B
CMP PlayerBGUpperExtent,X     ; compare with upper extent value based on offset                     ; 
BCC DoFootCheck               ; if player is too high, skip this part                               ; 
JSR BlockBufferColli_Head     ; do player-to-bg collision detection on top of                       ;  B
BEQ DoFootCheck               ; player, and branch if nothing above player's head                   ; 
JSR CheckForCoinMTiles        ; check to see if player touched coin with their head                 ;  B
BCS AwardTouchedCoin          ; if so, branch to some other part of code                            ; 
LDY Player_Y_Speed            ; check player's vertical speed                                       ;  B
BPL DoFootCheck               ; if player not moving upwards, branch elsewhere                      ; 
LDY $04                       ; check lower nybble of vertical coordinate returned                  ;  B
CPY #$04                      ; from collision detection routine                                    ; 
BCC DoFootCheck               ; if low nybble < 4, branch                                           ; 
JSR CheckForSolidMTiles       ; check to see what player's head bumped on                           ;  B
BCS SolidOrClimb              ; if player collided with solid metatile, branch                      ; 
LDY AreaType                  ; otherwise check area type                                           ;  B
BEQ NYSpd                     ; if water level, branch ahead                                        ; 
LDY BlockBounceTimer          ; if block bounce timer not expired,                                  ;  B
BNE NYSpd                     ; branch ahead, do not process collision                              ; 
JSR PlayerHeadCollision       ; otherwise do a sub to process collision                             ;  B
JMP DoFootCheck               ; jump ahead to skip these other parts here                           ; 
                                                                                                    ;  B
SolidOrClimb:                                                                                       ;  B
CMP #$26                      ; if climbing metatile,                                               ; 
BEQ NYSpd                     ; branch ahead and do not play sound                                  ; 
LDA #Sfx_Bump                                                                                       ;  B
STA Square1SoundQueue         ; otherwise load bump sound                                           ; 
NYSpd:  LDA #$01              ; set player's vertical speed to nullify                              ;  B
STA Player_Y_Speed            ; jump or swim                                                        ; 
                                                                                                    ; 
DoFootCheck:                                                                                        ;  B
LDY $eb                       ; get block buffer adder offset                                       ; 
LDA Player_Y_Position                                                                               ; 
CMP #$cf                      ; check to see how low player is                                      ; 
BCS DoPlayerSideCheck         ; if player is too far down on screen, skip all of this               ; 
JSR BlockBufferColli_Feet     ; do player-to-bg collision detection on bottom left of player        ;  B
JSR CheckForCoinMTiles        ; check to see if player touched coin with their left foot            ; 
BCS AwardTouchedCoin          ; if so, branch to some other part of code                            ; 
PHA                           ; save bottom left metatile to stack                                  ;  B
JSR BlockBufferColli_Feet     ; do player-to-bg collision detection on bottom right of player       ; 
STA $00                       ; save bottom right metatile here                                     ; 
PLA                                                                                                 ; 
STA $01                       ; pull bottom left metatile and save here                             ; 
BNE ChkFootMTile              ; if anything here, skip this part                                    ; 
LDA $00                       ; otherwise check for anything in bottom right metatile               ;  B
BEQ DoPlayerSideCheck         ; and skip ahead if not                                               ; 
JSR CheckForCoinMTiles        ; check to see if player touched coin with their right foot           ;  B
BCC ChkFootMTile              ; if not, skip unconditional jump and continue code                   ; 
                                                                                                    ;  B
AwardTouchedCoin:                                                                                   ;  B
JMP HandleCoinMetatile        ; follow the code to erase coin and award to player 1 coin            ; 
                                                                                                    ;  B
ChkFootMTile:                                                                                       ;  B
JSR CheckForClimbMTiles       ; check to see if player landed on climbable metatiles                ; 
BCS DoPlayerSideCheck         ; if so, branch                                                       ; 
LDY Player_Y_Speed            ; check player's vertical speed                                       ;  B
BMI DoPlayerSideCheck         ; if player moving upwards, branch                                    ; 
CMP #$c5                                                                                            ;  B
BNE ContChk                   ; if player did not touch axe, skip ahead                             ; 
JMP HandleAxeMetatile         ; otherwise jump to set modes of operation                            ;  B
ContChk:  JSR ChkInvisibleMTiles; do sub to check for hidden coin or 1-up blocks                    ;  B
BEQ DoPlayerSideCheck         ; if either found, branch                                             ; 
LDY JumpspringAnimCtrl        ; if jumpspring animating right now,                                  ;  B
BNE InitSteP                  ; branch ahead                                                        ; 
LDY $04                       ; check lower nybble of vertical coordinate returned                  ;  B
CPY #$05                      ; from collision detection routine                                    ; 
BCC LandPlyr                  ; if lower nybble < 5, branch                                         ; 
LDA Player_MovingDir                                                                                ;  B
STA $00                       ; use player's moving direction as temp variable                      ; 
JMP ImpedePlayerMove          ; jump to impede player's movement in that direction                  ; 
LandPlyr:  JSR ChkForLandJumpSpring; do sub to check for jumpspring metatiles and deal with it      ;  B
LDA #$f0                                                                                            ; 
AND Player_Y_Position         ; mask out lower nybble of player's vertical position                 ; 
STA Player_Y_Position         ; and store as new vertical position to land player properly          ; 
JSR HandlePipeEntry           ; do sub to process potential pipe entry                              ; 
LDA #$00                                                                                            ; 
STA Player_Y_Speed            ; initialize vertical speed and fractional                            ; 
STA Player_Y_MoveForce        ; movement force to stop player's vertical movement                   ; 
STA StompChainCounter         ; initialize enemy stomp counter                                      ; 
InitSteP:  LDA #$00                                                                                 ;  B
STA Player_State              ; set player's state to normal                                        ; 
                                                                                                    ; 
DoPlayerSideCheck:                                                                                  ;  B
LDY $eb                       ; get block buffer adder offset                                       ; 
INY                                                                                                 ; 
INY                           ; increment offset 2 bytes to use adders for side collisions          ; 
LDA #$02                      ; set value here to be used as counter                                ; 
STA $00                                                                                             ; 
                                                                                                    ; 
SideCheckLoop:                                                                                      ;  B
INY                           ; move onto the next one                                              ; 
STY $eb                       ; store it                                                            ; 
LDA Player_Y_Position                                                                               ; 
CMP #$20                      ; check player's vertical position                                    ; 
BCC BHalf                     ; if player is in status bar area, branch ahead to skip this part     ; 
CMP #$e4                                                                                            ;  B
BCS ExSCH                     ; branch to leave if player is too far down                           ; 
JSR BlockBufferColli_Side     ; do player-to-bg collision detection on one half of player           ;  B
BEQ BHalf                     ; branch ahead if nothing found                                       ; 
CMP #$1c                      ; otherwise check for pipe metatiles                                  ;  B
BEQ BHalf                     ; if collided with sideways pipe (top), branch ahead                  ; 
CMP #$6b                                                                                            ;  B
BEQ BHalf                     ; if collided with water pipe (top), branch ahead                     ; 
JSR CheckForClimbMTiles       ; do sub to see if player bumped into anything climbable              ;  B
BCC CheckSideMTiles           ; if not, branch to alternate section of code                         ; 
BHalf:  LDY $eb               ; load block adder offset                                             ;  B
INY                           ; increment it                                                        ; 
LDA Player_Y_Position         ; get player's vertical position                                      ; 
CMP #$08                                                                                            ; 
BCC ExSCH                     ; if too high, branch to leave                                        ; 
CMP #$d0                                                                                            ;  B
BCS ExSCH                     ; if too low, branch to leave                                         ; 
JSR BlockBufferColli_Side     ; do player-to-bg collision detection on other half of player         ;  B
BNE CheckSideMTiles           ; if something found, branch                                          ; 
DEC $00                       ; otherwise decrement counter                                         ;  B
BNE SideCheckLoop             ; run code until both sides of player are checked                     ; 
ExSCH:  RTS                   ; leave                                                               ;  B
                                                                                                    ;  B
CheckSideMTiles:                                                                                    ;  B
JSR ChkInvisibleMTiles        ; check for hidden or coin 1-up blocks                                ; 
BEQ ExCSM                     ; branch to leave if either found                                     ; 
JSR CheckForClimbMTiles       ; check for climbable metatiles                                       ;  B
BCC ContSChk                  ; if not found, skip and continue with code                           ; 
JMP HandleClimbing            ; otherwise jump to handle climbing                                   ;  B
ContSChk:  JSR CheckForCoinMTiles; check to see if player touched coin                              ;  B
BCS HandleCoinMetatile        ; if so, execute code to erase coin and award to player 1 coin        ; 
JSR ChkJumpspringMetatiles    ; check for jumpspring metatiles                                      ;  B
BCC ChkPBtm                   ; if not found, branch ahead to continue cude                         ; 
LDA JumpspringAnimCtrl        ; otherwise check jumpspring animation control                        ;  B
BNE ExCSM                     ; branch to leave if set                                              ; 
JMP StopPlayerMove            ; otherwise jump to impede player's movement                          ;  B
ChkPBtm:  LDY Player_State    ; get player's state                                                  ;  B
CPY #$00                      ; check for player's state set to normal                              ; 
BNE StopPlayerMove            ; if not, branch to impede player's movement                          ; 
LDY PlayerFacingDir           ; get player's facing direction                                       ;  B
DEY                                                                                                 ; 
BNE StopPlayerMove            ; if facing left, branch to impede movement                           ; 
CMP #$6c                      ; otherwise check for pipe metatiles                                  ;  B
BEQ PipeDwnS                  ; if collided with sideways pipe (bottom), branch                     ; 
CMP #$1f                      ; if collided with water pipe (bottom), continue                      ;  B
BNE StopPlayerMove            ; otherwise branch to impede player's movement                        ; 
PipeDwnS:  LDA Player_SprAttrib; check player's attributes                                          ;  B
BNE PlyrPipe                  ; if already set, branch, do not play sound again                     ; 
LDY #Sfx_PipeDown_Injury                                                                            ;  B
STY Square1SoundQueue         ; otherwise load pipedown/injury sound                                ; 
PlyrPipe:  ORA #%00100000                                                                           ;  B
STA Player_SprAttrib          ; set background priority bit in player attributes                    ; 
LDA Player_X_Position                                                                               ; 
AND #%00001111                ; get lower nybble of player's horizontal coordinate                  ; 
BEQ ChkGERtn                  ; if at zero, branch ahead to skip this part                          ; 
LDY #$00                      ; set default offset for timer setting data                           ;  B
LDA ScreenLeft_PageLoc        ; load page location for left side of screen                          ; 
BEQ SetCATmr                  ; if at page zero, use default offset                                 ; 
INY                           ; otherwise increment offset                                          ;  B
SetCATmr:  LDA AreaChangeTimerData,Y; set timer for change of area as appropriate                   ;  B
STA ChangeAreaTimer                                                                                 ; 
ChkGERtn:  LDA GameEngineSubroutine; get number of game engine routine running                      ;  B
CMP #$07                                                                                            ; 
BEQ ExCSM                     ; if running player entrance routine or                               ; 
CMP #$08                      ; player control routine, go ahead and branch to leave                ;  B
BNE ExCSM                                                                                           ; 
LDA #$02                                                                                            ;  B
STA GameEngineSubroutine      ; otherwise set sideways pipe entry routine to run                    ; 
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $02 - high nybble of vertical coordinate from block buffer          ; 
                              ; $04 - low nybble of horizontal coordinate from block buffer         ; 
                              ; $06-$07 - block buffer address                                      ; 
                                                                                                    ; 
StopPlayerMove:                                                                                     ;  B
JSR ImpedePlayerMove          ; stop player's movement                                              ; 
ExCSM:  RTS                   ; leave                                                               ;  B
                                                                                                    ;  B
AreaChangeTimerData:                                                                                ;  B
DATA: ByteValue(value=160), ByteValue(value=52)                                                     ; 
                                                                                                    ; 
HandleCoinMetatile:                                                                                 ;  B
JSR ErACM                     ; do sub to erase coin metatile from block buffer                     ; 
INC CoinTallyFor1Ups          ; increment coin tally used for 1-up blocks                           ; 
JMP GiveOneCoin               ; update coin amount and tally on the screen                          ; 
                                                                                                    ;  B
HandleAxeMetatile:                                                                                  ;  B
LDA #$00                                                                                            ; 
STA OperMode_Task             ; reset secondary mode                                                ; 
LDA #$02                                                                                            ; 
STA OperMode                  ; set primary mode to autoctrl mode                                   ; 
LDA #$18                                                                                            ; 
STA Player_X_Speed            ; set horizontal speed and continue to erase axe metatile             ; 
ErACM:  LDY $02               ; load vertical high nybble offset for block buffer                   ; fun($02):  B
LDA #$00                      ; load blank metatile                                                 ; 
STA ($06),Y                   ; store to remove old contents from block buffer                      ; 
JMP RemoveCoin_Axe            ; update the screen accordingly                                       ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $02 - high nybble of vertical coordinate from block buffer          ; 
                              ; $04 - low nybble of horizontal coordinate from block buffer         ; 
                              ; $06-$07 - block buffer address                                      ; 
                                                                                                    ; 
ClimbXPosAdder:                                                                                     ;  B
DATA: ByteValue(value=249), ByteValue(value=7)                                                      ; 
                                                                                                    ; 
ClimbPLocAdder:                                                                                     ;  B
DATA: ByteValue(value=255), ByteValue(value=0)                                                      ; 
                                                                                                    ; 
FlagpoleYPosData:                                                                                   ;  B
DATA: ByteValue(value=24), ByteValue(value=34), ByteValue(value=80), ByteValue(value=104), ByteValue(value=144); 
                                                                                                    ; 
HandleClimbing:                                                                                     ;  B
LDY $04                       ; check low nybble of horizontal coordinate returned from             ; 
CPY #$06                      ; collision detection routine against certain values, this            ; 
BCC ExHC                      ; makes actual physical part of vine or flagpole thinner              ; 
CPY #$0a                      ; than 16 pixels                                                      ;  B
BCC ChkForFlagpole                                                                                  ; 
ExHC:  RTS                    ; leave if too far left or too far right                              ;  B
                                                                                                    ;  B
ChkForFlagpole:                                                                                     ;  B
CMP #$24                      ; check climbing metatiles                                            ; 
BEQ FlagpoleCollision         ; branch if flagpole ball found                                       ; 
CMP #$25                                                                                            ;  B
BNE VineCollision             ; branch to alternate code if flagpole shaft not found                ; 
                                                                                                    ;  B
FlagpoleCollision:                                                                                  ;  B
LDA GameEngineSubroutine                                                                            ; 
CMP #$05                      ; check for end-of-level routine running                              ; 
BEQ PutPlayerOnVine           ; if running, branch to end of climbing code                          ; 
LDA #$01                                                                                            ;  B
STA PlayerFacingDir           ; set player's facing direction to right                              ; 
INC ScrollLock                ; set scroll lock flag                                                ; 
LDA GameEngineSubroutine                                                                            ; 
CMP #$04                      ; check for flagpole slide routine running                            ; 
BEQ RunFR                     ; if running, branch to end of flagpole code here                     ; 
LDA #BulletBill_CannonVar     ; load identifier for bullet bills (cannon variant)                   ;  B
JSR KillEnemies               ; get rid of them                                                     ; 
LDA #Silence                                                                                        ; 
STA EventMusicQueue           ; silence music                                                       ; 
LSR                                                                                                 ; 
STA FlagpoleSoundQueue        ; load flagpole sound into flagpole sound queue                       ; 
LDX #$04                      ; start at end of vertical coordinate data                            ; 
LDA Player_Y_Position                                                                               ; 
STA FlagpoleCollisionYPos     ; store player's vertical coordinate here to be used later            ; 
                                                                                                    ; 
ChkFlagpoleYPosLoop:                                                                                ;  B
CMP FlagpoleYPosData,X        ; compare with current vertical coordinate data                       ; 
BCS MtchF                     ; if player's => current, branch to use current offset                ; 
DEX                           ; otherwise decrement offset to use                                   ;  B
BNE ChkFlagpoleYPosLoop       ; do this until all data is checked (use last one if all checked)     ; 
MtchF:  STX FlagpoleScore     ; store offset here to be used later                                  ;  B
RunFR:  LDA #$04                                                                                    ;  B
STA GameEngineSubroutine      ; set value to run flagpole slide routine                             ; 
JMP PutPlayerOnVine           ; jump to end of climbing code                                        ; 
                                                                                                    ;  B
VineCollision:                                                                                      ;  B
CMP #$26                      ; check for climbing metatile used on vines                           ; 
BNE PutPlayerOnVine                                                                                 ; 
LDA Player_Y_Position         ; check player's vertical coordinate                                  ;  B
CMP #$20                      ; for being in status bar area                                        ; 
BCS PutPlayerOnVine           ; branch if not that far up                                           ; 
LDA #$01                                                                                            ;  B
STA GameEngineSubroutine      ; otherwise set to run autoclimb routine next frame                   ; 
                                                                                                    ; 
PutPlayerOnVine:                                                                                    ;  B
LDA #$03                      ; set player state to climbing                                        ; 
STA Player_State                                                                                    ; 
LDA #$00                      ; nullify player's horizontal speed                                   ; 
STA Player_X_Speed            ; and fractional horizontal movement force                            ; 
STA Player_X_MoveForce                                                                              ; 
LDA Player_X_Position         ; get player's horizontal coordinate                                  ; 
SEC                                                                                                 ; 
SBC ScreenLeft_X_Pos          ; subtract from left side horizontal coordinate                       ; 
CMP #$10                                                                                            ; 
BCS SetVXPl                   ; if 16 or more pixels difference, do not alter facing direction      ; 
LDA #$02                                                                                            ;  B
STA PlayerFacingDir           ; otherwise force player to face left                                 ; 
SetVXPl:  LDY PlayerFacingDir ; get current facing direction, use as offset                         ;  B
LDA $06                       ; get low byte of block buffer address                                ; 
ASL                                                                                                 ; 
ASL                           ; move low nybble to high                                             ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
CLC                                                                                                 ; 
ADC ClimbXPosAdder-1,Y        ; add pixels depending on facing direction                            ; 
STA Player_X_Position         ; store as player's horizontal coordinate                             ; 
LDA $06                       ; get low byte of block buffer address again                          ; 
BNE ExPVne                    ; if not zero, branch                                                 ; 
LDA ScreenRight_PageLoc       ; load page location of right side of screen                          ;  B
CLC                                                                                                 ; 
ADC ClimbPLocAdder-1,Y        ; add depending on facing location                                    ; 
STA Player_PageLoc            ; store as player's page location                                     ; 
ExPVne:  RTS                  ; finally, we're done!                                                ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ChkInvisibleMTiles:                                                                                 ; fun(A): ZeroFlag B
CMP #$5f                      ; check for hidden coin block                                         ; 
BEQ ExCInvT                   ; branch to leave if found                                            ; 
CMP #$60                      ; check for hidden 1-up block                                         ;  B
ExCInvT:  RTS                 ; leave with zero flag set if either found                            ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00-$01 - used to hold bottom right and bottom left metatiles (in that order); 
                              ; $00 - used as flag by ImpedePlayerMove to restrict specific movement; 
                                                                                                    ; 
ChkForLandJumpSpring:                                                                               ; fun(CarryFlag):  B
JSR ChkJumpspringMetatiles    ; do sub to check if player landed on jumpspring                      ; 
BCC ExCJSp                    ; if carry not set, jumpspring not found, therefore leave             ; 
LDA #$70                                                                                            ;  B
STA VerticalForce             ; otherwise set vertical movement force for player                    ; 
LDA #$f9                                                                                            ; 
STA JumpspringForce           ; set default jumpspring force                                        ; 
LDA #$03                                                                                            ; 
STA JumpspringTimer           ; set jumpspring timer to be used later                               ; 
LSR                                                                                                 ; 
STA JumpspringAnimCtrl        ; set jumpspring animation control to start animating                 ; 
ExCJSp:  RTS                  ; and leave                                                           ;  B
                                                                                                    ;  B
ChkJumpspringMetatiles:                                                                             ; fun(A): CarryFlag B
CMP #$67                      ; check for top jumpspring metatile                                   ; 
BEQ JSFnd                     ; branch to set carry if found                                        ; 
CMP #$68                      ; check for bottom jumpspring metatile                                ;  B
CLC                           ; clear carry flag                                                    ; 
BNE NoJSFnd                   ; branch to use cleared carry if not found                            ; 
JSFnd:  SEC                   ; set carry if found                                                  ;  B
NoJSFnd:  RTS                 ; leave                                                               ;  B
                                                                                                    ;  B
HandlePipeEntry:                                                                                    ; fun($00$01):  B
LDA Up_Down_Buttons           ; check saved controller bits from earlier                            ; 
AND #%00000100                ; for pressing down                                                   ; 
BEQ ExPipeE                   ; if not pressing down, branch to leave                               ; 
LDA $00                                                                                             ;  B
CMP #$11                      ; check right foot metatile for warp pipe right metatile              ; 
BNE ExPipeE                   ; branch to leave if not found                                        ; 
LDA $01                                                                                             ;  B
CMP #$10                      ; check left foot metatile for warp pipe left metatile                ; 
BNE ExPipeE                   ; branch to leave if not found                                        ; 
LDA #$30                                                                                            ;  B
STA ChangeAreaTimer           ; set timer for change of area                                        ; 
LDA #$03                                                                                            ; 
STA GameEngineSubroutine      ; set to run vertical pipe entry routine on next frame                ; 
LDA #Sfx_PipeDown_Injury                                                                            ; 
STA Square1SoundQueue         ; load pipedown/injury sound                                          ; 
LDA #%00100000                                                                                      ; 
STA Player_SprAttrib          ; set background priority bit in player's attributes                  ; 
LDA WarpZoneControl           ; check warp zone control                                             ; 
BEQ ExPipeE                   ; branch to leave if none found                                       ; 
AND #%00000011                ; mask out all but 2 LSB                                              ;  B
ASL                                                                                                 ; 
ASL                           ; multiply by four                                                    ; 
TAX                           ; save as offset to warp zone numbers (starts at left pipe)           ; 
LDA Player_X_Position         ; get player's horizontal position                                    ; 
CMP #$60                                                                                            ; 
BCC GetWNum                   ; if player at left, not near middle, use offset and skip ahead       ; 
INX                           ; otherwise increment for middle pipe                                 ;  B
CMP #$a0                                                                                            ; 
BCC GetWNum                   ; if player at middle, but not too far right, use offset and skip     ; 
INX                           ; otherwise increment for last pipe                                   ;  B
GetWNum:  LDY WarpZoneNumbers,X; get warp zone numbers                                              ;  B
DEY                           ; decrement for use as world number                                   ; 
STY WorldNumber               ; store as world number and offset                                    ; 
LDX WorldAddrOffsets,Y        ; get offset to where this world's area offsets are                   ; 
LDA AreaAddrOffsets,X         ; get area offset based on world offset                               ; 
STA AreaPointer               ; store area offset here to be used to change areas                   ; 
LDA #Silence                                                                                        ; 
STA EventMusicQueue           ; silence music                                                       ; 
LDA #$00                                                                                            ; 
STA EntrancePage              ; initialize starting page number                                     ; 
STA AreaNumber                ; initialize area number used for area address offset                 ; 
STA LevelNumber               ; initialize level number used for world display                      ; 
STA AltEntranceControl        ; initialize mode of entry                                            ; 
INC Hidden1UpFlag             ; set flag for hidden 1-up blocks                                     ; 
INC FetchNewGameTimerFlag     ; set flag to load new game timer                                     ; 
ExPipeE:  RTS                 ; leave!!!                                                            ;  B
                                                                                                    ;  B
ImpedePlayerMove:                                                                                   ; fun($00):  B
LDA #$00                      ; initialize value here                                               ; 
LDY Player_X_Speed            ; get player's horizontal speed                                       ; 
LDX $00                       ; check value set earlier for                                         ; 
DEX                           ; left side collision                                                 ; 
BNE RImpd                     ; if right side collision, skip this part                             ; 
INX                           ; return value to X                                                   ;  B
CPY #$00                      ; if player moving to the left,                                       ; 
BMI ExIPM                     ; branch to invert bit and leave                                      ; 
LDA #$ff                      ; otherwise load A with value to be used later                        ;  B
JMP NXSpd                     ; and jump to affect movement                                         ; 
RImpd:  LDX #$02              ; return $02 to X                                                     ;  B
CPY #$01                      ; if player moving to the right,                                      ; 
BPL ExIPM                     ; branch to invert bit and leave                                      ; 
LDA #$01                      ; otherwise load A with value to be used here                         ;  B
NXSpd:  LDY #$10                                                                                    ;  B
STY SideCollisionTimer        ; set timer of some sort                                              ; 
LDY #$00                                                                                            ; 
STY Player_X_Speed            ; nullify player's horizontal speed                                   ; 
CMP #$00                      ; if value set in A not set to $ff,                                   ; 
BPL PlatF                     ; branch ahead, do not decrement Y                                    ; 
DEY                           ; otherwise decrement Y now                                           ;  B
PlatF:  STY $00               ; store Y as high bits of horizontal adder                            ;  B
CLC                                                                                                 ; 
ADC Player_X_Position         ; add contents of A to player's horizontal                            ; 
STA Player_X_Position         ; position to move player left or right                               ; 
LDA Player_PageLoc                                                                                  ; 
ADC $00                       ; add high bits and carry to                                          ; 
STA Player_PageLoc            ; page location if necessary                                          ; 
ExIPM:  TXA                   ; invert contents of X                                                ;  B
EOR #$ff                                                                                            ; 
AND Player_CollisionBits      ; mask out bit that was set here                                      ; 
STA Player_CollisionBits      ; store to clear bit                                                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
SolidMTileUpperExt:                                                                                 ;  B
DATA: ByteValue(value=16), ByteValue(value=97), ByteValue(value=136), ByteValue(value=196)          ; 
                                                                                                    ; 
CheckForSolidMTiles:                                                                                ; fun(A): CarryFlag B
JSR GetMTileAttrib            ; find appropriate offset based on metatile's 2 MSB                   ; 
CMP SolidMTileUpperExt,X      ; compare current metatile with solid metatiles                       ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ClimbMTileUpperExt:                                                                                 ;  B
DATA: ByteValue(value=36), ByteValue(value=109), ByteValue(value=138), ByteValue(value=198)         ; 
                                                                                                    ; 
CheckForClimbMTiles:                                                                                ; fun(A): CarryFlag B
JSR GetMTileAttrib            ; find appropriate offset based on metatile's 2 MSB                   ; 
CMP ClimbMTileUpperExt,X      ; compare current metatile with climbable metatiles                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
CheckForCoinMTiles:                                                                                 ; fun(A): CarryFlag B
CMP #$c2                      ; check for regular coin                                              ; 
BEQ CoinSd                    ; branch if found                                                     ; 
CMP #$c3                      ; check for underwater coin                                           ;  B
BEQ CoinSd                    ; branch if found                                                     ; 
CLC                           ; otherwise clear carry and leave                                     ;  B
RTS                                                                                                 ; 
CoinSd:  LDA #Sfx_CoinGrab                                                                          ;  B
STA Square2SoundQueue         ; load coin grab sound and leave                                      ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
GetMTileAttrib:                                                                                     ; fun(A): A B
TAY                           ; save metatile value into Y                                          ; 
AND #%11000000                ; mask out all but 2 MSB                                              ; 
ASL                                                                                                 ; 
ROL                           ; shift and rotate d7-d6 to d1-d0                                     ; 
ROL                                                                                                 ; 
TAX                           ; use as offset for metatile data                                     ; 
TYA                           ; get original metatile value back                                    ; 
ExEBG:  RTS                   ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $06-$07 - address from block buffer routine                         ; 
                                                                                                    ; 
EnemyBGCStateData:                                                                                  ;  B
DATA: ByteValue(value=1), ByteValue(value=1), ByteValue(value=2), ByteValue(value=2), ByteValue(value=2), ByteValue(value=5); 
                                                                                                    ; 
EnemyBGCXSpdData:                                                                                   ;  B
DATA: ByteValue(value=16), ByteValue(value=240)                                                     ; 
                                                                                                    ; 
EnemyToBGCollisionDet:                                                                              ; fun(CarryFlag$02$04):  B
LDA Enemy_State,X             ; check enemy state for d6 set                                        ; 
AND #%00100000                                                                                      ; 
BNE ExEBG                     ; if set, branch to leave                                             ; 
JSR SubtEnemyYPos             ; otherwise, do a subroutine here                                     ;  B
BCC ExEBG                     ; if enemy vertical coord + 62 < 68, branch to leave                  ; 
LDY Enemy_ID,X                                                                                      ;  B
CPY #Spiny                    ; if enemy object is not spiny, branch elsewhere                      ; 
BNE DoIDCheckBGColl                                                                                 ; 
LDA Enemy_Y_Position,X                                                                              ;  B
CMP #$25                      ; if enemy vertical coordinate < 36 branch to leave                   ; 
BCC ExEBG                                                                                           ; 
                                                                                                    ;  B
DoIDCheckBGColl:                                                                                    ;  B
CPY #GreenParatroopaJump      ; check for some other enemy object                                   ; 
BNE HBChk                     ; branch if not found                                                 ; 
JMP EnemyJump                 ; otherwise jump elsewhere                                            ;  B
HBChk:  CPY #HammerBro        ; check for hammer bro                                                ;  B
BNE CInvu                     ; branch if not found                                                 ; 
JMP HammerBroBGColl           ; otherwise jump elsewhere                                            ;  B
CInvu:  CPY #Spiny            ; if enemy object is spiny, branch                                    ;  B
BEQ YesIn                                                                                           ; 
CPY #PowerUpObject            ; if special power-up object, branch                                  ;  B
BEQ YesIn                                                                                           ; 
CPY #$07                      ; if enemy object =>$07, branch to leave                              ;  B
BCS ExEBGChk                                                                                        ; 
YesIn:  JSR ChkUnderEnemy     ; if enemy object < $07, or = $12 or $2e, do this sub                 ;  B
BNE HandleEToBGCollision      ; if block underneath enemy, branch                                   ; 
                                                                                                    ;  B
NoEToBGCollision:                                                                                   ;  B
JMP ChkForRedKoopa            ; otherwise skip and do something else                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $02 - vertical coordinate from block buffer routine                 ; 
                                                                                                    ; 
HandleEToBGCollision:                                                                               ;  B
JSR ChkForNonSolids           ; if something is underneath enemy, find out what                     ; 
BEQ NoEToBGCollision          ; if blank $26, coins, or hidden blocks, jump, enemy falls through    ; 
CMP #$23                                                                                            ;  B
BNE LandEnemyProperly         ; check for blank metatile $23 and branch if not found                ; 
LDY $02                       ; get vertical coordinate used to find block                          ;  B
LDA #$00                      ; store default blank metatile in that spot so we won't               ; 
STA ($06),Y                   ; trigger this routine accidentally again                             ; 
LDA Enemy_ID,X                                                                                      ; 
CMP #$15                      ; if enemy object => $15, branch ahead                                ; 
BCS ChkToStunEnemies                                                                                ; 
CMP #Goomba                   ; if enemy object not goomba, branch ahead of this routine            ;  B
BNE GiveOEPoints                                                                                    ; 
JSR KillEnemyAboveBlock       ; if enemy object IS goomba, do this sub                              ;  B
                                                                                                    ; 
GiveOEPoints:                                                                                       ;  B
LDA #$01                      ; award 100 points for hitting block beneath enemy                    ; 
JSR SetupFloateyNumber                                                                              ; 
                                                                                                    ; 
ChkToStunEnemies:                                                                                   ; fun(A):  B
CMP #$09                      ; perform many comparisons on enemy object identifier                 ; 
BCC SetStun                                                                                         ; 
CMP #$11                      ; if the enemy object identifier is equal to the values               ;  B
BCS SetStun                   ; $09, $0e, $0f or $10, it will be modified, and not                  ; 
CMP #$0a                      ; modified if not any of those values, note that piranha plant will   ;  B
BCC Demote                    ; always fail this test because A will still have vertical            ; 
CMP #PiranhaPlant             ; coordinate from previous addition, also these comparisons           ;  B
BCC SetStun                   ; are only necessary if branching from $d7a1                          ; 
Demote:  AND #%00000001       ; erase all but LSB, essentially turning enemy object                 ;  B
STA Enemy_ID,X                ; into green or red koopa troopa to demote them                       ; 
SetStun:  LDA Enemy_State,X   ; load enemy state                                                    ; fun():  B
AND #%11110000                ; save high nybble                                                    ; 
ORA #%00000010                                                                                      ; 
STA Enemy_State,X             ; set d1 of enemy state                                               ; 
DEC Enemy_Y_Position,X                                                                              ; 
DEC Enemy_Y_Position,X        ; subtract two pixels from enemy's vertical position                  ; 
LDA Enemy_ID,X                                                                                      ; 
CMP #Bloober                  ; check for bloober object                                            ; 
BEQ SetWYSpd                                                                                        ; 
LDA #$fd                      ; set default vertical speed                                          ;  B
LDY AreaType                                                                                        ; 
BNE SetNotW                   ; if area type not water, set as speed, otherwise                     ; 
SetWYSpd:  LDA #$ff           ; change the vertical speed                                           ;  B
SetNotW:  STA Enemy_Y_Speed,X ; set vertical speed now                                              ;  B
LDY #$01                                                                                            ; 
JSR PlayerEnemyDiff           ; get horizontal difference between player and enemy object           ; 
BPL ChkBBill                  ; branch if enemy is to the right of player                           ; 
INY                           ; increment Y if not                                                  ;  B
ChkBBill:  LDA Enemy_ID,X                                                                           ;  B
CMP #BulletBill_CannonVar     ; check for bullet bill (cannon variant)                              ; 
BEQ NoCDirF                                                                                         ; 
CMP #BulletBill_FrenzyVar     ; check for bullet bill (frenzy variant)                              ;  B
BEQ NoCDirF                   ; branch if either found, direction does not change                   ; 
STY Enemy_MovingDir,X         ; store as moving direction                                           ;  B
NoCDirF:  DEY                 ; decrement and use as offset                                         ;  B
LDA EnemyBGCXSpdData,Y        ; get proper horizontal speed                                         ; 
STA Enemy_X_Speed,X           ; and store, then leave                                               ; 
ExEBGChk:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $04 - low nybble of vertical coordinate from block buffer routine   ; 
                                                                                                    ; 
LandEnemyProperly:                                                                                  ;  B
LDA $04                       ; check lower nybble of vertical coordinate saved earlier             ; 
SEC                                                                                                 ; 
SBC #$08                      ; subtract eight pixels                                               ; 
CMP #$05                      ; used to determine whether enemy landed from falling                 ; 
BCS ChkForRedKoopa            ; branch if lower nybble in range of $0d-$0f before subtract          ; 
LDA Enemy_State,X                                                                                   ;  B
AND #%01000000                ; branch if d6 in enemy state is set                                  ; 
BNE LandEnemyInitState                                                                              ; 
LDA Enemy_State,X                                                                                   ;  B
ASL                           ; branch if d7 in enemy state is not set                              ; 
BCC ChkLandedEnemyState                                                                             ; 
SChkA:  JMP DoEnemySideCheck  ; if lower nybble < $0d, d7 set but d6 not set, jump here             ;  B
                                                                                                    ;  B
ChkLandedEnemyState:                                                                                ;  B
LDA Enemy_State,X             ; if enemy in normal state, branch back to jump here                  ; 
BEQ SChkA                                                                                           ; 
CMP #$05                      ; if in state used by spiny's egg                                     ;  B
BEQ ProcEnemyDirection        ; then branch elsewhere                                               ; 
CMP #$03                      ; if already in state used by koopas and buzzy beetles                ;  B
BCS ExSteChk                  ; or in higher numbered state, branch to leave                        ; 
LDA Enemy_State,X             ; load enemy state again (why?)                                       ;  B
CMP #$02                      ; if not in $02 state (used by koopas and buzzy beetles)              ; 
BNE ProcEnemyDirection        ; then branch elsewhere                                               ; 
LDA #$10                      ; load default timer here                                             ;  B
LDY Enemy_ID,X                ; check enemy identifier for spiny                                    ; 
CPY #Spiny                                                                                          ; 
BNE SetForStn                 ; branch if not found                                                 ; 
LDA #$00                      ; set timer for $00 if spiny                                          ;  B
SetForStn:  STA EnemyIntervalTimer,X; set timer here                                                ;  B
LDA #$03                      ; set state here, apparently used to render                           ; 
STA Enemy_State,X             ; upside-down koopas and buzzy beetles                                ; 
JSR EnemyLanding              ; then land it properly                                               ; 
ExSteChk:  RTS                ; then leave                                                          ;  B
                                                                                                    ;  B
ProcEnemyDirection:                                                                                 ;  B
LDA Enemy_ID,X                ; check enemy identifier for goomba                                   ; 
CMP #Goomba                   ; branch if found                                                     ; 
BEQ LandEnemyInitState                                                                              ; 
CMP #Spiny                    ; check for spiny                                                     ;  B
BNE InvtD                     ; branch if not found                                                 ; 
LDA #$01                                                                                            ;  B
STA Enemy_MovingDir,X         ; send enemy moving to the right by default                           ; 
LDA #$08                                                                                            ; 
STA Enemy_X_Speed,X           ; set horizontal speed accordingly                                    ; 
LDA FrameCounter                                                                                    ; 
AND #%00000111                ; if timed appropriately, spiny will skip over                        ; 
BEQ LandEnemyInitState        ; trying to face the player                                           ; 
InvtD:  LDY #$01              ; load 1 for enemy to face the left (inverted here)                   ;  B
JSR PlayerEnemyDiff           ; get horizontal difference between player and enemy                  ; 
BPL CNwCDir                   ; if enemy to the right of player, branch                             ; 
INY                           ; if to the left, increment by one for enemy to face right (inverted) ;  B
CNwCDir:  TYA                                                                                       ;  B
CMP Enemy_MovingDir,X         ; compare direction in A with current direction in memory             ; 
BNE LandEnemyInitState                                                                              ; 
JSR ChkForBump_HammerBroJ     ; if equal, not facing in correct dir, do sub to turn around          ;  B
                                                                                                    ; 
LandEnemyInitState:                                                                                 ;  B
JSR EnemyLanding              ; land enemy properly                                                 ; 
LDA Enemy_State,X                                                                                   ; 
AND #%10000000                ; if d7 of enemy state is set, branch                                 ; 
BNE NMovShellFallBit                                                                                ; 
LDA #$00                      ; otherwise initialize enemy state and leave                          ;  B
STA Enemy_State,X             ; note this will also turn spiny's egg into spiny                     ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
NMovShellFallBit:                                                                                   ;  B
LDA Enemy_State,X             ; nullify d6 of enemy state, save other bits                          ; 
AND #%10111111                ; and store, then leave                                               ; 
STA Enemy_State,X                                                                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ChkForRedKoopa:                                                                                     ;  B
LDA Enemy_ID,X                ; check for red koopa troopa $03                                      ; 
CMP #RedKoopa                                                                                       ; 
BNE Chk2MSBSt                 ; branch if not found                                                 ; 
LDA Enemy_State,X                                                                                   ;  B
BEQ ChkForBump_HammerBroJ     ; if enemy found and in normal state, branch                          ; 
Chk2MSBSt:  LDA Enemy_State,X ; save enemy state into Y                                             ;  B
TAY                                                                                                 ; 
ASL                           ; check for d7 set                                                    ; 
BCC GetSteFromD               ; branch if not set                                                   ; 
LDA Enemy_State,X                                                                                   ;  B
ORA #%01000000                ; set d6                                                              ; 
JMP SetD6Ste                  ; jump ahead of this part                                             ; 
GetSteFromD:  LDA EnemyBGCStateData,Y; load new enemy state with old as offset                      ;  B
SetD6Ste:  STA Enemy_State,X  ; set as new state                                                    ;  B
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                              ; $00 - used to store bitmask (not used but initialized here)         ; 
                              ; $eb - used in DoEnemySideCheck as counter and to compare moving directions; 
                                                                                                    ; 
DoEnemySideCheck:                                                                                   ;  B
LDA Enemy_Y_Position,X        ; if enemy within status bar, branch to leave                         ; 
CMP #$20                      ; because there's nothing there that impedes movement                 ; 
BCC ExESdeC                                                                                         ; 
LDY #$16                      ; start by finding block to the left of enemy ($00,$14)               ;  B
LDA #$02                      ; set value here in what is also used as                              ; 
STA $eb                       ; OAM data offset                                                     ; 
SdeCLoop:  LDA $eb            ; check value                                                         ;  B
CMP Enemy_MovingDir,X         ; compare value against moving direction                              ; 
BNE NextSdeC                  ; branch if different and do not seek block there                     ; 
LDA #$01                      ; set flag in A for save horizontal coordinate                        ;  B
JSR BlockBufferChk_Enemy      ; find block to left or right of enemy object                         ; 
BEQ NextSdeC                  ; if nothing found, branch                                            ; 
JSR ChkForNonSolids           ; check for non-solid blocks                                          ;  B
BNE ChkForBump_HammerBroJ     ; branch if not found                                                 ; 
NextSdeC:  DEC $eb            ; move to the next direction                                          ;  B
INY                                                                                                 ; 
CPY #$18                      ; increment Y, loop only if Y < $18, thus we check                    ; 
BCC SdeCLoop                  ; enemy ($00, $14) and ($10, $14) pixel coordinates                   ; 
ExESdeC:  RTS                                                                                       ;  B
                                                                                                    ;  B
ChkForBump_HammerBroJ:                                                                              ; fun(X):  B
CPX #$05                      ; check if we're on the special use slot                              ; 
BEQ NoBump                    ; and if so, branch ahead and do not play sound                       ; 
LDA Enemy_State,X             ; if enemy state d7 not set, branch                                   ;  B
ASL                           ; ahead and do not play sound                                         ; 
BCC NoBump                                                                                          ; 
LDA #Sfx_Bump                 ; otherwise, play bump sound                                          ;  B
STA Square1SoundQueue         ; sound will never be played if branching from ChkForRedKoopa         ; 
NoBump:  LDA Enemy_ID,X       ; check for hammer bro                                                ;  B
CMP #$05                                                                                            ; 
BNE InvEnemyDir               ; branch if not found                                                 ; 
LDA #$00                                                                                            ;  B
STA $00                       ; initialize value here for bitmask                                   ; 
LDY #$fa                      ; load default vertical speed for jumping                             ; 
JMP SetHJ                     ; jump to code that makes hammer bro jump                             ; 
                                                                                                    ;  B
InvEnemyDir:                                                                                        ;  B
JMP RXSpd                     ; jump to turn the enemy around                                       ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; $00 - used to hold horizontal difference between player and enemy   ; 
                                                                                                    ; 
PlayerEnemyDiff:                                                                                    ; fun(): NegativeFlag B
LDA Enemy_X_Position,X        ; get distance between enemy object's                                 ; 
SEC                           ; horizontal coordinate and the player's                              ; 
SBC Player_X_Position         ; horizontal coordinate                                               ; 
STA $00                       ; and store here                                                      ; 
LDA Enemy_PageLoc,X                                                                                 ; 
SBC Player_PageLoc            ; subtract borrow, then leave                                         ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
EnemyLanding:                                                                                       ; fun():  B
JSR InitVStf                  ; do something here to vertical speed and something else              ; 
LDA Enemy_Y_Position,X                                                                              ; 
AND #%11110000                ; save high nybble of vertical coordinate, and                        ; 
ORA #%00001000                ; set d3, then store, probably used to set enemy object               ; 
STA Enemy_Y_Position,X        ; neatly on whatever it's landing on                                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
SubtEnemyYPos:                                                                                      ; fun(): CarryFlag B
LDA Enemy_Y_Position,X        ; add 62 pixels to enemy object's                                     ; 
CLC                           ; vertical coordinate                                                 ; 
ADC #$3e                                                                                            ; 
CMP #$44                      ; compare against a certain range                                     ; 
RTS                           ; and leave with flags set for conditional branch                     ; 
                                                                                                    ;  B
EnemyJump:                                                                                          ; fun(CarryFlag):  B
JSR SubtEnemyYPos             ; do a sub here                                                       ; 
BCC DoSide                    ; if enemy vertical coord + 62 < 68, branch to leave                  ; 
LDA Enemy_Y_Speed,X                                                                                 ;  B
CLC                           ; add two to vertical speed                                           ; 
ADC #$02                                                                                            ; 
CMP #$03                      ; if green paratroopa not falling, branch ahead                       ; 
BCC DoSide                                                                                          ; 
JSR ChkUnderEnemy             ; otherwise, check to see if green paratroopa is                      ;  B
BEQ DoSide                    ; standing on anything, then branch to same place if not              ; 
JSR ChkForNonSolids           ; check for non-solid blocks                                          ;  B
BEQ DoSide                    ; branch if found                                                     ; 
JSR EnemyLanding              ; change vertical coordinate and speed                                ;  B
LDA #$fd                                                                                            ; 
STA Enemy_Y_Speed,X           ; make the paratroopa jump again                                      ; 
DoSide:  JMP DoEnemySideCheck ; check for horizontal blockage, then leave                           ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
HammerBroBGColl:                                                                                    ;  B
JSR ChkUnderEnemy             ; check to see if hammer bro is standing on anything                  ; 
BEQ NoUnderHammerBro                                                                                ; 
CMP #$23                      ; check for blank metatile $23 and branch if not found                ;  B
BNE UnderHammerBro                                                                                  ; 
                                                                                                    ;  B
KillEnemyAboveBlock:                                                                                ; fun():  B
JSR ShellOrBlockDefeat        ; do this sub to kill enemy                                           ; 
LDA #$fc                      ; alter vertical speed of enemy and leave                             ; 
STA Enemy_Y_Speed,X                                                                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
UnderHammerBro:                                                                                     ;  B
LDA EnemyFrameTimer,X         ; check timer used by hammer bro                                      ; 
BNE NoUnderHammerBro          ; branch if not expired                                               ; 
LDA Enemy_State,X                                                                                   ;  B
AND #%10001000                ; save d7 and d3 from enemy state, nullify other bits                 ; 
STA Enemy_State,X             ; and store                                                           ; 
JSR EnemyLanding              ; modify vertical coordinate, speed and something else                ; 
JMP DoEnemySideCheck          ; then check for horizontal blockage and leave                        ; 
                                                                                                    ;  B
NoUnderHammerBro:                                                                                   ;  B
LDA Enemy_State,X             ; if hammer bro is not standing on anything, set d0                   ; 
ORA #$01                      ; in the enemy state to indicate jumping or falling, then leave       ; 
STA Enemy_State,X                                                                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ChkUnderEnemy:                                                                                      ; fun(): ZeroFlag B
LDA #$00                      ; set flag in A for save vertical coordinate                          ; 
LDY #$15                      ; set Y to check the bottom middle (8,18) of enemy object             ; 
JMP BlockBufferChk_Enemy      ; hop to it!                                                          ; 
                                                                                                    ;  B
ChkForNonSolids:                                                                                    ; fun(A): ZeroFlag B
CMP #$26                      ; blank metatile used for vines?                                      ; 
BEQ NSFnd                                                                                           ; 
CMP #$c2                      ; regular coin?                                                       ;  B
BEQ NSFnd                                                                                           ; 
CMP #$c3                      ; underwater coin?                                                    ;  B
BEQ NSFnd                                                                                           ; 
CMP #$5f                      ; hidden coin block?                                                  ;  B
BEQ NSFnd                                                                                           ; 
CMP #$60                      ; hidden 1-up block?                                                  ;  B
NSFnd:  RTS                                                                                         ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
FireballBGCollision:                                                                                ; fun():  B
LDA Fireball_Y_Position,X     ; check fireball's vertical coordinate                                ; 
CMP #$18                                                                                            ; 
BCC ClearBounceFlag           ; if within the status bar area of the screen, branch ahead           ; 
JSR BlockBufferChk_FBall      ; do fireball to background collision detection on bottom of it       ;  B
BEQ ClearBounceFlag           ; if nothing underneath fireball, branch                              ; 
JSR ChkForNonSolids           ; check for non-solid metatiles                                       ;  B
BEQ ClearBounceFlag           ; branch if any found                                                 ; 
LDA Fireball_Y_Speed,X        ; if fireball's vertical speed set to move upwards,                   ;  B
BMI InitFireballExplode       ; branch to set exploding bit in fireball's state                     ; 
LDA FireballBouncingFlag,X    ; if bouncing flag already set,                                       ;  B
BNE InitFireballExplode       ; branch to set exploding bit in fireball's state                     ; 
LDA #$fd                                                                                            ;  B
STA Fireball_Y_Speed,X        ; otherwise set vertical speed to move upwards (give it bounce)       ; 
LDA #$01                                                                                            ; 
STA FireballBouncingFlag,X    ; set bouncing flag                                                   ; 
LDA Fireball_Y_Position,X                                                                           ; 
AND #$f8                      ; modify vertical coordinate to land it properly                      ; 
STA Fireball_Y_Position,X     ; store as new vertical coordinate                                    ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
ClearBounceFlag:                                                                                    ;  B
LDA #$00                                                                                            ; 
STA FireballBouncingFlag,X    ; clear bouncing flag by default                                      ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
InitFireballExplode:                                                                                ;  B
LDA #$80                                                                                            ; 
STA Fireball_State,X          ; set exploding flag in fireball's state                              ; 
LDA #Sfx_Bump                                                                                       ; 
STA Square1SoundQueue         ; load bump sound                                                     ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to hold one of bitmasks, or offset                       ; 
                              ; $01 - used for relative X coordinate, also used to store middle screen page location; 
                              ; $02 - used for relative Y coordinate, also used to store middle screen coordinate; 
                                                                                                    ; 
                              ; this data added to relative coordinates of sprite objects           ; 
                              ; stored in order: left edge, top edge, right edge, bottom edge       ; 
BoundBoxCtrlData:                                                                                   ;  B
DATA: ByteValue(value=2), ByteValue(value=8), ByteValue(value=14), ByteValue(value=32)              ; 
DATA: ByteValue(value=3), ByteValue(value=20), ByteValue(value=13), ByteValue(value=32)             ; 
DATA: ByteValue(value=2), ByteValue(value=20), ByteValue(value=14), ByteValue(value=32)             ; 
DATA: ByteValue(value=2), ByteValue(value=9), ByteValue(value=14), ByteValue(value=21)              ; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=24), ByteValue(value=6)               ; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=32), ByteValue(value=13)              ; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=48), ByteValue(value=13)              ; 
DATA: ByteValue(value=0), ByteValue(value=0), ByteValue(value=8), ByteValue(value=8)                ; 
DATA: ByteValue(value=6), ByteValue(value=4), ByteValue(value=10), ByteValue(value=8)               ; 
DATA: ByteValue(value=3), ByteValue(value=14), ByteValue(value=13), ByteValue(value=20)             ; 
DATA: ByteValue(value=0), ByteValue(value=2), ByteValue(value=16), ByteValue(value=21)              ; 
DATA: ByteValue(value=4), ByteValue(value=4), ByteValue(value=12), ByteValue(value=28)              ; 
                                                                                                    ; 
GetFireballBoundBox:                                                                                ; fun(X):  B
TXA                           ; add seven bytes to offset                                           ; 
CLC                           ; to use in routines as offset for fireball                           ; 
ADC #$07                                                                                            ; 
TAX                                                                                                 ; 
LDY #$02                      ; set offset for relative coordinates                                 ; 
BNE FBallB                    ; unconditional branch                                                ; 
                                                                                                    ;  B
GetMiscBoundBox:                                                                                    ; fun(X):  B
TXA                           ; add nine bytes to offset                                            ; 
CLC                           ; to use in routines as offset for misc object                        ; 
ADC #$09                                                                                            ; 
TAX                                                                                                 ; 
LDY #$06                      ; set offset for relative coordinates                                 ; 
FBallB:  JSR BoundingBoxCore  ; get bounding box coordinates                                        ;  B
JMP CheckRightScreenBBox      ; jump to handle any offscreen coordinates                            ; 
                                                                                                    ;  B
GetEnemyBoundBox:                                                                                   ; fun(X):  B
LDY #$48                      ; store bitmask here for now                                          ; 
STY $00                                                                                             ; 
LDY #$44                      ; store another bitmask here for now and jump                         ; 
JMP GetMaskedOffScrBits                                                                             ; 
                                                                                                    ;  B
SmallPlatformBoundBox:                                                                              ; fun(X):  B
LDY #$08                      ; store bitmask here for now                                          ; 
STY $00                                                                                             ; 
LDY #$04                      ; store another bitmask here for now                                  ; 
                                                                                                    ; 
GetMaskedOffScrBits:                                                                                ;  B
LDA Enemy_X_Position,X        ; get enemy object position relative                                  ; 
SEC                           ; to the left side of the screen                                      ; 
SBC ScreenLeft_X_Pos                                                                                ; 
STA $01                       ; store here                                                          ; 
LDA Enemy_PageLoc,X           ; subtract borrow from current page location                          ; 
SBC ScreenLeft_PageLoc        ; of left side                                                        ; 
BMI CMBits                    ; if enemy object is beyond left edge, branch                         ; 
ORA $01                                                                                             ;  B
BEQ CMBits                    ; if precisely at the left edge, branch                               ; 
LDY $00                       ; if to the right of left edge, use value in $00 for A                ;  B
CMBits:  TYA                  ; otherwise use contents of Y                                         ;  B
AND Enemy_OffscreenBits       ; preserve bitwise whatever's in here                                 ; 
STA EnemyOffscrBitsMasked,X   ; save masked offscreen bits here                                     ; 
BNE MoveBoundBoxOffscreen     ; if anything set here, branch                                        ; 
JMP SetupEOffsetFBBox         ; otherwise, do something else                                        ;  B
                                                                                                    ;  B
LargePlatformBoundBox:                                                                              ; fun(XA):  B
INX                           ; increment X to get the proper offset                                ; 
JSR GetXOffscreenBits         ; then jump directly to the sub for horizontal offscreen bits         ; 
DEX                           ; decrement to return to original offset                              ; 
CMP #$fe                      ; if completely offscreen, branch to put entire bounding              ; 
BCS MoveBoundBoxOffscreen     ; box offscreen, otherwise start getting coordinates                  ; 
                                                                                                    ;  B
SetupEOffsetFBBox:                                                                                  ;  B
TXA                           ; add 1 to offset to properly address                                 ; 
CLC                           ; the enemy object memory locations                                   ; 
ADC #$01                                                                                            ; 
TAX                                                                                                 ; 
LDY #$01                      ; load 1 as offset here, same reason                                  ; 
JSR BoundingBoxCore           ; do a sub to get the coordinates of the bounding box                 ; 
JMP CheckRightScreenBBox      ; jump to handle offscreen coordinates of bounding box                ; 
                                                                                                    ;  B
MoveBoundBoxOffscreen:                                                                              ;  B
TXA                           ; multiply offset by 4                                                ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
TAY                           ; use as offset here                                                  ; 
LDA #$ff                                                                                            ; 
STA EnemyBoundingBoxCoord,Y   ; load value into four locations here and leave                       ; 
STA EnemyBoundingBoxCoord+1,Y                                                                       ; 
STA EnemyBoundingBoxCoord+2,Y                                                                       ; 
STA EnemyBoundingBoxCoord+3,Y                                                                       ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
BoundingBoxCore:                                                                                    ; fun(X):  B
STX $00                       ; save offset here                                                    ; 
LDA SprObject_Rel_YPos,Y      ; store object coordinates relative to screen                         ; 
STA $02                       ; vertically and horizontally, respectively                           ; 
LDA SprObject_Rel_XPos,Y                                                                            ; 
STA $01                                                                                             ; 
TXA                           ; multiply offset by four and save to stack                           ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
PHA                                                                                                 ; 
TAY                           ; use as offset for Y, X is left alone                                ; 
LDA SprObj_BoundBoxCtrl,X     ; load value here to be used as offset for X                          ; 
ASL                           ; multiply that by four and use as X                                  ; 
ASL                                                                                                 ; 
TAX                                                                                                 ; 
LDA $01                       ; add the first number in the bounding box data to the                ; 
CLC                           ; relative horizontal coordinate using enemy object offset            ; 
ADC BoundBoxCtrlData,X        ; and store somewhere using same offset * 4                           ; 
STA BoundingBox_UL_Corner,Y   ; store here                                                          ; 
LDA $01                                                                                             ; 
CLC                                                                                                 ; 
ADC BoundBoxCtrlData+2,X      ; add the third number in the bounding box data to the                ; 
STA BoundingBox_LR_Corner,Y   ; relative horizontal coordinate and store                            ; 
INX                           ; increment both offsets                                              ; 
INY                                                                                                 ; 
LDA $02                       ; add the second number to the relative vertical coordinate           ; 
CLC                           ; using incremented offset and store using the other                  ; 
ADC BoundBoxCtrlData,X        ; incremented offset                                                  ; 
STA BoundingBox_UL_Corner,Y                                                                         ; 
LDA $02                                                                                             ; 
CLC                                                                                                 ; 
ADC BoundBoxCtrlData+2,X      ; add the fourth number to the relative vertical coordinate           ; 
STA BoundingBox_LR_Corner,Y   ; and store                                                           ; 
PLA                           ; get original offset loaded into $00 * y from stack                  ; 
TAY                           ; use as Y                                                            ; 
LDX $00                       ; get original offset and use as X again                              ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
CheckRightScreenBBox:                                                                               ;  B
LDA ScreenLeft_X_Pos          ; add 128 pixels to left side of screen                               ; 
CLC                           ; and store as horizontal coordinate of middle                        ; 
ADC #$80                                                                                            ; 
STA $02                                                                                             ; 
LDA ScreenLeft_PageLoc        ; add carry to page location of left side of screen                   ; 
ADC #$00                      ; and store as page location of middle                                ; 
STA $01                                                                                             ; 
LDA SprObject_X_Position,X    ; get horizontal coordinate                                           ; 
CMP $02                       ; compare against middle horizontal coordinate                        ; 
LDA SprObject_PageLoc,X       ; get page location                                                   ; 
SBC $01                       ; subtract from middle page location                                  ; 
BCC CheckLeftScreenBBox       ; if object is on the left side of the screen, branch                 ; 
LDA BoundingBox_DR_XPos,Y     ; check right-side edge of bounding box for offscreen                 ;  B
BMI NoOfs                     ; coordinates, branch if still on the screen                          ; 
LDA #$ff                      ; load offscreen value here to use on one or both horizontal sides    ;  B
LDX BoundingBox_UL_XPos,Y     ; check left-side edge of bounding box for offscreen                  ; 
BMI SORte                     ; coordinates, and branch if still on the screen                      ; 
STA BoundingBox_UL_XPos,Y     ; store offscreen value for left side                                 ;  B
SORte:  STA BoundingBox_DR_XPos,Y; store offscreen value for right side                             ;  B
NoOfs:  LDX ObjectOffset      ; get object offset and leave                                         ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
CheckLeftScreenBBox:                                                                                ;  B
LDA BoundingBox_UL_XPos,Y     ; check left-side edge of bounding box for offscreen                  ; 
BPL NoOfs2                    ; coordinates, and branch if still on the screen                      ; 
CMP #$a0                      ; check to see if left-side edge is in the middle of the              ;  B
BCC NoOfs2                    ; screen or really offscreen, and branch if still on                  ; 
LDA #$00                                                                                            ;  B
LDX BoundingBox_DR_XPos,Y     ; check right-side edge of bounding box for offscreen                 ; 
BPL SOLft                     ; coordinates, branch if still onscreen                               ; 
STA BoundingBox_DR_XPos,Y     ; store offscreen value for right side                                ;  B
SOLft:  STA BoundingBox_UL_XPos,Y; store offscreen value for left side                              ;  B
NoOfs2:  LDX ObjectOffset     ; get object offset and leave                                         ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $06 - second object's offset                                        ; 
                              ; $07 - counter                                                       ; 
                                                                                                    ; 
PlayerCollisionCore:                                                                                ; fun():  B
LDX #$00                      ; initialize X to use player's bounding box for comparison            ; 
                                                                                                    ; 
SprObjectCollisionCore:                                                                             ; fun(YX): CarryFlag B
STY $06                       ; save contents of Y here                                             ; 
LDA #$01                                                                                            ; 
STA $07                       ; save value 1 here as counter, compare horizontal coordinates first  ; 
                                                                                                    ; 
CollisionCoreLoop:                                                                                  ;  B
LDA BoundingBox_UL_Corner,Y   ; compare left/top coordinates                                        ; 
CMP BoundingBox_UL_Corner,X   ; of first and second objects' bounding boxes                         ; 
BCS FirstBoxGreater           ; if first left/top => second, branch                                 ; 
CMP BoundingBox_LR_Corner,X   ; otherwise compare to right/bottom of second                         ;  B
BCC SecondBoxVerticalChk      ; if first left/top < second right/bottom, branch elsewhere           ; 
BEQ CollisionFound            ; if somehow equal, collision, thus branch                            ;  B
LDA BoundingBox_LR_Corner,Y   ; if somehow greater, check to see if bottom of                       ;  B
CMP BoundingBox_UL_Corner,Y   ; first object's bounding box is greater than its top                 ; 
BCC CollisionFound            ; if somehow less, vertical wrap collision, thus branch               ; 
CMP BoundingBox_UL_Corner,X   ; otherwise compare bottom of first bounding box to the top           ;  B
BCS CollisionFound            ; of second box, and if equal or greater, collision, thus branch      ; 
LDY $06                       ; otherwise return with carry clear and Y = $0006                     ;  B
RTS                           ; note horizontal wrapping never occurs                               ; 
                                                                                                    ;  B
SecondBoxVerticalChk:                                                                               ;  B
LDA BoundingBox_LR_Corner,X   ; check to see if the vertical bottom of the box                      ; 
CMP BoundingBox_UL_Corner,X   ; is greater than the vertical top                                    ; 
BCC CollisionFound            ; if somehow less, vertical wrap collision, thus branch               ; 
LDA BoundingBox_LR_Corner,Y   ; otherwise compare horizontal right or vertical bottom               ;  B
CMP BoundingBox_UL_Corner,X   ; of first box with horizontal left or vertical top of second box     ; 
BCS CollisionFound            ; if equal or greater, collision, thus branch                         ; 
LDY $06                       ; otherwise return with carry clear and Y = $0006                     ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
FirstBoxGreater:                                                                                    ;  B
CMP BoundingBox_UL_Corner,X   ; compare first and second box horizontal left/vertical top again     ; 
BEQ CollisionFound            ; if first coordinate = second, collision, thus branch                ; 
CMP BoundingBox_LR_Corner,X   ; if not, compare with second object right or bottom edge             ;  B
BCC CollisionFound            ; if left/top of first less than or equal to right/bottom of second   ; 
BEQ CollisionFound            ; then collision, thus branch                                         ;  B
CMP BoundingBox_LR_Corner,Y   ; otherwise check to see if top of first box is greater than bottom   ;  B
BCC NoCollisionFound          ; if less than or equal, no collision, branch to end                  ; 
BEQ NoCollisionFound                                                                                ;  B
LDA BoundingBox_LR_Corner,Y   ; otherwise compare bottom of first to top of second                  ;  B
CMP BoundingBox_UL_Corner,X   ; if bottom of first is greater than top of second, vertical wrap     ; 
BCS CollisionFound            ; collision, and branch, otherwise, proceed onwards here              ; 
                                                                                                    ;  B
NoCollisionFound:                                                                                   ;  B
CLC                           ; clear carry, then load value set earlier, then leave                ; 
LDY $06                       ; like previous ones, if horizontal coordinates do not collide, we do ; 
RTS                           ; not bother checking vertical ones, because what's the point?        ; 
                                                                                                    ;  B
CollisionFound:                                                                                     ;  B
INX                           ; increment offsets on both objects to check                          ; 
INY                           ; the vertical coordinates                                            ; 
DEC $07                       ; decrement counter to reflect this                                   ; 
BPL CollisionCoreLoop         ; if counter not expired, branch to loop                              ; 
SEC                           ; otherwise we already did both sets, therefore collision, so set carry;  B
LDY $06                       ; load original value set here earlier, then leave                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $02 - modified y coordinate                                         ; 
                              ; $03 - stores metatile involved in block buffer collisions           ; 
                              ; $04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate; 
                              ; $05 - modified x coordinate                                         ; 
                              ; $06-$07 - block buffer address                                      ; 
                                                                                                    ; 
BlockBufferChk_Enemy:                                                                               ; fun(AX): ZeroFlag B
PHA                           ; save contents of A to stack                                         ; 
TXA                                                                                                 ; 
CLC                           ; add 1 to X to run sub with enemy offset in mind                     ; 
ADC #$01                                                                                            ; 
TAX                                                                                                 ; 
PLA                           ; pull A from stack and jump elsewhere                                ; 
JMP BBChk_E                                                                                         ; 
                                                                                                    ;  B
ResidualMiscObjectCode:                                                                             ;  B
TXA                                                                                                 ; 
CLC                           ; supposedly used once to set offset for                              ; 
ADC #$0d                      ; miscellaneous objects                                               ; 
TAX                                                                                                 ; 
LDY #$1b                      ; supposedly used once to set offset for block buffer data            ; 
JMP ResJmpM                   ; probably used in early stages to do misc to bg collision detection  ; 
                                                                                                    ;  B
BlockBufferChk_FBall:                                                                               ; fun(X): ZeroFlag B
LDY #$1a                      ; set offset for block buffer adder data                              ; 
TXA                                                                                                 ; 
CLC                                                                                                 ; 
ADC #$07                      ; add seven bytes to use                                              ; 
TAX                                                                                                 ; 
ResJmpM:  LDA #$00            ; set A to return vertical coordinate                                 ;  B
BBChk_E:  JSR BlockBufferCollision; do collision detection subroutine for sprite object             ;  B
LDX ObjectOffset              ; get object offset                                                   ; 
CMP #$00                      ; check to see if object bumped into anything                         ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
BlockBufferAdderData:                                                                               ;  B
DATA: ByteValue(value=0), ByteValue(value=7), ByteValue(value=14)                                   ; 
                                                                                                    ; 
BlockBuffer_X_Adder:                                                                                ;  B
DATA: ByteValue(value=8), ByteValue(value=3), ByteValue(value=12), ByteValue(value=2), ByteValue(value=2), ByteValue(value=13), ByteValue(value=13), ByteValue(value=8); 
DATA: ByteValue(value=3), ByteValue(value=12), ByteValue(value=2), ByteValue(value=2), ByteValue(value=13), ByteValue(value=13), ByteValue(value=8), ByteValue(value=3); 
DATA: ByteValue(value=12), ByteValue(value=2), ByteValue(value=2), ByteValue(value=13), ByteValue(value=13), ByteValue(value=8), ByteValue(value=0), ByteValue(value=16); 
DATA: ByteValue(value=4), ByteValue(value=20), ByteValue(value=4), ByteValue(value=4)               ; 
                                                                                                    ; 
BlockBuffer_Y_Adder:                                                                                ;  B
DATA: ByteValue(value=4), ByteValue(value=32), ByteValue(value=32), ByteValue(value=8), ByteValue(value=24), ByteValue(value=8), ByteValue(value=24), ByteValue(value=2); 
DATA: ByteValue(value=32), ByteValue(value=32), ByteValue(value=8), ByteValue(value=24), ByteValue(value=8), ByteValue(value=24), ByteValue(value=18), ByteValue(value=32); 
DATA: ByteValue(value=32), ByteValue(value=24), ByteValue(value=24), ByteValue(value=24), ByteValue(value=24), ByteValue(value=24), ByteValue(value=20), ByteValue(value=20); 
DATA: ByteValue(value=6), ByteValue(value=6), ByteValue(value=8), ByteValue(value=16)               ; 
                                                                                                    ; 
BlockBufferColli_Feet:                                                                              ; fun(Y):  B
INY                           ; if branched here, increment to next set of adders                   ; 
                                                                                                    ; 
BlockBufferColli_Head:                                                                              ; fun(): ZeroFlag B
LDA #$00                      ; set flag to return vertical coordinate                              ; 
DATA: ByteValue(value=44)     ; BIT instruction opcode                                              ; 
                                                                                                    ; 
BlockBufferColli_Side:                                                                              ; fun(): ZeroFlag B
LDA #$01                      ; set flag to return horizontal coordinate                            ; 
LDX #$00                      ; set offset for player object                                        ; 
                                                                                                    ; 
BlockBufferCollision:                                                                               ; fun(AY): $02A B
PHA                           ; save contents of A to stack                                         ; 
STY $04                       ; save contents of Y here                                             ; 
LDA BlockBuffer_X_Adder,Y     ; add horizontal coordinate                                           ; 
CLC                           ; of object to value obtained using Y as offset                       ; 
ADC SprObject_X_Position,X                                                                          ; 
STA $05                       ; store here                                                          ; 
LDA SprObject_PageLoc,X                                                                             ; 
ADC #$00                      ; add carry to page location                                          ; 
AND #$01                      ; get LSB, mask out all other bits                                    ; 
LSR                           ; move to carry                                                       ; 
ORA $05                       ; get stored value                                                    ; 
ROR                           ; rotate carry to MSB of A                                            ; 
LSR                           ; and effectively move high nybble to                                 ; 
LSR                           ; lower, LSB which became MSB will be                                 ; 
LSR                           ; d4 at this point                                                    ; 
JSR GetBlockBufferAddr        ; get address of block buffer into $06, $07                           ; 
LDY $04                       ; get old contents of Y                                               ; 
LDA SprObject_Y_Position,X    ; get vertical coordinate of object                                   ; 
CLC                                                                                                 ; 
ADC BlockBuffer_Y_Adder,Y     ; add it to value obtained using Y as offset                          ; 
AND #%11110000                ; mask out low nybble                                                 ; 
SEC                                                                                                 ; 
SBC #$20                      ; subtract 32 pixels for the status bar                               ; 
STA $02                       ; store result here                                                   ; 
TAY                           ; use as offset for block buffer                                      ; 
LDA ($06),Y                   ; check current content of block buffer                               ; 
STA $03                       ; and store here                                                      ; 
LDY $04                       ; get old contents of Y again                                         ; 
PLA                           ; pull A from stack                                                   ; 
BNE RetXC                     ; if A = 1, branch                                                    ; 
LDA SprObject_Y_Position,X    ; if A = 0, load vertical coordinate                                  ;  B
JMP RetYC                     ; and jump                                                            ; 
RetXC:  LDA SprObject_X_Position,X; otherwise load horizontal coordinate                            ;  B
RetYC:  AND #%00001111        ; and mask out high nybble                                            ;  B
STA $04                       ; store masked out result here                                        ; 
LDA $03                       ; get saved content of block buffer                                   ; 
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; unused byte                                                         ; 
DATA: ByteValue(value=255)                                                                          ; 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - offset to vine Y coordinate adder                             ; 
                              ; $02 - offset to sprite data                                         ; 
                                                                                                    ; 
VineYPosAdder:                                                                                      ;  B
DATA: ByteValue(value=0), ByteValue(value=48)                                                       ; 
                                                                                                    ; 
DrawVine:                                                                                           ; fun(Y): Y B
STY $00                       ; save offset here                                                    ; 
LDA Enemy_Rel_YPos            ; get relative vertical coordinate                                    ; 
CLC                                                                                                 ; 
ADC VineYPosAdder,Y           ; add value using offset in Y to get value                            ; 
LDX VineObjOffset,Y           ; get offset to vine                                                  ; 
LDY Enemy_SprDataOffset,X     ; get sprite data offset                                              ; 
STY $02                       ; store sprite data offset here                                       ; 
JSR SixSpriteStacker          ; stack six sprites on top of each other vertically                   ; 
LDA Enemy_Rel_XPos            ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y       ; store in first, third and fifth sprites                             ; 
STA Sprite_X_Position+8,Y                                                                           ; 
STA Sprite_X_Position+16,Y                                                                          ; 
CLC                                                                                                 ; 
ADC #$06                      ; add six pixels to second, fourth and sixth sprites                  ; 
STA Sprite_X_Position+4,Y     ; to give characteristic staggered vine shape to                      ; 
STA Sprite_X_Position+12,Y    ; our vertical stack of sprites                                       ; 
STA Sprite_X_Position+20,Y                                                                          ; 
LDA #%00100001                ; set bg priority and palette attribute bits                          ; 
STA Sprite_Attributes,Y       ; set in first, third and fifth sprites                               ; 
STA Sprite_Attributes+8,Y                                                                           ; 
STA Sprite_Attributes+16,Y                                                                          ; 
ORA #%01000000                ; additionally, set horizontal flip bit                               ; 
STA Sprite_Attributes+4,Y     ; for second, fourth and sixth sprites                                ; 
STA Sprite_Attributes+12,Y                                                                          ; 
STA Sprite_Attributes+20,Y                                                                          ; 
LDX #$05                      ; set tiles for six sprites                                           ; 
VineTL:  LDA #$e1             ; set tile number for sprite                                          ;  B
STA Sprite_Tilenumber,Y                                                                             ; 
INY                           ; move offset to next sprite data                                     ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
DEX                           ; move onto next sprite                                               ; 
BPL VineTL                    ; loop until all sprites are done                                     ; 
LDY $02                       ; get original offset                                                 ;  B
LDA $00                       ; get offset to vine adding data                                      ; 
BNE SkpVTop                   ; if offset not zero, skip this part                                  ; 
LDA #$e0                                                                                            ;  B
STA Sprite_Tilenumber,Y       ; set other tile number for top of vine                               ; 
SkpVTop:  LDX #$00            ; start with the first sprite again                                   ;  B
ChkFTop:  LDA VineStart_Y_Position; get original starting vertical coordinate                       ;  B
SEC                                                                                                 ; 
SBC Sprite_Y_Position,Y       ; subtract top-most sprite's Y coordinate                             ; 
CMP #$64                      ; if two coordinates are less than 100/$64 pixels                     ; 
BCC NextVSp                   ; apart, skip this to leave sprite alone                              ; 
LDA #$f8                                                                                            ;  B
STA Sprite_Y_Position,Y       ; otherwise move sprite offscreen                                     ; 
NextVSp:  INY                 ; move offset to next OAM data                                        ;  B
INY                                                                                                 ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
INX                           ; move onto next sprite                                               ; 
CPX #$06                      ; do this until all sprites are checked                               ; 
BNE ChkFTop                                                                                         ; 
LDY $00                       ; return offset set earlier                                           ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
SixSpriteStacker:                                                                                   ; fun(AY$02):  B
LDX #$06                      ; do six sprites                                                      ; 
StkLp:  STA Sprite_Data,Y     ; store X or Y coordinate into OAM data                               ;  B
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
INY                                                                                                 ; 
INY                           ; move offset four bytes forward                                      ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
DEX                           ; do another sprite                                                   ; 
BNE StkLp                     ; do this until all sprites are done                                  ; 
LDY $02                       ; get saved OAM data offset and leave                                 ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
FirstSprXPos:                                                                                       ;  B
DATA: ByteValue(value=4), ByteValue(value=0), ByteValue(value=4), ByteValue(value=0)                ; 
                                                                                                    ; 
FirstSprYPos:                                                                                       ;  B
DATA: ByteValue(value=0), ByteValue(value=4), ByteValue(value=0), ByteValue(value=4)                ; 
                                                                                                    ; 
SecondSprXPos:                                                                                      ;  B
DATA: ByteValue(value=0), ByteValue(value=8), ByteValue(value=0), ByteValue(value=8)                ; 
                                                                                                    ; 
SecondSprYPos:                                                                                      ;  B
DATA: ByteValue(value=8), ByteValue(value=0), ByteValue(value=8), ByteValue(value=0)                ; 
                                                                                                    ; 
FirstSprTilenum:                                                                                    ;  B
DATA: ByteValue(value=128), ByteValue(value=130), ByteValue(value=129), ByteValue(value=131)        ; 
                                                                                                    ; 
SecondSprTilenum:                                                                                   ;  B
DATA: ByteValue(value=129), ByteValue(value=131), ByteValue(value=128), ByteValue(value=130)        ; 
                                                                                                    ; 
HammerSprAttrib:                                                                                    ;  B
DATA: ByteValue(value=3), ByteValue(value=3), ByteValue(value=195), ByteValue(value=195)            ; 
                                                                                                    ; 
DrawHammer:                                                                                         ; fun():  B
LDY Misc_SprDataOffset,X      ; get misc object OAM data offset                                     ; 
LDA TimerControl                                                                                    ; 
BNE ForceHPose                ; if master timer control set, skip this part                         ; 
LDA Misc_State,X              ; otherwise get hammer's state                                        ;  B
AND #%01111111                ; mask out d7                                                         ; 
CMP #$01                      ; check to see if set to 1 yet                                        ; 
BEQ GetHPose                  ; if so, branch                                                       ; 
ForceHPose:  LDX #$00         ; reset offset here                                                   ;  B
BEQ RenderH                   ; do unconditional branch to rendering part                           ; 
GetHPose:  LDA FrameCounter   ; get frame counter                                                   ;  B
LSR                           ; move d3-d2 to d1-d0                                                 ; 
LSR                                                                                                 ; 
AND #%00000011                ; mask out all but d1-d0 (changes every four frames)                  ; 
TAX                           ; use as timing offset                                                ; 
RenderH:  LDA Misc_Rel_YPos   ; get relative vertical coordinate                                    ;  B
CLC                                                                                                 ; 
ADC FirstSprYPos,X            ; add first sprite vertical adder based on offset                     ; 
STA Sprite_Y_Position,Y       ; store as sprite Y coordinate for first sprite                       ; 
CLC                                                                                                 ; 
ADC SecondSprYPos,X           ; add second sprite vertical adder based on offset                    ; 
STA Sprite_Y_Position+4,Y     ; store as sprite Y coordinate for second sprite                      ; 
LDA Misc_Rel_XPos             ; get relative horizontal coordinate                                  ; 
CLC                                                                                                 ; 
ADC FirstSprXPos,X            ; add first sprite horizontal adder based on offset                   ; 
STA Sprite_X_Position,Y       ; store as sprite X coordinate for first sprite                       ; 
CLC                                                                                                 ; 
ADC SecondSprXPos,X           ; add second sprite horizontal adder based on offset                  ; 
STA Sprite_X_Position+4,Y     ; store as sprite X coordinate for second sprite                      ; 
LDA FirstSprTilenum,X                                                                               ; 
STA Sprite_Tilenumber,Y       ; get and store tile number of first sprite                           ; 
LDA SecondSprTilenum,X                                                                              ; 
STA Sprite_Tilenumber+4,Y     ; get and store tile number of second sprite                          ; 
LDA HammerSprAttrib,X                                                                               ; 
STA Sprite_Attributes,Y       ; get and store attribute bytes for both                              ; 
STA Sprite_Attributes+4,Y     ; note in this case they use the same data                            ; 
LDX ObjectOffset              ; get misc object offset                                              ; 
LDA Misc_OffscreenBits                                                                              ; 
AND #%11111100                ; check offscreen bits                                                ; 
BEQ NoHOffscr                 ; if all bits clear, leave object alone                               ; 
LDA #$00                                                                                            ;  B
STA Misc_State,X              ; otherwise nullify misc object state                                 ; 
LDA #$f8                                                                                            ; 
JSR DumpTwoSpr                ; do sub to move hammer sprites offscreen                             ; 
NoHOffscr:  RTS               ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part); 
                              ; $02 - used to hold Y coordinate for floatey number                  ; 
                              ; $03 - residual byte used for flip (but value set here affects nothing); 
                              ; $04 - attribute byte for floatey number                             ; 
                              ; $05 - used as X coordinate for floatey number                       ; 
                                                                                                    ; 
FlagpoleScoreNumTiles:                                                                              ;  B
DATA: ByteValue(value=249), ByteValue(value=80)                                                     ; 
DATA: ByteValue(value=247), ByteValue(value=80)                                                     ; 
DATA: ByteValue(value=250), ByteValue(value=251)                                                    ; 
DATA: ByteValue(value=248), ByteValue(value=251)                                                    ; 
DATA: ByteValue(value=246), ByteValue(value=251)                                                    ; 
                                                                                                    ; 
FlagpoleGfxHandler:                                                                                 ; fun():  B
LDY Enemy_SprDataOffset,X     ; get sprite data offset for flagpole flag                            ; 
LDA Enemy_Rel_XPos            ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y       ; store as X coordinate for first sprite                              ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels and store                                          ; 
STA Sprite_X_Position+4,Y     ; as X coordinate for second and third sprites                        ; 
STA Sprite_X_Position+8,Y                                                                           ; 
CLC                                                                                                 ; 
ADC #$0c                      ; add twelve more pixels and                                          ; 
STA $05                       ; store here to be used later by floatey number                       ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
JSR DumpTwoSpr                ; and do sub to dump into first and second sprites                    ; 
ADC #$08                      ; add eight pixels                                                    ; 
STA Sprite_Y_Position+8,Y     ; and store into third sprite                                         ; 
LDA FlagpoleFNum_Y_Pos        ; get vertical coordinate for floatey number                          ; 
STA $02                       ; store it here                                                       ; 
LDA #$01                                                                                            ; 
STA $03                       ; set value for flip which will not be used, and                      ; 
STA $04                       ; attribute byte for floatey number                                   ; 
STA Sprite_Attributes,Y       ; set attribute bytes for all three sprites                           ; 
STA Sprite_Attributes+4,Y                                                                           ; 
STA Sprite_Attributes+8,Y                                                                           ; 
LDA #$7e                                                                                            ; 
STA Sprite_Tilenumber,Y       ; put triangle shaped tile                                            ; 
STA Sprite_Tilenumber+8,Y     ; into first and third sprites                                        ; 
LDA #$7f                                                                                            ; 
STA Sprite_Tilenumber+4,Y     ; put skull tile into second sprite                                   ; 
LDA FlagpoleCollisionYPos     ; get vertical coordinate at time of collision                        ; 
BEQ ChkFlagOffscreen          ; if zero, branch ahead                                               ; 
TYA                                                                                                 ;  B
CLC                           ; add 12 bytes to sprite data offset                                  ; 
ADC #$0c                                                                                            ; 
TAY                           ; put back in Y                                                       ; 
LDA FlagpoleScore             ; get offset used to award points for touching flagpole               ; 
ASL                           ; multiply by 2 to get proper offset here                             ; 
TAX                                                                                                 ; 
LDA FlagpoleScoreNumTiles,X   ; get appropriate tile data                                           ; 
STA $00                                                                                             ; 
LDA FlagpoleScoreNumTiles+1,X                                                                       ; 
JSR DrawOneSpriteRow          ; use it to render floatey number                                     ; 
                                                                                                    ; 
ChkFlagOffscreen:                                                                                   ;  B
LDX ObjectOffset              ; get object offset for flag                                          ; 
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDA Enemy_OffscreenBits       ; get offscreen bits                                                  ; 
AND #%00001110                ; mask out all but d3-d1                                              ; 
BEQ ExitDumpSpr               ; if none of these bits set, branch to leave                          ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
MoveSixSpritesOffscreen:                                                                            ; fun():  B
LDA #$f8                      ; set offscreen coordinate if jumping here                            ; 
                                                                                                    ; 
DumpSixSpr:                                                                                         ; fun(A):  B
STA Sprite_Data+20,Y          ; dump A contents                                                     ; 
STA Sprite_Data+16,Y          ; into third row sprites                                              ; 
                                                                                                    ; 
DumpFourSpr:                                                                                        ; fun(A):  B
STA Sprite_Data+12,Y          ; into second row sprites                                             ; 
                                                                                                    ; 
DumpThreeSpr:                                                                                       ; fun(A):  B
STA Sprite_Data+8,Y                                                                                 ; 
                                                                                                    ; 
DumpTwoSpr:                                                                                         ; fun(A):  B
STA Sprite_Data+4,Y           ; and into first row sprites                                          ; 
STA Sprite_Data,Y                                                                                   ; 
                                                                                                    ; 
ExitDumpSpr:                                                                                        ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DrawLargePlatform:                                                                                  ; fun():  B
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
STY $02                       ; store here                                                          ; 
INY                           ; add 3 to it for offset                                              ; 
INY                           ; to X coordinate                                                     ; 
INY                                                                                                 ; 
LDA Enemy_Rel_XPos            ; get horizontal relative coordinate                                  ; 
JSR SixSpriteStacker          ; store X coordinates using A as base, stack horizontally             ; 
LDX ObjectOffset                                                                                    ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
JSR DumpFourSpr               ; dump into first four sprites as Y coordinate                        ; 
LDY AreaType                                                                                        ; 
CPY #$03                      ; check for castle-type level                                         ; 
BEQ ShrinkPlatform                                                                                  ; 
LDY SecondaryHardMode         ; check for secondary hard mode flag set                              ;  B
BEQ SetLast2Platform          ; branch if not set elsewhere                                         ; 
                                                                                                    ;  B
ShrinkPlatform:                                                                                     ;  B
LDA #$f8                      ; load offscreen coordinate if flag set or castle-type level          ; 
                                                                                                    ; 
SetLast2Platform:                                                                                   ;  B
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
STA Sprite_Y_Position+16,Y    ; store vertical coordinate or offscreen                              ; 
STA Sprite_Y_Position+20,Y    ; coordinate into last two sprites as Y coordinate                    ; 
LDA #$5b                      ; load default tile for platform (girder)                             ; 
LDX CloudTypeOverride                                                                               ; 
BEQ SetPlatformTilenum        ; if cloud level override flag not set, use                           ; 
LDA #$75                      ; otherwise load other tile for platform (puff)                       ;  B
                                                                                                    ; 
SetPlatformTilenum:                                                                                 ;  B
LDX ObjectOffset              ; get enemy object buffer offset                                      ; 
INY                           ; increment Y for tile offset                                         ; 
JSR DumpSixSpr                ; dump tile number into all six sprites                               ; 
LDA #$02                      ; set palette controls                                                ; 
INY                           ; increment Y for sprite attributes                                   ; 
JSR DumpSixSpr                ; dump attributes into all six sprites                                ; 
INX                           ; increment X for enemy objects                                       ; 
JSR GetXOffscreenBits         ; get offscreen bits again                                            ; 
DEX                                                                                                 ; 
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
ASL                           ; rotate d7 into carry, save remaining                                ; 
PHA                           ; bits to the stack                                                   ; 
BCC SChk2                                                                                           ; 
LDA #$f8                      ; if d7 was set, move first sprite offscreen                          ;  B
STA Sprite_Y_Position,Y                                                                             ; 
SChk2:  PLA                   ; get bits from stack                                                 ;  B
ASL                           ; rotate d6 into carry                                                ; 
PHA                           ; save to stack                                                       ; 
BCC SChk3                                                                                           ; 
LDA #$f8                      ; if d6 was set, move second sprite offscreen                         ;  B
STA Sprite_Y_Position+4,Y                                                                           ; 
SChk3:  PLA                   ; get bits from stack                                                 ;  B
ASL                           ; rotate d5 into carry                                                ; 
PHA                           ; save to stack                                                       ; 
BCC SChk4                                                                                           ; 
LDA #$f8                      ; if d5 was set, move third sprite offscreen                          ;  B
STA Sprite_Y_Position+8,Y                                                                           ; 
SChk4:  PLA                   ; get bits from stack                                                 ;  B
ASL                           ; rotate d4 into carry                                                ; 
PHA                           ; save to stack                                                       ; 
BCC SChk5                                                                                           ; 
LDA #$f8                      ; if d4 was set, move fourth sprite offscreen                         ;  B
STA Sprite_Y_Position+12,Y                                                                          ; 
SChk5:  PLA                   ; get bits from stack                                                 ;  B
ASL                           ; rotate d3 into carry                                                ; 
PHA                           ; save to stack                                                       ; 
BCC SChk6                                                                                           ; 
LDA #$f8                      ; if d3 was set, move fifth sprite offscreen                          ;  B
STA Sprite_Y_Position+16,Y                                                                          ; 
SChk6:  PLA                   ; get bits from stack                                                 ;  B
ASL                           ; rotate d2 into carry                                                ; 
BCC SLChk                     ; save to stack                                                       ; 
LDA #$f8                                                                                            ;  B
STA Sprite_Y_Position+20,Y    ; if d2 was set, move sixth sprite offscreen                          ; 
SLChk:  LDA Enemy_OffscreenBits; check d7 of offscreen bits                                         ;  B
ASL                           ; and if d7 is not set, skip sub                                      ; 
BCC ExDLPl                                                                                          ; 
JSR MoveSixSpritesOffscreen   ; otherwise branch to move all sprites offscreen                      ;  B
ExDLPl:  RTS                                                                                        ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DrawFloateyNumber_Coin:                                                                             ;  B
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; divide by 2                                                         ; 
BCS NotRsNum                  ; branch if d0 not set to raise number every other frame              ; 
DEC Misc_Y_Position,X         ; otherwise, decrement vertical coordinate                            ;  B
NotRsNum:  LDA Misc_Y_Position,X; get vertical coordinate                                           ;  B
JSR DumpTwoSpr                ; dump into both sprites                                              ; 
LDA Misc_Rel_XPos             ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y       ; store as X coordinate for first sprite                              ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
STA Sprite_X_Position+4,Y     ; store as X coordinate for second sprite                             ; 
LDA #$02                                                                                            ; 
STA Sprite_Attributes,Y       ; store attribute byte in both sprites                                ; 
STA Sprite_Attributes+4,Y                                                                           ; 
LDA #$f7                                                                                            ; 
STA Sprite_Tilenumber,Y       ; put tile numbers into both sprites                                  ; 
LDA #$fb                      ; that resemble "200"                                                 ; 
STA Sprite_Tilenumber+4,Y                                                                           ; 
JMP ExJCGfx                   ; then jump to leave (why not an rts here instead?)                   ; 
                                                                                                    ;  B
JumpingCoinTiles:                                                                                   ;  B
DATA: ByteValue(value=96), ByteValue(value=97), ByteValue(value=98), ByteValue(value=99)            ; 
                                                                                                    ; 
JCoinGfxHandler:                                                                                    ; fun():  B
LDY Misc_SprDataOffset,X      ; get coin/floatey number's OAM data offset                           ; 
LDA Misc_State,X              ; get state of misc object                                            ; 
CMP #$02                      ; if 2 or greater,                                                    ; 
BCS DrawFloateyNumber_Coin    ; branch to draw floatey number                                       ; 
LDA Misc_Y_Position,X         ; store vertical coordinate as                                        ;  B
STA Sprite_Y_Position,Y       ; Y coordinate for first sprite                                       ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
STA Sprite_Y_Position+4,Y     ; store as Y coordinate for second sprite                             ; 
LDA Misc_Rel_XPos             ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y                                                                             ; 
STA Sprite_X_Position+4,Y     ; store as X coordinate for first and second sprites                  ; 
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; divide by 2 to alter every other frame                              ; 
AND #%00000011                ; mask out d2-d1                                                      ; 
TAX                           ; use as graphical offset                                             ; 
LDA JumpingCoinTiles,X        ; load tile number                                                    ; 
INY                           ; increment OAM data offset to write tile numbers                     ; 
JSR DumpTwoSpr                ; do sub to dump tile number into both sprites                        ; 
DEY                           ; decrement to get old offset                                         ; 
LDA #$02                                                                                            ; 
STA Sprite_Attributes,Y       ; set attribute byte in first sprite                                  ; 
LDA #$82                                                                                            ; 
STA Sprite_Attributes+4,Y     ; set attribute byte with vertical flip in second sprite              ; 
LDX ObjectOffset              ; get misc object offset                                              ; 
ExJCGfx:  RTS                 ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type; 
                              ; $02 - used to hold bottom row Y position                            ; 
                              ; $03 - used to hold flip control (not used here)                     ; 
                              ; $04 - used to hold sprite attributes                                ; 
                              ; $05 - used to hold X position                                       ; 
                              ; $07 - counter                                                       ; 
                                                                                                    ; 
                              ; tiles arranged in top left, right, bottom left, right order         ; 
PowerUpGfxTable:                                                                                    ;  B
DATA: ByteValue(value=118), ByteValue(value=119), ByteValue(value=120), ByteValue(value=121); regular mushroom; 
DATA: ByteValue(value=214), ByteValue(value=214), ByteValue(value=217), ByteValue(value=217); fire flower; 
DATA: ByteValue(value=141), ByteValue(value=141), ByteValue(value=228), ByteValue(value=228); star  ; 
DATA: ByteValue(value=118), ByteValue(value=119), ByteValue(value=120), ByteValue(value=121); 1-up mushroom; 
                                                                                                    ; 
PowerUpAttributes:                                                                                  ;  B
DATA: ByteValue(value=2), ByteValue(value=1), ByteValue(value=2), ByteValue(value=1)                ; 
                                                                                                    ; 
DrawPowerUp:                                                                                        ; fun():  B
LDY Enemy_SprDataOffset+5     ; get power-up's sprite data offset                                   ; 
LDA Enemy_Rel_YPos            ; get relative vertical coordinate                                    ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
STA $02                       ; store result here                                                   ; 
LDA Enemy_Rel_XPos            ; get relative horizontal coordinate                                  ; 
STA $05                       ; store here                                                          ; 
LDX PowerUpType               ; get power-up type                                                   ; 
LDA PowerUpAttributes,X       ; get attribute data for power-up type                                ; 
ORA Enemy_SprAttrib+5         ; add background priority bit if set                                  ; 
STA $04                       ; store attributes here                                               ; 
TXA                                                                                                 ; 
PHA                           ; save power-up type to the stack                                     ; 
ASL                                                                                                 ; 
ASL                           ; multiply by four to get proper offset                               ; 
TAX                           ; use as X                                                            ; 
LDA #$01                                                                                            ; 
STA $07                       ; set counter here to draw two rows of sprite object                  ; 
STA $03                       ; init d1 of flip control                                             ; 
                                                                                                    ; 
PUpDrawLoop:                                                                                        ;  B
LDA PowerUpGfxTable,X         ; load left tile of power-up object                                   ; 
STA $00                                                                                             ; 
LDA PowerUpGfxTable+1,X       ; load right tile                                                     ; 
JSR DrawOneSpriteRow          ; branch to draw one row of our power-up object                       ; 
DEC $07                       ; decrement counter                                                   ; 
BPL PUpDrawLoop               ; branch until two rows are drawn                                     ; 
LDY Enemy_SprDataOffset+5     ; get sprite data offset again                                        ;  B
PLA                           ; pull saved power-up type from the stack                             ; 
BEQ PUpOfs                    ; if regular mushroom, branch, do not change colors or flip           ; 
CMP #$03                                                                                            ;  B
BEQ PUpOfs                    ; if 1-up mushroom, branch, do not change colors or flip              ; 
STA $00                       ; store power-up type here now                                        ;  B
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; divide by 2 to change colors every two frames                       ; 
AND #%00000011                ; mask out all but d1 and d0 (previously d2 and d1)                   ; 
ORA Enemy_SprAttrib+5         ; add background priority bit if any set                              ; 
STA Sprite_Attributes,Y       ; set as new palette bits for top left and                            ; 
STA Sprite_Attributes+4,Y     ; top right sprites for fire flower and star                          ; 
LDX $00                                                                                             ; 
DEX                           ; check power-up type for fire flower                                 ; 
BEQ FlipPUpRightSide          ; if found, skip this part                                            ; 
STA Sprite_Attributes+8,Y     ; otherwise set new palette bits  for bottom left                     ;  B
STA Sprite_Attributes+12,Y    ; and bottom right sprites as well for star only                      ; 
                                                                                                    ; 
FlipPUpRightSide:                                                                                   ;  B
LDA Sprite_Attributes+4,Y                                                                           ; 
ORA #%01000000                ; set horizontal flip bit for top right sprite                        ; 
STA Sprite_Attributes+4,Y                                                                           ; 
LDA Sprite_Attributes+12,Y                                                                          ; 
ORA #%01000000                ; set horizontal flip bit for bottom right sprite                     ; 
STA Sprite_Attributes+12,Y    ; note these are only done for fire flower and star power-ups         ; 
PUpOfs:  JMP SprObjectOffscrChk; jump to check to see if power-up is offscreen at all, then leave   ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers       ; 
                              ; $02 - used to store Y position                                      ; 
                              ; $03 - used to store moving direction, used to flip enemies horizontally; 
                              ; $04 - used to store enemy's sprite attributes                       ; 
                              ; $05 - used to store X position                                      ; 
                              ; $eb - used to hold sprite data offset                               ; 
                              ; $ec - used to hold either altered enemy state or special value used in gfx handler as condition; 
                              ; $ed - used to hold enemy state from buffer                          ; 
                              ; $ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values); 
                                                                                                    ; 
                              ; tiles arranged in top left, right, middle left, right, bottom left, right order; 
EnemyGraphicsTable:                                                                                 ;  B
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=170), ByteValue(value=171), ByteValue(value=172), ByteValue(value=173); buzzy beetle frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=174), ByteValue(value=175), ByteValue(value=176), ByteValue(value=177); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=165), ByteValue(value=166), ByteValue(value=167), ByteValue(value=168), ByteValue(value=169); koopa troopa frame 1; 
DATA: ByteValue(value=252), ByteValue(value=160), ByteValue(value=161), ByteValue(value=162), ByteValue(value=163), ByteValue(value=164); frame 2; 
DATA: ByteValue(value=105), ByteValue(value=165), ByteValue(value=106), ByteValue(value=167), ByteValue(value=168), ByteValue(value=169); koopa paratroopa frame 1; 
DATA: ByteValue(value=107), ByteValue(value=160), ByteValue(value=108), ByteValue(value=162), ByteValue(value=163), ByteValue(value=164); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=150), ByteValue(value=151), ByteValue(value=152), ByteValue(value=153); spiny frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=154), ByteValue(value=155), ByteValue(value=156), ByteValue(value=157); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=143), ByteValue(value=142), ByteValue(value=142), ByteValue(value=143); spiny's egg frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=149), ByteValue(value=148), ByteValue(value=148), ByteValue(value=149); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=220), ByteValue(value=220), ByteValue(value=223), ByteValue(value=223); bloober frame 1; 
DATA: ByteValue(value=220), ByteValue(value=220), ByteValue(value=221), ByteValue(value=221), ByteValue(value=222), ByteValue(value=222); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=178), ByteValue(value=179), ByteValue(value=180), ByteValue(value=181); cheep-cheep frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=182), ByteValue(value=179), ByteValue(value=183), ByteValue(value=181); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=112), ByteValue(value=113), ByteValue(value=114), ByteValue(value=115); goomba; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=110), ByteValue(value=110), ByteValue(value=111), ByteValue(value=111); koopa shell frame 1 (upside-down); 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=109), ByteValue(value=109), ByteValue(value=111), ByteValue(value=111); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=111), ByteValue(value=111), ByteValue(value=110), ByteValue(value=110); koopa shell frame 1 (rightsideup); 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=111), ByteValue(value=111), ByteValue(value=109), ByteValue(value=109); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=244), ByteValue(value=244), ByteValue(value=245), ByteValue(value=245); buzzy beetle shell frame 1 (rightsideup); 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=244), ByteValue(value=244), ByteValue(value=245), ByteValue(value=245); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=245), ByteValue(value=245), ByteValue(value=244), ByteValue(value=244); buzzy beetle shell frame 1 (upside-down); 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=245), ByteValue(value=245), ByteValue(value=244), ByteValue(value=244); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=239), ByteValue(value=239); defeated goomba; 
DATA: ByteValue(value=185), ByteValue(value=184), ByteValue(value=187), ByteValue(value=186), ByteValue(value=188), ByteValue(value=188); lakitu frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=189), ByteValue(value=189), ByteValue(value=188), ByteValue(value=188); frame 2; 
DATA: ByteValue(value=122), ByteValue(value=123), ByteValue(value=218), ByteValue(value=219), ByteValue(value=216), ByteValue(value=216); princess; 
DATA: ByteValue(value=205), ByteValue(value=205), ByteValue(value=206), ByteValue(value=206), ByteValue(value=207), ByteValue(value=207); mushroom retainer; 
DATA: ByteValue(value=125), ByteValue(value=124), ByteValue(value=209), ByteValue(value=140), ByteValue(value=211), ByteValue(value=210); hammer bro frame 1; 
DATA: ByteValue(value=125), ByteValue(value=124), ByteValue(value=137), ByteValue(value=136), ByteValue(value=139), ByteValue(value=138); frame 2; 
DATA: ByteValue(value=213), ByteValue(value=212), ByteValue(value=227), ByteValue(value=226), ByteValue(value=211), ByteValue(value=210); frame 3; 
DATA: ByteValue(value=213), ByteValue(value=212), ByteValue(value=227), ByteValue(value=226), ByteValue(value=139), ByteValue(value=138); frame 4; 
DATA: ByteValue(value=229), ByteValue(value=229), ByteValue(value=230), ByteValue(value=230), ByteValue(value=235), ByteValue(value=235); piranha plant frame 1; 
DATA: ByteValue(value=236), ByteValue(value=236), ByteValue(value=237), ByteValue(value=237), ByteValue(value=238), ByteValue(value=238); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=208), ByteValue(value=208), ByteValue(value=215), ByteValue(value=215); podoboo; 
DATA: ByteValue(value=191), ByteValue(value=190), ByteValue(value=193), ByteValue(value=192), ByteValue(value=194), ByteValue(value=252); bowser front frame 1; 
DATA: ByteValue(value=196), ByteValue(value=195), ByteValue(value=198), ByteValue(value=197), ByteValue(value=200), ByteValue(value=199); bowser rear frame 1; 
DATA: ByteValue(value=191), ByteValue(value=190), ByteValue(value=202), ByteValue(value=201), ByteValue(value=194), ByteValue(value=252); front frame 2; 
DATA: ByteValue(value=196), ByteValue(value=195), ByteValue(value=198), ByteValue(value=197), ByteValue(value=204), ByteValue(value=203); rear frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=232), ByteValue(value=231), ByteValue(value=234), ByteValue(value=233); bullet bill; 
DATA: ByteValue(value=242), ByteValue(value=242), ByteValue(value=243), ByteValue(value=243), ByteValue(value=242), ByteValue(value=242); jumpspring frame 1; 
DATA: ByteValue(value=241), ByteValue(value=241), ByteValue(value=241), ByteValue(value=241), ByteValue(value=252), ByteValue(value=252); frame 2; 
DATA: ByteValue(value=240), ByteValue(value=240), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252); frame 3; 
                                                                                                    ; 
EnemyGfxTableOffsets:                                                                               ;  B
DATA: ByteValue(value=12), ByteValue(value=12), ByteValue(value=0), ByteValue(value=12), ByteValue(value=12), ByteValue(value=168), ByteValue(value=84), ByteValue(value=60); 
DATA: ByteValue(value=234), ByteValue(value=24), ByteValue(value=72), ByteValue(value=72), ByteValue(value=204), ByteValue(value=192), ByteValue(value=24), ByteValue(value=24); 
DATA: ByteValue(value=24), ByteValue(value=144), ByteValue(value=36), ByteValue(value=255), ByteValue(value=72), ByteValue(value=156), ByteValue(value=210), ByteValue(value=216); 
DATA: ByteValue(value=240), ByteValue(value=246), ByteValue(value=252)                              ; 
                                                                                                    ; 
EnemyAttributeData:                                                                                 ;  B
DATA: ByteValue(value=1), ByteValue(value=2), ByteValue(value=3), ByteValue(value=2), ByteValue(value=1), ByteValue(value=1), ByteValue(value=3), ByteValue(value=3); 
DATA: ByteValue(value=3), ByteValue(value=1), ByteValue(value=1), ByteValue(value=2), ByteValue(value=2), ByteValue(value=33), ByteValue(value=1), ByteValue(value=2); 
DATA: ByteValue(value=1), ByteValue(value=1), ByteValue(value=2), ByteValue(value=255), ByteValue(value=2), ByteValue(value=2), ByteValue(value=1), ByteValue(value=1); 
DATA: ByteValue(value=2), ByteValue(value=2), ByteValue(value=2)                                    ; 
                                                                                                    ; 
EnemyAnimTimingBMask:                                                                               ;  B
DATA: ByteValue(value=8), ByteValue(value=24)                                                       ; 
                                                                                                    ; 
JumpspringFrameOffsets:                                                                             ;  B
DATA: ByteValue(value=24), ByteValue(value=25), ByteValue(value=26), ByteValue(value=25), ByteValue(value=24); 
                                                                                                    ; 
EnemyGfxHandler:                                                                                    ; fun():  B
LDA Enemy_Y_Position,X        ; get enemy object vertical position                                  ; 
STA $02                                                                                             ; 
LDA Enemy_Rel_XPos            ; get enemy object horizontal position                                ; 
STA $05                       ; relative to screen                                                  ; 
LDY Enemy_SprDataOffset,X                                                                           ; 
STY $eb                       ; get sprite data offset                                              ; 
LDA #$00                                                                                            ; 
STA VerticalFlipFlag          ; initialize vertical flip flag by default                            ; 
LDA Enemy_MovingDir,X                                                                               ; 
STA $03                       ; get enemy object moving direction                                   ; 
LDA Enemy_SprAttrib,X                                                                               ; 
STA $04                       ; get enemy object sprite attributes                                  ; 
LDA Enemy_ID,X                                                                                      ; 
CMP #PiranhaPlant             ; is enemy object piranha plant?                                      ; 
BNE CheckForRetainerObj       ; if not, branch                                                      ; 
LDY PiranhaPlant_Y_Speed,X                                                                          ;  B
BMI CheckForRetainerObj       ; if piranha plant moving upwards, branch                             ; 
LDY EnemyFrameTimer,X                                                                               ;  B
BEQ CheckForRetainerObj       ; if timer for movement expired, branch                               ; 
RTS                           ; if all conditions fail, leave                                       ;  B
                                                                                                    ;  B
CheckForRetainerObj:                                                                                ;  B
LDA Enemy_State,X             ; store enemy state                                                   ; 
STA $ed                                                                                             ; 
AND #%00011111                ; nullify all but 5 LSB and use as Y                                  ; 
TAY                                                                                                 ; 
LDA Enemy_ID,X                ; check for mushroom retainer/princess object                         ; 
CMP #RetainerObject                                                                                 ; 
BNE CheckForBulletBillCV      ; if not found, branch                                                ; 
LDY #$00                      ; if found, nullify saved state in Y                                  ;  B
LDA #$01                      ; set value that will not be used                                     ; 
STA $03                                                                                             ; 
LDA #$15                      ; set value $15 as code for mushroom retainer/princess object         ; 
                                                                                                    ; 
CheckForBulletBillCV:                                                                               ;  B
CMP #BulletBill_CannonVar     ; otherwise check for bullet bill object                              ; 
BNE CheckForJumpspring        ; if not found, branch again                                          ; 
DEC $02                       ; decrement saved vertical position                                   ;  B
LDA #$03                                                                                            ; 
LDY EnemyFrameTimer,X         ; get timer for enemy object                                          ; 
BEQ SBBAt                     ; if expired, do not set priority bit                                 ; 
ORA #%00100000                ; otherwise do so                                                     ;  B
SBBAt:  STA $04               ; set new sprite attributes                                           ;  B
LDY #$00                      ; nullify saved enemy state both in Y and in                          ; 
STY $ed                       ; memory location here                                                ; 
LDA #$08                      ; set specific value to unconditionally branch once                   ; 
                                                                                                    ; 
CheckForJumpspring:                                                                                 ;  B
CMP #JumpspringObject         ; check for jumpspring object                                         ; 
BNE CheckForPodoboo                                                                                 ; 
LDY #$03                      ; set enemy state -2 MSB here for jumpspring object                   ;  B
LDX JumpspringAnimCtrl        ; get current frame number for jumpspring object                      ; 
LDA JumpspringFrameOffsets,X  ; load data using frame number as offset                              ; 
                                                                                                    ; 
CheckForPodoboo:                                                                                    ;  B
STA $ef                       ; store saved enemy object value here                                 ; 
STY $ec                       ; and Y here (enemy state -2 MSB if not changed)                      ; 
LDX ObjectOffset              ; get enemy object offset                                             ; 
CMP #$0c                      ; check for podoboo object                                            ; 
BNE CheckBowserGfxFlag        ; branch if not found                                                 ; 
LDA Enemy_Y_Speed,X           ; if moving upwards, branch                                           ;  B
BMI CheckBowserGfxFlag                                                                              ; 
INC VerticalFlipFlag          ; otherwise, set flag for vertical flip                               ;  B
                                                                                                    ; 
CheckBowserGfxFlag:                                                                                 ;  B
LDA BowserGfxFlag             ; if not drawing bowser at all, skip to something else                ; 
BEQ CheckForGoomba                                                                                  ; 
LDY #$16                      ; if set to 1, draw bowser's front                                    ;  B
CMP #$01                                                                                            ; 
BEQ SBwsrGfxOfs                                                                                     ; 
INY                           ; otherwise draw bowser's rear                                        ;  B
SBwsrGfxOfs:  STY $ef                                                                               ;  B
                                                                                                    ; 
CheckForGoomba:                                                                                     ;  B
LDY $ef                       ; check value for goomba object                                       ; 
CPY #Goomba                                                                                         ; 
BNE CheckBowserFront          ; branch if not found                                                 ; 
LDA Enemy_State,X                                                                                   ;  B
CMP #$02                      ; check for defeated state                                            ; 
BCC GmbaAnim                  ; if not defeated, go ahead and animate                               ; 
LDX #$04                      ; if defeated, write new value here                                   ;  B
STX $ec                                                                                             ; 
GmbaAnim:  AND #%00100000     ; check for d5 set in enemy object state                              ;  B
ORA TimerControl              ; or timer disable flag set                                           ; 
BNE CheckBowserFront          ; if either condition true, do not animate goomba                     ; 
LDA FrameCounter                                                                                    ;  B
AND #%00001000                ; check for every eighth frame                                        ; 
BNE CheckBowserFront                                                                                ; 
LDA $03                                                                                             ;  B
EOR #%00000011                ; invert bits to flip horizontally every eight frames                 ; 
STA $03                       ; leave alone otherwise                                               ; 
                                                                                                    ; 
CheckBowserFront:                                                                                   ;  B
LDA EnemyAttributeData,Y      ; load sprite attribute using enemy object                            ; 
ORA $04                       ; as offset, and add to bits already loaded                           ; 
STA $04                                                                                             ; 
LDA EnemyGfxTableOffsets,Y    ; load value based on enemy object as offset                          ; 
TAX                           ; save as X                                                           ; 
LDY $ec                       ; get previously saved value                                          ; 
LDA BowserGfxFlag                                                                                   ; 
BEQ CheckForSpiny             ; if not drawing bowser object at all, skip all of this               ; 
CMP #$01                                                                                            ;  B
BNE CheckBowserRear           ; if not drawing front part, branch to draw the rear part             ; 
LDA BowserBodyControls        ; check bowser's body control bits                                    ;  B
BPL ChkFrontSte               ; branch if d7 not set (control's bowser's mouth)                     ; 
LDX #$de                      ; otherwise load offset for second frame                              ;  B
ChkFrontSte:  LDA $ed         ; check saved enemy state                                             ;  B
AND #%00100000                ; if bowser not defeated, do not set flag                             ; 
BEQ DrawBowser                                                                                      ; 
                                                                                                    ;  B
FlipBowserOver:                                                                                     ;  B
STX VerticalFlipFlag          ; set vertical flip flag to nonzero                                   ; 
                                                                                                    ; 
DrawBowser:                                                                                         ;  B
JMP DrawEnemyObject           ; draw bowser's graphics now                                          ; 
                                                                                                    ;  B
CheckBowserRear:                                                                                    ;  B
LDA BowserBodyControls        ; check bowser's body control bits                                    ; 
AND #$01                                                                                            ; 
BEQ ChkRearSte                ; branch if d0 not set (control's bowser's feet)                      ; 
LDX #$e4                      ; otherwise load offset for second frame                              ;  B
ChkRearSte:  LDA $ed          ; check saved enemy state                                             ;  B
AND #%00100000                ; if bowser not defeated, do not set flag                             ; 
BEQ DrawBowser                                                                                      ; 
LDA $02                       ; subtract 16 pixels from                                             ;  B
SEC                           ; saved vertical coordinate                                           ; 
SBC #$10                                                                                            ; 
STA $02                                                                                             ; 
JMP FlipBowserOver            ; jump to set vertical flip flag                                      ; 
                                                                                                    ;  B
CheckForSpiny:                                                                                      ;  B
CPX #$24                      ; check if value loaded is for spiny                                  ; 
BNE CheckForLakitu            ; if not found, branch                                                ; 
CPY #$05                      ; if enemy state set to $05, do this,                                 ;  B
BNE NotEgg                    ; otherwise branch                                                    ; 
LDX #$30                      ; set to spiny egg offset                                             ;  B
LDA #$02                                                                                            ; 
STA $03                       ; set enemy direction to reverse sprites horizontally                 ; 
LDA #$05                                                                                            ; 
STA $ec                       ; set enemy state                                                     ; 
NotEgg:  JMP CheckForHammerBro; skip a big chunk of this if we found spiny but not in egg           ;  B
                                                                                                    ;  B
CheckForLakitu:                                                                                     ;  B
CPX #$90                      ; check value for lakitu's offset loaded                              ; 
BNE CheckUpsideDownShell      ; branch if not loaded                                                ; 
LDA $ed                                                                                             ;  B
AND #%00100000                ; check for d5 set in enemy state                                     ; 
BNE NoLAFr                    ; branch if set                                                       ; 
LDA FrenzyEnemyTimer                                                                                ;  B
CMP #$10                      ; check timer to see if we've reached a certain range                 ; 
BCS NoLAFr                    ; branch if not                                                       ; 
LDX #$96                      ; if d6 not set and timer in range, load alt frame for lakitu         ;  B
NoLAFr:  JMP CheckDefeatedState; skip this next part if we found lakitu but alt frame not needed    ;  B
                                                                                                    ;  B
CheckUpsideDownShell:                                                                               ;  B
LDA $ef                       ; check for enemy object => $04                                       ; 
CMP #$04                                                                                            ; 
BCS CheckRightSideUpShell     ; branch if true                                                      ; 
CPY #$02                                                                                            ;  B
BCC CheckRightSideUpShell     ; branch if enemy state < $02                                         ; 
LDX #$5a                      ; set for upside-down koopa shell by default                          ;  B
LDY $ef                                                                                             ; 
CPY #BuzzyBeetle              ; check for buzzy beetle object                                       ; 
BNE CheckRightSideUpShell                                                                           ; 
LDX #$7e                      ; set for upside-down buzzy beetle shell if found                     ;  B
INC $02                       ; increment vertical position by one pixel                            ; 
                                                                                                    ; 
CheckRightSideUpShell:                                                                              ;  B
LDA $ec                       ; check for value set here                                            ; 
CMP #$04                      ; if enemy state < $02, do not change to shell, if                    ; 
BNE CheckForHammerBro         ; enemy state => $02 but not = $04, leave shell upside-down           ; 
LDX #$72                      ; set right-side up buzzy beetle shell by default                     ;  B
INC $02                       ; increment saved vertical position by one pixel                      ; 
LDY $ef                                                                                             ; 
CPY #BuzzyBeetle              ; check for buzzy beetle object                                       ; 
BEQ CheckForDefdGoomba        ; branch if found                                                     ; 
LDX #$66                      ; change to right-side up koopa shell if not found                    ;  B
INC $02                       ; and increment saved vertical position again                         ; 
                                                                                                    ; 
CheckForDefdGoomba:                                                                                 ;  B
CPY #Goomba                   ; check for goomba object (necessary if previously                    ; 
BNE CheckForHammerBro         ; failed buzzy beetle object test)                                    ; 
LDX #$54                      ; load for regular goomba                                             ;  B
LDA $ed                       ; note that this only gets performed if enemy state => $02            ; 
AND #%00100000                ; check saved enemy state for d5 set                                  ; 
BNE CheckForHammerBro         ; branch if set                                                       ; 
LDX #$8a                      ; load offset for defeated goomba                                     ;  B
DEC $02                       ; set different value and decrement saved vertical position           ; 
                                                                                                    ; 
CheckForHammerBro:                                                                                  ;  B
LDY ObjectOffset                                                                                    ; 
LDA $ef                       ; check for hammer bro object                                         ; 
CMP #HammerBro                                                                                      ; 
BNE CheckForBloober           ; branch if not found                                                 ; 
LDA $ed                                                                                             ;  B
BEQ CheckToAnimateEnemy       ; branch if not in normal enemy state                                 ; 
AND #%00001000                                                                                      ;  B
BEQ CheckDefeatedState        ; if d3 not set, branch further away                                  ; 
LDX #$b4                      ; otherwise load offset for different frame                           ;  B
BNE CheckToAnimateEnemy       ; unconditional branch                                                ; 
                                                                                                    ;  B
CheckForBloober:                                                                                    ;  B
CPX #$48                      ; check for cheep-cheep offset loaded                                 ; 
BEQ CheckToAnimateEnemy       ; branch if found                                                     ; 
LDA EnemyIntervalTimer,Y                                                                            ;  B
CMP #$05                                                                                            ; 
BCS CheckDefeatedState        ; branch if some timer is above a certain point                       ; 
CPX #$3c                      ; check for bloober offset loaded                                     ;  B
BNE CheckToAnimateEnemy       ; branch if not found this time                                       ; 
CMP #$01                                                                                            ;  B
BEQ CheckDefeatedState        ; branch if timer is set to certain point                             ; 
INC $02                       ; increment saved vertical coordinate three pixels                    ;  B
INC $02                                                                                             ; 
INC $02                                                                                             ; 
JMP CheckAnimationStop        ; and do something else                                               ; 
                                                                                                    ;  B
CheckToAnimateEnemy:                                                                                ;  B
LDA $ef                       ; check for specific enemy objects                                    ; 
CMP #Goomba                                                                                         ; 
BEQ CheckDefeatedState        ; branch if goomba                                                    ; 
CMP #$08                                                                                            ;  B
BEQ CheckDefeatedState        ; branch if bullet bill (note both variants use $08 here)             ; 
CMP #Podoboo                                                                                        ;  B
BEQ CheckDefeatedState        ; branch if podoboo                                                   ; 
CMP #$18                      ; branch if => $18                                                    ;  B
BCS CheckDefeatedState                                                                              ; 
LDY #$00                                                                                            ;  B
CMP #$15                      ; check for mushroom retainer/princess object                         ; 
BNE CheckForSecondFrame       ; which uses different code here, branch if not found                 ; 
INY                           ; residual instruction                                                ;  B
LDA WorldNumber               ; are we on world 8?                                                  ; 
CMP #World8                                                                                         ; 
BCS CheckDefeatedState        ; if so, leave the offset alone (use princess)                        ; 
LDX #$a2                      ; otherwise, set for mushroom retainer object instead                 ;  B
LDA #$03                      ; set alternate state here                                            ; 
STA $ec                                                                                             ; 
BNE CheckDefeatedState        ; unconditional branch                                                ; 
                                                                                                    ;  B
CheckForSecondFrame:                                                                                ;  B
LDA FrameCounter              ; load frame counter                                                  ; 
AND EnemyAnimTimingBMask,Y    ; mask it (partly residual, one byte not ever used)                   ; 
BNE CheckDefeatedState        ; branch if timing is off                                             ; 
                                                                                                    ;  B
CheckAnimationStop:                                                                                 ;  B
LDA $ed                       ; check saved enemy state                                             ; 
AND #%10100000                ; for d7 or d5, or check for timers stopped                           ; 
ORA TimerControl                                                                                    ; 
BNE CheckDefeatedState        ; if either condition true, branch                                    ; 
TXA                                                                                                 ;  B
CLC                                                                                                 ; 
ADC #$06                      ; add $06 to current enemy offset                                     ; 
TAX                           ; to animate various enemy objects                                    ; 
                                                                                                    ; 
CheckDefeatedState:                                                                                 ;  B
LDA $ed                       ; check saved enemy state                                             ; 
AND #%00100000                ; for d5 set                                                          ; 
BEQ DrawEnemyObject           ; branch if not set                                                   ; 
LDA $ef                                                                                             ;  B
CMP #$04                      ; check for saved enemy object => $04                                 ; 
BCC DrawEnemyObject           ; branch if less                                                      ; 
LDY #$01                                                                                            ;  B
STY VerticalFlipFlag          ; set vertical flip flag                                              ; 
DEY                                                                                                 ; 
STY $ec                       ; init saved value here                                               ; 
                                                                                                    ; 
DrawEnemyObject:                                                                                    ;  B
LDY $eb                       ; load sprite data offset                                             ; 
JSR DrawEnemyObjRow           ; draw six tiles of data                                              ; 
JSR DrawEnemyObjRow           ; into sprite data                                                    ; 
JSR DrawEnemyObjRow                                                                                 ; 
LDX ObjectOffset              ; get enemy object offset                                             ; 
LDY Enemy_SprDataOffset,X     ; get sprite data offset                                              ; 
LDA $ef                                                                                             ; 
CMP #$08                      ; get saved enemy object and check                                    ; 
BNE CheckForVerticalFlip      ; for bullet bill, branch if not found                                ; 
                                                                                                    ;  B
SkipToOffScrChk:                                                                                    ;  B
JMP SprObjectOffscrChk        ; jump if found                                                       ; 
                                                                                                    ;  B
CheckForVerticalFlip:                                                                               ;  B
LDA VerticalFlipFlag          ; check if vertical flip flag is set here                             ; 
BEQ CheckForESymmetry         ; branch if not                                                       ; 
LDA Sprite_Attributes,Y       ; get attributes of first sprite we dealt with                        ;  B
ORA #%10000000                ; set bit for vertical flip                                           ; 
INY                                                                                                 ; 
INY                           ; increment two bytes so that we store the vertical flip              ; 
JSR DumpSixSpr                ; in attribute bytes of enemy obj sprite data                         ; 
DEY                                                                                                 ; 
DEY                           ; now go back to the Y coordinate offset                              ; 
TYA                                                                                                 ; 
TAX                           ; give offset to X                                                    ; 
LDA $ef                                                                                             ; 
CMP #HammerBro                ; check saved enemy object for hammer bro                             ; 
BEQ FlipEnemyVertically                                                                             ; 
CMP #Lakitu                   ; check saved enemy object for lakitu                                 ;  B
BEQ FlipEnemyVertically       ; branch for hammer bro or lakitu                                     ; 
CMP #$15                                                                                            ;  B
BCS FlipEnemyVertically       ; also branch if enemy object => $15                                  ; 
TXA                                                                                                 ;  B
CLC                                                                                                 ; 
ADC #$08                      ; if not selected objects or => $15, set                              ; 
TAX                           ; offset in X for next row                                            ; 
                                                                                                    ; 
FlipEnemyVertically:                                                                                ;  B
LDA Sprite_Tilenumber,X       ; load first or second row tiles                                      ; 
PHA                           ; and save tiles to the stack                                         ; 
LDA Sprite_Tilenumber+4,X                                                                           ; 
PHA                                                                                                 ; 
LDA Sprite_Tilenumber+16,Y    ; exchange third row tiles                                            ; 
STA Sprite_Tilenumber,X       ; with first or second row tiles                                      ; 
LDA Sprite_Tilenumber+20,Y                                                                          ; 
STA Sprite_Tilenumber+4,X                                                                           ; 
PLA                           ; pull first or second row tiles from stack                           ; 
STA Sprite_Tilenumber+20,Y    ; and save in third row                                               ; 
PLA                                                                                                 ; 
STA Sprite_Tilenumber+16,Y                                                                          ; 
                                                                                                    ; 
CheckForESymmetry:                                                                                  ;  B
LDA BowserGfxFlag             ; are we drawing bowser at all?                                       ; 
BNE SkipToOffScrChk           ; branch if so                                                        ; 
LDA $ef                                                                                             ;  B
LDX $ec                       ; get alternate enemy state                                           ; 
CMP #$05                      ; check for hammer bro object                                         ; 
BNE ContES                                                                                          ; 
JMP SprObjectOffscrChk        ; jump if found                                                       ;  B
ContES:  CMP #Bloober         ; check for bloober object                                            ;  B
BEQ MirrorEnemyGfx                                                                                  ; 
CMP #PiranhaPlant             ; check for piranha plant object                                      ;  B
BEQ MirrorEnemyGfx                                                                                  ; 
CMP #Podoboo                  ; check for podoboo object                                            ;  B
BEQ MirrorEnemyGfx            ; branch if either of three are found                                 ; 
CMP #Spiny                    ; check for spiny object                                              ;  B
BNE ESRtnr                    ; branch closer if not found                                          ; 
CPX #$05                      ; check spiny's state                                                 ;  B
BNE CheckToMirrorLakitu       ; branch if not an egg, otherwise                                     ; 
ESRtnr:  CMP #$15             ; check for princess/mushroom retainer object                         ;  B
BNE SpnySC                                                                                          ; 
LDA #$42                      ; set horizontal flip on bottom right sprite                          ;  B
STA Sprite_Attributes+20,Y    ; note that palette bits were already set earlier                     ; 
SpnySC:  CPX #$02             ; if alternate enemy state set to 1 or 0, branch                      ;  B
BCC CheckToMirrorLakitu                                                                             ; 
                                                                                                    ;  B
MirrorEnemyGfx:                                                                                     ;  B
LDA BowserGfxFlag             ; if enemy object is bowser, skip all of this                         ; 
BNE CheckToMirrorLakitu                                                                             ; 
LDA Sprite_Attributes,Y       ; load attribute bits of first sprite                                 ;  B
AND #%10100011                                                                                      ; 
STA Sprite_Attributes,Y       ; save vertical flip, priority, and palette bits                      ; 
STA Sprite_Attributes+8,Y     ; in left sprite column of enemy object OAM data                      ; 
STA Sprite_Attributes+16,Y                                                                          ; 
ORA #%01000000                ; set horizontal flip                                                 ; 
CPX #$05                      ; check for state used by spiny's egg                                 ; 
BNE EggExc                    ; if alternate state not set to $05, branch                           ; 
ORA #%10000000                ; otherwise set vertical flip                                         ;  B
EggExc:  STA Sprite_Attributes+4,Y; set bits of right sprite column                                 ;  B
STA Sprite_Attributes+12,Y    ; of enemy object sprite data                                         ; 
STA Sprite_Attributes+20,Y                                                                          ; 
CPX #$04                      ; check alternate enemy state                                         ; 
BNE CheckToMirrorLakitu       ; branch if not $04                                                   ; 
LDA Sprite_Attributes+8,Y     ; get second row left sprite attributes                               ;  B
ORA #%10000000                                                                                      ; 
STA Sprite_Attributes+8,Y     ; store bits with vertical flip in                                    ; 
STA Sprite_Attributes+16,Y    ; second and third row left sprites                                   ; 
ORA #%01000000                                                                                      ; 
STA Sprite_Attributes+12,Y    ; store with horizontal and vertical flip in                          ; 
STA Sprite_Attributes+20,Y    ; second and third row right sprites                                  ; 
                                                                                                    ; 
CheckToMirrorLakitu:                                                                                ;  B
LDA $ef                       ; check for lakitu enemy object                                       ; 
CMP #Lakitu                                                                                         ; 
BNE CheckToMirrorJSpring      ; branch if not found                                                 ; 
LDA VerticalFlipFlag                                                                                ;  B
BNE NVFLak                    ; branch if vertical flip flag not set                                ; 
LDA Sprite_Attributes+16,Y    ; save vertical flip and palette bits                                 ;  B
AND #%10000001                ; in third row left sprite                                            ; 
STA Sprite_Attributes+16,Y                                                                          ; 
LDA Sprite_Attributes+20,Y    ; set horizontal flip and palette bits                                ; 
ORA #%01000001                ; in third row right sprite                                           ; 
STA Sprite_Attributes+20,Y                                                                          ; 
LDX FrenzyEnemyTimer          ; check timer                                                         ; 
CPX #$10                                                                                            ; 
BCS SprObjectOffscrChk        ; branch if timer has not reached a certain range                     ; 
STA Sprite_Attributes+12,Y    ; otherwise set same for second row right sprite                      ;  B
AND #%10000001                                                                                      ; 
STA Sprite_Attributes+8,Y     ; preserve vertical flip and palette bits for left sprite             ; 
BCC SprObjectOffscrChk        ; unconditional branch                                                ; 
NVFLak:  LDA Sprite_Attributes,Y; get first row left sprite attributes                              ;  B
AND #%10000001                                                                                      ; 
STA Sprite_Attributes,Y       ; save vertical flip and palette bits                                 ; 
LDA Sprite_Attributes+4,Y     ; get first row right sprite attributes                               ; 
ORA #%01000001                ; set horizontal flip and palette bits                                ; 
STA Sprite_Attributes+4,Y     ; note that vertical flip is left as-is                               ; 
                                                                                                    ; 
CheckToMirrorJSpring:                                                                               ;  B
LDA $ef                       ; check for jumpspring object (any frame)                             ; 
CMP #$18                                                                                            ; 
BCC SprObjectOffscrChk        ; branch if not jumpspring object at all                              ; 
LDA #$82                                                                                            ;  B
STA Sprite_Attributes+8,Y     ; set vertical flip and palette bits of                               ; 
STA Sprite_Attributes+16,Y    ; second and third row left sprites                                   ; 
ORA #%01000000                                                                                      ; 
STA Sprite_Attributes+12,Y    ; set, in addition to those, horizontal flip                          ; 
STA Sprite_Attributes+20,Y    ; for second and third row right sprites                              ; 
                                                                                                    ; 
SprObjectOffscrChk:                                                                                 ;  B
LDX ObjectOffset              ; get enemy buffer offset                                             ; 
LDA Enemy_OffscreenBits       ; check offscreen information                                         ; 
LSR                                                                                                 ; 
LSR                           ; shift three times to the right                                      ; 
LSR                           ; which puts d2 into carry                                            ; 
PHA                           ; save to stack                                                       ; 
BCC LcChk                     ; branch if not set                                                   ; 
LDA #$04                      ; set for right column sprites                                        ;  B
JSR MoveESprColOffscreen      ; and move them offscreen                                             ; 
LcChk:  PLA                   ; get from stack                                                      ;  B
LSR                           ; move d3 to carry                                                    ; 
PHA                           ; save to stack                                                       ; 
BCC Row3C                     ; branch if not set                                                   ; 
LDA #$00                      ; set for left column sprites,                                        ;  B
JSR MoveESprColOffscreen      ; move them offscreen                                                 ; 
Row3C:  PLA                   ; get from stack again                                                ;  B
LSR                           ; move d5 to carry this time                                          ; 
LSR                                                                                                 ; 
PHA                           ; save to stack again                                                 ; 
BCC Row23C                    ; branch if carry not set                                             ; 
LDA #$10                      ; set for third row of sprites                                        ;  B
JSR MoveESprRowOffscreen      ; and move them offscreen                                             ; 
Row23C:  PLA                  ; get from stack                                                      ;  B
LSR                           ; move d6 into carry                                                  ; 
PHA                           ; save to stack                                                       ; 
BCC AllRowC                                                                                         ; 
LDA #$08                      ; set for second and third rows                                       ;  B
JSR MoveESprRowOffscreen      ; move them offscreen                                                 ; 
AllRowC:  PLA                 ; get from stack once more                                            ;  B
LSR                           ; move d7 into carry                                                  ; 
BCC ExEGHandler                                                                                     ; 
JSR MoveESprRowOffscreen      ; move all sprites offscreen (A should be 0 by now)                   ;  B
LDA Enemy_ID,X                                                                                      ; 
CMP #Podoboo                  ; check enemy identifier for podoboo                                  ; 
BEQ ExEGHandler               ; skip this part if found, we do not want to erase podoboo!           ; 
LDA Enemy_Y_HighPos,X         ; check high byte of vertical position                                ;  B
CMP #$02                      ; if not yet past the bottom of the screen, branch                    ; 
BNE ExEGHandler                                                                                     ; 
JSR EraseEnemyObject          ; what it says                                                        ;  B
                                                                                                    ; 
ExEGHandler:                                                                                        ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
DrawEnemyObjRow:                                                                                    ; fun():  B
LDA EnemyGraphicsTable,X      ; load two tiles of enemy graphics                                    ; 
STA $00                                                                                             ; 
LDA EnemyGraphicsTable+1,X                                                                          ; 
                                                                                                    ; 
DrawOneSpriteRow:                                                                                   ; fun(A$03$00$04$02$05YX): X B
STA $01                                                                                             ; 
JMP DrawSpriteObject          ; draw them                                                           ; 
                                                                                                    ;  B
MoveESprRowOffscreen:                                                                               ; fun(A):  B
CLC                           ; add A to enemy object OAM data offset                               ; 
ADC Enemy_SprDataOffset,X                                                                           ; 
TAY                           ; use as offset                                                       ; 
LDA #$f8                                                                                            ; 
JMP DumpTwoSpr                ; move first row of sprites offscreen                                 ; 
                                                                                                    ;  B
MoveESprColOffscreen:                                                                               ; fun(A):  B
CLC                           ; add A to enemy object OAM data offset                               ; 
ADC Enemy_SprDataOffset,X                                                                           ; 
TAY                           ; use as offset                                                       ; 
JSR MoveColOffscreen          ; move first and second row sprites in column offscreen               ; 
STA Sprite_Data+16,Y          ; move third row sprite in column offscreen                           ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - tile numbers                                              ; 
                              ; $02 - relative Y position                                           ; 
                              ; $03 - horizontal flip flag (not used here)                          ; 
                              ; $04 - attributes                                                    ; 
                              ; $05 - relative X position                                           ; 
                                                                                                    ; 
DefaultBlockObjTiles:                                                                               ;  B
DATA: ByteValue(value=133), ByteValue(value=133), ByteValue(value=134), ByteValue(value=134); brick w/ line (these are sprite tiles, not BG!); 
                                                                                                    ; 
DrawBlock:                                                                                          ; fun():  B
LDA Block_Rel_YPos            ; get relative vertical coordinate of block object                    ; 
STA $02                       ; store here                                                          ; 
LDA Block_Rel_XPos            ; get relative horizontal coordinate of block object                  ; 
STA $05                       ; store here                                                          ; 
LDA #$03                                                                                            ; 
STA $04                       ; set attribute byte here                                             ; 
LSR                                                                                                 ; 
STA $03                       ; set horizontal flip bit here (will not be used)                     ; 
LDY Block_SprDataOffset,X     ; get sprite data offset                                              ; 
LDX #$00                      ; reset X for use as offset to tile data                              ; 
DBlkLoop:  LDA DefaultBlockObjTiles,X; get left tile number                                         ;  B
STA $00                       ; set here                                                            ; 
LDA DefaultBlockObjTiles+1,X  ; get right tile number                                               ; 
JSR DrawOneSpriteRow          ; do sub to write tile numbers to first row of sprites                ; 
CPX #$04                      ; check incremented offset                                            ; 
BNE DBlkLoop                  ; and loop back until all four sprites are done                       ; 
LDX ObjectOffset              ; get block object offset                                             ;  B
LDY Block_SprDataOffset,X     ; get sprite data offset                                              ; 
LDA AreaType                                                                                        ; 
CMP #$01                      ; check for ground level type area                                    ; 
BEQ ChkRep                    ; if found, branch to next part                                       ; 
LDA #$86                                                                                            ;  B
STA Sprite_Tilenumber,Y       ; otherwise remove brick tiles with lines                             ; 
STA Sprite_Tilenumber+4,Y     ; and replace then with lineless brick tiles                          ; 
ChkRep:  LDA Block_Metatile,X ; check replacement metatile                                          ;  B
CMP #$c4                      ; if not used block metatile, then                                    ; 
BNE BlkOffscr                 ; branch ahead to use current graphics                                ; 
LDA #$87                      ; set A for used block tile                                           ;  B
INY                           ; increment Y to write to tile bytes                                  ; 
JSR DumpFourSpr               ; do sub to dump into all four sprites                                ; 
DEY                           ; return Y to original offset                                         ; 
LDA #$03                      ; set palette bits                                                    ; 
LDX AreaType                                                                                        ; 
DEX                           ; check for ground level type area again                              ; 
BEQ SetBFlip                  ; if found, use current palette bits                                  ; 
LSR                           ; otherwise set to $01                                                ;  B
SetBFlip:  LDX ObjectOffset   ; put block object offset back in X                                   ;  B
STA Sprite_Attributes,Y       ; store attribute byte as-is in first sprite                          ; 
ORA #%01000000                                                                                      ; 
STA Sprite_Attributes+4,Y     ; set horizontal flip bit for second sprite                           ; 
ORA #%10000000                                                                                      ; 
STA Sprite_Attributes+12,Y    ; set both flip bits for fourth sprite                                ; 
AND #%10000011                                                                                      ; 
STA Sprite_Attributes+8,Y     ; set vertical flip bit for third sprite                              ; 
BlkOffscr:  LDA Block_OffscreenBits; get offscreen bits for block object                            ;  B
PHA                           ; save to stack                                                       ; 
AND #%00000100                ; check to see if d2 in offscreen bits are set                        ; 
BEQ PullOfsB                  ; if not set, branch, otherwise move sprites offscreen                ; 
LDA #$f8                      ; move offscreen two OAMs                                             ;  B
STA Sprite_Y_Position+4,Y     ; on the right side                                                   ; 
STA Sprite_Y_Position+12,Y                                                                          ; 
PullOfsB:  PLA                ; pull offscreen bits from stack                                      ;  B
ChkLeftCo:  AND #%00001000    ; check to see if d3 in offscreen bits are set                        ; fun(A):  B
BEQ ExDBlk                    ; if not set, branch, otherwise move sprites offscreen                ; 
                                                                                                    ;  B
MoveColOffscreen:                                                                                   ; fun(): A B
LDA #$f8                      ; move offscreen two OAMs                                             ; 
STA Sprite_Y_Position,Y       ; on the left side (or two rows of enemy on either side               ; 
STA Sprite_Y_Position+8,Y     ; if branched here from enemy graphics handler)                       ; 
ExDBlk:  RTS                                                                                        ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to hold palette bits for attribute byte or relative X position; 
                                                                                                    ; 
DrawBrickChunks:                                                                                    ; fun():  B
LDA #$02                      ; set palette bits here                                               ; 
STA $00                                                                                             ; 
LDA #$75                      ; set tile number for ball (something residual, likely)               ; 
LDY GameEngineSubroutine                                                                            ; 
CPY #$05                      ; if end-of-level routine running,                                    ; 
BEQ DChunks                   ; use palette and tile number assigned                                ; 
LDA #$03                      ; otherwise set different palette bits                                ;  B
STA $00                                                                                             ; 
LDA #$84                      ; and set tile number for brick chunks                                ; 
DChunks:  LDY Block_SprDataOffset,X; get OAM data offset                                            ;  B
INY                           ; increment to start with tile bytes in OAM                           ; 
JSR DumpFourSpr               ; do sub to dump tile number into all four sprites                    ; 
LDA FrameCounter              ; get frame counter                                                   ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ASL                           ; move low nybble to high                                             ; 
ASL                                                                                                 ; 
AND #$c0                      ; get what was originally d3-d2 of low nybble                         ; 
ORA $00                       ; add palette bits                                                    ; 
INY                           ; increment offset for attribute bytes                                ; 
JSR DumpFourSpr               ; do sub to dump attribute data into all four sprites                 ; 
DEY                                                                                                 ; 
DEY                           ; decrement offset to Y coordinate                                    ; 
LDA Block_Rel_YPos            ; get first block object's relative vertical coordinate               ; 
JSR DumpTwoSpr                ; do sub to dump current Y coordinate into two sprites                ; 
LDA Block_Rel_XPos            ; get first block object's relative horizontal coordinate             ; 
STA Sprite_X_Position,Y       ; save into X coordinate of first sprite                              ; 
LDA Block_Orig_XPos,X         ; get original horizontal coordinate                                  ; 
SEC                                                                                                 ; 
SBC ScreenLeft_X_Pos          ; subtract coordinate of left side from original coordinate           ; 
STA $00                       ; store result as relative horizontal coordinate of original          ; 
SEC                                                                                                 ; 
SBC Block_Rel_XPos            ; get difference of relative positions of original - current          ; 
ADC $00                       ; add original relative position to result                            ; 
ADC #$06                      ; plus 6 pixels to position second brick chunk correctly              ; 
STA Sprite_X_Position+4,Y     ; save into X coordinate of second sprite                             ; 
LDA Block_Rel_YPos+1          ; get second block object's relative vertical coordinate              ; 
STA Sprite_Y_Position+8,Y                                                                           ; 
STA Sprite_Y_Position+12,Y    ; dump into Y coordinates of third and fourth sprites                 ; 
LDA Block_Rel_XPos+1          ; get second block object's relative horizontal coordinate            ; 
STA Sprite_X_Position+8,Y     ; save into X coordinate of third sprite                              ; 
LDA $00                       ; use original relative horizontal position                           ; 
SEC                                                                                                 ; 
SBC Block_Rel_XPos+1          ; get difference of relative positions of original - current          ; 
ADC $00                       ; add original relative position to result                            ; 
ADC #$06                      ; plus 6 pixels to position fourth brick chunk correctly              ; 
STA Sprite_X_Position+12,Y    ; save into X coordinate of fourth sprite                             ; 
LDA Block_OffscreenBits       ; get offscreen bits for block object                                 ; 
JSR ChkLeftCo                 ; do sub to move left half of sprites offscreen if necessary          ; 
LDA Block_OffscreenBits       ; get offscreen bits again                                            ; 
ASL                           ; shift d7 into carry                                                 ; 
BCC ChnkOfs                   ; if d7 not set, branch to last part                                  ; 
LDA #$f8                                                                                            ;  B
JSR DumpTwoSpr                ; otherwise move top sprites offscreen                                ; 
ChnkOfs:  LDA $00             ; if relative position on left side of screen,                        ;  B
BPL ExBCDr                    ; go ahead and leave                                                  ; 
LDA Sprite_X_Position,Y       ; otherwise compare left-side X coordinate                            ;  B
CMP Sprite_X_Position+4,Y     ; to right-side X coordinate                                          ; 
BCC ExBCDr                    ; branch to leave if less                                             ; 
LDA #$f8                      ; otherwise move right half of sprites offscreen                      ;  B
STA Sprite_Y_Position+4,Y                                                                           ; 
STA Sprite_Y_Position+12,Y                                                                          ; 
ExBCDr:  RTS                  ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DrawFireball:                                                                                       ;  B
LDY FBall_SprDataOffset,X     ; get fireball's sprite data offset                                   ; 
LDA Fireball_Rel_YPos         ; get relative vertical coordinate                                    ; 
STA Sprite_Y_Position,Y       ; store as sprite Y coordinate                                        ; 
LDA Fireball_Rel_XPos         ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y       ; store as sprite X coordinate, then do shared code                   ; 
                                                                                                    ; 
DrawFirebar:                                                                                        ; fun():  B
LDA FrameCounter              ; get frame counter                                                   ; 
LSR                           ; divide by four                                                      ; 
LSR                                                                                                 ; 
PHA                           ; save result to stack                                                ; 
AND #$01                      ; mask out all but last bit                                           ; 
EOR #$64                      ; set either tile $64 or $65 as fireball tile                         ; 
STA Sprite_Tilenumber,Y       ; thus tile changes every four frames                                 ; 
PLA                           ; get from stack                                                      ; 
LSR                           ; divide by four again                                                ; 
LSR                                                                                                 ; 
LDA #$02                      ; load value $02 to set palette in attrib byte                        ; 
BCC FireA                     ; if last bit shifted out was not set, skip this                      ; 
ORA #%11000000                ; otherwise flip both ways every eight frames                         ;  B
FireA:  STA Sprite_Attributes,Y; store attribute byte and leave                                     ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
ExplosionTiles:                                                                                     ;  B
DATA: ByteValue(value=104), ByteValue(value=103), ByteValue(value=102)                              ; 
                                                                                                    ; 
DrawExplosion_Fireball:                                                                             ;  B
LDY Alt_SprDataOffset,X       ; get OAM data offset of alternate sort for fireball's explosion      ; 
LDA Fireball_State,X          ; load fireball state                                                 ; 
INC Fireball_State,X          ; increment state for next frame                                      ; 
LSR                           ; divide by 2                                                         ; 
AND #%00000111                ; mask out all but d3-d1                                              ; 
CMP #$03                      ; check to see if time to kill fireball                               ; 
BCS KillFireBall              ; branch if so, otherwise continue to draw explosion                  ; 
                                                                                                    ;  B
DrawExplosion_Fireworks:                                                                            ; fun(AY):  B
TAX                           ; use whatever's in A for offset                                      ; 
LDA ExplosionTiles,X          ; get tile number using offset                                        ; 
INY                           ; increment Y (contains sprite data offset)                           ; 
JSR DumpFourSpr               ; and dump into tile number part of sprite data                       ; 
DEY                           ; decrement Y so we have the proper offset again                      ; 
LDX ObjectOffset              ; return enemy object buffer offset to X                              ; 
LDA Fireball_Rel_YPos         ; get relative vertical coordinate                                    ; 
SEC                           ; subtract four pixels vertically                                     ; 
SBC #$04                      ; for first and third sprites                                         ; 
STA Sprite_Y_Position,Y                                                                             ; 
STA Sprite_Y_Position+8,Y                                                                           ; 
CLC                           ; add eight pixels vertically                                         ; 
ADC #$08                      ; for second and fourth sprites                                       ; 
STA Sprite_Y_Position+4,Y                                                                           ; 
STA Sprite_Y_Position+12,Y                                                                          ; 
LDA Fireball_Rel_XPos         ; get relative horizontal coordinate                                  ; 
SEC                           ; subtract four pixels horizontally                                   ; 
SBC #$04                      ; for first and second sprites                                        ; 
STA Sprite_X_Position,Y                                                                             ; 
STA Sprite_X_Position+4,Y                                                                           ; 
CLC                           ; add eight pixels horizontally                                       ; 
ADC #$08                      ; for third and fourth sprites                                        ; 
STA Sprite_X_Position+8,Y                                                                           ; 
STA Sprite_X_Position+12,Y                                                                          ; 
LDA #$02                      ; set palette attributes for all sprites, but                         ; 
STA Sprite_Attributes,Y       ; set no flip at all for first sprite                                 ; 
LDA #$82                                                                                            ; 
STA Sprite_Attributes+4,Y     ; set vertical flip for second sprite                                 ; 
LDA #$42                                                                                            ; 
STA Sprite_Attributes+8,Y     ; set horizontal flip for third sprite                                ; 
LDA #$c2                                                                                            ; 
STA Sprite_Attributes+12,Y    ; set both flips for fourth sprite                                    ; 
RTS                           ; we are done                                                         ; 
                                                                                                    ;  B
KillFireBall:                                                                                       ;  B
LDA #$00                      ; clear fireball state to kill it                                     ; 
STA Fireball_State,X                                                                                ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DrawSmallPlatform:                                                                                  ; fun():  B
LDY Enemy_SprDataOffset,X     ; get OAM data offset                                                 ; 
LDA #$5b                      ; load tile number for small platforms                                ; 
INY                           ; increment offset for tile numbers                                   ; 
JSR DumpSixSpr                ; dump tile number into all six sprites                               ; 
INY                           ; increment offset for attributes                                     ; 
LDA #$02                      ; load palette controls                                               ; 
JSR DumpSixSpr                ; dump attributes into all six sprites                                ; 
DEY                           ; decrement for original offset                                       ; 
DEY                                                                                                 ; 
LDA Enemy_Rel_XPos            ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y                                                                             ; 
STA Sprite_X_Position+12,Y    ; dump as X coordinate into first and fourth sprites                  ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight pixels                                                    ; 
STA Sprite_X_Position+4,Y     ; dump into second and fifth sprites                                  ; 
STA Sprite_X_Position+16,Y                                                                          ; 
CLC                                                                                                 ; 
ADC #$08                      ; add eight more pixels                                               ; 
STA Sprite_X_Position+8,Y     ; dump into third and sixth sprites                                   ; 
STA Sprite_X_Position+20,Y                                                                          ; 
LDA Enemy_Y_Position,X        ; get vertical coordinate                                             ; 
TAX                                                                                                 ; 
PHA                           ; save to stack                                                       ; 
CPX #$20                      ; if vertical coordinate below status bar,                            ; 
BCS TopSP                     ; do not mess with it                                                 ; 
LDA #$f8                      ; otherwise move first three sprites offscreen                        ;  B
TopSP:  JSR DumpThreeSpr      ; dump vertical coordinate into Y coordinates                         ;  B
PLA                           ; pull from stack                                                     ; 
CLC                                                                                                 ; 
ADC #$80                      ; add 128 pixels                                                      ; 
TAX                                                                                                 ; 
CPX #$20                      ; if below status bar (taking wrap into account)                      ; 
BCS BotSP                     ; then do not change altered coordinate                               ; 
LDA #$f8                      ; otherwise move last three sprites offscreen                         ;  B
BotSP:  STA Sprite_Y_Position+12,Y; dump vertical coordinate + 128 pixels                           ;  B
STA Sprite_Y_Position+16,Y    ; into Y coordinates                                                  ; 
STA Sprite_Y_Position+20,Y                                                                          ; 
LDA Enemy_OffscreenBits       ; get offscreen bits                                                  ; 
PHA                           ; save to stack                                                       ; 
AND #%00001000                ; check d3                                                            ; 
BEQ SOfs                                                                                            ; 
LDA #$f8                      ; if d3 was set, move first and                                       ;  B
STA Sprite_Y_Position,Y       ; fourth sprites offscreen                                            ; 
STA Sprite_Y_Position+12,Y                                                                          ; 
SOfs:  PLA                    ; move out and back into stack                                        ;  B
PHA                                                                                                 ; 
AND #%00000100                ; check d2                                                            ; 
BEQ SOfs2                                                                                           ; 
LDA #$f8                      ; if d2 was set, move second and                                      ;  B
STA Sprite_Y_Position+4,Y     ; fifth sprites offscreen                                             ; 
STA Sprite_Y_Position+16,Y                                                                          ; 
SOfs2:  PLA                   ; get from stack                                                      ;  B
AND #%00000010                ; check d1                                                            ; 
BEQ ExSPl                                                                                           ; 
LDA #$f8                      ; if d1 was set, move third and                                       ;  B
STA Sprite_Y_Position+8,Y     ; sixth sprites offscreen                                             ; 
STA Sprite_Y_Position+20,Y                                                                          ; 
ExSPl:  LDX ObjectOffset      ; get enemy object offset and leave                                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
DrawBubble:                                                                                         ; fun():  B
LDY Player_Y_HighPos          ; if player's vertical high position                                  ; 
DEY                           ; not within screen, skip all of this                                 ; 
BNE ExDBub                                                                                          ; 
LDA Bubble_OffscreenBits      ; check air bubble's offscreen bits                                   ;  B
AND #%00001000                                                                                      ; 
BNE ExDBub                    ; if bit set, branch to leave                                         ; 
LDY Bubble_SprDataOffset,X    ; get air bubble's OAM data offset                                    ;  B
LDA Bubble_Rel_XPos           ; get relative horizontal coordinate                                  ; 
STA Sprite_X_Position,Y       ; store as X coordinate here                                          ; 
LDA Bubble_Rel_YPos           ; get relative vertical coordinate                                    ; 
STA Sprite_Y_Position,Y       ; store as Y coordinate here                                          ; 
LDA #$74                                                                                            ; 
STA Sprite_Tilenumber,Y       ; put air bubble tile into OAM data                                   ; 
LDA #$02                                                                                            ; 
STA Sprite_Attributes,Y       ; set attribute byte                                                  ; 
ExDBub:  RTS                  ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used to store player's vertical offscreen bits                ; 
                                                                                                    ; 
PlayerGfxTblOffsets:                                                                                ;  B
DATA: ByteValue(value=32), ByteValue(value=40), ByteValue(value=200), ByteValue(value=24), ByteValue(value=0), ByteValue(value=64), ByteValue(value=80), ByteValue(value=88); 
DATA: ByteValue(value=128), ByteValue(value=136), ByteValue(value=184), ByteValue(value=120), ByteValue(value=96), ByteValue(value=160), ByteValue(value=176), ByteValue(value=184); 
                                                                                                    ; 
                              ; tiles arranged in order, 2 tiles per row, top to bottom             ; 
                                                                                                    ; 
PlayerGraphicsTable:                                                                                ;  B
                              ; big player table                                                    ; 
DATA: ByteValue(value=0), ByteValue(value=1), ByteValue(value=2), ByteValue(value=3), ByteValue(value=4), ByteValue(value=5), ByteValue(value=6), ByteValue(value=7); walking frame 1; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=10), ByteValue(value=11), ByteValue(value=12), ByteValue(value=13), ByteValue(value=14), ByteValue(value=15); frame 2; 
DATA: ByteValue(value=16), ByteValue(value=17), ByteValue(value=18), ByteValue(value=19), ByteValue(value=20), ByteValue(value=21), ByteValue(value=22), ByteValue(value=23); frame 3; 
DATA: ByteValue(value=24), ByteValue(value=25), ByteValue(value=26), ByteValue(value=27), ByteValue(value=28), ByteValue(value=29), ByteValue(value=30), ByteValue(value=31); skidding; 
DATA: ByteValue(value=32), ByteValue(value=33), ByteValue(value=34), ByteValue(value=35), ByteValue(value=36), ByteValue(value=37), ByteValue(value=38), ByteValue(value=39); jumping; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=40), ByteValue(value=41), ByteValue(value=42), ByteValue(value=43), ByteValue(value=44), ByteValue(value=45); swimming frame 1; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=10), ByteValue(value=11), ByteValue(value=12), ByteValue(value=48), ByteValue(value=44), ByteValue(value=45); frame 2; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=10), ByteValue(value=11), ByteValue(value=46), ByteValue(value=47), ByteValue(value=44), ByteValue(value=45); frame 3; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=40), ByteValue(value=41), ByteValue(value=42), ByteValue(value=43), ByteValue(value=92), ByteValue(value=93); climbing frame 1; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=10), ByteValue(value=11), ByteValue(value=12), ByteValue(value=13), ByteValue(value=94), ByteValue(value=95); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=8), ByteValue(value=9), ByteValue(value=88), ByteValue(value=89), ByteValue(value=90), ByteValue(value=90); crouching; 
DATA: ByteValue(value=8), ByteValue(value=9), ByteValue(value=40), ByteValue(value=41), ByteValue(value=42), ByteValue(value=43), ByteValue(value=14), ByteValue(value=15); fireball throwing; 
                                                                                                    ; 
                              ; small player table                                                  ; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=50), ByteValue(value=51), ByteValue(value=52), ByteValue(value=53); walking frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=54), ByteValue(value=55), ByteValue(value=56), ByteValue(value=57); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=58), ByteValue(value=55), ByteValue(value=59), ByteValue(value=60); frame 3; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=61), ByteValue(value=62), ByteValue(value=63), ByteValue(value=64); skidding; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=50), ByteValue(value=65), ByteValue(value=66), ByteValue(value=67); jumping; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=50), ByteValue(value=51), ByteValue(value=68), ByteValue(value=69); swimming frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=50), ByteValue(value=51), ByteValue(value=68), ByteValue(value=71); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=50), ByteValue(value=51), ByteValue(value=72), ByteValue(value=73); frame 3; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=50), ByteValue(value=51), ByteValue(value=144), ByteValue(value=145); climbing frame 1; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=58), ByteValue(value=55), ByteValue(value=146), ByteValue(value=147); frame 2; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=158), ByteValue(value=158), ByteValue(value=159), ByteValue(value=159); killed; 
                                                                                                    ; 
                              ; used by both player sizes                                           ; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=252), ByteValue(value=58), ByteValue(value=55), ByteValue(value=79), ByteValue(value=79); small player standing; 
DATA: ByteValue(value=252), ByteValue(value=252), ByteValue(value=0), ByteValue(value=1), ByteValue(value=76), ByteValue(value=77), ByteValue(value=78), ByteValue(value=78); intermediate grow frame; 
DATA: ByteValue(value=0), ByteValue(value=1), ByteValue(value=76), ByteValue(value=77), ByteValue(value=74), ByteValue(value=74), ByteValue(value=75), ByteValue(value=75); big player standing; 
                                                                                                    ; 
SwimKickTileNum:                                                                                    ;  B
DATA: ByteValue(value=49), ByteValue(value=70)                                                      ; 
                                                                                                    ; 
PlayerGfxHandler:                                                                                   ; fun():  B
LDA InjuryTimer               ; if player's injured invincibility timer                             ; 
BEQ CntPl                     ; not set, skip checkpoint and continue code                          ; 
LDA FrameCounter                                                                                    ;  B
LSR                           ; otherwise check frame counter and branch                            ; 
BCS ExPGH                     ; to leave on every other frame (when d0 is set)                      ; 
CntPl:  LDA GameEngineSubroutine; if executing specific game engine routine,                        ;  B
CMP #$0b                      ; branch ahead to some other part                                     ; 
BEQ PlayerKilled                                                                                    ; 
LDA PlayerChangeSizeFlag      ; if grow/shrink flag set                                             ;  B
BNE DoChangeSize              ; then branch to some other code                                      ; 
LDY SwimmingFlag              ; if swimming flag set, branch to                                     ;  B
BEQ FindPlayerAction          ; different part, do not return                                       ; 
LDA Player_State                                                                                    ;  B
CMP #$00                      ; if player status normal,                                            ; 
BEQ FindPlayerAction          ; branch and do not return                                            ; 
JSR FindPlayerAction          ; otherwise jump and return                                           ;  B
LDA FrameCounter                                                                                    ; 
AND #%00000100                ; check frame counter for d2 set (8 frames every                      ; 
BNE ExPGH                     ; eighth frame), and branch if set to leave                           ; 
TAX                           ; initialize X to zero                                                ;  B
LDY Player_SprDataOffset      ; get player sprite data offset                                       ; 
LDA PlayerFacingDir           ; get player's facing direction                                       ; 
LSR                                                                                                 ; 
BCS SwimKT                    ; if player facing to the right, use current offset                   ; 
INY                                                                                                 ;  B
INY                           ; otherwise move to next OAM data                                     ; 
INY                                                                                                 ; 
INY                                                                                                 ; 
SwimKT:  LDA PlayerSize       ; check player's size                                                 ;  B
BEQ BigKTS                    ; if big, use first tile                                              ; 
LDA Sprite_Tilenumber+24,Y    ; check tile number of seventh/eighth sprite                          ;  B
CMP SwimTileRepOffset         ; against tile number in player graphics table                        ; 
BEQ ExPGH                     ; if spr7/spr8 tile number = value, branch to leave                   ; 
INX                           ; otherwise increment X for second tile                               ;  B
BigKTS:  LDA SwimKickTileNum,X; overwrite tile number in sprite 7/8                                 ;  B
STA Sprite_Tilenumber+24,Y    ; to animate player's feet when swimming                              ; 
ExPGH:  RTS                   ; then leave                                                          ;  B
                                                                                                    ;  B
FindPlayerAction:                                                                                   ; fun(A):  B
JSR ProcessPlayerAction       ; find proper offset to graphics table by player's actions            ; 
JMP PlayerGfxProcessing       ; draw player, then process for fireball throwing                     ; 
                                                                                                    ;  B
DoChangeSize:                                                                                       ;  B
JSR HandleChangeSize          ; find proper offset to graphics table for grow/shrink                ; 
JMP PlayerGfxProcessing       ; draw player, then process for fireball throwing                     ; 
                                                                                                    ;  B
PlayerKilled:                                                                                       ;  B
LDY #$0e                      ; load offset for player killed                                       ; 
LDA PlayerGfxTblOffsets,Y     ; get offset to graphics table                                        ; 
                                                                                                    ; 
PlayerGfxProcessing:                                                                                ;  B
STA PlayerGfxOffset           ; store offset to graphics table here                                 ; 
LDA #$04                                                                                            ; 
JSR RenderPlayerSub           ; draw player based on offset loaded                                  ; 
JSR ChkForPlayerAttrib        ; set horizontal flip bits as necessary                               ; 
LDA FireballThrowingTimer                                                                           ; 
BEQ PlayerOffscreenChk        ; if fireball throw timer not set, skip to the end                    ; 
LDY #$00                      ; set value to initialize by default                                  ;  B
LDA PlayerAnimTimer           ; get animation frame timer                                           ; 
CMP FireballThrowingTimer     ; compare to fireball throw timer                                     ; 
STY FireballThrowingTimer     ; initialize fireball throw timer                                     ; 
BCS PlayerOffscreenChk        ; if animation frame timer => fireball throw timer skip to end        ; 
STA FireballThrowingTimer     ; otherwise store animation timer into fireball throw timer           ;  B
LDY #$07                      ; load offset for throwing                                            ; 
LDA PlayerGfxTblOffsets,Y     ; get offset to graphics table                                        ; 
STA PlayerGfxOffset           ; store it for use later                                              ; 
LDY #$04                      ; set to update four sprite rows by default                           ; 
LDA Player_X_Speed                                                                                  ; 
ORA Left_Right_Buttons        ; check for horizontal speed or left/right button press               ; 
BEQ SUpdR                     ; if no speed or button press, branch using set value in Y            ; 
DEY                           ; otherwise set to update only three sprite rows                      ;  B
SUpdR:  TYA                   ; save in A for use                                                   ;  B
JSR RenderPlayerSub           ; in sub, draw player object again                                    ; 
                                                                                                    ; 
PlayerOffscreenChk:                                                                                 ;  B
LDA Player_OffscreenBits      ; get player's offscreen bits                                         ; 
LSR                                                                                                 ; 
LSR                           ; move vertical bits to low nybble                                    ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
STA $00                       ; store here                                                          ; 
LDX #$03                      ; check all four rows of player sprites                               ; 
LDA Player_SprDataOffset      ; get player's sprite data offset                                     ; 
CLC                                                                                                 ; 
ADC #$18                      ; add 24 bytes to start at bottom row                                 ; 
TAY                           ; set as offset here                                                  ; 
PROfsLoop:  LDA #$f8          ; load offscreen Y coordinate just in case                            ;  B
LSR $00                       ; shift bit into carry                                                ; 
BCC NPROffscr                 ; if bit not set, skip, do not move sprites                           ; 
JSR DumpTwoSpr                ; otherwise dump offscreen Y coordinate into sprite data              ;  B
NPROffscr:  TYA                                                                                     ;  B
SEC                           ; subtract eight bytes to do                                          ; 
SBC #$08                      ; next row up                                                         ; 
TAY                                                                                                 ; 
DEX                           ; decrement row counter                                               ; 
BPL PROfsLoop                 ; do this until all sprite rows are checked                           ; 
RTS                           ; then we are done!                                                   ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
IntermediatePlayerData:                                                                             ;  B
DATA: ByteValue(value=88), ByteValue(value=1), ByteValue(value=0), ByteValue(value=96), ByteValue(value=255), ByteValue(value=4); 
                                                                                                    ; 
DrawPlayer_Intermediate:                                                                            ; fun():  B
LDX #$05                      ; store data into zero page memory                                    ; 
PIntLoop:  LDA IntermediatePlayerData,X; load data to display player as he always                   ;  B
STA $02,X                     ; appears on world/lives display                                      ; 
DEX                                                                                                 ; 
BPL PIntLoop                  ; do this until all data is loaded                                    ; 
LDX #$b8                      ; load offset for small standing                                      ;  B
LDY #$04                      ; load sprite data offset                                             ; 
JSR DrawPlayerLoop            ; draw player accordingly                                             ; 
LDA Sprite_Attributes+36      ; get empty sprite attributes                                         ; 
ORA #%01000000                ; set horizontal flip bit for bottom-right sprite                     ; 
STA Sprite_Attributes+32      ; store and leave                                                     ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames; 
                              ; $02 - vertical position                                             ; 
                              ; $03 - facing direction, used as horizontal flip control             ; 
                              ; $04 - attributes                                                    ; 
                              ; $05 - horizontal position                                           ; 
                              ; $07 - number of rows to draw                                        ; 
                              ; these also used in IntermediatePlayerData                           ; 
                                                                                                    ; 
RenderPlayerSub:                                                                                    ; fun(A):  B
STA $07                       ; store number of rows of sprites to draw                             ; 
LDA Player_Rel_XPos                                                                                 ; 
STA Player_Pos_ForScroll      ; store player's relative horizontal position                         ; 
STA $05                       ; store it here also                                                  ; 
LDA Player_Rel_YPos                                                                                 ; 
STA $02                       ; store player's vertical position                                    ; 
LDA PlayerFacingDir                                                                                 ; 
STA $03                       ; store player's facing direction                                     ; 
LDA Player_SprAttrib                                                                                ; 
STA $04                       ; store player's sprite attributes                                    ; 
LDX PlayerGfxOffset           ; load graphics table offset                                          ; 
LDY Player_SprDataOffset      ; get player's sprite data offset                                     ; 
                                                                                                    ; 
DrawPlayerLoop:                                                                                     ; fun($07):  B
LDA PlayerGraphicsTable,X     ; load player's left side                                             ; 
STA $00                                                                                             ; 
LDA PlayerGraphicsTable+1,X   ; now load right side                                                 ; 
JSR DrawOneSpriteRow                                                                                ; 
DEC $07                       ; decrement rows of sprites to draw                                   ; 
BNE DrawPlayerLoop            ; do this until all rows are drawn                                    ; 
RTS                                                                                                 ;  B
                                                                                                    ;  B
ProcessPlayerAction:                                                                                ; fun():  B
LDA Player_State              ; get player's state                                                  ; 
CMP #$03                                                                                            ; 
BEQ ActionClimbing            ; if climbing, branch here                                            ; 
CMP #$02                                                                                            ;  B
BEQ ActionFalling             ; if falling, branch here                                             ; 
CMP #$01                                                                                            ;  B
BNE ProcOnGroundActs          ; if not jumping, branch here                                         ; 
LDA SwimmingFlag                                                                                    ;  B
BNE ActionSwimming            ; if swimming flag set, branch elsewhere                              ; 
LDY #$06                      ; load offset for crouching                                           ;  B
LDA CrouchingFlag             ; get crouching flag                                                  ; 
BNE NonAnimatedActs           ; if set, branch to get offset for graphics table                     ; 
LDY #$00                      ; otherwise load offset for jumping                                   ;  B
JMP NonAnimatedActs           ; go to get offset to graphics table                                  ; 
                                                                                                    ;  B
ProcOnGroundActs:                                                                                   ;  B
LDY #$06                      ; load offset for crouching                                           ; 
LDA CrouchingFlag             ; get crouching flag                                                  ; 
BNE NonAnimatedActs           ; if set, branch to get offset for graphics table                     ; 
LDY #$02                      ; load offset for standing                                            ;  B
LDA Player_X_Speed            ; check player's horizontal speed                                     ; 
ORA Left_Right_Buttons        ; and left/right controller bits                                      ; 
BEQ NonAnimatedActs           ; if no speed or buttons pressed, use standing offset                 ; 
LDA Player_XSpeedAbsolute     ; load walking/running speed                                          ;  B
CMP #$09                                                                                            ; 
BCC ActionWalkRun             ; if less than a certain amount, branch, too slow to skid             ; 
LDA Player_MovingDir          ; otherwise check to see if moving direction                          ;  B
AND PlayerFacingDir           ; and facing direction are the same                                   ; 
BNE ActionWalkRun             ; if moving direction = facing direction, branch, don't skid          ; 
INY                           ; otherwise increment to skid offset ($03)                            ;  B
                                                                                                    ; 
NonAnimatedActs:                                                                                    ;  B
JSR GetGfxOffsetAdder         ; do a sub here to get offset adder for graphics table                ; 
LDA #$00                                                                                            ; 
STA PlayerAnimCtrl            ; initialize animation frame control                                  ; 
LDA PlayerGfxTblOffsets,Y     ; load offset to graphics table using size as offset                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
ActionFalling:                                                                                      ;  B
LDY #$04                      ; load offset for walking/running                                     ; 
JSR GetGfxOffsetAdder         ; get offset to graphics table                                        ; 
JMP GetCurrentAnimOffset      ; execute instructions for falling state                              ; 
                                                                                                    ;  B
ActionWalkRun:                                                                                      ;  B
LDY #$04                      ; load offset for walking/running                                     ; 
JSR GetGfxOffsetAdder         ; get offset to graphics table                                        ; 
JMP FourFrameExtent           ; execute instructions for normal state                               ; 
                                                                                                    ;  B
ActionClimbing:                                                                                     ;  B
LDY #$05                      ; load offset for climbing                                            ; 
LDA Player_Y_Speed            ; check player's vertical speed                                       ; 
BEQ NonAnimatedActs           ; if no speed, branch, use offset as-is                               ; 
JSR GetGfxOffsetAdder         ; otherwise get offset for graphics table                             ;  B
JMP ThreeFrameExtent          ; then skip ahead to more code                                        ; 
                                                                                                    ;  B
ActionSwimming:                                                                                     ;  B
LDY #$01                      ; load offset for swimming                                            ; 
JSR GetGfxOffsetAdder                                                                               ; 
LDA JumpSwimTimer             ; check jump/swim timer                                               ; 
ORA PlayerAnimCtrl            ; and animation frame control                                         ; 
BNE FourFrameExtent           ; if any one of these set, branch ahead                               ; 
LDA A_B_Buttons                                                                                     ;  B
ASL                           ; check for A button pressed                                          ; 
BCS FourFrameExtent           ; branch to same place if A button pressed                            ; 
                                                                                                    ;  B
GetCurrentAnimOffset:                                                                               ; fun(): A B
LDA PlayerAnimCtrl            ; get animation frame control                                         ; 
JMP GetOffsetFromAnimCtrl     ; jump to get proper offset to graphics table                         ; 
                                                                                                    ;  B
FourFrameExtent:                                                                                    ;  B
LDA #$03                      ; load upper extent for frame control                                 ; 
JMP AnimationControl          ; jump to get offset and animate player object                        ; 
                                                                                                    ;  B
ThreeFrameExtent:                                                                                   ;  B
LDA #$02                      ; load upper extent for frame control for climbing                    ; 
                                                                                                    ; 
AnimationControl:                                                                                   ;  B
STA $00                       ; store upper extent here                                             ; 
JSR GetCurrentAnimOffset      ; get proper offset to graphics table                                 ; 
PHA                           ; save offset to stack                                                ; 
LDA PlayerAnimTimer           ; load animation frame timer                                          ; 
BNE ExAnimC                   ; branch if not expired                                               ; 
LDA PlayerAnimTimerSet        ; get animation frame timer amount                                    ;  B
STA PlayerAnimTimer           ; and set timer accordingly                                           ; 
LDA PlayerAnimCtrl                                                                                  ; 
CLC                           ; add one to animation frame control                                  ; 
ADC #$01                                                                                            ; 
CMP $00                       ; compare to upper extent                                             ; 
BCC SetAnimC                  ; if frame control + 1 < upper extent, use as next                    ; 
LDA #$00                      ; otherwise initialize frame control                                  ;  B
SetAnimC:  STA PlayerAnimCtrl ; store as new animation frame control                                ;  B
ExAnimC:  PLA                 ; get offset to graphics table from stack and leave                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
GetGfxOffsetAdder:                                                                                  ; fun(Y):  B
LDA PlayerSize                ; get player's size                                                   ; 
BEQ SzOfs                     ; if player big, use current offset as-is                             ; 
TYA                           ; for big player                                                      ;  B
CLC                           ; otherwise add eight bytes to offset                                 ; 
ADC #$08                      ; for small player                                                    ; 
TAY                                                                                                 ; 
SzOfs:  RTS                   ; go back                                                             ;  B
                                                                                                    ;  B
ChangeSizeOffsetAdder:                                                                              ;  B
DATA: ByteValue(value=0), ByteValue(value=1), ByteValue(value=0), ByteValue(value=1), ByteValue(value=0), ByteValue(value=1), ByteValue(value=2), ByteValue(value=0), ByteValue(value=1), ByteValue(value=2); 
DATA: ByteValue(value=2), ByteValue(value=0), ByteValue(value=2), ByteValue(value=0), ByteValue(value=2), ByteValue(value=0), ByteValue(value=2), ByteValue(value=0), ByteValue(value=2), ByteValue(value=0); 
                                                                                                    ; 
HandleChangeSize:                                                                                   ; fun():  B
LDY PlayerAnimCtrl            ; get animation frame control                                         ; 
LDA FrameCounter                                                                                    ; 
AND #%00000011                ; get frame counter and execute this code every                       ; 
BNE GorSLog                   ; fourth frame, otherwise branch ahead                                ; 
INY                           ; increment frame control                                             ;  B
CPY #$0a                      ; check for preset upper extent                                       ; 
BCC CSzNext                   ; if not there yet, skip ahead to use                                 ; 
LDY #$00                      ; otherwise initialize both grow/shrink flag                          ;  B
STY PlayerChangeSizeFlag      ; and animation frame control                                         ; 
CSzNext:  STY PlayerAnimCtrl  ; store proper frame control                                          ;  B
GorSLog:  LDA PlayerSize      ; get player's size                                                   ;  B
BNE ShrinkPlayer              ; if player small, skip ahead to next part                            ; 
LDA ChangeSizeOffsetAdder,Y   ; get offset adder based on frame control as offset                   ;  B
LDY #$0f                      ; load offset for player growing                                      ; 
                                                                                                    ; 
GetOffsetFromAnimCtrl:                                                                              ;  B
ASL                           ; multiply animation frame control                                    ; 
ASL                           ; by eight to get proper amount                                       ; 
ASL                           ; to add to our offset                                                ; 
ADC PlayerGfxTblOffsets,Y     ; add to offset to graphics table                                     ; 
RTS                           ; and return with result in A                                         ; 
                                                                                                    ;  B
ShrinkPlayer:                                                                                       ;  B
TYA                           ; add ten bytes to frame control as offset                            ; 
CLC                                                                                                 ; 
ADC #$0a                      ; this thing apparently uses two of the swimming frames               ; 
TAX                           ; to draw the player shrinking                                        ; 
LDY #$09                      ; load offset for small player swimming                               ; 
LDA ChangeSizeOffsetAdder,X   ; get what would normally be offset adder                             ; 
BNE ShrPlF                    ; and branch to use offset if nonzero                                 ; 
LDY #$01                      ; otherwise load offset for big player swimming                       ;  B
ShrPlF:  LDA PlayerGfxTblOffsets,Y; get offset to graphics table based on offset loaded             ;  B
RTS                           ; and leave                                                           ; 
                                                                                                    ;  B
ChkForPlayerAttrib:                                                                                 ; fun():  B
LDY Player_SprDataOffset      ; get sprite data offset                                              ; 
LDA GameEngineSubroutine                                                                            ; 
CMP #$0b                      ; if executing specific game engine routine,                          ; 
BEQ KilledAtt                 ; branch to change third and fourth row OAM attributes                ; 
LDA PlayerGfxOffset           ; get graphics table offset                                           ;  B
CMP #$50                                                                                            ; 
BEQ C_S_IGAtt                 ; if crouch offset, either standing offset,                           ; 
CMP #$b8                      ; or intermediate growing offset,                                     ;  B
BEQ C_S_IGAtt                 ; go ahead and execute code to change                                 ; 
CMP #$c0                      ; fourth row OAM attributes only                                      ;  B
BEQ C_S_IGAtt                                                                                       ; 
CMP #$c8                                                                                            ;  B
BNE ExPlyrAt                  ; if none of these, branch to leave                                   ; 
KilledAtt:  LDA Sprite_Attributes+16,Y                                                              ;  B
AND #%00111111                ; mask out horizontal and vertical flip bits                          ; 
STA Sprite_Attributes+16,Y    ; for third row sprites and save                                      ; 
LDA Sprite_Attributes+20,Y                                                                          ; 
AND #%00111111                                                                                      ; 
ORA #%01000000                ; set horizontal flip bit for second                                  ; 
STA Sprite_Attributes+20,Y    ; sprite in the third row                                             ; 
C_S_IGAtt:  LDA Sprite_Attributes+24,Y                                                              ;  B
AND #%00111111                ; mask out horizontal and vertical flip bits                          ; 
STA Sprite_Attributes+24,Y    ; for fourth row sprites and save                                     ; 
LDA Sprite_Attributes+28,Y                                                                          ; 
AND #%00111111                                                                                      ; 
ORA #%01000000                ; set horizontal flip bit for second                                  ; 
STA Sprite_Attributes+28,Y    ; sprite in the fourth row                                            ; 
ExPlyrAt:  RTS                ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used in adding to get proper offset                           ; 
                                                                                                    ; 
RelativePlayerPosition:                                                                             ; fun():  B
LDX #$00                      ; set offsets for relative cooordinates                               ; 
LDY #$00                      ; routine to correspond to player object                              ; 
JMP RelWOfs                   ; get the coordinates                                                 ; 
                                                                                                    ;  B
RelativeBubblePosition:                                                                             ; fun(): X B
LDY #$01                      ; set for air bubble offsets                                          ; 
JSR GetProperObjOffset        ; modify X to get proper air bubble offset                            ; 
LDY #$03                                                                                            ; 
JMP RelWOfs                   ; get the coordinates                                                 ; 
                                                                                                    ;  B
RelativeFireballPosition:                                                                           ; fun():  B
LDY #$00                      ; set for fireball offsets                                            ; 
JSR GetProperObjOffset        ; modify X to get proper fireball offset                              ; 
LDY #$02                                                                                            ; 
RelWOfs:  JSR GetObjRelativePosition; get the coordinates                                           ;  B
LDX ObjectOffset              ; return original offset                                              ; 
RTS                           ; leave                                                               ; 
                                                                                                    ;  B
RelativeMiscPosition:                                                                               ; fun():  B
LDY #$02                      ; set for misc object offsets                                         ; 
JSR GetProperObjOffset        ; modify X to get proper misc object offset                           ; 
LDY #$06                                                                                            ; 
JMP RelWOfs                   ; get the coordinates                                                 ; 
                                                                                                    ;  B
RelativeEnemyPosition:                                                                              ; fun():  B
LDA #$01                      ; get coordinates of enemy object                                     ; 
LDY #$01                      ; relative to the screen                                              ; 
JMP VariableObjOfsRelPos                                                                            ; 
                                                                                                    ;  B
RelativeBlockPosition:                                                                              ; fun(X):  B
LDA #$09                      ; get coordinates of one block object                                 ; 
LDY #$04                      ; relative to the screen                                              ; 
JSR VariableObjOfsRelPos                                                                            ; 
INX                           ; adjust offset for other block object if any                         ; 
INX                                                                                                 ; 
LDA #$09                                                                                            ; 
INY                           ; adjust other and get coordinates for other one                      ; 
                                                                                                    ; 
VariableObjOfsRelPos:                                                                               ; fun(XA): X B
STX $00                       ; store value to add to A here                                        ; 
CLC                                                                                                 ; 
ADC $00                       ; add A to value stored                                               ; 
TAX                           ; use as enemy offset                                                 ; 
JSR GetObjRelativePosition                                                                          ; 
LDX ObjectOffset              ; reload old object offset and leave                                  ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
GetObjRelativePosition:                                                                             ; fun():  B
LDA SprObject_Y_Position,X    ; load vertical coordinate low                                        ; 
STA SprObject_Rel_YPos,Y      ; store here                                                          ; 
LDA SprObject_X_Position,X    ; load horizontal coordinate                                          ; 
SEC                           ; subtract left edge coordinate                                       ; 
SBC ScreenLeft_X_Pos                                                                                ; 
STA SprObject_Rel_XPos,Y      ; store result here                                                   ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00 - used as temp variable to hold offscreen bits                  ; 
                                                                                                    ; 
GetPlayerOffscreenBits:                                                                             ; fun($00):  B
LDX #$00                      ; set offsets for player-specific variables                           ; 
LDY #$00                      ; and get offscreen information about player                          ; 
JMP GetOffScreenBitsSet                                                                             ; 
                                                                                                    ;  B
GetFireballOffscreenBits:                                                                           ; fun($00):  B
LDY #$00                      ; set for fireball offsets                                            ; 
JSR GetProperObjOffset        ; modify X to get proper fireball offset                              ; 
LDY #$02                      ; set other offset for fireball's offscreen bits                      ; 
JMP GetOffScreenBitsSet       ; and get offscreen information about fireball                        ; 
                                                                                                    ;  B
GetBubbleOffscreenBits:                                                                             ; fun($00): X B
LDY #$01                      ; set for air bubble offsets                                          ; 
JSR GetProperObjOffset        ; modify X to get proper air bubble offset                            ; 
LDY #$03                      ; set other offset for airbubble's offscreen bits                     ; 
JMP GetOffScreenBitsSet       ; and get offscreen information about air bubble                      ; 
                                                                                                    ;  B
GetMiscOffscreenBits:                                                                               ; fun($00):  B
LDY #$02                      ; set for misc object offsets                                         ; 
JSR GetProperObjOffset        ; modify X to get proper misc object offset                           ; 
LDY #$06                      ; set other offset for misc object's offscreen bits                   ; 
JMP GetOffScreenBitsSet       ; and get offscreen information about misc object                     ; 
                                                                                                    ;  B
ObjOffsetData:                                                                                      ;  B
DATA: ByteValue(value=7), ByteValue(value=22), ByteValue(value=13)                                  ; 
                                                                                                    ; 
GetProperObjOffset:                                                                                 ; fun(X):  B
TXA                           ; move offset to A                                                    ; 
CLC                                                                                                 ; 
ADC ObjOffsetData,Y           ; add amount of bytes to offset depending on setting in Y             ; 
TAX                           ; put back in X and leave                                             ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
GetEnemyOffscreenBits:                                                                              ; fun(X):  B
LDA #$01                      ; set A to add 1 byte in order to get enemy offset                    ; 
LDY #$01                      ; set Y to put offscreen bits in Enemy_OffscreenBits                  ; 
JMP SetOffscrBitsOffset                                                                             ; 
                                                                                                    ;  B
GetBlockOffscreenBits:                                                                              ; fun(X):  B
LDA #$09                      ; set A to add 9 bytes in order to get block obj offset               ; 
LDY #$04                      ; set Y to put offscreen bits in Block_OffscreenBits                  ; 
                                                                                                    ; 
SetOffscrBitsOffset:                                                                                ;  B
STX $00                                                                                             ; 
CLC                           ; add contents of X to A to get                                       ; 
ADC $00                       ; appropriate offset, then give back to X                             ; 
TAX                                                                                                 ; 
                                                                                                    ; 
GetOffScreenBitsSet:                                                                                ;  B
TYA                           ; save offscreen bits offset to stack for now                         ; 
PHA                                                                                                 ; 
JSR RunOffscrBitsSubs                                                                               ; 
ASL                           ; move low nybble to high nybble                                      ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ASL                                                                                                 ; 
ORA $00                       ; mask together with previously saved low nybble                      ; 
STA $00                       ; store both here                                                     ; 
PLA                           ; get offscreen bits offset from stack                                ; 
TAY                                                                                                 ; 
LDA $00                       ; get value here and store elsewhere                                  ; 
STA SprObject_OffscrBits,Y                                                                          ; 
LDX ObjectOffset                                                                                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
RunOffscrBitsSubs:                                                                                  ; fun(AX): A$00 B
JSR GetXOffscreenBits         ; do subroutine here                                                  ; 
LSR                           ; move high nybble to low                                             ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
LSR                                                                                                 ; 
STA $00                       ; store here                                                          ; 
JMP GetYOffscreenBits                                                                               ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                              ; (these apply to these three subsections)                            ; 
                              ; $04 - used to store proper offset                                   ; 
                              ; $05 - used as adder in DividePDiff                                  ; 
                              ; $06 - used to store preset value used to compare to pixel difference in $07; 
                              ; $07 - used to store difference between coordinates of object and screen edges; 
                                                                                                    ; 
XOffscreenBitsData:                                                                                 ;  B
DATA: ByteValue(value=127), ByteValue(value=63), ByteValue(value=31), ByteValue(value=15), ByteValue(value=7), ByteValue(value=3), ByteValue(value=1), ByteValue(value=0); 
DATA: ByteValue(value=128), ByteValue(value=192), ByteValue(value=224), ByteValue(value=240), ByteValue(value=248), ByteValue(value=252), ByteValue(value=254), ByteValue(value=255); 
                                                                                                    ; 
DefaultXOnscreenOfs:                                                                                ;  B
DATA: ByteValue(value=7), ByteValue(value=15), ByteValue(value=7)                                   ; 
                                                                                                    ; 
GetXOffscreenBits:                                                                                  ; fun(X): AX B
STX $04                       ; save position in buffer to here                                     ; 
LDY #$01                      ; start with right side of screen                                     ; 
XOfsLoop:  LDA ScreenEdge_X_Pos,Y; get pixel coordinate of edge                                     ;  B
SEC                           ; get difference between pixel coordinate of edge                     ; 
SBC SprObject_X_Position,X    ; and pixel coordinate of object position                             ; 
STA $07                       ; store here                                                          ; 
LDA ScreenEdge_PageLoc,Y      ; get page location of edge                                           ; 
SBC SprObject_PageLoc,X       ; subtract from page location of object position                      ; 
LDX DefaultXOnscreenOfs,Y     ; load offset value here                                              ; 
CMP #$00                                                                                            ; 
BMI XLdBData                  ; if beyond right edge or in front of left edge, branch               ; 
LDX DefaultXOnscreenOfs+1,Y   ; if not, load alternate offset value here                            ;  B
CMP #$01                                                                                            ; 
BPL XLdBData                  ; if one page or more to the left of either edge, branch              ; 
LDA #$38                      ; if no branching, load value here and store                          ;  B
STA $06                                                                                             ; 
LDA #$08                      ; load some other value and execute subroutine                        ; 
JSR DividePDiff                                                                                     ; 
XLdBData:  LDA XOffscreenBitsData,X; get bits here                                                  ;  B
LDX $04                       ; reobtain position in buffer                                         ; 
CMP #$00                      ; if bits not zero, branch to leave                                   ; 
BNE ExXOfsBS                                                                                        ; 
DEY                           ; otherwise, do left side of screen now                               ;  B
BPL XOfsLoop                  ; branch if not already done with left side                           ; 
ExXOfsBS:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
YOffscreenBitsData:                                                                                 ;  B
DATA: ByteValue(value=0), ByteValue(value=8), ByteValue(value=12), ByteValue(value=14)              ; 
DATA: ByteValue(value=15), ByteValue(value=7), ByteValue(value=3), ByteValue(value=1)               ; 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
DefaultYOnscreenOfs:                                                                                ;  B
DATA: ByteValue(value=4), ByteValue(value=0), ByteValue(value=4)                                    ; 
                                                                                                    ; 
HighPosUnitData:                                                                                    ;  B
DATA: ByteValue(value=255), ByteValue(value=0)                                                      ; 
                                                                                                    ; 
GetYOffscreenBits:                                                                                  ;  B
STX $04                       ; save position in buffer to here                                     ; 
LDY #$01                      ; start with top of screen                                            ; 
YOfsLoop:  LDA HighPosUnitData,Y; load coordinate for edge of vertical unit                         ;  B
SEC                                                                                                 ; 
SBC SprObject_Y_Position,X    ; subtract from vertical coordinate of object                         ; 
STA $07                       ; store here                                                          ; 
LDA #$01                      ; subtract one from vertical high byte of object                      ; 
SBC SprObject_Y_HighPos,X                                                                           ; 
LDX DefaultYOnscreenOfs,Y     ; load offset value here                                              ; 
CMP #$00                                                                                            ; 
BMI YLdBData                  ; if under top of the screen or beyond bottom, branch                 ; 
LDX DefaultYOnscreenOfs+1,Y   ; if not, load alternate offset value here                            ;  B
CMP #$01                                                                                            ; 
BPL YLdBData                  ; if one vertical unit or more above the screen, branch               ; 
LDA #$20                      ; if no branching, load value here and store                          ;  B
STA $06                                                                                             ; 
LDA #$04                      ; load some other value and execute subroutine                        ; 
JSR DividePDiff                                                                                     ; 
YLdBData:  LDA YOffscreenBitsData,X; get offscreen data bits using offset                           ;  B
LDX $04                       ; reobtain position in buffer                                         ; 
CMP #$00                                                                                            ; 
BNE ExYOfsBS                  ; if bits not zero, branch to leave                                   ; 
DEY                           ; otherwise, do bottom of the screen now                              ;  B
BPL YOfsLoop                                                                                        ; 
ExYOfsBS:  RTS                                                                                      ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
DividePDiff:                                                                                        ; fun(A$07$06Y):  B
STA $05                       ; store current value in A here                                       ; 
LDA $07                       ; get pixel difference                                                ; 
CMP $06                       ; compare to preset value                                             ; 
BCS ExDivPD                   ; if pixel difference >= preset value, branch                         ; 
LSR                           ; divide by eight                                                     ;  B
LSR                                                                                                 ; 
LSR                                                                                                 ; 
AND #$07                      ; mask out all but 3 LSB                                              ; 
CPY #$01                      ; right side of the screen or top?                                    ; 
BCS SetOscrO                  ; if so, branch, use difference / 8 as offset                         ; 
ADC $05                       ; if not, add value to difference / 8                                 ;  B
SetOscrO:  TAX                ; use as offset                                                       ;  B
ExDivPD:  RTS                 ; leave                                                               ;  B
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                              ; $00-$01 - tile numbers                                              ; 
                              ; $02 - Y coordinate                                                  ; 
                              ; $03 - flip control                                                  ; 
                              ; $04 - sprite attributes                                             ; 
                              ; $05 - X coordinate                                                  ; 
                                                                                                    ; 
DrawSpriteObject:                                                                                   ;  B
LDA $03                       ; get saved flip control bits                                         ; 
LSR                                                                                                 ; 
LSR                           ; move d1 into carry                                                  ; 
LDA $00                                                                                             ; 
BCC NoHFlip                   ; if d1 not set, branch                                               ; 
STA Sprite_Tilenumber+4,Y     ; store first tile into second sprite                                 ;  B
LDA $01                       ; and second into first sprite                                        ; 
STA Sprite_Tilenumber,Y                                                                             ; 
LDA #$40                      ; activate horizontal flip OAM attribute                              ; 
BNE SetHFAt                   ; and unconditionally branch                                          ; 
NoHFlip:  STA Sprite_Tilenumber,Y; store first tile into first sprite                               ;  B
LDA $01                       ; and second into second sprite                                       ; 
STA Sprite_Tilenumber+4,Y                                                                           ; 
LDA #$00                      ; clear bit for horizontal flip                                       ; 
SetHFAt:  ORA $04             ; add other OAM attributes if necessary                               ;  B
STA Sprite_Attributes,Y       ; store sprite attributes                                             ; 
STA Sprite_Attributes+4,Y                                                                           ; 
LDA $02                       ; now the y coordinates                                               ; 
STA Sprite_Y_Position,Y       ; note because they are                                               ; 
STA Sprite_Y_Position+4,Y     ; side by side, they are the same                                     ; 
LDA $05                                                                                             ; 
STA Sprite_X_Position,Y       ; store x coordinate, then                                            ; 
CLC                           ; add 8 pixels and store another to                                   ; 
ADC #$08                      ; put them side by side                                               ; 
STA Sprite_X_Position+4,Y                                                                           ; 
LDA $02                       ; add eight pixels to the next y                                      ; 
CLC                           ; coordinate                                                          ; 
ADC #$08                                                                                            ; 
STA $02                                                                                             ; 
TYA                           ; add eight to the offset in Y to                                     ; 
CLC                           ; move to the next two sprites                                        ; 
ADC #$08                                                                                            ; 
TAY                                                                                                 ; 
INX                           ; increment offset to return it to the                                ; 
INX                           ; routine that called this subroutine                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
                              ; unused space                                                        ; 
DATA: ByteValue(value=255), ByteValue(value=255), ByteValue(value=255), ByteValue(value=255), ByteValue(value=255), ByteValue(value=255); 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                                                                                                    ; 
SoundEngine:                                                                                        ; fun():  B
LDA OperMode                  ; are we in title screen mode?                                        ; 
BNE SndOn                                                                                           ; 
STA SND_MASTERCTRL_REG        ; if so, disable sound and leave                                      ;  B
RTS                                                                                                 ; 
SndOn:  LDA #$ff                                                                                    ;  B
STA JOYPAD_PORT2              ; disable irqs and set frame counter mode???                          ; 
LDA #$0f                                                                                            ; 
STA SND_MASTERCTRL_REG        ; enable first four channels                                          ; 
LDA PauseModeFlag             ; is sound already in pause mode?                                     ; 
BNE InPause                                                                                         ; 
LDA PauseSoundQueue           ; if not, check pause sfx queue                                       ;  B
CMP #$01                                                                                            ; 
BNE RunSoundSubroutines       ; if queue is empty, skip pause mode routine                          ; 
InPause:  LDA PauseSoundBuffer; check pause sfx buffer                                              ;  B
BNE ContPau                                                                                         ; 
LDA PauseSoundQueue           ; check pause queue                                                   ;  B
BEQ SkipSoundSubroutines                                                                            ; 
STA PauseSoundBuffer          ; if queue full, store in buffer and activate                         ;  B
STA PauseModeFlag             ; pause mode to interrupt game sounds                                 ; 
LDA #$00                      ; disable sound and clear sfx buffers                                 ; 
STA SND_MASTERCTRL_REG                                                                              ; 
STA Square1SoundBuffer                                                                              ; 
STA Square2SoundBuffer                                                                              ; 
STA NoiseSoundBuffer                                                                                ; 
LDA #$0f                                                                                            ; 
STA SND_MASTERCTRL_REG        ; enable sound again                                                  ; 
LDA #$2a                      ; store length of sound in pause counter                              ; 
STA Squ1_SfxLenCounter                                                                              ; 
PTone1F:  LDA #$44            ; play first tone                                                     ;  B
BNE PTRegC                    ; unconditional branch                                                ; 
ContPau:  LDA Squ1_SfxLenCounter; check pause length left                                           ;  B
CMP #$24                      ; time to play second?                                                ; 
BEQ PTone2F                                                                                         ; 
CMP #$1e                      ; time to play first again?                                           ;  B
BEQ PTone1F                                                                                         ; 
CMP #$18                      ; time to play second again?                                          ;  B
BNE DecPauC                   ; only load regs during times, otherwise skip                         ; 
PTone2F:  LDA #$64            ; store reg contents and play the pause sfx                           ;  B
PTRegC:  LDX #$84                                                                                   ;  B
LDY #$7f                                                                                            ; 
JSR PlaySqu1Sfx                                                                                     ; 
DecPauC:  DEC Squ1_SfxLenCounter; decrement pause sfx counter                                       ;  B
BNE SkipSoundSubroutines                                                                            ; 
LDA #$00                      ; disable sound if in pause mode and                                  ;  B
STA SND_MASTERCTRL_REG        ; not currently playing the pause sfx                                 ; 
LDA PauseSoundBuffer          ; if no longer playing pause sfx, check to see                        ; 
CMP #$02                      ; if we need to be playing sound again                                ; 
BNE SkipPIn                                                                                         ; 
LDA #$00                      ; clear pause mode to allow game sounds again                         ;  B
STA PauseModeFlag                                                                                   ; 
SkipPIn:  LDA #$00            ; clear pause sfx buffer                                              ;  B
STA PauseSoundBuffer                                                                                ; 
BEQ SkipSoundSubroutines                                                                            ; 
                                                                                                    ;  B
RunSoundSubroutines:                                                                                ;  B
JSR Square1SfxHandler         ; play sfx on square channel 1                                        ; 
JSR Square2SfxHandler         ; ''  ''  '' square channel 2                                         ; 
JSR NoiseSfxHandler           ; ''  ''  '' noise channel                                            ; 
JSR MusicHandler              ; play music on all channels                                          ; 
LDA #$00                      ; clear the music queues                                              ; 
STA AreaMusicQueue                                                                                  ; 
STA EventMusicQueue                                                                                 ; 
                                                                                                    ; 
SkipSoundSubroutines:                                                                               ;  B
LDA #$00                      ; clear the sound effects queues                                      ; 
STA Square1SoundQueue                                                                               ; 
STA Square2SoundQueue                                                                               ; 
STA NoiseSoundQueue                                                                                 ; 
STA PauseSoundQueue                                                                                 ; 
LDY DAC_Counter               ; load some sort of counter                                           ; 
LDA AreaMusicBuffer                                                                                 ; 
AND #%00000011                ; check for specific music                                            ; 
BEQ NoIncDAC                                                                                        ; 
INC DAC_Counter               ; increment and check counter                                         ;  B
CPY #$30                                                                                            ; 
BCC StrWave                   ; if not there yet, just store it                                     ; 
NoIncDAC:  TYA                                                                                      ;  B
BEQ StrWave                   ; if we are at zero, do not decrement                                 ; 
DEC DAC_Counter               ; decrement counter                                                   ;  B
StrWave:  STY SND_DELTA_REG+1 ; store into DMC load register (??)                                   ;  B
RTS                           ; we are done here                                                    ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
Dump_Squ1_Regs:                                                                                     ; fun(YX):  B
STY SND_SQUARE1_REG+1         ; dump the contents of X and Y into square 1's control regs           ; 
STX SND_SQUARE1_REG                                                                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
PlaySqu1Sfx:                                                                                        ; fun():  B
JSR Dump_Squ1_Regs            ; do sub to set ctrl regs for square 1, then set frequency regs       ; 
                                                                                                    ; 
SetFreq_Squ1:                                                                                       ; fun(A): ZeroFlag B
LDX #$00                      ; set frequency reg offset for square 1 sound channel                 ; 
                                                                                                    ; 
Dump_Freq_Regs:                                                                                     ;  B
TAY                                                                                                 ; 
LDA FreqRegLookupTbl+1,Y      ; use previous contents of A for sound reg offset                     ; 
BEQ NoTone                    ; if zero, then do not load                                           ; 
STA SND_REGISTER+2,X          ; first byte goes into LSB of frequency divider                       ;  B
LDA FreqRegLookupTbl,Y        ; second byte goes into 3 MSB plus extra bit for                      ; 
ORA #%00001000                ; length counter                                                      ; 
STA SND_REGISTER+3,X                                                                                ; 
NoTone:  RTS                                                                                        ;  B
                                                                                                    ;  B
Dump_Sq2_Regs:                                                                                      ; fun(XY):  B
STX SND_SQUARE2_REG           ; dump the contents of X and Y into square 2's control regs           ; 
STY SND_SQUARE2_REG+1                                                                               ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
PlaySqu2Sfx:                                                                                        ; fun():  B
JSR Dump_Sq2_Regs             ; do sub to set ctrl regs for square 2, then set frequency regs       ; 
                                                                                                    ; 
SetFreq_Squ2:                                                                                       ; fun(A): ZeroFlag B
LDX #$04                      ; set frequency reg offset for square 2 sound channel                 ; 
BNE Dump_Freq_Regs            ; unconditional branch                                                ; 
                                                                                                    ;  B
SetFreq_Tri:                                                                                        ; fun(A):  B
LDX #$08                      ; set frequency reg offset for triangle sound channel                 ; 
BNE Dump_Freq_Regs            ; unconditional branch                                                ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
SwimStompEnvelopeData:                                                                              ;  B
DATA: ByteValue(value=159), ByteValue(value=155), ByteValue(value=152), ByteValue(value=150), ByteValue(value=149), ByteValue(value=148), ByteValue(value=146), ByteValue(value=144); 
DATA: ByteValue(value=144), ByteValue(value=154), ByteValue(value=151), ByteValue(value=149), ByteValue(value=147), ByteValue(value=146); 
                                                                                                    ; 
PlayFlagpoleSlide:                                                                                  ;  B
LDA #$40                      ; store length of flagpole sound                                      ; 
STA Squ1_SfxLenCounter                                                                              ; 
LDA #$62                      ; load part of reg contents for flagpole sound                        ; 
JSR SetFreq_Squ1                                                                                    ; 
LDX #$99                      ; now load the rest                                                   ; 
BNE FPS2nd                                                                                          ; 
                                                                                                    ;  B
PlaySmallJump:                                                                                      ;  B
LDA #$26                      ; branch here for small mario jumping sound                           ; 
BNE JumpRegContents                                                                                 ; 
                                                                                                    ;  B
PlayBigJump:                                                                                        ;  B
LDA #$18                      ; branch here for big mario jumping sound                             ; 
                                                                                                    ; 
JumpRegContents:                                                                                    ;  B
LDX #$82                      ; note that small and big jump borrow each others' reg contents       ; 
LDY #$a7                      ; anyway, this loads the first part of mario's jumping sound          ; 
JSR PlaySqu1Sfx                                                                                     ; 
LDA #$28                      ; store length of sfx for both jumping sounds                         ; 
STA Squ1_SfxLenCounter        ; then continue on here                                               ; 
                                                                                                    ; 
ContinueSndJump:                                                                                    ;  B
LDA Squ1_SfxLenCounter        ; jumping sounds seem to be composed of three parts                   ; 
CMP #$25                      ; check for time to play second part yet                              ; 
BNE N2Prt                                                                                           ; 
LDX #$5f                      ; load second part                                                    ;  B
LDY #$f6                                                                                            ; 
BNE DmpJpFPS                  ; unconditional branch                                                ; 
N2Prt:  CMP #$20              ; check for third part                                                ;  B
BNE DecJpFPS                                                                                        ; 
LDX #$48                      ; load third part                                                     ;  B
FPS2nd:  LDY #$bc             ; the flagpole slide sound shares part of third part                  ;  B
DmpJpFPS:  JSR Dump_Squ1_Regs                                                                       ;  B
BNE DecJpFPS                  ; unconditional branch outta here                                     ; 
                                                                                                    ;  B
PlayFireballThrow:                                                                                  ;  B
LDA #$05                                                                                            ; 
LDY #$99                      ; load reg contents for fireball throw sound                          ; 
BNE Fthrow                    ; unconditional branch                                                ; 
                                                                                                    ;  B
PlayBump:                                                                                           ;  B
LDA #$0a                      ; load length of sfx and reg contents for bump sound                  ; 
LDY #$93                                                                                            ; 
Fthrow:  LDX #$9e             ; the fireball sound shares reg contents with the bump sound          ;  B
STA Squ1_SfxLenCounter                                                                              ; 
LDA #$0c                      ; load offset for bump sound                                          ; 
JSR PlaySqu1Sfx                                                                                     ; 
                                                                                                    ; 
ContinueBumpThrow:                                                                                  ;  B
LDA Squ1_SfxLenCounter        ; check for second part of bump sound                                 ; 
CMP #$06                                                                                            ; 
BNE DecJpFPS                                                                                        ; 
LDA #$bb                      ; load second part directly                                           ;  B
STA SND_SQUARE1_REG+1                                                                               ; 
DecJpFPS:  BNE BranchToDecLength1; unconditional branch                                             ;  B
                                                                                                    ;  B
                                                                                                    ; 
Square1SfxHandler:                                                                                  ; fun():  B
LDY Square1SoundQueue         ; check for sfx in queue                                              ; 
BEQ CheckSfx1Buffer                                                                                 ; 
STY Square1SoundBuffer        ; if found, put in buffer                                             ;  B
BMI PlaySmallJump             ; small jump                                                          ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlayBigJump               ; big jump                                                            ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlayBump                  ; bump                                                                ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlaySwimStomp             ; swim/stomp                                                          ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlaySmackEnemy            ; smack enemy                                                         ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlayPipeDownInj           ; pipedown/injury                                                     ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlayFireballThrow         ; fireball throw                                                      ; 
LSR Square1SoundQueue                                                                               ;  B
BCS PlayFlagpoleSlide         ; slide flagpole                                                      ; 
                                                                                                    ;  B
CheckSfx1Buffer:                                                                                    ;  B
LDA Square1SoundBuffer        ; check for sfx in buffer                                             ; 
BEQ ExS1H                     ; if not found, exit sub                                              ; 
BMI ContinueSndJump           ; small mario jump                                                    ;  B
LSR                                                                                                 ;  B
BCS ContinueSndJump           ; big mario jump                                                      ; 
LSR                                                                                                 ;  B
BCS ContinueBumpThrow         ; bump                                                                ; 
LSR                                                                                                 ;  B
BCS ContinueSwimStomp         ; swim/stomp                                                          ; 
LSR                                                                                                 ;  B
BCS ContinueSmackEnemy        ; smack enemy                                                         ; 
LSR                                                                                                 ;  B
BCS ContinuePipeDownInj       ; pipedown/injury                                                     ; 
LSR                                                                                                 ;  B
BCS ContinueBumpThrow         ; fireball throw                                                      ; 
LSR                                                                                                 ;  B
BCS DecrementSfx1Length       ; slide flagpole                                                      ; 
ExS1H:  RTS                                                                                         ;  B
                                                                                                    ;  B
PlaySwimStomp:                                                                                      ;  B
LDA #$0e                      ; store length of swim/stomp sound                                    ; 
STA Squ1_SfxLenCounter                                                                              ; 
LDY #$9c                      ; store reg contents for swim/stomp sound                             ; 
LDX #$9e                                                                                            ; 
LDA #$26                                                                                            ; 
JSR PlaySqu1Sfx                                                                                     ; 
                                                                                                    ; 
ContinueSwimStomp:                                                                                  ;  B
LDY Squ1_SfxLenCounter        ; look up reg contents in data section based on                       ; 
LDA SwimStompEnvelopeData-1,Y ; length of sound left, used to control sound's                       ; 
STA SND_SQUARE1_REG           ; envelope                                                            ; 
CPY #$06                                                                                            ; 
BNE BranchToDecLength1                                                                              ; 
LDA #$9e                      ; when the length counts down to a certain point, put this            ;  B
STA SND_SQUARE1_REG+2         ; directly into the LSB of square 1's frequency divider               ; 
                                                                                                    ; 
BranchToDecLength1:                                                                                 ;  B
BNE DecrementSfx1Length       ; unconditional branch (regardless of how we got here)                ; 
                                                                                                    ;  B
PlaySmackEnemy:                                                                                     ;  B
LDA #$0e                      ; store length of smack enemy sound                                   ; 
LDY #$cb                                                                                            ; 
LDX #$9f                                                                                            ; 
STA Squ1_SfxLenCounter                                                                              ; 
LDA #$28                      ; store reg contents for smack enemy sound                            ; 
JSR PlaySqu1Sfx                                                                                     ; 
BNE DecrementSfx1Length       ; unconditional branch                                                ; 
                                                                                                    ;  B
ContinueSmackEnemy:                                                                                 ;  B
LDY Squ1_SfxLenCounter        ; check about halfway through                                         ; 
CPY #$08                                                                                            ; 
BNE SmSpc                                                                                           ; 
LDA #$a0                      ; if we're at the about-halfway point, make the second tone           ;  B
STA SND_SQUARE1_REG+2         ; in the smack enemy sound                                            ; 
LDA #$9f                                                                                            ; 
BNE SmTick                                                                                          ; 
SmSpc:  LDA #$90              ; this creates spaces in the sound, giving it its distinct noise      ;  B
SmTick:  STA SND_SQUARE1_REG                                                                        ;  B
                                                                                                    ; 
DecrementSfx1Length:                                                                                ;  B
DEC Squ1_SfxLenCounter        ; decrement length of sfx                                             ; 
BNE ExSfx1                                                                                          ; 
                                                                                                    ;  B
StopSquare1Sfx:                                                                                     ; fun():  B
LDX #$00                      ; if end of sfx reached, clear buffer                                 ; 
STX $f1                       ; and stop making the sfx                                             ; 
LDX #$0e                                                                                            ; 
STX SND_MASTERCTRL_REG                                                                              ; 
LDX #$0f                                                                                            ; 
STX SND_MASTERCTRL_REG                                                                              ; 
ExSfx1:  RTS                                                                                        ;  B
                                                                                                    ;  B
PlayPipeDownInj:                                                                                    ;  B
LDA #$2f                      ; load length of pipedown sound                                       ; 
STA Squ1_SfxLenCounter                                                                              ; 
                                                                                                    ; 
ContinuePipeDownInj:                                                                                ;  B
LDA Squ1_SfxLenCounter        ; some bitwise logic, forces the regs                                 ; 
LSR                           ; to be written to only during six specific times                     ; 
BCS NoPDwnL                   ; during which d3 must be set and d1-0 must be clear                  ; 
LSR                                                                                                 ;  B
BCS NoPDwnL                                                                                         ; 
AND #%00000010                                                                                      ;  B
BEQ NoPDwnL                                                                                         ; 
LDY #$91                      ; and this is where it actually gets written in                       ;  B
LDX #$9a                                                                                            ; 
LDA #$44                                                                                            ; 
JSR PlaySqu1Sfx                                                                                     ; 
NoPDwnL:  JMP DecrementSfx1Length                                                                   ;  B
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ExtraLifeFreqData:                                                                                  ;  B
DATA: ByteValue(value=88), ByteValue(value=2), ByteValue(value=84), ByteValue(value=86), ByteValue(value=78), ByteValue(value=68); 
                                                                                                    ; 
PowerUpGrabFreqData:                                                                                ;  B
DATA: ByteValue(value=76), ByteValue(value=82), ByteValue(value=76), ByteValue(value=72), ByteValue(value=62), ByteValue(value=54), ByteValue(value=62), ByteValue(value=54), ByteValue(value=48); 
DATA: ByteValue(value=40), ByteValue(value=74), ByteValue(value=80), ByteValue(value=74), ByteValue(value=100), ByteValue(value=60), ByteValue(value=50), ByteValue(value=60), ByteValue(value=50); 
DATA: ByteValue(value=44), ByteValue(value=36), ByteValue(value=58), ByteValue(value=100), ByteValue(value=58), ByteValue(value=52), ByteValue(value=44), ByteValue(value=34), ByteValue(value=44); 
                                                                                                    ; 
                              ; residual frequency data                                             ; 
DATA: ByteValue(value=34), ByteValue(value=28), ByteValue(value=20)                                 ; 
                                                                                                    ; 
PUp_VGrow_FreqData:                                                                                 ;  B
DATA: ByteValue(value=20), ByteValue(value=4), ByteValue(value=34), ByteValue(value=36), ByteValue(value=22), ByteValue(value=4), ByteValue(value=36), ByteValue(value=38); used by both; 
DATA: ByteValue(value=24), ByteValue(value=4), ByteValue(value=38), ByteValue(value=40), ByteValue(value=26), ByteValue(value=4), ByteValue(value=40), ByteValue(value=42); 
DATA: ByteValue(value=28), ByteValue(value=4), ByteValue(value=42), ByteValue(value=44), ByteValue(value=30), ByteValue(value=4), ByteValue(value=44), ByteValue(value=46); used by vinegrow; 
DATA: ByteValue(value=32), ByteValue(value=4), ByteValue(value=46), ByteValue(value=48), ByteValue(value=34), ByteValue(value=4), ByteValue(value=48), ByteValue(value=50); 
                                                                                                    ; 
PlayCoinGrab:                                                                                       ;  B
LDA #$35                      ; load length of coin grab sound                                      ; 
LDX #$8d                      ; and part of reg contents                                            ; 
BNE CGrab_TTickRegL                                                                                 ; 
                                                                                                    ;  B
PlayTimerTick:                                                                                      ;  B
LDA #$06                      ; load length of timer tick sound                                     ; 
LDX #$98                      ; and part of reg contents                                            ; 
                                                                                                    ; 
CGrab_TTickRegL:                                                                                    ;  B
STA Squ2_SfxLenCounter                                                                              ; 
LDY #$7f                      ; load the rest of reg contents                                       ; 
LDA #$42                      ; of coin grab and timer tick sound                                   ; 
JSR PlaySqu2Sfx                                                                                     ; 
                                                                                                    ; 
ContinueCGrabTTick:                                                                                 ;  B
LDA Squ2_SfxLenCounter        ; check for time to play second tone yet                              ; 
CMP #$30                      ; timer tick sound also executes this, not sure why                   ; 
BNE N2Tone                                                                                          ; 
LDA #$54                      ; if so, load the tone directly into the reg                          ;  B
STA SND_SQUARE2_REG+2                                                                               ; 
N2Tone:  BNE DecrementSfx2Length                                                                    ;  B
                                                                                                    ;  B
PlayBlast:                                                                                          ;  B
LDA #$20                      ; load length of fireworks/gunfire sound                              ; 
STA Squ2_SfxLenCounter                                                                              ; 
LDY #$94                      ; load reg contents of fireworks/gunfire sound                        ; 
LDA #$5e                                                                                            ; 
BNE SBlasJ                                                                                          ; 
                                                                                                    ;  B
ContinueBlast:                                                                                      ;  B
LDA Squ2_SfxLenCounter        ; check for time to play second part                                  ; 
CMP #$18                                                                                            ; 
BNE DecrementSfx2Length                                                                             ; 
LDY #$93                      ; load second part reg contents then                                  ;  B
LDA #$18                                                                                            ; 
SBlasJ:  BNE BlstSJp          ; unconditional branch to load rest of reg contents                   ;  B
                                                                                                    ;  B
PlayPowerUpGrab:                                                                                    ;  B
LDA #$36                      ; load length of power-up grab sound                                  ; 
STA Squ2_SfxLenCounter                                                                              ; 
                                                                                                    ; 
ContinuePowerUpGrab:                                                                                ;  B
LDA Squ2_SfxLenCounter        ; load frequency reg based on length left over                        ; 
LSR                           ; divide by 2                                                         ; 
BCS DecrementSfx2Length       ; alter frequency every other frame                                   ; 
TAY                                                                                                 ;  B
LDA PowerUpGrabFreqData-1,Y   ; use length left over / 2 for frequency offset                       ; 
LDX #$5d                      ; store reg contents of power-up grab sound                           ; 
LDY #$7f                                                                                            ; 
                                                                                                    ; 
LoadSqu2Regs:                                                                                       ;  B
JSR PlaySqu2Sfx                                                                                     ; 
                                                                                                    ; 
DecrementSfx2Length:                                                                                ;  B
DEC Squ2_SfxLenCounter        ; decrement length of sfx                                             ; 
BNE ExSfx2                                                                                          ; 
                                                                                                    ;  B
EmptySfx2Buffer:                                                                                    ;  B
LDX #$00                      ; initialize square 2's sound effects buffer                          ; 
STX Square2SoundBuffer                                                                              ; 
                                                                                                    ; 
StopSquare2Sfx:                                                                                     ; fun():  B
LDX #$0d                      ; stop playing the sfx                                                ; 
STX SND_MASTERCTRL_REG                                                                              ; 
LDX #$0f                                                                                            ; 
STX SND_MASTERCTRL_REG                                                                              ; 
ExSfx2:  RTS                                                                                        ;  B
                                                                                                    ;  B
Square2SfxHandler:                                                                                  ; fun():  B
LDA Square2SoundBuffer        ; special handling for the 1-up sound to keep it                      ; 
AND #Sfx_ExtraLife            ; from being interrupted by other sounds on square 2                  ; 
BNE ContinueExtraLife                                                                               ; 
LDY Square2SoundQueue         ; check for sfx in queue                                              ;  B
BEQ CheckSfx2Buffer                                                                                 ; 
STY Square2SoundBuffer        ; if found, put in buffer and check for the following                 ;  B
BMI PlayBowserFall            ; bowser fall                                                         ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayCoinGrab              ; coin grab                                                           ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayGrowPowerUp           ; power-up reveal                                                     ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayGrowVine              ; vine grow                                                           ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayBlast                 ; fireworks/gunfire                                                   ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayTimerTick             ; timer tick                                                          ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayPowerUpGrab           ; power-up grab                                                       ; 
LSR Square2SoundQueue                                                                               ;  B
BCS PlayExtraLife             ; 1-up                                                                ; 
                                                                                                    ;  B
CheckSfx2Buffer:                                                                                    ;  B
LDA Square2SoundBuffer        ; check for sfx in buffer                                             ; 
BEQ ExS2H                     ; if not found, exit sub                                              ; 
BMI ContinueBowserFall        ; bowser fall                                                         ;  B
LSR                                                                                                 ;  B
BCS Cont_CGrab_TTick          ; coin grab                                                           ; 
LSR                                                                                                 ;  B
BCS ContinueGrowItems         ; power-up reveal                                                     ; 
LSR                                                                                                 ;  B
BCS ContinueGrowItems         ; vine grow                                                           ; 
LSR                                                                                                 ;  B
BCS ContinueBlast             ; fireworks/gunfire                                                   ; 
LSR                                                                                                 ;  B
BCS Cont_CGrab_TTick          ; timer tick                                                          ; 
LSR                                                                                                 ;  B
BCS ContinuePowerUpGrab       ; power-up grab                                                       ; 
LSR                                                                                                 ;  B
BCS ContinueExtraLife         ; 1-up                                                                ; 
ExS2H:  RTS                                                                                         ;  B
                                                                                                    ;  B
Cont_CGrab_TTick:                                                                                   ;  B
JMP ContinueCGrabTTick                                                                              ; 
                                                                                                    ;  B
JumpToDecLength2:                                                                                   ;  B
JMP DecrementSfx2Length                                                                             ; 
                                                                                                    ;  B
PlayBowserFall:                                                                                     ;  B
LDA #$38                      ; load length of bowser defeat sound                                  ; 
STA Squ2_SfxLenCounter                                                                              ; 
LDY #$c4                      ; load contents of reg for bowser defeat sound                        ; 
LDA #$18                                                                                            ; 
BlstSJp:  BNE PBFRegs                                                                               ;  B
                                                                                                    ;  B
ContinueBowserFall:                                                                                 ;  B
LDA Squ2_SfxLenCounter        ; check for almost near the end                                       ; 
CMP #$08                                                                                            ; 
BNE DecrementSfx2Length                                                                             ; 
LDY #$a4                      ; if so, load the rest of reg contents for bowser defeat sound        ;  B
LDA #$5a                                                                                            ; 
PBFRegs:  LDX #$9f            ; the fireworks/gunfire sound shares part of reg contents here        ;  B
EL_LRegs:  BNE LoadSqu2Regs   ; this is an unconditional branch outta here                          ;  B
                                                                                                    ;  B
PlayExtraLife:                                                                                      ;  B
LDA #$30                      ; load length of 1-up sound                                           ; 
STA Squ2_SfxLenCounter                                                                              ; 
                                                                                                    ; 
ContinueExtraLife:                                                                                  ;  B
LDA Squ2_SfxLenCounter                                                                              ; 
LDX #$03                      ; load new tones only every eight frames                              ; 
DivLLoop:  LSR                                                                                      ;  B
BCS JumpToDecLength2          ; if any bits set here, branch to dec the length                      ; 
DEX                                                                                                 ;  B
BNE DivLLoop                  ; do this until all bits checked, if none set, continue               ; 
TAY                                                                                                 ;  B
LDA ExtraLifeFreqData-1,Y     ; load our reg contents                                               ; 
LDX #$82                                                                                            ; 
LDY #$7f                                                                                            ; 
BNE EL_LRegs                  ; unconditional branch                                                ; 
                                                                                                    ;  B
PlayGrowPowerUp:                                                                                    ;  B
LDA #$10                      ; load length of power-up reveal sound                                ; 
BNE GrowItemRegs                                                                                    ; 
                                                                                                    ;  B
PlayGrowVine:                                                                                       ;  B
LDA #$20                      ; load length of vine grow sound                                      ; 
                                                                                                    ; 
GrowItemRegs:                                                                                       ;  B
STA Squ2_SfxLenCounter                                                                              ; 
LDA #$7f                      ; load contents of reg for both sounds directly                       ; 
STA SND_SQUARE2_REG+1                                                                               ; 
LDA #$00                      ; start secondary counter for both sounds                             ; 
STA Sfx_SecondaryCounter                                                                            ; 
                                                                                                    ; 
ContinueGrowItems:                                                                                  ;  B
INC Sfx_SecondaryCounter      ; increment secondary counter for both sounds                         ; 
LDA Sfx_SecondaryCounter      ; this sound doesn't decrement the usual counter                      ; 
LSR                           ; divide by 2 to get the offset                                       ; 
TAY                                                                                                 ; 
CPY Squ2_SfxLenCounter        ; have we reached the end yet?                                        ; 
BEQ StopGrowItems             ; if so, branch to jump, and stop playing sounds                      ; 
LDA #$9d                      ; load contents of other reg directly                                 ;  B
STA SND_SQUARE2_REG                                                                                 ; 
LDA PUp_VGrow_FreqData,Y      ; use secondary counter / 2 as offset for frequency regs              ; 
JSR SetFreq_Squ2                                                                                    ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
StopGrowItems:                                                                                      ;  B
JMP EmptySfx2Buffer           ; branch to stop playing sounds                                       ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
BrickShatterFreqData:                                                                               ;  B
DATA: ByteValue(value=1), ByteValue(value=14), ByteValue(value=14), ByteValue(value=13), ByteValue(value=11), ByteValue(value=6), ByteValue(value=12), ByteValue(value=15); 
DATA: ByteValue(value=10), ByteValue(value=9), ByteValue(value=3), ByteValue(value=13), ByteValue(value=8), ByteValue(value=13), ByteValue(value=6), ByteValue(value=12); 
                                                                                                    ; 
PlayBrickShatter:                                                                                   ;  B
LDA #$20                      ; load length of brick shatter sound                                  ; 
STA Noise_SfxLenCounter                                                                             ; 
                                                                                                    ; 
ContinueBrickShatter:                                                                               ;  B
LDA Noise_SfxLenCounter                                                                             ; 
LSR                           ; divide by 2 and check for bit set to use offset                     ; 
BCC DecrementSfx3Length                                                                             ; 
TAY                                                                                                 ;  B
LDX BrickShatterFreqData,Y    ; load reg contents of brick shatter sound                            ; 
LDA BrickShatterEnvData,Y                                                                           ; 
                                                                                                    ; 
PlayNoiseSfx:                                                                                       ;  B
STA SND_NOISE_REG             ; play the sfx                                                        ; 
STX SND_NOISE_REG+2                                                                                 ; 
LDA #$18                                                                                            ; 
STA SND_NOISE_REG+3                                                                                 ; 
                                                                                                    ; 
DecrementSfx3Length:                                                                                ;  B
DEC Noise_SfxLenCounter       ; decrement length of sfx                                             ; 
BNE ExSfx3                                                                                          ; 
LDA #$f0                      ; if done, stop playing the sfx                                       ;  B
STA SND_NOISE_REG                                                                                   ; 
LDA #$00                                                                                            ; 
STA NoiseSoundBuffer                                                                                ; 
ExSfx3:  RTS                                                                                        ;  B
                                                                                                    ;  B
NoiseSfxHandler:                                                                                    ; fun():  B
LDY NoiseSoundQueue           ; check for sfx in queue                                              ; 
BEQ CheckNoiseBuffer                                                                                ; 
STY NoiseSoundBuffer          ; if found, put in buffer                                             ;  B
LSR NoiseSoundQueue                                                                                 ; 
BCS PlayBrickShatter          ; brick shatter                                                       ; 
LSR NoiseSoundQueue                                                                                 ;  B
BCS PlayBowserFlame           ; bowser flame                                                        ; 
                                                                                                    ;  B
CheckNoiseBuffer:                                                                                   ;  B
LDA NoiseSoundBuffer          ; check for sfx in buffer                                             ; 
BEQ ExNH                      ; if not found, exit sub                                              ; 
LSR                                                                                                 ;  B
BCS ContinueBrickShatter      ; brick shatter                                                       ; 
LSR                                                                                                 ;  B
BCS ContinueBowserFlame       ; bowser flame                                                        ; 
ExNH:  RTS                                                                                          ;  B
                                                                                                    ;  B
PlayBowserFlame:                                                                                    ;  B
LDA #$40                      ; load length of bowser flame sound                                   ; 
STA Noise_SfxLenCounter                                                                             ; 
                                                                                                    ; 
ContinueBowserFlame:                                                                                ;  B
LDA Noise_SfxLenCounter                                                                             ; 
LSR                                                                                                 ; 
TAY                                                                                                 ; 
LDX #$0f                      ; load reg contents of bowser flame sound                             ; 
LDA BowserFlameEnvData-1,Y                                                                          ; 
BNE PlayNoiseSfx              ; unconditional branch here                                           ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
ContinueMusic:                                                                                      ;  B
JMP HandleSquare2Music        ; if we have music, start with square 2 channel                       ; 
                                                                                                    ;  B
MusicHandler:                                                                                       ; fun():  B
LDA EventMusicQueue           ; check event music queue                                             ; 
BNE LoadEventMusic                                                                                  ; 
LDA AreaMusicQueue            ; check area music queue                                              ;  B
BNE LoadAreaMusic                                                                                   ; 
LDA EventMusicBuffer          ; check both buffers                                                  ;  B
ORA AreaMusicBuffer                                                                                 ; 
BNE ContinueMusic                                                                                   ; 
RTS                           ; no music, then leave                                                ;  B
                                                                                                    ;  B
LoadEventMusic:                                                                                     ;  B
STA EventMusicBuffer          ; copy event music queue contents to buffer                           ; 
CMP #DeathMusic               ; is it death music?                                                  ; 
BNE NoStopSfx                 ; if not, jump elsewhere                                              ; 
JSR StopSquare1Sfx            ; stop sfx in square 1 and 2                                          ;  B
JSR StopSquare2Sfx            ; but clear only square 1's sfx buffer                                ; 
NoStopSfx:  LDX AreaMusicBuffer                                                                     ;  B
STX AreaMusicBuffer_Alt       ; save current area music buffer to be re-obtained later              ; 
LDY #$00                                                                                            ; 
STY NoteLengthTblAdder        ; default value for additional length byte offset                     ; 
STY AreaMusicBuffer           ; clear area music buffer                                             ; 
CMP #TimeRunningOutMusic      ; is it time running out music?                                       ; 
BNE FindEventMusicHeader                                                                            ; 
LDX #$08                      ; load offset to be added to length byte of header                    ;  B
STX NoteLengthTblAdder                                                                              ; 
BNE FindEventMusicHeader      ; unconditional branch                                                ; 
                                                                                                    ;  B
LoadAreaMusic:                                                                                      ;  B
CMP #$04                      ; is it underground music?                                            ; 
BNE NoStop1                   ; no, do not stop square 1 sfx                                        ; 
JSR StopSquare1Sfx                                                                                  ;  B
NoStop1:  LDY #$10            ; start counter used only by ground level music                       ;  B
GMLoopB:  STY GroundMusicHeaderOfs                                                                  ;  B
                                                                                                    ; 
HandleAreaMusicLoopB:                                                                               ;  B
LDY #$00                      ; clear event music buffer                                            ; 
STY EventMusicBuffer                                                                                ; 
STA AreaMusicBuffer           ; copy area music queue contents to buffer                            ; 
CMP #$01                      ; is it ground level music?                                           ; 
BNE FindAreaMusicHeader                                                                             ; 
INC GroundMusicHeaderOfs      ; increment but only if playing ground level music                    ;  B
LDY GroundMusicHeaderOfs      ; is it time to loopback ground level music?                          ; 
CPY #$32                                                                                            ; 
BNE LoadHeader                ; branch ahead with alternate offset                                  ; 
LDY #$11                                                                                            ;  B
BNE GMLoopB                   ; unconditional branch                                                ; 
                                                                                                    ;  B
FindAreaMusicHeader:                                                                                ;  B
LDY #$08                      ; load Y for offset of area music                                     ; 
STY MusicOffset_Square2       ; residual instruction here                                           ; 
                                                                                                    ; 
FindEventMusicHeader:                                                                               ;  B
INY                           ; increment Y pointer based on previously loaded queue contents       ; 
LSR                           ; bit shift and increment until we find a set bit for music           ; 
BCC FindEventMusicHeader                                                                            ; 
                                                                                                    ;  B
LoadHeader:                                                                                         ;  B
LDA MusicHeaderOffsetData,Y   ; load offset for header                                              ; 
TAY                                                                                                 ; 
LDA MusicHeaderData,Y         ; now load the header                                                 ; 
STA NoteLenLookupTblOfs                                                                             ; 
LDA MusicHeaderData+1,Y                                                                             ; 
STA MusicDataLow                                                                                    ; 
LDA MusicHeaderData+2,Y                                                                             ; 
STA MusicDataHigh                                                                                   ; 
LDA MusicHeaderData+3,Y                                                                             ; 
STA MusicOffset_Triangle                                                                            ; 
LDA MusicHeaderData+4,Y                                                                             ; 
STA MusicOffset_Square1                                                                             ; 
LDA MusicHeaderData+5,Y                                                                             ; 
STA MusicOffset_Noise                                                                               ; 
STA NoiseDataLoopbackOfs                                                                            ; 
LDA #$01                      ; initialize music note counters                                      ; 
STA Squ2_NoteLenCounter                                                                             ; 
STA Squ1_NoteLenCounter                                                                             ; 
STA Tri_NoteLenCounter                                                                              ; 
STA Noise_BeatLenCounter                                                                            ; 
LDA #$00                      ; initialize music data offset for square 2                           ; 
STA MusicOffset_Square2                                                                             ; 
STA AltRegContentFlag         ; initialize alternate control reg data used by square 1              ; 
LDA #$0b                      ; disable triangle channel and reenable it                            ; 
STA SND_MASTERCTRL_REG                                                                              ; 
LDA #$0f                                                                                            ; 
STA SND_MASTERCTRL_REG                                                                              ; 
                                                                                                    ; 
HandleSquare2Music:                                                                                 ;  B
DEC Squ2_NoteLenCounter       ; decrement square 2 note length                                      ; 
BNE MiscSqu2MusicTasks        ; is it time for more data?  if not, branch to end tasks              ; 
LDY MusicOffset_Square2       ; increment square 2 music offset and fetch data                      ;  B
INC MusicOffset_Square2                                                                             ; 
LDA (MusicData),Y                                                                                   ; 
BEQ EndOfMusicData            ; if zero, the data is a null terminator                              ; 
BPL Squ2NoteHandler           ; if non-negative, data is a note                                     ;  B
BNE Squ2LengthHandler         ; otherwise it is length data                                         ;  B
                                                                                                    ;  B
EndOfMusicData:                                                                                     ;  B
LDA EventMusicBuffer          ; check secondary buffer for time running out music                   ; 
CMP #TimeRunningOutMusic                                                                            ; 
BNE NotTRO                                                                                          ; 
LDA AreaMusicBuffer_Alt       ; load previously saved contents of primary buffer                    ;  B
BNE MusicLoopBack             ; and start playing the song again if there is one                    ; 
NotTRO:  AND #VictoryMusic    ; check for victory music (the only secondary that loops)             ;  B
BNE VictoryMLoopBack                                                                                ; 
LDA AreaMusicBuffer           ; check primary buffer for any music except pipe intro                ;  B
AND #%01011111                                                                                      ; 
BNE MusicLoopBack             ; if any area music except pipe intro, music loops                    ; 
LDA #$00                      ; clear primary and secondary buffers and initialize                  ;  B
STA AreaMusicBuffer           ; control regs of square and triangle channels                        ; 
STA EventMusicBuffer                                                                                ; 
STA SND_TRIANGLE_REG                                                                                ; 
LDA #$90                                                                                            ; 
STA SND_SQUARE1_REG                                                                                 ; 
STA SND_SQUARE2_REG                                                                                 ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
MusicLoopBack:                                                                                      ;  B
JMP HandleAreaMusicLoopB                                                                            ; 
                                                                                                    ;  B
VictoryMLoopBack:                                                                                   ;  B
JMP LoadEventMusic                                                                                  ; 
                                                                                                    ;  B
Squ2LengthHandler:                                                                                  ;  B
JSR ProcessLengthData         ; store length of note                                                ; 
STA Squ2_NoteLenBuffer                                                                              ; 
LDY MusicOffset_Square2       ; fetch another byte (MUST NOT BE LENGTH BYTE!)                       ; 
INC MusicOffset_Square2                                                                             ; 
LDA (MusicData),Y                                                                                   ; 
                                                                                                    ; 
Squ2NoteHandler:                                                                                    ;  B
LDX Square2SoundBuffer        ; is there a sound playing on this channel?                           ; 
BNE SkipFqL1                                                                                        ; 
JSR SetFreq_Squ2              ; no, then play the note                                              ;  B
BEQ Rest                      ; check to see if note is rest                                        ; 
JSR LoadControlRegs           ; if not, load control regs for square 2                              ;  B
Rest:  STA Squ2_EnvelopeDataCtrl; save contents of A                                                ;  B
JSR Dump_Sq2_Regs             ; dump X and Y into square 2 control regs                             ; 
SkipFqL1:  LDA Squ2_NoteLenBuffer; save length in square 2 note counter                             ;  B
STA Squ2_NoteLenCounter                                                                             ; 
                                                                                                    ; 
MiscSqu2MusicTasks:                                                                                 ;  B
LDA Square2SoundBuffer        ; is there a sound playing on square 2?                               ; 
BNE HandleSquare1Music                                                                              ; 
LDA EventMusicBuffer          ; check for death music or d4 set on secondary buffer                 ;  B
AND #%10010001                ; note that regs for death music or d4 are loaded by default          ; 
BNE HandleSquare1Music                                                                              ; 
LDY Squ2_EnvelopeDataCtrl     ; check for contents saved from LoadControlRegs                       ;  B
BEQ NoDecEnv1                                                                                       ; 
DEC Squ2_EnvelopeDataCtrl     ; decrement unless already zero                                       ;  B
NoDecEnv1:  JSR LoadEnvelopeData; do a load of envelope data to replace default                     ;  B
STA SND_SQUARE2_REG           ; based on offset set by first load unless playing                    ; 
LDX #$7f                      ; death music or d4 set on secondary buffer                           ; 
STX SND_SQUARE2_REG+1                                                                               ; 
                                                                                                    ; 
HandleSquare1Music:                                                                                 ;  B
LDY MusicOffset_Square1       ; is there a nonzero offset here?                                     ; 
BEQ HandleTriangleMusic       ; if not, skip ahead to the triangle channel                          ; 
DEC Squ1_NoteLenCounter       ; decrement square 1 note length                                      ;  B
BNE MiscSqu1MusicTasks        ; is it time for more data?                                           ; 
                                                                                                    ;  B
FetchSqu1MusicData:                                                                                 ;  B
LDY MusicOffset_Square1       ; increment square 1 music offset and fetch data                      ; 
INC MusicOffset_Square1                                                                             ; 
LDA (MusicData),Y                                                                                   ; 
BNE Squ1NoteHandler           ; if nonzero, then skip this part                                     ; 
LDA #$83                                                                                            ;  B
STA SND_SQUARE1_REG           ; store some data into control regs for square 1                      ; 
LDA #$94                      ; and fetch another byte of data, used to give                        ; 
STA SND_SQUARE1_REG+1         ; death music its unique sound                                        ; 
STA AltRegContentFlag                                                                               ; 
BNE FetchSqu1MusicData        ; unconditional branch                                                ; 
                                                                                                    ;  B
Squ1NoteHandler:                                                                                    ;  B
JSR AlternateLengthHandler                                                                          ; 
STA Squ1_NoteLenCounter       ; save contents of A in square 1 note counter                         ; 
LDY Square1SoundBuffer        ; is there a sound playing on square 1?                               ; 
BNE HandleTriangleMusic                                                                             ; 
TXA                                                                                                 ;  B
AND #%00111110                ; change saved data to appropriate note format                        ; 
JSR SetFreq_Squ1              ; play the note                                                       ; 
BEQ SkipCtrlL                                                                                       ; 
JSR LoadControlRegs                                                                                 ;  B
SkipCtrlL:  STA Squ1_EnvelopeDataCtrl; save envelope offset                                         ;  B
JSR Dump_Squ1_Regs                                                                                  ; 
                                                                                                    ; 
MiscSqu1MusicTasks:                                                                                 ;  B
LDA Square1SoundBuffer        ; is there a sound playing on square 1?                               ; 
BNE HandleTriangleMusic                                                                             ; 
LDA EventMusicBuffer          ; check for death music or d4 set on secondary buffer                 ;  B
AND #%10010001                                                                                      ; 
BNE DeathMAltReg                                                                                    ; 
LDY Squ1_EnvelopeDataCtrl     ; check saved envelope offset                                         ;  B
BEQ NoDecEnv2                                                                                       ; 
DEC Squ1_EnvelopeDataCtrl     ; decrement unless already zero                                       ;  B
NoDecEnv2:  JSR LoadEnvelopeData; do a load of envelope data                                        ;  B
STA SND_SQUARE1_REG           ; based on offset set by first load                                   ; 
DeathMAltReg:  LDA AltRegContentFlag; check for alternate control reg data                          ;  B
BNE DoAltLoad                                                                                       ; 
LDA #$7f                      ; load this value if zero, the alternate value                        ;  B
DoAltLoad:  STA SND_SQUARE1_REG+1; if nonzero, and let's move on                                    ;  B
                                                                                                    ; 
HandleTriangleMusic:                                                                                ;  B
LDA MusicOffset_Triangle                                                                            ; 
DEC Tri_NoteLenCounter        ; decrement triangle note length                                      ; 
BNE HandleNoiseMusic          ; is it time for more data?                                           ; 
LDY MusicOffset_Triangle      ; increment square 1 music offset and fetch data                      ;  B
INC MusicOffset_Triangle                                                                            ; 
LDA (MusicData),Y                                                                                   ; 
BEQ LoadTriCtrlReg            ; if zero, skip all this and move on to noise                         ; 
BPL TriNoteHandler            ; if non-negative, data is note                                       ;  B
JSR ProcessLengthData         ; otherwise, it is length data                                        ;  B
STA Tri_NoteLenBuffer         ; save contents of A                                                  ; 
LDA #$1f                                                                                            ; 
STA SND_TRIANGLE_REG          ; load some default data for triangle control reg                     ; 
LDY MusicOffset_Triangle      ; fetch another byte                                                  ; 
INC MusicOffset_Triangle                                                                            ; 
LDA (MusicData),Y                                                                                   ; 
BEQ LoadTriCtrlReg            ; check once more for nonzero data                                    ; 
                                                                                                    ;  B
TriNoteHandler:                                                                                     ;  B
JSR SetFreq_Tri                                                                                     ; 
LDX Tri_NoteLenBuffer         ; save length in triangle note counter                                ; 
STX Tri_NoteLenCounter                                                                              ; 
LDA EventMusicBuffer                                                                                ; 
AND #%01101110                ; check for death music or d4 set on secondary buffer                 ; 
BNE NotDOrD4                  ; if playing any other secondary, skip primary buffer check           ; 
LDA AreaMusicBuffer           ; check primary buffer for water or castle level music                ;  B
AND #%00001010                                                                                      ; 
BEQ HandleNoiseMusic          ; if playing any other primary, or death or d4, go on to noise routine; 
NotDOrD4:  TXA                ; if playing water or castle music or any secondary                   ;  B
CMP #$12                      ; besides death music or d4 set, check length of note                 ; 
BCS LongN                                                                                           ; 
LDA EventMusicBuffer          ; check for win castle music again if not playing a long note         ;  B
AND #EndOfCastleMusic                                                                               ; 
BEQ MediN                                                                                           ; 
LDA #$0f                      ; load value $0f if playing the win castle music and playing a short  ;  B
BNE LoadTriCtrlReg            ; note, load value $1f if playing water or castle level music or any  ; 
MediN:  LDA #$1f              ; secondary besides death and d4 except win castle or win castle and playing;  B
BNE LoadTriCtrlReg            ; a short note, and load value $ff if playing a long note on water, castle; 
LongN:  LDA #$ff              ; or any secondary (including win castle) except death and d4         ;  B
                                                                                                    ; 
LoadTriCtrlReg:                                                                                     ;  B
STA SND_TRIANGLE_REG          ; save final contents of A into control reg for triangle              ; 
                                                                                                    ; 
HandleNoiseMusic:                                                                                   ;  B
LDA AreaMusicBuffer           ; check if playing underground or castle music                        ; 
AND #%11110011                                                                                      ; 
BEQ ExitMusicHandler          ; if so, skip the noise routine                                       ; 
DEC Noise_BeatLenCounter      ; decrement noise beat length                                         ;  B
BNE ExitMusicHandler          ; is it time for more data?                                           ; 
                                                                                                    ;  B
FetchNoiseBeatData:                                                                                 ;  B
LDY MusicOffset_Noise         ; increment noise beat offset and fetch data                          ; 
INC MusicOffset_Noise                                                                               ; 
LDA (MusicData),Y             ; get noise beat data, if nonzero, branch to handle                   ; 
BNE NoiseBeatHandler                                                                                ; 
LDA NoiseDataLoopbackOfs      ; if data is zero, reload original noise beat offset                  ;  B
STA MusicOffset_Noise         ; and loopback next time around                                       ; 
BNE FetchNoiseBeatData        ; unconditional branch                                                ; 
                                                                                                    ;  B
NoiseBeatHandler:                                                                                   ;  B
JSR AlternateLengthHandler                                                                          ; 
STA Noise_BeatLenCounter      ; store length in noise beat counter                                  ; 
TXA                                                                                                 ; 
AND #%00111110                ; reload data and erase length bits                                   ; 
BEQ SilentBeat                ; if no beat data, silence                                            ; 
CMP #$30                      ; check the beat data and play the appropriate                        ;  B
BEQ LongBeat                  ; noise accordingly                                                   ; 
CMP #$20                                                                                            ;  B
BEQ StrongBeat                                                                                      ; 
AND #%00010000                                                                                      ;  B
BEQ SilentBeat                                                                                      ; 
LDA #$1c                      ; short beat data                                                     ;  B
LDX #$03                                                                                            ; 
LDY #$18                                                                                            ; 
BNE PlayBeat                                                                                        ; 
                                                                                                    ;  B
StrongBeat:                                                                                         ;  B
LDA #$1c                      ; strong beat data                                                    ; 
LDX #$0c                                                                                            ; 
LDY #$18                                                                                            ; 
BNE PlayBeat                                                                                        ; 
                                                                                                    ;  B
LongBeat:                                                                                           ;  B
LDA #$1c                      ; long beat data                                                      ; 
LDX #$03                                                                                            ; 
LDY #$58                                                                                            ; 
BNE PlayBeat                                                                                        ; 
                                                                                                    ;  B
SilentBeat:                                                                                         ;  B
LDA #$10                      ; silence                                                             ; 
                                                                                                    ; 
PlayBeat:                                                                                           ;  B
STA SND_NOISE_REG             ; load beat data into noise regs                                      ; 
STX SND_NOISE_REG+2                                                                                 ; 
STY SND_NOISE_REG+3                                                                                 ; 
                                                                                                    ; 
ExitMusicHandler:                                                                                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
AlternateLengthHandler:                                                                             ; fun(ACarryFlag): AX B
TAX                           ; save a copy of original byte into X                                 ; 
ROR                           ; save LSB from original byte into carry                              ; 
TXA                           ; reload original byte and rotate three times                         ; 
ROL                           ; turning xx00000x into 00000xxx, with the                            ; 
ROL                           ; bit in carry as the MSB here                                        ; 
ROL                                                                                                 ; 
                                                                                                    ; 
ProcessLengthData:                                                                                  ; fun(A): A B
AND #%00000111                ; clear all but the three LSBs                                        ; 
CLC                                                                                                 ; 
ADC $f0                       ; add offset loaded from first header byte                            ; 
ADC NoteLengthTblAdder        ; add extra if time running out music                                 ; 
TAY                                                                                                 ; 
LDA MusicLengthLookupTbl,Y    ; load length                                                         ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
LoadControlRegs:                                                                                    ; fun():  B
LDA EventMusicBuffer          ; check secondary buffer for win castle music                         ; 
AND #EndOfCastleMusic                                                                               ; 
BEQ NotECstlM                                                                                       ; 
LDA #$04                      ; this value is only used for win castle music                        ;  B
BNE AllMus                    ; unconditional branch                                                ; 
NotECstlM:  LDA AreaMusicBuffer                                                                     ;  B
AND #%01111101                ; check primary buffer for water music                                ; 
BEQ WaterMus                                                                                        ; 
LDA #$08                      ; this is the default value for all other music                       ;  B
BNE AllMus                                                                                          ; 
WaterMus:  LDA #$28           ; this value is used for water music and all other event music        ;  B
AllMus:  LDX #$82             ; load contents of other sound regs for square 2                      ;  B
LDY #$7f                                                                                            ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
LoadEnvelopeData:                                                                                   ; fun(): A B
LDA EventMusicBuffer          ; check secondary buffer for win castle music                         ; 
AND #EndOfCastleMusic                                                                               ; 
BEQ LoadUsualEnvData                                                                                ; 
LDA EndOfCastleMusicEnvData,Y ; load data from offset for win castle music                          ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
LoadUsualEnvData:                                                                                   ;  B
LDA AreaMusicBuffer           ; check primary buffer for water music                                ; 
AND #%01111101                                                                                      ; 
BEQ LoadWaterEventMusEnvData                                                                        ; 
LDA AreaMusicEnvData,Y        ; load default data from offset for all other music                   ;  B
RTS                                                                                                 ; 
                                                                                                    ;  B
LoadWaterEventMusEnvData:                                                                           ;  B
LDA WaterEventMusEnvData,Y    ; load data from offset for water music and all other event music     ; 
RTS                                                                                                 ; 
                                                                                                    ;  B
                              ; --------------------------------                                    ; 
                                                                                                    ; 
                              ; music header offsets                                                ; 
                                                                                                    ; 
MusicHeaderData:                                                                                    ;  B
DATA: Expr(expr=DeathMusHdr-MHD); event music                                                       ; 
DATA: Expr(expr=GameOverMusHdr-MHD)                                                                 ; 
DATA: Expr(expr=VictoryMusHdr-MHD)                                                                  ; 
DATA: Expr(expr=WinCastleMusHdr-MHD)                                                                ; 
DATA: Expr(expr=GameOverMusHdr-MHD)                                                                 ; 
DATA: Expr(expr=EndOfLevelMusHdr-MHD)                                                               ; 
DATA: Expr(expr=TimeRunningOutHdr-MHD)                                                              ; 
DATA: Expr(expr=SilenceHdr-MHD)                                                                     ; 
                                                                                                    ; 
DATA: Expr(expr=GroundLevelPart1Hdr-MHD); area music                                                ; 
DATA: Expr(expr=WaterMusHdr-MHD)                                                                    ; 
DATA: Expr(expr=UndergroundMusHdr-MHD)                                                              ; 
DATA: Expr(expr=CastleMusHdr-MHD)                                                                   ; 
DATA: Expr(expr=Star_CloudHdr-MHD)                                                                  ; 
DATA: Expr(expr=GroundLevelLeadInHdr-MHD)                                                           ; 
DATA: Expr(expr=Star_CloudHdr-MHD)                                                                  ; 
DATA: Expr(expr=SilenceHdr-MHD)                                                                     ; 
                                                                                                    ; 
DATA: Expr(expr=GroundLevelLeadInHdr-MHD); ground level music layout                                ; 
DATA: Expr(expr=GroundLevelPart1Hdr-MHD), Expr(expr=GroundLevelPart1Hdr-MHD)                        ; 
DATA: Expr(expr=GroundLevelPart2AHdr-MHD), Expr(expr=GroundLevelPart2BHdr-MHD), Expr(expr=GroundLevelPart2AHdr-MHD), Expr(expr=GroundLevelPart2CHdr-MHD); 
DATA: Expr(expr=GroundLevelPart2AHdr-MHD), Expr(expr=GroundLevelPart2BHdr-MHD), Expr(expr=GroundLevelPart2AHdr-MHD), Expr(expr=GroundLevelPart2CHdr-MHD); 
DATA: Expr(expr=GroundLevelPart3AHdr-MHD), Expr(expr=GroundLevelPart3BHdr-MHD), Expr(expr=GroundLevelPart3AHdr-MHD), Expr(expr=GroundLevelLeadInHdr-MHD); 
DATA: Expr(expr=GroundLevelPart1Hdr-MHD), Expr(expr=GroundLevelPart1Hdr-MHD)                        ; 
DATA: Expr(expr=GroundLevelPart4AHdr-MHD), Expr(expr=GroundLevelPart4BHdr-MHD), Expr(expr=GroundLevelPart4AHdr-MHD), Expr(expr=GroundLevelPart4CHdr-MHD); 
DATA: Expr(expr=GroundLevelPart4AHdr-MHD), Expr(expr=GroundLevelPart4BHdr-MHD), Expr(expr=GroundLevelPart4AHdr-MHD), Expr(expr=GroundLevelPart4CHdr-MHD); 
DATA: Expr(expr=GroundLevelPart3AHdr-MHD), Expr(expr=GroundLevelPart3BHdr-MHD), Expr(expr=GroundLevelPart3AHdr-MHD), Expr(expr=GroundLevelLeadInHdr-MHD); 
DATA: Expr(expr=GroundLevelPart4AHdr-MHD), Expr(expr=GroundLevelPart4BHdr-MHD), Expr(expr=GroundLevelPart4AHdr-MHD), Expr(expr=GroundLevelPart4CHdr-MHD); 
                                                                                                    ; 
                              ; music headers                                                       ; 
                              ; header format is as follows:                                        ; 
                              ; 1 byte - length byte offset                                         ; 
                              ; 2 bytes -  music data address                                       ; 
                              ; 1 byte - triangle data offset                                       ; 
                              ; 1 byte - square 1 data offset                                       ; 
                              ; 1 byte - noise data offset (not used by secondary music)            ; 
                                                                                                    ; 
TimeRunningOutHdr:  DATA: ByteValue(value=8), Expr(expr=<TimeRunOutMusData), Expr(expr=>TimeRunOutMusData), ByteValue(value=39), ByteValue(value=24);  B
Star_CloudHdr:  DATA: ByteValue(value=32), Expr(expr=<Star_CloudMData), Expr(expr=>Star_CloudMData), ByteValue(value=46), ByteValue(value=26), ByteValue(value=64);  B
EndOfLevelMusHdr:  DATA: ByteValue(value=32), Expr(expr=<WinLevelMusData), Expr(expr=>WinLevelMusData), ByteValue(value=61), ByteValue(value=33);  B
ResidualHeaderData:  DATA: ByteValue(value=32), ByteValue(value=196), ByteValue(value=252), ByteValue(value=63), ByteValue(value=29);  B
UndergroundMusHdr:  DATA: ByteValue(value=24), Expr(expr=<UndergroundMusData), Expr(expr=>UndergroundMusData), ByteValue(value=0), ByteValue(value=0);  B
SilenceHdr:  DATA: ByteValue(value=8), Expr(expr=<SilenceData), Expr(expr=>SilenceData), ByteValue(value=0);  B
CastleMusHdr:  DATA: ByteValue(value=0), Expr(expr=<CastleMusData), Expr(expr=>CastleMusData), ByteValue(value=147), ByteValue(value=98);  B
VictoryMusHdr:  DATA: ByteValue(value=16), Expr(expr=<VictoryMusData), Expr(expr=>VictoryMusData), ByteValue(value=36), ByteValue(value=20);  B
GameOverMusHdr:  DATA: ByteValue(value=24), Expr(expr=<GameOverMusData), Expr(expr=>GameOverMusData), ByteValue(value=30), ByteValue(value=20);  B
WaterMusHdr:  DATA: ByteValue(value=8), Expr(expr=<WaterMusData), Expr(expr=>WaterMusData), ByteValue(value=160), ByteValue(value=112), ByteValue(value=104);  B
WinCastleMusHdr:  DATA: ByteValue(value=8), Expr(expr=<EndOfCastleMusData), Expr(expr=>EndOfCastleMusData), ByteValue(value=76), ByteValue(value=36);  B
GroundLevelPart1Hdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P1Data), Expr(expr=>GroundM_P1Data), ByteValue(value=45), ByteValue(value=28), ByteValue(value=184);  B
GroundLevelPart2AHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P2AData), Expr(expr=>GroundM_P2AData), ByteValue(value=32), ByteValue(value=18), ByteValue(value=112);  B
GroundLevelPart2BHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P2BData), Expr(expr=>GroundM_P2BData), ByteValue(value=27), ByteValue(value=16), ByteValue(value=68);  B
GroundLevelPart2CHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P2CData), Expr(expr=>GroundM_P2CData), ByteValue(value=17), ByteValue(value=10), ByteValue(value=28);  B
GroundLevelPart3AHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P3AData), Expr(expr=>GroundM_P3AData), ByteValue(value=45), ByteValue(value=16), ByteValue(value=88);  B
GroundLevelPart3BHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P3BData), Expr(expr=>GroundM_P3BData), ByteValue(value=20), ByteValue(value=13), ByteValue(value=63);  B
GroundLevelLeadInHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundMLdInData), Expr(expr=>GroundMLdInData), ByteValue(value=21), ByteValue(value=13), ByteValue(value=33);  B
GroundLevelPart4AHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P4AData), Expr(expr=>GroundM_P4AData), ByteValue(value=24), ByteValue(value=16), ByteValue(value=122);  B
GroundLevelPart4BHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P4BData), Expr(expr=>GroundM_P4BData), ByteValue(value=25), ByteValue(value=15), ByteValue(value=84);  B
GroundLevelPart4CHdr:  DATA: ByteValue(value=24), Expr(expr=<GroundM_P4CData), Expr(expr=>GroundM_P4CData), ByteValue(value=30), ByteValue(value=18), ByteValue(value=43);  B
DeathMusHdr:  DATA: ByteValue(value=24), Expr(expr=<DeathMusData), Expr(expr=>DeathMusData), ByteValue(value=30), ByteValue(value=15), ByteValue(value=45);  B
                                                                                                    ; 
                              ; --------------------------------                                    ; 
                                                                                                    ; 
                              ; MUSIC DATA                                                          ; 
                              ; square 2/triangle format                                            ; 
                              ; d7 - length byte flag (0-note, 1-length)                            ; 
                              ; if d7 is set to 0 and d6-d0 is nonzero:                             ; 
                              ; d6-d0 - note offset in frequency look-up table (must be even)       ; 
                              ; if d7 is set to 1:                                                  ; 
                              ; d6-d3 - unused                                                      ; 
                              ; d2-d0 - length offset in length look-up table                       ; 
                              ; value of $00 in square 2 data is used as null terminator, affects all sound channels; 
                              ; value of $00 in triangle data causes routine to skip note           ; 
                                                                                                    ; 
                              ; square 1 format                                                     ; 
                              ; d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6); 
                              ; d5-d1 - note offset in frequency look-up table                      ; 
                              ; value of $00 in square 1 data is flag alternate control reg data to be loaded; 
                                                                                                    ; 
                              ; noise format                                                        ; 
                              ; d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6); 
                              ; d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)       ; 
                              ; d3-d1 - unused                                                      ; 
                              ; value of $00 in noise data is used as null terminator, affects only noise; 
                                                                                                    ; 
                              ; all music data is organized into sections (unless otherwise stated):; 
                              ; square 2, square 1, triangle, noise                                 ; 
                                                                                                    ; 
Star_CloudMData:                                                                                    ;  B
DATA: ByteValue(value=132), ByteValue(value=44), ByteValue(value=44), ByteValue(value=44), ByteValue(value=130), ByteValue(value=4), ByteValue(value=44), ByteValue(value=4), ByteValue(value=133), ByteValue(value=44), ByteValue(value=132), ByteValue(value=44), ByteValue(value=44); 
DATA: ByteValue(value=42), ByteValue(value=42), ByteValue(value=42), ByteValue(value=130), ByteValue(value=4), ByteValue(value=42), ByteValue(value=4), ByteValue(value=133), ByteValue(value=42), ByteValue(value=132), ByteValue(value=42), ByteValue(value=42), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=31), ByteValue(value=31), ByteValue(value=31), ByteValue(value=152), ByteValue(value=31), ByteValue(value=31), ByteValue(value=152), ByteValue(value=158), ByteValue(value=152), ByteValue(value=31); 
DATA: ByteValue(value=29), ByteValue(value=29), ByteValue(value=29), ByteValue(value=148), ByteValue(value=29), ByteValue(value=29), ByteValue(value=148), ByteValue(value=156), ByteValue(value=148), ByteValue(value=29); 
                                                                                                    ; 
DATA: ByteValue(value=134), ByteValue(value=24), ByteValue(value=133), ByteValue(value=38), ByteValue(value=48), ByteValue(value=132), ByteValue(value=4), ByteValue(value=38), ByteValue(value=48); 
DATA: ByteValue(value=134), ByteValue(value=20), ByteValue(value=133), ByteValue(value=34), ByteValue(value=44), ByteValue(value=132), ByteValue(value=4), ByteValue(value=34), ByteValue(value=44); 
                                                                                                    ; 
DATA: ByteValue(value=33), ByteValue(value=208), ByteValue(value=196), ByteValue(value=208), ByteValue(value=49), ByteValue(value=208), ByteValue(value=196), ByteValue(value=208), ByteValue(value=0); 
                                                                                                    ; 
GroundM_P1Data:                                                                                     ;  B
DATA: ByteValue(value=133), ByteValue(value=44), ByteValue(value=34), ByteValue(value=28), ByteValue(value=132), ByteValue(value=38), ByteValue(value=42), ByteValue(value=130), ByteValue(value=40), ByteValue(value=38), ByteValue(value=4); 
DATA: ByteValue(value=135), ByteValue(value=34), ByteValue(value=52), ByteValue(value=58), ByteValue(value=130), ByteValue(value=64), ByteValue(value=4), ByteValue(value=54), ByteValue(value=132), ByteValue(value=58), ByteValue(value=52); 
DATA: ByteValue(value=130), ByteValue(value=44), ByteValue(value=48), ByteValue(value=133), ByteValue(value=42); 
                                                                                                    ; 
SilenceData:                                                                                        ;  B
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
DATA: ByteValue(value=93), ByteValue(value=85), ByteValue(value=77), ByteValue(value=21), ByteValue(value=25), ByteValue(value=150), ByteValue(value=21), ByteValue(value=213), ByteValue(value=227), ByteValue(value=235); 
DATA: ByteValue(value=45), ByteValue(value=166), ByteValue(value=43), ByteValue(value=39), ByteValue(value=156), ByteValue(value=158), ByteValue(value=89); 
                                                                                                    ; 
DATA: ByteValue(value=133), ByteValue(value=34), ByteValue(value=28), ByteValue(value=20), ByteValue(value=132), ByteValue(value=30), ByteValue(value=34), ByteValue(value=130), ByteValue(value=32), ByteValue(value=30), ByteValue(value=4), ByteValue(value=135); 
DATA: ByteValue(value=28), ByteValue(value=44), ByteValue(value=52), ByteValue(value=130), ByteValue(value=54), ByteValue(value=4), ByteValue(value=48), ByteValue(value=52), ByteValue(value=4), ByteValue(value=44), ByteValue(value=4), ByteValue(value=38); 
DATA: ByteValue(value=42), ByteValue(value=133), ByteValue(value=34)                                ; 
                                                                                                    ; 
GroundM_P2AData:                                                                                    ;  B
DATA: ByteValue(value=132), ByteValue(value=4), ByteValue(value=130), ByteValue(value=58), ByteValue(value=56), ByteValue(value=54), ByteValue(value=50), ByteValue(value=4), ByteValue(value=52); 
DATA: ByteValue(value=4), ByteValue(value=36), ByteValue(value=38), ByteValue(value=44), ByteValue(value=4), ByteValue(value=38), ByteValue(value=44), ByteValue(value=48), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=5), ByteValue(value=180), ByteValue(value=178), ByteValue(value=176), ByteValue(value=43), ByteValue(value=172), ByteValue(value=132); 
DATA: ByteValue(value=156), ByteValue(value=158), ByteValue(value=162), ByteValue(value=132), ByteValue(value=148), ByteValue(value=156), ByteValue(value=158); 
                                                                                                    ; 
DATA: ByteValue(value=133), ByteValue(value=20), ByteValue(value=34), ByteValue(value=132), ByteValue(value=44), ByteValue(value=133), ByteValue(value=30); 
DATA: ByteValue(value=130), ByteValue(value=44), ByteValue(value=132), ByteValue(value=44), ByteValue(value=30); 
                                                                                                    ; 
GroundM_P2BData:                                                                                    ;  B
DATA: ByteValue(value=132), ByteValue(value=4), ByteValue(value=130), ByteValue(value=58), ByteValue(value=56), ByteValue(value=54), ByteValue(value=50), ByteValue(value=4), ByteValue(value=52); 
DATA: ByteValue(value=4), ByteValue(value=100), ByteValue(value=4), ByteValue(value=100), ByteValue(value=134), ByteValue(value=100), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=5), ByteValue(value=180), ByteValue(value=178), ByteValue(value=176), ByteValue(value=43), ByteValue(value=172), ByteValue(value=132); 
DATA: ByteValue(value=55), ByteValue(value=182), ByteValue(value=182), ByteValue(value=69)          ; 
                                                                                                    ; 
DATA: ByteValue(value=133), ByteValue(value=20), ByteValue(value=28), ByteValue(value=130), ByteValue(value=34), ByteValue(value=132), ByteValue(value=44); 
DATA: ByteValue(value=78), ByteValue(value=130), ByteValue(value=78), ByteValue(value=132), ByteValue(value=78), ByteValue(value=34); 
                                                                                                    ; 
GroundM_P2CData:                                                                                    ;  B
DATA: ByteValue(value=132), ByteValue(value=4), ByteValue(value=133), ByteValue(value=50), ByteValue(value=133), ByteValue(value=48), ByteValue(value=134), ByteValue(value=44), ByteValue(value=4), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=5), ByteValue(value=164), ByteValue(value=5), ByteValue(value=158), ByteValue(value=5), ByteValue(value=157), ByteValue(value=133); 
                                                                                                    ; 
DATA: ByteValue(value=132), ByteValue(value=20), ByteValue(value=133), ByteValue(value=36), ByteValue(value=40), ByteValue(value=44), ByteValue(value=130); 
DATA: ByteValue(value=34), ByteValue(value=132), ByteValue(value=34), ByteValue(value=20)           ; 
                                                                                                    ; 
DATA: ByteValue(value=33), ByteValue(value=208), ByteValue(value=196), ByteValue(value=208), ByteValue(value=49), ByteValue(value=208), ByteValue(value=196), ByteValue(value=208), ByteValue(value=0); 
                                                                                                    ; 
GroundM_P3AData:                                                                                    ;  B
DATA: ByteValue(value=130), ByteValue(value=44), ByteValue(value=132), ByteValue(value=44), ByteValue(value=44), ByteValue(value=130), ByteValue(value=44), ByteValue(value=48); 
DATA: ByteValue(value=4), ByteValue(value=52), ByteValue(value=44), ByteValue(value=4), ByteValue(value=38), ByteValue(value=134), ByteValue(value=34), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=164), ByteValue(value=37), ByteValue(value=37), ByteValue(value=164), ByteValue(value=41), ByteValue(value=162), ByteValue(value=29), ByteValue(value=156), ByteValue(value=149); 
                                                                                                    ; 
GroundM_P3BData:                                                                                    ;  B
DATA: ByteValue(value=130), ByteValue(value=44), ByteValue(value=44), ByteValue(value=4), ByteValue(value=44), ByteValue(value=4), ByteValue(value=44), ByteValue(value=48), ByteValue(value=133), ByteValue(value=52), ByteValue(value=4), ByteValue(value=4), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=164), ByteValue(value=37), ByteValue(value=37), ByteValue(value=164), ByteValue(value=168), ByteValue(value=99), ByteValue(value=4); 
                                                                                                    ; 
                              ; triangle data used by both sections of third part                   ; 
DATA: ByteValue(value=133), ByteValue(value=14), ByteValue(value=26), ByteValue(value=132), ByteValue(value=36), ByteValue(value=133), ByteValue(value=34), ByteValue(value=20), ByteValue(value=132), ByteValue(value=12); 
                                                                                                    ; 
GroundMLdInData:                                                                                    ;  B
DATA: ByteValue(value=130), ByteValue(value=52), ByteValue(value=132), ByteValue(value=52), ByteValue(value=52), ByteValue(value=130), ByteValue(value=44), ByteValue(value=132), ByteValue(value=52), ByteValue(value=134), ByteValue(value=58), ByteValue(value=4), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=160), ByteValue(value=33), ByteValue(value=33), ByteValue(value=160), ByteValue(value=33), ByteValue(value=43), ByteValue(value=5), ByteValue(value=163); 
                                                                                                    ; 
DATA: ByteValue(value=130), ByteValue(value=24), ByteValue(value=132), ByteValue(value=24), ByteValue(value=24), ByteValue(value=130), ByteValue(value=24), ByteValue(value=24), ByteValue(value=4), ByteValue(value=134), ByteValue(value=58), ByteValue(value=34); 
                                                                                                    ; 
                              ; noise data used by lead-in and third part sections                  ; 
DATA: ByteValue(value=49), ByteValue(value=144), ByteValue(value=49), ByteValue(value=144), ByteValue(value=49), ByteValue(value=113), ByteValue(value=49), ByteValue(value=144), ByteValue(value=144), ByteValue(value=144), ByteValue(value=0); 
                                                                                                    ; 
GroundM_P4AData:                                                                                    ;  B
DATA: ByteValue(value=130), ByteValue(value=52), ByteValue(value=132), ByteValue(value=44), ByteValue(value=133), ByteValue(value=34), ByteValue(value=132), ByteValue(value=36); 
DATA: ByteValue(value=130), ByteValue(value=38), ByteValue(value=54), ByteValue(value=4), ByteValue(value=54), ByteValue(value=134), ByteValue(value=38), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=172), ByteValue(value=39), ByteValue(value=93), ByteValue(value=29), ByteValue(value=158), ByteValue(value=45), ByteValue(value=172), ByteValue(value=159); 
                                                                                                    ; 
DATA: ByteValue(value=133), ByteValue(value=20), ByteValue(value=130), ByteValue(value=32), ByteValue(value=132), ByteValue(value=34), ByteValue(value=44); 
DATA: ByteValue(value=30), ByteValue(value=30), ByteValue(value=130), ByteValue(value=44), ByteValue(value=44), ByteValue(value=30), ByteValue(value=4); 
                                                                                                    ; 
GroundM_P4BData:                                                                                    ;  B
DATA: ByteValue(value=135), ByteValue(value=42), ByteValue(value=64), ByteValue(value=64), ByteValue(value=64), ByteValue(value=58), ByteValue(value=54); 
DATA: ByteValue(value=130), ByteValue(value=52), ByteValue(value=44), ByteValue(value=4), ByteValue(value=38), ByteValue(value=134), ByteValue(value=34), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=227), ByteValue(value=247), ByteValue(value=247), ByteValue(value=247), ByteValue(value=245), ByteValue(value=241), ByteValue(value=172), ByteValue(value=39), ByteValue(value=158), ByteValue(value=157); 
                                                                                                    ; 
DATA: ByteValue(value=133), ByteValue(value=24), ByteValue(value=130), ByteValue(value=30), ByteValue(value=132), ByteValue(value=34), ByteValue(value=42); 
DATA: ByteValue(value=34), ByteValue(value=34), ByteValue(value=130), ByteValue(value=44), ByteValue(value=44), ByteValue(value=34), ByteValue(value=4); 
                                                                                                    ; 
DeathMusData:                                                                                       ;  B
DATA: ByteValue(value=134), ByteValue(value=4); death music share data with fourth part c of ground level music; 
                                                                                                    ; 
GroundM_P4CData:                                                                                    ;  B
DATA: ByteValue(value=130), ByteValue(value=42), ByteValue(value=54), ByteValue(value=4), ByteValue(value=54), ByteValue(value=135), ByteValue(value=54), ByteValue(value=52), ByteValue(value=48), ByteValue(value=134), ByteValue(value=44), ByteValue(value=4), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=0), ByteValue(value=104), ByteValue(value=106), ByteValue(value=108), ByteValue(value=69); death music only; 
                                                                                                    ; 
DATA: ByteValue(value=162), ByteValue(value=49), ByteValue(value=176), ByteValue(value=241), ByteValue(value=237), ByteValue(value=235), ByteValue(value=162), ByteValue(value=29), ByteValue(value=156), ByteValue(value=149); 
                                                                                                    ; 
DATA: ByteValue(value=134), ByteValue(value=4); death music only                                    ; 
                                                                                                    ; 
DATA: ByteValue(value=133), ByteValue(value=34), ByteValue(value=130), ByteValue(value=34), ByteValue(value=135), ByteValue(value=34), ByteValue(value=38), ByteValue(value=42), ByteValue(value=132), ByteValue(value=44), ByteValue(value=34), ByteValue(value=134), ByteValue(value=20); 
                                                                                                    ; 
                              ; noise data used by fourth part sections                             ; 
DATA: ByteValue(value=81), ByteValue(value=144), ByteValue(value=49), ByteValue(value=17), ByteValue(value=0); 
                                                                                                    ; 
CastleMusData:                                                                                      ;  B
DATA: ByteValue(value=128), ByteValue(value=34), ByteValue(value=40), ByteValue(value=34), ByteValue(value=38), ByteValue(value=34), ByteValue(value=36), ByteValue(value=34), ByteValue(value=38); 
DATA: ByteValue(value=34), ByteValue(value=40), ByteValue(value=34), ByteValue(value=42), ByteValue(value=34), ByteValue(value=40), ByteValue(value=34), ByteValue(value=38); 
DATA: ByteValue(value=34), ByteValue(value=40), ByteValue(value=34), ByteValue(value=38), ByteValue(value=34), ByteValue(value=36), ByteValue(value=34), ByteValue(value=38); 
DATA: ByteValue(value=34), ByteValue(value=40), ByteValue(value=34), ByteValue(value=42), ByteValue(value=34), ByteValue(value=40), ByteValue(value=34), ByteValue(value=38); 
DATA: ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=36), ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=40); 
DATA: ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=40), ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=36); 
DATA: ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=36), ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=40); 
DATA: ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=40), ByteValue(value=32), ByteValue(value=38), ByteValue(value=32), ByteValue(value=36); 
DATA: ByteValue(value=40), ByteValue(value=48), ByteValue(value=40), ByteValue(value=50), ByteValue(value=40), ByteValue(value=48), ByteValue(value=40), ByteValue(value=46); 
DATA: ByteValue(value=40), ByteValue(value=48), ByteValue(value=40), ByteValue(value=46), ByteValue(value=40), ByteValue(value=44), ByteValue(value=40), ByteValue(value=46); 
DATA: ByteValue(value=40), ByteValue(value=48), ByteValue(value=40), ByteValue(value=50), ByteValue(value=40), ByteValue(value=48), ByteValue(value=40), ByteValue(value=46); 
DATA: ByteValue(value=40), ByteValue(value=48), ByteValue(value=40), ByteValue(value=46), ByteValue(value=40), ByteValue(value=44), ByteValue(value=40), ByteValue(value=46), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=4), ByteValue(value=112), ByteValue(value=110), ByteValue(value=108), ByteValue(value=110), ByteValue(value=112), ByteValue(value=114), ByteValue(value=112), ByteValue(value=110); 
DATA: ByteValue(value=112), ByteValue(value=110), ByteValue(value=108), ByteValue(value=110), ByteValue(value=112), ByteValue(value=114), ByteValue(value=112), ByteValue(value=110); 
DATA: ByteValue(value=110), ByteValue(value=108), ByteValue(value=110), ByteValue(value=112), ByteValue(value=110), ByteValue(value=112), ByteValue(value=110), ByteValue(value=108); 
DATA: ByteValue(value=110), ByteValue(value=108), ByteValue(value=110), ByteValue(value=112), ByteValue(value=110), ByteValue(value=112), ByteValue(value=110), ByteValue(value=108); 
DATA: ByteValue(value=118), ByteValue(value=120), ByteValue(value=118), ByteValue(value=116), ByteValue(value=118), ByteValue(value=116), ByteValue(value=114), ByteValue(value=116); 
DATA: ByteValue(value=118), ByteValue(value=120), ByteValue(value=118), ByteValue(value=116), ByteValue(value=118), ByteValue(value=116), ByteValue(value=114), ByteValue(value=116); 
                                                                                                    ; 
DATA: ByteValue(value=132), ByteValue(value=26), ByteValue(value=131), ByteValue(value=24), ByteValue(value=32), ByteValue(value=132), ByteValue(value=30), ByteValue(value=131), ByteValue(value=28), ByteValue(value=40); 
DATA: ByteValue(value=38), ByteValue(value=28), ByteValue(value=26), ByteValue(value=28)            ; 
                                                                                                    ; 
GameOverMusData:                                                                                    ;  B
DATA: ByteValue(value=130), ByteValue(value=44), ByteValue(value=4), ByteValue(value=4), ByteValue(value=34), ByteValue(value=4), ByteValue(value=4), ByteValue(value=132), ByteValue(value=28), ByteValue(value=135); 
DATA: ByteValue(value=38), ByteValue(value=42), ByteValue(value=38), ByteValue(value=132), ByteValue(value=36), ByteValue(value=40), ByteValue(value=36), ByteValue(value=128), ByteValue(value=34), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=156), ByteValue(value=5), ByteValue(value=148), ByteValue(value=5), ByteValue(value=13), ByteValue(value=159), ByteValue(value=30), ByteValue(value=156), ByteValue(value=152), ByteValue(value=157); 
                                                                                                    ; 
DATA: ByteValue(value=130), ByteValue(value=34), ByteValue(value=4), ByteValue(value=4), ByteValue(value=28), ByteValue(value=4), ByteValue(value=4), ByteValue(value=132), ByteValue(value=20); 
DATA: ByteValue(value=134), ByteValue(value=30), ByteValue(value=128), ByteValue(value=22), ByteValue(value=128), ByteValue(value=20); 
                                                                                                    ; 
TimeRunOutMusData:                                                                                  ;  B
DATA: ByteValue(value=129), ByteValue(value=28), ByteValue(value=48), ByteValue(value=4), ByteValue(value=48), ByteValue(value=48), ByteValue(value=4), ByteValue(value=30), ByteValue(value=50), ByteValue(value=4), ByteValue(value=50), ByteValue(value=50); 
DATA: ByteValue(value=4), ByteValue(value=32), ByteValue(value=52), ByteValue(value=4), ByteValue(value=52), ByteValue(value=52), ByteValue(value=4), ByteValue(value=54), ByteValue(value=4), ByteValue(value=132), ByteValue(value=54), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=70), ByteValue(value=164), ByteValue(value=100), ByteValue(value=164), ByteValue(value=72), ByteValue(value=166), ByteValue(value=102), ByteValue(value=166), ByteValue(value=74), ByteValue(value=168), ByteValue(value=104), ByteValue(value=168); 
DATA: ByteValue(value=106), ByteValue(value=68), ByteValue(value=43)                                ; 
                                                                                                    ; 
DATA: ByteValue(value=129), ByteValue(value=42), ByteValue(value=66), ByteValue(value=4), ByteValue(value=66), ByteValue(value=66), ByteValue(value=4), ByteValue(value=44), ByteValue(value=100), ByteValue(value=4), ByteValue(value=100), ByteValue(value=100); 
DATA: ByteValue(value=4), ByteValue(value=46), ByteValue(value=70), ByteValue(value=4), ByteValue(value=70), ByteValue(value=70), ByteValue(value=4), ByteValue(value=34), ByteValue(value=4), ByteValue(value=132), ByteValue(value=34); 
                                                                                                    ; 
WinLevelMusData:                                                                                    ;  B
DATA: ByteValue(value=135), ByteValue(value=4), ByteValue(value=6), ByteValue(value=12), ByteValue(value=20), ByteValue(value=28), ByteValue(value=34), ByteValue(value=134), ByteValue(value=44), ByteValue(value=34); 
DATA: ByteValue(value=135), ByteValue(value=4), ByteValue(value=96), ByteValue(value=14), ByteValue(value=20), ByteValue(value=26), ByteValue(value=36), ByteValue(value=134), ByteValue(value=44), ByteValue(value=36); 
DATA: ByteValue(value=135), ByteValue(value=4), ByteValue(value=8), ByteValue(value=16), ByteValue(value=24), ByteValue(value=30), ByteValue(value=40), ByteValue(value=134), ByteValue(value=48), ByteValue(value=48); 
DATA: ByteValue(value=128), ByteValue(value=100), ByteValue(value=0)                                ; 
                                                                                                    ; 
DATA: ByteValue(value=205), ByteValue(value=213), ByteValue(value=221), ByteValue(value=227), ByteValue(value=237), ByteValue(value=245), ByteValue(value=187), ByteValue(value=181), ByteValue(value=207), ByteValue(value=213); 
DATA: ByteValue(value=219), ByteValue(value=229), ByteValue(value=237), ByteValue(value=243), ByteValue(value=189), ByteValue(value=179), ByteValue(value=209), ByteValue(value=217), ByteValue(value=223), ByteValue(value=233); 
DATA: ByteValue(value=241), ByteValue(value=247), ByteValue(value=191), ByteValue(value=255), ByteValue(value=255), ByteValue(value=255), ByteValue(value=52); 
DATA: ByteValue(value=0)      ; unused byte                                                         ; 
                                                                                                    ; 
DATA: ByteValue(value=134), ByteValue(value=4), ByteValue(value=135), ByteValue(value=20), ByteValue(value=28), ByteValue(value=34), ByteValue(value=134), ByteValue(value=52), ByteValue(value=132), ByteValue(value=44); 
DATA: ByteValue(value=4), ByteValue(value=4), ByteValue(value=4), ByteValue(value=135), ByteValue(value=20), ByteValue(value=26), ByteValue(value=36), ByteValue(value=134), ByteValue(value=50), ByteValue(value=132); 
DATA: ByteValue(value=44), ByteValue(value=4), ByteValue(value=134), ByteValue(value=4), ByteValue(value=135), ByteValue(value=24), ByteValue(value=30), ByteValue(value=40), ByteValue(value=134), ByteValue(value=54); 
DATA: ByteValue(value=135), ByteValue(value=48), ByteValue(value=48), ByteValue(value=48), ByteValue(value=128), ByteValue(value=44); 
                                                                                                    ; 
                              ; square 2 and triangle use the same data, square 1 is unused         ; 
UndergroundMusData:                                                                                 ;  B
DATA: ByteValue(value=130), ByteValue(value=20), ByteValue(value=44), ByteValue(value=98), ByteValue(value=38), ByteValue(value=16), ByteValue(value=40), ByteValue(value=128), ByteValue(value=4); 
DATA: ByteValue(value=130), ByteValue(value=20), ByteValue(value=44), ByteValue(value=98), ByteValue(value=38), ByteValue(value=16), ByteValue(value=40), ByteValue(value=128), ByteValue(value=4); 
DATA: ByteValue(value=130), ByteValue(value=8), ByteValue(value=30), ByteValue(value=94), ByteValue(value=24), ByteValue(value=96), ByteValue(value=26), ByteValue(value=128), ByteValue(value=4); 
DATA: ByteValue(value=130), ByteValue(value=8), ByteValue(value=30), ByteValue(value=94), ByteValue(value=24), ByteValue(value=96), ByteValue(value=26), ByteValue(value=134), ByteValue(value=4); 
DATA: ByteValue(value=131), ByteValue(value=26), ByteValue(value=24), ByteValue(value=22), ByteValue(value=132), ByteValue(value=20), ByteValue(value=26), ByteValue(value=24), ByteValue(value=14), ByteValue(value=12); 
DATA: ByteValue(value=22), ByteValue(value=131), ByteValue(value=20), ByteValue(value=32), ByteValue(value=30), ByteValue(value=28), ByteValue(value=40), ByteValue(value=38), ByteValue(value=135); 
DATA: ByteValue(value=36), ByteValue(value=26), ByteValue(value=18), ByteValue(value=16), ByteValue(value=98), ByteValue(value=14), ByteValue(value=128), ByteValue(value=4), ByteValue(value=4); 
DATA: ByteValue(value=0)                                                                            ; 
                                                                                                    ; 
                              ; noise data directly follows square 2 here unlike in other songs     ; 
WaterMusData:                                                                                       ;  B
DATA: ByteValue(value=130), ByteValue(value=24), ByteValue(value=28), ByteValue(value=32), ByteValue(value=34), ByteValue(value=38), ByteValue(value=40); 
DATA: ByteValue(value=129), ByteValue(value=42), ByteValue(value=42), ByteValue(value=42), ByteValue(value=4), ByteValue(value=42), ByteValue(value=4), ByteValue(value=131), ByteValue(value=42), ByteValue(value=130), ByteValue(value=34); 
DATA: ByteValue(value=134), ByteValue(value=52), ByteValue(value=50), ByteValue(value=52), ByteValue(value=129), ByteValue(value=4), ByteValue(value=34), ByteValue(value=38), ByteValue(value=42), ByteValue(value=44), ByteValue(value=48); 
DATA: ByteValue(value=134), ByteValue(value=52), ByteValue(value=131), ByteValue(value=50), ByteValue(value=130), ByteValue(value=54), ByteValue(value=132), ByteValue(value=52), ByteValue(value=133), ByteValue(value=4), ByteValue(value=129), ByteValue(value=34); 
DATA: ByteValue(value=134), ByteValue(value=48), ByteValue(value=46), ByteValue(value=48), ByteValue(value=129), ByteValue(value=4), ByteValue(value=34), ByteValue(value=38), ByteValue(value=42), ByteValue(value=44), ByteValue(value=46); 
DATA: ByteValue(value=134), ByteValue(value=48), ByteValue(value=131), ByteValue(value=34), ByteValue(value=130), ByteValue(value=54), ByteValue(value=132), ByteValue(value=52), ByteValue(value=133), ByteValue(value=4), ByteValue(value=129), ByteValue(value=34); 
DATA: ByteValue(value=134), ByteValue(value=58), ByteValue(value=58), ByteValue(value=58), ByteValue(value=130), ByteValue(value=58), ByteValue(value=129), ByteValue(value=64), ByteValue(value=130), ByteValue(value=4), ByteValue(value=129), ByteValue(value=58); 
DATA: ByteValue(value=134), ByteValue(value=54), ByteValue(value=54), ByteValue(value=54), ByteValue(value=130), ByteValue(value=54), ByteValue(value=129), ByteValue(value=58), ByteValue(value=130), ByteValue(value=4), ByteValue(value=129), ByteValue(value=54); 
DATA: ByteValue(value=134), ByteValue(value=52), ByteValue(value=130), ByteValue(value=38), ByteValue(value=42), ByteValue(value=54); 
DATA: ByteValue(value=129), ByteValue(value=52), ByteValue(value=52), ByteValue(value=133), ByteValue(value=52), ByteValue(value=129), ByteValue(value=42), ByteValue(value=134), ByteValue(value=44), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=132), ByteValue(value=144), ByteValue(value=176), ByteValue(value=132), ByteValue(value=80), ByteValue(value=80), ByteValue(value=176), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=152), ByteValue(value=150), ByteValue(value=148), ByteValue(value=146), ByteValue(value=148), ByteValue(value=150), ByteValue(value=88), ByteValue(value=88), ByteValue(value=88), ByteValue(value=68); 
DATA: ByteValue(value=92), ByteValue(value=68), ByteValue(value=159), ByteValue(value=163), ByteValue(value=161), ByteValue(value=163), ByteValue(value=133), ByteValue(value=163), ByteValue(value=224), ByteValue(value=166); 
DATA: ByteValue(value=35), ByteValue(value=196), ByteValue(value=159), ByteValue(value=157), ByteValue(value=159), ByteValue(value=133), ByteValue(value=159), ByteValue(value=210), ByteValue(value=166), ByteValue(value=35); 
DATA: ByteValue(value=196), ByteValue(value=181), ByteValue(value=177), ByteValue(value=175), ByteValue(value=133), ByteValue(value=177), ByteValue(value=175), ByteValue(value=173), ByteValue(value=133), ByteValue(value=149); 
DATA: ByteValue(value=158), ByteValue(value=162), ByteValue(value=170), ByteValue(value=106), ByteValue(value=106), ByteValue(value=107), ByteValue(value=94), ByteValue(value=157); 
                                                                                                    ; 
DATA: ByteValue(value=132), ByteValue(value=4), ByteValue(value=4), ByteValue(value=130), ByteValue(value=34), ByteValue(value=134), ByteValue(value=34); 
DATA: ByteValue(value=130), ByteValue(value=20), ByteValue(value=34), ByteValue(value=44), ByteValue(value=18), ByteValue(value=34), ByteValue(value=42), ByteValue(value=20), ByteValue(value=34), ByteValue(value=44); 
DATA: ByteValue(value=28), ByteValue(value=34), ByteValue(value=44), ByteValue(value=20), ByteValue(value=34), ByteValue(value=44), ByteValue(value=18), ByteValue(value=34), ByteValue(value=42), ByteValue(value=20); 
DATA: ByteValue(value=34), ByteValue(value=44), ByteValue(value=28), ByteValue(value=34), ByteValue(value=44), ByteValue(value=24), ByteValue(value=34), ByteValue(value=42), ByteValue(value=22), ByteValue(value=32); 
DATA: ByteValue(value=40), ByteValue(value=24), ByteValue(value=34), ByteValue(value=42), ByteValue(value=18), ByteValue(value=34), ByteValue(value=42), ByteValue(value=24), ByteValue(value=34), ByteValue(value=42); 
DATA: ByteValue(value=18), ByteValue(value=34), ByteValue(value=42), ByteValue(value=20), ByteValue(value=34), ByteValue(value=44), ByteValue(value=12), ByteValue(value=34), ByteValue(value=44), ByteValue(value=20), ByteValue(value=34), ByteValue(value=52), ByteValue(value=18); 
DATA: ByteValue(value=34), ByteValue(value=48), ByteValue(value=16), ByteValue(value=34), ByteValue(value=46), ByteValue(value=22), ByteValue(value=34), ByteValue(value=52), ByteValue(value=24), ByteValue(value=38); 
DATA: ByteValue(value=54), ByteValue(value=22), ByteValue(value=38), ByteValue(value=54), ByteValue(value=20), ByteValue(value=38), ByteValue(value=54), ByteValue(value=18), ByteValue(value=34), ByteValue(value=54); 
DATA: ByteValue(value=92), ByteValue(value=34), ByteValue(value=52), ByteValue(value=12), ByteValue(value=34), ByteValue(value=34), ByteValue(value=129), ByteValue(value=30), ByteValue(value=30), ByteValue(value=133), ByteValue(value=30); 
DATA: ByteValue(value=129), ByteValue(value=18), ByteValue(value=134), ByteValue(value=20)          ; 
                                                                                                    ; 
EndOfCastleMusData:                                                                                 ;  B
DATA: ByteValue(value=129), ByteValue(value=44), ByteValue(value=34), ByteValue(value=28), ByteValue(value=44), ByteValue(value=34), ByteValue(value=28), ByteValue(value=133), ByteValue(value=44), ByteValue(value=4); 
DATA: ByteValue(value=129), ByteValue(value=46), ByteValue(value=36), ByteValue(value=30), ByteValue(value=46), ByteValue(value=36), ByteValue(value=30), ByteValue(value=133), ByteValue(value=46), ByteValue(value=4); 
DATA: ByteValue(value=129), ByteValue(value=50), ByteValue(value=40), ByteValue(value=34), ByteValue(value=50), ByteValue(value=40), ByteValue(value=34), ByteValue(value=133), ByteValue(value=50); 
DATA: ByteValue(value=135), ByteValue(value=54), ByteValue(value=54), ByteValue(value=54), ByteValue(value=132), ByteValue(value=58), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=92), ByteValue(value=84), ByteValue(value=76), ByteValue(value=92), ByteValue(value=84), ByteValue(value=76); 
DATA: ByteValue(value=92), ByteValue(value=28), ByteValue(value=28), ByteValue(value=92), ByteValue(value=92), ByteValue(value=92), ByteValue(value=92); 
DATA: ByteValue(value=94), ByteValue(value=86), ByteValue(value=78), ByteValue(value=94), ByteValue(value=86), ByteValue(value=78); 
DATA: ByteValue(value=94), ByteValue(value=30), ByteValue(value=30), ByteValue(value=94), ByteValue(value=94), ByteValue(value=94), ByteValue(value=94); 
DATA: ByteValue(value=98), ByteValue(value=90), ByteValue(value=80), ByteValue(value=98), ByteValue(value=90), ByteValue(value=80); 
DATA: ByteValue(value=98), ByteValue(value=34), ByteValue(value=34), ByteValue(value=98), ByteValue(value=231), ByteValue(value=231), ByteValue(value=231), ByteValue(value=43); 
                                                                                                    ; 
DATA: ByteValue(value=134), ByteValue(value=20), ByteValue(value=129), ByteValue(value=20), ByteValue(value=128), ByteValue(value=20), ByteValue(value=20), ByteValue(value=129), ByteValue(value=20), ByteValue(value=20), ByteValue(value=20), ByteValue(value=20); 
DATA: ByteValue(value=134), ByteValue(value=22), ByteValue(value=129), ByteValue(value=22), ByteValue(value=128), ByteValue(value=22), ByteValue(value=22), ByteValue(value=129), ByteValue(value=22), ByteValue(value=22), ByteValue(value=22), ByteValue(value=22); 
DATA: ByteValue(value=129), ByteValue(value=40), ByteValue(value=34), ByteValue(value=26), ByteValue(value=40), ByteValue(value=34), ByteValue(value=26), ByteValue(value=40), ByteValue(value=128), ByteValue(value=40), ByteValue(value=40); 
DATA: ByteValue(value=129), ByteValue(value=40), ByteValue(value=135), ByteValue(value=44), ByteValue(value=44), ByteValue(value=44), ByteValue(value=132), ByteValue(value=48); 
                                                                                                    ; 
VictoryMusData:                                                                                     ;  B
DATA: ByteValue(value=131), ByteValue(value=4), ByteValue(value=132), ByteValue(value=12), ByteValue(value=131), ByteValue(value=98), ByteValue(value=16), ByteValue(value=132), ByteValue(value=18); 
DATA: ByteValue(value=131), ByteValue(value=28), ByteValue(value=34), ByteValue(value=30), ByteValue(value=34), ByteValue(value=38), ByteValue(value=24), ByteValue(value=30), ByteValue(value=4), ByteValue(value=28), ByteValue(value=0); 
                                                                                                    ; 
DATA: ByteValue(value=227), ByteValue(value=225), ByteValue(value=227), ByteValue(value=29), ByteValue(value=222), ByteValue(value=224), ByteValue(value=35); 
DATA: ByteValue(value=236), ByteValue(value=117), ByteValue(value=116), ByteValue(value=240), ByteValue(value=244), ByteValue(value=246), ByteValue(value=234), ByteValue(value=49), ByteValue(value=45); 
                                                                                                    ; 
DATA: ByteValue(value=131), ByteValue(value=18), ByteValue(value=20), ByteValue(value=4), ByteValue(value=24), ByteValue(value=26), ByteValue(value=28), ByteValue(value=20); 
DATA: ByteValue(value=38), ByteValue(value=34), ByteValue(value=30), ByteValue(value=28), ByteValue(value=24), ByteValue(value=30), ByteValue(value=34), ByteValue(value=12), ByteValue(value=20); 
                                                                                                    ; 
                              ; unused space                                                        ; 
DATA: ByteValue(value=255), ByteValue(value=255), ByteValue(value=255)                              ; 
                                                                                                    ; 
FreqRegLookupTbl:                                                                                   ;  B
DATA: ByteValue(value=0), ByteValue(value=136), ByteValue(value=0), ByteValue(value=47), ByteValue(value=0), ByteValue(value=0); 
DATA: ByteValue(value=2), ByteValue(value=166), ByteValue(value=2), ByteValue(value=128), ByteValue(value=2), ByteValue(value=92), ByteValue(value=2), ByteValue(value=58); 
DATA: ByteValue(value=2), ByteValue(value=26), ByteValue(value=1), ByteValue(value=223), ByteValue(value=1), ByteValue(value=196), ByteValue(value=1), ByteValue(value=171); 
DATA: ByteValue(value=1), ByteValue(value=147), ByteValue(value=1), ByteValue(value=124), ByteValue(value=1), ByteValue(value=103), ByteValue(value=1), ByteValue(value=83); 
DATA: ByteValue(value=1), ByteValue(value=64), ByteValue(value=1), ByteValue(value=46), ByteValue(value=1), ByteValue(value=29), ByteValue(value=1), ByteValue(value=13); 
DATA: ByteValue(value=0), ByteValue(value=254), ByteValue(value=0), ByteValue(value=239), ByteValue(value=0), ByteValue(value=226), ByteValue(value=0), ByteValue(value=213); 
DATA: ByteValue(value=0), ByteValue(value=201), ByteValue(value=0), ByteValue(value=190), ByteValue(value=0), ByteValue(value=179), ByteValue(value=0), ByteValue(value=169); 
DATA: ByteValue(value=0), ByteValue(value=160), ByteValue(value=0), ByteValue(value=151), ByteValue(value=0), ByteValue(value=142), ByteValue(value=0), ByteValue(value=134); 
DATA: ByteValue(value=0), ByteValue(value=119), ByteValue(value=0), ByteValue(value=126), ByteValue(value=0), ByteValue(value=113), ByteValue(value=0), ByteValue(value=84); 
DATA: ByteValue(value=0), ByteValue(value=100), ByteValue(value=0), ByteValue(value=95), ByteValue(value=0), ByteValue(value=89), ByteValue(value=0), ByteValue(value=80); 
DATA: ByteValue(value=0), ByteValue(value=71), ByteValue(value=0), ByteValue(value=67), ByteValue(value=0), ByteValue(value=59), ByteValue(value=0), ByteValue(value=53); 
DATA: ByteValue(value=0), ByteValue(value=42), ByteValue(value=0), ByteValue(value=35), ByteValue(value=4), ByteValue(value=117), ByteValue(value=3), ByteValue(value=87); 
DATA: ByteValue(value=2), ByteValue(value=249), ByteValue(value=2), ByteValue(value=207), ByteValue(value=1), ByteValue(value=252), ByteValue(value=0), ByteValue(value=106); 
                                                                                                    ; 
MusicLengthLookupTbl:                                                                               ;  B
DATA: ByteValue(value=5), ByteValue(value=10), ByteValue(value=20), ByteValue(value=40), ByteValue(value=80), ByteValue(value=30), ByteValue(value=60), ByteValue(value=2); 
DATA: ByteValue(value=4), ByteValue(value=8), ByteValue(value=16), ByteValue(value=32), ByteValue(value=64), ByteValue(value=24), ByteValue(value=48), ByteValue(value=12); 
DATA: ByteValue(value=3), ByteValue(value=6), ByteValue(value=12), ByteValue(value=24), ByteValue(value=48), ByteValue(value=18), ByteValue(value=36), ByteValue(value=8); 
DATA: ByteValue(value=54), ByteValue(value=3), ByteValue(value=9), ByteValue(value=6), ByteValue(value=18), ByteValue(value=27), ByteValue(value=36), ByteValue(value=12); 
DATA: ByteValue(value=36), ByteValue(value=2), ByteValue(value=6), ByteValue(value=4), ByteValue(value=12), ByteValue(value=18), ByteValue(value=24), ByteValue(value=8); 
DATA: ByteValue(value=18), ByteValue(value=1), ByteValue(value=3), ByteValue(value=2), ByteValue(value=6), ByteValue(value=9), ByteValue(value=12), ByteValue(value=4); 
                                                                                                    ; 
EndOfCastleMusicEnvData:                                                                            ;  B
DATA: ByteValue(value=152), ByteValue(value=153), ByteValue(value=154), ByteValue(value=155)        ; 
                                                                                                    ; 
AreaMusicEnvData:                                                                                   ;  B
DATA: ByteValue(value=144), ByteValue(value=148), ByteValue(value=148), ByteValue(value=149), ByteValue(value=149), ByteValue(value=150), ByteValue(value=151), ByteValue(value=152); 
                                                                                                    ; 
WaterEventMusEnvData:                                                                               ;  B
DATA: ByteValue(value=144), ByteValue(value=145), ByteValue(value=146), ByteValue(value=146), ByteValue(value=147), ByteValue(value=147), ByteValue(value=147), ByteValue(value=148); 
DATA: ByteValue(value=148), ByteValue(value=148), ByteValue(value=148), ByteValue(value=148), ByteValue(value=148), ByteValue(value=149), ByteValue(value=149), ByteValue(value=149); 
DATA: ByteValue(value=149), ByteValue(value=149), ByteValue(value=149), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150); 
DATA: ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150); 
DATA: ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=150), ByteValue(value=149), ByteValue(value=149), ByteValue(value=148), ByteValue(value=147); 
                                                                                                    ; 
BowserFlameEnvData:                                                                                 ;  B
DATA: ByteValue(value=21), ByteValue(value=22), ByteValue(value=22), ByteValue(value=23), ByteValue(value=23), ByteValue(value=24), ByteValue(value=25), ByteValue(value=25); 
DATA: ByteValue(value=26), ByteValue(value=26), ByteValue(value=28), ByteValue(value=29), ByteValue(value=29), ByteValue(value=30), ByteValue(value=30), ByteValue(value=31); 
DATA: ByteValue(value=31), ByteValue(value=31), ByteValue(value=31), ByteValue(value=30), ByteValue(value=29), ByteValue(value=28), ByteValue(value=30), ByteValue(value=31); 
DATA: ByteValue(value=31), ByteValue(value=30), ByteValue(value=29), ByteValue(value=28), ByteValue(value=26), ByteValue(value=24), ByteValue(value=22), ByteValue(value=20); 
                                                                                                    ; 
BrickShatterEnvData:                                                                                ;  B
DATA: ByteValue(value=21), ByteValue(value=22), ByteValue(value=22), ByteValue(value=23), ByteValue(value=23), ByteValue(value=24), ByteValue(value=25), ByteValue(value=25); 
DATA: ByteValue(value=26), ByteValue(value=26), ByteValue(value=28), ByteValue(value=29), ByteValue(value=29), ByteValue(value=30), ByteValue(value=30), ByteValue(value=31); 
                                                                                                    ; 
                              ; -------------------------------------------------------------------------------------; 
                              ; INTERRUPT VECTORS                                                   ; 
                                                                                                    ; 
DATA: Expr(expr=NonMaskableInterrupt)                                                               ; 
DATA: Expr(expr=Start)                                                                              ; 
DATA: ByteValue(value=240), ByteValue(value=255); unused                                            ; 

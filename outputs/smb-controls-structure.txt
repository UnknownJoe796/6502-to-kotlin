def EnemyMovementSubs():
  // Block: EnemyMovementSubs
  lda Enemy_ID,x
  jsr JumpEngine
  // Block: NoMoveCode
  rts

def BlockObjMT_Updater():
  // Block: BlockObjMT_Updater
  ldx #$01                  ;set offset to start with second block object
  NextBUpd:   dex                       ;decrement block object offset
  while (!BPL UpdateLoop) {  // loop8
    lda Block_RepFlag,x       ;if flag for block object already clear,
    if (!BEQ NextBUpd) {  // from @7506
      lda Block_BBuf_Low,x      ;get low byte of block buffer
      sta $06                   ;store into block buffer address
      lda #$05
      sta $07                   ;set high byte of block buffer address
      lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
      sta $02                   ;store here and use as offset to block buffer
      tay
      lda Block_Metatile,x      ;get metatile to be written
      sta ($06),y               ;write it to the block buffer
      jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
      lda #$00
      sta Block_RepFlag,x       ;clear block object flag
    }
    do {  // loop7
      // Block: UpdateLoop
      UpdateLoop: stx ObjectOffset          ;set offset here
      lda VRAM_Buffer1          ;if vram buffer already being used here,
      bne NextBUpd              ;branch to move onto next block object
    } while (BPL UpdateLoop)
  }
  rts                       ;then leave

def MovePlatformUp():
  lda #$01        ;save value to stack
  pha
  ldy Enemy_ID,x  ;get enemy object identifier
  inx             ;increment offset for enemy object
  lda #$05        ;load default value here
  cpy #$29        ;residual comparison, object #29 never executes
  if (!BNE SetDplSpd) {  // from MovePlatformUp
    lda #$09        ;residual code
  }
  // Block: SetDplSpd
  SetDplSpd: sta $00         ;save downward movement amount here
  lda #$0a        ;save upward movement amount here
  sta $01
  lda #$03        ;save maximum vertical speed here
  sta $02
  pla             ;get value from stack
  tay             ;use as Y, then move onto code shared by red koopa
  // Block: RedPTroopaGrav
  jsr ImposeGravity  ;do a sub to move object gradually
  ldx ObjectOffset   ;get enemy object offset and leave
  rts

def DrawPlayerLoop():
  do {  // loop1
    // Block: DrawPlayerLoop
    lda PlayerGraphicsTable,x    ;load player's left side
    sta $00
    lda PlayerGraphicsTable+1,x  ;now load right side
    jsr DrawOneSpriteRow
    dec $07                      ;decrement rows of sprites to draw
    bne DrawPlayerLoop           ;do this until all rows are drawn
  } while (!BNE DrawPlayerLoop)
  rts

def ChkLrgObjFixedLength():
  lda AreaObjectLength,x  ;check for set length counter
  clc                     ;clear carry flag for not just starting
  if (!BPL LenSet) {  // from ChkLrgObjFixedLength
    tya                     ;save length into length counter
    sta AreaObjectLength,x
    sec                     ;set carry flag if just starting
  }
  // Block: LenSet
  LenSet: rts

def BumpBlock():
  // Block: SetupPowerUp
  lda #PowerUpObject        ;load power-up identifier into
  sta Enemy_ID+5            ;special use slot of enemy object buffer
  lda Block_PageLoc,x       ;store page location of block object
  sta Enemy_PageLoc+5       ;as page location of power-up object
  lda Block_X_Position,x    ;store horizontal coordinate of block object
  sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
  lda #$01
  sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
  lda Block_Y_Position,x    ;get vertical coordinate of block object
  sec
  sbc #$08                  ;subtract 8 pixels
  sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
  PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
  sta Enemy_State+5         ;set power-up object's state
  sta Enemy_Flag+5          ;set buffer flag
  lda #$03
  sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
  lda PowerUpType
  cmp #$02                  ;check currently loaded power-up type
  if (!BCS PutBehind) {  // from PwrUpJmp
    lda PlayerStatus          ;otherwise check player's current status
    cmp #$02
    if (!BCC StrType) {  // from @7145
      lsr                       ;otherwise shift right to force fire flower type
    }
    // Block: StrType
    StrType:   sta PowerUpType           ;store type here
  }
  // Block: PutBehind
  PutBehind: lda #%00100000
  sta Enemy_SprAttrib+5     ;set background priority bit
  lda #Sfx_GrowPowerUp
  sta Square2SoundQueue     ;load power-up reveal sound and leave
  rts
  jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
  lda #Sfx_Bump
  sta Square1SoundQueue   ;play bump sound
  lda #$00
  sta Block_X_Speed,x     ;initialize horizontal speed for block object
  sta Block_Y_MoveForce,x ;init fractional movement force
  sta Player_Y_Speed      ;init player's vertical speed
  lda #$fe
  sta Block_Y_Speed,x     ;set vertical speed for block object
  lda $05                 ;get original metatile from stack
  jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
  if (!BCC ExitBlockChk) {  // from BumpBlock
    tya                     ;move block number to A
    cmp #$09                ;if block number was within 0-8 range,
    if (!BCC BlockCode) {  // from @7319
      sbc #$05                ;otherwise subtract 5 for second set to get proper number
    }
    // Block: BlockCode
    BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
    // Block: MushFlowerBlock
    lda #$00       ;load mushroom/fire flower into power-up type
    // Block: StarBlock
    lda #$02       ;load star into power-up type
    loop {  // loop24 (infinite)
      // Block: PwrUpJmp
      PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
      sta Enemy_State+5         ;set power-up object's state
      sta Enemy_Flag+5          ;set buffer flag
      lda #$03
      sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
      lda PowerUpType
      cmp #$02                  ;check currently loaded power-up type
      bcs PutBehind             ;if star or 1-up, branch ahead
      lda PlayerStatus          ;otherwise check player's current status
      cmp #$02
      bcc StrType               ;if player not fiery, use status as power-up type
      // Block: ExtraLifeMushBlock
      lda #$03         ;load 1-up mushroom into power-up type
      sta $39          ;store correct power-up type
      jmp SetupPowerUp
    }
  }
  // Block: ExitBlockChk
  rts                     ;leave

def OutputNumbers():
  clc                      ;add 1 to low nybble
  adc #$01
  and #%00001111           ;mask out high nybble
  cmp #$06
  if (!BCS ExitOutputN) {  // from OutputNumbers
    pha                      ;save incremented value to stack for now and
    asl                      ;shift to left and use as offset
    tay
    ldx VRAM_Buffer1_Offset  ;get current buffer pointer
    lda #$20                 ;put at top of screen by default
    cpy #$00                 ;are we writing top score on title screen?
    if (!BNE SetupNums) {  // from @2544
      lda #$22                 ;if so, put further down on the screen
    }
    // Block: SetupNums
    SetupNums:   sta VRAM_Buffer1,x
    lda StatusBarData,y      ;write low vram address and length of thing
    sta VRAM_Buffer1+1,x     ;we're printing to the buffer
    lda StatusBarData+1,y
    sta VRAM_Buffer1+2,x
    sta $03                  ;save length byte in counter
    stx $02                  ;and buffer pointer elsewhere for now
    pla                      ;pull original incremented value from stack
    tax
    lda StatusBarOffset,x    ;load offset to value we want to write
    sec
    sbc StatusBarData+1,y    ;subtract from length byte we read before
    tay                      ;use value as offset to display digits
    ldx $02
    do {  // loop4
      // Block: DigitPLoop
      DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
      sta VRAM_Buffer1+3,x
      inx
      iny
      dec $03                  ;do this until all the digits are written
      bne DigitPLoop
    } while (!BNE DigitPLoop)
    lda #$00                 ;put null terminator at end
    sta VRAM_Buffer1+3,x
    inx                      ;increment buffer pointer by 3
    inx
    inx
    stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
  }
  // Block: ExitOutputN
  ExitOutputN: rts

def InjurePlayer():
  // Block: InjurePlayer
  lda InjuryTimer          ;check again to see if injured invincibility timer is
  bne ExInjColRoutines     ;at zero, and branch to leave if so

def MoveFallingPlatform():
  // Block: MoveFallingPlatform
  ldy #$20       ;set movement amount

def TransposePlayers():
  sec                       ;set carry flag by default to end game
  lda NumberOfPlayers       ;if only a 1 player game, leave
  if (!BEQ ExTrans) {  // from TransposePlayers
    lda OffScr_NumberofLives  ;does offscreen player have any lives left?
    if (!BMI ExTrans) {  // from @3007
      lda CurrentPlayer         ;invert bit to update
      eor #%00000001            ;which player is on the screen
      sta CurrentPlayer
      ldx #$06
      do {  // loop2
        // Block: TransLoop
        TransLoop: lda OnscreenPlayerInfo,x    ;transpose the information
        pha                         ;of the onscreen player
        lda OffscreenPlayerInfo,x   ;with that of the offscreen player
        sta OnscreenPlayerInfo,x
        pla
        sta OffscreenPlayerInfo,x
        dex
        bpl TransLoop
      } while (!BPL TransLoop)
      clc            ;clear carry flag to get game going
    }
  }
  // Block: ExTrans
  ExTrans:   rts

def BoundingBoxCore():
  // Block: BoundingBoxCore
  stx $00                     ;save offset here
  lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
  sta $02                     ;vertically and horizontally, respectively
  lda SprObject_Rel_XPos,y
  sta $01
  txa                         ;multiply offset by four and save to stack
  asl
  asl
  pha
  tay                         ;use as offset for Y, X is left alone
  lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
  asl                         ;multiply that by four and use as X
  asl
  tax
  lda $01                     ;add the first number in the bounding box data to the
  clc                         ;relative horizontal coordinate using enemy object offset
  adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
  sta BoundingBox_UL_Corner,y ;store here
  lda $01
  clc
  adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
  sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
  inx                         ;increment both offsets
  iny
  lda $02                     ;add the second number to the relative vertical coordinate
  clc                         ;using incremented offset and store using the other
  adc BoundBoxCtrlData,x      ;incremented offset
  sta BoundingBox_UL_Corner,y
  lda $02
  clc
  adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
  sta BoundingBox_LR_Corner,y ;and store
  pla                         ;get original offset loaded into $00 * y from stack
  tay                         ;use as Y
  ldx $00                     ;get original offset and use as X again
  rts

def DrawBlock():
  // Block: DrawBlock
  lda Block_Rel_YPos            ;get relative vertical coordinate of block object
  sta $02                       ;store here
  lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
  sta $05                       ;store here
  lda #$03
  sta $04                       ;set attribute byte here
  lsr
  sta $03                       ;set horizontal flip bit here (will not be used)
  ldy Block_SprDataOffset,x     ;get sprite data offset
  ldx #$00                      ;reset X for use as offset to tile data
  do {  // loop2
    // Block: DBlkLoop
    DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
    sta $00                       ;set here
    lda DefaultBlockObjTiles+1,x  ;get right tile number
    jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
    cpx #$04                      ;check incremented offset
    bne DBlkLoop                  ;and loop back until all four sprites are done
  } while (!BNE DBlkLoop)
  ldx ObjectOffset              ;get block object offset
  ldy Block_SprDataOffset,x     ;get sprite data offset
  lda AreaType
  cmp #$01                      ;check for ground level type area
  if (!BEQ ChkRep) {  // from @14113
    lda #$86
    sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
    sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
  }
  ChkRep:    lda Block_Metatile,x          ;check replacement metatile
  cmp #$c4                      ;if not used block metatile, then
  if (!BNE BlkOffscr) {  // from ChkRep
    lda #$87                      ;set A for used block tile
    iny                           ;increment Y to write to tile bytes
    jsr DumpFourSpr               ;do sub to dump into all four sprites
    dey                           ;return Y to original offset
    lda #$03                      ;set palette bits
    ldx AreaType
    dex                           ;check for ground level type area again
    if (!BEQ SetBFlip) {  // from @14124
      lsr                           ;otherwise set to $01
    }
    // Block: SetBFlip
    SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
    sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
    ora #%01000000
    sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
    ora #%10000000
    sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
    and #%10000011
    sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
  }
  BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
  pha                           ;save to stack
  and #%00000100                ;check to see if d2 in offscreen bits are set
  if (!BEQ PullOfsB) {  // from BlkOffscr
    lda #$f8                      ;move offscreen two OAMs
    sta Sprite_Y_Position+4,y     ;on the right side
    sta Sprite_Y_Position+12,y
  }
  // Block: PullOfsB
  PullOfsB:  pla                           ;pull offscreen bits from stack

def RelativeEnemyPosition():
  // Block: RelativeEnemyPosition
  lda #$01                     ;get coordinates of enemy object
  ldy #$01                     ;relative to the screen
  jmp VariableObjOfsRelPos

def BulletBillHandler():
  lda TimerControl          ;if master timer control set,
  if (!BNE RunBBSubs) {  // from BulletBillHandler
    lda Enemy_State,x
    if (!BNE ChkDSte) {  // from @6826
      lda Enemy_OffscreenBits   ;otherwise load offscreen bits
      and #%00001100            ;mask out bits
      cmp #%00001100            ;check to see if all bits are set
      if (!BEQ KillBB) {  // from @6828
        ldy #$01                  ;set to move right by default
        jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
        if (!BMI SetupBB) {  // from @6832
          iny                       ;otherwise increment to move left
        }
        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
        dey                       ;decrement to use as offset
        lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
        sta Enemy_X_Speed,x       ;and store it
        lda $00                   ;get horizontal difference
        adc #$28                  ;add 40 pixels
        cmp #$50                  ;if less than a certain amount, player is too close
        if (!BCC KillBB) {  // from SetupBB
          lda #$01
          sta Enemy_State,x         ;otherwise set bullet bill's state
          lda #$0a
          sta EnemyFrameTimer,x     ;set enemy frame timer
          lda #Sfx_Blast
          sta Square2SoundQueue     ;play fireworks/gunfire sound
          ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
          and #%00100000
          if (!BEQ BBFly) {  // from ChkDSte
            jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
          }
          // Block: BBFly
          BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
          // Block: RunBBSubs
          RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
          jsr RelativeEnemyPosition ;get relative coordinates
          jsr GetEnemyBoundBox      ;get bounding box coordinates
          jsr PlayerEnemyCollision  ;handle player to enemy collisions
          jmp EnemyGfxHandler       ;draw the bullet bill and leave
        }
      }
    }
    if (!BEQ BBFly) {  // from ChkDSte
    }
  }
  // Block: KillBB
  KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
  rts

def BlockBufferColli_Head():
  // Block: BlockBufferColli_Head
  lda #$00       ;set flag to return vertical coordinate

def Square1SfxHandler():
  ldy Square1SoundQueue   ;check for sfx in queue
  if (!BEQ CheckSfx1Buffer) {  // from Square1SfxHandler
    sty Square1SoundBuffer  ;if found, put in buffer
    bmi PlaySmallJump       ;small jump
    lsr Square1SoundQueue
    bcs PlayBigJump         ;big jump
    lsr Square1SoundQueue
    bcs PlayBump            ;bump
    lsr Square1SoundQueue
    if (!BCS PlaySwimStomp) {  // from @15239
      lsr Square1SoundQueue
      bcs PlaySmackEnemy      ;smack enemy
      lsr Square1SoundQueue
      if (!BCS PlayPipeDownInj) {  // from @15243
        lsr Square1SoundQueue
        bcs PlayFireballThrow   ;fireball throw
        lsr Square1SoundQueue
        bcs PlayFlagpoleSlide   ;slide flagpole
        lda Square1SoundBuffer   ;check for sfx in buffer
        if (!BEQ ExS1H) {  // from CheckSfx1Buffer
          bmi ContinueSndJump      ;small mario jump
          lsr
          bcs ContinueSndJump      ;big mario jump
          lsr
          bcs ContinueBumpThrow    ;bump
          lsr
          if (!BCS ContinueSwimStomp) {  // from @15258
            lsr
            bcs ContinueSmackEnemy   ;smack enemy
            lsr
            if (!BCS ContinuePipeDownInj) {  // from @15262
              lsr
              bcs ContinueBumpThrow    ;fireball throw
              lsr
              bcs DecrementSfx1Length  ;slide flagpole
              // Block: ExS1H
              ExS1H: rts
              // Block: PlaySwimStomp
              lda #$0e               ;store length of swim/stomp sound
              sta Squ1_SfxLenCounter
              ldy #$9c               ;store reg contents for swim/stomp sound
              ldx #$9e
              lda #$26
              jsr PlaySqu1Sfx
              // Block: ContinueSwimStomp
              ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
              lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
              sta SND_SQUARE1_REG           ;envelope
              cpy #$06
              bne BranchToDecLength1
              lda #$9e                      ;when the length counts down to a certain point, put this
              sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
              // Block: PlayPipeDownInj
              lda #$2f                ;load length of pipedown sound
              sta Squ1_SfxLenCounter
            }
          }
        }
      }
    }
  }
  lda Square1SoundBuffer   ;check for sfx in buffer
  if (!BEQ ExS1H) {  // from CheckSfx1Buffer
    lsr
    if (!BCS ContinueSwimStomp) {  // from @15258
      lsr
      if (!BCS ContinuePipeDownInj) {  // from @15262
      }
    }
  }
  lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
  lsr                     ;to be written to only during six specific times
  if (!BCS NoPDwnL) {  // from ContinuePipeDownInj
    lsr
    if (!BCS NoPDwnL) {  // from @15331
      and #%00000010
      if (!BEQ NoPDwnL) {  // from @15333
        ldy #$91                ;and this is where it actually gets written in
        ldx #$9a
        lda #$44
        jsr PlaySqu1Sfx
      }
    }
  }
  // Block: NoPDwnL
  NoPDwnL: jmp DecrementSfx1Length

def DecodeAreaData():
  lda AreaObjectLength,x     ;check current buffer flag
  if (!BMI Chk1stB) {  // from DecodeAreaData
    ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
  }
  // Block: Chk1stB
  Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
  lda (AreaData),y           ;get first byte of level object again
  cmp #$fd
  beq EndAParse              ;if end of level, leave this routine
  and #$0f                   ;otherwise, mask out low nybble
  cmp #$0f                   ;row 15?
  if (!BEQ ChkRow14) {  // from @3375
    ldx #$08                   ;otherwise load offset of 8 for special row 12
    cmp #$0c                   ;row 12?
    if (!BEQ ChkRow14) {  // from @3378
      ldx #$00                   ;otherwise nullify value by default
    }
  }
  ChkRow14: stx $07                    ;store whatever value we just loaded here
  ldx ObjectOffset           ;get object offset again
  cmp #$0e                   ;row 14?
  if (!BNE ChkRow13) {  // from ChkRow14
    lda #$00                   ;if so, load offset with $00
    sta $07
    lda #$2e                   ;and load A with another value
    if (!BNE NormObj) {  // from @3386
      ChkRow13: cmp #$0d                   ;row 13?
      if (!BNE ChkSRows) {  // from ChkRow13
        lda #$22                   ;if so, load offset with 34
        sta $07
        iny                        ;get next byte
        lda (AreaData),y
        and #%01000000             ;mask out all but d6 (page control obj bit)
        if (!BEQ LeavePar) {  // from @3392
          lda (AreaData),y           ;otherwise, get byte again
          and #%01111111             ;mask out d7
          cmp #$4b                   ;check for loop command in low nybble
          if (!BNE Mask2MSB) {  // from @3398
            inc LoopCommand            ;if loop command, set loop command flag
          }
          // Block: Mask2MSB
          Mask2MSB: and #%00111111             ;mask out d7 and d6
          jmp NormObj                ;and jump
          ChkSRows: cmp #$0c                   ;row 12-15?
          if (!BCS SpecObj) {  // from ChkSRows
            iny                        ;if not, get second byte of level object
            lda (AreaData),y
            and #%01110000             ;mask out all but d6-d4
            if (!BNE LrgObj) {  // from @3407
              lda #$16
              sta $07                    ;otherwise set offset of 24 for small object
              lda (AreaData),y           ;reload second byte of level object
              and #%00001111             ;mask out higher nybble and jump
              jmp NormObj
            }
            LrgObj:   sta $00                    ;store value here (branch for large objects)
            cmp #$70                   ;check for vertical pipe object
            if (!BNE NotWPipe) {  // from LrgObj
              lda (AreaData),y           ;if not, reload second byte
              and #%00001000             ;mask out all but d3 (usage control bit)
              if (!BEQ NotWPipe) {  // from @3419
                lda #$00                   ;otherwise, nullify value for warp pipe
                sta $00
              }
            }
            // Block: NotWPipe
            NotWPipe: lda $00                    ;get value and jump ahead
            jmp MoveAOId
          } else {
            // Block: SpecObj
            SpecObj:  iny                        ;branch here for rows 12-15
            lda (AreaData),y
            and #%01110000             ;get next byte and mask out all but d6-d4
          }
          // Block: MoveAOId
          MoveAOId: lsr                        ;move d6-d4 to lower nybble
          lsr
          lsr
          lsr
          NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
          lda AreaObjectLength,x     ;is there something stored here already?
          if (!BPL RunAObj) {  // from NormObj
            lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
            cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
            if (!BEQ InitRear) {  // from @3436
              ldy AreaDataOffset         ;if not, get old offset of level pointer
              lda (AreaData),y           ;and reload first byte
              and #%00001111
              cmp #$0e                   ;row 14?
              if (!BNE LeavePar) {  // from @3439
                lda BackloadingFlag        ;if so, check backloading flag
                if (!BNE StrAObj) {  // from @3444
                  // Block: LeavePar
                  LeavePar: rts
                  InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
                  if (!BEQ BackColC) {  // from InitRear
                    lda #$00                   ;if not, initialize both backloading and
                    sta BackloadingFlag        ;behind-renderer flags and leave
                    sta BehindAreaParserFlag
                    sta ObjectOffset
                    // Block: LoopCmdE
                    LoopCmdE: rts
                  }
                  // Block: BackColC
                  BackColC: ldy AreaDataOffset         ;get first byte again
                  lda (AreaData),y
                  and #%11110000             ;mask out low nybble and move high to low
                  lsr
                  lsr
                  lsr
                  lsr
                  cmp CurrentColumnPos       ;is this where we're at?
                  bne LeavePar               ;if not, branch to leave
                }
              }
            }
            if (!BEQ BackColC) {  // from InitRear
            }
            do {  // loop35
            } while (BNE LeavePar)
            // Block: StrAObj
            StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
            sta AreaObjOffsetBuffer,x
            jsr IncAreaObjOffset       ;do sub to increment to next object data
          }
        }
      } else {
        if (!BCS SpecObj) {  // from ChkSRows
          if (!BNE LrgObj) {  // from @3407
          }
          if (!BNE NotWPipe) {  // from LrgObj
            if (!BEQ NotWPipe) {  // from @3419
            }
          }
        }
      }
    }
  }
  ChkRow13: cmp #$0d                   ;row 13?
  if (!BNE ChkSRows) {  // from ChkRow13
    lda #$22                   ;if so, load offset with 34
    sta $07
    iny                        ;get next byte
    lda (AreaData),y
    and #%01000000             ;mask out all but d6 (page control obj bit)
    if (!BEQ LeavePar) {  // from @3392
      lda (AreaData),y           ;otherwise, get byte again
      and #%01111111             ;mask out d7
      cmp #$4b                   ;check for loop command in low nybble
      if (!BNE Mask2MSB) {  // from @3398
      }
      ChkSRows: cmp #$0c                   ;row 12-15?
      if (!BCS SpecObj) {  // from ChkSRows
        iny                        ;if not, get second byte of level object
        lda (AreaData),y
        and #%01110000             ;mask out all but d6-d4
        if (!BNE LrgObj) {  // from @3407
        }
        LrgObj:   sta $00                    ;store value here (branch for large objects)
        cmp #$70                   ;check for vertical pipe object
        if (!BNE NotWPipe) {  // from LrgObj
          lda (AreaData),y           ;if not, reload second byte
          and #%00001000             ;mask out all but d3 (usage control bit)
          if (!BEQ NotWPipe) {  // from @3419
          }
        }
      }
      NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
      lda AreaObjectLength,x     ;is there something stored here already?
      if (!BPL RunAObj) {  // from NormObj
        lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
        cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
        if (!BEQ InitRear) {  // from @3436
          ldy AreaDataOffset         ;if not, get old offset of level pointer
          lda (AreaData),y           ;and reload first byte
          and #%00001111
          cmp #$0e                   ;row 14?
          if (!BNE LeavePar) {  // from @3439
            lda BackloadingFlag        ;if so, check backloading flag
            if (!BNE StrAObj) {  // from @3444
              InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
              if (!BEQ BackColC) {  // from InitRear
              }
            }
          }
        }
        if (!BEQ BackColC) {  // from InitRear
        }
        do {  // loop80
        } while (BNE LeavePar)
      }
    }
  } else {
    if (!BCS SpecObj) {  // from ChkSRows
      if (!BNE LrgObj) {  // from @3407
      }
      if (!BNE NotWPipe) {  // from LrgObj
        if (!BEQ NotWPipe) {  // from @3419
        }
      }
    }
  }
  NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
  lda AreaObjectLength,x     ;is there something stored here already?
  if (!BPL RunAObj) {  // from NormObj
    lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
    cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
    if (!BEQ InitRear) {  // from @3436
      ldy AreaDataOffset         ;if not, get old offset of level pointer
      lda (AreaData),y           ;and reload first byte
      and #%00001111
      cmp #$0e                   ;row 14?
      if (!BNE LeavePar) {  // from @3439
        lda BackloadingFlag        ;if so, check backloading flag
        if (!BNE StrAObj) {  // from @3444
          InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
          if (!BEQ BackColC) {  // from InitRear
          }
        }
      }
    }
    if (!BEQ BackColC) {  // from InitRear
    }
    do {  // loop111
    } while (BNE LeavePar)
  }
  // Block: RunAObj
  RunAObj:  lda $00                    ;get stored value and add offset to it
  clc                        ;then use the jump engine with current contents of A
  adc $07
  jsr JumpEngine
  ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
  iny                       ;load second byte
  lda (AreaData),y
  pha                       ;save in stack for now
  and #%01000000
  if (!BNE Alter2) {  // from AlterAreaAttributes
    pla
    pha                       ;pull and push offset to copy to A
    and #%00001111            ;mask out high nybble and store as
    sta TerrainControl        ;new terrain height type bits
    pla
    and #%00110000            ;pull and mask out all but d5 and d4
    lsr                       ;move bits to lower nybble and store
    lsr                       ;as new background scenery bits
    lsr
    lsr
    sta BackgroundScenery     ;then leave
    rts
  }
  Alter2:  pla
  and #%00000111            ;mask out all but 3 LSB
  cmp #$04                  ;if four or greater, set color control bits
  if (!BCC SetFore) {  // from Alter2
    sta BackgroundColorCtrl
    lda #$00
  }
  // Block: SetFore
  SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
  rts

def ImposeGravitySprObj():
  // Block: ImposeGravitySprObj
  sta $02            ;set maximum speed here
  lda #$00           ;set value to move downwards
  jmp ImposeGravity  ;jump to the code that actually moves it

def LargePlatformCollision():
  // Block: LargePlatformCollision
  lda #$ff                     ;save value here
  sta PlatformCollisionFlag,x
  lda TimerControl             ;check master timer control
  bne ExLPC                    ;if set, branch to leave
  lda Enemy_State,x            ;if d7 set in object state,
  bmi ExLPC                    ;branch to leave
  lda Enemy_ID,x
  cmp #$24                     ;check enemy object identifier for
  bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
  lda Enemy_State,x
  tax                          ;set state as enemy offset here
  jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X

def Dump_Sq2_Regs():
  // Block: Dump_Sq2_Regs
  stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
  sty SND_SQUARE2_REG+1
  rts

def ReadPortBits():
  // Block: ReadPortBits
  ReadPortBits: ldy #$08
  do {  // loop2
    // Block: PortLoop
    PortLoop:     pha                    ;push previous bit onto stack
    lda JOYPAD_PORT,x      ;read current bit on joypad port
    sta $00                ;check d1 and d0 of port output
    lsr                    ;this is necessary on the old
    ora $00                ;famicom systems in japan
    lsr
    pla                    ;read bits from stack
    rol                    ;rotate bit from carry flag
    dey
    bne PortLoop           ;count down bits left
  } while (!BNE PortLoop)
  sta SavedJoypadBits,x  ;save controller status here always
  pha
  and #%00110000         ;check for select or start
  and JoypadBitMask,x    ;if neither saved state nor current state
  if (!BEQ Save8Bits) {  // from @2439
    pla
    and #%11001111         ;otherwise store without select
    sta SavedJoypadBits,x  ;or start bits and leave
    rts
  }
  // Block: Save8Bits
  Save8Bits:    pla
  sta JoypadBitMask,x    ;save with all bits in another place and leave
  rts

def SetupJumpCoin():
  // Block: SetupJumpCoin
  jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
  lda Block_PageLoc2,x   ;get page location saved earlier
  sta Misc_PageLoc,y     ;and save as page location for misc object
  lda $06                ;get low byte of block buffer offset
  asl
  asl                    ;multiply by 16 to use lower nybble
  asl
  asl
  ora #$05               ;add five pixels
  sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
  lda $02                ;get vertical high nybble offset from earlier
  adc #$20               ;add 32 pixels for the status bar
  sta Misc_Y_Position,y  ;store as vertical coordinate
  // Block: JCoinC
  JCoinC: lda #$fb
  sta Misc_Y_Speed,y     ;set vertical speed
  lda #$01
  sta Misc_Y_HighPos,y   ;set vertical high byte
  sta Misc_State,y       ;set state for misc object
  sta Square2SoundQueue  ;load coin grab sound
  stx ObjectOffset       ;store current control bit as misc object offset
  jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
  inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
  rts

def InitializeNameTables():
  // Block: InitializeNameTables
  lda PPU_STATUS            ;reset flip-flop
  lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
  ora #%00010000            ;set sprites for first 4k and background for second 4k
  and #%11110000            ;clear rest of lower nybble, leave higher alone
  jsr WritePPUReg1
  lda #$24                  ;set vram address to start of name table 1
  jsr WriteNTAddr
  lda #$20                  ;and then set it to name table 0

def SmallBBox():
  // Block: SmallBBox
  SmallBBox: lda #$09               ;set specific bounding box size control
  bne SetBBox            ;unconditional branch
  ldy #$30                    ;load central position adder for 48 pixels down
  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
  sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
  if (!BPL GetCent) {  // from InitRedPTroopa
    ldy #$e0                    ;if => $80, load position adder for 32 pixels up
  }
  // Block: GetCent
  GetCent:  tya                         ;send central position adder to A
  adc Enemy_Y_Position,x      ;add to current vertical coordinate
  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate

def GetEnemyBoundBoxOfs():
  // Block: GetEnemyBoundBoxOfs
  lda ObjectOffset         ;get enemy object buffer offset

def JCoinGfxHandler():
  lda FrameCounter          ;get frame counter
  lsr                       ;divide by 2
  if (!BCS NotRsNum) {  // from DrawFloateyNumber_Coin
    dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
  }
  // Block: NotRsNum
  NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
  jsr DumpTwoSpr            ;dump into both sprites
  lda Misc_Rel_XPos         ;get relative horizontal coordinate
  sta Sprite_X_Position,y   ;store as X coordinate for first sprite
  clc
  adc #$08                  ;add eight pixels
  sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
  lda #$02
  sta Sprite_Attributes,y   ;store attribute byte in both sprites
  sta Sprite_Attributes+4,y
  lda #$f7
  sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
  lda #$fb                  ;that resemble "200"
  sta Sprite_Tilenumber+4,y
  jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
  // Block: JCoinGfxHandler
  ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
  lda Misc_State,x            ;get state of misc object
  cmp #$02                    ;if 2 or greater,
  bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
  lda Misc_Y_Position,x       ;store vertical coordinate as
  sta Sprite_Y_Position,y     ;Y coordinate for first sprite
  clc
  adc #$08                    ;add eight pixels
  sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
  lda Misc_Rel_XPos           ;get relative horizontal coordinate
  sta Sprite_X_Position,y
  sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
  lda FrameCounter            ;get frame counter
  lsr                         ;divide by 2 to alter every other frame
  and #%00000011              ;mask out d2-d1
  tax                         ;use as graphical offset
  lda JumpingCoinTiles,x      ;load tile number
  iny                         ;increment OAM data offset to write tile numbers
  jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
  dey                         ;decrement to get old offset
  lda #$02
  sta Sprite_Attributes,y     ;set attribute byte in first sprite
  lda #$82
  sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
  ldx ObjectOffset            ;get misc object offset
  // Block: ExJCGfx
  ExJCGfx: rts                         ;leave

def UpdateTopScore():
  // Block: UpdateTopScore
  ldx #$05          ;start with mario's score
  jsr TopScoreCheck
  ldx #$0b          ;now do luigi's score

def InitHorizFlySwimEnemy():
  // Block: InitHorizFlySwimEnemy
  lda #$00        ;initialize horizontal speed
  jmp SetESpd

def LargePlatformSubroutines():
  // Block: LargePlatformSubroutines
  lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
  sec
  sbc #$24
  jsr JumpEngine

def ChkForPlayerC_LargeP():
  jsr CheckPlayerVertical      ;figure out if player is below a certain point
  if (!BCS ExLPC) {  // from ChkForPlayerC_LargeP
    txa
    jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
    lda Enemy_Y_Position,x       ;store vertical coordinate in
    sta $00                      ;temp variable for now
    txa                          ;send offset we're on to the stack
    pha
    jsr PlayerCollisionCore      ;do player-to-platform collision detection
    pla                          ;retrieve offset from the stack
    tax
    if (!BCC ExLPC) {  // from @11725
      jsr ProcLPlatCollisions      ;otherwise collision, perform sub
    }
  }
  // Block: ExLPC
  ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
  rts

def ChkInvisibleMTiles():
  cmp #$5f       ;check for hidden coin block
  if (!BEQ ExCInvT) {  // from ChkInvisibleMTiles
    cmp #$60       ;check for hidden 1-up block
  }
  // Block: ExCInvT
  ExCInvT: rts            ;leave with zero flag set if either found

def ChgAreaMode():
  // Block: ChgAreaMode
  ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
  lda #$00
  sta OperMode_Task         ;set secondary mode of operation
  sta Sprite0HitDetectFlag  ;disable sprite 0 check
  // Block: ExitCAPipe
  ExitCAPipe:  rts                       ;leave

def ProcessLengthData():
  // Block: ProcessLengthData
  and #%00000111              ;clear all but the three LSBs
  clc
  adc $f0                     ;add offset loaded from first header byte
  adc NoteLengthTblAdder      ;add extra if time running out music
  tay
  lda MusicLengthLookupTbl,y  ;load length
  rts

def VictoryModeSubroutines():
  // Block: VictoryModeSubroutines
  lda OperMode_Task
  jsr JumpEngine
  // Block: SetupVictoryMode
  ldx ScreenRight_PageLoc  ;get page location of right side of screen
  inx                      ;increment to next page
  stx DestinationPageLoc   ;store here
  lda #EndOfCastleMusic
  sta EventMusicQueue      ;play win castle music
  jmp IncModeTask_B        ;jump to set next major task in victory mode
  // Block: IncModeTask_B
  IncModeTask_B: inc OperMode_Task  ;move onto next mode
  rts

def DonePlayerTask():
  // Block: DonePlayerTask
  lda #$00
  sta TimerControl          ;initialize master timer control to continue timers
  lda #$08
  sta GameEngineSubroutine  ;set player control routine to run next frame
  rts                       ;leave

def FlagpoleGfxHandler():
  ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
  lda Enemy_Rel_XPos             ;get relative horizontal coordinate
  sta Sprite_X_Position,y        ;store as X coordinate for first sprite
  clc
  adc #$08                       ;add eight pixels and store
  sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
  sta Sprite_X_Position+8,y
  clc
  adc #$0c                       ;add twelve more pixels and
  sta $05                        ;store here to be used later by floatey number
  lda Enemy_Y_Position,x         ;get vertical coordinate
  jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
  adc #$08                       ;add eight pixels
  sta Sprite_Y_Position+8,y      ;and store into third sprite
  lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
  sta $02                        ;store it here
  lda #$01
  sta $03                        ;set value for flip which will not be used, and
  sta $04                        ;attribute byte for floatey number
  sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
  sta Sprite_Attributes+4,y
  sta Sprite_Attributes+8,y
  lda #$7e
  sta Sprite_Tilenumber,y        ;put triangle shaped tile
  sta Sprite_Tilenumber+8,y      ;into first and third sprites
  lda #$7f
  sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
  lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
  if (!BEQ ChkFlagOffscreen) {  // from FlagpoleGfxHandler
    tya
    clc                            ;add 12 bytes to sprite data offset
    adc #$0c
    tay                            ;put back in Y
    lda FlagpoleScore              ;get offset used to award points for touching flagpole
    asl                            ;multiply by 2 to get proper offset here
    tax
    lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
    sta $00
    lda FlagpoleScoreNumTiles+1,x
    jsr DrawOneSpriteRow           ;use it to render floatey number
  }
  // Block: ChkFlagOffscreen
  ldx ObjectOffset               ;get object offset for flag
  ldy Enemy_SprDataOffset,x      ;get OAM data offset
  lda Enemy_OffscreenBits        ;get offscreen bits
  and #%00001110                 ;mask out all but d3-d1
  beq ExitDumpSpr                ;if none of these bits set, branch to leave

def ChkLrgObjLength():
  // Block: ChkLrgObjLength
  jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)

def DumpSixSpr():
  // Block: DumpSixSpr
  sta Sprite_Data+20,y      ;dump A contents
  sta Sprite_Data+16,y      ;into third row sprites

def HandleChangeSize():
  ldy PlayerAnimCtrl           ;get animation frame control
  lda FrameCounter
  and #%00000011               ;get frame counter and execute this code every
  if (!BNE GorSLog) {  // from HandleChangeSize
    iny                          ;increment frame control
    cpy #$0a                     ;check for preset upper extent
    if (!BCC CSzNext) {  // from @14697
      ldy #$00                     ;otherwise initialize both grow/shrink flag
      sty PlayerChangeSizeFlag     ;and animation frame control
    }
    // Block: CSzNext
    CSzNext: sty PlayerAnimCtrl           ;store proper frame control
  }
  GorSLog: lda PlayerSize               ;get player's size
  if (!BNE ShrinkPlayer) {  // from GorSLog
    lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
    ldy #$0f                     ;load offset for player growing
  }
  tya                          ;add ten bytes to frame control as offset
  clc
  adc #$0a                     ;this thing apparently uses two of the swimming frames
  tax                          ;to draw the player shrinking
  ldy #$09                     ;load offset for small player swimming
  lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
  if (!BNE ShrPlF) {  // from ShrinkPlayer
    ldy #$01                     ;otherwise load offset for big player swimming
  }
  // Block: ShrPlF
  ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
  rts                          ;and leave

def InitializeMemory():
  // Block: InitializeMemory
  ldx #$07          ;set initial high byte to $0700-$07ff
  lda #$00          ;set initial low byte to start of page (at $00 of page)
  sta $06
  dex               ;go onto the next page
  while (BPL InitPageLoop) {  // loop7
    // Block: InitPageLoop
    InitPageLoop: stx $07
    // Block: InitByteLoop
    InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
    bne InitByte      ;if not, go ahead anyway
    cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
    bcs SkipByte      ;if so, skip write
    // Block: InitByte
    InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
    // Block: SkipByte
    SkipByte:     dey
    cpy #$ff          ;do this until all bytes in page have been erased
    bne InitByteLoop
  }
  rts

def InitNormalEnemy():
  ldy #$01              ;load offset of 1 by default
  lda PrimaryHardMode   ;check for primary hard mode flag set
  if (!BNE GetESpd) {  // from InitNormalEnemy
    dey                   ;if not set, decrement offset
  }
  // Block: GetESpd
  GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
  // Block: SetESpd
  SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
  jmp TallBBox          ;branch to set bounding box control and other data
  // Block: TallBBox
  TallBBox: lda #$03                    ;set specific bounding box size control
  // Block: SetBBox
  SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
  lda #$02                    ;set moving direction for left
  sta Enemy_MovingDir,x

def SprObjectCollisionCore():
  // Block: SprObjectCollisionCore
  sty $06      ;save contents of Y here
  lda #$01
  sta $07      ;save value 1 here as counter, compare horizontal coordinates first
  lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
  cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
  if (!BCS FirstBoxGreater) {  // from CollisionCoreLoop
    cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
    if (!BCC SecondBoxVerticalChk) {  // from @12942
      if (!BEQ CollisionFound) {  // from @12944
        lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
        cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
        if (!BCC CollisionFound) {  // from @12945
          cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
          if (!BCS CollisionFound) {  // from @12948
            ldy $06                      ;otherwise return with carry clear and Y = $0006
            rts                          ;note horizontal wrapping never occurs
            lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
            cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
            if (!BCC CollisionFound) {  // from SecondBoxVerticalChk
              lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
              cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
              if (!BCS CollisionFound) {  // from @12957
                ldy $06                      ;otherwise return with carry clear and Y = $0006
                rts
                cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
                if (!BEQ CollisionFound) {  // from FirstBoxGreater
                  cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
                  if (!BCC CollisionFound) {  // from @12966
                    if (!BEQ CollisionFound) {  // from @12968
                      cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
                      if (!BCC NoCollisionFound) {  // from @12969
                        if (!BEQ NoCollisionFound) {  // from @12971
                          lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
                          cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
                          if (!BCS CollisionFound) {  // from @12972
                            // Block: NoCollisionFound
                            clc          ;clear carry, then load value set earlier, then leave
                            ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
                            rts          ;not bother checking vertical ones, because what's the point?
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!BCC CollisionFound) {  // from SecondBoxVerticalChk
      if (!BCS CollisionFound) {  // from @12957
        if (!BEQ CollisionFound) {  // from FirstBoxGreater
          if (!BCC CollisionFound) {  // from @12966
            if (!BEQ CollisionFound) {  // from @12968
              if (!BCC NoCollisionFound) {  // from @12969
                if (!BEQ NoCollisionFound) {  // from @12971
                  if (!BCS CollisionFound) {  // from @12972
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
  if (!BEQ CollisionFound) {  // from FirstBoxGreater
    cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
    if (!BCC CollisionFound) {  // from @12966
      if (!BEQ CollisionFound) {  // from @12968
        cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
        if (!BCC NoCollisionFound) {  // from @12969
          if (!BEQ NoCollisionFound) {  // from @12971
            lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
            cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
            if (!BCS CollisionFound) {  // from @12972
            }
          }
        }
      }
    }
  }
  // Block: CollisionFound
  inx                    ;increment offsets on both objects to check
  iny                    ;the vertical coordinates
  dec $07                ;decrement counter to reflect this
  bpl CollisionCoreLoop  ;if counter not expired, branch to loop
  sec                    ;otherwise we already did both sets, therefore collision, so set carry
  ldy $06                ;load original value set here earlier, then leave
  rts

def MoveNormalEnemy():
  ldy #$00                   ;init Y to leave horizontal movement as-is
  lda Enemy_State,x
  and #%01000000             ;check enemy state for d6 set, if set skip
  if (!BNE FallE) {  // from MoveNormalEnemy
    lda Enemy_State,x
    asl                        ;check enemy state for d7 set
    if (!BCS SteadM) {  // from @9297
      lda Enemy_State,x
      and #%00100000             ;check enemy state for d5 set
      if (!BNE MoveDefeatedEnemy) {  // from @9300
        lda Enemy_State,x
        and #%00000111             ;check d2-d0 of enemy state for any set bits
        if (!BEQ SteadM) {  // from @9303
          cmp #$05
          if (!BEQ FallE) {  // from @9306
            cmp #$03
            if (!BCS ReviveStunned) {  // from @9308
              FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
              ldy #$00
              lda Enemy_State,x          ;check for enemy state $02
              cmp #$02
              if (!BEQ MEHor) {  // from FallE
                and #%01000000             ;check for d6 set
                if (!BEQ SteadM) {  // from @9315
                  lda Enemy_ID,x
                  cmp #PowerUpObject         ;check for power-up object
                  if (!BEQ SteadM) {  // from @9317
                    if (!BNE SlowM) {  // from @9320
                      // Block: MEHor
                      MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
                    }
                    // Block: SlowM
                    SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
                  }
                }
              }
              SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
              pha                       ;save to stack
              if (!BPL AddHS) {  // from SteadM
                iny
                iny                       ;otherwise increment Y to next data
              }
              // Block: AddHS
              AddHS:  clc
              adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
              sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
              jsr MoveEnemyHorizontally ;then do a sub to move horizontally
              pla
              sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
              rts                       ;original memory location, then leave
            }
          }
          if (!BEQ MEHor) {  // from FallE
            if (!BEQ SteadM) {  // from @9315
              if (!BEQ SteadM) {  // from @9317
                if (!BNE SlowM) {  // from @9320
                }
              }
            }
          }
        }
        if (!BPL AddHS) {  // from SteadM
        }
        lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
        if (!BNE ChkKillGoomba) {  // from ReviveStunned
          sta Enemy_State,x         ;otherwise initialize enemy state to normal
          lda FrameCounter
          and #$01                  ;get d0 of frame counter
          tay                       ;use as Y and increment for movement direction
          iny
          sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
          dey                       ;decrement for use as pointer
          lda PrimaryHardMode       ;check primary hard mode flag
          if (!BEQ SetRSpd) {  // from @9340
            iny
            iny                       ;otherwise increment 2 bytes to next data
          }
          // Block: SetRSpd
          SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
          sta Enemy_X_Speed,x       ;and leave
          rts
          // Block: MoveDefeatedEnemy
          jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
          jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
        }
      }
    }
  }
  FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
  ldy #$00
  lda Enemy_State,x          ;check for enemy state $02
  cmp #$02
  if (!BEQ MEHor) {  // from FallE
    and #%01000000             ;check for d6 set
    if (!BEQ SteadM) {  // from @9315
      lda Enemy_ID,x
      cmp #PowerUpObject         ;check for power-up object
      if (!BEQ SteadM) {  // from @9317
        if (!BNE SlowM) {  // from @9320
        }
      }
    }
  }
  SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
  pha                       ;save to stack
  if (!BPL AddHS) {  // from SteadM
  }
  lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
  if (!BNE ChkKillGoomba) {  // from ReviveStunned
    sta Enemy_State,x         ;otherwise initialize enemy state to normal
    lda FrameCounter
    and #$01                  ;get d0 of frame counter
    tay                       ;use as Y and increment for movement direction
    iny
    sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
    dey                       ;decrement for use as pointer
    lda PrimaryHardMode       ;check primary hard mode flag
    if (!BEQ SetRSpd) {  // from @9340
    }
  }
  cmp #$0e              ;check to see if enemy timer has reached
  if (!BNE NKGmba) {  // from ChkKillGoomba
    lda Enemy_ID,x
    cmp #Goomba           ;check for goomba object
    if (!BNE NKGmba) {  // from @9362
      jsr EraseEnemyObject  ;otherwise, kill this goomba object
    }
  }
  // Block: NKGmba
  NKGmba: rts                   ;leave!

def ProcLPlatCollisions():
  lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
  sec                          ;of the player's bounding box from the bottom
  sbc BoundingBox_UL_YPos      ;of the platform's bounding box
  cmp #$04                     ;if difference too large or negative,
  if (!BCS ChkForTopCollision) {  // from ProcLPlatCollisions
    lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
    if (!BPL ChkForTopCollision) {  // from @11787
      lda #$01                     ;otherwise, set vertical
      sta Player_Y_Speed           ;speed of player to kill jump
    }
  }
  lda BoundingBox_DR_YPos      ;get difference by subtracting the top
  sec                          ;of the platform's bounding box from the bottom
  sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
  cmp #$06
  if (!BCS PlatformSideCollisions) {  // from ChkForTopCollision
    lda Player_Y_Speed
    if (!BMI PlatformSideCollisions) {  // from @11798
      lda $00                      ;get saved bounding box counter from earlier
      ldy Enemy_ID,x
      cpy #$2b                     ;if either of the two small platform objects are found,
      if (!BEQ SetCollisionFlag) {  // from @11800
        cpy #$2c                     ;as contents of collision flag
        if (!BEQ SetCollisionFlag) {  // from @11804
          txa                          ;otherwise use enemy object buffer offset
        }
      }
      // Block: SetCollisionFlag
      ldx ObjectOffset             ;get enemy object buffer offset
      sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
      lda #$00
      sta Player_State             ;set player state to normal then leave
      rts
    }
  }
  lda #$01                   ;set value here to indicate possible horizontal
  sta $00                    ;collision on left side of platform
  lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
  sec                        ;from player's right edge
  sbc BoundingBox_UL_XPos,y
  cmp #$08                   ;if difference close enough, skip all of this
  if (!BCC SideC) {  // from PlatformSideCollisions
    inc $00                    ;otherwise increment value set here for right side collision
    lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
    clc                        ;from platform's right edge
    sbc BoundingBox_UL_XPos
    cmp #$09                   ;if difference not close enough, skip subroutine
    if (!BCS NoSideC) {  // from @11823
      // Block: SideC
      SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
    }
  }
  // Block: NoSideC
  NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
  rts

def AddToScore():
  // Block: AddToScore
  ldx CurrentPlayer      ;get current player
  ldy ScoreOffsets,x     ;get offset for player's score
  jsr DigitsMathRoutine  ;update the score internally with value in digit modifier

def MoveEnemySlowVert():
  // Block: MoveEnemySlowVert
  ldy #$0f         ;set movement amount for bowser/other objects

def DuplicateEnemyObj():
  // Block: DuplicateEnemyObj
  ldy #$ff                ;start at beginning of enemy slots
  do {  // loop2
    // Block: FSLoop
    FSLoop: iny                     ;increment one slot
    lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
    bne FSLoop              ;if set, branch and keep checking
  } while (!BNE FSLoop)
  sty DuplicateObj_Offset ;otherwise set offset here
  txa                     ;transfer original enemy buffer offset
  ora #%10000000          ;store with d7 set as flag in new enemy
  sta Enemy_Flag,y        ;slot as well as enemy offset
  lda Enemy_PageLoc,x
  sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
  lda Enemy_X_Position,x  ;from original enemy to new enemy
  sta Enemy_X_Position,y
  lda #$01
  sta Enemy_Flag,x        ;set flag as normal for original enemy
  sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
  lda Enemy_Y_Position,x
  sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
  // Block: FlmEx
  FlmEx:  rts                     ;and then leave

def RemBridge():
  // Block: RemBridge
  RemBridge:  lda BlockGfxData,x    ;write top left and top right
  sta VRAM_Buffer1+2,y  ;tile numbers into first spot
  lda BlockGfxData+1,x
  sta VRAM_Buffer1+3,y
  lda BlockGfxData+2,x  ;write bottom left and bottom
  sta VRAM_Buffer1+7,y  ;right tiles numbers into
  lda BlockGfxData+3,x  ;second spot
  sta VRAM_Buffer1+8,y
  lda $04
  sta VRAM_Buffer1,y    ;write low byte of name table
  clc                   ;into first slot as read
  adc #$20              ;add 32 bytes to value
  sta VRAM_Buffer1+5,y  ;write low byte of name table
  lda $05               ;plus 32 bytes into second slot
  sta VRAM_Buffer1-1,y  ;write high byte of name
  sta VRAM_Buffer1+4,y  ;table address to both slots
  lda #$02
  sta VRAM_Buffer1+1,y  ;put length of 2 in
  sta VRAM_Buffer1+6,y  ;both slots
  lda #$00
  sta VRAM_Buffer1+9,y  ;put null terminator at end
  ldx $00               ;get offset control bit here
  rts                   ;and leave

def SetupPlatformRope():
  pha                     ;save second/third copy to stack
  lda Enemy_X_Position,y  ;get horizontal coordinate
  clc
  adc #$08                ;add eight pixels
  ldx SecondaryHardMode   ;if secondary hard mode flag set,
  if (!BNE GetLRp) {  // from SetupPlatformRope
    clc
    adc #$10                ;otherwise add sixteen more pixels
  }
  GetLRp: pha                     ;save modified horizontal coordinate to stack
  lda Enemy_PageLoc,y
  adc #$00                ;add carry to page location
  sta $02                 ;and save here
  pla                     ;pull modified horizontal coordinate
  and #%11110000          ;from the stack, mask out low nybble
  lsr                     ;and shift three bits to the right
  lsr
  lsr
  sta $00                 ;store result here as part of name table low byte
  ldx Enemy_Y_Position,y  ;get vertical coordinate
  pla                     ;get second/third copy of vertical speed from stack
  if (!BPL GetHRp) {  // from GetLRp
    txa
    clc
    adc #$08                ;add eight to vertical coordinate and
    tax                     ;save as X
  }
  GetHRp: txa                     ;move vertical coordinate to A
  ldx VRAM_Buffer1_Offset ;get vram buffer offset
  asl
  rol                     ;rotate d7 to d0 and d6 into carry
  pha                     ;save modified vertical coordinate to stack
  rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
  and #%00000011          ;mask out all bits but d7 and d6, then set
  ora #%00100000          ;d5 to get appropriate high byte of name table
  sta $01                 ;address, then store
  lda $02                 ;get saved page location from earlier
  and #$01                ;mask out all but LSB
  asl
  asl                     ;shift twice to the left and save with the
  ora $01                 ;rest of the bits of the high byte, to get
  sta $01                 ;the proper name table and the right place on it
  pla                     ;get modified vertical coordinate from stack
  and #%11100000          ;mask out low nybble and LSB of high nybble
  clc
  adc $00                 ;add to horizontal part saved here
  sta $00                 ;save as name table low byte
  lda Enemy_Y_Position,y
  cmp #$e8                ;if vertical position not below the
  if (!BCC ExPRp) {  // from GetHRp
    lda $00
    and #%10111111          ;mask out d6 of low byte of name table address
    sta $00
  }
  // Block: ExPRp
  ExPRp:  rts                     ;leave!

def RelativeFireballPosition():
  // Block: RelativeFireballPosition
  ldy #$00                    ;set for fireball offsets
  jsr GetProperObjOffset      ;modify X to get proper fireball offset
  ldy #$02

def MoveEnemyHorizontally():
  // Block: MoveEnemyHorizontally
  inx                         ;increment offset for enemy offset
  jsr MoveObjectHorizontally  ;position object horizontally according to
  ldx ObjectOffset            ;counters, return with saved value in A,
  rts                         ;put enemy offset back in X and leave

def GetAreaObjYPosition():
  // Block: GetAreaObjYPosition
  lda $07  ;multiply value by 16
  asl
  asl      ;this will give us the proper vertical pixel coordinate
  asl
  asl
  clc
  adc #32  ;add 32 pixels for the status bar
  rts

def WriteGameText():
  pha                      ;save text number to stack
  asl
  tay                      ;multiply by 2 and use as offset
  cpy #$04                 ;if set to do top status bar or world/lives display,
  if (!BCC LdGameText) {  // from WriteGameText
    cpy #$08                 ;if set to do time-up or game over,
    if (!BCC Chk2Players) {  // from @1699
      ldy #$08                 ;otherwise warp zone, therefore set offset
    }
    Chk2Players:   lda NumberOfPlayers      ;check for number of players
    if (!BNE LdGameText) {  // from Chk2Players
      iny                      ;otherwise increment offset by one to not print name
    }
  }
  // Block: LdGameText
  LdGameText:    ldx GameTextOffsets,y    ;get offset to message we want to print
  ldy #$00
  sta VRAM_Buffer1,y       ;otherwise write data to buffer
  inx                      ;and increment increment
  iny
  while (!BNE GameTextLoop) {  // loop9
    do {  // loop8
      // Block: GameTextLoop
      GameTextLoop:  lda GameText,x           ;load message data
      cmp #$ff                 ;check for terminator
      beq EndGameText          ;branch to end text if found
    } while (BNE GameTextLoop)
  }
  EndGameText:   lda #$00                 ;put null terminator at end
  sta VRAM_Buffer1,y
  pla                      ;pull original text number from stack
  tax
  cmp #$04                 ;are we printing warp zone?
  if (!BCS PrintWarpZoneNumbers) {  // from EndGameText
    dex                      ;are we printing the world/lives display?
    if (!BNE CheckPlayerName) {  // from @1720
      lda NumberofLives        ;otherwise, check number of lives
      clc                      ;and increment by one for display
      adc #$01
      cmp #10                  ;more than 9 lives?
      if (!BCC PutLives) {  // from @1722
        sbc #10                  ;if so, subtract 10 and put a crown tile
        ldy #$9f                 ;next to the difference...strange things happen if
        sty VRAM_Buffer1+7       ;the number of lives exceeds 19
      }
      // Block: PutLives
      PutLives:      sta VRAM_Buffer1+8
      ldy WorldNumber          ;write world and level numbers (incremented for display)
      iny                      ;to the buffer in the spaces surrounding the dash
      sty VRAM_Buffer1+19
      ldy LevelNumber
      iny
      sty VRAM_Buffer1+21      ;we're done here
      rts
    }
    lda NumberOfPlayers    ;check number of players
    if (!BEQ ExitChkName) {  // from CheckPlayerName
      lda CurrentPlayer      ;load current player
      dex                    ;check to see if current message number is for time up
      if (!BNE ChkLuigi) {  // from @1742
        ldy OperMode           ;check for game over mode
        cpy #GameOverModeValue
        if (!BEQ ChkLuigi) {  // from @1745
          eor #%00000001         ;if not, must be time up, invert d0 to do other player
        }
      }
      ChkLuigi:    lsr
      if (!BCC ExitChkName) {  // from ChkLuigi
        ldy #$04
        do {  // loop19
          // Block: NameLoop
          NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
          sta VRAM_Buffer1+3,y
          dey
          bpl NameLoop           ;do this until each letter is replaced
        } while (!BPL NameLoop)
      }
    }
    // Block: ExitChkName
    ExitChkName: rts
  }
  // Block: PrintWarpZoneNumbers
  sbc #$04               ;subtract 4 and then shift to the left
  asl                    ;twice to get proper warp zone number
  asl                    ;offset
  tax
  ldy #$00
  do {  // loop26
    // Block: WarpNumLoop
    WarpNumLoop: lda WarpZoneNumbers,x  ;print warp zone numbers into the
    sta VRAM_Buffer1+27,y  ;placeholders from earlier
    inx
    iny                    ;put a number in every fourth space
    iny
    iny
    iny
    cpy #$0c
    bcc WarpNumLoop
  } while (!BCC WarpNumLoop)
  lda #$2c               ;load new buffer pointer at end of message
  jmp SetVRAMOffset

def StopPlatforms():
  // Block: StopPlatforms
  jsr InitVStf             ;initialize vertical speed and low byte
  sta Enemy_Y_Speed,y      ;for both platforms and leave
  sta Enemy_Y_MoveForce,y
  rts

def Setup_Vine():
  lda #VineObject          ;load identifier for vine object
  sta Enemy_ID,x           ;store in buffer
  lda #$01
  sta Enemy_Flag,x         ;set flag for enemy object buffer
  lda Block_PageLoc,y
  sta Enemy_PageLoc,x      ;copy page location from previous object
  lda Block_X_Position,y
  sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
  lda Block_Y_Position,y
  sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
  ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
  if (!BNE NextVO) {  // from Setup_Vine
    sta VineStart_Y_Position ;otherwise store vertical coordinate here
  }
  // Block: NextVO
  NextVO: txa                      ;store object offset to next available vine slot
  sta VineObjOffset,y      ;using vine flag as offset
  inc VineFlagOffset       ;increment vine flag offset
  lda #Sfx_GrowVine
  sta Square2SoundQueue    ;load vine grow sound
  rts

def ProcBowserFlame():
  lda TimerControl            ;if master timer control flag set,
  if (!BNE SetGfxF) {  // from ProcBowserFlame
    lda #$40                    ;load default movement force
    ldy SecondaryHardMode
    if (!BEQ SFlmX) {  // from @10326
      lda #$60                    ;otherwise load alternate movement force to go faster
    }
    SFlmX:   sta $00                     ;store value here
    lda Enemy_X_MoveForce,x
    sec                         ;subtract value from movement force
    sbc $00
    sta Enemy_X_MoveForce,x     ;save new value
    lda Enemy_X_Position,x
    sbc #$01                    ;subtract one from horizontal position to move
    sta Enemy_X_Position,x      ;to the left
    lda Enemy_PageLoc,x
    sbc #$00                    ;subtract borrow from page location
    sta Enemy_PageLoc,x
    ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
    lda Enemy_Y_Position,x      ;load vertical coordinate
    cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
    if (!BEQ SetGfxF) {  // from SFlmX
      clc
      adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
      sta Enemy_Y_Position,x      ;as new vertical coordinate
    }
  }
  // Block: SetGfxF
  SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
  lda Enemy_State,x           ;if bowser's flame not in normal state,
  bne ExFl                    ;branch to leave
  lda #$51                    ;otherwise, continue
  sta $00                     ;write first tile number
  ldy #$02                    ;load attributes without vertical flip by default
  lda FrameCounter
  and #%00000010              ;invert vertical flip bit every 2 frames
  if (!BEQ FlmeAt) {  // from @10351
    ldy #$82                    ;otherwise write value with vertical flip bit set
  }
  // Block: FlmeAt
  FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
  ldy Enemy_SprDataOffset,x   ;get OAM data offset
  ldx #$00
  do {  // loop10
    // Block: DrawFlameLoop
    lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
    sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
    lda $00
    sta Sprite_Tilenumber,y    ;write current tile number into OAM data
    inc $00                    ;increment tile number to draw more bowser's flame
    lda $01
    sta Sprite_Attributes,y    ;write saved attributes into OAM data
    lda Enemy_Rel_XPos
    sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
    clc
    adc #$08
    sta Enemy_Rel_XPos         ;then add eight to it and store
    iny
    iny
    iny
    iny                        ;increment Y four times to move onto the next OAM
    inx                        ;move onto the next OAM, and branch if three
    cpx #$03                   ;have not yet been done
    bcc DrawFlameLoop
  } while (!BCC DrawFlameLoop)
  ldx ObjectOffset           ;reload original enemy offset
  jsr GetEnemyOffscreenBits  ;get offscreen information
  ldy Enemy_SprDataOffset,x  ;get OAM data offset
  lda Enemy_OffscreenBits    ;get enemy object offscreen bits
  lsr                        ;move d0 to carry and result to stack
  pha
  if (!BCC M3FOfs) {  // from @10382
    lda #$f8                   ;otherwise move sprite offscreen, this part likely
    sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
  }
  M3FOfs:  pla                        ;get bits from stack
  lsr                        ;move d1 to carry and move bits back to stack
  pha
  if (!BCC M2FOfs) {  // from M3FOfs
    lda #$f8                   ;otherwise move third sprite offscreen
    sta Sprite_Y_Position+8,y
  }
  M2FOfs:  pla                        ;get bits from stack again
  lsr                        ;move d2 to carry and move bits back to stack again
  pha
  if (!BCC M1FOfs) {  // from M2FOfs
    lda #$f8                   ;otherwise move second sprite offscreen
    sta Sprite_Y_Position+4,y
  }
  M1FOfs:  pla                        ;get bits from stack one last time
  lsr                        ;move d3 to carry
  if (!BCC ExFlmeD) {  // from M1FOfs
    lda #$f8
    sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
  }
  // Block: ExFlmeD
  ExFlmeD: rts                        ;leave

def DumpFourSpr():
  // Block: DumpFourSpr
  sta Sprite_Data+12,y      ;into second row sprites

def WriteNTAddr():
  // Block: WriteNTAddr
  WriteNTAddr:  sta PPU_ADDRESS
  lda #$00
  sta PPU_ADDRESS
  ldx #$04                  ;clear name table with blank tile #24
  ldy #$c0
  lda #$24
  InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
  dey
  while (!BNE InitNTLoop) {  // loop4
    do {  // loop3
      dex
      bne InitNTLoop
    } while (BNE InitNTLoop)
  }
  ldy #64                   ;now to clear the attribute table (with zero this time)
  txa
  sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
  sta VRAM_Buffer1          ;init vram buffer 1
  do {  // loop7
    // Block: InitATLoop
    InitATLoop:   sta PPU_DATA
    dey
    bne InitATLoop
  } while (!BNE InitATLoop)
  sta HorizontalScroll      ;reset scroll variables
  sta VerticalScroll
  jmp InitScroll            ;initialize scroll registers to zero

def AlternateLengthHandler():
  // Block: AlternateLengthHandler
  tax            ;save a copy of original byte into X
  ror            ;save LSB from original byte into carry
  txa            ;reload original byte and rotate three times
  rol            ;turning xx00000x into 00000xxx, with the
  rol            ;bit in carry as the MSB here
  rol

def MoveLiftPlatforms():
  // Block: MoveLiftPlatforms
  lda TimerControl         ;if master timer control set, skip all of this
  bne ExLiftP              ;and branch to leave
  lda Enemy_YMF_Dummy,x
  clc                      ;add contents of movement amount to whatever's here
  adc Enemy_Y_MoveForce,x
  sta Enemy_YMF_Dummy,x
  lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
  adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
  sta Enemy_Y_Position,x   ;and then leave
  rts

def DividePDiff():
  sta $05       ;store current value in A here
  lda $07       ;get pixel difference
  cmp $06       ;compare to preset value
  if (!BCS ExDivPD) {  // from DividePDiff
    lsr           ;divide by eight
    lsr
    lsr
    and #$07      ;mask out all but 3 LSB
    cpy #$01      ;right side of the screen or top?
    if (!BCS SetOscrO) {  // from @14982
      adc $05       ;if not, add value to difference / 8
    }
    // Block: SetOscrO
    SetOscrO: tax           ;use as offset
  }
  // Block: ExDivPD
  ExDivPD:  rts           ;leave

def ForceInjury():
  ldx PlayerStatus          ;check player's status
  if (!BEQ KillPlayer) {  // from ForceInjury
    sta PlayerStatus          ;otherwise set player's status to small
    lda #$08
    sta InjuryTimer           ;set injured invincibility timer
    asl
    sta Square1SoundQueue     ;play pipedown/injury sound
    jsr GetPlayerColors       ;change player's palette if necessary
    lda #$0a                  ;set subroutine to run on next frame
    // Block: SetKRout
    SetKRout: ldy #$01                  ;set new player state
  }
  do {  // loop5
    // Block: KillPlayer
    stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
    inx
    stx EventMusicQueue  ;set event music queue to death music
    lda #$fc
    sta Player_Y_Speed   ;set new vertical speed
    lda #$0b             ;set subroutine to run on next frame
    bne SetKRout         ;branch to set player's state and other things
  } while (BNE SetKRout)
  // Block: StompedEnemyPtsData

def SpawnHammerObj():
  lda PseudoRandomBitReg+1 ;get pseudorandom bits from
  and #%00000111           ;second part of LSFR
  if (!BNE SetMOfs) {  // from SpawnHammerObj
    lda PseudoRandomBitReg+1
    and #%00001000           ;get d3 from same part of LSFR
  }
  SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
  lda Misc_State,y         ;if any values loaded in
  if (!BNE NoHammer) {  // from SetMOfs
    ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
    lda Enemy_Flag,x         ;check enemy buffer flag at offset
    if (!BNE NoHammer) {  // from @6881
      ldx ObjectOffset         ;get original enemy object offset
      txa
      sta HammerEnemyOffset,y  ;save here
      lda #$90
      sta Misc_State,y         ;save hammer's state here
      lda #$07
      sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
      sec                      ;return with carry set
      rts
    }
  }
  // Block: NoHammer
  NoHammer: ldx ObjectOffset         ;get original enemy object offset
  clc                      ;return with carry clear
  rts

def DoNothing2():
  // Block: DoNothing2
  rts

def SetEntr():
  // Block: SetEntr
  SetEntr:   lda #$02               ;set starting position to override
  sta AltEntranceControl
  jmp ChgAreaMode        ;set modes

def CheckForSolidMTiles():
  // Block: CheckForSolidMTiles
  jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
  cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
  rts

def GetPipeHeight():
  // Block: GetPipeHeight
  ldy #$01       ;check for length loaded, if not, load
  jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
  jsr GetLrgObjAttrib
  tya            ;get saved lower nybble as height
  and #$07       ;save only the three lower bits as
  sta $06        ;vertical length, then load Y with
  ldy AreaObjectLength,x    ;length left over
  rts

def ImposeGravity():
  pha                          ;push value to stack
  lda SprObject_YMF_Dummy,x
  clc                          ;add value in movement force to contents of dummy variable
  adc SprObject_Y_MoveForce,x
  sta SprObject_YMF_Dummy,x
  ldy #$00                     ;set Y to zero by default
  lda SprObject_Y_Speed,x      ;get current vertical speed
  if (!BPL AlterYP) {  // from ImposeGravity
    dey                          ;otherwise decrement Y
  }
  AlterYP: sty $07                      ;store Y here
  adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
  sta SprObject_Y_Position,x   ;store as new vertical position
  lda SprObject_Y_HighPos,x
  adc $07                      ;add carry plus contents of $07 to vertical high byte
  sta SprObject_Y_HighPos,x    ;store as new vertical high byte
  lda SprObject_Y_MoveForce,x
  clc
  adc $00                      ;add downward movement amount to contents of $0433
  sta SprObject_Y_MoveForce,x
  lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
  adc #$00
  sta SprObject_Y_Speed,x
  cmp $02                      ;compare to maximum speed
  if (!BMI ChkUpM) {  // from AlterYP
    lda SprObject_Y_MoveForce,x
    cmp #$80                     ;if less positively than preset maximum, skip this part
    if (!BCC ChkUpM) {  // from @7728
      lda $02
      sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
      lda #$00
      sta SprObject_Y_MoveForce,x  ;clear fractional
    }
  }
  ChkUpM:  pla                          ;get value from stack
  if (!BEQ ExVMove) {  // from ChkUpM
    lda $02
    eor #%11111111               ;otherwise get two's compliment of maximum speed
    tay
    iny
    sty $07                      ;store two's compliment here
    lda SprObject_Y_MoveForce,x
    sec                          ;subtract upward movement amount from contents
    sbc $01                      ;of movement force, note that $01 is twice as large as $00,
    sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
    lda SprObject_Y_Speed,x
    sbc #$00                     ;subtract borrow from vertical speed and store
    sta SprObject_Y_Speed,x
    cmp $07                      ;compare vertical speed to two's compliment
    if (!BPL ExVMove) {  // from @7737
      lda SprObject_Y_MoveForce,x
      cmp #$80                     ;check if fractional part is above certain amount,
      if (!BCS ExVMove) {  // from @7751
        lda $07
        sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
        lda #$ff
        sta SprObject_Y_MoveForce,x  ;clear fractional
      }
    }
  }
  // Block: ExVMove
  ExVMove: rts                          ;leave!

def MoveWithXMCntrs():
  lda XMoveSecondaryCounter,x  ;save secondary counter to stack
  pha
  ldy #$01                     ;set value here by default
  lda XMovePrimaryCounter,x
  and #%00000010               ;if d1 of primary counter is
  if (!BNE XMRight) {  // from MoveWithXMCntrs
    lda XMoveSecondaryCounter,x
    eor #$ff                     ;otherwise change secondary
    clc                          ;counter to two's compliment
    adc #$01
    sta XMoveSecondaryCounter,x
    ldy #$02                     ;load alternate value here
  }
  // Block: XMRight
  XMRight: sty Enemy_MovingDir,x        ;store as moving direction
  jsr MoveEnemyHorizontally
  sta $00                      ;save value obtained from sub here
  pla                          ;get secondary counter from stack
  sta XMoveSecondaryCounter,x  ;and return to original place
  rts

def ProcHammerObj():
  lda TimerControl           ;if master timer control set
  if (!BNE RunHSubs) {  // from ProcHammerObj
    lda Misc_State,x           ;otherwise get hammer's state
    and #%01111111             ;mask out d7
    ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
    cmp #$02                   ;check hammer's state
    if (!BEQ SetHSpd) {  // from @6905
      if (!BCS SetHPos) {  // from @6910
        txa
        clc                        ;add 13 bytes to use
        adc #$0d                   ;proper misc object
        tax                        ;return offset to X
        lda #$10
        sta $00                    ;set downward movement force
        lda #$0f
        sta $01                    ;set upward movement force (not used)
        lda #$04
        sta $02                    ;set maximum vertical speed
        lda #$00                   ;set A to impose gravity on hammer
        jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
        jsr MoveObjectHorizontally ;do sub to move it horizontally
        ldx ObjectOffset           ;get original misc object offset
        jmp RunAllH                ;branch to essential subroutines
        // Block: SetHSpd
        SetHSpd:  lda #$fe
        sta Misc_Y_Speed,x         ;set hammer's vertical speed
        lda Enemy_State,y          ;get enemy object state
        and #%11110111             ;mask out d3
        sta Enemy_State,y          ;store new state
        ldx Enemy_MovingDir,y      ;get enemy's moving direction
        dex                        ;decrement to use as offset
        lda HammerXSpdData,x       ;get proper speed to use based on moving direction
        ldx ObjectOffset           ;reobtain hammer's buffer offset
        sta Misc_X_Speed,x         ;set hammer's horizontal speed
      }
    } else {
      SetHPos:  dec Misc_State,x           ;decrement hammer's state
      lda Enemy_X_Position,y     ;get enemy's horizontal position
      clc
      adc #$02                   ;set position 2 pixels to the right
      sta Misc_X_Position,x      ;store as hammer's horizontal position
      lda Enemy_PageLoc,y        ;get enemy's page location
      adc #$00                   ;add carry
      sta Misc_PageLoc,x         ;store as hammer's page location
      lda Enemy_Y_Position,y     ;get enemy's vertical position
      sec
      sbc #$0a                   ;move position 10 pixels upward
      sta Misc_Y_Position,x      ;store as hammer's vertical position
      lda #$01
      sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
      if (!BNE RunHSubs) {  // from SetHPos
        // Block: RunAllH
        RunAllH:  jsr PlayerHammerCollision  ;handle collisions
      }
    }
  }
  // Block: RunHSubs
  RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
  jsr RelativeMiscPosition   ;get relative coordinates
  jsr GetMiscBoundBox        ;get bounding box coordinates
  jsr DrawHammer             ;draw the hammer
  rts                        ;and we are done here

def LoadAreaPointer():
  // Block: LoadAreaPointer
  jsr FindAreaPointer  ;find it and store it here
  sta AreaPointer

def PlayerMovementSubs():
  lda #$00                  ;set A to init crouch flag by default
  ldy PlayerSize            ;is player small?
  if (!BNE SetCrouch) {  // from PlayerMovementSubs
    lda Player_State          ;check state of player
    if (!BNE ProcMove) {  // from @5877
      lda Up_Down_Buttons       ;load controller bits for up and down
      and #%00000100            ;single out bit for down button
      // Block: SetCrouch
      SetCrouch: sta CrouchingFlag         ;store value in crouch flag
    }
  }
  ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
  lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
  if (!BNE NoMoveSub) {  // from ProcMove
    lda Player_State
    cmp #$03                  ;get player state
    if (!BEQ MoveSubs) {  // from @5885
      ldy #$18
      sty ClimbSideTimer        ;otherwise reset timer now
    }
    // Block: MoveSubs
    MoveSubs:  jsr JumpEngine
  }
  // Block: NoMoveSub
  NoMoveSub: rts

def PlaySqu2Sfx():
  // Block: PlaySqu2Sfx
  jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs

def SpriteShuffler():
  // Block: SpriteShuffler
  ldy AreaType                ;load level type, likely residual code
  lda #$28                    ;load preset value which will put it at
  sta $00                     ;sprite #10
  ldx #$0e                    ;start at the end of OAM data offsets
  NextSprOffset: dex                         ;move backwards to next one
  while (!BPL ShuffleLoop) {  // loop10
    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
    clc
    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
    if (!BCC StrSprOffset) {  // from @894
      clc
      adc $00                     ;otherwise add preset value $28 to offset
    }
    // Block: StrSprOffset
    StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
    do {  // loop9
      // Block: ShuffleLoop
      ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
      cmp $00                     ;the preset value
      bcc NextSprOffset           ;if less, skip this part
    } while (BPL ShuffleLoop)
  }
  ldx SprShuffleAmtOffset     ;load offset
  inx
  cpx #$03                    ;check if offset + 1 goes to 3
  if (!BNE SetAmtOffset) {  // from @903
    ldx #$00                    ;otherwise, init to 0
  }
  // Block: SetAmtOffset
  SetAmtOffset:  stx SprShuffleAmtOffset
  ldx #$08                    ;load offsets for values and storage
  ldy #$02
  do {  // loop15
    // Block: SetMiscOffset
    SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
    clc                         ;add eight to the second and eight
    adc #$08                    ;more to the third one
    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
    clc                         ;this code loads into the misc sprite offsets
    adc #$08
    sta Misc_SprDataOffset,x
    dex
    dex
    dex
    dey
    bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
  } while (!BPL SetMiscOffset)
  rts

def GameCoreRoutine():
  ldx CurrentPlayer          ;get which player is on the screen
  lda SavedJoypadBits,x      ;use appropriate player's controller bits
  sta SavedJoypadBits        ;as the master controller bits
  jsr GameRoutines           ;execute one of many possible subs
  lda OperMode_Task          ;check major task of operating mode
  cmp #$03                   ;if we are supposed to be here,
  if (!BCS GameEngine) {  // from GameCoreRoutine
    rts
  }
  // Block: GameEngine
  jsr ProcFireball_Bubble    ;process fireballs and air bubbles
  ldx #$00
  do {  // loop4
    // Block: ProcELoop
    ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
    jsr EnemiesAndLoopsCore    ;process enemy objects
    jsr FloateyNumbersRoutine  ;process floatey numbers
    inx
    cpx #$06                   ;do these two subroutines until the whole buffer is done
    bne ProcELoop
  } while (!BNE ProcELoop)
  jsr GetPlayerOffscreenBits ;get offscreen bits for player object
  jsr RelativePlayerPosition ;get relative coordinates for player object
  jsr PlayerGfxHandler       ;draw the player
  jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
  ldx #$01
  stx ObjectOffset           ;set offset for second
  jsr BlockObjectsCore       ;process second block object
  dex
  stx ObjectOffset           ;set offset for first
  jsr BlockObjectsCore       ;process first block object
  jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
  jsr ProcessCannons         ;process bullet bill cannons
  jsr ProcessWhirlpools      ;process whirlpools
  jsr FlagpoleRoutine        ;process the flagpole
  jsr RunGameTimer           ;count down the game timer
  jsr ColorRotation          ;cycle one of the background colors
  lda Player_Y_HighPos
  cmp #$02                   ;if player is below the screen, don't bother with the music
  if (!BPL NoChgMus) {  // from @5319
    lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
    if (!BEQ ClrPlrPal) {  // from @5338
      cmp #$04
      if (!BNE NoChgMus) {  // from @5340
        lda IntervalTimerControl   ;if interval timer not yet expired,
        if (!BNE NoChgMus) {  // from @5342
          jsr GetAreaMusic           ;to re-attain appropriate level music
        }
      }
      NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
      lda FrameCounter           ;get frame counter
      cpy #$08                   ;if timer still above certain point,
      if (!BCS CycleTwo) {  // from NoChgMus
        lsr                        ;otherwise, divide by 8 to cycle every eighth frame
        lsr
      }
      // Block: CycleTwo
      CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
      jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
      jmp SaveAB                 ;then skip this sub to finish up the game engine
    }
  }
  NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
  lda FrameCounter           ;get frame counter
  cpy #$08                   ;if timer still above certain point,
  if (!BCS CycleTwo) {  // from NoChgMus
  }
  // Block: ClrPlrPal
  ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
  // Block: SaveAB
  SaveAB:       lda A_B_Buttons            ;save current A and B button
  sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
  lda #$00
  sta Left_Right_Buttons     ;nullify left and right buttons temp variable

def ProcEnemyCollisions():
  lda Enemy_State,y        ;check both enemy states for d5 set
  ora Enemy_State,x
  and #%00100000           ;if d5 is set in either state, or both, branch
  if (!BNE ExitProcessEColl) {  // from ProcEnemyCollisions
    lda Enemy_State,x
    cmp #$06                 ;if second enemy state < $06, branch elsewhere
    if (!BCC ProcSecondEnemyColl) {  // from @11627
      lda Enemy_ID,x           ;check second enemy identifier for hammer bro
      cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
      if (!BEQ ExitProcessEColl) {  // from @11630
        lda Enemy_State,y        ;check first enemy state for d7 set
        asl
        if (!BCC ShellCollisions) {  // from @11633
          lda #$06
          jsr SetupFloateyNumber   ;award 1000 points for killing enemy
          jsr ShellOrBlockDefeat   ;then kill enemy, then load
          ldy $01                  ;original offset of second enemy
        }
        // Block: ShellCollisions
        tya                      ;move Y to X
        tax
        jsr ShellOrBlockDefeat   ;kill second enemy
        ldx ObjectOffset
        lda ShellChainCounter,x  ;get chain counter for shell
        clc
        adc #$04                 ;add four to get appropriate point offset
        ldx $01
        jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
        ldx ObjectOffset         ;load original offset of first enemy
        inc ShellChainCounter,x  ;increment chain counter for additional enemies
      }
      // Block: ExitProcessEColl
      rts                      ;leave!!!
    }
  }
  lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
  cmp #$06
  if (!BCC MoveEOfs) {  // from ProcSecondEnemyColl
    do {  // loop11
      lda Enemy_ID,y           ;check first enemy identifier for hammer bro
      cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
      beq ExitProcessEColl
    } while (BEQ ExitProcessEColl)
    jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
    ldy $01
    lda ShellChainCounter,y  ;get chain counter for shell
    clc
    adc #$04                 ;add four to get appropriate point offset
    ldx ObjectOffset
    jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
    ldx $01                  ;load original offset of second enemy
    inc ShellChainCounter,x  ;increment chain counter for additional enemies
    rts                      ;leave!!!
  }
  // Block: MoveEOfs
  tya                      ;move Y ($01) to X
  tax
  jsr EnemyTurnAround      ;do the sub here using value from $01
  ldx ObjectOffset         ;then do it again using value from $08

def PlatLiftDown():
  // Block: PlatLiftDown
  lda #$f0                 ;set movement amount here
  sta Enemy_Y_MoveForce,x
  lda #$00                 ;set moving speed for platforms going down
  sta Enemy_Y_Speed,x

def StopSquare1Sfx():
  // Block: StopSquare1Sfx
  ldx #$00                ;if end of sfx reached, clear buffer
  stx $f1                 ;and stop making the sfx
  ldx #$0e
  stx SND_MASTERCTRL_REG
  ldx #$0f
  stx SND_MASTERCTRL_REG

def PlaySqu1Sfx():
  // Block: PlaySqu1Sfx
  jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs

def SetupFloateyNumber():
  // Block: SetupFloateyNumber
  sta FloateyNum_Control,x ;set number of points control for floatey numbers
  lda #$30
  sta FloateyNum_Timer,x   ;set timer for floatey numbers
  lda Enemy_Y_Position,x
  sta FloateyNum_Y_Pos,x   ;set vertical coordinate
  lda Enemy_Rel_XPos
  sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave

def InitPodoboo():
  // Block: InitPodoboo
  lda #$02                  ;set enemy position to below
  sta Enemy_Y_HighPos,x     ;the bottom of the screen
  sta Enemy_Y_Position,x
  lsr
  sta EnemyIntervalTimer,x  ;set timer for enemy
  lsr
  sta Enemy_State,x         ;initialize enemy state, then jump to use
  jmp SmallBBox             ;$09 as bounding box size and set other things

def ChkForNonSolids():
  cmp #$26       ;blank metatile used for vines?
  if (!BEQ NSFnd) {  // from ChkForNonSolids
    cmp #$c2       ;regular coin?
    if (!BEQ NSFnd) {  // from @12714
      cmp #$c3       ;underwater coin?
      if (!BEQ NSFnd) {  // from @12716
        cmp #$5f       ;hidden coin block?
        if (!BEQ NSFnd) {  // from @12718
          cmp #$60       ;hidden 1-up block?
        }
      }
    }
  }
  // Block: NSFnd
  NSFnd: rts

def PlayerHeadCollision():
  pha                      ;store metatile number to stack
  lda #$11                 ;load unbreakable block object state by default
  ldx SprDataOffset_Ctrl   ;load offset control bit here
  ldy PlayerSize           ;check player's size
  if (!BNE DBlockSte) {  // from PlayerHeadCollision
    lda #$12                 ;otherwise load breakable block object state
  }
  DBlockSte: sta Block_State,x        ;store into block object buffer
  jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
  ldx SprDataOffset_Ctrl   ;load offset control bit
  lda $02                  ;get vertical high nybble offset used in block buffer routine
  sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
  tay
  lda $06                  ;get low byte of block buffer address used in same routine
  sta Block_BBuf_Low,x     ;save as offset here to be used later
  lda ($06),y              ;get contents of block buffer at old address at $06, $07
  jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
  sta $00                  ;store metatile here
  ldy PlayerSize           ;check player's size
  if (!BNE ChkBrick) {  // from DBlockSte
    tya                      ;otherwise init A (note: big = 0)
  }
  if (!BCC PutMTileB) {  // from ChkBrick
    ldy #$11                 ;otherwise load unbreakable state into block object buffer
    sty Block_State,x        ;note this applies to both player sizes
    lda #$c4                 ;load empty block metatile into A for now
    ldy $00                  ;get metatile from before
    cpy #$58                 ;is it brick with coins (with line)?
    if (!BEQ StartBTmr) {  // from @7240
      cpy #$5d                 ;is it brick with coins (without line)?
      if (!BNE PutMTileB) {  // from @7246
        StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
        if (!BNE ContBTmr) {  // from StartBTmr
          lda #$0b
          sta BrickCoinTimer       ;if not set, set brick coin timer
          inc BrickCoinTimerFlag   ;and set flag linked to it
        }
        ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
        if (!BNE PutOldMT) {  // from ContBTmr
          ldy #$c4                 ;otherwise use empty block metatile
        }
        // Block: PutOldMT
        PutOldMT:  tya                      ;put metatile into A
      }
    }
    if (!BNE ContBTmr) {  // from StartBTmr
    }
    if (!BNE PutOldMT) {  // from ContBTmr
    }
  }
  PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
  jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
  ldy $02                  ;get vertical high nybble offset
  lda #$23
  sta ($06),y              ;write blank metatile $23 to block buffer
  lda #$10
  sta BlockBounceTimer     ;set block bounce timer
  pla                      ;pull original metatile from stack
  sta $05                  ;and save here
  ldy #$00                 ;set default offset
  lda CrouchingFlag        ;is player crouching?
  if (!BNE SmallBP) {  // from PutMTileB
    lda PlayerSize           ;is player big?
    if (!BEQ BigBP) {  // from @7269
      // Block: SmallBP
      SmallBP:   iny                      ;increment for small or big and crouching
    }
  }
  BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
  clc
  adc BlockYPosAdderData,y ;add value determined by size
  and #$f0                 ;mask out low nybble to get 16-pixel correspondence
  sta Block_Y_Position,x   ;save as vertical coordinate for block object
  ldy Block_State,x        ;get block object state
  cpy #$11
  if (!BEQ Unbreak) {  // from BigBP
    jsr BrickShatter         ;execute code for breakable brick
    jmp InvOBit              ;skip subroutine to do last part of code here
  } else {
    // Block: Unbreak
    Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
  }
  // Block: InvOBit
  InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
  eor #$01                 ;and floatey numbers
  sta SprDataOffset_Ctrl
  rts                      ;leave!

def GetAreaType():
  // Block: GetAreaType
  GetAreaType: and #%01100000       ;mask out all but d6 and d5
  asl
  rol
  rol
  rol                  ;make %0xx00000 into %000000xx
  sta AreaType         ;save 2 MSB as area type
  rts

def MovePlayerYAxis():
  // Block: MovePlayerYAxis
  clc
  adc Player_Y_Position ;add contents of A to player position
  sta Player_Y_Position
  rts

def AutoControlPlayer():
  // Block: AutoControlPlayer
  sta SavedJoypadBits         ;override controller bits with contents of A if executing here
  lda GameEngineSubroutine    ;check task here
  cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
  if (!BEQ SizeChk) {  // from PlayerCtrlRoutine
    lda AreaType                ;are we in a water type area?
    if (!BNE SaveJoyp) {  // from @5561
      ldy Player_Y_HighPos
      dey                         ;if not in vertical area between
      if (!BNE DisJoyp) {  // from @5563
        lda Player_Y_Position
        cmp #$d0                    ;if nearing the bottom of the screen or
        if (!BCC SaveJoyp) {  // from @5566
          // Block: DisJoyp
          DisJoyp:    lda #$00                    ;disable controller bits
          sta SavedJoypadBits
        }
      }
    }
    SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
    and #%11000000
    sta A_B_Buttons
    lda SavedJoypadBits         ;store left and right buttons in $0c
    and #%00000011
    sta Left_Right_Buttons
    lda SavedJoypadBits         ;store up and down buttons in $0b
    and #%00001100
    sta Up_Down_Buttons
    and #%00000100              ;check for pressing down
    if (!BEQ SizeChk) {  // from SaveJoyp
      lda Player_State            ;check player's state
      if (!BNE SizeChk) {  // from @5582
        ldy Left_Right_Buttons      ;check left and right
        if (!BEQ SizeChk) {  // from @5584
          lda #$00
          sta Left_Right_Buttons      ;if pressing down while on the ground,
          sta Up_Down_Buttons         ;nullify directional bits
        }
      }
    }
  }
  SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
  ldy #$01                    ;is player small?
  lda PlayerSize
  if (!BNE ChkMoveDir) {  // from SizeChk
    ldy #$00                    ;check for if crouching
    lda CrouchingFlag
    if (!BEQ ChkMoveDir) {  // from @5593
      ldy #$02                    ;if big and crouching, load y with 2
    }
  }
  ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
  lda #$01                    ;set moving direction to right by default
  ldy Player_X_Speed          ;check player's horizontal speed
  if (!BEQ PlayerSubs) {  // from ChkMoveDir
    if (!BPL SetMoveDir) {  // from @5601
      asl                         ;otherwise change to move to the left
    }
    // Block: SetMoveDir
    SetMoveDir: sta Player_MovingDir        ;set moving direction
  }
  PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
  jsr GetPlayerOffscreenBits  ;get player's offscreen bits
  jsr RelativePlayerPosition  ;get coordinates relative to the screen
  ldx #$00                    ;set offset for player object
  jsr BoundingBoxCore         ;get player's bounding box coordinates
  jsr PlayerBGCollision       ;do collision detection and process
  lda Player_Y_Position
  cmp #$40                    ;check to see if player is higher than 64th pixel
  if (!BCC PlayerHole) {  // from PlayerSubs
    lda GameEngineSubroutine
    cmp #$05                    ;if running end-of-level routine, branch ahead
    if (!BEQ PlayerHole) {  // from @5613
      cmp #$07                    ;if running player entrance routine, branch ahead
      if (!BEQ PlayerHole) {  // from @5616
        cmp #$04                    ;if running routines $00-$03, branch ahead
        if (!BCC PlayerHole) {  // from @5618
          lda Player_SprAttrib
          and #%11011111              ;otherwise nullify player's
          sta Player_SprAttrib        ;background priority flag
        }
      }
    }
  }
  PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
  cmp #$02                    ;for below the screen
  if (!BMI ExitCtrl) {  // from PlayerHole
    ldx #$01
    stx ScrollLock              ;set scroll lock
    ldy #$04
    sty $07                     ;set value here
    ldx #$00                    ;use X as flag, and clear for cloud level
    ldy GameTimerExpiredFlag    ;check game timer expiration flag
    if (!BNE HoleDie) {  // from @5626
      ldy CloudTypeOverride       ;check for cloud type override
      if (!BNE ChkHoleX) {  // from @5633
        HoleDie:    inx                         ;set flag in X for player death
        ldy GameEngineSubroutine
        cpy #$0b                    ;check for some other routine running
        if (!BEQ ChkHoleX) {  // from HoleDie
          ldy DeathMusicLoaded        ;check value here
          if (!BNE HoleBottom) {  // from @5639
            iny
            sty EventMusicQueue         ;otherwise play death music
            sty DeathMusicLoaded        ;and set value here
          }
          // Block: HoleBottom
          HoleBottom: ldy #$06
          sty $07                     ;change value here
        }
      }
    }
    if (!BEQ ChkHoleX) {  // from HoleDie
      if (!BNE HoleBottom) {  // from @5639
      }
    }
    ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
    if (!BMI ExitCtrl) {  // from ChkHoleX
      dex                         ;otherwise decrement flag in X
      if (!BMI CloudExit) {  // from @5648
        ldy EventMusicBuffer        ;check to see if music is still playing
        if (!BNE ExitCtrl) {  // from @5650
          lda #$06                    ;otherwise set to run lose life routine
          sta GameEngineSubroutine    ;on next frame
        }
        // Block: ExitCtrl
        ExitCtrl:   rts                         ;leave
      }
    }
  }
  // Block: CloudExit
  lda #$00
  sta JoypadOverride      ;clear controller override bits if any are set
  jsr SetEntr             ;do sub to set secondary mode
  inc AltEntranceControl  ;set mode of entry to 3
  rts

def ReplaceBlockMetatile():
  // Block: ReplaceBlockMetatile
  jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
  inc Block_ResidualCounter ;increment unused counter (residual code)
  dec Block_RepFlag,x       ;decrement flag (residual code)
  rts                       ;leave

def GetFireballBoundBox():
  // Block: GetFireballBoundBox
  txa         ;add seven bytes to offset
  clc         ;to use in routines as offset for fireball
  adc #$07
  tax
  ldy #$02    ;set offset for relative coordinates
  bne FBallB  ;unconditional branch

def Square2SfxHandler():
  lda #$35             ;load length of coin grab sound
  ldx #$8d             ;and part of reg contents
  if (!BNE CGrab_TTickRegL) {  // from PlayCoinGrab
    // Block: PlayTimerTick
    lda #$06             ;load length of timer tick sound
    ldx #$98             ;and part of reg contents
  }
  // Block: CGrab_TTickRegL
  sta Squ2_SfxLenCounter
  ldy #$7f                ;load the rest of reg contents
  lda #$42                ;of coin grab and timer tick sound
  jsr PlaySqu2Sfx
  lda Squ2_SfxLenCounter  ;check for time to play second tone yet
  cmp #$30                ;timer tick sound also executes this, not sure why
  if (!BNE N2Tone) {  // from ContinueCGrabTTick
    lda #$54                ;if so, load the tone directly into the reg
    sta SND_SQUARE2_REG+2
  }
  if (!BNE DecrementSfx2Length) {  // from N2Tone
    lda #$20                ;load length of fireworks/gunfire sound
    sta Squ2_SfxLenCounter
    ldy #$94                ;load reg contents of fireworks/gunfire sound
    lda #$5e
    if (!BNE SBlasJ) {  // from PlayBlast
      lda Squ2_SfxLenCounter  ;check for time to play second part
      cmp #$18
      if (!BNE DecrementSfx2Length) {  // from ContinueBlast
        ldy #$93                ;load second part reg contents then
        lda #$18
        if (!BNE BlstSJp) {  // from SBlasJ
          // Block: PlayPowerUpGrab
          lda #$36                    ;load length of power-up grab sound
          sta Squ2_SfxLenCounter
          lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
          lsr                         ;divide by 2
          if (!BCS DecrementSfx2Length) {  // from ContinuePowerUpGrab
            tay
            lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
            ldx #$5d                    ;store reg contents of power-up grab sound
            ldy #$7f
            // Block: LoadSqu2Regs
            jsr PlaySqu2Sfx
          }
          dec Squ2_SfxLenCounter   ;decrement length of sfx
          while (!BNE ExSfx2) {  // loop702
            // Block: EmptySfx2Buffer
            ldx #$00                ;initialize square 2's sound effects buffer
            stx Square2SoundBuffer
            lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
            and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
            if (!BNE ContinueExtraLife) {  // from Square2SfxHandler
              ldy Square2SoundQueue  ;check for sfx in queue
              if (!BEQ CheckSfx2Buffer) {  // from @15433
                sty Square2SoundBuffer ;if found, put in buffer and check for the following
                if (!BMI PlayBowserFall) {  // from @15435
                  lsr Square2SoundQueue
                  bcs PlayCoinGrab       ;coin grab
                  lsr Square2SoundQueue
                  if (!BCS PlayGrowPowerUp) {  // from @15439
                    lsr Square2SoundQueue
                    if (!BCS PlayGrowVine) {  // from @15441
                      lsr Square2SoundQueue
                      bcs PlayBlast          ;fireworks/gunfire
                      lsr Square2SoundQueue
                      bcs PlayTimerTick      ;timer tick
                      lsr Square2SoundQueue
                      bcs PlayPowerUpGrab    ;power-up grab
                      lsr Square2SoundQueue
                      if (!BCS PlayExtraLife) {  // from @15449
                        lda Square2SoundBuffer   ;check for sfx in buffer
                        if (!BEQ ExS2H) {  // from CheckSfx2Buffer
                          if (!BMI ContinueBowserFall) {  // from @15455
                            lsr
                            if (!BCS Cont_CGrab_TTick) {  // from @15456
                              lsr
                              if (!BCS ContinueGrowItems) {  // from @15458
                                lsr
                                if (!BCS ContinueGrowItems) {  // from @15460
                                  lsr
                                  bcs ContinueBlast        ;fireworks/gunfire
                                  lsr
                                  if (!BCS Cont_CGrab_TTick) {  // from @15464
                                    lsr
                                    bcs ContinuePowerUpGrab  ;power-up grab
                                    lsr
                                    if (!BCS ContinueExtraLife) {  // from @15468
                                      // Block: ExS2H
                                      ExS2H:  rts
                                      loop {  // loop63 (infinite)
                                        // Block: ContinueCGrabTTick
                                        lda Squ2_SfxLenCounter  ;check for time to play second tone yet
                                        cmp #$30                ;timer tick sound also executes this, not sure why
                                        bne N2Tone
                                        // Block: Cont_CGrab_TTick
                                        jmp ContinueCGrabTTick
                                      }
                                      loop {  // loop90 (infinite)
                                        // Block: JumpToDecLength2
                                        jmp DecrementSfx2Length
                                      }
                                      // Block: PlayBowserFall
                                      lda #$38                ;load length of bowser defeat sound
                                      sta Squ2_SfxLenCounter
                                      ldy #$c4                ;load contents of reg for bowser defeat sound
                                      lda #$18
                                      if (!BNE PBFRegs) {  // from BlstSJp
                                        // Block: ContinueBowserFall
                                        lda Squ2_SfxLenCounter   ;check for almost near the end
                                        cmp #$08
                                        bne DecrementSfx2Length
                                        ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
                                        lda #$5a
                                      }
                                      // Block: PBFRegs
                                      PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
                                      // Block: EL_LRegs
                                      EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
                                      // Block: PlayExtraLife
                                      lda #$30                  ;load length of 1-up sound
                                      sta Squ2_SfxLenCounter
                                    }
                                  }
                                  loop {  // loop141 (infinite)
                                  }
                                  loop {  // loop168 (infinite)
                                  }
                                  if (!BNE PBFRegs) {  // from BlstSJp
                                  }
                                  while (!BNE LoadSqu2Regs) {  // loop190
                                    // Block: ContinueExtraLife
                                    lda Squ2_SfxLenCounter
                                    ldx #$03                  ;load new tones only every eight frames
                                    dex
                                    while (!BNE DivLLoop) {  // loop181
                                      do {  // loop180
                                        // Block: DivLLoop
                                        DivLLoop: lsr
                                        bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
                                      } while (BNE DivLLoop)
                                    }
                                    do {  // loop189
                                      tay
                                      lda ExtraLifeFreqData-1,y ;load our reg contents
                                      ldx #$82
                                      ldy #$7f
                                      bne EL_LRegs              ;unconditional branch
                                    } while (BNE EL_LRegs)
                                  }
                                  lda #$10                ;load length of power-up reveal sound
                                  if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                                    // Block: PlayGrowVine
                                    lda #$20                ;load length of vine grow sound
                                  }
                                  // Block: GrowItemRegs
                                  sta Squ2_SfxLenCounter
                                  lda #$7f                  ;load contents of reg for both sounds directly
                                  sta SND_SQUARE2_REG+1
                                  lda #$00                  ;start secondary counter for both sounds
                                  sta Sfx_SecondaryCounter
                                }
                              }
                            }
                            loop {  // loop238 (infinite)
                            }
                            loop {  // loop265 (infinite)
                            }
                            if (!BNE PBFRegs) {  // from BlstSJp
                            }
                          }
                        }
                        loop {  // loop313 (infinite)
                        }
                        loop {  // loop340 (infinite)
                        }
                        if (!BNE PBFRegs) {  // from BlstSJp
                        }
                      }
                      while (!BNE DivLLoop) {  // loop355
                        do {  // loop354
                        } while (BNE DivLLoop)
                      }
                      do {  // loop363
                      } while (BNE EL_LRegs)
                      if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                      }
                    }
                  }
                }
              }
              if (!BEQ ExS2H) {  // from CheckSfx2Buffer
                if (!BMI ContinueBowserFall) {  // from @15455
                  if (!BCS Cont_CGrab_TTick) {  // from @15456
                    if (!BCS ContinueGrowItems) {  // from @15458
                      if (!BCS ContinueGrowItems) {  // from @15460
                        if (!BCS Cont_CGrab_TTick) {  // from @15464
                          if (!BCS ContinueExtraLife) {  // from @15468
                            loop {  // loop414 (infinite)
                            }
                            loop {  // loop441 (infinite)
                            }
                            if (!BNE PBFRegs) {  // from BlstSJp
                            }
                          }
                        }
                        loop {  // loop492 (infinite)
                        }
                        loop {  // loop519 (infinite)
                        }
                        if (!BNE PBFRegs) {  // from BlstSJp
                        }
                        while (!BNE LoadSqu2Regs) {  // loop541
                          while (!BNE DivLLoop) {  // loop532
                            do {  // loop531
                            } while (BNE DivLLoop)
                          }
                          do {  // loop540
                          } while (BNE EL_LRegs)
                        }
                        if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                        }
                      }
                    }
                  }
                  loop {  // loop589 (infinite)
                  }
                  loop {  // loop616 (infinite)
                  }
                  if (!BNE PBFRegs) {  // from BlstSJp
                  }
                }
              }
              loop {  // loop664 (infinite)
              }
              loop {  // loop691 (infinite)
              }
              if (!BNE PBFRegs) {  // from BlstSJp
              }
            }
          }
        }
      }
    }
    if (!BNE BlstSJp) {  // from SBlasJ
      if (!BCS DecrementSfx2Length) {  // from ContinuePowerUpGrab
      }
      while (!BNE ExSfx2) {  // loop1400
        if (!BNE ContinueExtraLife) {  // from Square2SfxHandler
          if (!BEQ CheckSfx2Buffer) {  // from @15433
            if (!BMI PlayBowserFall) {  // from @15435
              if (!BCS PlayGrowPowerUp) {  // from @15439
                if (!BCS PlayGrowVine) {  // from @15441
                  if (!BCS PlayExtraLife) {  // from @15449
                    if (!BEQ ExS2H) {  // from CheckSfx2Buffer
                      if (!BMI ContinueBowserFall) {  // from @15455
                        if (!BCS Cont_CGrab_TTick) {  // from @15456
                          if (!BCS ContinueGrowItems) {  // from @15458
                            if (!BCS ContinueGrowItems) {  // from @15460
                              if (!BCS Cont_CGrab_TTick) {  // from @15464
                                if (!BCS ContinueExtraLife) {  // from @15468
                                  loop {  // loop761 (infinite)
                                  }
                                  loop {  // loop788 (infinite)
                                  }
                                  if (!BNE PBFRegs) {  // from BlstSJp
                                  }
                                }
                              }
                              loop {  // loop839 (infinite)
                              }
                              loop {  // loop866 (infinite)
                              }
                              if (!BNE PBFRegs) {  // from BlstSJp
                              }
                              while (!BNE LoadSqu2Regs) {  // loop888
                                while (!BNE DivLLoop) {  // loop879
                                  do {  // loop878
                                  } while (BNE DivLLoop)
                                }
                                do {  // loop887
                                } while (BNE EL_LRegs)
                              }
                              if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                              }
                            }
                          }
                        }
                        loop {  // loop936 (infinite)
                        }
                        loop {  // loop963 (infinite)
                        }
                        if (!BNE PBFRegs) {  // from BlstSJp
                        }
                      }
                    }
                    loop {  // loop1011 (infinite)
                    }
                    loop {  // loop1038 (infinite)
                    }
                    if (!BNE PBFRegs) {  // from BlstSJp
                    }
                  }
                  while (!BNE DivLLoop) {  // loop1053
                    do {  // loop1052
                    } while (BNE DivLLoop)
                  }
                  do {  // loop1061
                  } while (BNE EL_LRegs)
                  if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                  }
                }
              }
            }
          }
          if (!BEQ ExS2H) {  // from CheckSfx2Buffer
            if (!BMI ContinueBowserFall) {  // from @15455
              if (!BCS Cont_CGrab_TTick) {  // from @15456
                if (!BCS ContinueGrowItems) {  // from @15458
                  if (!BCS ContinueGrowItems) {  // from @15460
                    if (!BCS Cont_CGrab_TTick) {  // from @15464
                      if (!BCS ContinueExtraLife) {  // from @15468
                        loop {  // loop1112 (infinite)
                        }
                        loop {  // loop1139 (infinite)
                        }
                        if (!BNE PBFRegs) {  // from BlstSJp
                        }
                      }
                    }
                    loop {  // loop1190 (infinite)
                    }
                    loop {  // loop1217 (infinite)
                    }
                    if (!BNE PBFRegs) {  // from BlstSJp
                    }
                    while (!BNE LoadSqu2Regs) {  // loop1239
                      while (!BNE DivLLoop) {  // loop1230
                        do {  // loop1229
                        } while (BNE DivLLoop)
                      }
                      do {  // loop1238
                      } while (BNE EL_LRegs)
                    }
                    if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                    }
                  }
                }
              }
              loop {  // loop1287 (infinite)
              }
              loop {  // loop1314 (infinite)
              }
              if (!BNE PBFRegs) {  // from BlstSJp
              }
            }
          }
          loop {  // loop1362 (infinite)
          }
          loop {  // loop1389 (infinite)
          }
          if (!BNE PBFRegs) {  // from BlstSJp
          }
        }
      }
    }
  }
  dec Squ2_SfxLenCounter   ;decrement length of sfx
  while (!BNE ExSfx2) {  // loop2092
    lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
    and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
    if (!BNE ContinueExtraLife) {  // from Square2SfxHandler
      ldy Square2SoundQueue  ;check for sfx in queue
      if (!BEQ CheckSfx2Buffer) {  // from @15433
        sty Square2SoundBuffer ;if found, put in buffer and check for the following
        if (!BMI PlayBowserFall) {  // from @15435
          lsr Square2SoundQueue
          if (!BCS PlayGrowPowerUp) {  // from @15439
            lsr Square2SoundQueue
            if (!BCS PlayGrowVine) {  // from @15441
              lsr Square2SoundQueue
              if (!BCS PlayExtraLife) {  // from @15449
                lda Square2SoundBuffer   ;check for sfx in buffer
                if (!BEQ ExS2H) {  // from CheckSfx2Buffer
                  if (!BMI ContinueBowserFall) {  // from @15455
                    lsr
                    if (!BCS Cont_CGrab_TTick) {  // from @15456
                      lsr
                      if (!BCS ContinueGrowItems) {  // from @15458
                        lsr
                        if (!BCS ContinueGrowItems) {  // from @15460
                          lsr
                          if (!BCS Cont_CGrab_TTick) {  // from @15464
                            lsr
                            if (!BCS ContinueExtraLife) {  // from @15468
                              loop {  // loop1453 (infinite)
                              }
                              loop {  // loop1480 (infinite)
                              }
                              if (!BNE PBFRegs) {  // from BlstSJp
                              }
                            }
                          }
                          loop {  // loop1531 (infinite)
                          }
                          loop {  // loop1558 (infinite)
                          }
                          if (!BNE PBFRegs) {  // from BlstSJp
                          }
                          while (!BNE LoadSqu2Regs) {  // loop1580
                            dex
                            while (!BNE DivLLoop) {  // loop1571
                              do {  // loop1570
                              } while (BNE DivLLoop)
                            }
                            do {  // loop1579
                            } while (BNE EL_LRegs)
                          }
                          lda #$10                ;load length of power-up reveal sound
                          if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                          }
                        }
                      }
                    }
                    loop {  // loop1628 (infinite)
                    }
                    loop {  // loop1655 (infinite)
                    }
                    if (!BNE PBFRegs) {  // from BlstSJp
                    }
                  }
                }
                loop {  // loop1703 (infinite)
                }
                loop {  // loop1730 (infinite)
                }
                if (!BNE PBFRegs) {  // from BlstSJp
                }
              }
              while (!BNE DivLLoop) {  // loop1745
                do {  // loop1744
                } while (BNE DivLLoop)
              }
              do {  // loop1753
              } while (BNE EL_LRegs)
              if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
              }
            }
          }
        }
      }
      if (!BEQ ExS2H) {  // from CheckSfx2Buffer
        if (!BMI ContinueBowserFall) {  // from @15455
          if (!BCS Cont_CGrab_TTick) {  // from @15456
            if (!BCS ContinueGrowItems) {  // from @15458
              if (!BCS ContinueGrowItems) {  // from @15460
                if (!BCS Cont_CGrab_TTick) {  // from @15464
                  if (!BCS ContinueExtraLife) {  // from @15468
                    loop {  // loop1804 (infinite)
                    }
                    loop {  // loop1831 (infinite)
                    }
                    if (!BNE PBFRegs) {  // from BlstSJp
                    }
                  }
                }
                loop {  // loop1882 (infinite)
                }
                loop {  // loop1909 (infinite)
                }
                if (!BNE PBFRegs) {  // from BlstSJp
                }
                while (!BNE LoadSqu2Regs) {  // loop1931
                  while (!BNE DivLLoop) {  // loop1922
                    do {  // loop1921
                    } while (BNE DivLLoop)
                  }
                  do {  // loop1930
                  } while (BNE EL_LRegs)
                }
                if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
                }
              }
            }
          }
          loop {  // loop1979 (infinite)
          }
          loop {  // loop2006 (infinite)
          }
          if (!BNE PBFRegs) {  // from BlstSJp
          }
        }
      }
      loop {  // loop2054 (infinite)
      }
      loop {  // loop2081 (infinite)
      }
      if (!BNE PBFRegs) {  // from BlstSJp
      }
    }
  }
  if (!BNE PBFRegs) {  // from BlstSJp
  }
  while (!BNE LoadSqu2Regs) {  // loop2114
    dex
    while (!BNE DivLLoop) {  // loop2105
      do {  // loop2104
      } while (BNE DivLLoop)
    }
    do {  // loop2113
    } while (BNE EL_LRegs)
  }
  lda #$10                ;load length of power-up reveal sound
  if (!BNE GrowItemRegs) {  // from PlayGrowPowerUp
  }
  inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
  lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
  lsr                       ;divide by 2 to get the offset
  tay
  cpy Squ2_SfxLenCounter    ;have we reached the end yet?
  if (!BEQ StopGrowItems) {  // from ContinueGrowItems
    lda #$9d                  ;load contents of other reg directly
    sta SND_SQUARE2_REG
    lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
    jsr SetFreq_Squ2
    rts
  }
  loop {  // loop2167 (infinite)
    // Block: BlstSJp
    BlstSJp: bne PBFRegs
    // Block: PlayGrowPowerUp
    lda #$10                ;load length of power-up reveal sound
    bne GrowItemRegs
    // Block: ContinueGrowItems
    inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
    lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
    lsr                       ;divide by 2 to get the offset
    tay
    cpy Squ2_SfxLenCounter    ;have we reached the end yet?
    beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
    // Block: StopGrowItems
    jmp EmptySfx2Buffer       ;branch to stop playing sounds
  }

def GetPlayerColors():
  ldx VRAM_Buffer1_Offset  ;get current buffer offset
  ldy #$00
  lda CurrentPlayer        ;check which player is on the screen
  if (!BEQ ChkFiery) {  // from GetPlayerColors
    ldy #$04                 ;load offset for luigi
  }
  ChkFiery:      lda PlayerStatus         ;check player status
  cmp #$02
  if (!BNE StartClrGet) {  // from ChkFiery
    ldy #$08
  }
  // Block: StartClrGet
  StartClrGet:   lda #$03                 ;do four colors
  sta $00
  do {  // loop6
    // Block: ClrGetLoop
    ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
    sta VRAM_Buffer1+3,x     ;in the buffer
    iny
    inx
    dec $00
    bpl ClrGetLoop
  } while (!BPL ClrGetLoop)
  ldx VRAM_Buffer1_Offset  ;load original offset from before
  ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
  if (!BNE SetBGColor) {  // from @1459
    ldy AreaType             ;otherwise use area type bits from area offset as offset
  }
  // Block: SetBGColor
  SetBGColor:    lda BackgroundColors,y   ;to background color instead
  sta VRAM_Buffer1+3,x
  lda #$3f                 ;set for sprite palette address
  sta VRAM_Buffer1,x       ;save to buffer
  lda #$10
  sta VRAM_Buffer1+1,x
  lda #$04                 ;write length byte to buffer
  sta VRAM_Buffer1+2,x
  lda #$00                 ;now the null terminator
  sta VRAM_Buffer1+7,x
  txa                      ;move the buffer pointer ahead 7 bytes
  clc                      ;in case we want to write anything else later
  adc #$07

def GetScreenPosition():
  // Block: GetScreenPosition
  lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
  clc
  adc #$ff                ;add 255 pixels
  sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
  lda ScreenLeft_PageLoc  ;get page number where left boundary is
  adc #$00                ;add carry from before
  sta ScreenRight_PageLoc ;store as page number where right boundary is
  rts

def InitBlock_XY_Pos():
  // Block: InitBlock_XY_Pos
  lda Player_X_Position   ;get player's horizontal coordinate
  clc
  adc #$08                ;add eight pixels
  and #$f0                ;mask out low nybble to give 16-pixel correspondence
  sta Block_X_Position,x  ;save as horizontal coordinate for block object
  lda Player_PageLoc
  adc #$00                ;add carry to page location of player
  sta Block_PageLoc,x     ;save as page location of block object
  sta Block_PageLoc2,x    ;save elsewhere to be used later
  lda Player_Y_HighPos
  sta Block_Y_HighPos,x   ;save vertical high byte of player into
  rts                     ;vertical high byte of block object and leave

def func@0():
  // Block: Start
  sei                          ;pretty standard 6502 type init here
  cld
  lda #%00010000               ;init PPU control register 1
  sta PPU_CTRL_REG1
  ldx #$ff                     ;reset stack pointer
  txs
  do {  // loop3
    // Block: VBlank1
    VBlank1:     lda PPU_STATUS               ;wait two frames
    bpl VBlank1
  } while (!BPL VBlank1)
  do {  // loop5
    // Block: VBlank2
    VBlank2:     lda PPU_STATUS
    bpl VBlank2
  } while (!BPL VBlank2)
  ldy #ColdBootOffset          ;load default cold boot pointer
  ldx #$05                     ;this is where we check for a warm boot
  dex
  while (!BPL WBootCheck) {  // loop10
    do {  // loop9
      // Block: WBootCheck
      WBootCheck:  lda TopScoreDisplay,x        ;check each score digit in the top score
      cmp #10                      ;to see if we have a valid digit
      bcs ColdBoot                 ;if not, give up and proceed with cold boot
    } while (BPL WBootCheck)
  }
  lda WarmBootValidation       ;second checkpoint, check to see if
  cmp #$a5                     ;another location has a specific value
  if (!BNE ColdBoot) {  // from @691
    ldy #WarmBootOffset          ;if passed both, load warm boot pointer
  }
  // Block: ColdBoot
  ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
  sta SND_DELTA_REG+1          ;reset delta counter load register
  sta OperMode                 ;reset primary mode of operation
  lda #$a5                     ;set warm boot flag
  sta WarmBootValidation
  sta PseudoRandomBitReg       ;set seed for pseudorandom register
  lda #%00001111
  sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
  lda #%00000110
  sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
  jsr MoveAllSpritesOffscreen
  jsr InitializeNameTables     ;initialize both name tables
  inc DisableScreenFlag        ;set flag to disable screen output
  lda Mirror_PPU_CTRL_REG1
  ora #%10000000               ;enable NMIs
  jsr WritePPUReg1
  loop {  // loop15 (infinite)
    // Block: EndlessLoop
    EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
  }

def DrawBrickChunks():
  lda #$02                   ;set palette bits here
  sta $00
  lda #$75                   ;set tile number for ball (something residual, likely)
  ldy GameEngineSubroutine
  cpy #$05                   ;if end-of-level routine running,
  if (!BEQ DChunks) {  // from DrawBrickChunks
    lda #$03                   ;otherwise set different palette bits
    sta $00
    lda #$84                   ;and set tile number for brick chunks
  }
  DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
  iny                        ;increment to start with tile bytes in OAM
  jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
  lda FrameCounter           ;get frame counter
  asl
  asl
  asl                        ;move low nybble to high
  asl
  and #$c0                   ;get what was originally d3-d2 of low nybble
  ora $00                    ;add palette bits
  iny                        ;increment offset for attribute bytes
  jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
  dey
  dey                        ;decrement offset to Y coordinate
  lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
  jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
  lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
  sta Sprite_X_Position,y    ;save into X coordinate of first sprite
  lda Block_Orig_XPos,x      ;get original horizontal coordinate
  sec
  sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
  sta $00                    ;store result as relative horizontal coordinate of original
  sec
  sbc Block_Rel_XPos         ;get difference of relative positions of original - current
  adc $00                    ;add original relative position to result
  adc #$06                   ;plus 6 pixels to position second brick chunk correctly
  sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
  lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
  sta Sprite_Y_Position+8,y
  sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
  lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
  sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
  lda $00                    ;use original relative horizontal position
  sec
  sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
  adc $00                    ;add original relative position to result
  adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
  sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
  lda Block_OffscreenBits    ;get offscreen bits for block object
  jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
  lda Block_OffscreenBits    ;get offscreen bits again
  asl                        ;shift d7 into carry
  if (!BCC ChnkOfs) {  // from DChunks
    lda #$f8
    jsr DumpTwoSpr             ;otherwise move top sprites offscreen
  }
  ChnkOfs: lda $00                    ;if relative position on left side of screen,
  if (!BPL ExBCDr) {  // from ChnkOfs
    lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
    cmp Sprite_X_Position+4,y  ;to right-side X coordinate
    if (!BCC ExBCDr) {  // from @14218
      lda #$f8                   ;otherwise move right half of sprites offscreen
      sta Sprite_Y_Position+4,y
      sta Sprite_Y_Position+12,y
    }
  }
  // Block: ExBCDr
  ExBCDr:  rts                        ;leave

def SetupLakitu():
  // Block: SetupLakitu
  lda #$00                   ;erase counter for lakitu's reappearance
  sta LakituReappearTimer
  jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
  jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
  // Block: TallBBox2
  TallBBox2: lda #$03                  ;set specific value for bounding box control

def BlockObjectsCore():
  lda Block_State,x           ;get state of block object
  if (!BEQ UpdSte) {  // from BlockObjectsCore
    and #$0f                    ;mask out high nybble
    pha                         ;push to stack
    tay                         ;put in Y for now
    txa
    clc
    adc #$09                    ;add 9 bytes to offset (note two block objects are created
    tax                         ;when using brick chunks, but only one offset for both)
    dey                         ;decrement Y to check for solid block state
    if (!BEQ BouncingBlockHandler) {  // from @7445
      jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
      jsr MoveObjectHorizontally  ;do another sub to move horizontally
      txa
      clc                         ;move onto next block object
      adc #$02
      tax
      jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
      jsr MoveObjectHorizontally  ;do another sub to move horizontally
      ldx ObjectOffset            ;get block object offset used for both
      jsr RelativeBlockPosition   ;get relative coordinates
      jsr GetBlockOffscreenBits   ;get offscreen information
      jsr DrawBrickChunks         ;draw the brick chunks
      pla                         ;get lower nybble of saved state
      ldy Block_Y_HighPos,x       ;check vertical high byte of block object
      if (!BEQ UpdSte) {  // from @7454
        pha                         ;otherwise save state back into stack
        lda #$f0
        cmp Block_Y_Position+2,x    ;check to see if bottom block object went
        if (!BCS ChkTop) {  // from @7469
          sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
        }
        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
        cmp #$f0                    ;see if it went to the bottom of the screen
        pla                         ;pull block object state from stack
        if (!BCC UpdSte) {  // from ChkTop
          if (!BCS KillBlock) {  // from @7478
            jsr ImposeGravityBlock     ;do sub to impose gravity on block object
            ldx ObjectOffset           ;get block object offset
            jsr RelativeBlockPosition  ;get relative coordinates
            jsr GetBlockOffscreenBits  ;get offscreen information
            jsr DrawBlock              ;draw the block
            lda Block_Y_Position,x     ;get vertical coordinate
            and #$0f                   ;mask out high nybble
            cmp #$05                   ;check to see if low nybble wrapped around
            pla                        ;pull state from stack
            if (!BCS UpdSte) {  // from BouncingBlockHandler
              lda #$01
              sta Block_RepFlag,x        ;otherwise set flag to replace metatile
              // Block: KillBlock
              KillBlock: lda #$00                   ;if branched here, nullify object state
            }
          }
        }
      }
    }
    if (!BCS UpdSte) {  // from BouncingBlockHandler
    }
  }
  // Block: UpdSte
  UpdSte:    sta Block_State,x          ;store contents of A in block object state
  rts

def DrawPlayer_Intermediate():
  // Block: DrawPlayer_Intermediate
  ldx #$05                       ;store data into zero page memory
  do {  // loop2
    // Block: PIntLoop
    PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
    sta $02,x                      ;appears on world/lives display
    dex
    bpl PIntLoop                   ;do this until all data is loaded
  } while (!BPL PIntLoop)
  ldx #$b8                       ;load offset for small standing
  ldy #$04                       ;load sprite data offset
  jsr DrawPlayerLoop             ;draw player accordingly
  lda Sprite_Attributes+36       ;get empty sprite attributes
  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
  sta Sprite_Attributes+32       ;store and leave
  rts

def ScrollScreen():
  // Block: ScrollScreen
  tya
  sta ScrollAmount          ;save value here
  clc
  adc ScrollThirtyTwo       ;add to value already set here
  sta ScrollThirtyTwo       ;save as new value here
  tya
  clc
  adc ScreenLeft_X_Pos      ;add to left side coordinate
  sta ScreenLeft_X_Pos      ;save as new left side coordinate
  sta HorizontalScroll      ;save here also
  lda ScreenLeft_PageLoc
  adc #$00                  ;add carry to page location for left
  sta ScreenLeft_PageLoc    ;side of the screen
  and #$01                  ;get LSB of page location
  sta $00                   ;save as temp variable for PPU register 1 mirror
  lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
  and #%11111110            ;save all bits except d0
  ora $00                   ;get saved bit here and save in PPU register 1
  sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
  jsr GetScreenPosition     ;figure out where the right side is
  lda #$08
  sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
  jmp ChkPOffscr            ;skip this part

def EnemiesAndLoopsCore():
  lda Enemy_Flag,x         ;check data here for MSB set
  pha                      ;save in stack
  asl
  if (!BCS ChkBowserF) {  // from EnemiesAndLoopsCore
    pla                      ;get from stack
    if (!BEQ ChkAreaTsk) {  // from @7767
      jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
    }
    ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
    and #$07
    cmp #$07                 ;if at a specific task, jump and leave
    if (!BEQ ExitELCore) {  // from ChkAreaTsk
      jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
      ChkBowserF: pla                      ;get data from stack
      and #%00001111           ;mask out high nybble
      tay
      lda Enemy_Flag,y         ;use as pointer and load same place with different offset
      if (!BNE ExitELCore) {  // from ChkBowserF
        sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
      }
    }
  } else {
    if (!BNE ExitELCore) {  // from ChkBowserF
    }
    // Block: ExitELCore
    ExitELCore: rts
  }
  lda LoopCommand           ;check if loop command was found
  if (!BEQ ChkEnemyFrenzy) {  // from ProcLoopCommand
    lda CurrentColumnPos      ;check to see if we're still on the first page
    if (!BNE ChkEnemyFrenzy) {  // from @7828
      ldy #$0b                  ;start at the end of each set of loop data
      lda WorldNumber           ;check to see if one of the world numbers
      cmp LoopCmdWorldNumber,y  ;matches our current world number
      while (!BNE FindLoop) {  // loop18
        do {  // loop13
          // Block: FindLoop
          FindLoop: dey
          bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
        } while (BNE FindLoop)
        do {  // loop17
          lda CurrentPageLoc        ;check to see if one of the page numbers
          cmp LoopCmdPageNumber,y   ;matches the page we're currently on
          bne FindLoop
        } while (BNE FindLoop)
      }
      lda Player_Y_Position     ;check to see if the player is at the correct position
      cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
      if (!BNE WrongChk) {  // from @7839
        lda Player_State          ;check to see if the player is
        cmp #$00                  ;on solid ground (i.e. not jumping or falling)
        if (!BNE WrongChk) {  // from @7842
          lda WorldNumber           ;are we in world 7? (check performed on correct
          cmp #World7               ;vertical position and on solid ground)
          if (!BNE InitMLp) {  // from @7845
            inc MultiLoopCorrectCntr  ;increment counter for correct progression
            IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
            lda MultiLoopPassCntr     ;have we done all three parts?
            cmp #$03
            while (!BNE InitLCmd) {  // loop28
              lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
              cmp #$03
              if (!BEQ InitMLp) {  // from @7853
                if (!BNE DoLpBack) {  // from @7856
                  do {  // loop24
                    // Block: WrongChk
                    WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
                    cmp #World7               ;incorrect vertical position or not on solid ground)
                    beq IncMLoop
                  } while (BEQ IncMLoop)
                }
                // Block: DoLpBack
                DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
                jsr KillAllEnemies
              }
            }
          }
        }
      }
      do {  // loop36
      } while (BEQ IncMLoop)
      // Block: InitMLp
      InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
      sta MultiLoopPassCntr
      sta MultiLoopCorrectCntr
      // Block: InitLCmd
      InitLCmd: lda #$00                  ;initialize loop command flag
      sta LoopCommand
    }
  }
  lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
  if (!BEQ ProcessEnemyData) {  // from ChkEnemyFrenzy
    sta Enemy_ID,x        ;store as enemy object identifier here
    lda #$01
    sta Enemy_Flag,x      ;activate enemy object flag
    lda #$00
    sta Enemy_State,x     ;initialize state and frenzy queue
    sta EnemyFrenzyQueue
    jmp InitEnemyObject   ;and then jump to deal with this enemy
  }
  ldy EnemyDataOffset      ;get offset of enemy object data
  lda (EnemyData),y        ;load first byte
  cmp #$ff                 ;check for EOD terminator
  if (!BNE CheckEndofBuffer) {  // from ProcessEnemyData
  } else {
    and #%00001111           ;check for special row $0e
    cmp #$0e
    if (!BEQ CheckRightBounds) {  // from CheckEndofBuffer
      cpx #$05                 ;check for end of buffer
      if (!BCC CheckRightBounds) {  // from @7896
        iny
        lda (EnemyData),y        ;check for specific value here
        and #%00111111           ;not sure what this was intended for, exactly
        cmp #$2e                 ;this part is quite possibly residual code
        if (!BEQ CheckRightBounds) {  // from @7898
          rts                      ;the sixth slot
        }
      }
    }
    lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
    clc
    adc #$30
    and #%11110000           ;store high nybble
    sta $07
    lda ScreenRight_PageLoc  ;add carry to page location of right boundary
    adc #$00
    sta $06                  ;store page location + carry
    ldy EnemyDataOffset
    iny
    lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
    asl
    if (!BCC CheckPageCtrlRow) {  // from CheckRightBounds
      lda EnemyObjectPageSel   ;if page select already set, do not set again
      if (!BNE CheckPageCtrlRow) {  // from @7919
        inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
        inc EnemyObjectPageLoc   ;and increment page control
      }
    }
    dey
    lda (EnemyData),y        ;reread first byte
    and #$0f
    cmp #$0f                 ;check for special row $0f
    if (!BNE PositionEnemyObj) {  // from CheckPageCtrlRow
      lda EnemyObjectPageSel   ;if page select set,
      if (!BNE PositionEnemyObj) {  // from @7930
        loop {  // loop82 (infinite)
          // Block: ProcLoopCommand
          lda LoopCommand           ;check if loop command was found
          beq ChkEnemyFrenzy
          lda CurrentColumnPos      ;check to see if we're still on the first page
          bne ChkEnemyFrenzy        ;if not, do not loop yet
          lda Player_Y_Position     ;check to see if the player is at the correct position
          cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
          bne WrongChk
          lda Player_State          ;check to see if the player is
          cmp #$00                  ;on solid ground (i.e. not jumping or falling)
          bne WrongChk              ;if not, player fails to pass loop, and loopback
          lda WorldNumber           ;are we in world 7? (check performed on correct
          cmp #World7               ;vertical position and on solid ground)
          bne InitMLp               ;if not, initialize flags used there, otherwise
          // Block: ChkEnemyFrenzy
          lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
          beq ProcessEnemyData  ;if not, skip this part
          jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
          iny
          lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
          and #%00111111
          sta EnemyObjectPageLoc   ;store as page control for enemy object data
          inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
          inc EnemyDataOffset
          inc EnemyObjectPageSel   ;set page select for enemy object data and
          jmp ProcLoopCommand      ;jump back to process loop commands again
        }
      }
    }
    lda EnemyObjectPageLoc   ;store page control as page location
    sta Enemy_PageLoc,x      ;for enemy object
    lda (EnemyData),y        ;get first byte of enemy object
    and #%11110000
    sta Enemy_X_Position,x   ;store column position
    cmp ScreenRight_X_Pos    ;check column position against right boundary
    lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
    sbc ScreenRight_PageLoc  ;from page location
    if (!BCS CheckRightExtBounds) {  // from PositionEnemyObj
      lda (EnemyData),y
      and #%00001111           ;check for special row $0e
      cmp #$0e                 ;if found, jump elsewhere
      if (!BEQ ParseRow0e) {  // from @7951
        jmp CheckThreeBytes      ;if not found, unconditional jump
        lda $07                  ;check right boundary + 48 against
        cmp Enemy_X_Position,x   ;column position without subtracting,
        lda $06                  ;then subtract borrow from page control temp
        sbc Enemy_PageLoc,x      ;plus carry
        if (!BCC CheckFrenzyBuffer) {  // from CheckRightExtBounds
          lda #$01                 ;store value in vertical high byte
          sta Enemy_Y_HighPos,x
          lda (EnemyData),y        ;get first byte again
          asl                      ;multiply by four to get the vertical
          asl                      ;coordinate
          asl
          asl
          sta Enemy_Y_Position,x
          cmp #$e0                 ;do one last check for special row $0e
          if (!BEQ ParseRow0e) {  // from @7963
            iny
            lda (EnemyData),y        ;get second byte of object
            and #%01000000           ;check to see if hard mode bit is set
            if (!BEQ CheckForEnemyGroup) {  // from @7973
              lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
              if (!BEQ Inc2B) {  // from @7977
                lda (EnemyData),y      ;get second byte and mask out 2 MSB
                and #%00111111
                cmp #$37               ;check for value below $37
                if (!BCC BuzzyBeetleMutate) {  // from CheckForEnemyGroup
                  cmp #$3f               ;if $37 or greater, check for value
                  if (!BCC DoGroup) {  // from @7985
                    cmp #Goomba          ;if below $37, check for goomba
                    if (!BNE StrID) {  // from BuzzyBeetleMutate
                      ldy PrimaryHardMode  ;check if primary hard mode flag is set
                      if (!BEQ StrID) {  // from @7991
                        lda #BuzzyBeetle
                      }
                    }
                    StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
                    lda #$01
                    sta Enemy_Flag,x     ;set flag for enemy in buffer
                    jsr InitEnemyObject
                    lda Enemy_Flag,x     ;check to see if flag is set
                    if (!BNE Inc2B) {  // from StrID
                      rts
                      lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
                      if (!BNE StrFre) {  // from CheckFrenzyBuffer
                        lda VineFlagOffset       ;otherwise check vine flag offset
                        cmp #$01
                        bne ExEPar               ;if other value <> 1, leave
                        lda #VineObject          ;otherwise put vine in enemy identifier
                      }
                      // Block: StrFre
                      StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
                      // Block: DoGroup
                      jmp HandleGroupEnemies   ;handle enemy group objects
                      iny                      ;increment Y to load third byte of object
                      iny
                      lda (EnemyData),y
                      lsr                      ;move 3 MSB to the bottom, effectively
                      lsr                      ;making %xxx00000 into %00000xxx
                      lsr
                      lsr
                      lsr
                      cmp WorldNumber          ;is it the same world number as we're on?
                      if (!BNE NotUse) {  // from ParseRow0e
                        dey                      ;of the same area, like the underground bonus areas)
                        lda (EnemyData),y        ;otherwise, get second byte and use as offset
                        sta AreaPointer          ;to addresses for level and enemy object data
                        iny
                        lda (EnemyData),y        ;get third byte again, and this time mask out
                        and #%00011111           ;the 3 MSB from before, save as page number to be
                        sta EntrancePage         ;used upon entry to area, if area is entered
                      }
                      // Block: NotUse
                      NotUse: jmp Inc3B
                      ldy EnemyDataOffset      ;load current offset for enemy object data
                      lda (EnemyData),y        ;get first byte
                      and #%00001111           ;check for special row $0e
                      cmp #$0e
                      if (!BNE Inc2B) {  // from CheckThreeBytes
                        // Block: Inc3B
                        Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
                      }
                    }
                  }
                }
                if (!BNE StrID) {  // from BuzzyBeetleMutate
                  if (!BEQ StrID) {  // from @7991
                  }
                }
                if (!BNE Inc2B) {  // from StrID
                  if (!BNE StrFre) {  // from CheckFrenzyBuffer
                  }
                  if (!BNE NotUse) {  // from ParseRow0e
                  }
                  if (!BNE Inc2B) {  // from CheckThreeBytes
                  }
                }
              }
            }
            if (!BCC BuzzyBeetleMutate) {  // from CheckForEnemyGroup
              if (!BCC DoGroup) {  // from @7985
                if (!BNE StrID) {  // from BuzzyBeetleMutate
                  if (!BEQ StrID) {  // from @7991
                  }
                }
                if (!BNE Inc2B) {  // from StrID
                  if (!BNE StrFre) {  // from CheckFrenzyBuffer
                  }
                  if (!BNE NotUse) {  // from ParseRow0e
                  }
                  if (!BNE Inc2B) {  // from CheckThreeBytes
                  }
                }
              }
            }
            if (!BNE StrID) {  // from BuzzyBeetleMutate
              if (!BEQ StrID) {  // from @7991
              }
            }
            if (!BNE Inc2B) {  // from StrID
              if (!BNE StrFre) {  // from CheckFrenzyBuffer
              }
              if (!BNE NotUse) {  // from ParseRow0e
              }
              if (!BNE Inc2B) {  // from CheckThreeBytes
              }
            }
          }
        }
        if (!BNE StrFre) {  // from CheckFrenzyBuffer
        }
      }
    }
    if (!BCC CheckFrenzyBuffer) {  // from CheckRightExtBounds
      if (!BEQ ParseRow0e) {  // from @7963
        if (!BEQ CheckForEnemyGroup) {  // from @7973
          if (!BEQ Inc2B) {  // from @7977
            if (!BCC BuzzyBeetleMutate) {  // from CheckForEnemyGroup
              if (!BCC DoGroup) {  // from @7985
                if (!BNE StrID) {  // from BuzzyBeetleMutate
                  if (!BEQ StrID) {  // from @7991
                  }
                }
                if (!BNE Inc2B) {  // from StrID
                  if (!BNE StrFre) {  // from CheckFrenzyBuffer
                  }
                  if (!BNE NotUse) {  // from ParseRow0e
                  }
                  if (!BNE Inc2B) {  // from CheckThreeBytes
                  }
                }
              }
            }
            if (!BNE StrID) {  // from BuzzyBeetleMutate
              if (!BEQ StrID) {  // from @7991
              }
            }
            if (!BNE Inc2B) {  // from StrID
              if (!BNE StrFre) {  // from CheckFrenzyBuffer
              }
              if (!BNE NotUse) {  // from ParseRow0e
              }
              if (!BNE Inc2B) {  // from CheckThreeBytes
              }
            }
          }
        }
        if (!BCC BuzzyBeetleMutate) {  // from CheckForEnemyGroup
          if (!BCC DoGroup) {  // from @7985
            if (!BNE StrID) {  // from BuzzyBeetleMutate
              if (!BEQ StrID) {  // from @7991
              }
            }
            if (!BNE Inc2B) {  // from StrID
              if (!BNE StrFre) {  // from CheckFrenzyBuffer
              }
              if (!BNE NotUse) {  // from ParseRow0e
              }
              if (!BNE Inc2B) {  // from CheckThreeBytes
              }
            }
          }
        }
        if (!BNE StrID) {  // from BuzzyBeetleMutate
          if (!BEQ StrID) {  // from @7991
          }
        }
        if (!BNE Inc2B) {  // from StrID
          if (!BNE StrFre) {  // from CheckFrenzyBuffer
          }
          if (!BNE NotUse) {  // from ParseRow0e
          }
          if (!BNE Inc2B) {  // from CheckThreeBytes
          }
        }
      }
    }
  }
  lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
  if (!BNE StrFre) {  // from CheckFrenzyBuffer
  }
  iny                      ;increment Y to load third byte of object
  iny
  lda (EnemyData),y
  lsr                      ;move 3 MSB to the bottom, effectively
  lsr                      ;making %xxx00000 into %00000xxx
  lsr
  lsr
  lsr
  cmp WorldNumber          ;is it the same world number as we're on?
  if (!BNE NotUse) {  // from ParseRow0e
  }
  ldy EnemyDataOffset      ;load current offset for enemy object data
  lda (EnemyData),y        ;get first byte
  and #%00001111           ;check for special row $0e
  cmp #$0e
  if (!BNE Inc2B) {  // from CheckThreeBytes
  }
  // Block: Inc2B
  Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
  inc EnemyDataOffset
  lda #$00                 ;init page select for enemy objects
  sta EnemyObjectPageSel
  ldx ObjectOffset         ;reload current offset in enemy buffers
  rts                      ;and leave
  ldy #$00                  ;load value for green koopa troopa
  sec
  sbc #$37                  ;subtract $37 from second byte read
  pha                       ;save result in stack for now
  cmp #$04                  ;was byte in $3b-$3e range?
  if (!BCS SnglID) {  // from HandleGroupEnemies
    pha                       ;save another copy to stack
    ldy #Goomba               ;load value for goomba enemy
    lda PrimaryHardMode       ;if primary hard mode flag not set,
    if (!BEQ PullID) {  // from @8761
      ldy #BuzzyBeetle          ;for buzzy beetle
    }
    // Block: PullID
    PullID: pla                       ;get second copy from stack
  }
  SnglID: sty $01                   ;save enemy id here
  ldy #$b0                  ;load default y coordinate
  and #$02                  ;check to see if d1 was set
  if (!BEQ SetYGp) {  // from SnglID
    ldy #$70                  ;otherwise branch and use default
  }
  SetYGp: sty $00                   ;save y coordinate here
  lda ScreenRight_PageLoc   ;get page number of right edge of screen
  sta $02                   ;save here
  lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
  sta $03                   ;save here
  ldy #$02                  ;load two enemies by default
  pla                       ;get first copy from stack
  lsr                       ;check to see if d0 was set
  if (!BCC CntGrp) {  // from SetYGp
    iny                       ;otherwise increment to three enemies
  }
  // Block: CntGrp
  CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
  lda $01
  sta Enemy_ID,x            ;store enemy object identifier
  lda $02
  sta Enemy_PageLoc,x       ;store page location for enemy object
  lda $03
  sta Enemy_X_Position,x    ;store x coordinate for enemy object
  clc
  adc #$18                  ;add 24 pixels for next enemy
  sta $03
  lda $02                   ;add carry to page location for
  adc #$00                  ;next enemy
  sta $02
  lda $00                   ;store y coordinate for enemy object
  sta Enemy_Y_Position,x
  lda #$01                  ;activate flag for buffer, and
  sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
  sta Enemy_Flag,x
  jsr CheckpointEnemyID     ;process each enemy object separately
  dec NumberofGroupEnemies  ;do this until we run out of enemy objects
  while (BNE GrLoop) {  // loop260
    // Block: GrLoop
    GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
    // Block: GSltLp
    GSltLp: inx                       ;increment and branch if past
    cpx #$05                  ;end of buffers
    bcs NextED
    lda Enemy_Flag,x          ;check to see if enemy is already
    bne GSltLp                ;stored in buffer, and branch if so
  }
  loop {  // loop276 (infinite)
    // Block: HandleGroupEnemies
    ldy #$00                  ;load value for green koopa troopa
    sec
    sbc #$37                  ;subtract $37 from second byte read
    pha                       ;save result in stack for now
    cmp #$04                  ;was byte in $3b-$3e range?
    bcs SnglID                ;if so, branch
    pha                       ;save another copy to stack
    ldy #Goomba               ;load value for goomba enemy
    lda PrimaryHardMode       ;if primary hard mode flag not set,
    beq PullID                ;branch, otherwise change to value
    // Block: SnglID
    SnglID: sty $01                   ;save enemy id here
    ldy #$b0                  ;load default y coordinate
    and #$02                  ;check to see if d1 was set
    beq SetYGp                ;if so, move y coordinate up,
    // Block: SetYGp
    SetYGp: sty $00                   ;save y coordinate here
    lda ScreenRight_PageLoc   ;get page number of right edge of screen
    sta $02                   ;save here
    lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
    sta $03                   ;save here
    ldy #$02                  ;load two enemies by default
    pla                       ;get first copy from stack
    lsr                       ;check to see if d0 was set
    bcc CntGrp                ;if not, use default value
    // Block: NextED
    NextED: jmp Inc2B                 ;jump to increment data offset and leave
  }
  ldx ObjectOffset  ;get offset for enemy object buffer
  lda #$00          ;load value 0 for jump engine by default
  ldy Enemy_ID,x
  cpy #$15          ;if enemy object < $15, use default value
  if (!BCC JmpEO) {  // from RunEnemyObjectsCore
    tya               ;otherwise subtract $14 from the value and use
    sbc #$14          ;as value for jump engine
  }
  // Block: JmpEO
  JmpEO: jsr JumpEngine
  // Block: NoRunCode
  rts

def EnemyJump():
  jsr SubtEnemyYPos     ;do a sub here
  if (!BCC DoSide) {  // from EnemyJump
    lda Enemy_Y_Speed,x
    clc                   ;add two to vertical speed
    adc #$02
    cmp #$03              ;if green paratroopa not falling, branch ahead
    if (!BCC DoSide) {  // from @12663
      jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
      if (!BEQ DoSide) {  // from @12668
        jsr ChkForNonSolids   ;check for non-solid blocks
        if (!BEQ DoSide) {  // from @12670
          jsr EnemyLanding      ;change vertical coordinate and speed
          lda #$fd
          sta Enemy_Y_Speed,x   ;make the paratroopa jump again
        }
      }
    }
  }
  // Block: DoSide
  DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave

def SetFreq_Squ1():
  // Block: SetFreq_Squ1
  ldx #$00               ;set frequency reg offset for square 1 sound channel

def ProcessAreaData():
  // Block: ProcessAreaData
  ldx #$02                 ;start at the end of area object buffer
  ProcLoopb:  dex                      ;decrement buffer offset
  while (!BPL ProcADLoop) {  // loop25
    lda AreaObjectLength,x   ;check area object buffer flag
    if (!BPL RdyDecode) {  // from @3309
      iny
      lda (AreaData),y         ;get second byte of area object
      asl                      ;check for page select bit (d7), branch if not set
      if (!BCC Chk1Row13) {  // from @3311
        lda AreaObjectPageSel    ;check page select
        if (!BNE Chk1Row13) {  // from @3315
          inc AreaObjectPageSel    ;if not already set, set it now
          inc AreaObjectPageLoc    ;and increment page location
        }
      }
      Chk1Row13:  dey
      lda (AreaData),y         ;reread first byte of level object
      and #$0f                 ;mask out high nybble
      cmp #$0d                 ;row 13?
      if (!BNE Chk1Row14) {  // from Chk1Row13
        iny                      ;if so, reread second byte of level object
        lda (AreaData),y
        dey                      ;decrement to get ready to read first byte
        and #%01000000           ;check for d6 set (if not, object is page control)
        if (!BNE CheckRear) {  // from @3324
          lda AreaObjectPageSel    ;if page select is set, do not reread
          if (!BNE CheckRear) {  // from @3329
            iny                      ;if d6 not set, reread second byte
            lda (AreaData),y
            and #%00011111           ;mask out all but 5 LSB and store in page control
            sta AreaObjectPageLoc
            inc AreaObjectPageSel    ;increment page select
            jmp NextAObj
            Chk1Row14:  cmp #$0e                 ;row 14?
            if (!BNE CheckRear) {  // from Chk1Row14
              lda BackloadingFlag      ;check flag for saved page number and branch if set
              if (!BNE RdyDecode) {  // from @3339
                CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
                cmp CurrentPageLoc       ;behind current page of renderer
                if (!BCC SetBehind) {  // from CheckRear
                  // Block: RdyDecode
                  RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
                  jmp ChkLength
                }
              }
            }
          }
        }
      }
      if (!BNE CheckRear) {  // from Chk1Row14
        if (!BNE RdyDecode) {  // from @3339
          if (!BCC SetBehind) {  // from CheckRear
          }
        }
      }
      if (!BCC SetBehind) {  // from CheckRear
      }
    }
    // Block: SetBehind
    SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
    // Block: NextAObj
    NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
    ChkLength:  ldx ObjectOffset         ;get buffer offset
    lda AreaObjectLength,x   ;check object length for anything stored here
    if (!BMI ProcLoopb) {  // from ChkLength
      dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
    }
  }
  lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
  bne ProcessAreaData      ;branch if true to load more level data, otherwise
  lda BackloadingFlag      ;check for flag set if starting right of page $00
  bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
  // Block: EndAParse
  EndAParse:  rts

def BlockBufferCollision():
  pha                         ;save contents of A to stack
  sty $04                     ;save contents of Y here
  lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
  clc                         ;of object to value obtained using Y as offset
  adc SprObject_X_Position,x
  sta $05                     ;store here
  lda SprObject_PageLoc,x
  adc #$00                    ;add carry to page location
  and #$01                    ;get LSB, mask out all other bits
  lsr                         ;move to carry
  ora $05                     ;get stored value
  ror                         ;rotate carry to MSB of A
  lsr                         ;and effectively move high nybble to
  lsr                         ;lower, LSB which became MSB will be
  lsr                         ;d4 at this point
  jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
  ldy $04                     ;get old contents of Y
  lda SprObject_Y_Position,x  ;get vertical coordinate of object
  clc
  adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
  and #%11110000              ;mask out low nybble
  sec
  sbc #$20                    ;subtract 32 pixels for the status bar
  sta $02                     ;store result here
  tay                         ;use as offset for block buffer
  lda ($06),y                 ;check current content of block buffer
  sta $03                     ;and store here
  ldy $04                     ;get old contents of Y again
  pla                         ;pull A from stack
  if (!BNE RetXC) {  // from BlockBufferCollision
    lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
    jmp RetYC                   ;and jump
  } else {
    // Block: RetXC
    RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
  }
  // Block: RetYC
  RetYC: and #%00001111              ;and mask out high nybble
  sta $04                     ;store masked out result here
  lda $03                     ;get saved content of block buffer
  rts                         ;and leave

def CheckForClimbMTiles():
  // Block: CheckForClimbMTiles
  jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
  cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
  rts

def GetEnemyOffscreenBits():
  // Block: GetEnemyOffscreenBits
  lda #$01                 ;set A to add 1 byte in order to get enemy offset
  ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
  jmp SetOffscrBitsOffset

def IncAreaObjOffset():
  // Block: IncAreaObjOffset
  inc AreaDataOffset    ;increment offset of level pointer
  inc AreaDataOffset
  lda #$00              ;reset page select
  sta AreaObjectPageSel
  rts

def OffscreenBoundsCheck():
  lda Enemy_ID,x          ;check for cheep-cheep object
  cmp #FlyingCheepCheep   ;branch to leave if found
  if (!BEQ ExScrnBd) {  // from OffscreenBoundsCheck
    lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
    ldy Enemy_ID,x
    cpy #HammerBro          ;check for hammer bro object
    if (!BEQ LimitB) {  // from @11009
      cpy #PiranhaPlant       ;check for piranha plant object
      if (!BNE ExtendLB) {  // from @11013
        // Block: LimitB
        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
      }
    }
    ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
    sta $01                 ;store result here
    lda ScreenLeft_PageLoc
    sbc #$00                ;subtract borrow from page location of left side
    sta $00                 ;store result here
    lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
    adc #$48
    sta $03                 ;store result here
    lda ScreenRight_PageLoc
    adc #$00                ;then add the carry to the page location
    sta $02                 ;and store result here
    lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
    cmp $01                 ;to modified horizontal left edge coordinate to get carry
    lda Enemy_PageLoc,x
    sbc $00                 ;then subtract it from the page coordinate of the enemy object
    if (!BMI TooFar) {  // from ExtendLB
      lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
      cmp $03                 ;to modified horizontal right edge coordinate to get carry
      lda Enemy_PageLoc,x
      sbc $02                 ;then subtract it from the page coordinate of the enemy object
      if (!BMI ExScrnBd) {  // from @11032
        lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
        cmp #HammerBro          ;if in state used by spiny's egg, do not erase
        if (!BEQ ExScrnBd) {  // from @11037
          cpy #PiranhaPlant       ;if piranha plant, do not erase
          if (!BEQ ExScrnBd) {  // from @11040
            cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
            if (!BEQ ExScrnBd) {  // from @11042
              cpy #StarFlagObject     ;if star flag, do not erase
              if (!BEQ ExScrnBd) {  // from @11044
                cpy #JumpspringObject   ;if jumpspring, do not erase
                if (!BEQ ExScrnBd) {  // from @11046
                  // Block: TooFar
                  TooFar:   jsr EraseEnemyObject    ;erase object if necessary
                }
              }
            }
          }
        }
      }
    }
  }
  // Block: ExScrnBd
  ExScrnBd: rts                     ;leave

def AreaParserTaskHandler():
  ldy AreaParserTaskNum     ;check number of tasks here
  if (!BNE DoAPTasks) {  // from AreaParserTaskHandler
    ldy #$08
    sty AreaParserTaskNum     ;otherwise, set eight by default
  }
  DoAPTasks:    dey
  tya
  jsr AreaParserTasks
  dec AreaParserTaskNum     ;if all tasks not complete do not
  if (!BNE SkipATRender) {  // from DoAPTasks
    jsr RenderAttributeTables
  }
  // Block: SkipATRender
  SkipATRender: rts

def MoveSixSpritesOffscreen():
  // Block: MoveSixSpritesOffscreen
  lda #$f8                  ;set offscreen coordinate if jumping here

def UpdateScreen():
  sta PPU_ADDRESS           ;store high byte of vram address
  iny
  lda ($00),y               ;load next byte (second)
  sta PPU_ADDRESS           ;store low byte of vram address
  iny
  lda ($00),y               ;load next byte (third)
  asl                       ;shift to left and save in stack
  pha
  lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
  ora #%00000100            ;set ppu to increment by 32 by default
  if (!BCS SetupWrites) {  // from WriteBufferToScreen
    and #%11111011            ;only increment by 1
  }
  SetupWrites:   jsr WritePPUReg1          ;write to register
  pla                       ;pull from stack and shift to left again
  asl
  if (!BCC GetLength) {  // from SetupWrites
    ora #%00000010            ;otherwise set d1 and increment Y
    iny
  }
  // Block: GetLength
  GetLength:     lsr                       ;shift back to the right to get proper length
  lsr                       ;note that d1 will now be in carry
  tax
  RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
  sta PPU_DATA
  dex                       ;done writing?
  while (!BNE OutputToVRAM) {  // loop10
    iny                       ;otherwise increment Y to load next byte
    do {  // loop9
      // Block: OutputToVRAM
      OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
    } while (BNE OutputToVRAM)
  }
  sec
  tya
  adc $00                   ;add end length plus one to the indirect at $00
  sta $00                   ;to allow this routine to read another set of updates
  lda #$00
  adc $01
  sta $01
  lda #$3f                  ;sets vram address to $3f00
  sta PPU_ADDRESS
  lda #$00
  sta PPU_ADDRESS
  sta PPU_ADDRESS           ;then reinitializes it for some reason
  sta PPU_ADDRESS
  // Block: UpdateScreen
  UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
  ldy #$00                  ;load first byte from indirect as a pointer
  lda ($00),y
  bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here

def DumpThreeSpr():
  // Block: DumpThreeSpr
  sta Sprite_Data+8,y

def MoveESprColOffscreen():
  // Block: MoveESprColOffscreen
  clc                         ;add A to enemy object OAM data offset
  adc Enemy_SprDataOffset,x
  tay                         ;use as offset
  jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
  sta Sprite_Data+16,y        ;move third row sprite in column offscreen
  rts

def FirebarSpin():
  sta $07                     ;save spinning speed here
  lda FirebarSpinDirection,x  ;check spinning direction
  if (!BNE SpinCounterClockwise) {  // from FirebarSpin
    ldy #$18                    ;possibly residual ldy
    lda FirebarSpinState_Low,x
    clc                         ;add spinning speed to what would normally be
    adc $07                     ;the horizontal speed
    sta FirebarSpinState_Low,x
    lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
    adc #$00
    rts
  }
  // Block: SpinCounterClockwise
  ldy #$08                    ;possibly residual ldy
  lda FirebarSpinState_Low,x
  sec                         ;subtract spinning speed to what would normally be
  sbc $07                     ;the horizontal speed
  sta FirebarSpinState_Low,x
  lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
  sbc #$00
  rts

def RenderUnderPart():
  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
  dey
  while (!BPL RenderUnderPart) {  // loop21
    cpy #$17
    if (!BEQ WaitOneRow) {  // from @4251
      cpy #$1a
      if (!BEQ WaitOneRow) {  // from @4253
        cpy #$c0
        if (!BEQ DrawThisRow) {  // from @4255
          cpy #$c0
          if (!BCS WaitOneRow) {  // from @4257
            cpy #$54
            if (!BNE DrawThisRow) {  // from @4259
              cmp #$50
              if (!BEQ WaitOneRow) {  // from @4261
                // Block: DrawThisRow
                DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
              }
            }
          }
        }
      }
    }
    WaitOneRow:  inx
    cpx #$0d              ;stop rendering if we're at the bottom of the screen
    if (!BCS ExitUPartR) {  // from WaitOneRow
      do {  // loop19
        // Block: RenderUnderPart
        sty AreaObjectHeight  ;store vertical length to render
        ldy MetatileBuffer,x  ;check current spot to see if there's something
        beq DrawThisRow       ;we need to keep, if nothing, go ahead
      } while (BPL RenderUnderPart)
    }
  }
  // Block: ExitUPartR
  ExitUPartR:  rts

def SmallPlatformBoundBox():
  // Block: SmallPlatformBoundBox
  ldy #$08                 ;store bitmask here for now
  sty $00
  ldy #$04                 ;store another bitmask here for now

def AreaParserTasks():
  // Block: AreaParserTasks
  jsr JumpEngine
  inc CurrentColumnPos     ;increment column where we're at
  lda CurrentColumnPos
  and #%00001111           ;mask out higher nybble
  if (!BNE NoColWrap) {  // from IncrementColumnPos
    sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
    inc CurrentPageLoc       ;and increment page number where we're at
  }
  // Block: NoColWrap
  NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
  lda BlockBufferColumnPos
  and #%00011111           ;mask out all but 5 LSB (0-1f)
  sta BlockBufferColumnPos ;and save
  rts

def LargePlatformBoundBox():
  // Block: LargePlatformBoundBox
  inx                        ;increment X to get the proper offset
  jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
  dex                        ;decrement to return to original offset
  cmp #$fe                   ;if completely offscreen, branch to put entire bounding
  bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates

def GetPlayerAnimSpeed():
  ldy #$00                   ;initialize offset in Y
  lda Player_XSpeedAbsolute  ;check player's walking/running speed
  cmp #$1c                   ;against preset amount
  if (!BCS SetRunSpd) {  // from GetPlayerAnimSpeed
    iny                        ;otherwise increment Y
    cmp #$0e                   ;compare against lower amount
    if (!BCS ChkSkid) {  // from @6199
      iny                        ;otherwise increment Y again
    }
    ChkSkid:    lda SavedJoypadBits        ;get controller bits
    and #%01111111             ;mask out A button
    if (!BEQ SetAnimSpd) {  // from ChkSkid
      and #$03                   ;mask out all others except left and right
      cmp Player_MovingDir       ;check against moving direction
      if (!BNE ProcSkid) {  // from @6206
        lda #$00                   ;otherwise set zero value here
        // Block: SetRunSpd
        SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
        jmp SetAnimSpd
      } else {
        ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
        cmp #$0b                   ;against one last amount
        if (!BCS SetAnimSpd) {  // from ProcSkid
          lda PlayerFacingDir
          sta Player_MovingDir       ;otherwise use facing direction to set moving direction
          lda #$00
          sta Player_X_Speed         ;nullify player's horizontal speed
          sta Player_X_MoveForce     ;and dummy variable for player
        }
      }
    }
  }
  ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
  cmp #$0b                   ;against one last amount
  if (!BCS SetAnimSpd) {  // from ProcSkid
  }
  // Block: SetAnimSpd
  SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
  sta PlayerAnimTimerSet
  rts

def FireballObjCore():
  stx ObjectOffset             ;store offset as current object
  lda Fireball_State,x         ;check for d7 = 1
  asl
  if (!BCS FireballExplosion) {  // from FireballObjCore
    ldy Fireball_State,x         ;if fireball inactive, branch to leave
    if (!BEQ NoFBall) {  // from @6331
      dey                          ;if fireball state set to 1, skip this part and just run it
      if (!BEQ RunFB) {  // from @6333
        lda Player_X_Position        ;get player's horizontal position
        adc #$04                     ;add four pixels and store as fireball's horizontal position
        sta Fireball_X_Position,x
        lda Player_PageLoc           ;get player's page location
        adc #$00                     ;add carry and store as fireball's page location
        sta Fireball_PageLoc,x
        lda Player_Y_Position        ;get player's vertical position and store
        sta Fireball_Y_Position,x
        lda #$01                     ;set high byte of vertical position
        sta Fireball_Y_HighPos,x
        ldy PlayerFacingDir          ;get player's facing direction
        dey                          ;decrement to use as offset here
        lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
        sta Fireball_X_Speed,x
        lda #$04                     ;set vertical speed of fireball
        sta Fireball_Y_Speed,x
        lda #$07
        sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
        dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
      }
      RunFB:   txa                          ;add 7 to offset to use
      clc                          ;as fireball offset for next routines
      adc #$07
      tax
      lda #$50                     ;set downward movement force here
      sta $00
      lda #$03                     ;set maximum speed here
      sta $02
      lda #$00
      jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
      jsr MoveObjectHorizontally   ;do another sub to move it horizontally
      ldx ObjectOffset             ;return fireball offset to X
      jsr RelativeFireballPosition ;get relative coordinates
      jsr GetFireballOffscreenBits ;get offscreen information
      jsr GetFireballBoundBox      ;get bounding box coordinates
      jsr FireballBGCollision      ;do fireball to background collision detection
      lda FBall_OffscreenBits      ;get fireball offscreen bits
      and #%11001100               ;mask out certain bits
      if (!BNE EraseFB) {  // from RunFB
        jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
        jmp DrawFireball             ;draw fireball appropriately and leave
      }
      // Block: EraseFB
      EraseFB: lda #$00                     ;erase fireball state
      sta Fireball_State,x
    }
    // Block: NoFBall
    NoFBall: rts                          ;leave
  }
  // Block: FireballExplosion
  jsr RelativeFireballPosition
  jmp DrawExplosion_Fireball
  // Block: DrawFireball
  ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
  lda Fireball_Rel_YPos      ;get relative vertical coordinate
  sta Sprite_Y_Position,y    ;store as sprite Y coordinate
  lda Fireball_Rel_XPos      ;get relative horizontal coordinate
  sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
  ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
  lda Fireball_State,x     ;load fireball state
  inc Fireball_State,x     ;increment state for next frame
  lsr                      ;divide by 2
  and #%00000111           ;mask out all but d3-d1
  cmp #$03                 ;check to see if time to kill fireball
  if (!BCS KillFireBall) {  // from DrawExplosion_Fireball
  }
  // Block: KillFireBall
  lda #$00                    ;clear fireball state to kill it
  sta Fireball_State,x
  rts

def DumpTwoSpr():
  // Block: DumpTwoSpr
  sta Sprite_Data+4,y       ;and into first row sprites
  sta Sprite_Data,y
  // Block: ExitDumpSpr
  rts

def ProcFirebar():
  jsr GetEnemyOffscreenBits   ;get offscreen information
  lda Enemy_OffscreenBits     ;check for d3 set
  and #%00001000              ;if so, branch to leave
  if (!BNE SkipFBar) {  // from ProcFirebar
    lda TimerControl            ;if master timer control set, branch
    if (!BNE SusFbar) {  // from @9705
      lda FirebarSpinSpeed,x      ;load spinning speed of firebar
      jsr FirebarSpin             ;modify current spinstate
      and #%00011111              ;mask out all but 5 LSB
      sta FirebarSpinState_High,x ;and store as new high byte of spinstate
    }
    SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
    ldy Enemy_ID,x              ;check enemy identifier
    cpy #$1f
    if (!BCC SetupGFB) {  // from SusFbar
      cmp #$08                    ;check high byte of spinstate
      if (!BEQ SkpFSte) {  // from @9715
        cmp #$18
        if (!BNE SetupGFB) {  // from @9717
          // Block: SkpFSte
          SkpFSte:  clc
          adc #$01                    ;add one to spinning thing to avoid horizontal state
          sta FirebarSpinState_High,x
        }
      }
    }
    SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
    jsr RelativeEnemyPosition   ;get relative coordinates to screen
    jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
    ldy Enemy_SprDataOffset,x   ;get OAM data offset
    lda Enemy_Rel_YPos          ;get relative vertical coordinate
    sta Sprite_Y_Position,y     ;store as Y in OAM data
    sta $07                     ;also save here
    lda Enemy_Rel_XPos          ;get relative horizontal coordinate
    sta Sprite_X_Position,y     ;store as X in OAM data
    sta $06                     ;also save here
    lda #$01
    sta $00                     ;set $01 value here (not necessary)
    jsr FirebarCollision        ;draw fireball part and do collision detection
    ldy #$05                    ;load value for short firebars by default
    lda Enemy_ID,x
    cmp #$1f                    ;are we doing a long firebar?
    if (!BCC SetMFbar) {  // from SetupGFB
      ldy #$0b                    ;otherwise load value for long firebars
    }
    // Block: SetMFbar
    SetMFbar: sty $ed                     ;store maximum value for length of firebars
    lda #$00
    sta $00                     ;initialize counter here
    NextFbar: inc $00                     ;move onto the next firebar part
    lda $00
    cmp $ed                     ;if we end up at the maximum part, go on and leave
    while (!BCC DrawFbar) {  // loop15
      ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
      lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
      sta $06                     ;using long firebar offset, then store as new one here
      do {  // loop14
        // Block: DrawFbar
        DrawFbar: lda $ef                     ;load high byte of spinstate
        jsr GetFirebarPosition      ;get fireball position data depending on firebar part
        jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
        lda $00                     ;check which firebar part
        cmp #$04
        bne NextFbar
      } while (BCC DrawFbar)
    }
  }
  // Block: SkipFBar
  SkipFBar: rts

def MoveJumpingEnemy():
  // Block: MoveJumpingEnemy
  jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
  jmp MoveEnemyHorizontally  ;jump to move enemy horizontally

def InitVStf():
  // Block: InitVStf
  InitVStf: lda #$00                    ;initialize vertical speed
  sta Enemy_Y_Speed,x         ;and movement force
  sta Enemy_Y_MoveForce,x
  rts

def ImpedePlayerMove():
  lda #$00                  ;initialize value here
  ldy Player_X_Speed        ;get player's horizontal speed
  ldx $00                   ;check value set earlier for
  dex                       ;left side collision
  if (!BNE RImpd) {  // from ImpedePlayerMove
    inx                       ;return value to X
    cpy #$00                  ;if player moving to the left,
    if (!BMI ExIPM) {  // from @12323
      lda #$ff                  ;otherwise load A with value to be used later
      jmp NXSpd                 ;and jump to affect movement
      RImpd: ldx #$02                  ;return $02 to X
      cpy #$01                  ;if player moving to the right,
      if (!BPL ExIPM) {  // from RImpd
        lda #$01                  ;otherwise load A with value to be used here
        NXSpd: ldy #$10
        sty SideCollisionTimer    ;set timer of some sort
        ldy #$00
        sty Player_X_Speed        ;nullify player's horizontal speed
        cmp #$00                  ;if value set in A not set to $ff,
        if (!BPL PlatF) {  // from NXSpd
          dey                       ;otherwise decrement Y now
        }
        // Block: PlatF
        PlatF: sty $00                   ;store Y as high bits of horizontal adder
        clc
        adc Player_X_Position     ;add contents of A to player's horizontal
        sta Player_X_Position     ;position to move player left or right
        lda Player_PageLoc
        adc $00                   ;add high bits and carry to
        sta Player_PageLoc        ;page location if necessary
      }
    }
  } else {
    if (!BPL ExIPM) {  // from RImpd
      if (!BPL PlatF) {  // from NXSpd
      }
    }
  }
  NXSpd: ldy #$10
  sty SideCollisionTimer    ;set timer of some sort
  ldy #$00
  sty Player_X_Speed        ;nullify player's horizontal speed
  cmp #$00                  ;if value set in A not set to $ff,
  if (!BPL PlatF) {  // from NXSpd
  }
  // Block: ExIPM
  ExIPM: txa                       ;invert contents of X
  eor #$ff
  and Player_CollisionBits  ;mask out bit that was set here
  sta Player_CollisionBits  ;store to clear bit
  rts

def FindAreaPointer():
  // Block: FindAreaPointer
  ldy WorldNumber        ;load offset from world variable
  lda WorldAddrOffsets,y
  clc                    ;add area number used to find data
  adc AreaNumber
  tay
  lda AreaAddrOffsets,y  ;from there we have our area pointer
  rts

def EnemyToBGCollisionDet():
  // Block: EnemyToBGCollisionDet
  lda Enemy_State,x        ;check enemy state for d6 set
  and #%00100000
  bne ExEBG                ;if set, branch to leave
  jsr SubtEnemyYPos        ;otherwise, do a subroutine here
  bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
  ldy Enemy_ID,x
  cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
  if (!BNE DoIDCheckBGColl) {  // from @12406
    lda Enemy_Y_Position,x
    cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
    bcc ExEBG
  }
  cpy #GreenParatroopaJump ;check for some other enemy object
  if (!BNE HBChk) {  // from DoIDCheckBGColl
    jmp EnemyJump            ;otherwise jump elsewhere
  }
  HBChk: cpy #HammerBro           ;check for hammer bro
  if (!BNE CInvu) {  // from HBChk
  } else {
    CInvu: cpy #Spiny               ;if enemy object is spiny, branch
    if (!BEQ YesIn) {  // from CInvu
      cpy #PowerUpObject       ;if special power-up object, branch
      if (!BEQ YesIn) {  // from @12422
        cpy #$07                 ;if enemy object =>$07, branch to leave
        bcs ExEBGChk
      }
    }
    YesIn: jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
    if (!BNE HandleEToBGCollision) {  // from YesIn
    } else {
      do {  // loop13
        // Block: NoEToBGCollision
        jmp ChkForRedKoopa       ;otherwise skip and do something else
        // Block: HandleEToBGCollision
        jsr ChkForNonSolids       ;if something is underneath enemy, find out what
        beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
      } while (BEQ NoEToBGCollision)
      cmp #$23
      if (!BNE LandEnemyProperly) {  // from @12438
        ldy $02                   ;get vertical coordinate used to find block
        lda #$00                  ;store default blank metatile in that spot so we won't
        sta ($06),y               ;trigger this routine accidentally again
        lda Enemy_ID,x
        cmp #$15                  ;if enemy object => $15, branch ahead
        bcs ChkToStunEnemies
        cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
        if (!BNE GiveOEPoints) {  // from @12446
          jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
        }
        // Block: GiveOEPoints
        lda #$01                  ;award 100 points for hitting block beneath enemy
        jsr SetupFloateyNumber
      }
      lda $04                 ;check lower nybble of vertical coordinate saved earlier
      sec
      sbc #$08                ;subtract eight pixels
      cmp #$05                ;used to determine whether enemy landed from falling
      if (!BCS ChkForRedKoopa) {  // from LandEnemyProperly
        lda Enemy_State,x
        and #%01000000          ;branch if d6 in enemy state is set
        if (!BNE LandEnemyInitState) {  // from @12503
          lda Enemy_State,x
          asl                     ;branch if d7 in enemy state is not set
          if (!BCC ChkLandedEnemyState) {  // from @12506
            // Block: SChkA
            SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
          }
          do {  // loop23
            // Block: ChkLandedEnemyState
            lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
            beq SChkA
          } while (BEQ SChkA)
          cmp #$05                  ;if in state used by spiny's egg
          if (!BEQ ProcEnemyDirection) {  // from @12514
            cmp #$03                  ;if already in state used by koopas and buzzy beetles
            if (!BCS ExSteChk) {  // from @12516
              lda Enemy_State,x         ;load enemy state again (why?)
              cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
              if (!BNE ProcEnemyDirection) {  // from @12518
                lda #$10                  ;load default timer here
                ldy Enemy_ID,x            ;check enemy identifier for spiny
                cpy #Spiny
                if (!BNE SetForStn) {  // from @12521
                  lda #$00                  ;set timer for $00 if spiny
                }
                // Block: SetForStn
                SetForStn: sta EnemyIntervalTimer,x  ;set timer here
                lda #$03                  ;set state here, apparently used to render
                sta Enemy_State,x         ;upside-down koopas and buzzy beetles
                jsr EnemyLanding          ;then land it properly
                // Block: ExSteChk
                ExSteChk:  rts                       ;then leave
              }
            }
          }
          lda Enemy_ID,x            ;check enemy identifier for goomba
          cmp #Goomba               ;branch if found
          if (!BEQ LandEnemyInitState) {  // from ProcEnemyDirection
            cmp #Spiny                ;check for spiny
            if (!BNE InvtD) {  // from @12536
              lda #$01
              sta Enemy_MovingDir,x     ;send enemy moving to the right by default
              lda #$08
              sta Enemy_X_Speed,x       ;set horizontal speed accordingly
              lda FrameCounter
              and #%00000111            ;if timed appropriately, spiny will skip over
              if (!BEQ LandEnemyInitState) {  // from @12538
                InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
                jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
                if (!BPL CNwCDir) {  // from InvtD
                  iny                       ;if to the left, increment by one for enemy to face right (inverted)
                }
                CNwCDir: tya
                cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
                if (!BNE LandEnemyInitState) {  // from CNwCDir
                  jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
                }
              }
            }
            if (!BPL CNwCDir) {  // from InvtD
            }
            if (!BNE LandEnemyInitState) {  // from CNwCDir
            }
          }
        }
        jsr EnemyLanding       ;land enemy properly
        lda Enemy_State,x
        and #%10000000         ;if d7 of enemy state is set, branch
        if (!BNE NMovShellFallBit) {  // from LandEnemyInitState
          lda #$00               ;otherwise initialize enemy state and leave
          sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
          rts
        }
        // Block: NMovShellFallBit
        lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
        and #%10111111      ;and store, then leave
        sta Enemy_State,x
        rts
      }
    }
    lda Enemy_ID,x            ;check for red koopa troopa $03
    cmp #RedKoopa
    if (!BNE Chk2MSBSt) {  // from ChkForRedKoopa
      lda Enemy_State,x
      beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
    }
    Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
    tay
    asl                       ;check for d7 set
    if (!BCC GetSteFromD) {  // from Chk2MSBSt
      lda Enemy_State,x
      ora #%01000000            ;set d6
      jmp SetD6Ste              ;jump ahead of this part
    } else {
      // Block: GetSteFromD
      GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
    }
    // Block: SetD6Ste
    SetD6Ste:    sta Enemy_State,x         ;set as new state
    lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
    cmp #$20                   ;because there's nothing there that impedes movement
    if (!BCC ExESdeC) {  // from DoEnemySideCheck
      ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
      lda #$02                   ;set value here in what is also used as
      sta $eb                    ;OAM data offset
      NextSdeC: dec $eb                    ;move to the next direction
      iny
      cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
      while (!BCC SdeCLoop) {  // loop63
        lda #$01                   ;set flag in A for save horizontal coordinate
        jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
        if (!BEQ NextSdeC) {  // from @12601
          jsr ChkForNonSolids        ;check for non-solid blocks
          bne ChkForBump_HammerBroJ  ;branch if not found
        }
        do {  // loop62
          // Block: SdeCLoop
          SdeCLoop: lda $eb                    ;check value
          cmp Enemy_MovingDir,x      ;compare value against moving direction
          bne NextSdeC               ;branch if different and do not seek block there
        } while (BCC SdeCLoop)
      }
    }
    // Block: ExESdeC
    ExESdeC:  rts
  }
  jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
  if (!BEQ NoUnderHammerBro) {  // from HammerBroBGColl
    cmp #$23             ;check for blank metatile $23 and branch if not found
    if (!BNE UnderHammerBro) {  // from @12682
    }
    lda EnemyFrameTimer,x ;check timer used by hammer bro
    if (!BNE NoUnderHammerBro) {  // from UnderHammerBro
      loop {  // loop81 (infinite)
        // Block: DoEnemySideCheck
        lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
        cmp #$20                   ;because there's nothing there that impedes movement
        bcc ExESdeC
        lda Enemy_State,x
        and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
        sta Enemy_State,x     ;and store
        jsr EnemyLanding      ;modify vertical coordinate, speed and something else
        jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
      }
    }
  }
  // Block: NoUnderHammerBro
  lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
  ora #$01           ;in the enemy state to indicate jumping or falling, then leave
  sta Enemy_State,x
  rts

def FindEmptyEnemySlot():
  // Block: FindEmptyEnemySlot
  ldx #$00          ;start at first enemy slot
  inx
  cpx #$05          ;if nonzero, check next value
  while (!BNE EmptyChkLoop) {  // loop4
    do {  // loop3
      // Block: EmptyChkLoop
      EmptyChkLoop: clc               ;clear carry flag by default
      lda Enemy_Flag,x  ;check enemy buffer for nonzero
      beq ExitEmptyChk  ;if zero, leave
    } while (BNE EmptyChkLoop)
  }
  // Block: ExitEmptyChk
  ExitEmptyChk: rts               ;if all values nonzero, carry flag is set

def GetMiscBoundBox():
  // Block: GetMiscBoundBox
  txa                       ;add nine bytes to offset
  clc                       ;to use in routines as offset for misc object
  adc #$09
  tax
  ldy #$06                  ;set offset for relative coordinates
  // Block: FBallB
  FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
  jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates

def FloateyNumbersRoutine():
  // Block: EndExitOne
  EndExitOne:    rts                        ;and leave
  do {  // loop3
    // Block: FloateyNumbersRoutine
    lda FloateyNum_Control,x     ;load control for floatey number
    beq EndExitOne               ;if zero, branch to leave
  } while (BEQ EndExitOne)
  cmp #$0b                     ;if less than $0b, branch
  if (!BCC ChkNumTimer) {  // from @1285
    lda #$0b                     ;otherwise set to $0b, thus keeping
    sta FloateyNum_Control,x     ;it in range
  }
  ChkNumTimer:  tay                          ;use as Y
  lda FloateyNum_Timer,x       ;check value here
  if (!BNE DecNumTimer) {  // from ChkNumTimer
    sta FloateyNum_Control,x     ;initialize floatey number control and leave
    rts
  }
  DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
  cmp #$2b                     ;if not reached a certain point, branch
  if (!BNE ChkTallEnemy) {  // from DecNumTimer
    cpy #$0b                     ;check offset for $0b
    if (!BNE LoadNumTiles) {  // from @1297
      inc NumberofLives            ;give player one extra life (1-up)
      lda #Sfx_ExtraLife
      sta Square2SoundQueue        ;and play the 1-up sound
    }
    // Block: LoadNumTiles
    LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
    lsr                          ;move high nybble to low
    lsr
    lsr
    lsr
    tax                          ;use as X offset, essentially the digit
    lda ScoreUpdateData,y        ;load again and this time
    and #%00001111               ;mask out the high nybble
    sta DigitModifier,x          ;store as amount to add to the digit
    jsr AddToScore               ;update the score accordingly
  }
  ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
  lda Enemy_ID,x               ;get enemy object identifier
  cmp #Spiny
  if (!BEQ FloateyPart) {  // from ChkTallEnemy
    cmp #PiranhaPlant
    if (!BEQ FloateyPart) {  // from @1316
      cmp #HammerBro
      if (!BEQ GetAltOffset) {  // from @1318
        cmp #GreyCheepCheep
        if (!BEQ FloateyPart) {  // from @1320
          cmp #RedCheepCheep
          if (!BEQ FloateyPart) {  // from @1322
            cmp #TallEnemy
            if (!BCS GetAltOffset) {  // from @1324
              lda Enemy_State,x
              cmp #$02                     ;if enemy state defeated or otherwise
              if (!BCS FloateyPart) {  // from @1326
                // Block: GetAltOffset
                GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
                ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
                ldx ObjectOffset             ;get enemy object offset again
              }
            }
          }
        }
      }
    }
  }
  FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
  cmp #$18                     ;floatey number, if coordinate in the
  if (!BCC SetupNumSpr) {  // from FloateyPart
    sbc #$01
    sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
  }
  // Block: SetupNumSpr
  SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
  sbc #$08                     ;subtract eight and dump into the
  jsr DumpTwoSpr               ;left and right sprite's Y coordinates
  lda FloateyNum_X_Pos,x       ;get horizontal coordinate
  sta Sprite_X_Position,y      ;store into X coordinate of left sprite
  clc
  adc #$08                     ;add eight pixels and store into X
  sta Sprite_X_Position+4,y    ;coordinate of right sprite
  lda #$02
  sta Sprite_Attributes,y      ;set palette control in attribute bytes
  sta Sprite_Attributes+4,y    ;of left and right sprites
  lda FloateyNum_Control,x
  asl                          ;multiply our floatey number control by 2
  tax                          ;and use as offset for look-up table
  lda FloateyNumTileData,x
  sta Sprite_Tilenumber,y      ;display first half of number of points
  lda FloateyNumTileData+1,x
  sta Sprite_Tilenumber+4,y    ;display the second half
  ldx ObjectOffset             ;get enemy object offset and leave
  rts

def JumpEngine():
  // Block: JumpEngine
  asl          ;shift bit from contents of A
  tay
  pla          ;pull saved return address from stack
  sta $04      ;save to indirect
  pla
  sta $05
  iny
  lda ($04),y  ;load pointer from indirect
  sta $06      ;note that if an RTS is performed in next routine
  iny          ;it will return to the execution before the sub
  lda ($04),y  ;that called this routine
  sta $07
  jmp ($06)    ;jump to the address we loaded

def KillEnemyAboveBlock():
  // Block: KillEnemyAboveBlock
  jsr ShellOrBlockDefeat  ;do this sub to kill enemy
  lda #$fc                ;alter vertical speed of enemy and leave
  sta Enemy_Y_Speed,x
  rts

def GetBlockOffscreenBits():
  // Block: GetBlockOffscreenBits
  lda #$09       ;set A to add 9 bytes in order to get block obj offset
  ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
  // Block: SetOffscrBitsOffset
  stx $00
  clc           ;add contents of X to A to get
  adc $00       ;appropriate offset, then give back to X
  tax

def GetEnemyBoundBox():
  // Block: GetEnemyBoundBox
  ldy #$48                 ;store bitmask here for now
  sty $00
  ldy #$44                 ;store another bitmask here for now and jump
  jmp GetMaskedOffScrBits
  lda Enemy_X_Position,x      ;get enemy object position relative
  sec                         ;to the left side of the screen
  sbc ScreenLeft_X_Pos
  sta $01                     ;store here
  lda Enemy_PageLoc,x         ;subtract borrow from current page location
  sbc ScreenLeft_PageLoc      ;of left side
  if (!BMI CMBits) {  // from GetMaskedOffScrBits
    ora $01
    if (!BEQ CMBits) {  // from @12815
      ldy $00                     ;if to the right of left edge, use value in $00 for A
    }
  }
  CMBits: tya                         ;otherwise use contents of Y
  and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
  sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
  if (!BNE MoveBoundBoxOffscreen) {  // from CMBits
    jmp SetupEOffsetFBBox       ;otherwise, do something else
    // Block: SetupEOffsetFBBox
    txa                        ;add 1 to offset to properly address
    clc                        ;the enemy object memory locations
    adc #$01
    tax
    ldy #$01                   ;load 1 as offset here, same reason
    jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
    jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
  } else {
    // Block: MoveBoundBoxOffscreen
    txa                            ;multiply offset by 4
    asl
    asl
    tay                            ;use as offset here
    lda #$ff
    sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
    sta EnemyBoundingBoxCoord+1,y
    sta EnemyBoundingBoxCoord+2,y
    sta EnemyBoundingBoxCoord+3,y
    rts
  }
  lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
  clc                        ;and store as horizontal coordinate of middle
  adc #$80
  sta $02
  lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
  adc #$00                   ;and store as page location of middle
  sta $01
  lda SprObject_X_Position,x ;get horizontal coordinate
  cmp $02                    ;compare against middle horizontal coordinate
  lda SprObject_PageLoc,x    ;get page location
  sbc $01                    ;subtract from middle page location
  if (!BCC CheckLeftScreenBBox) {  // from CheckRightScreenBBox
    lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
    if (!BMI NoOfs) {  // from @12903
      lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
      ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
      if (!BMI SORte) {  // from @12905
        sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
      }
      // Block: SORte
      SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
    }
    // Block: NoOfs
    NoOfs: ldx ObjectOffset           ;get object offset and leave
    rts
  }
  lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
  if (!BPL NoOfs2) {  // from CheckLeftScreenBBox
    cmp #$a0                   ;check to see if left-side edge is in the middle of the
    if (!BCC NoOfs2) {  // from @12916
      lda #$00
      ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
      if (!BPL SOLft) {  // from @12918
        sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
      }
      // Block: SOLft
      SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
    }
  }
  // Block: NoOfs2
  NoOfs2: ldx ObjectOffset           ;get object offset and leave
  rts

def GetBlockBufferAddr():
  // Block: GetBlockBufferAddr
  pha                      ;take value of A, save
  lsr                      ;move high nybble to low
  lsr
  lsr
  lsr
  tay                      ;use nybble as pointer to high byte
  lda BlockBufferAddr+2,y  ;of indirect here
  sta $07
  pla
  and #%00001111           ;pull from stack, mask out high nybble
  clc
  adc BlockBufferAddr,y    ;add to low byte
  sta $06                  ;store here and leave
  rts

def PrintStatusBarNumbers():
  // Block: PrintStatusBarNumbers
  sta $00            ;store player-specific offset
  jsr OutputNumbers  ;use first nybble to print the coin display
  lda $00            ;move high nybble to low
  lsr                ;and print to score display
  lsr
  lsr
  lsr

def BlockBumpedChk():
  // Block: BlockBumpedChk
  ldy #$0d                    ;start at end of metatile data
  dey                         ;otherwise move onto next metatile
  while (!BPL BumpChkLoop) {  // loop4
    do {  // loop3
      // Block: BumpChkLoop
      BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
      beq MatchBump               ;metatile found in block buffer, branch if so
    } while (BPL BumpChkLoop)
  }
  clc                         ;if none match, return with carry clear
  // Block: MatchBump
  MatchBump:   rts                         ;note carry is set if found match

def DrawFirebar():
  lda FrameCounter         ;get frame counter
  lsr                      ;divide by four
  lsr
  pha                      ;save result to stack
  and #$01                 ;mask out all but last bit
  eor #$64                 ;set either tile $64 or $65 as fireball tile
  sta Sprite_Tilenumber,y  ;thus tile changes every four frames
  pla                      ;get from stack
  lsr                      ;divide by four again
  lsr
  lda #$02                 ;load value $02 to set palette in attrib byte
  if (!BCC FireA) {  // from DrawFirebar
    ora #%11000000           ;otherwise flip both ways every eight frames
  }
  // Block: FireA
  FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
  rts

def BlockBufferColli_Feet():
  // Block: BlockBufferColli_Feet
  iny            ;if branched here, increment to next set of adders

def DigitsMathRoutine():
  lda OperMode              ;check mode of operation
  cmp #TitleScreenModeValue
  if (!BEQ EraseDMods) {  // from DigitsMathRoutine
    ldx #$05
    AddModLoop: lda DigitModifier,x       ;load digit amount to increment
    clc
    adc DisplayDigits,y       ;add to current digit
    while (!BMI BorrowOne) {  // loop13
      cmp #10
      if (!BCS CarryOne) {  // from @2591
        StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
        dey                       ;move onto next digits in score or game timer
        dex                       ;and digit amounts to increment
        while (!BPL AddModLoop) {  // loop11
          // Block: EraseDMods
          EraseDMods: lda #$00                  ;store zero here
          ldx #$06                  ;start with the last digit
          do {  // loop3
            // Block: EraseMLoop
            EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
            dex
            bpl EraseMLoop            ;do this until they're all reset, then leave
          } while (!BPL EraseMLoop)
          rts
          do {  // loop10
            // Block: BorrowOne
            BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
            lda #$09                  ;the game timer digit we're currently on to "borrow
            bne StoreNewD             ;the one", then do an unconditional branch back
          } while (BNE StoreNewD)
        }
      }
    }
  }
  do {  // loop17
  } while (!BPL EraseMLoop)
  do {  // loop24
  } while (BNE StoreNewD)
  loop {  // loop31 (infinite)
    // Block: CarryOne
    CarryOne:   sec                       ;subtract ten from our digit to make it a
    sbc #10                   ;proper BCD number, then increment the digit
    inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
    jmp StoreNewD             ;go back to just after we branched here
  }

def GetXOffscreenBits():
  // Block: GetXOffscreenBits
  stx $04                     ;save position in buffer to here
  ldy #$01                    ;start with right side of screen
  dey                         ;otherwise, do left side of screen now
  while (!BPL XOfsLoop) {  // loop10
    ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
    cmp #$01
    if (!BPL XLdBData) {  // from @14920
      lda #$38                    ;if no branching, load value here and store
      sta $06
      lda #$08                    ;load some other value and execute subroutine
      jsr DividePDiff
    }
    XLdBData: lda XOffscreenBitsData,x    ;get bits here
    ldx $04                     ;reobtain position in buffer
    cmp #$00                    ;if bits not zero, branch to leave
    if (!BNE ExXOfsBS) {  // from XLdBData
      do {  // loop8
        // Block: XOfsLoop
        XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
        sec                         ;get difference between pixel coordinate of edge
        sbc SprObject_X_Position,x  ;and pixel coordinate of object position
        sta $07                     ;store here
        lda ScreenEdge_PageLoc,y    ;get page location of edge
        sbc SprObject_PageLoc,x     ;subtract from page location of object position
        ldx DefaultXOnscreenOfs,y   ;load offset value here
        cmp #$00
        bmi XLdBData                ;if beyond right edge or in front of left edge, branch
      } while (BPL XOfsLoop)
    }
  }
  // Block: ExXOfsBS
  ExXOfsBS: rts

def PlayerBGCollision():
  lda DisableCollisionDet   ;if collision detection disabled flag set,
  if (!BNE ExPBGCol) {  // from PlayerBGCollision
    lda GameEngineSubroutine
    cmp #$0b                  ;if running routine #11 or $0b
    if (!BEQ ExPBGCol) {  // from @11904
      cmp #$04
      if (!BCC ExPBGCol) {  // from @11907
        lda #$01                  ;load default player state for swimming
        ldy SwimmingFlag          ;if swimming flag set,
        if (!BNE SetPSte) {  // from @11909
          lda Player_State          ;if player in normal state,
          if (!BEQ SetFallS) {  // from @11912
            cmp #$03
            if (!BNE ChkOnScr) {  // from @11914
              // Block: SetFallS
              SetFallS: lda #$02                  ;load default player state for falling
              // Block: SetPSte
              SetPSte:  sta Player_State          ;set whatever player state is appropriate
            }
          }
        }
        ChkOnScr: lda Player_Y_HighPos
        cmp #$01                  ;check player's vertical high byte for still on the screen
        if (!BNE ExPBGCol) {  // from ChkOnScr
          lda #$ff
          sta Player_CollisionBits  ;initialize player's collision flag
          lda Player_Y_Position
          cmp #$cf                  ;check player's vertical coordinate
          if (!BCC ChkCollSize) {  // from @11921
            // Block: ExPBGCol
            ExPBGCol: rts                       ;otherwise leave
          }
        }
      }
    }
  }
  ldy #$02                    ;load default offset
  lda CrouchingFlag
  if (!BNE GBBAdr) {  // from ChkCollSize
    lda PlayerSize
    if (!BNE GBBAdr) {  // from @11932
      dey                         ;otherwise decrement offset for big player not crouching
      lda SwimmingFlag
      if (!BNE GBBAdr) {  // from @11934
        dey                         ;otherwise decrement offset
      }
    }
  }
  GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
  sta $eb                     ;store value here
  tay                         ;put value into Y, as offset for block buffer routine
  ldx PlayerSize              ;get player's size as offset
  lda CrouchingFlag
  if (!BEQ HeadChk) {  // from GBBAdr
    inx                         ;otherwise increment size as offset
  }
  HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
  cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
  if (!BCC DoFootCheck) {  // from HeadChk
    jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
    if (!BEQ DoFootCheck) {  // from @11948
      jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
      if (!BCS AwardTouchedCoin) {  // from @11950
        ldy Player_Y_Speed          ;check player's vertical speed
        if (!BPL DoFootCheck) {  // from @11952
          ldy $04                     ;check lower nybble of vertical coordinate returned
          cpy #$04                    ;from collision detection routine
          if (!BCC DoFootCheck) {  // from @11954
            jsr CheckForSolidMTiles     ;check to see what player's head bumped on
            if (!BCS SolidOrClimb) {  // from @11957
              ldy AreaType                ;otherwise check area type
              if (!BEQ NYSpd) {  // from @11959
                ldy BlockBounceTimer        ;if block bounce timer not expired,
                if (!BNE NYSpd) {  // from @11961
                  jsr PlayerHeadCollision     ;otherwise do a sub to process collision
                  jmp DoFootCheck             ;jump ahead to skip these other parts here
                  cmp #$26               ;if climbing metatile,
                  if (!BEQ NYSpd) {  // from SolidOrClimb
                    lda #Sfx_Bump
                    sta Square1SoundQueue  ;otherwise load bump sound
                  }
                }
              }
            } else {
              if (!BEQ NYSpd) {  // from SolidOrClimb
              }
              // Block: NYSpd
              NYSpd: lda #$01               ;set player's vertical speed to nullify
              sta Player_Y_Speed     ;jump or swim
            }
          }
        }
        ldy $eb                    ;get block buffer adder offset
        lda Player_Y_Position
        cmp #$cf                   ;check to see how low player is
        if (!BCS DoPlayerSideCheck) {  // from DoFootCheck
          jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
          jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
          if (!BCS AwardTouchedCoin) {  // from @11979
            pha                        ;save bottom left metatile to stack
            jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
            sta $00                    ;save bottom right metatile here
            pla
            sta $01                    ;pull bottom left metatile and save here
            if (!BNE ChkFootMTile) {  // from @11982
              lda $00                    ;otherwise check for anything in bottom right metatile
              if (!BEQ DoPlayerSideCheck) {  // from @11988
                jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
                if (!BCC ChkFootMTile) {  // from @11990
                  // Block: AwardTouchedCoin
                  jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
                }
                jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
                if (!BCS DoPlayerSideCheck) {  // from ChkFootMTile
                  ldy Player_Y_Speed         ;check player's vertical speed
                  if (!BMI DoPlayerSideCheck) {  // from @11999
                    cmp #$c5
                    if (!BNE ContChk) {  // from @12001
                      jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
                    }
                    ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
                    if (!BEQ DoPlayerSideCheck) {  // from ContChk
                      ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
                      if (!BNE InitSteP) {  // from @12006
                        ldy $04                    ;check lower nybble of vertical coordinate returned
                        cpy #$05                   ;from collision detection routine
                        if (!BCC LandPlyr) {  // from @12008
                          lda Player_MovingDir
                          sta $00                    ;use player's moving direction as temp variable
                          jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
                        }
                        // Block: LandPlyr
                        LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
                        lda #$f0
                        and Player_Y_Position      ;mask out lower nybble of player's vertical position
                        sta Player_Y_Position      ;and store as new vertical position to land player properly
                        jsr HandlePipeEntry        ;do sub to process potential pipe entry
                        lda #$00
                        sta Player_Y_Speed         ;initialize vertical speed and fractional
                        sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
                        sta StompChainCounter      ;initialize enemy stomp counter
                      }
                      // Block: InitSteP
                      InitSteP: lda #$00
                      sta Player_State           ;set player's state to normal
                    }
                  }
                }
              }
            }
          }
          if (!BCS DoPlayerSideCheck) {  // from ChkFootMTile
            if (!BMI DoPlayerSideCheck) {  // from @11999
              if (!BNE ContChk) {  // from @12001
              }
              if (!BEQ DoPlayerSideCheck) {  // from ContChk
                if (!BNE InitSteP) {  // from @12006
                  if (!BCC LandPlyr) {  // from @12008
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ldy $eb                    ;get block buffer adder offset
  lda Player_Y_Position
  cmp #$cf                   ;check to see how low player is
  if (!BCS DoPlayerSideCheck) {  // from DoFootCheck
    jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
    jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
    if (!BCS AwardTouchedCoin) {  // from @11979
      pha                        ;save bottom left metatile to stack
      jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
      sta $00                    ;save bottom right metatile here
      pla
      sta $01                    ;pull bottom left metatile and save here
      if (!BNE ChkFootMTile) {  // from @11982
        lda $00                    ;otherwise check for anything in bottom right metatile
        if (!BEQ DoPlayerSideCheck) {  // from @11988
          jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
          if (!BCC ChkFootMTile) {  // from @11990
          }
          jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
          if (!BCS DoPlayerSideCheck) {  // from ChkFootMTile
            ldy Player_Y_Speed         ;check player's vertical speed
            if (!BMI DoPlayerSideCheck) {  // from @11999
              cmp #$c5
              if (!BNE ContChk) {  // from @12001
              }
              ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
              if (!BEQ DoPlayerSideCheck) {  // from ContChk
                ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
                if (!BNE InitSteP) {  // from @12006
                  ldy $04                    ;check lower nybble of vertical coordinate returned
                  cpy #$05                   ;from collision detection routine
                  if (!BCC LandPlyr) {  // from @12008
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!BCS DoPlayerSideCheck) {  // from ChkFootMTile
      if (!BMI DoPlayerSideCheck) {  // from @11999
        if (!BNE ContChk) {  // from @12001
        }
        if (!BEQ DoPlayerSideCheck) {  // from ContChk
          if (!BNE InitSteP) {  // from @12006
            if (!BCC LandPlyr) {  // from @12008
            }
          }
        }
      }
    }
  }
  // Block: DoPlayerSideCheck
  ldy $eb       ;get block buffer adder offset
  iny
  iny           ;increment offset 2 bytes to use adders for side collisions
  lda #$02      ;set value here to be used as counter
  sta $00
  dec $00                   ;otherwise decrement counter
  while (!BNE SideCheckLoop) {  // loop127
    cmp #$e4
    if (!BCS ExSCH) {  // from @12039
      jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
      if (!BEQ BHalf) {  // from @12041
        cmp #$1c                  ;otherwise check for pipe metatiles
        if (!BEQ BHalf) {  // from @12043
          cmp #$6b
          if (!BEQ BHalf) {  // from @12045
            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
            if (!BCC CheckSideMTiles) {  // from @12047
              BHalf: ldy $eb                   ;load block adder offset
              iny                       ;increment it
              lda Player_Y_Position     ;get player's vertical position
              cmp #$08
              if (!BCC ExSCH) {  // from BHalf
                cmp #$d0
                if (!BCS ExSCH) {  // from @12054
                  jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
                  if (!BNE CheckSideMTiles) {  // from @12056
                    do {  // loop101
                      // Block: SideCheckLoop
                      iny                       ;move onto the next one
                      sty $eb                   ;store it
                      lda Player_Y_Position
                      cmp #$20                  ;check player's vertical position
                      bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
                    } while (BNE SideCheckLoop)
                    // Block: ExSCH
                    ExSCH: rts                       ;leave
                  }
                }
              }
            }
          }
        }
      }
      if (!BCC ExSCH) {  // from BHalf
        if (!BCS ExSCH) {  // from @12054
          if (!BNE CheckSideMTiles) {  // from @12056
            do {  // loop121
            } while (BNE SideCheckLoop)
          }
        }
      }
    }
  }
  jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
  if (!BEQ ExCSM) {  // from CheckSideMTiles
    jsr CheckForClimbMTiles    ;check for climbable metatiles
    if (!BCC ContSChk) {  // from @12065
      jmp HandleClimbing         ;otherwise jump to handle climbing
    }
    ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
    if (!BCS HandleCoinMetatile) {  // from ContSChk
      jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
      if (!BCC ChkPBtm) {  // from @12070
        lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
        if (!BNE ExCSM) {  // from @12072
          jmp StopPlayerMove         ;otherwise jump to impede player's movement
          ChkPBtm:  ldy Player_State           ;get player's state
          cpy #$00                   ;check for player's state set to normal
          if (!BNE StopPlayerMove) {  // from ChkPBtm
            ldy PlayerFacingDir        ;get player's facing direction
            dey
            if (!BNE StopPlayerMove) {  // from @12078
              cmp #$6c                   ;otherwise check for pipe metatiles
              if (!BEQ PipeDwnS) {  // from @12081
                cmp #$1f                   ;if collided with water pipe (bottom), continue
                if (!BNE StopPlayerMove) {  // from @12083
                  PipeDwnS: lda Player_SprAttrib       ;check player's attributes
                  if (!BNE PlyrPipe) {  // from PipeDwnS
                    ldy #Sfx_PipeDown_Injury
                    sty Square1SoundQueue      ;otherwise load pipedown/injury sound
                  }
                  PlyrPipe: ora #%00100000
                  sta Player_SprAttrib       ;set background priority bit in player attributes
                  lda Player_X_Position
                  and #%00001111             ;get lower nybble of player's horizontal coordinate
                  if (!BEQ ChkGERtn) {  // from PlyrPipe
                    ldy #$00                   ;set default offset for timer setting data
                    lda ScreenLeft_PageLoc     ;load page location for left side of screen
                    if (!BEQ SetCATmr) {  // from @12094
                      iny                        ;otherwise increment offset
                    }
                    // Block: SetCATmr
                    SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
                    sta ChangeAreaTimer
                  }
                  ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
                  cmp #$07
                  if (!BEQ ExCSM) {  // from ChkGERtn
                    cmp #$08                   ;player control routine, go ahead and branch to leave
                    if (!BNE ExCSM) {  // from @12103
                      lda #$02
                      sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
                      rts                        ;and leave
                      // Block: StopPlayerMove
                      jsr ImpedePlayerMove      ;stop player's movement
                    }
                  }
                }
              }
              if (!BNE PlyrPipe) {  // from PipeDwnS
              }
              if (!BEQ ChkGERtn) {  // from PlyrPipe
                if (!BEQ SetCATmr) {  // from @12094
                }
              }
              if (!BEQ ExCSM) {  // from ChkGERtn
                if (!BNE ExCSM) {  // from @12103
                }
              }
            }
          }
        }
      } else {
        if (!BNE StopPlayerMove) {  // from ChkPBtm
          if (!BNE StopPlayerMove) {  // from @12078
            if (!BEQ PipeDwnS) {  // from @12081
              if (!BNE StopPlayerMove) {  // from @12083
                if (!BNE PlyrPipe) {  // from PipeDwnS
                }
                if (!BEQ ChkGERtn) {  // from PlyrPipe
                  if (!BEQ SetCATmr) {  // from @12094
                  }
                }
                if (!BEQ ExCSM) {  // from ChkGERtn
                  if (!BNE ExCSM) {  // from @12103
                  }
                }
              }
            }
            if (!BNE PlyrPipe) {  // from PipeDwnS
            }
            if (!BEQ ChkGERtn) {  // from PlyrPipe
              if (!BEQ SetCATmr) {  // from @12094
              }
            }
            if (!BEQ ExCSM) {  // from ChkGERtn
              if (!BNE ExCSM) {  // from @12103
              }
            }
          }
        }
      }
      // Block: ExCSM
      ExCSM: rts                       ;leave
    }
  }
  // Block: HandleCoinMetatile
  jsr ErACM             ;do sub to erase coin metatile from block buffer
  inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
  jmp GiveOneCoin       ;update coin amount and tally on the screen
  // Block: HandleAxeMetatile
  lda #$00
  sta OperMode_Task   ;reset secondary mode
  lda #$02
  sta OperMode        ;set primary mode to autoctrl mode
  lda #$18
  sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
  ldy $04            ;check low nybble of horizontal coordinate returned from
  cpy #$06           ;collision detection routine against certain values, this
  if (!BCC ExHC) {  // from HandleClimbing
    cpy #$0a           ;than 16 pixels
    if (!BCC ChkForFlagpole) {  // from @12156
      // Block: ExHC
      ExHC: rts                ;leave if too far left or too far right
    }
  }
  cmp #$24               ;check climbing metatiles
  if (!BEQ FlagpoleCollision) {  // from ChkForFlagpole
    cmp #$25
    if (!BNE VineCollision) {  // from @12163
      lda GameEngineSubroutine
      cmp #$05                  ;check for end-of-level routine running
      if (!BEQ PutPlayerOnVine) {  // from FlagpoleCollision
        lda #$01
        sta PlayerFacingDir       ;set player's facing direction to right
        inc ScrollLock            ;set scroll lock flag
        lda GameEngineSubroutine
        cmp #$04                  ;check for flagpole slide routine running
        if (!BEQ RunFR) {  // from @12170
          lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
          jsr KillEnemies           ;get rid of them
          lda #Silence
          sta EventMusicQueue       ;silence music
          lsr
          sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
          ldx #$04                  ;start at end of vertical coordinate data
          lda Player_Y_Position
          sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
          dex                       ;otherwise decrement offset to use
          while (!BNE ChkFlagpoleYPosLoop) {  // loop199
            do {  // loop198
              // Block: ChkFlagpoleYPosLoop
              cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
              bcs MtchF                 ;if player's => current, branch to use current offset
            } while (BNE ChkFlagpoleYPosLoop)
          }
          // Block: MtchF
          MtchF: stx FlagpoleScore         ;store offset here to be used later
        }
        // Block: RunFR
        RunFR: lda #$04
        sta GameEngineSubroutine  ;set value to run flagpole slide routine
        jmp PutPlayerOnVine       ;jump to end of climbing code
        cmp #$26                  ;check for climbing metatile used on vines
        if (!BNE PutPlayerOnVine) {  // from VineCollision
          lda Player_Y_Position     ;check player's vertical coordinate
          cmp #$20                  ;for being in status bar area
          if (!BCS PutPlayerOnVine) {  // from @12199
            lda #$01
            sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
          }
        }
      }
    }
  }
  lda GameEngineSubroutine
  cmp #$05                  ;check for end-of-level routine running
  if (!BEQ PutPlayerOnVine) {  // from FlagpoleCollision
    lda #$01
    sta PlayerFacingDir       ;set player's facing direction to right
    inc ScrollLock            ;set scroll lock flag
    lda GameEngineSubroutine
    cmp #$04                  ;check for flagpole slide routine running
    if (!BEQ RunFR) {  // from @12170
      dex                       ;otherwise decrement offset to use
      while (!BNE ChkFlagpoleYPosLoop) {  // loop213
        do {  // loop212
        } while (BNE ChkFlagpoleYPosLoop)
      }
    }
    cmp #$26                  ;check for climbing metatile used on vines
    if (!BNE PutPlayerOnVine) {  // from VineCollision
      lda Player_Y_Position     ;check player's vertical coordinate
      cmp #$20                  ;for being in status bar area
      if (!BCS PutPlayerOnVine) {  // from @12199
      }
    }
  }
  lda #$03                ;set player state to climbing
  sta Player_State
  lda #$00                ;nullify player's horizontal speed
  sta Player_X_Speed      ;and fractional horizontal movement force
  sta Player_X_MoveForce
  lda Player_X_Position   ;get player's horizontal coordinate
  sec
  sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
  cmp #$10
  if (!BCS SetVXPl) {  // from PutPlayerOnVine
    lda #$02
    sta PlayerFacingDir     ;otherwise force player to face left
  }
  SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
  lda $06                 ;get low byte of block buffer address
  asl
  asl                     ;move low nybble to high
  asl
  asl
  clc
  adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
  sta Player_X_Position   ;store as player's horizontal coordinate
  lda $06                 ;get low byte of block buffer address again
  if (!BNE ExPVne) {  // from SetVXPl
    lda ScreenRight_PageLoc ;load page location of right side of screen
    clc
    adc ClimbPLocAdder-1,y  ;add depending on facing location
    sta Player_PageLoc      ;store as player's page location
  }
  // Block: ExPVne
  ExPVne:  rts                     ;finally, we're done!

def ResetPalStar():
  // Block: ResetPalStar
  lda Player_SprAttrib  ;get player attributes
  and #%11111100        ;mask out palette bits to force palette 0
  sta Player_SprAttrib  ;store as new player attributes
  rts                   ;and leave

def RemoveCoin_Axe():
  ldy #$41                 ;set low byte so offset points to $0341
  lda #$03                 ;load offset for default blank metatile
  ldx AreaType             ;check area type
  if (!BNE WriteBlankMT) {  // from RemoveCoin_Axe
    lda #$04                 ;otherwise load offset for blank metatile used in water
  }
  // Block: WriteBlankMT
  WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
  lda #$06
  sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
  rts

def ImposeGravityBlock():
  // Block: ImposeGravityBlock
  ldy #$01       ;set offset for maximum speed
  lda #$50       ;set movement amount here
  sta $00
  lda MaxSpdBlockData,y    ;get maximum speed

def CheckPlayerVertical():
  lda Player_OffscreenBits  ;if player object is completely offscreen
  cmp #$f0                  ;vertically, leave this routine
  if (!BCS ExCPV) {  // from CheckPlayerVertical
    ldy Player_Y_HighPos      ;if player high vertical byte is not
    dey                       ;within the screen, leave this routine
    if (!BNE ExCPV) {  // from @11870
      lda Player_Y_Position     ;if on the screen, check to see how far down
      cmp #$d0                  ;the player is vertically
    }
  }
  // Block: ExCPV
  ExCPV: rts

def ErACM():
  // Block: ErACM
  ErACM: ldy $02             ;load vertical high nybble offset for block buffer
  lda #$00            ;load blank metatile
  sta ($06),y         ;store to remove old contents from block buffer
  jmp RemoveCoin_Axe  ;update the screen accordingly

def MoveJ_EnemyVertically():
  // Block: MoveJ_EnemyVertically
  ldy #$1c                ;set movement amount for podoboo/other objects

def TerminateGame():
  lda #Silence          ;silence music
  sta EventMusicQueue
  jsr TransposePlayers  ;check if other player can keep
  if (!BCC ContinueGame) {  // from TerminateGame
    lda WorldNumber       ;otherwise put world number of current
    sta ContinueWorld     ;player into secret continue function variable
    lda #$00
    asl                   ;residual ASL instruction
    sta OperMode_Task     ;reset all modes to title screen and
    sta ScreenTimer       ;leave
    sta OperMode
    rts
  }
  // Block: ContinueGame
  jsr LoadAreaPointer       ;update level pointer with
  lda #$01                  ;actual world and area numbers, then
  sta PlayerSize            ;reset player's size, status, and
  inc FetchNewGameTimerFlag ;set game timer flag to reload
  lda #$00                  ;game timer from header
  sta TimerControl          ;also set flag for timers to count again
  sta PlayerStatus
  sta GameEngineSubroutine  ;reset task for game core
  sta OperMode_Task         ;set modes and leave
  lda #$01                  ;if in game over mode, switch back to
  sta OperMode              ;game mode, because game is still on
  // Block: GameIsOn
  GameIsOn:  rts

def PositionPlayerOnHPlat():
  lda Player_X_Position
  clc                       ;add saved value from second subroutine to
  adc $00                   ;current player's position to position
  sta Player_X_Position     ;player accordingly in horizontal position
  lda Player_PageLoc        ;get player's page location
  ldy $00                   ;check to see if saved value here is positive or negative
  if (!BMI PPHSubt) {  // from PositionPlayerOnHPlat
    adc #$00                  ;otherwise add carry to page location
    jmp SetPVar               ;jump to skip subtraction
  } else {
    // Block: PPHSubt
    PPHSubt: sbc #$00                  ;subtract borrow from page location
  }
  // Block: SetPVar
  SetPVar: sta Player_PageLoc        ;save result to player's page location
  sty Platform_X_Scroll     ;put saved value from second sub here to be used later
  jsr PositionPlayerOnVPlat ;position player vertically and appropriately
  // Block: ExXMP
  ExXMP:   rts                       ;and we are done here

def EraseEnemyObject():
  // Block: EraseEnemyObject
  lda #$00                 ;clear all enemy object variables
  sta Enemy_Flag,x
  sta Enemy_ID,x
  sta Enemy_State,x
  sta FloateyNum_Control,x
  sta EnemyIntervalTimer,x
  sta ShellChainCounter,x
  sta Enemy_SprAttrib,x
  sta EnemyFrameTimer,x
  rts

def ChkLeftCo():
  // Block: ChkLeftCo
  ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
  beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen

def FireballBGCollision():
  lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
  cmp #$18
  if (!BCC ClearBounceFlag) {  // from FireballBGCollision
    jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
    if (!BEQ ClearBounceFlag) {  // from @12729
      jsr ChkForNonSolids         ;check for non-solid metatiles
      if (!BEQ ClearBounceFlag) {  // from @12731
        lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
        if (!BMI InitFireballExplode) {  // from @12733
          lda FireballBouncingFlag,x  ;if bouncing flag already set,
          if (!BNE InitFireballExplode) {  // from @12735
            lda #$fd
            sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
            lda #$01
            sta FireballBouncingFlag,x  ;set bouncing flag
            lda Fireball_Y_Position,x
            and #$f8                    ;modify vertical coordinate to land it properly
            sta Fireball_Y_Position,x   ;store as new vertical coordinate
            rts                         ;leave
            // Block: ClearBounceFlag
            lda #$00
            sta FireballBouncingFlag,x  ;clear bouncing flag by default
            rts                         ;leave
          }
        }
      }
    }
  }
  // Block: InitFireballExplode
  lda #$80
  sta Fireball_State,x        ;set exploding flag in fireball's state
  lda #Sfx_Bump
  sta Square1SoundQueue       ;load bump sound
  rts                         ;leave

def XMoveCntr_GreenPTroopa():
  // Block: XMoveCntr_GreenPTroopa
  lda #$13                    ;load preset maximum value for secondary counter

def RunOffscrBitsSubs():
  // Block: RunOffscrBitsSubs
  jsr GetXOffscreenBits  ;do subroutine here
  lsr                    ;move high nybble to low
  lsr
  lsr
  lsr
  sta $00                ;store here
  jmp GetYOffscreenBits
  // Block: GetYOffscreenBits
  stx $04                      ;save position in buffer to here
  ldy #$01                     ;start with top of screen
  dey                          ;otherwise, do bottom of the screen now
  while (!BPL YOfsLoop) {  // loop11
    ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
    cmp #$01
    if (!BPL YLdBData) {  // from @14960
      lda #$20                     ;if no branching, load value here and store
      sta $06
      lda #$04                     ;load some other value and execute subroutine
      jsr DividePDiff
    }
    YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
    ldx $04                      ;reobtain position in buffer
    cmp #$00
    if (!BNE ExYOfsBS) {  // from YLdBData
      do {  // loop9
        // Block: YOfsLoop
        YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
        sec
        sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
        sta $07                      ;store here
        lda #$01                     ;subtract one from vertical high byte of object
        sbc SprObject_Y_HighPos,x
        ldx DefaultYOnscreenOfs,y    ;load offset value here
        cmp #$00
        bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
      } while (BPL YOfsLoop)
    }
  }
  // Block: ExYOfsBS
  ExYOfsBS: rts

def DrawExplosion_Fireworks():
  // Block: DrawExplosion_Fireworks
  tax                         ;use whatever's in A for offset
  lda ExplosionTiles,x        ;get tile number using offset
  iny                         ;increment Y (contains sprite data offset)
  jsr DumpFourSpr             ;and dump into tile number part of sprite data
  dey                         ;decrement Y so we have the proper offset again
  ldx ObjectOffset            ;return enemy object buffer offset to X
  lda Fireball_Rel_YPos       ;get relative vertical coordinate
  sec                         ;subtract four pixels vertically
  sbc #$04                    ;for first and third sprites
  sta Sprite_Y_Position,y
  sta Sprite_Y_Position+8,y
  clc                         ;add eight pixels vertically
  adc #$08                    ;for second and fourth sprites
  sta Sprite_Y_Position+4,y
  sta Sprite_Y_Position+12,y
  lda Fireball_Rel_XPos       ;get relative horizontal coordinate
  sec                         ;subtract four pixels horizontally
  sbc #$04                    ;for first and second sprites
  sta Sprite_X_Position,y
  sta Sprite_X_Position+4,y
  clc                         ;add eight pixels horizontally
  adc #$08                    ;for third and fourth sprites
  sta Sprite_X_Position+8,y
  sta Sprite_X_Position+12,y
  lda #$02                    ;set palette attributes for all sprites, but
  sta Sprite_Attributes,y     ;set no flip at all for first sprite
  lda #$82
  sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
  lda #$42
  sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
  lda #$c2
  sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
  rts                         ;we are done

def SetStun():
  SetStun:  lda Enemy_State,x          ;load enemy state
  and #%11110000             ;save high nybble
  ora #%00000010
  sta Enemy_State,x          ;set d1 of enemy state
  dec Enemy_Y_Position,x
  dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
  lda Enemy_ID,x
  cmp #Bloober               ;check for bloober object
  if (!BEQ SetWYSpd) {  // from SetStun
    lda #$fd                   ;set default vertical speed
    ldy AreaType
    if (!BNE SetNotW) {  // from @12474
      // Block: SetWYSpd
      SetWYSpd: lda #$ff                   ;change the vertical speed
    }
  }
  SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
  ldy #$01
  jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
  if (!BPL ChkBBill) {  // from SetNotW
    iny                        ;increment Y if not
  }
  ChkBBill: lda Enemy_ID,x
  cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
  if (!BEQ NoCDirF) {  // from ChkBBill
    cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
    if (!BEQ NoCDirF) {  // from @12486
      sty Enemy_MovingDir,x      ;store as moving direction
    }
  }
  // Block: NoCDirF
  NoCDirF:  dey                        ;decrement and use as offset
  lda EnemyBGCXSpdData,y     ;get proper horizontal speed
  sta Enemy_X_Speed,x        ;and store, then leave
  // Block: ExEBGChk
  ExEBGChk: rts

def PlayerPhysicsSub():
  lda Player_State          ;check player state
  cmp #$03
  if (!BNE CheckForJumping) {  // from PlayerPhysicsSub
    ldy #$00
    lda Up_Down_Buttons       ;get controller bits for up/down
    and Player_CollisionBits  ;check against player's collision detection bits
    if (!BEQ ProcClimb) {  // from @6045
      iny
      and #%00001000            ;check for pressing up
      if (!BNE ProcClimb) {  // from @6049
        iny
      }
    }
    ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
    stx Player_Y_MoveForce    ;store as vertical movement force
    lda #$08                  ;load default animation timing
    ldx Climb_Y_SpeedData,y   ;load some other value here
    stx Player_Y_Speed        ;store as vertical speed
    if (!BMI SetCAnim) {  // from ProcClimb
      lsr                       ;otherwise divide timer setting by 2
    }
    // Block: SetCAnim
    SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
    rts
  }
  lda JumpspringAnimCtrl    ;if jumpspring animating,
  if (!BNE NoJump) {  // from CheckForJumping
    lda A_B_Buttons           ;check for A button press
    and #A_Button
    if (!BEQ NoJump) {  // from @6066
      and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
      if (!BEQ ProcJumping) {  // from @6069
        // Block: NoJump
        NoJump: jmp X_Physics             ;otherwise, jump to something else
      }
    }
  }
  lda Player_State           ;check player state
  if (!BEQ InitJS) {  // from ProcJumping
    do {  // loop15
      lda SwimmingFlag           ;if swimming flag not set, jump to do something else
      beq NoJump                 ;to prevent midair jumping, otherwise continue
    } while (BEQ NoJump)
    lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
    if (!BNE InitJS) {  // from @6078
      lda Player_Y_Speed         ;check player's vertical speed
      if (!BPL InitJS) {  // from @6080
        jmp X_Physics              ;if timer at zero and player still rising, do not swim
      }
    }
  } else {
    InitJS:    lda #$20                   ;set jump/swim timer
    sta JumpSwimTimer
    ldy #$00                   ;initialize vertical force and dummy variable
    sty Player_YMF_Dummy
    sty Player_Y_MoveForce
    lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
    sta JumpOrigin_Y_HighPos   ;and store them next to each other here
    lda Player_Y_Position
    sta JumpOrigin_Y_Position
    lda #$01                   ;set player state to jumping/swimming
    sta Player_State
    lda Player_XSpeedAbsolute  ;check value related to walking/running speed
    cmp #$09
    if (!BCC ChkWtr) {  // from InitJS
      iny                        ;for each amount equal or exceeded
      cmp #$10
      if (!BCC ChkWtr) {  // from @6097
        iny
        cmp #$19
        if (!BCC ChkWtr) {  // from @6100
          iny
          cmp #$1c
          if (!BCC ChkWtr) {  // from @6103
            iny
          }
        }
      }
    }
    ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
    sta DiffToHaltJump
    lda SwimmingFlag           ;if swimming flag disabled, branch
    if (!BEQ GetYPhy) {  // from ChkWtr
      ldy #$05                   ;otherwise set Y to 5, range is 5-6
      lda Whirlpool_Flag         ;if whirlpool flag not set, branch
      if (!BEQ GetYPhy) {  // from @6111
        iny                        ;otherwise increment to 6
      }
    }
    GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
    sta VerticalForce          ;data here
    lda FallMForceData,y
    sta VerticalForceDown
    lda InitMForceData,y
    sta Player_Y_MoveForce
    lda PlayerYSpdData,y
    sta Player_Y_Speed
    lda SwimmingFlag           ;if swimming flag disabled, branch
    if (!BEQ PJumpSnd) {  // from GetYPhy
      lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
      sta Square1SoundQueue      ;square 1's sfx queue
      lda Player_Y_Position
      cmp #$14                   ;check vertical low byte of player position
      if (!BCS X_Physics) {  // from @6125
        lda #$00                   ;otherwise reset player's vertical speed
        sta Player_Y_Speed         ;and jump to something else to keep player
        jmp X_Physics              ;from swimming above water level
        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
        ldy PlayerSize             ;is mario big?
        if (!BEQ SJumpSnd) {  // from PJumpSnd
          lda #Sfx_SmallJump         ;if not, load small mario's jump sound
        }
        // Block: SJumpSnd
        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
      }
    } else {
      if (!BEQ SJumpSnd) {  // from PJumpSnd
      }
    }
  }
  X_Physics: ldy #$00
  sty $00                    ;init value here
  lda Player_State           ;if mario is on the ground, branch
  if (!BEQ ProcPRun) {  // from X_Physics
    lda Player_XSpeedAbsolute  ;check something that seems to be related
    cmp #$19                   ;to mario's speed
    if (!BCS GetXPhy) {  // from @6142
      if (!BCC ChkRFast) {  // from @6145
        ProcPRun:  iny                        ;if mario on the ground, increment Y
        lda AreaType               ;check area type
        if (!BEQ ChkRFast) {  // from ProcPRun
          dey                        ;decrement Y by default for non-water type area
          lda Left_Right_Buttons     ;get left/right controller bits
          cmp Player_MovingDir       ;check against moving direction
          if (!BNE ChkRFast) {  // from @6149
            lda A_B_Buttons            ;check for b button pressed
            and #B_Button
            if (!BNE SetRTmr) {  // from @6153
              lda RunningTimer           ;check for running timer set
              if (!BNE GetXPhy) {  // from @6156
                ChkRFast:  iny                        ;if running timer not set or level type is water,
                inc $00                    ;increment Y again and temp variable in memory
                lda RunningSpeed
                if (!BNE FastXSp) {  // from ChkRFast
                  lda Player_XSpeedAbsolute
                  cmp #$21                   ;otherwise check player's walking/running speed
                  if (!BCC GetXPhy) {  // from @6162
                    // Block: FastXSp
                    FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
                    jmp GetXPhy                ;and jump ahead
                    // Block: SetRTmr
                    SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
                    sta RunningTimer
                  }
                }
              }
            }
          }
        }
      }
      if (!BNE FastXSp) {  // from ChkRFast
        if (!BCC GetXPhy) {  // from @6162
        }
      }
    }
  }
  ProcPRun:  iny                        ;if mario on the ground, increment Y
  lda AreaType               ;check area type
  if (!BEQ ChkRFast) {  // from ProcPRun
    dey                        ;decrement Y by default for non-water type area
    lda Left_Right_Buttons     ;get left/right controller bits
    cmp Player_MovingDir       ;check against moving direction
    if (!BNE ChkRFast) {  // from @6149
      lda A_B_Buttons            ;check for b button pressed
      and #B_Button
      if (!BNE SetRTmr) {  // from @6153
        lda RunningTimer           ;check for running timer set
        if (!BNE GetXPhy) {  // from @6156
          ChkRFast:  iny                        ;if running timer not set or level type is water,
          inc $00                    ;increment Y again and temp variable in memory
          lda RunningSpeed
          if (!BNE FastXSp) {  // from ChkRFast
            lda Player_XSpeedAbsolute
            cmp #$21                   ;otherwise check player's walking/running speed
            if (!BCC GetXPhy) {  // from @6162
            }
          }
        }
      }
    }
  }
  ChkRFast:  iny                        ;if running timer not set or level type is water,
  inc $00                    ;increment Y again and temp variable in memory
  lda RunningSpeed
  if (!BNE FastXSp) {  // from ChkRFast
    lda Player_XSpeedAbsolute
    cmp #$21                   ;otherwise check player's walking/running speed
    if (!BCC GetXPhy) {  // from @6162
    }
  }
  GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
  sta MaximumLeftSpeed
  lda GameEngineSubroutine   ;check for specific routine running
  cmp #$07                   ;(player entrance)
  if (!BNE GetXPhy2) {  // from GetXPhy
    ldy #$03                   ;otherwise set Y to 3
  }
  GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
  sta MaximumRightSpeed
  ldy $00                    ;get other value in memory
  lda FrictionData,y         ;get value using value in memory as offset
  sta FrictionAdderLow
  lda #$00
  sta FrictionAdderHigh      ;init something here
  lda PlayerFacingDir
  cmp Player_MovingDir       ;check facing direction against moving direction
  if (!BEQ ExitPhy) {  // from GetXPhy2
    asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
    rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
  }
  // Block: ExitPhy
  ExitPhy:   rts                        ;and then leave

def RelativeBubblePosition():
  // Block: RelativeBubblePosition
  ldy #$01                ;set for air bubble offsets
  jsr GetProperObjOffset  ;modify X to get proper air bubble offset
  ldy #$03
  jmp RelWOfs             ;get the coordinates

def NoiseSfxHandler():
  // Block: PlayBrickShatter
  lda #$20                 ;load length of brick shatter sound
  sta Noise_SfxLenCounter
  lda Noise_SfxLenCounter
  lsr                         ;divide by 2 and check for bit set to use offset
  if (!BCC DecrementSfx3Length) {  // from ContinueBrickShatter
    tay
    ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
    lda BrickShatterEnvData,y
    // Block: PlayNoiseSfx
    sta SND_NOISE_REG        ;play the sfx
    stx SND_NOISE_REG+2
    lda #$18
    sta SND_NOISE_REG+3
  }
  dec Noise_SfxLenCounter  ;decrement length of sfx
  if (!BNE ExSfx3) {  // from DecrementSfx3Length
    lda #$f0                 ;if done, stop playing the sfx
    sta SND_NOISE_REG
    lda #$00
    sta NoiseSoundBuffer
  }
  // Block: ExSfx3
  ExSfx3: rts
  ldy NoiseSoundQueue   ;check for sfx in queue
  if (!BEQ CheckNoiseBuffer) {  // from NoiseSfxHandler
    do {  // loop16
      // Block: ContinueBrickShatter
      lda Noise_SfxLenCounter
      lsr                         ;divide by 2 and check for bit set to use offset
      bcc DecrementSfx3Length
      // Block: DecrementSfx3Length
      dec Noise_SfxLenCounter  ;decrement length of sfx
      bne ExSfx3
      sty NoiseSoundBuffer  ;if found, put in buffer
      lsr NoiseSoundQueue
      bcs PlayBrickShatter  ;brick shatter
    } while (BCS PlayBrickShatter)
    lsr NoiseSoundQueue
    if (!BCS PlayBowserFlame) {  // from @15580
      lda NoiseSoundBuffer      ;check for sfx in buffer
      if (!BEQ ExNH) {  // from CheckNoiseBuffer
        lsr
        bcs ContinueBrickShatter  ;brick shatter
        lsr
        if (!BCS ContinueBowserFlame) {  // from @15588
          // Block: ExNH
          ExNH:   rts
          // Block: PlayBowserFlame
          lda #$40                    ;load length of bowser flame sound
          sta Noise_SfxLenCounter
        }
      }
    }
  }
  lda NoiseSoundBuffer      ;check for sfx in buffer
  if (!BEQ ExNH) {  // from CheckNoiseBuffer
    lsr
    if (!BCS ContinueBowserFlame) {  // from @15588
    }
  }
  // Block: ContinueBowserFlame
  lda Noise_SfxLenCounter
  lsr
  tay
  ldx #$0f                    ;load reg contents of bowser flame sound
  lda BowserFlameEnvData-1,y
  bne PlayNoiseSfx            ;unconditional branch here

def PlatLiftUp():
  // Block: PlatLiftUp
  lda #$10                 ;set movement amount here
  sta Enemy_Y_MoveForce,x
  lda #$ff                 ;set moving speed for platforms going up
  sta Enemy_Y_Speed,x
  jmp CommonSmallLift      ;skip ahead to part we should be executing
  // Block: CommonSmallLift
  ldy #$01
  jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
  lda #$04
  sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
  rts

def PauseRoutine():
  lda OperMode           ;are we in victory mode?
  cmp #VictoryModeValue  ;if so, go ahead
  if (!BEQ ChkPauseTimer) {  // from PauseRoutine
    cmp #GameModeValue     ;are we in game mode?
    if (!BNE ExitPause) {  // from @854
      lda OperMode_Task      ;if we are in game mode, are we running game engine?
      cmp #$03
      if (!BNE ExitPause) {  // from @856
        ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
        if (!BEQ ChkStart) {  // from ChkPauseTimer
          dec GamePauseTimer     ;if so, decrement and leave
          rts
        }
        ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
        and #Start_Button      ;on controller 1
        if (!BEQ ClrPauseTimer) {  // from ChkStart
          lda GamePauseStatus    ;check to see if timer flag is set
          and #%10000000         ;and if so, do not reset timer (residual,
          if (!BNE ExitPause) {  // from @866
            lda #$2b               ;set pause timer
            sta GamePauseTimer
            lda GamePauseStatus
            tay
            iny                    ;set pause sfx queue for next pause mode
            sty PauseSoundQueue
            eor #%00000001         ;invert d0 and set d7
            ora #%10000000
            if (!BNE SetPause) {  // from @869
              // Block: ClrPauseTimer
              ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
              and #%01111111         ;is not pressed
            }
            // Block: SetPause
            SetPause:      sta GamePauseStatus
          }
        }
      }
    }
  }
  ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
  if (!BEQ ChkStart) {  // from ChkPauseTimer
  }
  ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
  and #Start_Button      ;on controller 1
  if (!BEQ ClrPauseTimer) {  // from ChkStart
    lda GamePauseStatus    ;check to see if timer flag is set
    and #%10000000         ;and if so, do not reset timer (residual,
    if (!BNE ExitPause) {  // from @866
      lda #$2b               ;set pause timer
      sta GamePauseTimer
      lda GamePauseStatus
      tay
      iny                    ;set pause sfx queue for next pause mode
      sty PauseSoundQueue
      eor #%00000001         ;invert d0 and set d7
      ora #%10000000
      if (!BNE SetPause) {  // from @869
      }
    }
  }
  // Block: ExitPause
  ExitPause:     rts

def EnemyLanding():
  // Block: EnemyLanding
  jsr InitVStf            ;do something here to vertical speed and something else
  lda Enemy_Y_Position,x
  and #%11110000          ;save high nybble of vertical coordinate, and
  ora #%00001000          ;set d3, then store, probably used to set enemy object
  sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
  rts

def UpdateNumber():
  jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
  ldy VRAM_Buffer1_Offset
  lda VRAM_Buffer1-6,y      ;check highest digit of score
  if (!BNE NoZSup) {  // from UpdateNumber
    lda #$24
    sta VRAM_Buffer1-6,y
  }
  // Block: NoZSup
  NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
  rts

def XMoveCntr_Platform():
  sta $01                     ;store value here
  lda FrameCounter
  and #%00000011              ;branch to leave if not on
  if (!BNE NoIncXM) {  // from XMoveCntr_Platform
    ldy XMoveSecondaryCounter,x ;get secondary counter
    lda XMovePrimaryCounter,x   ;get primary counter
    lsr
    if (!BCS DecSeXM) {  // from @9427
      cpy $01                     ;compare secondary counter to preset maximum value
      if (!BEQ IncPXM) {  // from @9431
        inc XMoveSecondaryCounter,x ;increment secondary counter and leave
        // Block: NoIncXM
        NoIncXM: rts
      }
      // Block: IncPXM
      IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
      rts
    }
  }
  do {  // loop10
    // Block: DecSeXM
    DecSeXM: tya                         ;put secondary counter in A
    beq IncPXM                  ;if secondary counter at zero, branch back
  } while (BEQ IncPXM)
  dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
  rts

def TopScoreCheck():
  // Block: TopScoreCheck
  ldy #$05                 ;start with the lowest digit
  sec
  do {  // loop2
    // Block: GetScoreDiff
    GetScoreDiff: lda PlayerScoreDisplay,x ;subtract each player digit from each high score digit
    sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
    dex                      ;any player digit, borrow will be set until a subsequent
    dey                      ;subtraction clears it (player digit is higher than top)
    bpl GetScoreDiff
  } while (!BPL GetScoreDiff)
  if (!BCC NoTopSc) {  // from @2626
    inx                      ;increment X and Y once to the start of the score
    iny
    do {  // loop5
      // Block: CopyScore
      CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
      sta TopScoreDisplay,y
      inx
      iny
      cpy #$06                 ;do this until we have stored them all
      bcc CopyScore
    } while (!BCC CopyScore)
  }
  // Block: NoTopSc
  NoTopSc:      rts

def GetAreaMusic():
  lda OperMode           ;if in title screen mode, leave
  if (!BEQ ExitGetM) {  // from GetAreaMusic
    lda AltEntranceControl ;check for specific alternate mode of entry
    cmp #$02               ;if found, branch without checking starting position
    if (!BEQ ChkAreaType) {  // from @2795
      ldy #$05               ;select music for pipe intro scene by default
      lda PlayerEntranceCtrl ;check value from level header for certain values
      cmp #$06
      if (!BEQ StoreMusic) {  // from @2798
        cmp #$07               ;start position either value $06 or $07
        if (!BEQ StoreMusic) {  // from @2802
          ChkAreaType: ldy AreaType           ;load area type as offset for music bit
          lda CloudTypeOverride
          if (!BEQ StoreMusic) {  // from ChkAreaType
            ldy #$04               ;select music for cloud type level if found
          }
        }
      }
    }
    if (!BEQ StoreMusic) {  // from ChkAreaType
    }
    // Block: StoreMusic
    StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
    sta AreaMusicQueue     ;store in queue and leave
  }
  // Block: ExitGetM
  ExitGetM:    rts

def InitEnemyObject():
  // Block: InitEnemyObject
  lda #$00                 ;initialize enemy state
  sta Enemy_State,x
  jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
  // Block: ExEPar
  ExEPar: rts                      ;then leave

def DrawEnemyObjRow():
  // Block: DrawEnemyObjRow
  lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
  sta $00
  lda EnemyGraphicsTable+1,x

def ProcessWhirlpools():
  lda AreaType                ;check for water type level
  if (!BNE ExitWh) {  // from ProcessWhirlpools
    sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
    lda TimerControl            ;if master timer control set,
    if (!BNE ExitWh) {  // from @6496
      ldy #$04                    ;otherwise start with last whirlpool data
      NextWh: dey                         ;move onto next whirlpool data
      while (!BPL WhLoop) {  // loop14
        adc #$00                    ;add carry
        sta $01                     ;store result as page location of right extent here
        lda Player_X_Position       ;get player's horizontal position
        sec
        sbc Whirlpool_LeftExtent,y  ;subtract left extent
        lda Player_PageLoc          ;get player's page location
        sbc Whirlpool_PageLoc,y     ;subtract borrow
        if (!BMI NextWh) {  // from @6506
          lda $02                     ;otherwise get right extent
          sec
          sbc Player_X_Position       ;subtract player's horizontal coordinate
          lda $01                     ;get right extent's page location
          sbc Player_PageLoc          ;subtract borrow
          if (!BPL WhirlpoolActivate) {  // from @6514
            do {  // loop5
              // Block: WhLoop
              WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
              clc
              adc Whirlpool_Length,y      ;add length of whirlpool
              sta $02                     ;store result as right extent here
              lda Whirlpool_PageLoc,y     ;get page location
              beq NextWh                  ;if none or page 0, branch to get next data
            } while (BPL WhLoop)
            // Block: ExitWh
            ExitWh: rts                         ;leave
          }
        }
        do {  // loop13
        } while (BPL WhLoop)
      }
    }
  }
  lda Whirlpool_Length,y      ;get length of whirlpool
  lsr                         ;divide by 2
  sta $00                     ;save here
  lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
  clc
  adc $00                     ;add length divided by 2
  sta $01                     ;save as center of whirlpool
  lda Whirlpool_PageLoc,y     ;get page location
  adc #$00                    ;add carry
  sta $00                     ;save as page location of whirlpool center
  lda FrameCounter            ;get frame counter
  lsr                         ;shift d0 into carry (to run on every other frame)
  if (!BCC WhPull) {  // from WhirlpoolActivate
    lda $01                     ;get center
    sec
    sbc Player_X_Position       ;subtract player's horizontal coordinate
    lda $00                     ;get page location of center
    sbc Player_PageLoc          ;subtract borrow
    if (!BPL LeftWh) {  // from @6538
      lda Player_X_Position       ;otherwise slowly pull player left, towards the center
      sec
      sbc #$01                    ;subtract one pixel
      sta Player_X_Position       ;set player's new horizontal coordinate
      lda Player_PageLoc
      sbc #$00                    ;subtract borrow
      jmp SetPWh                  ;jump to set player's new page location
    } else {
      LeftWh: lda Player_CollisionBits    ;get player's collision bits
      lsr                         ;shift d0 into carry
      if (!BCC WhPull) {  // from LeftWh
        lda Player_X_Position       ;otherwise slowly pull player right, towards the center
        clc
        adc #$01                    ;add one pixel
        sta Player_X_Position       ;set player's new horizontal coordinate
        lda Player_PageLoc
        adc #$00                    ;add carry
        // Block: SetPWh
        SetPWh: sta Player_PageLoc          ;set player's new page location
      }
    }
  }
  // Block: WhPull
  WhPull: lda #$10
  sta $00                     ;set vertical movement force
  lda #$01
  sta Whirlpool_Flag          ;set whirlpool flag to be used later
  sta $02                     ;also set maximum vertical speed
  lsr
  tax                         ;set X for player offset
  jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return

def FlagpoleRoutine():
  ldx #$05                  ;set enemy object offset
  stx ObjectOffset          ;to special use slot
  lda Enemy_ID,x
  cmp #FlagpoleFlagObject   ;if flagpole flag not found,
  if (!BNE ExitFlagP) {  // from FlagpoleRoutine
    lda GameEngineSubroutine
    cmp #$04                  ;if flagpole slide routine not running,
    if (!BNE SkipScore) {  // from @6584
      lda Player_State
      cmp #$03                  ;if player state not climbing,
      if (!BNE SkipScore) {  // from @6587
        lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
        cmp #$aa                  ;if flagpole flag down to a certain point,
        if (!BCS GiveFPScr) {  // from @6590
          lda Player_Y_Position     ;check player's vertical coordinate
          cmp #$a2                  ;if player down to a certain point,
          if (!BCS GiveFPScr) {  // from @6593
            lda Enemy_YMF_Dummy,x
            adc #$ff                  ;add movement amount to dummy variable
            sta Enemy_YMF_Dummy,x     ;save dummy variable
            lda Enemy_Y_Position,x    ;get flag's vertical coordinate
            adc #$01                  ;add 1 plus carry to move flag, and
            sta Enemy_Y_Position,x    ;store vertical coordinate
            lda FlagpoleFNum_YMFDummy
            sec                       ;subtract movement amount from dummy variable
            sbc #$ff
            sta FlagpoleFNum_YMFDummy ;save dummy variable
            lda FlagpoleFNum_Y_Pos
            sbc #$01                  ;subtract one plus borrow to move floatey number,
            sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
            // Block: SkipScore
            SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
          }
        }
      }
    }
    // Block: GiveFPScr
    GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
    lda FlagpoleScoreMods,y   ;get amount to award player points
    ldx FlagpoleScoreDigits,y ;get digit with which to award points
    sta DigitModifier,x       ;store in digit modifier
    jsr AddToScore            ;do sub to award player points depending on height of collision
    lda #$05
    sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
    // Block: FPGfx
    FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
    jsr RelativeEnemyPosition ;get relative coordinates
    jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
  }
  // Block: ExitFlagP
  ExitFlagP: rts

def ProcSwimmingB():
  lda BlooperMoveCounter,x  ;get enemy's movement counter
  and #%00000010            ;check for d1 set
  if (!BNE ChkForFloatdown) {  // from ProcSwimmingB
    lda FrameCounter
    and #%00000111            ;get 3 LSB of frame counter
    pha                       ;and save it to the stack
    lda BlooperMoveCounter,x  ;get enemy's movement counter
    lsr                       ;check for d0 set
    if (!BCS SlowSwim) {  // from @9523
      pla                       ;pull 3 LSB of frame counter from the stack
      if (!BNE BSwimE) {  // from @9529
        lda Enemy_Y_MoveForce,x
        clc                       ;add to movement force to speed up swim
        adc #$01
        sta Enemy_Y_MoveForce,x   ;set movement force
        sta BlooperMoveSpeed,x    ;set as movement speed
        cmp #$02
        if (!BNE BSwimE) {  // from @9531
          inc BlooperMoveCounter,x  ;otherwise increment movement counter
        }
      }
      // Block: BSwimE
      BSwimE: rts
    }
    pla                      ;pull 3 LSB of frame counter from the stack
    if (!BNE NoSSw) {  // from SlowSwim
      lda Enemy_Y_MoveForce,x
      sec                      ;subtract from movement force to slow swim
      sbc #$01
      sta Enemy_Y_MoveForce,x  ;set movement force
      sta BlooperMoveSpeed,x   ;set as movement speed
      if (!BNE NoSSw) {  // from @9544
        inc BlooperMoveCounter,x ;otherwise increment movement counter
        lda #$02
        sta EnemyIntervalTimer,x ;set enemy's timer
      }
    }
    // Block: NoSSw
    NoSSw: rts                      ;leave
  }
  lda EnemyIntervalTimer,x ;get enemy timer
  if (!BEQ ChkNearPlayer) {  // from ChkForFloatdown
    lda FrameCounter        ;get frame counter
    lsr                     ;check for d0 set
    if (!BCS NoFD) {  // from Floatdown
      inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
    }
    // Block: NoFD
    NoFD: rts                     ;leave
  }
  do {  // loop19
    // Block: Floatdown
    lda FrameCounter        ;get frame counter
    lsr                     ;check for d0 set
    bcs NoFD                ;branch to leave on every other frame
    // Block: ChkNearPlayer
    lda Enemy_Y_Position,x    ;get vertical coordinate
    adc #$10                  ;add sixteen pixels
    cmp Player_Y_Position     ;compare result with player's vertical coordinate
    bcc Floatdown             ;if modified vertical less than player's, branch
  } while (BCC Floatdown)
  lda #$00
  sta BlooperMoveCounter,x  ;otherwise nullify movement counter
  rts

def MoveAllSpritesOffscreen():
  // Block: MoveAllSpritesOffscreen
  ldy #$00                ;this routine moves all sprites off the screen

def GiveOneCoin():
  lda #$01               ;set digit modifier to add 1 coin
  sta DigitModifier+5    ;to the current player's coin tally
  ldx CurrentPlayer      ;get current player on the screen
  ldy CoinTallyOffsets,x ;get offset for player's coin tally
  jsr DigitsMathRoutine  ;update the coin tally
  inc CoinTally          ;increment onscreen player's coin amount
  lda CoinTally
  cmp #100               ;does player have 100 coins yet?
  if (!BNE CoinPoints) {  // from GiveOneCoin
    lda #$00
    sta CoinTally          ;otherwise, reinitialize coin amount
    inc NumberofLives      ;give the player an extra life
    lda #Sfx_ExtraLife
    sta Square2SoundQueue  ;play 1-up sound
  }
  // Block: CoinPoints
  lda #$02               ;set digit modifier to award
  sta DigitModifier+4    ;200 points to the player

def ProcessCannons():
  lda AreaType                ;get area type
  if (!BEQ ExCannon) {  // from ProcessCannons
    ldx #$02
    ThreeSChk: stx ObjectOffset            ;start at third enemy slot
    lda Enemy_Flag,x            ;check enemy buffer flag
    if (!BNE Chk_BB) {  // from ThreeSChk
      lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
      ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
      and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
      cmp #$06                    ;check to see if lower nybble is above certain value
      if (!BCS Chk_BB) {  // from @6769
        tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
        lda Cannon_PageLoc,y        ;get page location
        if (!BEQ Chk_BB) {  // from @6774
          lda Cannon_Timer,y          ;get cannon timer
          if (!BEQ FireCannon) {  // from @6777
            sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
            sta Cannon_Timer,y          ;to count timer down
            jmp Chk_BB                  ;then jump ahead to check enemy
          } else {
            lda TimerControl           ;if master timer control set,
            if (!BNE Chk_BB) {  // from FireCannon
              lda #$0e                   ;otherwise we start creating one
              sta Cannon_Timer,y         ;first, reset cannon timer
              lda Cannon_PageLoc,y       ;get page location of cannon
              sta Enemy_PageLoc,x        ;save as page location of bullet bill
              lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
              sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
              lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
              sec
              sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
              sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
              lda #$01
              sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
              sta Enemy_Flag,x           ;set buffer flag
              lsr                        ;shift right once to init A
              sta Enemy_State,x          ;then initialize enemy's state
              lda #$09
              sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
              lda #BulletBill_CannonVar
              sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
              jmp Next3Slt               ;move onto next slot
            }
          }
        }
      }
    } else {
      Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
      cmp #BulletBill_CannonVar
      if (!BNE Next3Slt) {  // from Chk_BB
        jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
        lda Enemy_Flag,x           ;check enemy buffer flag
        if (!BEQ Next3Slt) {  // from @6809
          jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
          jsr BulletBillHandler      ;then do sub to handle bullet bill
        }
      }
    }
    // Block: Next3Slt
    Next3Slt: dex                        ;move onto next slot
    bpl ThreeSChk              ;do this until first three slots are checked
  }
  // Block: ExCannon
  ExCannon: rts                        ;then leave

def SetXMoveAmt():
  // Block: SetXMoveAmt
  SetXMoveAmt: sty $00                 ;set movement amount here
  inx                     ;increment X for enemy offset
  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
  ldx ObjectOffset        ;get enemy object buffer offset and leave
  rts

def CheckpointEnemyID():
  lda Enemy_ID,x
  cmp #$15                     ;check enemy object identifier for $15 or greater
  if (!BCS InitEnemyRoutines) {  // from CheckpointEnemyID
    tay                          ;save identifier in Y register for now
    lda Enemy_Y_Position,x
    adc #$08                     ;add eight pixels to what will eventually be the
    sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
    lda #$01
    sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
    tya                          ;get identifier back and use as offset for jump engine
  }
  // Block: InitEnemyRoutines
  jsr JumpEngine
  // Block: NoInitCode
  rts               ;this executed when enemy object has no init code

def DrawFirebar_Collision():
  lda $03                  ;store mirror data elsewhere
  sta $05
  ldy $06                  ;load OAM data offset for firebar
  lda $01                  ;load horizontal adder we got from position loader
  lsr $05                  ;shift LSB of mirror data
  if (!BCS AddHA) {  // from DrawFirebar_Collision
    eor #$ff
    adc #$01                 ;otherwise get two's compliment of horizontal adder
  }
  AddHA:   clc                      ;add horizontal coordinate relative to screen to
  adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
  sta Sprite_X_Position,y  ;store as X coordinate here
  sta $06                  ;store here for now, note offset is saved in Y still
  cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
  if (!BCS SubtR1) {  // from AddHA
    lda Enemy_Rel_XPos
    sec                      ;otherwise subtract sprite X from the
    sbc $06                  ;original one and skip this part
    jmp ChkFOfs
  } else {
    // Block: SubtR1
    SubtR1:  sec                      ;subtract original X from the
    sbc Enemy_Rel_XPos       ;current sprite X
  }
  ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
  if (!BCC VAHandl) {  // from ChkFOfs
    lda #$f8                 ;otherwise, load offscreen Y coordinate
    if (!BNE SetVFbr) {  // from @9781
      VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
      cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
      if (!BEQ SetVFbr) {  // from VAHandl
        lda $02                  ;load vertical adder we got from position loader
        lsr $05                  ;shift LSB of mirror data one more time
        if (!BCS AddVA) {  // from @9786
          eor #$ff
          adc #$01                 ;otherwise get two's compliment of second part
        }
        // Block: AddVA
        AddVA:   clc                      ;add vertical coordinate relative to screen to
        adc Enemy_Rel_YPos       ;the second data, modified or otherwise
      }
    }
  }
  VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
  cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
  if (!BEQ SetVFbr) {  // from VAHandl
    lda $02                  ;load vertical adder we got from position loader
    lsr $05                  ;shift LSB of mirror data one more time
    if (!BCS AddVA) {  // from @9786
    }
  }
  // Block: SetVFbr
  SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
  sta $07                  ;also store here for now

def GetPlayerOffscreenBits():
  // Block: GetPlayerOffscreenBits
  ldx #$00                 ;set offsets for player-specific variables
  ldy #$00                 ;and get offscreen information about player
  jmp GetOffScreenBitsSet

def BrickShatter():
  // Block: BrickShatter
  jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
  lda #Sfx_BrickShatter
  sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
  sta NoiseSoundQueue    ;load brick shatter sound
  jsr SpawnBrickChunks   ;create brick chunk objects
  lda #$fe
  sta Player_Y_Speed     ;set vertical speed for player
  lda #$05
  sta DigitModifier+5    ;set digit modifier to give player 50 points
  jsr AddToScore         ;do sub to update the score
  ldx SprDataOffset_Ctrl ;load control bit and leave
  rts

def LoadEnvelopeData():
  lda EventMusicBuffer           ;check secondary buffer for win castle music
  and #EndOfCastleMusic
  if (!BEQ LoadUsualEnvData) {  // from LoadEnvelopeData
    lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
    rts
  }
  lda AreaMusicBuffer            ;check primary buffer for water music
  and #%01111101
  if (!BEQ LoadWaterEventMusEnvData) {  // from LoadUsualEnvData
    lda AreaMusicEnvData,y         ;load default data from offset for all other music
    rts
  }
  // Block: LoadWaterEventMusEnvData
  lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
  rts

def SixSpriteStacker():
  // Block: SixSpriteStacker
  ldx #$06           ;do six sprites
  do {  // loop2
    // Block: StkLp
    StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
    clc
    adc #$08           ;add eight pixels
    iny
    iny                ;move offset four bytes forward
    iny
    iny
    dex                ;do another sprite
    bne StkLp          ;do this until all sprites are done
  } while (!BNE StkLp)
  ldy $02            ;get saved OAM data offset and leave
  rts

def PlayerHammerCollision():
  lda FrameCounter          ;get frame counter
  lsr                       ;shift d0 into carry
  if (!BCC ExPHC) {  // from PlayerHammerCollision
    lda TimerControl          ;if either master timer control
    ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
    if (!BNE ExPHC) {  // from @11206
      txa
      asl                       ;multiply misc object offset by four
      asl
      clc
      adc #$24                  ;add 36 or $24 bytes to get proper offset
      tay                       ;for misc object bounding box coordinates
      jsr PlayerCollisionCore   ;do player-to-hammer collision detection
      ldx ObjectOffset          ;get misc object offset
      if (!BCC ClHCol) {  // from @11209
        lda Misc_Collision_Flag,x ;otherwise read collision flag
        if (!BNE ExPHC) {  // from @11218
          lda #$01
          sta Misc_Collision_Flag,x ;otherwise set collision flag now
          lda Misc_X_Speed,x
          eor #$ff                  ;get two's compliment of
          clc                       ;hammer's horizontal speed
          adc #$01
          sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
          lda StarInvincibleTimer   ;if star mario invincibility timer set,
          if (!BNE ExPHC) {  // from @11220
            jmp InjurePlayer          ;otherwise jump to hurt player, do not return
            // Block: ClHCol
            ClHCol: lda #$00                  ;clear collision flag
            sta Misc_Collision_Flag,x
          }
        }
      }
    }
  }
  // Block: ExPHC
  ExPHC:  rts

def BubbleCheck():
  // Block: BubbleCheck
  lda PseudoRandomBitReg+1,x  ;get part of LSFR
  and #$01
  sta $07                     ;store pseudorandom bit here
  lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
  cmp #$f8                    ;if offscreen coordinate not set,
  bne MoveBubl                ;branch to move air bubble
  lda AirBubbleTimer          ;if air bubble timer not expired,
  bne ExitBubl                ;branch to leave, otherwise create new air bubble

def PositionPlayerOnVPlat():
  lda Enemy_Y_Position,x    ;get vertical coordinate
  ldy GameEngineSubroutine
  cpy #$0b                  ;if certain routine being executed on this frame,
  if (!BEQ ExPlPos) {  // from PositionPlayerOnVPlat
    ldy Enemy_Y_HighPos,x
    cpy #$01                  ;if vertical high byte offscreen, skip this
    if (!BNE ExPlPos) {  // from @11850
      sec                       ;subtract 32 pixels from vertical coordinate
      sbc #$20                  ;for the player object's height
      sta Player_Y_Position     ;save as player's new vertical coordinate
      tya
      sbc #$00                  ;subtract borrow and store as player's
      sta Player_Y_HighPos      ;new vertical high byte
      lda #$00
      sta Player_Y_Speed        ;initialize vertical speed and low byte of force
      sta Player_Y_MoveForce    ;and then leave
    }
  }
  // Block: ExPlPos
  ExPlPos: rts

def SetPRout():
  // Block: SetPRout
  SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
  sty Player_State          ;store new player state
  ldy #$ff
  sty TimerControl          ;set master timer control flag to halt timers
  iny
  sty ScrollAmount          ;initialize scroll speed

def DemoEngine():
  ldx DemoAction         ;load current demo action
  lda DemoActionTimer    ;load current action timer
  if (!BNE DoAction) {  // from DemoEngine
    inx
    inc DemoAction         ;if expired, increment action, X, and
    sec                    ;set carry by default for demo over
    lda DemoTimingData-1,x ;get next timer
    sta DemoActionTimer    ;store as current timer
    if (!BEQ DemoOver) {  // from @1097
      // Block: DoAction
      DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
      sta SavedJoypad1Bits
      dec DemoActionTimer    ;decrement action timer
      clc                    ;clear carry if demo still going
    }
  }
  // Block: DemoOver
  DemoOver: rts

def DoNothing1():
  // Block: DoNothing1
  lda #$ff       ;this is residual code, this value is
  sta $06c9      ;not used anywhere in the program

def MoveSpritesOffscreen():
  // Block: MoveSpritesOffscreen
  ldy #$04                ;this routine moves all but sprite 0
  lda #$f8                ;off the screen
  do {  // loop2
    // Block: SprInitLoop
    SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
    iny                     ;which will move it off the screen
    iny
    iny
    iny
    bne SprInitLoop
  } while (!BNE SprInitLoop)
  rts

def OperModeExecutionTree():
  // Block: OperModeExecutionTree
  lda OperMode     ;this is the heart of the entire program,
  jsr JumpEngine   ;most of what goes on starts here

def MoveColOffscreen():
  // Block: MoveColOffscreen
  lda #$f8                   ;move offscreen two OAMs
  sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
  sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
  // Block: ExDBlk
  ExDBlk: rts

def GetObjRelativePosition():
  // Block: GetObjRelativePosition
  lda SprObject_Y_Position,x  ;load vertical coordinate low
  sta SprObject_Rel_YPos,y    ;store here
  lda SprObject_X_Position,x  ;load horizontal coordinate
  sec                         ;subtract left edge coordinate
  sbc ScreenLeft_X_Pos
  sta SprObject_Rel_XPos,y    ;store result here
  rts

def DrawHammer():
  ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
  lda TimerControl
  if (!BNE ForceHPose) {  // from DrawHammer
    lda Misc_State,x            ;otherwise get hammer's state
    and #%01111111              ;mask out d7
    cmp #$01                    ;check to see if set to 1 yet
    if (!BEQ GetHPose) {  // from @13202
      ForceHPose: ldx #$00                    ;reset offset here
      if (!BEQ RenderH) {  // from ForceHPose
        // Block: GetHPose
        GetHPose:   lda FrameCounter            ;get frame counter
        lsr                         ;move d3-d2 to d1-d0
        lsr
        and #%00000011              ;mask out all but d1-d0 (changes every four frames)
        tax                         ;use as timing offset
      }
    }
  }
  ForceHPose: ldx #$00                    ;reset offset here
  if (!BEQ RenderH) {  // from ForceHPose
  }
  RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
  clc
  adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
  sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
  clc
  adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
  sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
  lda Misc_Rel_XPos           ;get relative horizontal coordinate
  clc
  adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
  sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
  clc
  adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
  sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
  lda FirstSprTilenum,x
  sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
  lda SecondSprTilenum,x
  sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
  lda HammerSprAttrib,x
  sta Sprite_Attributes,y     ;get and store attribute bytes for both
  sta Sprite_Attributes+4,y   ;note in this case they use the same data
  ldx ObjectOffset            ;get misc object offset
  lda Misc_OffscreenBits
  and #%11111100              ;check offscreen bits
  if (!BEQ NoHOffscr) {  // from RenderH
    lda #$00
    sta Misc_State,x            ;otherwise nullify misc object state
    lda #$f8
    jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
  }
  // Block: NoHOffscr
  NoHOffscr:  rts                         ;leave

def DrawStarFlag():
  // Block: DrawStarFlag
  jsr RelativeEnemyPosition  ;get relative coordinates of star flag
  ldy Enemy_SprDataOffset,x  ;get OAM data offset
  ldx #$03                   ;do four sprites
  do {  // loop2
    // Block: DSFLoop
    DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
    clc
    adc StarFlagYPosAdder,x    ;add Y coordinate adder data
    sta Sprite_Y_Position,y    ;store as Y coordinate
    lda StarFlagTileData,x     ;get tile number
    sta Sprite_Tilenumber,y    ;store as tile number
    lda #$22                   ;set palette and background priority bits
    sta Sprite_Attributes,y    ;store as attributes
    lda Enemy_Rel_XPos         ;get relative horizontal coordinate
    clc
    adc StarFlagXPosAdder,x    ;add X coordinate adder data
    sta Sprite_X_Position,y    ;store as X coordinate
    iny
    iny                        ;increment OAM data offset four bytes
    iny                        ;for next sprite
    iny
    dex                        ;move onto next sprite
    bpl DSFLoop                ;do this until all sprites are done
  } while (!BPL DSFLoop)
  ldx ObjectOffset           ;get enemy object offset and leave
  rts

def GetGfxOffsetAdder():
  lda PlayerSize  ;get player's size
  if (!BEQ SzOfs) {  // from GetGfxOffsetAdder
    tya             ;for big player
    clc             ;otherwise add eight bytes to offset
    adc #$08        ;for small player
    tay
  }
  // Block: SzOfs
  SzOfs:  rts             ;go back

def Dump_Squ1_Regs():
  // Block: Dump_Squ1_Regs
  sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
  stx SND_SQUARE1_REG
  rts

def SetFreq_Tri():
  // Block: SetFreq_Tri
  ldx #$08               ;set frequency reg offset for triangle sound channel
  bne Dump_Freq_Regs     ;unconditional branch
  // Block: SwimStompEnvelopeData
  lda #$40               ;store length of flagpole sound
  sta Squ1_SfxLenCounter
  lda #$62               ;load part of reg contents for flagpole sound
  jsr SetFreq_Squ1
  ldx #$99               ;now load the rest
  if (!BNE FPS2nd) {  // from PlayFlagpoleSlide
    lda #$26               ;branch here for small mario jumping sound
    if (!BNE JumpRegContents) {  // from PlaySmallJump
      // Block: PlayBigJump
      lda #$18               ;branch here for big mario jumping sound
    }
    // Block: JumpRegContents
    ldx #$82               ;note that small and big jump borrow each others' reg contents
    ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
    jsr PlaySqu1Sfx
    lda #$28               ;store length of sfx for both jumping sounds
    sta Squ1_SfxLenCounter ;then continue on here
    lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
    cmp #$25               ;check for time to play second part yet
    if (!BNE N2Prt) {  // from ContinueSndJump
      ldx #$5f               ;load second part
      ldy #$f6
      if (!BNE DmpJpFPS) {  // from @15198
        N2Prt:    cmp #$20               ;check for third part
        if (!BNE DecJpFPS) {  // from N2Prt
          ldx #$48               ;load third part
          // Block: FPS2nd
          FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
          DmpJpFPS: jsr Dump_Squ1_Regs
          if (!BNE DecJpFPS) {  // from DmpJpFPS
            lda #$05
            ldy #$99                 ;load reg contents for fireball throw sound
            if (!BNE Fthrow) {  // from PlayFireballThrow
              // Block: PlayBump
              lda #$0a                ;load length of sfx and reg contents for bump sound
              ldy #$93
            }
            // Block: Fthrow
            Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
            sta Squ1_SfxLenCounter
            lda #$0c                ;load offset for bump sound
            jsr PlaySqu1Sfx
            lda Squ1_SfxLenCounter  ;check for second part of bump sound
            cmp #$06
            if (!BNE DecJpFPS) {  // from ContinueBumpThrow
              lda #$bb                ;load second part directly
              sta SND_SQUARE1_REG+1
            }
          }
        }
      }
    }
    if (!BNE DecJpFPS) {  // from N2Prt
      if (!BNE DecJpFPS) {  // from DmpJpFPS
        if (!BNE Fthrow) {  // from PlayFireballThrow
        }
        if (!BNE DecJpFPS) {  // from ContinueBumpThrow
        }
      }
    }
  }
  DmpJpFPS: jsr Dump_Squ1_Regs
  if (!BNE DecJpFPS) {  // from DmpJpFPS
    lda #$05
    ldy #$99                 ;load reg contents for fireball throw sound
    if (!BNE Fthrow) {  // from PlayFireballThrow
    }
    lda Squ1_SfxLenCounter  ;check for second part of bump sound
    cmp #$06
    if (!BNE DecJpFPS) {  // from ContinueBumpThrow
    }
  }
  if (!BNE BranchToDecLength1) {  // from DecJpFPS
  }
  if (!BNE DecrementSfx1Length) {  // from BranchToDecLength1
    lda #$0e                 ;store length of smack enemy sound
    ldy #$cb
    ldx #$9f
    sta Squ1_SfxLenCounter
    lda #$28                 ;store reg contents for smack enemy sound
    jsr PlaySqu1Sfx
    if (!BNE DecrementSfx1Length) {  // from PlaySmackEnemy
      ldy Squ1_SfxLenCounter  ;check about halfway through
      cpy #$08
      if (!BNE SmSpc) {  // from ContinueSmackEnemy
        lda #$a0                ;if we're at the about-halfway point, make the second tone
        sta SND_SQUARE1_REG+2   ;in the smack enemy sound
        lda #$9f
        if (!BNE SmTick) {  // from @15303
          // Block: SmSpc
          SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
        }
      }
      // Block: SmTick
      SmTick: sta SND_SQUARE1_REG
    }
  }
  dec Squ1_SfxLenCounter    ;decrement length of sfx
  if (!BNE ExSfx1) {  // from DecrementSfx1Length
  }
  // Block: ExSfx1
  ExSfx1: rts

def EnemyFacePlayer():
  ldy #$01               ;set to move right by default
  jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
  if (!BPL SFcRt) {  // from EnemyFacePlayer
    iny                    ;otherwise, increment to set to move to the left
  }
  // Block: SFcRt
  SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
  dey                    ;then decrement to use as a proper offset
  rts

def WriteBlockMetatile():
  ldy #$03                ;load offset for blank metatile
  cmp #$00                ;check contents of A for blank metatile
  if (!BEQ UseBOffset) {  // from WriteBlockMetatile
    ldy #$00                ;load offset for brick metatile w/ line
    cmp #$58
    if (!BEQ UseBOffset) {  // from @2039
      cmp #$51
      if (!BEQ UseBOffset) {  // from @2042
        iny                     ;increment offset for brick metatile w/o line
        cmp #$5d
        if (!BEQ UseBOffset) {  // from @2044
          cmp #$52
          if (!BEQ UseBOffset) {  // from @2047
            iny                     ;if any other metatile, increment offset for empty block
          }
        }
      }
    }
  }
  // Block: UseBOffset
  UseBOffset:  tya                     ;put Y in A
  ldy VRAM_Buffer1_Offset ;get vram buffer offset
  iny                     ;move onto next byte
  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer

def CheckTopOfBlock():
  ldx SprDataOffset_Ctrl  ;load control bit
  ldy $02                 ;get vertical high nybble offset used in block buffer
  if (!BEQ TopEx) {  // from CheckTopOfBlock
    tya                     ;otherwise set to A
    sec
    sbc #$10                ;subtract $10 to move up one row in the block buffer
    sta $02                 ;store as new vertical high nybble offset
    tay
    lda ($06),y             ;get contents of block buffer in same column, one row up
    cmp #$c2                ;is it a coin? (not underwater)
    if (!BNE TopEx) {  // from @7398
      lda #$00
      sta ($06),y             ;otherwise put blank metatile where coin was
      jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
      ldx SprDataOffset_Ctrl  ;get control bit
      jsr SetupJumpCoin       ;create jumping coin object and update coin variables
    }
  }
  // Block: TopEx
  TopEx: rts                     ;leave!

def MoveDropPlatform():
  ldy #$7f      ;set movement amount for drop platform
  if (!BNE SetMdMax) {  // from MoveDropPlatform
  }
  // Block: SetMdMax
  SetMdMax: lda #$02         ;set maximum speed in A
  bne SetXMoveAmt  ;unconditional branch

def MoveVOffset():
  // Block: SetVRAMOffset
  SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
  rts
  loop {  // loop3 (infinite)
    // Block: MoveVOffset
    MoveVOffset: dey                     ;decrement vram buffer offset
    tya                     ;add 10 bytes to it
    clc
    adc #10
    jmp SetVRAMOffset       ;branch to store as new vram buffer offset
  }

def MoveObjectHorizontally():
  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
  asl                         ;speed, secondary counter, whatever)
  asl                         ;and move low nybble to high
  asl
  asl
  sta $01                     ;store result here
  lda SprObject_X_Speed,x     ;get saved value again
  lsr                         ;move high nybble to low
  lsr
  lsr
  lsr
  cmp #$08                    ;if < 8, branch, do not change
  if (!BCC SaveXSpd) {  // from MoveObjectHorizontally
    ora #%11110000              ;otherwise alter high nybble
  }
  SaveXSpd: sta $00                     ;save result here
  ldy #$00                    ;load default Y value here
  cmp #$00                    ;if result positive, leave Y alone
  if (!BPL UseAdder) {  // from SaveXSpd
    dey                         ;otherwise decrement Y
  }
  // Block: UseAdder
  UseAdder: sty $02                     ;save Y here
  lda SprObject_X_MoveForce,x ;get whatever number's here
  clc
  adc $01                     ;add low nybble moved to high
  sta SprObject_X_MoveForce,x ;store result here
  lda #$00                    ;init A
  rol                         ;rotate carry into d0
  pha                         ;push onto stack
  ror                         ;rotate d0 back onto carry
  lda SprObject_X_Position,x
  adc $00                     ;add carry plus saved value (high nybble moved to low
  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
  lda SprObject_PageLoc,x
  adc $02                     ;add carry plus other saved value to the
  sta SprObject_PageLoc,x     ;object's page location and save
  pla
  clc                         ;pull old carry from stack and add
  adc $00                     ;to high nybble moved to low

def RenderAttributeTables():
  lda CurrentNTAddr_Low    ;get low byte of next name table address
  and #%00011111           ;to be written to, mask out all but 5 LSB,
  sec                      ;subtract four
  sbc #$04
  and #%00011111           ;mask out bits again and store
  sta $01
  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
  if (!BCS SetATHigh) {  // from RenderAttributeTables
    eor #%00000100           ;otherwise invert d2
  }
  // Block: SetATHigh
  SetATHigh:   and #%00000100           ;mask out all other bits
  ora #$23                 ;add $2300 to the high byte and store
  sta $00
  lda $01                  ;get low byte - 4, divide by 4, add offset for
  lsr                      ;attribute table and store
  lsr
  adc #$c0                 ;we should now have the appropriate block of
  sta $01                  ;attribute table in our temp address
  ldx #$00
  ldy VRAM_Buffer2_Offset  ;get buffer offset
  do {  // loop4
    // Block: AttribLoop
    AttribLoop:  lda $00
    sta VRAM_Buffer2,y       ;store high byte of attribute table address
    lda $01
    clc                      ;get low byte, add 8 because we want to start
    adc #$08                 ;below the status bar, and store
    sta VRAM_Buffer2+1,y
    sta $01                  ;also store in temp again
    lda AttributeBuffer,x    ;fetch current attribute table byte and store
    sta VRAM_Buffer2+3,y     ;in the buffer
    lda #$01
    sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
    lsr
    sta AttributeBuffer,x    ;clear current byte in attribute buffer
    iny                      ;increment buffer offset by 4 bytes
    iny
    iny
    iny
    inx                      ;increment attribute offset and check to see
    cpx #$07                 ;if we're at the end yet
    bcc AttribLoop
  } while (!BCC AttribLoop)
  sta VRAM_Buffer2,y       ;put null terminator at the end
  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
  // Block: SetVRAMCtrl
  SetVRAMCtrl: lda #$06
  sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
  rts

def KillAllEnemies():
  // Block: KillAllEnemies
  ldx #$04              ;start with last enemy slot
  do {  // loop2
    // Block: KillLoop
    KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
    dex                   ;move onto next enemy slot
    bpl KillLoop          ;do this until all slots are emptied
  } while (!BPL KillLoop)
  sta EnemyFrenzyBuffer ;empty frenzy buffer
  ldx ObjectOffset      ;get enemy object offset and leave
  rts

def GetSBNybbles():
  // Block: GetSBNybbles
  ldy CurrentPlayer      ;get current player
  lda StatusBarNybbles,y ;get nybbles based on player, use to update score and coins

def HandlePipeEntry():
  lda Up_Down_Buttons       ;check saved controller bits from earlier
  and #%00000100            ;for pressing down
  if (!BEQ ExPipeE) {  // from HandlePipeEntry
    lda $00
    cmp #$11                  ;check right foot metatile for warp pipe right metatile
    if (!BNE ExPipeE) {  // from @12273
      lda $01
      cmp #$10                  ;check left foot metatile for warp pipe left metatile
      if (!BNE ExPipeE) {  // from @12276
        lda #$30
        sta ChangeAreaTimer       ;set timer for change of area
        lda #$03
        sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
        lda #Sfx_PipeDown_Injury
        sta Square1SoundQueue     ;load pipedown/injury sound
        lda #%00100000
        sta Player_SprAttrib      ;set background priority bit in player's attributes
        lda WarpZoneControl       ;check warp zone control
        if (!BEQ ExPipeE) {  // from @12279
          and #%00000011            ;mask out all but 2 LSB
          asl
          asl                       ;multiply by four
          tax                       ;save as offset to warp zone numbers (starts at left pipe)
          lda Player_X_Position     ;get player's horizontal position
          cmp #$60
          if (!BCC GetWNum) {  // from @12289
            inx                       ;otherwise increment for middle pipe
            cmp #$a0
            if (!BCC GetWNum) {  // from @12296
              inx                       ;otherwise increment for last pipe
            }
          }
          // Block: GetWNum
          GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
          dey                       ;decrement for use as world number
          sty WorldNumber           ;store as world number and offset
          ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
          lda AreaAddrOffsets,x     ;get area offset based on world offset
          sta AreaPointer           ;store area offset here to be used to change areas
          lda #Silence
          sta EventMusicQueue       ;silence music
          lda #$00
          sta EntrancePage          ;initialize starting page number
          sta AreaNumber            ;initialize area number used for area address offset
          sta LevelNumber           ;initialize level number used for world display
          sta AltEntranceControl    ;initialize mode of entry
          inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
          inc FetchNewGameTimerFlag ;set flag to load new game timer
        }
      }
    }
  }
  // Block: ExPipeE
  ExPipeE: rts                       ;leave!!!

def DrawVine():
  // Block: DrawVine
  sty $00                    ;save offset here
  lda Enemy_Rel_YPos         ;get relative vertical coordinate
  clc
  adc VineYPosAdder,y        ;add value using offset in Y to get value
  ldx VineObjOffset,y        ;get offset to vine
  ldy Enemy_SprDataOffset,x  ;get sprite data offset
  sty $02                    ;store sprite data offset here
  jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
  lda Enemy_Rel_XPos         ;get relative horizontal coordinate
  sta Sprite_X_Position,y    ;store in first, third and fifth sprites
  sta Sprite_X_Position+8,y
  sta Sprite_X_Position+16,y
  clc
  adc #$06                   ;add six pixels to second, fourth and sixth sprites
  sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
  sta Sprite_X_Position+12,y ;our vertical stack of sprites
  sta Sprite_X_Position+20,y
  lda #%00100001             ;set bg priority and palette attribute bits
  sta Sprite_Attributes,y    ;set in first, third and fifth sprites
  sta Sprite_Attributes+8,y
  sta Sprite_Attributes+16,y
  ora #%01000000             ;additionally, set horizontal flip bit
  sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
  sta Sprite_Attributes+12,y
  sta Sprite_Attributes+20,y
  ldx #$05                   ;set tiles for six sprites
  do {  // loop2
    // Block: VineTL
    VineTL:  lda #$e1                   ;set tile number for sprite
    sta Sprite_Tilenumber,y
    iny                        ;move offset to next sprite data
    iny
    iny
    iny
    dex                        ;move onto next sprite
    bpl VineTL                 ;loop until all sprites are done
  } while (!BPL VineTL)
  ldy $02                    ;get original offset
  lda $00                    ;get offset to vine adding data
  if (!BNE SkpVTop) {  // from @13138
    lda #$e0
    sta Sprite_Tilenumber,y    ;set other tile number for top of vine
  }
  // Block: SkpVTop
  SkpVTop: ldx #$00                   ;start with the first sprite again
  NextVSp: iny                        ;move offset to next OAM data
  iny
  iny
  iny
  inx                        ;move onto next sprite
  cpx #$06                   ;do this until all sprites are checked
  while (!BNE ChkFTop) {  // loop11
    lda #$f8
    sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
    do {  // loop10
      // Block: ChkFTop
      ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
      sec
      sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
      cmp #$64                   ;if two coordinates are less than 100/$64 pixels
      bcc NextVSp                ;apart, skip this to leave sprite alone
    } while (BNE ChkFTop)
  }
  ldy $00                    ;return offset set earlier
  rts

def MovePlatformDown():
  // Block: MovePlatformDown
  lda #$00    ;save value to stack (if branching here, execute next

def PlayerCollisionCore():
  // Block: PlayerCollisionCore
  ldx #$00     ;initialize X to use player's bounding box for comparison

def DrawMushroomIcon():
  // Block: DrawMushroomIcon
  ldy #$07                ;read eight bytes to be read by transfer routine
  do {  // loop2
    // Block: IconDataRead
    IconDataRead: lda MushroomIconData,y  ;note that the default position is set for a
    sta VRAM_Buffer1-1,y    ;1-player game
    dey
    bpl IconDataRead
  } while (!BPL IconDataRead)
  lda NumberOfPlayers     ;check number of players
  if (!BEQ ExitIcon) {  // from @1073
    lda #$24                ;otherwise, load blank tile in 1-player position
    sta VRAM_Buffer1+3
    lda #$ce                ;then load shroom icon tile in 2-player position
    sta VRAM_Buffer1+5
  }
  // Block: ExitIcon
  ExitIcon:     rts

def MovePlayerHorizontally():
  lda JumpspringAnimCtrl  ;if jumpspring currently animating,
  if (!BNE ExXMove) {  // from MovePlayerHorizontally
    tax                     ;otherwise set zero for offset to use player's stuff
  }
  // Block: ExXMove
  ExXMove:  rts                         ;and leave

def ResetScreenTimer():
  // Block: ResetScreenTimer
  lda #$07                    ;reset timer again
  sta ScreenTimer
  inc ScreenRoutineTask       ;move onto next task
  // Block: NoReset
  NoReset: rts

def GetFirebarPosition():
  pha                        ;save high byte of spinstate to the stack
  and #%00001111             ;mask out low nybble
  cmp #$09
  if (!BCC GetHAdder) {  // from GetFirebarPosition
    eor #%00001111             ;otherwise get two's compliment to oscillate
    clc
    adc #$01
  }
  GetHAdder: sta $01                    ;store result, modified or not, here
  ldy $00                    ;load number of firebar ball where we're at
  lda FirebarTblOffsets,y    ;load offset to firebar position data
  clc
  adc $01                    ;add oscillated high byte of spinstate
  tay                        ;to offset here and use as new offset
  lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
  sta $01
  pla                        ;pull whatever was in A from the stack
  pha                        ;save it again because we still need it
  clc
  adc #$08                   ;add eight this time, to get vertical adder
  and #%00001111             ;mask out high nybble
  cmp #$09                   ;if lower than $09, branch ahead
  if (!BCC GetVAdder) {  // from GetHAdder
    eor #%00001111             ;otherwise get two's compliment
    clc
    adc #$01
  }
  // Block: GetVAdder
  GetVAdder: sta $02                    ;store result here
  ldy $00
  lda FirebarTblOffsets,y    ;load offset to firebar position data again
  clc
  adc $02                    ;this time add value in $02 to offset here and use as offset
  tay
  lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
  sta $02
  pla                        ;pull out whatever was in A one last time
  lsr                        ;divide by eight or shift three to the right
  lsr
  lsr
  tay                        ;use as offset
  lda FirebarMirrorData,y    ;load mirroring data here
  sta $03                    ;store
  rts

def RunRetainerObj():
  // Block: RunRetainerObj
  jsr GetEnemyOffscreenBits
  jsr RelativeEnemyPosition
  jmp EnemyGfxHandler

def PositionPlayerOnS_Plat():
  // Block: PositionPlayerOnS_Plat
  tay                        ;use bounding box counter saved in collision flag
  lda Enemy_Y_Position,x     ;for offset
  clc                        ;add positioning data using offset to the vertical
  adc PlayerPosSPlatData-1,y ;coordinate

def UpdScrollVar():
  UpdScrollVar: lda VRAM_Buffer_AddrCtrl
  cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
  if (!BEQ ExitEng) {  // from UpdScrollVar
    lda AreaParserTaskNum      ;otherwise check number of tasks
    if (!BNE RunParser) {  // from @5362
      lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
      cmp #$20                   ;check to see if exceeded $21
      if (!BMI ExitEng) {  // from @5364
        lda ScrollThirtyTwo
        sbc #$20                   ;otherwise subtract $20 to set appropriately
        sta ScrollThirtyTwo        ;and store
        lda #$00                   ;reset vram buffer offset used in conjunction with
        sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
        // Block: RunParser
        RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
      }
    }
  }
  // Block: ExitEng
  ExitEng:      rts                        ;and after all that, we're finally done!

def ExecGameLoopback():
  // Block: ExecGameLoopback
  lda Player_PageLoc        ;send player back four pages
  sec
  sbc #$04
  sta Player_PageLoc
  lda CurrentPageLoc        ;send current page back four pages
  sec
  sbc #$04
  sta CurrentPageLoc
  lda ScreenLeft_PageLoc    ;subtract four from page location
  sec                       ;of screen's left border
  sbc #$04
  sta ScreenLeft_PageLoc
  lda ScreenRight_PageLoc   ;do the same for the page location
  sec                       ;of screen's right border
  sbc #$04
  sta ScreenRight_PageLoc
  lda AreaObjectPageLoc     ;subtract four from page control
  sec                       ;for area objects
  sbc #$04
  sta AreaObjectPageLoc
  lda #$00                  ;initialize page select for both
  sta EnemyObjectPageSel    ;area and enemy objects
  sta AreaObjectPageSel
  sta EnemyDataOffset       ;initialize enemy object data offset
  sta EnemyObjectPageLoc    ;and enemy object page control
  lda AreaDataOfsLoopback,y ;adjust area object offset based on
  sta AreaDataOffset        ;which loop command we encountered
  rts

def ChkJumpspringMetatiles():
  cmp #$67      ;check for top jumpspring metatile
  if (!BEQ JSFnd) {  // from ChkJumpspringMetatiles
    cmp #$68      ;check for bottom jumpspring metatile
    clc           ;clear carry flag
    if (!BNE NoJSFnd) {  // from @12263
      // Block: JSFnd
      JSFnd:   sec           ;set carry if found
    }
  }
  // Block: NoJSFnd
  NoJSFnd: rts           ;leave

def FireballEnemyCollision():
  lda Fireball_State,x  ;check to see if fireball state is set at all
  if (!BEQ ExitFBallEnemy) {  // from FireballEnemyCollision
    asl
    if (!BCS ExitFBallEnemy) {  // from @11062
      lda FrameCounter
      lsr                   ;get LSB of frame counter
      if (!BCS ExitFBallEnemy) {  // from @11064
        txa
        asl                   ;multiply fireball offset by four
        asl
        clc
        adc #$1c              ;then add $1c or 28 bytes to it
        tay                   ;to use fireball's bounding box coordinates
        ldx #$04
        NoFToECol: pla                         ;pull fireball offset from stack
        tay                         ;put it in Y
        ldx $01                     ;get enemy object offset
        dex                         ;decrement it
        while (!BPL FireballEnemyCDLoop) {  // loop31
          lda Enemy_Flag,x            ;check to see if buffer flag is set
          if (!BEQ NoFToECol) {  // from @11082
            lda Enemy_ID,x              ;check enemy identifier
            cmp #$24
            if (!BCC GoombaDie) {  // from @11084
              cmp #$2b
              if (!BCC NoFToECol) {  // from @11087
                GoombaDie: cmp #Goomba                 ;check for goomba identifier
                if (!BNE NotGoomba) {  // from GoombaDie
                  lda Enemy_State,x           ;otherwise check for defeated state
                  cmp #$02                    ;if stomped or otherwise defeated,
                  if (!BCS NoFToECol) {  // from @11091
                    NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
                    if (!BNE NoFToECol) {  // from NotGoomba
                      txa
                      asl                         ;otherwise multiply enemy offset by four
                      asl
                      clc
                      adc #$04                    ;add 4 bytes to it
                      tax                         ;to use enemy's bounding box coordinates
                      jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
                      ldx ObjectOffset            ;return fireball's original offset
                      if (!BCC NoFToECol) {  // from @11096
                        lda #%10000000
                        sta Fireball_State,x        ;set d7 in enemy state
                        ldx $01                     ;get enemy offset
                        jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
                      }
                    }
                  }
                }
                if (!BNE NoFToECol) {  // from NotGoomba
                  if (!BCC NoFToECol) {  // from @11096
                  }
                }
              }
            }
            if (!BNE NotGoomba) {  // from GoombaDie
              if (!BCS NoFToECol) {  // from @11091
                if (!BNE NoFToECol) {  // from NotGoomba
                  if (!BCC NoFToECol) {  // from @11096
                  }
                }
              }
            }
            if (!BNE NoFToECol) {  // from NotGoomba
              if (!BCC NoFToECol) {  // from @11096
              }
            }
          }
          do {  // loop30
            // Block: FireballEnemyCDLoop
            stx $01                     ;store enemy object offset here
            tya
            pha                         ;push fireball offset to the stack
            lda Enemy_State,x
            and #%00100000              ;check to see if d5 is set in enemy state
            bne NoFToECol               ;if so, skip to next enemy slot
          } while (BPL FireballEnemyCDLoop)
        }
      }
    }
  }
  // Block: ExitFBallEnemy
  ldx ObjectOffset                 ;get original fireball offset and leave
  rts

def ProcessPlayerAction():
  lda Player_State      ;get player's state
  cmp #$03
  if (!BEQ ActionClimbing) {  // from ProcessPlayerAction
    cmp #$02
    if (!BEQ ActionFalling) {  // from @14588
      cmp #$01
      if (!BNE ProcOnGroundActs) {  // from @14590
        lda SwimmingFlag
        if (!BNE ActionSwimming) {  // from @14592
          ldy #$06              ;load offset for crouching
          lda CrouchingFlag     ;get crouching flag
          if (!BNE NonAnimatedActs) {  // from @14594
            ldy #$00              ;otherwise load offset for jumping
            jmp NonAnimatedActs   ;go to get offset to graphics table
            ldy #$06                   ;load offset for crouching
            lda CrouchingFlag          ;get crouching flag
            if (!BNE NonAnimatedActs) {  // from ProcOnGroundActs
              ldy #$02                   ;load offset for standing
              lda Player_X_Speed         ;check player's horizontal speed
              ora Left_Right_Buttons     ;and left/right controller bits
              if (!BEQ NonAnimatedActs) {  // from @14604
                lda Player_XSpeedAbsolute  ;load walking/running speed
                cmp #$09
                if (!BCC ActionWalkRun) {  // from @14608
                  lda Player_MovingDir       ;otherwise check to see if moving direction
                  and PlayerFacingDir        ;and facing direction are the same
                  if (!BNE ActionWalkRun) {  // from @14611
                    iny                        ;otherwise increment to skid offset ($03)
                    // Block: NonAnimatedActs
                    jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
                    lda #$00
                    sta PlayerAnimCtrl         ;initialize animation frame control
                    lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
                    rts
                    // Block: ActionFalling
                    ldy #$04                  ;load offset for walking/running
                    jsr GetGfxOffsetAdder     ;get offset to graphics table
                    jmp GetCurrentAnimOffset  ;execute instructions for falling state
                  }
                }
              }
            }
          }
          // Block: ActionWalkRun
          ldy #$04               ;load offset for walking/running
          jsr GetGfxOffsetAdder  ;get offset to graphics table
          jmp FourFrameExtent    ;execute instructions for normal state
          do {  // loop16
            // Block: ActionClimbing
            ldy #$05               ;load offset for climbing
            lda Player_Y_Speed     ;check player's vertical speed
            beq NonAnimatedActs    ;if no speed, branch, use offset as-is
          } while (BEQ NonAnimatedActs)
          jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
          jmp ThreeFrameExtent   ;then skip ahead to more code
        }
      } else {
        if (!BNE NonAnimatedActs) {  // from ProcOnGroundActs
          if (!BEQ NonAnimatedActs) {  // from @14604
            if (!BCC ActionWalkRun) {  // from @14608
              if (!BNE ActionWalkRun) {  // from @14611
              }
            }
          }
        }
      }
    }
  } else {
    do {  // loop35
    } while (BEQ NonAnimatedActs)
    ldy #$01               ;load offset for swimming
    jsr GetGfxOffsetAdder
    lda JumpSwimTimer      ;check jump/swim timer
    ora PlayerAnimCtrl     ;and animation frame control
    if (!BNE FourFrameExtent) {  // from ActionSwimming
      lda A_B_Buttons
      asl                    ;check for A button pressed
      if (!BCS FourFrameExtent) {  // from @14646
      }
    }
  }
  // Block: FourFrameExtent
  lda #$03              ;load upper extent for frame control
  jmp AnimationControl  ;jump to get offset and animate player object
  // Block: ThreeFrameExtent
  lda #$02              ;load upper extent for frame control for climbing
  sta $00                   ;store upper extent here
  jsr GetCurrentAnimOffset  ;get proper offset to graphics table
  pha                       ;save offset to stack
  lda PlayerAnimTimer       ;load animation frame timer
  if (!BNE ExAnimC) {  // from AnimationControl
    lda PlayerAnimTimerSet    ;get animation frame timer amount
    sta PlayerAnimTimer       ;and set timer accordingly
    lda PlayerAnimCtrl
    clc                       ;add one to animation frame control
    adc #$01
    cmp $00                   ;compare to upper extent
    if (!BCC SetAnimC) {  // from @14667
      lda #$00                  ;otherwise initialize frame control
    }
    // Block: SetAnimC
    SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
  }
  // Block: ExAnimC
  ExAnimC:  pla                       ;get offset to graphics table from stack and leave
  rts

def RelativePlayerPosition():
  // Block: RelativePlayerPosition
  ldx #$00      ;set offsets for relative cooordinates
  ldy #$00      ;routine to correspond to player object
  jmp RelWOfs   ;get the coordinates

def GetAreaObjectID():
  // Block: GetAreaObjectID
  lda $00    ;get value saved from area parser routine
  sec
  sbc #$00   ;possibly residual code
  tay        ;save to Y
  // Block: ExitDecBlock
  ExitDecBlock: rts

def ImposeFriction():
  and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
  cmp #$00                  ;then compare to zero (this instruction is redundant)
  if (!BNE JoypFrict) {  // from ImposeFriction
    lda Player_X_Speed
    if (!BEQ SetAbsSpd) {  // from @6230
      if (!BPL RghtFrict) {  // from @6232
        if (!BMI LeftFrict) {  // from @6233
          JoypFrict: lsr                       ;put right controller bit into carry
          if (!BCC RghtFrict) {  // from JoypFrict
            LeftFrict: lda Player_X_MoveForce    ;load value set here
            clc
            adc FrictionAdderLow      ;add to it another value set here
            sta Player_X_MoveForce    ;store here
            lda Player_X_Speed
            adc FrictionAdderHigh     ;add value plus carry to horizontal speed
            sta Player_X_Speed        ;set as new horizontal speed
            cmp MaximumRightSpeed     ;compare against maximum value for right movement
            if (!BMI XSpdSign) {  // from LeftFrict
              lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
              sta Player_X_Speed        ;thus slowing the player's left movement down
              jmp SetAbsSpd             ;skip to the end
              RghtFrict: lda Player_X_MoveForce    ;load value set here
              sec
              sbc FrictionAdderLow      ;subtract from it another value set here
              sta Player_X_MoveForce    ;store here
              lda Player_X_Speed
              sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
              sta Player_X_Speed        ;set as new horizontal speed
              cmp MaximumLeftSpeed      ;compare against maximum value for left movement
              if (!BPL XSpdSign) {  // from RghtFrict
                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
                sta Player_X_Speed        ;thus slowing the player's right movement down
              }
            }
          }
        }
        if (!BMI XSpdSign) {  // from LeftFrict
          if (!BPL XSpdSign) {  // from RghtFrict
          }
        }
      } else {
        if (!BPL XSpdSign) {  // from RghtFrict
        }
        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
        if (!BPL SetAbsSpd) {  // from XSpdSign
          eor #$ff
          clc                       ;otherwise get two's compliment to get absolute
          adc #$01                  ;unsigned walking/running speed
        }
      }
    }
  }
  JoypFrict: lsr                       ;put right controller bit into carry
  if (!BCC RghtFrict) {  // from JoypFrict
    LeftFrict: lda Player_X_MoveForce    ;load value set here
    clc
    adc FrictionAdderLow      ;add to it another value set here
    sta Player_X_MoveForce    ;store here
    lda Player_X_Speed
    adc FrictionAdderHigh     ;add value plus carry to horizontal speed
    sta Player_X_Speed        ;set as new horizontal speed
    cmp MaximumRightSpeed     ;compare against maximum value for right movement
    if (!BMI XSpdSign) {  // from LeftFrict
      RghtFrict: lda Player_X_MoveForce    ;load value set here
      sec
      sbc FrictionAdderLow      ;subtract from it another value set here
      sta Player_X_MoveForce    ;store here
      lda Player_X_Speed
      sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
      sta Player_X_Speed        ;set as new horizontal speed
      cmp MaximumLeftSpeed      ;compare against maximum value for left movement
      if (!BPL XSpdSign) {  // from RghtFrict
      }
    }
  } else {
    if (!BPL XSpdSign) {  // from RghtFrict
    }
    XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
    if (!BPL SetAbsSpd) {  // from XSpdSign
    }
  }
  // Block: SetAbsSpd
  SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
  rts

def LoadControlRegs():
  lda EventMusicBuffer  ;check secondary buffer for win castle music
  and #EndOfCastleMusic
  if (!BEQ NotECstlM) {  // from LoadControlRegs
    lda #$04              ;this value is only used for win castle music
    if (!BNE AllMus) {  // from @15929
      NotECstlM: lda AreaMusicBuffer
      and #%01111101        ;check primary buffer for water music
      if (!BEQ WaterMus) {  // from NotECstlM
        lda #$08              ;this is the default value for all other music
        if (!BNE AllMus) {  // from @15934
          // Block: WaterMus
          WaterMus:  lda #$28              ;this value is used for water music and all other event music
        }
      }
    }
  }
  NotECstlM: lda AreaMusicBuffer
  and #%01111101        ;check primary buffer for water music
  if (!BEQ WaterMus) {  // from NotECstlM
    lda #$08              ;this is the default value for all other music
    if (!BNE AllMus) {  // from @15934
    }
  }
  // Block: AllMus
  AllMus:    ldx #$82              ;load contents of other sound regs for square 2
  ldy #$7f
  rts

def MiscObjectsCore():
  // Block: MiscObjectsCore
  ldx #$08          ;set at end of misc object buffer
  MiscLoop: stx ObjectOffset  ;store misc object offset here
  lda Misc_State,x  ;check misc object state
  if (!BEQ MiscLoopBack) {  // from MiscLoop
    asl               ;otherwise shift d7 into carry
    if (!BCC ProcJumpCoin) {  // from @7017
      jsr ProcHammerObj ;otherwise go to process hammer,
      jmp MiscLoopBack  ;then check next slot
    } else {
      ldy Misc_State,x          ;check misc object state
      dey                       ;decrement to see if it's set to 1
      if (!BEQ JCoinRun) {  // from ProcJumpCoin
        inc Misc_State,x          ;otherwise increment state to either start off or as timer
        lda Misc_X_Position,x     ;get horizontal coordinate for misc object
        clc                       ;whether its jumping coin (state 0 only) or floatey number
        adc ScrollAmount          ;add current scroll speed
        sta Misc_X_Position,x     ;store as new horizontal coordinate
        lda Misc_PageLoc,x        ;get page location
        adc #$00                  ;add carry
        sta Misc_PageLoc,x        ;store as new page location
        lda Misc_State,x
        cmp #$30                  ;check state of object for preset value
        if (!BNE RunJCSubs) {  // from @7031
          lda #$00
          sta Misc_State,x          ;otherwise nullify object state
          jmp MiscLoopBack          ;and move onto next slot
          JCoinRun:  txa
          clc                       ;add 13 bytes to offset for next subroutine
          adc #$0d
          tax
          lda #$50                  ;set downward movement amount
          sta $00
          lda #$06                  ;set maximum vertical speed
          sta $02
          lsr                       ;divide by 2 and set
          sta $01                   ;as upward movement amount (apparently residual)
          lda #$00                  ;set A to impose gravity on jumping coin
          jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
          ldx ObjectOffset          ;get original misc object offset
          lda Misc_Y_Speed,x        ;check vertical speed
          cmp #$05
          if (!BNE RunJCSubs) {  // from JCoinRun
            inc Misc_State,x          ;otherwise increment state to change to floatey number
          }
        }
      } else {
        if (!BNE RunJCSubs) {  // from JCoinRun
        }
        // Block: RunJCSubs
        RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
        jsr GetMiscOffscreenBits  ;get offscreen information
        jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
        jsr JCoinGfxHandler       ;draw the coin or floatey number
      }
    }
  }
  do {  // loop22
    // Block: MiscLoop
    MiscLoop: stx ObjectOffset  ;store misc object offset here
    lda Misc_State,x  ;check misc object state
    beq MiscLoopBack  ;branch to check next slot
    asl               ;otherwise shift d7 into carry
    bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
    // Block: ProcJumpCoin
    ldy Misc_State,x          ;check misc object state
    dey                       ;decrement to see if it's set to 1
    beq JCoinRun              ;if so, branch to handle jumping coin
    inc Misc_State,x          ;otherwise increment state to either start off or as timer
    lda Misc_X_Position,x     ;get horizontal coordinate for misc object
    clc                       ;whether its jumping coin (state 0 only) or floatey number
    adc ScrollAmount          ;add current scroll speed
    sta Misc_X_Position,x     ;store as new horizontal coordinate
    lda Misc_PageLoc,x        ;get page location
    adc #$00                  ;add carry
    sta Misc_PageLoc,x        ;store as new page location
    lda Misc_State,x
    cmp #$30                  ;check state of object for preset value
    bne RunJCSubs             ;if not yet reached, branch to subroutines
    // Block: JCoinRun
    JCoinRun:  txa
    clc                       ;add 13 bytes to offset for next subroutine
    adc #$0d
    tax
    lda #$50                  ;set downward movement amount
    sta $00
    lda #$06                  ;set maximum vertical speed
    sta $02
    lsr                       ;divide by 2 and set
    sta $01                   ;as upward movement amount (apparently residual)
    lda #$00                  ;set A to impose gravity on jumping coin
    jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
    ldx ObjectOffset          ;get original misc object offset
    lda Misc_Y_Speed,x        ;check vertical speed
    cmp #$05
    bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
    // Block: MiscLoopBack
    dex                       ;decrement misc object offset
    bpl MiscLoop              ;loop back until all misc objects handled
  } while (BPL MiscLoop)
  rts                       ;then leave

def InitScroll():
  // Block: InitScroll
  InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
  sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
  rts

def ChkToStunEnemies():
  // Block: ChkToStunEnemies
  cmp #$09                   ;perform many comparisons on enemy object identifier
  bcc SetStun
  cmp #$11                   ;if the enemy object identifier is equal to the values
  bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
  cmp #$0a                   ;modified if not any of those values, note that piranha plant will
  if (!BCC Demote) {  // from @12459
    cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
    bcc SetStun                ;are only necessary if branching from $d7a1
  }
  // Block: Demote
  Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
  sta Enemy_ID,x             ;into green or red koopa troopa to demote them

def BlockBufferColli_Side():
  // Block: BlockBufferColli_Side
  lda #$01       ;set flag to return horizontal coordinate
  ldx #$00       ;set offset for player object

def DrawLargePlatform():
  ldy Enemy_SprDataOffset,x   ;get OAM data offset
  sty $02                     ;store here
  iny                         ;add 3 to it for offset
  iny                         ;to X coordinate
  iny
  lda Enemy_Rel_XPos          ;get horizontal relative coordinate
  jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
  ldx ObjectOffset
  lda Enemy_Y_Position,x      ;get vertical coordinate
  jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
  ldy AreaType
  cpy #$03                    ;check for castle-type level
  if (!BEQ ShrinkPlatform) {  // from DrawLargePlatform
    ldy SecondaryHardMode       ;check for secondary hard mode flag set
    if (!BEQ SetLast2Platform) {  // from @13345
      // Block: ShrinkPlatform
      lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
    }
  }
  ldy Enemy_SprDataOffset,x   ;get OAM data offset
  sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
  sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
  lda #$5b                    ;load default tile for platform (girder)
  ldx CloudTypeOverride
  if (!BEQ SetPlatformTilenum) {  // from SetLast2Platform
    lda #$75                    ;otherwise load other tile for platform (puff)
  }
  ldx ObjectOffset            ;get enemy object buffer offset
  iny                         ;increment Y for tile offset
  jsr DumpSixSpr              ;dump tile number into all six sprites
  lda #$02                    ;set palette controls
  iny                         ;increment Y for sprite attributes
  jsr DumpSixSpr              ;dump attributes into all six sprites
  inx                         ;increment X for enemy objects
  jsr GetXOffscreenBits       ;get offscreen bits again
  dex
  ldy Enemy_SprDataOffset,x   ;get OAM data offset
  asl                         ;rotate d7 into carry, save remaining
  pha                         ;bits to the stack
  if (!BCC SChk2) {  // from SetPlatformTilenum
    lda #$f8                    ;if d7 was set, move first sprite offscreen
    sta Sprite_Y_Position,y
  }
  SChk2:  pla                         ;get bits from stack
  asl                         ;rotate d6 into carry
  pha                         ;save to stack
  if (!BCC SChk3) {  // from SChk2
    lda #$f8                    ;if d6 was set, move second sprite offscreen
    sta Sprite_Y_Position+4,y
  }
  SChk3:  pla                         ;get bits from stack
  asl                         ;rotate d5 into carry
  pha                         ;save to stack
  if (!BCC SChk4) {  // from SChk3
    lda #$f8                    ;if d5 was set, move third sprite offscreen
    sta Sprite_Y_Position+8,y
  }
  SChk4:  pla                         ;get bits from stack
  asl                         ;rotate d4 into carry
  pha                         ;save to stack
  if (!BCC SChk5) {  // from SChk4
    lda #$f8                    ;if d4 was set, move fourth sprite offscreen
    sta Sprite_Y_Position+12,y
  }
  SChk5:  pla                         ;get bits from stack
  asl                         ;rotate d3 into carry
  pha                         ;save to stack
  if (!BCC SChk6) {  // from SChk5
    lda #$f8                    ;if d3 was set, move fifth sprite offscreen
    sta Sprite_Y_Position+16,y
  }
  SChk6:  pla                         ;get bits from stack
  asl                         ;rotate d2 into carry
  if (!BCC SLChk) {  // from SChk6
    lda #$f8
    sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
  }
  SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
  asl                         ;and if d7 is not set, skip sub
  if (!BCC ExDLPl) {  // from SLChk
    jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
  }
  // Block: ExDLPl
  ExDLPl: rts

def SoundEngine():
  lda OperMode              ;are we in title screen mode?
  if (!BNE SndOn) {  // from SoundEngine
    sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
    rts
  }
  SndOn:   lda #$ff
  sta JOYPAD_PORT2          ;disable irqs and set frame counter mode???
  lda #$0f
  sta SND_MASTERCTRL_REG    ;enable first four channels
  lda PauseModeFlag         ;is sound already in pause mode?
  if (!BNE InPause) {  // from SndOn
    lda PauseSoundQueue       ;if not, check pause sfx queue
    cmp #$01
    if (!BNE RunSoundSubroutines) {  // from @15055
      InPause: lda PauseSoundBuffer      ;check pause sfx buffer
      if (!BNE ContPau) {  // from InPause
        lda PauseSoundQueue       ;check pause queue
        if (!BEQ SkipSoundSubroutines) {  // from @15060
          sta PauseSoundBuffer      ;if queue full, store in buffer and activate
          sta PauseModeFlag         ;pause mode to interrupt game sounds
          lda #$00                  ;disable sound and clear sfx buffers
          sta SND_MASTERCTRL_REG
          sta Square1SoundBuffer
          sta Square2SoundBuffer
          sta NoiseSoundBuffer
          lda #$0f
          sta SND_MASTERCTRL_REG    ;enable sound again
          lda #$2a                  ;store length of sound in pause counter
          sta Squ1_SfxLenCounter
          PTone1F: lda #$44                  ;play first tone
          while (!BNE PTRegC) {  // loop11
            ContPau: lda Squ1_SfxLenCounter    ;check pause length left
            cmp #$24                  ;time to play second?
            if (!BEQ PTone2F) {  // from ContPau
              do {  // loop6
                cmp #$1e                  ;time to play first again?
                beq PTone1F
              } while (BEQ PTone1F)
              cmp #$18                  ;time to play second again?
              if (!BNE DecPauC) {  // from @15080
                // Block: PTone2F
                PTone2F: lda #$64                  ;store reg contents and play the pause sfx
                // Block: PTRegC
                PTRegC:  ldx #$84
                ldy #$7f
                jsr PlaySqu1Sfx
              }
            }
          }
          DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
          if (!BNE SkipSoundSubroutines) {  // from DecPauC
            lda #$00                  ;disable sound if in pause mode and
            sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
            lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
            cmp #$02                  ;if we need to be playing sound again
            if (!BNE SkipPIn) {  // from @15088
              lda #$00                  ;clear pause mode to allow game sounds again
              sta PauseModeFlag
            }
            SkipPIn: lda #$00                  ;clear pause sfx buffer
            sta PauseSoundBuffer
            if (!BEQ SkipSoundSubroutines) {  // from SkipPIn
              // Block: RunSoundSubroutines
              jsr Square1SfxHandler  ;play sfx on square channel 1
              jsr Square2SfxHandler  ; ''  ''  '' square channel 2
              jsr NoiseSfxHandler    ; ''  ''  '' noise channel
              jsr MusicHandler       ;play music on all channels
              lda #$00               ;clear the music queues
              sta AreaMusicQueue
              sta EventMusicQueue
            }
          }
        }
      }
      if (!BEQ PTone2F) {  // from ContPau
        do {  // loop24
        } while (BEQ PTone1F)
        if (!BNE DecPauC) {  // from @15080
        }
      }
      if (!BNE SkipSoundSubroutines) {  // from DecPauC
        if (!BNE SkipPIn) {  // from @15088
        }
        if (!BEQ SkipSoundSubroutines) {  // from SkipPIn
        }
      }
    }
  }
  InPause: lda PauseSoundBuffer      ;check pause sfx buffer
  if (!BNE ContPau) {  // from InPause
    lda PauseSoundQueue       ;check pause queue
    if (!BEQ SkipSoundSubroutines) {  // from @15060
      PTone1F: lda #$44                  ;play first tone
      while (!BNE PTRegC) {  // loop48
        ContPau: lda Squ1_SfxLenCounter    ;check pause length left
        cmp #$24                  ;time to play second?
        if (!BEQ PTone2F) {  // from ContPau
          do {  // loop43
          } while (BEQ PTone1F)
          cmp #$18                  ;time to play second again?
          if (!BNE DecPauC) {  // from @15080
          }
        }
      }
      DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
      if (!BNE SkipSoundSubroutines) {  // from DecPauC
        lda #$00                  ;disable sound if in pause mode and
        sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
        lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
        cmp #$02                  ;if we need to be playing sound again
        if (!BNE SkipPIn) {  // from @15088
        }
        SkipPIn: lda #$00                  ;clear pause sfx buffer
        sta PauseSoundBuffer
        if (!BEQ SkipSoundSubroutines) {  // from SkipPIn
        }
      }
    }
  }
  ContPau: lda Squ1_SfxLenCounter    ;check pause length left
  cmp #$24                  ;time to play second?
  if (!BEQ PTone2F) {  // from ContPau
    do {  // loop61
    } while (BEQ PTone1F)
    cmp #$18                  ;time to play second again?
    if (!BNE DecPauC) {  // from @15080
    }
  }
  DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
  if (!BNE SkipSoundSubroutines) {  // from DecPauC
    lda #$00                  ;disable sound if in pause mode and
    sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
    lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
    cmp #$02                  ;if we need to be playing sound again
    if (!BNE SkipPIn) {  // from @15088
    }
    SkipPIn: lda #$00                  ;clear pause sfx buffer
    sta PauseSoundBuffer
    if (!BEQ SkipSoundSubroutines) {  // from SkipPIn
    }
  }
  lda #$00               ;clear the sound effects queues
  sta Square1SoundQueue
  sta Square2SoundQueue
  sta NoiseSoundQueue
  sta PauseSoundQueue
  ldy DAC_Counter        ;load some sort of counter
  lda AreaMusicBuffer
  and #%00000011         ;check for specific music
  if (!BEQ NoIncDAC) {  // from SkipSoundSubroutines
    inc DAC_Counter        ;increment and check counter
    cpy #$30
    if (!BCC StrWave) {  // from @15118
      NoIncDAC: tya
      if (!BEQ StrWave) {  // from NoIncDAC
        dec DAC_Counter        ;decrement counter
      }
    }
  }
  NoIncDAC: tya
  if (!BEQ StrWave) {  // from NoIncDAC
  }
  // Block: StrWave
  StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
  rts                    ;we are done here

def RunGameTimer():
  lda OperMode               ;get primary mode of operation
  if (!BEQ ExGTimer) {  // from RunGameTimer
    lda GameEngineSubroutine
    cmp #$08                   ;if routine number less than eight running,
    if (!BCC ExGTimer) {  // from @6438
      cmp #$0b                   ;if running death routine,
      if (!BEQ ExGTimer) {  // from @6441
        lda Player_Y_HighPos
        cmp #$02                   ;if player below the screen,
        if (!BCS ExGTimer) {  // from @6443
          lda GameTimerCtrlTimer     ;if game timer control not yet expired,
          if (!BNE ExGTimer) {  // from @6446
            lda GameTimerDisplay
            ora GameTimerDisplay+1     ;otherwise check game timer digits
            ora GameTimerDisplay+2
            if (!BEQ TimeUpOn) {  // from @6448
              ldy GameTimerDisplay       ;otherwise check first digit
              dey                        ;if first digit not on 1,
              if (!BNE ResGTCtrl) {  // from @6452
                lda GameTimerDisplay+1     ;otherwise check second and third digits
                ora GameTimerDisplay+2
                if (!BNE ResGTCtrl) {  // from @6455
                  lda #TimeRunningOutMusic
                  sta EventMusicQueue        ;otherwise load time running out music
                }
              }
              // Block: ResGTCtrl
              ResGTCtrl: lda #$18                   ;reset game timer control
              sta GameTimerCtrlTimer
              ldy #$23                   ;set offset for last digit
              lda #$ff                   ;set value to decrement game timer digit
              sta DigitModifier+5
              jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
              lda #$a4                   ;set status nybbles to update game timer display
              jmp PrintStatusBarNumbers  ;do sub to update the display
            }
            // Block: TimeUpOn
            TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
            jsr ForceInjury            ;do sub to kill the player (note player is small here)
            inc GameTimerExpiredFlag   ;set game timer expiration flag
          }
        }
      }
    }
  }
  // Block: ExGTimer
  ExGTimer:  rts                        ;leave

def ScrollHandler():
  lda Player_X_Scroll       ;load value saved here
  clc
  adc Platform_X_Scroll     ;add value used by left/right platforms
  sta Player_X_Scroll       ;save as new value here to impose force on scroll
  lda ScrollLock            ;check scroll lock flag
  if (!BNE InitScrlAmt) {  // from ScrollHandler
    lda Player_Pos_ForScroll
    cmp #$50                  ;check player's horizontal screen position
    if (!BCC InitScrlAmt) {  // from @5384
      lda SideCollisionTimer    ;if timer related to player's side collision
      if (!BNE InitScrlAmt) {  // from @5387
        ldy Player_X_Scroll       ;get value and decrement by one
        dey                       ;if value originally set to zero or otherwise
        if (!BMI InitScrlAmt) {  // from @5389
          iny
          cpy #$02                  ;if value $01, branch and do not decrement
          if (!BCC ChkNearMid) {  // from @5392
            dey                       ;otherwise decrement by one
          }
          // Block: ChkNearMid
          ChkNearMid: lda Player_Pos_ForScroll
          cmp #$70                  ;check player's horizontal screen position
          bcc ScrollScreen          ;if less than 112 pixels to the right, branch
          ldy Player_X_Scroll       ;otherwise get original value undecremented
        }
      }
    }
  }
  // Block: InitScrlAmt
  InitScrlAmt:  lda #$00
  sta ScrollAmount          ;initialize value here
  ChkPOffscr:   ldx #$00                  ;set X for player offset
  jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
  sta $00                   ;save them here
  ldy #$00                  ;load default offset (left side)
  asl                       ;if d7 of offscreen bits are set,
  if (!BCS KeepOnscr) {  // from ChkPOffscr
    iny                         ;otherwise use different offset (right side)
    lda $00
    and #%00100000              ;check offscreen bits for d5 set
    if (!BEQ InitPlatScrl) {  // from @5433
      KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
      sec
      sbc X_SubtracterData,y      ;subtract amount based on offset
      sta Player_X_Position       ;store as player position to prevent movement further
      lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
      sbc #$00                    ;subtract borrow
      sta Player_PageLoc          ;save as player's page location
      lda Left_Right_Buttons      ;check saved controller bits
      cmp OffscrJoypadBitsData,y  ;against bits based on offset
      if (!BEQ InitPlatScrl) {  // from KeepOnscr
        lda #$00
        sta Player_X_Speed          ;otherwise nullify horizontal speed of player
      }
    }
  }
  KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
  sec
  sbc X_SubtracterData,y      ;subtract amount based on offset
  sta Player_X_Position       ;store as player position to prevent movement further
  lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
  sbc #$00                    ;subtract borrow
  sta Player_PageLoc          ;save as player's page location
  lda Left_Right_Buttons      ;check saved controller bits
  cmp OffscrJoypadBitsData,y  ;against bits based on offset
  if (!BEQ InitPlatScrl) {  // from KeepOnscr
  }
  // Block: InitPlatScrl
  InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
  sta Platform_X_Scroll
  rts

def EnemyTurnAround():
  // Block: EnemyTurnAround
  lda Enemy_ID,x           ;check for specific enemies
  cmp #PiranhaPlant
  beq ExTA                 ;if piranha plant, leave
  cmp #Lakitu
  beq ExTA                 ;if lakitu, leave
  cmp #HammerBro
  beq ExTA                 ;if hammer bro, leave
  cmp #Spiny
  beq RXSpd                ;if spiny, turn it around
  cmp #GreenParatroopaJump
  beq RXSpd                ;if green paratroopa, turn it around
  cmp #$07
  bcs ExTA                 ;if any OTHER enemy object => $07, leave

def GameRoutines():
  // Block: GameRoutines
  lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
  jsr JumpEngine            ;merely placeholders as conditions for other routines)
  lda AltEntranceControl    ;check for mode of alternate entry
  cmp #$02
  if (!BEQ EntrMode2) {  // from PlayerEntrance
    lda #$00
    ldy Player_Y_Position     ;if vertical position above a certain
    cpy #$30                  ;point, nullify controller bits and continue
    bcc AutoControlPlayer     ;with player movement code, do not return
    lda PlayerEntranceCtrl    ;check player entry bits from header
    cmp #$06
    if (!BEQ ChkBehPipe) {  // from @5501
      cmp #$07                  ;otherwise branch to normal entry
      if (!BNE PlayerRdy) {  // from @5504
        ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
        if (!BNE IntroEntr) {  // from ChkBehPipe
          lda #$01
          jmp AutoControlPlayer     ;force player to walk to the right
        }
        IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
        dec ChangeAreaTimer       ;decrement timer for change of area
        if (!BNE ExitEntr) {  // from IntroEntr
          inc DisableIntermediate   ;set flag to skip world and lives display
          jmp NextArea              ;jump to increment to next area and set modes
          EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
          if (!BNE VineEntr) {  // from EntrMode2
            lda #$ff                  ;otherwise, set value here then execute sub
            jsr MovePlayerYAxis       ;to move player upwards (note $ff = -1)
            lda Player_Y_Position     ;check to see if player is at a specific coordinate
            cmp #$91                  ;if player risen to a certain point (this requires pipes
            if (!BCC PlayerRdy) {  // from @5517
              rts                       ;to the last part, otherwise leave
              VineEntr:   lda VineHeight
              cmp #$60                  ;check vine height
              if (!BNE ExitEntr) {  // from VineEntr
                lda Player_Y_Position     ;get player's vertical coordinate
                cmp #$99                  ;check player's vertical coordinate against preset value
                ldy #$00                  ;load default values to be written to
                lda #$01                  ;this value moves player to the right off the vine
                if (!BCC OffVine) {  // from @5526
                  lda #$03
                  sta Player_State          ;otherwise set player state to climbing
                  iny                       ;increment value in Y
                  lda #$08                  ;set block in block buffer to cover hole, then
                }
                OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
                jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
                lda Player_X_Position
                cmp #$48                  ;check player's horizontal position
                if (!BCC ExitEntr) {  // from OffVine
                  // Block: PlayerRdy
                  PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
                  sta GameEngineSubroutine
                  lda #$01                  ;set to face player to the right
                  sta PlayerFacingDir
                  lsr                       ;init A
                  sta AltEntranceControl    ;init mode of entry
                  sta DisableCollisionDet   ;init collision detection disable flag
                  sta JoypadOverride        ;nullify controller override bits
                }
              }
            }
          }
          if (!BNE ExitEntr) {  // from VineEntr
            if (!BCC OffVine) {  // from @5526
            }
            if (!BCC ExitEntr) {  // from OffVine
            }
          }
        }
      }
    }
    if (!BNE IntroEntr) {  // from ChkBehPipe
    }
    if (!BNE ExitEntr) {  // from IntroEntr
      if (!BNE VineEntr) {  // from EntrMode2
        if (!BCC PlayerRdy) {  // from @5517
          if (!BNE ExitEntr) {  // from VineEntr
            if (!BCC OffVine) {  // from @5526
            }
            if (!BCC ExitEntr) {  // from OffVine
            }
          }
        }
      }
      if (!BNE ExitEntr) {  // from VineEntr
        if (!BCC OffVine) {  // from @5526
        }
        if (!BCC ExitEntr) {  // from OffVine
        }
      }
    }
  } else {
    if (!BNE VineEntr) {  // from EntrMode2
      if (!BCC PlayerRdy) {  // from @5517
        if (!BNE ExitEntr) {  // from VineEntr
          if (!BCC OffVine) {  // from @5526
          }
          if (!BCC ExitEntr) {  // from OffVine
          }
        }
      }
    }
    if (!BNE ExitEntr) {  // from VineEntr
      if (!BCC OffVine) {  // from @5526
      }
      if (!BCC ExitEntr) {  // from OffVine
      }
    }
    // Block: ExitEntr
    ExitEntr:   rts                       ;leave!
  }
  // Block: NextArea
  NextArea: inc AreaNumber            ;increment area number used for address loader
  jsr LoadAreaPointer       ;get new level pointer
  inc FetchNewGameTimerFlag ;set flag to load new game timer
  jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
  sta HalfwayPage           ;reset halfway page to 0 (beginning)
  lda #Silence
  sta EventMusicQueue       ;silence music and leave
  // Block: ExitNA
  ExitNA:   rts

def ColorRotation():
  lda FrameCounter         ;get frame counter
  and #$07                 ;mask out all but three LSB
  if (!BNE ExitColorRot) {  // from ColorRotation
    ldx VRAM_Buffer1_Offset  ;check vram buffer offset
    cpx #$31
    if (!BCS ExitColorRot) {  // from @1961
      tay                      ;otherwise use frame counter's 3 LSB as offset here
      do {  // loop2
        // Block: GetBlankPal
        GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
        sta VRAM_Buffer1,x       ;store it in the vram buffer
        inx                      ;increment offsets
        iny
        cpy #$08
        bcc GetBlankPal          ;do this until all bytes are copied
      } while (!BCC GetBlankPal)
      ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
      lda #$03
      sta $00                  ;set counter here
      lda AreaType             ;get area type
      asl                      ;multiply by 4 to get proper offset
      asl
      tay                      ;save as offset here
      do {  // loop5
        // Block: GetAreaPal
        GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
        sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
        iny
        inx
        dec $00                  ;decrement counter
        bpl GetAreaPal           ;do this until the palette is all copied
      } while (!BPL GetAreaPal)
      ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
      ldy ColorRotateOffset    ;get color cycling offset
      lda ColorRotatePalette,y
      sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
      lda VRAM_Buffer1_Offset
      clc                      ;add seven bytes to vram buffer offset
      adc #$07
      sta VRAM_Buffer1_Offset
      inc ColorRotateOffset    ;increment color cycling offset
      lda ColorRotateOffset
      cmp #$06                 ;check to see if it's still in range
      if (!BCC ExitColorRot) {  // from @1984
        lda #$00
        sta ColorRotateOffset    ;otherwise, init to keep it in range
      }
    }
  }
  // Block: ExitColorRot
  ExitColorRot: rts                      ;leave

def DestroyBlockMetatile():
  // Block: DestroyBlockMetatile
  lda #$00       ;force blank metatile if branched/jumped to this point

def EnemiesCollision():
  // Block: ExSFN
  ExSFN: rts
  do {  // loop3
    // Block: EnemiesCollision
    lda FrameCounter            ;check counter for d0 set
    lsr
    bcc ExSFN                   ;if d0 not set, leave
  } while (BCC ExSFN)
  do {  // loop7
    lda AreaType
    beq ExSFN                   ;if water area type, leave
  } while (BEQ ExSFN)
  lda Enemy_ID,x
  cmp #$15                    ;if enemy object => $15, branch to leave
  if (!BCS ExitECRoutine) {  // from @11557
    cmp #Lakitu                 ;if lakitu, branch to leave
    if (!BEQ ExitECRoutine) {  // from @11560
      cmp #PiranhaPlant           ;if piranha plant, branch to leave
      if (!BEQ ExitECRoutine) {  // from @11562
        lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
        if (!BNE ExitECRoutine) {  // from @11564
          jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
          dex                         ;first enemy we're going to compare, then decrement for second
          if (!BMI ExitECRoutine) {  // from @11566
            ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
            tya                         ;save first enemy's bounding box offset to stack
            pha
            lda Enemy_Flag,x            ;check enemy object enable flag
            if (!BEQ ReadyNextEnemy) {  // from ECLoop
              lda Enemy_ID,x
              cmp #$15                    ;check for enemy object => $15
              if (!BCS ReadyNextEnemy) {  // from @11574
                cmp #Lakitu
                if (!BEQ ReadyNextEnemy) {  // from @11577
                  cmp #PiranhaPlant
                  if (!BEQ ReadyNextEnemy) {  // from @11579
                    lda EnemyOffscrBitsMasked,x
                    if (!BNE ReadyNextEnemy) {  // from @11581
                      txa                         ;get second enemy object's bounding box offset
                      asl                         ;multiply by four, then add four
                      asl
                      clc
                      adc #$04
                      tax                         ;use as new contents of X
                      jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
                      ldx ObjectOffset            ;use first enemy offset for X
                      ldy $01                     ;use second enemy offset for Y
                      if (!BCC NoEnemyCollision) {  // from @11583
                        lda Enemy_State,x
                        ora Enemy_State,y           ;check both enemy states for d7 set
                        and #%10000000
                        if (!BNE YesEC) {  // from @11593
                          lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
                          and SetBitsMask,x           ;check to see if bit connected to second enemy is
                          if (!BNE ReadyNextEnemy) {  // from @11597
                            lda Enemy_CollisionBits,y
                            ora SetBitsMask,x           ;if the bit is not set, set it now
                            sta Enemy_CollisionBits,y
                            // Block: YesEC
                            YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
                            jmp ReadyNextEnemy          ;move onto next enemy slot
                            // Block: NoEnemyCollision
                            lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
                            and ClearBitsMask,x           ;clear bit connected to second enemy
                            sta Enemy_CollisionBits,y     ;then move onto next enemy slot
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            // Block: ReadyNextEnemy
            pla              ;get first enemy's bounding box offset from the stack
            tay              ;use as Y again
            ldx $01          ;get and decrement second enemy's object buffer offset
            dex
            bpl ECLoop       ;loop until all enemy slots have been checked
          }
        }
      }
    }
  }
  // Block: ExitECRoutine
  ldx ObjectOffset ;get enemy object buffer offset
  rts              ;leave

def ProcessBowserHalf():
  // Block: ExBGfxH
  ExBGfxH:  rts                      ;leave!
  do {  // loop3
    // Block: ProcessBowserHalf
    inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
    jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
    lda Enemy_State,x
    bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
  } while (BNE ExBGfxH)
  lda #$0a
  sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
  jsr GetEnemyBoundBox      ;get bounding box coordinates
  jmp PlayerEnemyCollision  ;do player-to-enemy collision detection

def RenderSidewaysPipe():
  dey                       ;decrement twice to make room for shaft at bottom
  dey                       ;and store here for now as vertical length
  sty $05
  ldy AreaObjectLength,x    ;get length left over and store here
  sty $06
  ldx $05                   ;get vertical length plus one, use as buffer offset
  inx
  lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
  cmp #$00
  if (!BEQ DrawSidePart) {  // from RenderSidewaysPipe
    ldx #$00
    ldy $05                   ;init buffer offset and get vertical length
    jsr RenderUnderPart       ;and render vertical shaft using tile number in A
    clc                       ;clear carry flag to be used by IntroPipe
  }
  // Block: DrawSidePart
  DrawSidePart: ldy $06                   ;render side pipe part at the bottom
  lda SidePipeTopPart,y
  sta MetatileBuffer,x      ;note that the pipe parts are stored
  lda SidePipeBottomPart,y  ;backwards horizontally
  sta MetatileBuffer+1,x
  rts

def DrawBubble():
  ldy Player_Y_HighPos        ;if player's vertical high position
  dey                         ;not within screen, skip all of this
  if (!BNE ExDBub) {  // from DrawBubble
    lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
    and #%00001000
    if (!BNE ExDBub) {  // from @14375
      ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
      lda Bubble_Rel_XPos         ;get relative horizontal coordinate
      sta Sprite_X_Position,y     ;store as X coordinate here
      lda Bubble_Rel_YPos         ;get relative vertical coordinate
      sta Sprite_Y_Position,y     ;store as Y coordinate here
      lda #$74
      sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
      lda #$02
      sta Sprite_Attributes,y     ;set attribute byte
    }
  }
  // Block: ExDBub
  ExDBub: rts                         ;leave

def WritePPUReg1():
  // Block: WritePPUReg1
  sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
  sta Mirror_PPU_CTRL_REG1  ;and its mirror
  rts

def PosPlatform():
  // Block: PosPlatform
  lda Enemy_X_Position,x  ;get horizontal coordinate
  clc
  adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
  sta Enemy_X_Position,x  ;store as new horizontal coordinate
  lda Enemy_PageLoc,x
  adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
  sta Enemy_PageLoc,x     ;store as new page location
  rts                     ;and go back

def ProcFireball_Bubble():
  lda PlayerStatus           ;check player's status
  cmp #$02
  if (!BCC ProcAirBubbles) {  // from ProcFireball_Bubble
    lda A_B_Buttons
    and #B_Button              ;check for b button pressed
    if (!BEQ ProcFireballs) {  // from @6276
      and PreviousA_B_Buttons
      if (!BNE ProcFireballs) {  // from @6279
        lda FireballCounter        ;load fireball counter
        and #%00000001             ;get LSB and use as offset for buffer
        tax
        lda Fireball_State,x       ;load fireball state
        if (!BNE ProcFireballs) {  // from @6281
          ldy Player_Y_HighPos       ;if player too high or too low, branch
          dey
          if (!BNE ProcFireballs) {  // from @6286
            lda CrouchingFlag          ;if player crouching, branch
            if (!BNE ProcFireballs) {  // from @6289
              lda Player_State           ;if player's state = climbing, branch
              cmp #$03
              if (!BEQ ProcFireballs) {  // from @6291
                lda #Sfx_Fireball          ;play fireball sound effect
                sta Square1SoundQueue
                lda #$02                   ;load state
                sta Fireball_State,x
                ldy PlayerAnimTimerSet     ;copy animation frame timer setting
                sty FireballThrowingTimer  ;into fireball throwing timer
                dey
                sty PlayerAnimTimer        ;decrement and store in player's animation timer
                inc FireballCounter        ;increment fireball counter
              }
            }
          }
        }
      }
    }
    // Block: ProcFireballs
    ldx #$00
    jsr FireballObjCore  ;process first fireball object
    ldx #$01
    jsr FireballObjCore  ;process second fireball object, then do air bubbles
  }
  lda AreaType                ;if not water type level, skip the rest of this
  if (!BNE BublExit) {  // from ProcAirBubbles
    ldx #$02                    ;otherwise load counter and use as offset
    do {  // loop11
      // Block: BublLoop
      BublLoop: stx ObjectOffset            ;store offset
      jsr BubbleCheck             ;check timers and coordinates, create air bubble
      jsr RelativeBubblePosition  ;get relative coordinates
      jsr GetBubbleOffscreenBits  ;get offscreen information
      jsr DrawBubble              ;draw the air bubble
      dex
      bpl BublLoop                ;do this until all three are handled
    } while (!BPL BublLoop)
  }
  // Block: BublExit
  BublExit: rts                         ;then leave

def PutBlockMetatile():
  stx $00               ;store control bit from SprDataOffset_Ctrl
  sty $01               ;store vram buffer offset for next byte
  asl
  asl                   ;multiply A by four and use as X
  tax
  ldy #$20              ;load high byte for name table 0
  lda $06               ;get low byte of block buffer pointer
  cmp #$d0              ;check to see if we're on odd-page block buffer
  if (!BCC SaveHAdder) {  // from PutBlockMetatile
    ldy #$24              ;otherwise load high byte for name table 1
  }
  // Block: SaveHAdder
  SaveHAdder: sty $03               ;save high byte here
  and #$0f              ;mask out high nybble of block buffer pointer
  asl                   ;multiply by 2 to get appropriate name table low byte
  sta $04               ;and then store it here
  lda #$00
  sta $05               ;initialize temp high byte
  lda $02               ;get vertical high nybble offset used in block buffer routine
  clc
  adc #$20              ;add 32 pixels for the status bar
  asl
  rol $05               ;shift and rotate d7 onto d0 and d6 into carry
  asl
  rol $05               ;shift and rotate d6 onto d0 and d5 into carry
  adc $04               ;add low byte of name table and carry to vertical high nybble
  sta $04               ;and store here
  lda $05               ;get whatever was in d7 and d6 of vertical high nybble
  adc #$00              ;add carry
  clc
  adc $03               ;then add high byte of name table
  sta $05               ;store here
  ldy $01               ;get vram buffer offset to be used

def GetCurrentAnimOffset():
  // Block: GetCurrentAnimOffset
  lda PlayerAnimCtrl         ;get animation frame control
  jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
  // Block: GetOffsetFromAnimCtrl
  asl                        ;multiply animation frame control
  asl                        ;by eight to get proper amount
  asl                        ;to add to our offset
  adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
  rts                        ;and return with result in A

def GetAreaObjXPosition():
  // Block: GetAreaObjXPosition
  lda CurrentColumnPos    ;multiply current offset where we're at by 16
  asl                     ;to obtain horizontal pixel coordinate
  asl
  asl
  asl
  rts

def GetEnemyBoundBoxOfsArg():
  // Block: GetEnemyBoundBoxOfsArg
  asl                      ;multiply A by four, then add four
  asl                      ;to skip player's bounding box
  clc
  adc #$04
  tay                      ;send to Y
  lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
  and #%00001111           ;save low nybble
  cmp #%00001111           ;check for all bits set
  rts

def CheckForCoinMTiles():
  cmp #$c2              ;check for regular coin
  if (!BEQ CoinSd) {  // from CheckForCoinMTiles
    cmp #$c3              ;check for underwater coin
    if (!BEQ CoinSd) {  // from @12373
      clc                   ;otherwise clear carry and leave
      rts
    }
  }
  // Block: CoinSd
  CoinSd:  lda #Sfx_CoinGrab
  sta Square2SoundQueue ;load coin grab sound and leave
  rts

def GetBubbleOffscreenBits():
  // Block: GetBubbleOffscreenBits
  ldy #$01                 ;set for air bubble offsets
  jsr GetProperObjOffset   ;modify X to get proper air bubble offset
  ldy #$03                 ;set other offset for airbubble's offscreen bits
  jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble

def FindPlayerAction():
  // Block: FindPlayerAction
  jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
  jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing

def MoveD_EnemyVertically():
  ldy #$3d           ;set quick movement amount downwards
  lda Enemy_State,x  ;then check enemy state
  cmp #$05           ;if not set to unique state for spiny's egg, go ahead
  if (!BNE ContVMove) {  // from MoveD_EnemyVertically
  }
  // Block: ContVMove
  ContVMove: jmp SetHiMax   ;jump to skip the rest of this
  // Block: SetHiMax
  SetHiMax:    lda #$03                ;set maximum speed in A

def GetMiscOffscreenBits():
  // Block: GetMiscOffscreenBits
  ldy #$02                 ;set for misc object offsets
  jsr GetProperObjOffset   ;modify X to get proper misc object offset
  ldy #$06                 ;set other offset for misc object's offscreen bits
  jmp GetOffScreenBitsSet  ;and get offscreen information about misc object

def EnemyGfxHandler():
  lda Enemy_Y_Position,x      ;get enemy object vertical position
  sta $02
  lda Enemy_Rel_XPos          ;get enemy object horizontal position
  sta $05                     ;relative to screen
  ldy Enemy_SprDataOffset,x
  sty $eb                     ;get sprite data offset
  lda #$00
  sta VerticalFlipFlag        ;initialize vertical flip flag by default
  lda Enemy_MovingDir,x
  sta $03                     ;get enemy object moving direction
  lda Enemy_SprAttrib,x
  sta $04                     ;get enemy object sprite attributes
  lda Enemy_ID,x
  cmp #PiranhaPlant           ;is enemy object piranha plant?
  if (!BNE CheckForRetainerObj) {  // from EnemyGfxHandler
    ldy PiranhaPlant_Y_Speed,x
    if (!BMI CheckForRetainerObj) {  // from @13629
      ldy EnemyFrameTimer,x
      if (!BEQ CheckForRetainerObj) {  // from @13631
        rts                         ;if all conditions fail, leave
      }
    }
  }
  lda Enemy_State,x           ;store enemy state
  sta $ed
  and #%00011111              ;nullify all but 5 LSB and use as Y
  tay
  lda Enemy_ID,x              ;check for mushroom retainer/princess object
  cmp #RetainerObject
  if (!BNE CheckForBulletBillCV) {  // from CheckForRetainerObj
    ldy #$00                    ;if found, nullify saved state in Y
    lda #$01                    ;set value that will not be used
    sta $03
    lda #$15                    ;set value $15 as code for mushroom retainer/princess object
  }
  cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
  if (!BNE CheckForJumpspring) {  // from CheckForBulletBillCV
    dec $02                     ;decrement saved vertical position
    lda #$03
    ldy EnemyFrameTimer,x       ;get timer for enemy object
    if (!BEQ SBBAt) {  // from @13651
      ora #%00100000              ;otherwise do so
    }
    // Block: SBBAt
    SBBAt: sta $04                     ;set new sprite attributes
    ldy #$00                    ;nullify saved enemy state both in Y and in
    sty $ed                     ;memory location here
    lda #$08                    ;set specific value to unconditionally branch once
  }
  cmp #JumpspringObject        ;check for jumpspring object
  if (!BNE CheckForPodoboo) {  // from CheckForJumpspring
    ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
    ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
    lda JumpspringFrameOffsets,x ;load data using frame number as offset
  }
  sta $ef                 ;store saved enemy object value here
  sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
  ldx ObjectOffset        ;get enemy object offset
  cmp #$0c                ;check for podoboo object
  if (!BNE CheckBowserGfxFlag) {  // from CheckForPodoboo
    lda Enemy_Y_Speed,x     ;if moving upwards, branch
    if (!BMI CheckBowserGfxFlag) {  // from @13674
      inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
    }
  }
  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
  if (!BEQ CheckForGoomba) {  // from CheckBowserGfxFlag
    ldy #$16            ;if set to 1, draw bowser's front
    cmp #$01
    if (!BEQ SBwsrGfxOfs) {  // from @13681
      iny                 ;otherwise draw bowser's rear
    }
    // Block: SBwsrGfxOfs
    SBwsrGfxOfs: sty $ef
  }
  ldy $ef               ;check value for goomba object
  cpy #Goomba
  if (!BNE CheckBowserFront) {  // from CheckForGoomba
    lda Enemy_State,x
    cmp #$02              ;check for defeated state
    if (!BCC GmbaAnim) {  // from @13691
      ldx #$04              ;if defeated, write new value here
      stx $ec
    }
    GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
    ora TimerControl      ;or timer disable flag set
    if (!BNE CheckBowserFront) {  // from GmbaAnim
      lda FrameCounter
      and #%00001000        ;check for every eighth frame
      if (!BNE CheckBowserFront) {  // from @13699
        lda $03
        eor #%00000011        ;invert bits to flip horizontally every eight frames
        sta $03               ;leave alone otherwise
      }
    }
  }
  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
  ora $04                     ;as offset, and add to bits already loaded
  sta $04
  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
  tax                         ;save as X
  ldy $ec                     ;get previously saved value
  lda BowserGfxFlag
  if (!BEQ CheckForSpiny) {  // from CheckBowserFront
    cmp #$01
    if (!BNE CheckBowserRear) {  // from @13715
      lda BowserBodyControls      ;check bowser's body control bits
      if (!BPL ChkFrontSte) {  // from @13717
        ldx #$de                    ;otherwise load offset for second frame
      }
      ChkFrontSte: lda $ed                     ;check saved enemy state
      and #%00100000              ;if bowser not defeated, do not set flag
      if (!BEQ DrawBowser) {  // from ChkFrontSte
        // Block: FlipBowserOver
        stx VerticalFlipFlag  ;set vertical flip flag to nonzero
      }
      // Block: DrawBowser
      jmp DrawEnemyObject   ;draw bowser's graphics now
    }
    lda BowserBodyControls  ;check bowser's body control bits
    and #$01
    if (!BEQ ChkRearSte) {  // from CheckBowserRear
      ldx #$e4                ;otherwise load offset for second frame
    }
    do {  // loop38
      // Block: ChkRearSte
      ChkRearSte: lda $ed                 ;check saved enemy state
      and #%00100000          ;if bowser not defeated, do not set flag
      beq DrawBowser
    } while (BEQ DrawBowser)
    loop {  // loop45 (infinite)
      lda $02                 ;subtract 16 pixels from
      sec                     ;saved vertical coordinate
      sbc #$10
      sta $02
      jmp FlipBowserOver      ;jump to set vertical flip flag
    }
  }
  cpx #$24               ;check if value loaded is for spiny
  if (!BNE CheckForLakitu) {  // from CheckForSpiny
    cpy #$05               ;if enemy state set to $05, do this,
    if (!BNE NotEgg) {  // from @13747
      ldx #$30               ;set to spiny egg offset
      lda #$02
      sta $03                ;set enemy direction to reverse sprites horizontally
      lda #$05
      sta $ec                ;set enemy state
    }
  } else {
    cpx #$90                  ;check value for lakitu's offset loaded
    if (!BNE CheckUpsideDownShell) {  // from CheckForLakitu
      lda $ed
      and #%00100000            ;check for d5 set in enemy state
      if (!BNE NoLAFr) {  // from @13759
        lda FrenzyEnemyTimer
        cmp #$10                  ;check timer to see if we've reached a certain range
        if (!BCS NoLAFr) {  // from @13762
          ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
        }
      }
      // Block: NoLAFr
      NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
    }
    lda $ef                    ;check for enemy object => $04
    cmp #$04
    if (!BCS CheckRightSideUpShell) {  // from CheckUpsideDownShell
      cpy #$02
      if (!BCC CheckRightSideUpShell) {  // from @13772
        ldx #$5a                   ;set for upside-down koopa shell by default
        ldy $ef
        cpy #BuzzyBeetle           ;check for buzzy beetle object
        if (!BNE CheckRightSideUpShell) {  // from @13774
          ldx #$7e                   ;set for upside-down buzzy beetle shell if found
          inc $02                    ;increment vertical position by one pixel
        }
      }
    }
    lda $ec                ;check for value set here
    cmp #$04               ;if enemy state < $02, do not change to shell, if
    if (!BNE CheckForHammerBro) {  // from CheckRightSideUpShell
      ldx #$72               ;set right-side up buzzy beetle shell by default
      inc $02                ;increment saved vertical position by one pixel
      ldy $ef
      cpy #BuzzyBeetle       ;check for buzzy beetle object
      if (!BEQ CheckForDefdGoomba) {  // from @13785
        ldx #$66               ;change to right-side up koopa shell if not found
        inc $02                ;and increment saved vertical position again
      }
      cpy #Goomba            ;check for goomba object (necessary if previously
      if (!BNE CheckForHammerBro) {  // from CheckForDefdGoomba
        ldx #$54               ;load for regular goomba
        lda $ed                ;note that this only gets performed if enemy state => $02
        and #%00100000         ;check saved enemy state for d5 set
        if (!BNE CheckForHammerBro) {  // from @13796
          ldx #$8a               ;load offset for defeated goomba
          dec $02                ;set different value and decrement saved vertical position
        }
      }
    }
  }
  ldy ObjectOffset
  lda $ef                  ;check for hammer bro object
  cmp #HammerBro
  if (!BNE CheckForBloober) {  // from CheckForHammerBro
    lda $ed
    if (!BEQ CheckToAnimateEnemy) {  // from @13808
      and #%00001000
      if (!BEQ CheckDefeatedState) {  // from @13810
        ldx #$b4                 ;otherwise load offset for different frame
        if (!BNE CheckToAnimateEnemy) {  // from @13812
          cpx #$48                 ;check for cheep-cheep offset loaded
          if (!BEQ CheckToAnimateEnemy) {  // from CheckForBloober
            lda EnemyIntervalTimer,y
            cmp #$05
            if (!BCS CheckDefeatedState) {  // from @13818
              cpx #$3c                 ;check for bloober offset loaded
              if (!BNE CheckToAnimateEnemy) {  // from @13821
                cmp #$01
                if (!BEQ CheckDefeatedState) {  // from @13823
                  inc $02                  ;increment saved vertical coordinate three pixels
                  inc $02
                  inc $02
                  jmp CheckAnimationStop   ;and do something else
                  lda $ef                  ;check for specific enemy objects
                  cmp #Goomba
                  if (!BEQ CheckDefeatedState) {  // from CheckToAnimateEnemy
                    cmp #$08
                    if (!BEQ CheckDefeatedState) {  // from @13834
                      cmp #Podoboo
                      if (!BEQ CheckDefeatedState) {  // from @13836
                        cmp #$18                 ;branch if => $18
                        if (!BCS CheckDefeatedState) {  // from @13838
                          ldy #$00
                          cmp #$15                 ;check for mushroom retainer/princess object
                          if (!BNE CheckForSecondFrame) {  // from @13840
                            iny                      ;residual instruction
                            lda WorldNumber          ;are we on world 8?
                            cmp #World8
                            if (!BCS CheckDefeatedState) {  // from @13843
                              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
                              lda #$03                 ;set alternate state here
                              sta $ec
                              if (!BNE CheckDefeatedState) {  // from @13847
                                lda FrameCounter            ;load frame counter
                                and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
                                if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                                  lda $ed                 ;check saved enemy state
                                  and #%10100000          ;for d7 or d5, or check for timers stopped
                                  ora TimerControl
                                  if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                                    txa
                                    clc
                                    adc #$06                ;add $06 to current enemy offset
                                    tax                     ;to animate various enemy objects
                                  }
                                }
                              }
                            }
                          }
                          if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                            if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (!BEQ CheckDefeatedState) {  // from CheckToAnimateEnemy
                  if (!BEQ CheckDefeatedState) {  // from @13834
                    if (!BEQ CheckDefeatedState) {  // from @13836
                      if (!BCS CheckDefeatedState) {  // from @13838
                        if (!BNE CheckForSecondFrame) {  // from @13840
                          if (!BCS CheckDefeatedState) {  // from @13843
                            if (!BNE CheckDefeatedState) {  // from @13847
                              if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                                if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                                }
                              }
                            }
                          }
                        }
                        if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                          if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
              }
            }
          }
        } else {
          if (!BEQ CheckDefeatedState) {  // from CheckToAnimateEnemy
            if (!BEQ CheckDefeatedState) {  // from @13834
              if (!BEQ CheckDefeatedState) {  // from @13836
                if (!BCS CheckDefeatedState) {  // from @13838
                  if (!BNE CheckForSecondFrame) {  // from @13840
                    if (!BCS CheckDefeatedState) {  // from @13843
                      if (!BNE CheckDefeatedState) {  // from @13847
                        if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                          if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                          }
                        }
                      }
                    }
                  }
                  if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                    if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                    }
                  }
                }
              }
            }
          }
        }
        if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
        }
      }
    }
  }
  cpx #$48                 ;check for cheep-cheep offset loaded
  if (!BEQ CheckToAnimateEnemy) {  // from CheckForBloober
    lda EnemyIntervalTimer,y
    cmp #$05
    if (!BCS CheckDefeatedState) {  // from @13818
      cpx #$3c                 ;check for bloober offset loaded
      if (!BNE CheckToAnimateEnemy) {  // from @13821
        cmp #$01
        if (!BEQ CheckDefeatedState) {  // from @13823
          lda $ef                  ;check for specific enemy objects
          cmp #Goomba
          if (!BEQ CheckDefeatedState) {  // from CheckToAnimateEnemy
            cmp #$08
            if (!BEQ CheckDefeatedState) {  // from @13834
              cmp #Podoboo
              if (!BEQ CheckDefeatedState) {  // from @13836
                cmp #$18                 ;branch if => $18
                if (!BCS CheckDefeatedState) {  // from @13838
                  ldy #$00
                  cmp #$15                 ;check for mushroom retainer/princess object
                  if (!BNE CheckForSecondFrame) {  // from @13840
                    iny                      ;residual instruction
                    lda WorldNumber          ;are we on world 8?
                    cmp #World8
                    if (!BCS CheckDefeatedState) {  // from @13843
                      ldx #$a2                 ;otherwise, set for mushroom retainer object instead
                      lda #$03                 ;set alternate state here
                      sta $ec
                      if (!BNE CheckDefeatedState) {  // from @13847
                        lda FrameCounter            ;load frame counter
                        and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
                        if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                          lda $ed                 ;check saved enemy state
                          and #%10100000          ;for d7 or d5, or check for timers stopped
                          ora TimerControl
                          if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                          }
                        }
                      }
                    }
                  }
                  if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                    if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (!BEQ CheckDefeatedState) {  // from CheckToAnimateEnemy
          if (!BEQ CheckDefeatedState) {  // from @13834
            if (!BEQ CheckDefeatedState) {  // from @13836
              if (!BCS CheckDefeatedState) {  // from @13838
                if (!BNE CheckForSecondFrame) {  // from @13840
                  if (!BCS CheckDefeatedState) {  // from @13843
                    if (!BNE CheckDefeatedState) {  // from @13847
                      if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                        if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                        }
                      }
                    }
                  }
                }
                if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                  if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                  }
                }
              }
            }
          }
        }
      }
      if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
      }
    }
  } else {
    if (!BEQ CheckDefeatedState) {  // from CheckToAnimateEnemy
      if (!BEQ CheckDefeatedState) {  // from @13834
        if (!BEQ CheckDefeatedState) {  // from @13836
          if (!BCS CheckDefeatedState) {  // from @13838
            if (!BNE CheckForSecondFrame) {  // from @13840
              if (!BCS CheckDefeatedState) {  // from @13843
                if (!BNE CheckDefeatedState) {  // from @13847
                  if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
                    if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
                    }
                  }
                }
              }
            }
            if (!BNE CheckDefeatedState) {  // from CheckForSecondFrame
              if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
              }
            }
          }
        }
      }
    }
  }
  lda $ed                 ;check saved enemy state
  and #%10100000          ;for d7 or d5, or check for timers stopped
  ora TimerControl
  if (!BNE CheckDefeatedState) {  // from CheckAnimationStop
  }
  lda $ed               ;check saved enemy state
  and #%00100000        ;for d5 set
  if (!BEQ DrawEnemyObject) {  // from CheckDefeatedState
    lda $ef
    cmp #$04              ;check for saved enemy object => $04
    if (!BCC DrawEnemyObject) {  // from @13871
      ldy #$01
      sty VerticalFlipFlag  ;set vertical flip flag
      dey
      sty $ec               ;init saved value here
    }
  }
  ldy $eb                    ;load sprite data offset
  jsr DrawEnemyObjRow        ;draw six tiles of data
  jsr DrawEnemyObjRow        ;into sprite data
  jsr DrawEnemyObjRow
  ldx ObjectOffset           ;get enemy object offset
  ldy Enemy_SprDataOffset,x  ;get sprite data offset
  lda $ef
  cmp #$08                   ;get saved enemy object and check
  if (!BNE CheckForVerticalFlip) {  // from DrawEnemyObject
    // Block: SkipToOffScrChk
    jmp SprObjectOffscrChk     ;jump if found
  }
  lda VerticalFlipFlag       ;check if vertical flip flag is set here
  if (!BEQ CheckForESymmetry) {  // from CheckForVerticalFlip
    lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
    ora #%10000000             ;set bit for vertical flip
    iny
    iny                        ;increment two bytes so that we store the vertical flip
    jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
    dey
    dey                        ;now go back to the Y coordinate offset
    tya
    tax                        ;give offset to X
    lda $ef
    cmp #HammerBro             ;check saved enemy object for hammer bro
    if (!BEQ FlipEnemyVertically) {  // from @13896
      cmp #Lakitu                ;check saved enemy object for lakitu
      if (!BEQ FlipEnemyVertically) {  // from @13908
        cmp #$15
        if (!BCS FlipEnemyVertically) {  // from @13910
          txa
          clc
          adc #$08                   ;if not selected objects or => $15, set
          tax                        ;offset in X for next row
        }
      }
    }
    // Block: FlipEnemyVertically
    lda Sprite_Tilenumber,x     ;load first or second row tiles
    pha                         ;and save tiles to the stack
    lda Sprite_Tilenumber+4,x
    pha
    lda Sprite_Tilenumber+16,y  ;exchange third row tiles
    sta Sprite_Tilenumber,x     ;with first or second row tiles
    lda Sprite_Tilenumber+20,y
    sta Sprite_Tilenumber+4,x
    pla                         ;pull first or second row tiles from stack
    sta Sprite_Tilenumber+20,y  ;and save in third row
    pla
    sta Sprite_Tilenumber+16,y
  }
  do {  // loop204
    // Block: CheckForVerticalFlip
    lda VerticalFlipFlag       ;check if vertical flip flag is set here
    beq CheckForESymmetry      ;branch if not
    lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
    ora #%10000000             ;set bit for vertical flip
    iny
    iny                        ;increment two bytes so that we store the vertical flip
    jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
    dey
    dey                        ;now go back to the Y coordinate offset
    tya
    tax                        ;give offset to X
    lda $ef
    cmp #HammerBro             ;check saved enemy object for hammer bro
    beq FlipEnemyVertically
    cmp #Lakitu                ;check saved enemy object for lakitu
    beq FlipEnemyVertically    ;branch for hammer bro or lakitu
    cmp #$15
    bcs FlipEnemyVertically    ;also branch if enemy object => $15
    // Block: CheckForESymmetry
    lda BowserGfxFlag           ;are we drawing bowser at all?
    bne SkipToOffScrChk         ;branch if so
  } while (BNE SkipToOffScrChk)
  lda $ef
  ldx $ec                     ;get alternate enemy state
  cmp #$05                    ;check for hammer bro object
  if (!BNE ContES) {  // from @13934
    jmp SprObjectOffscrChk      ;jump if found
  }
  ContES: cmp #Bloober                ;check for bloober object
  if (!BEQ MirrorEnemyGfx) {  // from ContES
    cmp #PiranhaPlant           ;check for piranha plant object
    if (!BEQ MirrorEnemyGfx) {  // from @13941
      cmp #Podoboo                ;check for podoboo object
      if (!BEQ MirrorEnemyGfx) {  // from @13943
        cmp #Spiny                  ;check for spiny object
        if (!BNE ESRtnr) {  // from @13945
          cpx #$05                    ;check spiny's state
          if (!BNE CheckToMirrorLakitu) {  // from @13947
            ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
            if (!BNE SpnySC) {  // from ESRtnr
              lda #$42                    ;set horizontal flip on bottom right sprite
              sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
            }
            SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
            if (!BCC CheckToMirrorLakitu) {  // from SpnySC
              lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
              if (!BNE CheckToMirrorLakitu) {  // from MirrorEnemyGfx
                lda Sprite_Attributes,y     ;load attribute bits of first sprite
                and #%10100011
                sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
                sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
                sta Sprite_Attributes+16,y
                ora #%01000000              ;set horizontal flip
                cpx #$05                    ;check for state used by spiny's egg
                if (!BNE EggExc) {  // from @13959
                  ora #%10000000              ;otherwise set vertical flip
                }
                EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
                sta Sprite_Attributes+12,y  ;of enemy object sprite data
                sta Sprite_Attributes+20,y
                cpx #$04                    ;check alternate enemy state
                if (!BNE CheckToMirrorLakitu) {  // from EggExc
                  lda Sprite_Attributes+8,y   ;get second row left sprite attributes
                  ora #%10000000
                  sta Sprite_Attributes+8,y   ;store bits with vertical flip in
                  sta Sprite_Attributes+16,y  ;second and third row left sprites
                  ora #%01000000
                  sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
                  sta Sprite_Attributes+20,y  ;second and third row right sprites
                }
              }
            }
          }
        }
        if (!BNE SpnySC) {  // from ESRtnr
        }
        if (!BCC CheckToMirrorLakitu) {  // from SpnySC
          if (!BNE CheckToMirrorLakitu) {  // from MirrorEnemyGfx
            if (!BNE EggExc) {  // from @13959
            }
            if (!BNE CheckToMirrorLakitu) {  // from EggExc
            }
          }
        }
      }
    }
  }
  lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
  if (!BNE CheckToMirrorLakitu) {  // from MirrorEnemyGfx
    lda Sprite_Attributes,y     ;load attribute bits of first sprite
    and #%10100011
    sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
    sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
    sta Sprite_Attributes+16,y
    ora #%01000000              ;set horizontal flip
    cpx #$05                    ;check for state used by spiny's egg
    if (!BNE EggExc) {  // from @13959
    }
    EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
    sta Sprite_Attributes+12,y  ;of enemy object sprite data
    sta Sprite_Attributes+20,y
    cpx #$04                    ;check alternate enemy state
    if (!BNE CheckToMirrorLakitu) {  // from EggExc
    }
  }
  lda $ef                     ;check for lakitu enemy object
  cmp #Lakitu
  if (!BNE CheckToMirrorJSpring) {  // from CheckToMirrorLakitu
    lda VerticalFlipFlag
    if (!BNE NVFLak) {  // from @13985
      lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
      and #%10000001              ;in third row left sprite
      sta Sprite_Attributes+16,y
      lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
      ora #%01000001              ;in third row right sprite
      sta Sprite_Attributes+20,y
      ldx FrenzyEnemyTimer        ;check timer
      cpx #$10
      bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
      sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
      and #%10000001
      sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
      bcc SprObjectOffscrChk      ;unconditional branch
    }
    // Block: NVFLak
    NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
    and #%10000001
    sta Sprite_Attributes,y     ;save vertical flip and palette bits
    lda Sprite_Attributes+4,y   ;get first row right sprite attributes
    ora #%01000001              ;set horizontal flip and palette bits
    sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
  }
  // Block: CheckToMirrorJSpring
  lda $ef                     ;check for jumpspring object (any frame)
  cmp #$18
  bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
  lda #$82
  sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
  sta Sprite_Attributes+16,y  ;second and third row left sprites
  ora #%01000000
  sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
  sta Sprite_Attributes+20,y  ;for second and third row right sprites

def HandleEnemyFBallCol():
  jsr RelativeEnemyPosition  ;get relative coordinate of enemy
  ldx $01                    ;get current enemy object offset
  lda Enemy_Flag,x           ;check buffer flag for d7 set
  if (!BPL ChkBuzzyBeetle) {  // from HandleEnemyFBallCol
    and #%00001111             ;otherwise mask out high nybble and
    tax                        ;use low nybble as enemy offset
    lda Enemy_ID,x
    cmp #Bowser                ;check enemy identifier for bowser
    if (!BEQ HurtBowser) {  // from @11127
      ldx $01                    ;otherwise retrieve current enemy offset
      // Block: ChkBuzzyBeetle
      lda Enemy_ID,x
      cmp #BuzzyBeetle           ;check for buzzy beetle
      beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
      cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
      if (!BNE ChkOtherEnemies) {  // from @11138
        // Block: HurtBowser
        dec BowserHitPoints        ;decrement bowser's hit points
        bne ExHCF                  ;if bowser still has hit points, branch to leave
        jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
        sta Enemy_X_Speed,x        ;initialize horizontal speed
        sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
        lda #$fe
        sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
        ldy WorldNumber            ;use world number as offset
        lda BowserIdentities,y     ;get enemy identifier to replace bowser with
        sta Enemy_ID,x             ;set as new enemy identifier
        lda #$20                   ;set A to use starting value for state
        cpy #$03                   ;check to see if using offset of 3 or more
        if (!BCS SetDBSte) {  // from @11144
          ora #$03                   ;otherwise add 3 to enemy state
        }
        // Block: SetDBSte
        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
        lda #Sfx_BowserFall
        sta Square2SoundQueue      ;load bowser defeat sound
        ldx $01                    ;get enemy offset
        lda #$09                   ;award 5000 points to player for defeating bowser
        bne EnemySmackScore        ;unconditional branch to award points
      }
    }
  }
  cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
  if (!BNE ChkOtherEnemies) {  // from @11138
    jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
    sta Enemy_X_Speed,x        ;initialize horizontal speed
    sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
    lda #$fe
    sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
    ldy WorldNumber            ;use world number as offset
    lda BowserIdentities,y     ;get enemy identifier to replace bowser with
    sta Enemy_ID,x             ;set as new enemy identifier
    lda #$20                   ;set A to use starting value for state
    cpy #$03                   ;check to see if using offset of 3 or more
    if (!BCS SetDBSte) {  // from @11144
    }
  }
  // Block: ChkOtherEnemies
  cmp #BulletBill_FrenzyVar
  beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
  cmp #Podoboo
  beq ExHCF                 ;branch to leave if podoboo
  cmp #$15
  bcs ExHCF                 ;branch to leave if identifier => $15

def DrawOneSpriteRow():
  // Block: DrawOneSpriteRow
  sta $01
  jmp DrawSpriteObject        ;draw them
  lda $03                    ;get saved flip control bits
  lsr
  lsr                        ;move d1 into carry
  lda $00
  if (!BCC NoHFlip) {  // from DrawSpriteObject
    sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
    lda $01                    ;and second into first sprite
    sta Sprite_Tilenumber,y
    lda #$40                   ;activate horizontal flip OAM attribute
    if (!BNE SetHFAt) {  // from @15005
      // Block: NoHFlip
      NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
      lda $01                    ;and second into second sprite
      sta Sprite_Tilenumber+4,y
      lda #$00                   ;clear bit for horizontal flip
    }
  }
  // Block: SetHFAt
  SetHFAt: ora $04                    ;add other OAM attributes if necessary
  sta Sprite_Attributes,y    ;store sprite attributes
  sta Sprite_Attributes+4,y
  lda $02                    ;now the y coordinates
  sta Sprite_Y_Position,y    ;note because they are
  sta Sprite_Y_Position+4,y  ;side by side, they are the same
  lda $05
  sta Sprite_X_Position,y    ;store x coordinate, then
  clc                        ;add 8 pixels and store another to
  adc #$08                   ;put them side by side
  sta Sprite_X_Position+4,y
  lda $02                    ;add eight pixels to the next y
  clc                        ;coordinate
  adc #$08
  sta $02
  tya                        ;add eight to the offset in Y to
  clc                        ;move to the next two sprites
  adc #$08
  tay
  inx                        ;increment offset to return it to the
  inx                        ;routine that called this subroutine
  rts

def GetProperObjOffset():
  // Block: GetProperObjOffset
  txa                  ;move offset to A
  clc
  adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
  tax                  ;put back in X and leave
  rts

def ReadJoypads():
  // Block: ReadJoypads
  lda #$01               ;reset and clear strobe of joypad ports
  sta JOYPAD_PORT
  lsr
  tax                    ;start with joypad 1's port
  sta JOYPAD_PORT
  jsr ReadPortBits
  inx                    ;increment for joypad 2's port

def KillEnemies():
  // Block: KillEnemies
  sta $00           ;store identifier here
  lda #$00
  ldx #$04          ;check for identifier in enemy object buffer
  NoKillE:   dex               ;do this until all slots are checked
  while (!BPL KillELoop) {  // loop6
    sta Enemy_Flag,x  ;if found, deactivate enemy object flag
    do {  // loop5
      // Block: KillELoop
      KillELoop: ldy Enemy_ID,x
      cpy $00           ;if not found, branch
      bne NoKillE
    } while (BPL KillELoop)
  }
  rts

def GetFireballOffscreenBits():
  // Block: GetFireballOffscreenBits
  ldy #$00                 ;set for fireball offsets
  jsr GetProperObjOffset   ;modify X to get proper fireball offset
  ldy #$02                 ;set other offset for fireball's offscreen bits
  jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
  // Block: GetOffScreenBitsSet
  tya                         ;save offscreen bits offset to stack for now
  pha
  jsr RunOffscrBitsSubs
  asl                         ;move low nybble to high nybble
  asl
  asl
  asl
  ora $00                     ;mask together with previously saved low nybble
  sta $00                     ;store both here
  pla                         ;get offscreen bits offset from stack
  tay
  lda $00                     ;get value here and store elsewhere
  sta SprObject_OffscrBits,y
  ldx ObjectOffset
  rts

def DrawSmallPlatform():
  ldy Enemy_SprDataOffset,x   ;get OAM data offset
  lda #$5b                    ;load tile number for small platforms
  iny                         ;increment offset for tile numbers
  jsr DumpSixSpr              ;dump tile number into all six sprites
  iny                         ;increment offset for attributes
  lda #$02                    ;load palette controls
  jsr DumpSixSpr              ;dump attributes into all six sprites
  dey                         ;decrement for original offset
  dey
  lda Enemy_Rel_XPos          ;get relative horizontal coordinate
  sta Sprite_X_Position,y
  sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
  clc
  adc #$08                    ;add eight pixels
  sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
  sta Sprite_X_Position+16,y
  clc
  adc #$08                    ;add eight more pixels
  sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
  sta Sprite_X_Position+20,y
  lda Enemy_Y_Position,x      ;get vertical coordinate
  tax
  pha                         ;save to stack
  cpx #$20                    ;if vertical coordinate below status bar,
  if (!BCS TopSP) {  // from DrawSmallPlatform
    lda #$f8                    ;otherwise move first three sprites offscreen
  }
  TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
  pla                         ;pull from stack
  clc
  adc #$80                    ;add 128 pixels
  tax
  cpx #$20                    ;if below status bar (taking wrap into account)
  if (!BCS BotSP) {  // from TopSP
    lda #$f8                    ;otherwise move last three sprites offscreen
  }
  BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
  sta Sprite_Y_Position+16,y  ;into Y coordinates
  sta Sprite_Y_Position+20,y
  lda Enemy_OffscreenBits     ;get offscreen bits
  pha                         ;save to stack
  and #%00001000              ;check d3
  if (!BEQ SOfs) {  // from BotSP
    lda #$f8                    ;if d3 was set, move first and
    sta Sprite_Y_Position,y     ;fourth sprites offscreen
    sta Sprite_Y_Position+12,y
  }
  SOfs:  pla                         ;move out and back into stack
  pha
  and #%00000100              ;check d2
  if (!BEQ SOfs2) {  // from SOfs
    lda #$f8                    ;if d2 was set, move second and
    sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
    sta Sprite_Y_Position+16,y
  }
  SOfs2: pla                         ;get from stack
  and #%00000010              ;check d1
  if (!BEQ ExSPl) {  // from SOfs2
    lda #$f8                    ;if d1 was set, move third and
    sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
    sta Sprite_Y_Position+20,y
  }
  // Block: ExSPl
  ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
  rts

def ChkForPlayerAttrib():
  ldy Player_SprDataOffset    ;get sprite data offset
  lda GameEngineSubroutine
  cmp #$0b                    ;if executing specific game engine routine,
  if (!BEQ KilledAtt) {  // from ChkForPlayerAttrib
    lda PlayerGfxOffset         ;get graphics table offset
    cmp #$50
    if (!BEQ C_S_IGAtt) {  // from @14732
      cmp #$b8                    ;or intermediate growing offset,
      if (!BEQ C_S_IGAtt) {  // from @14735
        cmp #$c0                    ;fourth row OAM attributes only
        if (!BEQ C_S_IGAtt) {  // from @14737
          cmp #$c8
          if (!BNE ExPlyrAt) {  // from @14739
            // Block: KilledAtt
            KilledAtt: lda Sprite_Attributes+16,y
            and #%00111111              ;mask out horizontal and vertical flip bits
            sta Sprite_Attributes+16,y  ;for third row sprites and save
            lda Sprite_Attributes+20,y
            and #%00111111
            ora #%01000000              ;set horizontal flip bit for second
            sta Sprite_Attributes+20,y  ;sprite in the third row
            // Block: C_S_IGAtt
            C_S_IGAtt: lda Sprite_Attributes+24,y
            and #%00111111              ;mask out horizontal and vertical flip bits
            sta Sprite_Attributes+24,y  ;for fourth row sprites and save
            lda Sprite_Attributes+28,y
            and #%00111111
            ora #%01000000              ;set horizontal flip bit for second
            sta Sprite_Attributes+28,y  ;sprite in the fourth row
          }
        }
      }
    }
  }
  // Block: ExPlyrAt
  ExPlyrAt:  rts                         ;leave

def SubtEnemyYPos():
  // Block: SubtEnemyYPos
  lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
  clc                     ;vertical coordinate
  adc #$3e
  cmp #$44                ;compare against a certain range
  rts                     ;and leave with flags set for conditional branch

def StopSquare2Sfx():
  // Block: StopSquare2Sfx
  ldx #$0d                ;stop playing the sfx
  stx SND_MASTERCTRL_REG
  ldx #$0f
  stx SND_MASTERCTRL_REG
  // Block: ExSfx2
  ExSfx2: rts

def EnterSidePipe():
  lda #$08               ;set player's horizontal speed
  sta Player_X_Speed
  ldy #$01               ;set controller right button by default
  lda Player_X_Position  ;mask out higher nybble of player's
  and #%00001111         ;horizontal position
  if (!BNE RightPipe) {  // from EnterSidePipe
    sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
    tay                    ;and nullify controller bit override here
  }
  // Block: RightPipe
  RightPipe: tya                    ;use contents of Y to
  jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
  rts

def CyclePlayerPalette():
  // Block: CyclePlayerPalette
  and #$03              ;mask out all but d1-d0 (previously d3-d2)
  sta $00               ;store result here to use as palette bits
  lda Player_SprAttrib  ;get player attributes
  and #%11111100        ;save any other bits but palette bits
  ora $00               ;add palette bits
  sta Player_SprAttrib  ;store as new player attributes
  rts                   ;and leave

def RelativeBlockPosition():
  // Block: RelativeBlockPosition
  lda #$09                     ;get coordinates of one block object
  ldy #$04                     ;relative to the screen
  jsr VariableObjOfsRelPos
  inx                          ;adjust offset for other block object if any
  inx
  lda #$09
  iny                          ;adjust other and get coordinates for other one

def BlockBufferChk_Enemy():
  // Block: BlockBufferChk_Enemy
  pha        ;save contents of A to stack
  txa
  clc        ;add 1 to X to run sub with enemy offset in mind
  adc #$01
  tax
  pla        ;pull A from stack and jump elsewhere
  jmp BBChk_E

def InitPiranhaPlant():
  // Block: InitPiranhaPlant
  lda #$01                     ;set initial speed
  sta PiranhaPlant_Y_Speed,x
  lsr
  sta Enemy_State,x            ;initialize enemy state and what would normally
  sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
  lda Enemy_Y_Position,x
  sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
  sec
  sbc #$18
  sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
  lda #$09
  jmp SetBBox2                 ;set specific value for bounding box control
  // Block: SetBBox2
  SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
  rts

def SetupBubble():
  ldy #$00                 ;load default value here
  lda PlayerFacingDir      ;get player's facing direction
  lsr                      ;move d0 to carry
  if (!BCC PosBubl) {  // from SetupBubble
    ldy #$08                 ;otherwise load alternate value here
  }
  // Block: PosBubl
  PosBubl:  tya                      ;use value loaded as adder
  adc Player_X_Position    ;add to player's horizontal position
  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
  lda Player_PageLoc
  adc #$00                 ;add carry to player's page location
  sta Bubble_PageLoc,x     ;save as page location for airbubble
  lda Player_Y_Position
  clc                      ;add eight pixels to player's vertical position
  adc #$08
  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
  lda #$01
  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
  ldy $07                  ;get pseudorandom bit, use as offset
  lda BubbleTimerData,y    ;get data for air bubble timer
  sta AirBubbleTimer       ;set air bubble timer
  MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
  lda Bubble_YMF_Dummy,x
  sec                      ;subtract pseudorandom amount from dummy variable
  sbc Bubble_MForceData,y
  sta Bubble_YMF_Dummy,x   ;save dummy variable
  lda Bubble_Y_Position,x
  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
  cmp #$20                 ;if below the status bar,
  if (!BCS Y_Bubl) {  // from MoveBubl
    lda #$f8                 ;otherwise set offscreen coordinate
  }
  // Block: Y_Bubl
  Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
  // Block: ExitBubl
  ExitBubl: rts                      ;leave

def MoveESprRowOffscreen():
  // Block: MoveESprRowOffscreen
  clc                         ;add A to enemy object OAM data offset
  adc Enemy_SprDataOffset,x
  tay                         ;use as offset
  lda #$f8
  jmp DumpTwoSpr              ;move first row of sprites offscreen

def VariableObjOfsRelPos():
  // Block: VariableObjOfsRelPos
  stx $00                     ;store value to add to A here
  clc
  adc $00                     ;add A to value stored
  tax                         ;use as enemy offset
  jsr GetObjRelativePosition
  ldx ObjectOffset            ;reload old object offset and leave
  rts

def SetFreq_Squ2():
  tay
  lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
  if (!BEQ NoTone) {  // from Dump_Freq_Regs
    sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
    lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
    ora #%00001000            ;length counter
    sta SND_REGISTER+3,x
  }
  // Block: NoTone
  NoTone: rts
  // Block: SetFreq_Squ2
  ldx #$04               ;set frequency reg offset for square 2 sound channel
  bne Dump_Freq_Regs     ;unconditional branch

def SetFlameTimer():
  // Block: SetFlameTimer
  ldy BowserFlameTimerCtrl  ;load counter as offset
  inc BowserFlameTimerCtrl  ;increment
  lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
  and #%00000111            ;to keep in range of 0-7
  sta BowserFlameTimerCtrl
  lda FlameTimerData,y      ;load value to be used then leave
  // Block: ExFl
  ExFl: rts

def PlayerGfxHandler():
  lda InjuryTimer             ;if player's injured invincibility timer
  if (!BEQ CntPl) {  // from PlayerGfxHandler
    lda FrameCounter
    lsr                         ;otherwise check frame counter and branch
    if (!BCS ExPGH) {  // from @14437
      CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
      cmp #$0b                    ;branch ahead to some other part
      if (!BEQ PlayerKilled) {  // from CntPl
        lda PlayerChangeSizeFlag    ;if grow/shrink flag set
        if (!BNE DoChangeSize) {  // from @14443
          ldy SwimmingFlag            ;if swimming flag set, branch to
          beq FindPlayerAction        ;different part, do not return
          lda Player_State
          cmp #$00                    ;if player status normal,
          beq FindPlayerAction        ;branch and do not return
          jsr FindPlayerAction        ;otherwise jump and return
          lda FrameCounter
          and #%00000100              ;check frame counter for d2 set (8 frames every
          if (!BNE ExPGH) {  // from @14450
            tax                         ;initialize X to zero
            ldy Player_SprDataOffset    ;get player sprite data offset
            lda PlayerFacingDir         ;get player's facing direction
            lsr
            if (!BCS SwimKT) {  // from @14454
              iny
              iny                         ;otherwise move to next OAM data
              iny
              iny
            }
            SwimKT: lda PlayerSize              ;check player's size
            if (!BEQ BigKTS) {  // from SwimKT
              lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
              cmp SwimTileRepOffset       ;against tile number in player graphics table
              if (!BEQ ExPGH) {  // from @14465
                inx                         ;otherwise increment X for second tile
                // Block: BigKTS
                BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
                sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
              }
            }
          }
          // Block: ExPGH
          ExPGH:  rts                         ;then leave
        }
        // Block: DoChangeSize
        jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
        jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
      }
    }
  }
  CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
  cmp #$0b                    ;branch ahead to some other part
  if (!BEQ PlayerKilled) {  // from CntPl
    lda PlayerChangeSizeFlag    ;if grow/shrink flag set
    if (!BNE DoChangeSize) {  // from @14443
      jsr FindPlayerAction        ;otherwise jump and return
      lda FrameCounter
      and #%00000100              ;check frame counter for d2 set (8 frames every
      if (!BNE ExPGH) {  // from @14450
        tax                         ;initialize X to zero
        ldy Player_SprDataOffset    ;get player sprite data offset
        lda PlayerFacingDir         ;get player's facing direction
        lsr
        if (!BCS SwimKT) {  // from @14454
        }
        SwimKT: lda PlayerSize              ;check player's size
        if (!BEQ BigKTS) {  // from SwimKT
          lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
          cmp SwimTileRepOffset       ;against tile number in player graphics table
          if (!BEQ ExPGH) {  // from @14465
          }
        }
      }
    }
  } else {
    // Block: PlayerKilled
    ldy #$0e                      ;load offset for player killed
    lda PlayerGfxTblOffsets,y     ;get offset to graphics table
  }
  sta PlayerGfxOffset           ;store offset to graphics table here
  lda #$04
  jsr RenderPlayerSub           ;draw player based on offset loaded
  jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
  lda FireballThrowingTimer
  if (!BEQ PlayerOffscreenChk) {  // from PlayerGfxProcessing
    ldy #$00                      ;set value to initialize by default
    lda PlayerAnimTimer           ;get animation frame timer
    cmp FireballThrowingTimer     ;compare to fireball throw timer
    sty FireballThrowingTimer     ;initialize fireball throw timer
    if (!BCS PlayerOffscreenChk) {  // from @14492
      sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
      ldy #$07                      ;load offset for throwing
      lda PlayerGfxTblOffsets,y     ;get offset to graphics table
      sta PlayerGfxOffset           ;store it for use later
      ldy #$04                      ;set to update four sprite rows by default
      lda Player_X_Speed
      ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
      if (!BEQ SUpdR) {  // from @14497
        dey                           ;otherwise set to update only three sprite rows
      }
      // Block: SUpdR
      SUpdR: tya                           ;save in A for use
      jsr RenderPlayerSub           ;in sub, draw player object again
    }
  }
  // Block: PlayerOffscreenChk
  lda Player_OffscreenBits      ;get player's offscreen bits
  lsr
  lsr                           ;move vertical bits to low nybble
  lsr
  lsr
  sta $00                       ;store here
  ldx #$03                      ;check all four rows of player sprites
  lda Player_SprDataOffset      ;get player's sprite data offset
  clc
  adc #$18                      ;add 24 bytes to start at bottom row
  tay                           ;set as offset here
  NPROffscr: tya
  sec                           ;subtract eight bytes to do
  sbc #$08                      ;next row up
  tay
  dex                           ;decrement row counter
  while (!BPL PROfsLoop) {  // loop42
    jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
    do {  // loop41
      // Block: PROfsLoop
      PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
      lsr $00                       ;shift bit into carry
      bcc NPROffscr                 ;if bit not set, skip, do not move sprites
    } while (BPL PROfsLoop)
  }
  rts                           ;then we are done!

def SpawnBrickChunks():
  // Block: SpawnBrickChunks
  lda Block_X_Position,x     ;set horizontal coordinate of block object
  sta Block_Orig_XPos,x      ;as original horizontal coordinate here
  lda #$f0
  sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
  sta Block_X_Speed+2,x
  lda #$fa
  sta Block_Y_Speed,x        ;set vertical speed for one
  lda #$fc
  sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
  lda #$00
  sta Block_Y_MoveForce,x    ;init fractional movement force for both
  sta Block_Y_MoveForce+2,x
  lda Block_PageLoc,x
  sta Block_PageLoc+2,x      ;copy page location
  lda Block_X_Position,x
  sta Block_X_Position+2,x   ;copy horizontal coordinate
  lda Block_Y_Position,x
  clc                        ;add 8 pixels to vertical coordinate
  adc #$08                   ;and save as vertical coordinate for one of them
  sta Block_Y_Position+2,x
  lda #$fa
  sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
  rts

def PutAtRightExtent():
  // Block: PutAtRightExtent
  sta Enemy_Y_Position,x    ;set vertical position
  lda ScreenRight_X_Pos
  clc
  adc #$20                  ;place enemy 32 pixels beyond right side of screen
  sta Enemy_X_Position,x
  lda ScreenRight_PageLoc
  adc #$00                  ;add carry
  sta Enemy_PageLoc,x
  jmp FinishFlame           ;skip this part to finish setting values
  // Block: FinishFlame
  lda #$08                 ;set $08 for bounding box control
  sta Enemy_BoundBoxCtrl,x
  lda #$01                 ;set high byte of vertical and
  sta Enemy_Y_HighPos,x    ;enemy buffer flag
  sta Enemy_Flag,x
  lsr
  sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
  sta Enemy_State,x        ;enemy state
  rts

def ChkForLandJumpSpring():
  jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
  if (!BCC ExCJSp) {  // from ChkForLandJumpSpring
    lda #$70
    sta VerticalForce           ;otherwise set vertical movement force for player
    lda #$f9
    sta JumpspringForce         ;set default jumpspring force
    lda #$03
    sta JumpspringTimer         ;set jumpspring timer to be used later
    lsr
    sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
  }
  // Block: ExCJSp
  ExCJSp: rts                         ;and leave

def SmallPlatformCollision():
  lda TimerControl             ;if master timer control set,
  if (!BNE ExSPC) {  // from SmallPlatformCollision
    sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
    jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
    if (!BCS ExSPC) {  // from @11745
      lda #$02
      sta $00                      ;load counter here for 2 bounding boxes
      lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
      clc                        ;128 pixels downwards
      adc #$80
      sta BoundingBox_UL_YPos,y
      lda BoundingBox_DR_YPos,y
      clc
      adc #$80
      sta BoundingBox_DR_YPos,y
      dec $00                    ;decrement counter we set earlier
      while (!BNE ChkSmallPlatLoop) {  // loop17
        lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
        cmp #$20                   ;above a specific point
        if (!BCC MoveBoundBox) {  // from @11756
          jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
          if (!BCS ProcSPlatCollisions) {  // from @11759
            do {  // loop7
              // Block: ChkSmallPlatLoop
              ldx ObjectOffset           ;get enemy object offset
              jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
              and #%00000010             ;if d1 of offscreen lower nybble bits was set
              bne ExSPC                  ;then branch to leave
            } while (BNE ChkSmallPlatLoop)
            // Block: ExSPC
            ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
            rts
          }
        }
        do {  // loop16
        } while (BNE ChkSmallPlatLoop)
      }
    }
  }
  // Block: ProcSPlatCollisions
  ldx ObjectOffset             ;return enemy object buffer offset to X, then continue

def GetLrgObjAttrib():
  // Block: GetLrgObjAttrib
  ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
  lda (AreaData),y          ;get first byte of level object
  and #%00001111
  sta $07                   ;save row location
  iny
  lda (AreaData),y          ;get next byte, save lower nybble (length or height)
  and #%00001111            ;as Y, then leave
  tay
  rts

def ChkUnderEnemy():
  // Block: ChkUnderEnemy
  lda #$00                  ;set flag in A for save vertical coordinate
  ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
  jmp BlockBufferChk_Enemy  ;hop to it!

def PlayerLakituDiff():
  ldy #$00                   ;set Y for default value
  jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
  if (!BPL ChkLakDif) {  // from PlayerLakituDiff
    iny                        ;increment Y for left of player
    lda $00
    eor #$ff                   ;get two's compliment of low byte of horizontal difference
    clc
    adc #$01                   ;store two's compliment as horizontal difference
    sta $00
  }
  ChkLakDif: lda $00                    ;get low byte of horizontal difference
  cmp #$3c                   ;if within a certain distance of player, branch
  if (!BCC ChkPSpeed) {  // from ChkLakDif
    lda #$3c                   ;otherwise set maximum distance
    sta $00
    lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
    cmp #Lakitu
    if (!BNE ChkPSpeed) {  // from @10014
      tya                        ;compare contents of Y, now in A
      cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
      if (!BEQ ChkPSpeed) {  // from @10019
        lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
        if (!BEQ SetLMovD) {  // from @10022
          dec LakituMoveSpeed,x      ;decrement horizontal speed
          lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
          if (!BNE ExMoveLak) {  // from @10024
            // Block: SetLMovD
            SetLMovD:  tya                        ;set horizontal direction depending on horizontal
            sta LakituMoveDirection,x  ;difference between enemy and player if necessary
            ChkPSpeed: lda $00
            and #%00111100             ;mask out all but four bits in the middle
            lsr                        ;divide masked difference by four
            lsr
            sta $00                    ;store as new value
            ldy #$00                   ;init offset
            lda Player_X_Speed
            if (!BEQ SubDifAdj) {  // from ChkPSpeed
              lda ScrollAmount
              if (!BEQ SubDifAdj) {  // from @10037
                iny                        ;otherwise increment offset
                lda Player_X_Speed
                cmp #$19                   ;if player not running, branch
                if (!BCC ChkSpinyO) {  // from @10039
                  lda ScrollAmount
                  cmp #$02                   ;if scroll speed below a certain amount, branch
                  if (!BCC ChkSpinyO) {  // from @10043
                    iny                        ;otherwise increment once more
                  }
                }
                ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
                cmp #Spiny
                if (!BNE ChkEmySpd) {  // from ChkSpinyO
                  lda Player_X_Speed         ;if player not moving, skip this part
                  if (!BNE SubDifAdj) {  // from @10050
                    ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
                    if (!BNE SubDifAdj) {  // from ChkEmySpd
                      ldy #$00                   ;otherwise reinit offset
                    }
                  }
                }
                if (!BNE SubDifAdj) {  // from ChkEmySpd
                }
              }
            }
            // Block: SubDifAdj
            SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
            ldy $00                    ;get saved horizontal difference
            do {  // loop16
              // Block: SPixelLak
              SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
              sbc #$01                   ;from one of three saved values
              dey
              bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
            } while (!BPL SPixelLak)
          }
        }
      }
    }
  }
  ChkPSpeed: lda $00
  and #%00111100             ;mask out all but four bits in the middle
  lsr                        ;divide masked difference by four
  lsr
  sta $00                    ;store as new value
  ldy #$00                   ;init offset
  lda Player_X_Speed
  if (!BEQ SubDifAdj) {  // from ChkPSpeed
    lda ScrollAmount
    if (!BEQ SubDifAdj) {  // from @10037
      iny                        ;otherwise increment offset
      lda Player_X_Speed
      cmp #$19                   ;if player not running, branch
      if (!BCC ChkSpinyO) {  // from @10039
        lda ScrollAmount
        cmp #$02                   ;if scroll speed below a certain amount, branch
        if (!BCC ChkSpinyO) {  // from @10043
        }
      }
      ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
      cmp #Spiny
      if (!BNE ChkEmySpd) {  // from ChkSpinyO
        lda Player_X_Speed         ;if player not moving, skip this part
        if (!BNE SubDifAdj) {  // from @10050
          ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
          if (!BNE SubDifAdj) {  // from ChkEmySpd
          }
        }
      }
      if (!BNE SubDifAdj) {  // from ChkEmySpd
      }
    }
  }
  do {  // loop36
  } while (!BPL SPixelLak)
  // Block: ExMoveLak
  ExMoveLak: rts                        ;leave!!!

def DrawPowerUp():
  // Block: DrawPowerUp
  ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
  lda Enemy_Rel_YPos         ;get relative vertical coordinate
  clc
  adc #$08                   ;add eight pixels
  sta $02                    ;store result here
  lda Enemy_Rel_XPos         ;get relative horizontal coordinate
  sta $05                    ;store here
  ldx PowerUpType            ;get power-up type
  lda PowerUpAttributes,x    ;get attribute data for power-up type
  ora Enemy_SprAttrib+5      ;add background priority bit if set
  sta $04                    ;store attributes here
  txa
  pha                        ;save power-up type to the stack
  asl
  asl                        ;multiply by four to get proper offset
  tax                        ;use as X
  lda #$01
  sta $07                    ;set counter here to draw two rows of sprite object
  sta $03                    ;init d1 of flip control
  do {  // loop2
    // Block: PUpDrawLoop
    lda PowerUpGfxTable,x      ;load left tile of power-up object
    sta $00
    lda PowerUpGfxTable+1,x    ;load right tile
    jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
    dec $07                    ;decrement counter
    bpl PUpDrawLoop            ;branch until two rows are drawn
  } while (!BPL PUpDrawLoop)
  ldy Enemy_SprDataOffset+5  ;get sprite data offset again
  pla                        ;pull saved power-up type from the stack
  if (!BEQ PUpOfs) {  // from @13511
    cmp #$03
    if (!BEQ PUpOfs) {  // from @13514
      sta $00                    ;store power-up type here now
      lda FrameCounter           ;get frame counter
      lsr                        ;divide by 2 to change colors every two frames
      and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
      ora Enemy_SprAttrib+5      ;add background priority bit if any set
      sta Sprite_Attributes,y    ;set as new palette bits for top left and
      sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
      ldx $00
      dex                        ;check power-up type for fire flower
      if (!BEQ FlipPUpRightSide) {  // from @13516
        sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
        sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
      }
      // Block: FlipPUpRightSide
      lda Sprite_Attributes+4,y
      ora #%01000000             ;set horizontal flip bit for top right sprite
      sta Sprite_Attributes+4,y
      lda Sprite_Attributes+12,y
      ora #%01000000             ;set horizontal flip bit for bottom right sprite
      sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
    }
  }
  // Block: PUpOfs
  PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
  ldx ObjectOffset          ;get enemy buffer offset
  lda Enemy_OffscreenBits   ;check offscreen information
  lsr
  lsr                       ;shift three times to the right
  lsr                       ;which puts d2 into carry
  pha                       ;save to stack
  if (!BCC LcChk) {  // from SprObjectOffscrChk
    lda #$04                  ;set for right column sprites
    jsr MoveESprColOffscreen  ;and move them offscreen
  }
  LcChk:   pla                       ;get from stack
  lsr                       ;move d3 to carry
  pha                       ;save to stack
  if (!BCC Row3C) {  // from LcChk
    lda #$00                  ;set for left column sprites,
    jsr MoveESprColOffscreen  ;move them offscreen
  }
  Row3C:   pla                       ;get from stack again
  lsr                       ;move d5 to carry this time
  lsr
  pha                       ;save to stack again
  if (!BCC Row23C) {  // from Row3C
    lda #$10                  ;set for third row of sprites
    jsr MoveESprRowOffscreen  ;and move them offscreen
  }
  Row23C:  pla                       ;get from stack
  lsr                       ;move d6 into carry
  pha                       ;save to stack
  if (!BCC AllRowC) {  // from Row23C
    lda #$08                  ;set for second and third rows
    jsr MoveESprRowOffscreen  ;move them offscreen
  }
  AllRowC: pla                       ;get from stack once more
  lsr                       ;move d7 into carry
  if (!BCC ExEGHandler) {  // from AllRowC
    jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
    lda Enemy_ID,x
    cmp #Podoboo              ;check enemy identifier for podoboo
    if (!BEQ ExEGHandler) {  // from @14050
      lda Enemy_Y_HighPos,x     ;check high byte of vertical position
      cmp #$02                  ;if not yet past the bottom of the screen, branch
      if (!BNE ExEGHandler) {  // from @14054
        jsr EraseEnemyObject      ;what it says
      }
    }
  }
  // Block: ExEGHandler
  rts

def RelativeMiscPosition():
  // Block: RelWOfs
  RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
  ldx ObjectOffset            ;return original offset
  rts                         ;leave
  loop {  // loop3 (infinite)
    // Block: RelativeMiscPosition
    ldy #$02                ;set for misc object offsets
    jsr GetProperObjOffset  ;modify X to get proper misc object offset
    ldy #$06
    jmp RelWOfs             ;get the coordinates
  }

def GetAreaDataAddrs():
  lda AreaPointer          ;use 2 MSB for Y
  jsr GetAreaType
  tay
  lda AreaPointer          ;mask out all but 5 LSB
  and #%00011111
  sta AreaAddrsLOffset     ;save as low offset
  lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
  clc                      ;then add base value to 5 LSB, result
  adc AreaAddrsLOffset     ;becomes offset for level data
  tay
  lda EnemyDataAddrLow,y   ;use offset to load pointer
  sta EnemyDataLow
  lda EnemyDataAddrHigh,y
  sta EnemyDataHigh
  ldy AreaType             ;use area type as offset
  lda AreaDataHOffsets,y   ;do the same thing but with different base value
  clc
  adc AreaAddrsLOffset
  tay
  lda AreaDataAddrLow,y    ;use this offset to load another pointer
  sta AreaDataLow
  lda AreaDataAddrHigh,y
  sta AreaDataHigh
  ldy #$00                 ;load first byte of header
  lda (AreaData),y
  pha                      ;save it to the stack for now
  and #%00000111           ;save 3 LSB for foreground scenery or bg color control
  cmp #$04
  if (!BCC StoreFore) {  // from GetAreaDataAddrs
    sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
    lda #$00
  }
  StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
  pla                      ;pull byte from stack and push it back
  pha
  and #%00111000           ;save player entrance control bits
  lsr                      ;shift bits over to LSBs
  lsr
  lsr
  sta PlayerEntranceCtrl       ;save value here as player entrance control
  pla                      ;pull byte again but do not push it back
  and #%11000000           ;save 2 MSB for game timer setting
  clc
  rol                      ;rotate bits over to LSBs
  rol
  rol
  sta GameTimerSetting     ;save value here as game timer setting
  iny
  lda (AreaData),y         ;load second byte of header
  pha                      ;save to stack
  and #%00001111           ;mask out all but lower nybble
  sta TerrainControl
  pla                      ;pull and push byte to copy it to A
  pha
  and #%00110000           ;save 2 MSB for background scenery type
  lsr
  lsr                      ;shift bits to LSBs
  lsr
  lsr
  sta BackgroundScenery    ;save as background scenery
  pla
  and #%11000000
  clc
  rol                      ;rotate bits over to LSBs
  rol
  rol
  cmp #%00000011           ;if set to 3, store here
  if (!BNE StoreStyle) {  // from StoreFore
    sta CloudTypeOverride    ;otherwise store value in other place
    lda #$00
  }
  // Block: StoreStyle
  StoreStyle: sta AreaStyle
  lda AreaDataLow          ;increment area data address by 2 bytes
  clc
  adc #$02
  sta AreaDataLow
  lda AreaDataHigh
  adc #$00
  sta AreaDataHigh
  rts

def PlayerEnemyCollision():
  jsr EraseEnemyObject    ;erase the power-up object
  lda #$06
  jsr SetupFloateyNumber  ;award 1000 points to player by default
  lda #Sfx_PowerUpGrab
  sta Square2SoundQueue   ;play the power-up sound
  lda PowerUpType         ;check power-up type
  cmp #$02
  if (!BCC Shroom_Flower_PUp) {  // from HandlePowerUpCollision
    cmp #$03
    if (!BEQ SetFor1Up) {  // from @11245
      lda #$23                ;otherwise set star mario invincibility
      sta StarInvincibleTimer ;timer, and load the star mario music
      lda #StarPowerMusic     ;into the area music queue, then leave
      sta AreaMusicQueue
      rts
      lda PlayerStatus    ;if player status = small, branch
      if (!BEQ UpToSuper) {  // from Shroom_Flower_PUp
        cmp #$01            ;if player status not super, leave
        if (!BNE NoPUp) {  // from @11256
          ldx ObjectOffset    ;get enemy offset, not necessary
          lda #$02            ;set player status to fiery
          sta PlayerStatus
          jsr GetPlayerColors ;run sub to change colors of player
          ldx ObjectOffset    ;get enemy offset again, and again not necessary
          lda #$0c            ;set value to be used by subroutine tree (fiery)
          jmp UpToFiery       ;jump to set values accordingly
          // Block: SetFor1Up
          lda #$0b                 ;change 1000 points into 1-up instead
          sta FloateyNum_Control,x ;and then leave
          rts
          // Block: UpToSuper
          lda #$01         ;set player status to super
          sta PlayerStatus
          lda #$09         ;set value to be used by subroutine tree (super)
          // Block: UpToFiery
          ldy #$00         ;set value to be used as new player state
          jsr SetPRout     ;set values to stop certain things in motion
        }
      }
    }
  }
  lda PlayerStatus    ;if player status = small, branch
  if (!BEQ UpToSuper) {  // from Shroom_Flower_PUp
    cmp #$01            ;if player status not super, leave
    if (!BNE NoPUp) {  // from @11256
    }
  }
  // Block: NoPUp
  NoPUp: rts
  do {  // loop20
    // Block: PlayerEnemyCollision
    lda FrameCounter            ;check counter for d0 set
    lsr
    bcs NoPUp                   ;if set, branch to leave
  } while (BCS NoPUp)
  jsr CheckPlayerVertical     ;if player object is completely offscreen or
  if (!BCS NoPECol) {  // from @11296
    lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
    if (!BNE NoPECol) {  // from @11298
      lda GameEngineSubroutine
      cmp #$08                    ;if not set to run player control routine
      if (!BNE NoPECol) {  // from @11300
        lda Enemy_State,x
        and #%00100000              ;if enemy state has d5 set, branch to leave
        if (!BNE NoPECol) {  // from @11303
          jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
          jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
          ldx ObjectOffset            ;get enemy object buffer offset
          if (!BCS CheckForPUpCollision) {  // from @11306
            lda Enemy_CollisionBits,x
            and #%11111110              ;otherwise, clear d0 of current enemy object's
            sta Enemy_CollisionBits,x   ;collision bit
            // Block: NoPECol
            NoPECol: rts
          }
        }
      }
    }
  }
  ldy Enemy_ID,x
  cpy #PowerUpObject            ;check for power-up object
  if (!BNE EColl) {  // from CheckForPUpCollision
    loop {  // loop49 (infinite)
      // Block: HandlePowerUpCollision
      jsr EraseEnemyObject    ;erase the power-up object
      lda #$06
      jsr SetupFloateyNumber  ;award 1000 points to player by default
      lda #Sfx_PowerUpGrab
      sta Square2SoundQueue   ;play the power-up sound
      lda PowerUpType         ;check power-up type
      cmp #$02
      bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
      cmp #$03
      beq SetFor1Up           ;if 1-up mushroom, branch
      // Block: Shroom_Flower_PUp
      lda PlayerStatus    ;if player status = small, branch
      beq UpToSuper
      cmp #$01            ;if player status not super, leave
      bne NoPUp
      jsr CheckPlayerVertical     ;if player object is completely offscreen or
      bcs NoPECol                 ;if down past 224th pixel row, branch to leave
      lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
      bne NoPECol                 ;go ahead and branch to leave
      lda GameEngineSubroutine
      cmp #$08                    ;if not set to run player control routine
      bne NoPECol                 ;on next frame, branch to leave
      lda Enemy_State,x
      and #%00100000              ;if enemy state has d5 set, branch to leave
      bne NoPECol
      jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
      jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
      ldx ObjectOffset            ;get enemy object buffer offset
      bcs CheckForPUpCollision    ;if collision, branch past this part here
      jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
    }
  }
  EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
  if (!BEQ HandlePECollisions) {  // from EColl
    jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
  }
  lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
  and #%00000001               ;or for being offscreen at all
  ora EnemyOffscrBitsMasked,x
  if (!BNE ExPEC) {  // from HandlePECollisions
    lda #$01
    ora Enemy_CollisionBits,x    ;otherwise set d0 now
    sta Enemy_CollisionBits,x
    cpy #Spiny                   ;branch if spiny
    if (!BEQ ChkForPlayerInjury) {  // from @11332
      cpy #PiranhaPlant            ;branch if piranha plant
      beq InjurePlayer
      cpy #Podoboo                 ;branch if podoboo
      beq InjurePlayer
      cpy #BulletBill_CannonVar    ;branch if bullet bill
      if (!BEQ ChkForPlayerInjury) {  // from @11341
        cpy #$15                     ;branch if object => $15
        bcs InjurePlayer
        lda AreaType                 ;branch if water type level
        beq InjurePlayer
        lda Enemy_State,x            ;branch if d7 of enemy state was set
        asl
        if (!BCS ChkForPlayerInjury) {  // from @11347
          lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
          and #%00000111
          cmp #$02                     ;branch if enemy is in normal or falling state
          if (!BCC ChkForPlayerInjury) {  // from @11350
            lda Enemy_ID,x               ;branch to leave if goomba in defeated state
            cmp #Goomba
            if (!BEQ ExPEC) {  // from @11354
              lda #Sfx_EnemySmack          ;play smack enemy sound
              sta Square1SoundQueue
              lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
              ora #%10000000
              sta Enemy_State,x
              jsr EnemyFacePlayer          ;set moving direction and get offset
              lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
              sta Enemy_X_Speed,x
              lda #$03                     ;add three to whatever the stomp counter contains
              clc                          ;to give points for kicking the shell
              adc StompChainCounter
              ldy EnemyIntervalTimer,x     ;check shell enemy's timer
              cpy #$03                     ;if above a certain point, branch using the points
              if (!BCS KSPts) {  // from @11357
                lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
              }
              // Block: KSPts
              KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
            }
            // Block: ExPEC
            ExPEC: rts                          ;leave!!!
          }
        }
      }
    }
  }
  lda Player_Y_Speed     ;check player's vertical speed
  if (!BMI ChkInj) {  // from ChkForPlayerInjury
    if (!BNE EnemyStomped) {  // from @11378
      ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
      cmp #Bloober
      if (!BCC ChkETmrs) {  // from ChkInj
        lda Player_Y_Position  ;add 12 pixels to player's vertical position
        clc
        adc #$0c
        cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
        if (!BCC EnemyStomped) {  // from @11382
          ChkETmrs: lda StompTimer         ;check stomp timer
          if (!BNE EnemyStomped) {  // from ChkETmrs
            lda InjuryTimer        ;check to see if injured invincibility timer still
            if (!BNE ExInjColRoutines) {  // from @11389
              lda Player_Rel_XPos
              cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
              if (!BCC TInjE) {  // from @11391
                jmp ChkEnemyFaceRight  ;otherwise do a jump here
              }
              // Block: TInjE
              TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
              cmp #$01               ;branch, otherwise do a jump here
              bne InjurePlayer       ;to turn the enemy around
              jmp LInj
            }
            // Block: ExInjColRoutines
            ldx ObjectOffset              ;get enemy offset and leave
            rts
          }
        }
      }
      if (!BNE EnemyStomped) {  // from ChkETmrs
        if (!BNE ExInjColRoutines) {  // from @11389
          if (!BCC TInjE) {  // from @11391
          }
        }
      }
    }
  }
  ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
  cmp #Bloober
  if (!BCC ChkETmrs) {  // from ChkInj
    lda Player_Y_Position  ;add 12 pixels to player's vertical position
    clc
    adc #$0c
    cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
    if (!BCC EnemyStomped) {  // from @11382
      ChkETmrs: lda StompTimer         ;check stomp timer
      if (!BNE EnemyStomped) {  // from ChkETmrs
        lda InjuryTimer        ;check to see if injured invincibility timer still
        if (!BNE ExInjColRoutines) {  // from @11389
          lda Player_Rel_XPos
          cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
          if (!BCC TInjE) {  // from @11391
          }
        }
      }
    }
  }
  ChkETmrs: lda StompTimer         ;check stomp timer
  if (!BNE EnemyStomped) {  // from ChkETmrs
    lda InjuryTimer        ;check to see if injured invincibility timer still
    if (!BNE ExInjColRoutines) {  // from @11389
      lda Player_Rel_XPos
      cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
      if (!BCC TInjE) {  // from @11391
      }
    }
  }
  // Block: EnemyStomped
  lda Enemy_ID,x             ;check for spiny, branch to hurt player
  cmp #Spiny                 ;if found
  beq InjurePlayer
  lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
  sta Square1SoundQueue
  lda Enemy_ID,x
  ldy #$00                   ;initialize points data offset for stomped enemies
  cmp #FlyingCheepCheep      ;branch for cheep-cheep
  if (!BEQ EnemyStompedPts) {  // from @11442
    cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
    if (!BEQ EnemyStompedPts) {  // from @11448
      cmp #BulletBill_CannonVar
      if (!BEQ EnemyStompedPts) {  // from @11450
        cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
        if (!BEQ EnemyStompedPts) {  // from @11452
          iny                        ;increment points data offset
          cmp #HammerBro             ;branch for hammer bro
          if (!BEQ EnemyStompedPts) {  // from @11454
            iny                        ;increment points data offset
            cmp #Lakitu                ;branch for lakitu
            if (!BEQ EnemyStompedPts) {  // from @11457
              iny                        ;increment points data offset
              cmp #Bloober               ;branch if NOT bloober
              if (!BNE ChkForDemoteKoopa) {  // from @11460
                // Block: EnemyStompedPts
                lda StompedEnemyPtsData,y  ;load points data using offset in Y
                jsr SetupFloateyNumber     ;run sub to set floatey number controls
                lda Enemy_MovingDir,x
                pha                        ;save enemy movement direction to stack
                jsr SetStun                ;run sub to kill enemy
                pla
                sta Enemy_MovingDir,x      ;return enemy movement direction from stack
                lda #%00100000
                sta Enemy_State,x          ;set d5 in enemy state
                jsr InitVStf               ;nullify vertical speed, physics-related thing,
                sta Enemy_X_Speed,x        ;and horizontal speed
                lda #$fd                   ;set player's vertical speed, to give bounce
                sta Player_Y_Speed
                rts
              }
            }
          }
        }
      }
    }
  }
  cmp #$09                   ;branch elsewhere if enemy object < $09
  if (!BCC HandleStompedShellE) {  // from ChkForDemoteKoopa
    and #%00000001             ;demote koopa paratroopas to ordinary troopas
    sta Enemy_ID,x
    ldy #$00                   ;return enemy to normal state
    sty Enemy_State,x
    lda #$03                   ;award 400 points to the player
    jsr SetupFloateyNumber
    jsr InitVStf               ;nullify physics-related thing and vertical speed
    jsr EnemyFacePlayer        ;turn enemy around if necessary
    lda DemotedKoopaXSpdData,y
    sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
    jmp SBnce                  ;then move onto something else
  } else {
    // Block: HandleStompedShellE
    lda #$04                   ;set defeated state for enemy
    sta Enemy_State,x
    inc StompChainCounter      ;increment the stomp counter
    lda StompChainCounter      ;add whatever is in the stomp counter
    clc                        ;to whatever is in the stomp timer
    adc StompTimer
    jsr SetupFloateyNumber     ;award points accordingly
    inc StompTimer             ;increment stomp timer of some sort
    ldy PrimaryHardMode        ;check primary hard mode flag
    lda RevivalRateData,y      ;load timer setting according to flag
    sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
  }
  // Block: SBnce
  SBnce: lda #$fc                   ;set player's vertical speed for bounce
  sta Player_Y_Speed         ;and then leave!!!
  rts
  lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
  cmp #$01
  if (!BNE LInj) {  // from ChkEnemyFaceRight
    jmp InjurePlayer      ;otherwise go back to hurt player
  }
  // Block: LInj
  LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
  jmp InjurePlayer      ;go back to hurt player

def FindEmptyMiscSlot():
  // Block: FindEmptyMiscSlot
  ldy #$08                ;start at end of misc objects buffer
  dey                     ;decrement offset
  cpy #$05                ;do this for three slots
  while (!BNE FMiscLoop) {  // loop4
    do {  // loop3
      // Block: FMiscLoop
      FMiscLoop: lda Misc_State,y        ;get misc object state
      beq UseMiscS            ;branch if none found to use current offset
    } while (BNE FMiscLoop)
  }
  ldy #$08                ;if no empty slots found, use last slot
  // Block: UseMiscS
  UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
  rts

def RenderPlayerSub():
  // Block: RenderPlayerSub
  sta $07                      ;store number of rows of sprites to draw
  lda Player_Rel_XPos
  sta Player_Pos_ForScroll     ;store player's relative horizontal position
  sta $05                      ;store it here also
  lda Player_Rel_YPos
  sta $02                      ;store player's vertical position
  lda PlayerFacingDir
  sta $03                      ;store player's facing direction
  lda Player_SprAttrib
  sta $04                      ;store player's sprite attributes
  ldx PlayerGfxOffset          ;load graphics table offset
  ldy Player_SprDataOffset     ;get player's sprite data offset

def FirebarCollision():
  jsr DrawFirebar          ;run sub here to draw current tile of firebar
  tya                      ;return OAM data offset and save
  pha                      ;to the stack for now
  lda StarInvincibleTimer  ;if star mario invincibility timer
  ora TimerControl         ;or master timer controls set
  if (!BNE NoColFB) {  // from FirebarCollision
    sta $05                  ;otherwise initialize counter
    ldy Player_Y_HighPos
    dey                      ;if player's vertical high byte offscreen,
    if (!BNE NoColFB) {  // from @9803
      ldy Player_Y_Position    ;get player's vertical position
      lda PlayerSize           ;get player's size
      if (!BNE AdjSm) {  // from @9807
        lda CrouchingFlag
        if (!BEQ BigJp) {  // from @9810
          // Block: AdjSm
          AdjSm:   inc $05                  ;if small or big but crouching, execute this part
          inc $05                  ;first increment our counter twice (setting $02 as flag)
          tya
          clc                      ;then add 24 pixels to the player's
          adc #$18                 ;vertical coordinate
          tay
        }
      }
      // Block: BigJp
      BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
      ldy $05                  ;otherwise get temp here and use as offset
      lda Player_Y_Position
      clc
      adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
      inc $05                  ;then increment temp and jump back
      while (!JMP FBCLoop) {  // loop39
        eor #$ff                 ;skip two's compliment part
        clc                      ;otherwise get two's compliment
        adc #$01
        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
        if (!BCS Chk2Ofs) {  // from ChkVFBD
          lda $06                  ;if firebar on far right on the screen, skip this,
          cmp #$f0                 ;because, really, what's the point?
          if (!BCS Chk2Ofs) {  // from @9827
            lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
            clc
            adc #$04                 ;add four pixels
            sta $04                  ;store here
            sec                      ;subtract horizontal coordinate of firebar
            sbc $06                  ;from the X coordinate of player's sprite 1
            if (!BPL ChkFBCl) {  // from @9830
              eor #$ff                 ;skip two's compliment part
              clc                      ;otherwise get two's compliment
              adc #$01
            }
            ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
            if (!BCC ChgSDir) {  // from ChkFBCl
              Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
              cmp #$02                 ;branch to increment OAM offset and leave, no collision
              if (!BEQ NoColFB) {  // from Chk2Ofs
                loop {  // loop17 (infinite)
                  // Block: FBCLoop
                  FBCLoop: sec                      ;subtract vertical position of firebar
                  sbc $07                  ;from the vertical coordinate of the player
                  bpl ChkVFBD              ;if player lower on the screen than firebar,
                }
                ChgSDir: ldx #$01                 ;set movement direction by default
                lda $04                  ;if OAM X coordinate of player's sprite 1
                cmp $06                  ;is greater than horizontal coordinate of firebar
                if (!BCS SetSDir) {  // from ChgSDir
                  inx                      ;otherwise increment it
                }
                // Block: SetSDir
                SetSDir: stx Enemy_MovingDir      ;store movement direction here
                ldx #$00
                lda $00                  ;save value written to $00 to stack
                pha
                jsr InjurePlayer         ;perform sub to hurt or kill player
                pla
                sta $00                  ;get value of $00 from stack
              }
            }
          }
        }
        if (!BEQ NoColFB) {  // from Chk2Ofs
          loop {  // loop34 (infinite)
          }
          if (!BCS SetSDir) {  // from ChgSDir
          }
        }
      }
      if (!BCS SetSDir) {  // from ChgSDir
      }
    }
  }
  // Block: NoColFB
  NoColFB: pla                      ;get OAM data offset
  clc                      ;add four to it and save
  adc #$04
  sta $06
  ldx ObjectOffset         ;get enemy object buffer offset and leave
  rts

def MusicHandler():
  // Block: ContinueMusic
  jmp HandleSquare2Music  ;if we have music, start with square 2 channel
  lda EventMusicQueue     ;check event music queue
  if (!BNE LoadEventMusic) {  // from MusicHandler
    lda AreaMusicQueue      ;check area music queue
    if (!BNE LoadAreaMusic) {  // from @15612
      do {  // loop5
        lda EventMusicBuffer    ;check both buffers
        ora AreaMusicBuffer
        bne ContinueMusic
      } while (BNE ContinueMusic)
      rts                     ;no music, then leave
      sta EventMusicBuffer      ;copy event music queue contents to buffer
      cmp #DeathMusic           ;is it death music?
      if (!BNE NoStopSfx) {  // from LoadEventMusic
        jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
        jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
      }
      NoStopSfx: ldx AreaMusicBuffer
      stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
      ldy #$00
      sty NoteLengthTblAdder    ;default value for additional length byte offset
      sty AreaMusicBuffer       ;clear area music buffer
      cmp #TimeRunningOutMusic  ;is it time running out music?
      if (!BNE FindEventMusicHeader) {  // from NoStopSfx
        ldx #$08                  ;load offset to be added to length byte of header
        stx NoteLengthTblAdder
        if (!BNE FindEventMusicHeader) {  // from @15632
          cmp #$04                  ;is it underground music?
          if (!BNE NoStop1) {  // from LoadAreaMusic
            jsr StopSquare1Sfx
          }
          // Block: NoStop1
          NoStop1: ldy #$10                  ;start counter used only by ground level music
          ldy #$11
          while (BNE GMLoopB) {  // loop17
            // Block: GMLoopB
            GMLoopB: sty GroundMusicHeaderOfs
            // Block: HandleAreaMusicLoopB
            ldy #$00                  ;clear event music buffer
            sty EventMusicBuffer
            sta AreaMusicBuffer       ;copy area music queue contents to buffer
            cmp #$01                  ;is it ground level music?
            bne FindAreaMusicHeader
            inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
            ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
            cpy #$32
            bne LoadHeader            ;branch ahead with alternate offset
          }
          // Block: FindAreaMusicHeader
          ldy #$08                   ;load Y for offset of area music
          sty MusicOffset_Square2    ;residual instruction here
        }
      }
    }
  }
  sta EventMusicBuffer      ;copy event music queue contents to buffer
  cmp #DeathMusic           ;is it death music?
  if (!BNE NoStopSfx) {  // from LoadEventMusic
  }
  NoStopSfx: ldx AreaMusicBuffer
  stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
  ldy #$00
  sty NoteLengthTblAdder    ;default value for additional length byte offset
  sty AreaMusicBuffer       ;clear area music buffer
  cmp #TimeRunningOutMusic  ;is it time running out music?
  if (!BNE FindEventMusicHeader) {  // from NoStopSfx
    ldx #$08                  ;load offset to be added to length byte of header
    stx NoteLengthTblAdder
    if (!BNE FindEventMusicHeader) {  // from @15632
      cmp #$04                  ;is it underground music?
      if (!BNE NoStop1) {  // from LoadAreaMusic
      }
      ldy #$11
      while (BNE GMLoopB) {  // loop34
      }
    }
  }
  do {  // loop40
    // Block: FindEventMusicHeader
    iny                       ;increment Y pointer based on previously loaded queue contents
    lsr                       ;bit shift and increment until we find a set bit for music
    bcc FindEventMusicHeader
  } while (!BCC FindEventMusicHeader)
  // Block: LoadHeader
  lda MusicHeaderOffsetData,y  ;load offset for header
  tay
  lda MusicHeaderData,y        ;now load the header
  sta NoteLenLookupTblOfs
  lda MusicHeaderData+1,y
  sta MusicDataLow
  lda MusicHeaderData+2,y
  sta MusicDataHigh
  lda MusicHeaderData+3,y
  sta MusicOffset_Triangle
  lda MusicHeaderData+4,y
  sta MusicOffset_Square1
  lda MusicHeaderData+5,y
  sta MusicOffset_Noise
  sta NoiseDataLoopbackOfs
  lda #$01                     ;initialize music note counters
  sta Squ2_NoteLenCounter
  sta Squ1_NoteLenCounter
  sta Tri_NoteLenCounter
  sta Noise_BeatLenCounter
  lda #$00                     ;initialize music data offset for square 2
  sta MusicOffset_Square2
  sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
  lda #$0b                     ;disable triangle channel and reenable it
  sta SND_MASTERCTRL_REG
  lda #$0f
  sta SND_MASTERCTRL_REG
  dec Squ2_NoteLenCounter  ;decrement square 2 note length
  if (!BNE MiscSqu2MusicTasks) {  // from HandleSquare2Music
    ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
    inc MusicOffset_Square2
    lda (MusicData),y
    if (!BEQ EndOfMusicData) {  // from @15697
      if (!BPL Squ2NoteHandler) {  // from @15701
        if (!BNE Squ2LengthHandler) {  // from @15702
          lda EventMusicBuffer     ;check secondary buffer for time running out music
          cmp #TimeRunningOutMusic
          if (!BNE NotTRO) {  // from EndOfMusicData
            lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
            if (!BNE MusicLoopBack) {  // from @15708
              NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
              if (!BNE VictoryMLoopBack) {  // from NotTRO
                lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
                and #%01011111
                if (!BNE MusicLoopBack) {  // from @15712
                  lda #$00                 ;clear primary and secondary buffers and initialize
                  sta AreaMusicBuffer      ;control regs of square and triangle channels
                  sta EventMusicBuffer
                  sta SND_TRIANGLE_REG
                  lda #$90
                  sta SND_SQUARE1_REG
                  sta SND_SQUARE2_REG
                  rts
                }
                loop {  // loop65 (infinite)
                  // Block: MusicLoopBack
                  jmp HandleAreaMusicLoopB
                }
              }
            }
          }
          if (!BNE VictoryMLoopBack) {  // from NotTRO
            if (!BNE MusicLoopBack) {  // from @15712
            }
            loop {  // loop90 (infinite)
            }
          }
          loop {  // loop121 (infinite)
            // Block: LoadEventMusic
            sta EventMusicBuffer      ;copy event music queue contents to buffer
            cmp #DeathMusic           ;is it death music?
            bne NoStopSfx             ;if not, jump elsewhere
            // Block: NoStopSfx
            NoStopSfx: ldx AreaMusicBuffer
            stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
            ldy #$00
            sty NoteLengthTblAdder    ;default value for additional length byte offset
            sty AreaMusicBuffer       ;clear area music buffer
            cmp #TimeRunningOutMusic  ;is it time running out music?
            bne FindEventMusicHeader
            ldx #$08                  ;load offset to be added to length byte of header
            stx NoteLengthTblAdder
            bne FindEventMusicHeader  ;unconditional branch
            // Block: LoadAreaMusic
            cmp #$04                  ;is it underground music?
            bne NoStop1               ;no, do not stop square 1 sfx
            // Block: VictoryMLoopBack
            jmp LoadEventMusic
          }
        }
        // Block: Squ2LengthHandler
        jsr ProcessLengthData    ;store length of note
        sta Squ2_NoteLenBuffer
        ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
        inc MusicOffset_Square2
        lda (MusicData),y
      }
    }
    if (!BNE NotTRO) {  // from EndOfMusicData
      if (!BNE MusicLoopBack) {  // from @15708
        if (!BNE VictoryMLoopBack) {  // from NotTRO
          if (!BNE MusicLoopBack) {  // from @15712
          }
          loop {  // loop147 (infinite)
          }
        }
      }
    }
    if (!BNE VictoryMLoopBack) {  // from NotTRO
      if (!BNE MusicLoopBack) {  // from @15712
      }
      loop {  // loop172 (infinite)
      }
    }
    loop {  // loop203 (infinite)
    }
    ldx Square2SoundBuffer     ;is there a sound playing on this channel?
    if (!BNE SkipFqL1) {  // from Squ2NoteHandler
      jsr SetFreq_Squ2           ;no, then play the note
      if (!BEQ Rest) {  // from @15740
        jsr LoadControlRegs        ;if not, load control regs for square 2
      }
      // Block: Rest
      Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
      jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
    }
    // Block: SkipFqL1
    SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
    sta Squ2_NoteLenCounter
  }
  lda Square2SoundBuffer     ;is there a sound playing on square 2?
  if (!BNE HandleSquare1Music) {  // from MiscSqu2MusicTasks
    lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
    and #%10010001             ;note that regs for death music or d4 are loaded by default
    if (!BNE HandleSquare1Music) {  // from @15751
      ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
      if (!BEQ NoDecEnv1) {  // from @15754
        dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
      }
      // Block: NoDecEnv1
      NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
      sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
      ldx #$7f                   ;death music or d4 set on secondary buffer
      stx SND_SQUARE2_REG+1
    }
  }
  ldy MusicOffset_Square1    ;is there a nonzero offset here?
  if (!BEQ HandleTriangleMusic) {  // from HandleSquare1Music
    dec Squ1_NoteLenCounter    ;decrement square 1 note length
    if (!BNE MiscSqu1MusicTasks) {  // from @15765
      lda #$83
      sta SND_SQUARE1_REG        ;store some data into control regs for square 1
      lda #$94                   ;and fetch another byte of data, used to give
      sta SND_SQUARE1_REG+1      ;death music its unique sound
      sta AltRegContentFlag
      while (!BNE FetchSqu1MusicData) {  // loop220
        do {  // loop219
          // Block: FetchSqu1MusicData
          ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
          inc MusicOffset_Square1
          lda (MusicData),y
          bne Squ1NoteHandler        ;if nonzero, then skip this part
        } while (BNE FetchSqu1MusicData)
      }
      jsr AlternateLengthHandler
      sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
      ldy Square1SoundBuffer     ;is there a sound playing on square 1?
      if (!BNE HandleTriangleMusic) {  // from Squ1NoteHandler
        txa
        and #%00111110             ;change saved data to appropriate note format
        jsr SetFreq_Squ1           ;play the note
        if (!BEQ SkipCtrlL) {  // from @15785
          jsr LoadControlRegs
        }
        // Block: SkipCtrlL
        SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
        jsr Dump_Squ1_Regs
        lda Square1SoundBuffer     ;is there a sound playing on square 1?
        if (!BNE HandleTriangleMusic) {  // from MiscSqu1MusicTasks
          lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
          and #%10010001
          if (!BNE DeathMAltReg) {  // from @15796
            ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
            if (!BEQ NoDecEnv2) {  // from @15799
              dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
            }
            // Block: NoDecEnv2
            NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
            sta SND_SQUARE1_REG        ;based on offset set by first load
          }
          DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
          if (!BNE DoAltLoad) {  // from DeathMAltReg
            lda #$7f                   ;load this value if zero, the alternate value
          }
          // Block: DoAltLoad
          DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
        }
      }
    }
    if (!BNE HandleTriangleMusic) {  // from MiscSqu1MusicTasks
      if (!BNE DeathMAltReg) {  // from @15796
        if (!BEQ NoDecEnv2) {  // from @15799
        }
      }
      if (!BNE DoAltLoad) {  // from DeathMAltReg
      }
    }
  }
  lda MusicOffset_Triangle
  dec Tri_NoteLenCounter    ;decrement triangle note length
  if (!BNE HandleNoiseMusic) {  // from HandleTriangleMusic
    ldy MusicOffset_Triangle  ;increment square 1 music offset and fetch data
    inc MusicOffset_Triangle
    lda (MusicData),y
    if (!BEQ LoadTriCtrlReg) {  // from @15813
      if (!BPL TriNoteHandler) {  // from @15817
        jsr ProcessLengthData     ;otherwise, it is length data
        sta Tri_NoteLenBuffer     ;save contents of A
        lda #$1f
        sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
        ldy MusicOffset_Triangle  ;fetch another byte
        inc MusicOffset_Triangle
        lda (MusicData),y
        if (!BEQ LoadTriCtrlReg) {  // from @15818
          jsr SetFreq_Tri
          ldx Tri_NoteLenBuffer   ;save length in triangle note counter
          stx Tri_NoteLenCounter
          lda EventMusicBuffer
          and #%01101110          ;check for death music or d4 set on secondary buffer
          if (!BNE NotDOrD4) {  // from TriNoteHandler
            lda AreaMusicBuffer     ;check primary buffer for water or castle level music
            and #%00001010
            if (!BEQ HandleNoiseMusic) {  // from @15834
              NotDOrD4: txa                     ;if playing water or castle music or any secondary
              cmp #$12                ;besides death music or d4 set, check length of note
              if (!BCS LongN) {  // from NotDOrD4
                lda EventMusicBuffer    ;check for win castle music again if not playing a long note
                and #EndOfCastleMusic
                if (!BEQ MediN) {  // from @15840
                  lda #$0f                ;load value $0f if playing the win castle music and playing a short
                  if (!BNE LoadTriCtrlReg) {  // from @15843
                    MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
                    if (!BNE LoadTriCtrlReg) {  // from MediN
                      // Block: LongN
                      LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
                    }
                  }
                }
                if (!BNE LoadTriCtrlReg) {  // from MediN
                }
              }
              // Block: LoadTriCtrlReg
              sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
            }
          }
          if (!BCS LongN) {  // from NotDOrD4
            if (!BEQ MediN) {  // from @15840
              if (!BNE LoadTriCtrlReg) {  // from @15843
                if (!BNE LoadTriCtrlReg) {  // from MediN
                }
              }
            }
            if (!BNE LoadTriCtrlReg) {  // from MediN
            }
          }
        }
      }
      if (!BNE NotDOrD4) {  // from TriNoteHandler
        if (!BEQ HandleNoiseMusic) {  // from @15834
          if (!BCS LongN) {  // from NotDOrD4
            if (!BEQ MediN) {  // from @15840
              if (!BNE LoadTriCtrlReg) {  // from @15843
                if (!BNE LoadTriCtrlReg) {  // from MediN
                }
              }
            }
            if (!BNE LoadTriCtrlReg) {  // from MediN
            }
          }
        }
      }
      if (!BCS LongN) {  // from NotDOrD4
        if (!BEQ MediN) {  // from @15840
          if (!BNE LoadTriCtrlReg) {  // from @15843
            if (!BNE LoadTriCtrlReg) {  // from MediN
            }
          }
        }
        if (!BNE LoadTriCtrlReg) {  // from MediN
        }
      }
    }
  }
  lda AreaMusicBuffer       ;check if playing underground or castle music
  and #%11110011
  if (!BEQ ExitMusicHandler) {  // from HandleNoiseMusic
    dec Noise_BeatLenCounter  ;decrement noise beat length
    if (!BNE ExitMusicHandler) {  // from @15856
      lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
      sta MusicOffset_Noise       ;and loopback next time around
      while (!BNE FetchNoiseBeatData) {  // loop292
        do {  // loop291
          // Block: FetchNoiseBeatData
          ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
          inc MusicOffset_Noise
          lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
          bne NoiseBeatHandler
        } while (BNE FetchNoiseBeatData)
      }
      jsr AlternateLengthHandler
      sta Noise_BeatLenCounter    ;store length in noise beat counter
      txa
      and #%00111110              ;reload data and erase length bits
      if (!BEQ SilentBeat) {  // from NoiseBeatHandler
        cmp #$30                    ;check the beat data and play the appropriate
        if (!BEQ LongBeat) {  // from @15874
          cmp #$20
          if (!BEQ StrongBeat) {  // from @15876
            and #%00010000
            if (!BEQ SilentBeat) {  // from @15878
              lda #$1c        ;short beat data
              ldx #$03
              ldy #$18
              if (!BNE PlayBeat) {  // from @15880
                lda #$1c        ;strong beat data
                ldx #$0c
                ldy #$18
                if (!BNE PlayBeat) {  // from StrongBeat
                  lda #$1c        ;long beat data
                  ldx #$03
                  ldy #$58
                  if (!BNE PlayBeat) {  // from LongBeat
                    // Block: SilentBeat
                    lda #$10        ;silence
                  }
                }
              }
            }
          }
          if (!BNE PlayBeat) {  // from StrongBeat
            if (!BNE PlayBeat) {  // from LongBeat
            }
          }
        }
        if (!BNE PlayBeat) {  // from LongBeat
        }
      }
      // Block: PlayBeat
      sta SND_NOISE_REG    ;load beat data into noise regs
      stx SND_NOISE_REG+2
      sty SND_NOISE_REG+3
    }
  }
  // Block: ExitMusicHandler
  rts

def ChkForBump_HammerBroJ():
  SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
  lda Enemy_State,x           ;set d0 in enemy state for jumping
  ora #$01
  sta Enemy_State,x
  lda $00                     ;load preset value here to use as bitmask
  and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
  tay                         ;then use as offset
  lda SecondaryHardMode       ;check secondary hard mode flag
  if (!BNE HJump) {  // from SetHJ
    tay                         ;if secondary hard mode flag clear, set offset to 0
  }
  // Block: HJump
  HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
  sta EnemyFrameTimer,x       ;save in enemy timer
  lda PseudoRandomBitReg+1,x
  ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
  sta HammerBroJumpTimer,x    ;store in jump timer
  ldy #$fc                  ;move hammer bro a little to the left
  lda FrameCounter
  and #%01000000            ;change hammer bro's direction every 64 frames
  if (!BNE Shimmy) {  // from MoveHammerBroXDir
    ldy #$04                  ;if d6 set in counter, move him a little to the right
  }
  Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
  ldy #$01                  ;set to face right by default
  jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
  if (!BMI SetShim) {  // from Shimmy
    iny                       ;set to face left
    lda EnemyIntervalTimer,x  ;check walking timer
    if (!BNE SetShim) {  // from @9285
      lda #$f8
      sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
    }
  }
  // Block: SetShim
  SetShim: sty Enemy_MovingDir,x     ;set moving direction
  // Block: RXSpd
  RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
  eor #$ff                 ;get two's compliment for horizontal speed
  tay
  iny
  sty Enemy_X_Speed,x      ;store as new horizontal speed
  lda Enemy_MovingDir,x
  eor #%00000011           ;invert moving direction and store, then leave
  sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
  // Block: ExTA
  ExTA:  rts                      ;leave!!!
  cpx #$05               ;check if we're on the special use slot
  if (!BEQ NoBump) {  // from ChkForBump_HammerBroJ
    lda Enemy_State,x      ;if enemy state d7 not set, branch
    asl                    ;ahead and do not play sound
    if (!BCC NoBump) {  // from @12615
      lda #Sfx_Bump          ;otherwise, play bump sound
      sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
    }
  }
  NoBump: lda Enemy_ID,x         ;check for hammer bro
  cmp #$05
  if (!BNE InvEnemyDir) {  // from NoBump
    loop {  // loop30 (infinite)
      // Block: SetHJ
      SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
      lda Enemy_State,x           ;set d0 in enemy state for jumping
      ora #$01
      sta Enemy_State,x
      lda $00                     ;load preset value here to use as bitmask
      and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
      tay                         ;then use as offset
      lda SecondaryHardMode       ;check secondary hard mode flag
      bne HJump
      // Block: MoveHammerBroXDir
      ldy #$fc                  ;move hammer bro a little to the left
      lda FrameCounter
      and #%01000000            ;change hammer bro's direction every 64 frames
      bne Shimmy
      // Block: Shimmy
      Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
      ldy #$01                  ;set to face right by default
      jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
      bmi SetShim               ;if enemy to the left of player, skip this part
      iny                       ;set to face left
      lda EnemyIntervalTimer,x  ;check walking timer
      bne SetShim               ;if not yet expired, skip to set moving direction
      // Block: ChkForBump_HammerBroJ
      cpx #$05               ;check if we're on the special use slot
      beq NoBump             ;and if so, branch ahead and do not play sound
      lda Enemy_State,x      ;if enemy state d7 not set, branch
      asl                    ;ahead and do not play sound
      bcc NoBump
      lda #$00
      sta $00                ;initialize value here for bitmask
      ldy #$fa               ;load default vertical speed for jumping
      jmp SetHJ              ;jump to code that makes hammer bro jump
    }
  }
  loop {  // loop40 (infinite)
    // Block: InvEnemyDir
    jmp RXSpd     ;jump to turn the enemy around
  }

def GoContinue():
  // Block: GoContinue
  GoContinue:   sta WorldNumber             ;start both players at the first area
  sta OffScr_WorldNumber      ;of the previously saved world number
  ldx #$00                    ;note that on power-up using this function
  stx AreaNumber              ;will make no difference
  stx OffScr_AreaNumber
  rts

def MoveSmallPlatform():
  // Block: MoveSmallPlatform
  jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
  jmp ChkSmallPlatCollision  ;branch to position player correctly
  lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
  if (!BEQ ExLiftP) {  // from ChkSmallPlatCollision
    jsr PositionPlayerOnS_Plat  ;use to position player correctly
  }
  // Block: ExLiftP
  ExLiftP: rts                         ;then leave

def ShellOrBlockDefeat():
  lda Enemy_ID,x            ;check for piranha plant
  cmp #PiranhaPlant
  if (!BNE StnE) {  // from ShellOrBlockDefeat
    lda Enemy_Y_Position,x
    adc #$18                  ;add 24 pixels to enemy object's vertical position
    sta Enemy_Y_Position,x
  }
  StnE: jsr ChkToStunEnemies      ;do yet another sub
  lda Enemy_State,x
  and #%00011111            ;mask out 2 MSB of enemy object's state
  ora #%00100000            ;set d5 to defeat enemy and save as new state
  sta Enemy_State,x
  lda #$02                  ;award 200 points by default
  ldy Enemy_ID,x            ;check for hammer bro
  cpy #HammerBro
  if (!BNE GoombaPoints) {  // from StnE
    lda #$06                  ;award 1000 points for hammer bro
  }
  cpy #Goomba               ;check for goomba
  if (!BNE EnemySmackScore) {  // from GoombaPoints
    lda #$01                  ;award 100 points for goomba
  }
  // Block: EnemySmackScore
  jsr SetupFloateyNumber   ;update necessary score variables
  lda #Sfx_EnemySmack      ;play smack enemy sound
  sta Square1SoundQueue
  // Block: ExHCF
  ExHCF: rts                      ;and now let's leave

def PlayerEnemyDiff():
  // Block: PlayerEnemyDiff
  lda Enemy_X_Position,x  ;get distance between enemy object's
  sec                     ;horizontal coordinate and the player's
  sbc Player_X_Position   ;horizontal coordinate
  sta $00                 ;and store here
  lda Enemy_PageLoc,x
  sbc Player_PageLoc      ;subtract borrow, then leave
  rts

def GetMTileAttrib():
  // Block: GetMTileAttrib
  tay            ;save metatile value into Y
  and #%11000000 ;mask out all but 2 MSB
  asl
  rol            ;shift and rotate d7-d6 to d1-d0
  rol
  tax            ;use as offset for metatile data
  tya            ;get original metatile value back
  // Block: ExEBG
  ExEBG: rts            ;leave

def BlockBufferChk_FBall():
  // Block: BlockBufferChk_FBall
  ldy #$1a                  ;set offset for block buffer adder data
  txa
  clc
  adc #$07                  ;add seven bytes to use
  tax
  // Block: ResJmpM
  ResJmpM: lda #$00                  ;set A to return vertical coordinate
  // Block: BBChk_E
  BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
  ldx ObjectOffset          ;get object offset
  cmp #$00                  ;check to see if object bumped into anything
  rts


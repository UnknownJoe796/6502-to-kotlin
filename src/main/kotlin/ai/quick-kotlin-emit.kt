package com.ivieleague.decompiler6502tokotlin

/**
 * Pass 35: Quick Kotlin Code Emitter
 * - Generate functional Kotlin code from analyzed assembly
 * - Use expression trees when available (Pass 22)
 * - Fall back to instruction-level emission when needed
 * - Include original assembly as comments for debugging
 * - Output is functional but not idiomatic (quick & dirty)
 */

/**
 * Result of Kotlin code emission
 */
data class KotlinEmissionResult(
    val sourceCode: String,
    val functionCount: Int,
    val linesEmitted: Int,
    val usedExpressionTrees: Boolean
)

/**
 * Emit Kotlin code for the entire program
 */
fun CfgConstruction.emitQuickKotlin(
    codeFile: AssemblyCodeFile,
    expressionAnalysis: ExpressionTreeAnalysis? = null,
    deadCodeAnalysis: DeadCodeEliminationResult? = null,
    variableIdentification: VariableIdentification? = null
): KotlinEmissionResult {

    val sb = StringBuilder()
    var lineCount = 0

    // Emit file header
    sb.appendLine("// Decompiled from: ${codeFile.file?.name ?: "assembly"}")
    sb.appendLine("// Generated by 6502-to-Kotlin decompiler")
    sb.appendLine("// This is quick & dirty output - functional but not idiomatic")
    sb.appendLine()
    sb.appendLine("@file:Suppress(\"UNUSED_VARIABLE\", \"UNUSED_PARAMETER\", \"UNREACHABLE_CODE\", \"VARIABLE_WITH_REDUNDANT_INITIALIZER\")")
    sb.appendLine("package decompiled")
    sb.appendLine()
    lineCount += 7

    // Emit memory and registers
    sb.appendLine("// 64KB address space")
    sb.appendLine("val memory = ByteArray(65536)")
    sb.appendLine()
    sb.appendLine("// CPU registers")
    sb.appendLine("var A = 0  // Accumulator")
    sb.appendLine("var X = 0  // Index X")
    sb.appendLine("var Y = 0  // Index Y")
    sb.appendLine("var SP = 0xFF  // Stack pointer")
    sb.appendLine()
    sb.appendLine("// CPU flags")
    sb.appendLine("var flagN = false  // Negative")
    sb.appendLine("var flagV = false  // Overflow")
    sb.appendLine("var flagZ = false  // Zero")
    sb.appendLine("var flagC = false  // Carry")
    sb.appendLine()
    lineCount += 14

    // Emit each function
    for ((index, function) in functions.withIndex()) {
        val functionExprs = expressionAnalysis?.functions?.getOrNull(index)
        val emitter = FunctionEmitter(function, codeFile, functionExprs)
        val functionCode = emitter.emit()
        sb.append(functionCode)
        lineCount += functionCode.lines().size
    }

    return KotlinEmissionResult(
        sourceCode = sb.toString(),
        functionCount = functions.size,
        linesEmitted = lineCount,
        usedExpressionTrees = expressionAnalysis != null
    )
}

/**
 * Emitter for a single function
 */
private class FunctionEmitter(
    val function: FunctionCfg,
    val codeFile: AssemblyCodeFile,
    val functionExprs: FunctionExpressions?
) {
    private val sb = StringBuilder()
    private val labelMap = mutableMapOf<Int, String>()  // leader -> label name

    fun emit(): String {
        // Generate function name
        val funcName = function.entryLabel?.sanitizeIdentifier()
            ?: "Function_${function.entryAddress.toString(16).uppercase()}"

        sb.appendLine("fun $funcName() {")

        // Emit blocks
        emitBlocks()

        sb.appendLine("}")
        sb.appendLine()

        return sb.toString()
    }

    private fun emitBlocks() {
        // First pass: assign labels to blocks that need them
        assignLabels()

        // Second pass: emit blocks
        for (block in function.blocks) {
            emitBlock(block)
        }
    }

    private fun assignLabels() {
        // Any block that's a target of a branch/jump needs a label
        val targetBlocks = function.edges
            .filter { it.kind == CfgEdgeKind.TRUE || it.kind == CfgEdgeKind.FALSE || it.kind == CfgEdgeKind.UNCONDITIONAL }
            .mapNotNull { it.toLeader }
            .toSet()

        for (leader in targetBlocks) {
            if (leader != function.entryLeader) {  // Entry doesn't need label
                labelMap[leader] = "label_${leader.toString(16).uppercase()}"
            }
        }
    }

    private fun emitBlock(block: BasicBlock) {
        // Emit label if needed
        labelMap[block.leaderIndex]?.let { label ->
            sb.appendLine("    $label@while (true) {")
        }

        // Try to use expression trees if available
        val blockExprs = functionExprs?.blockExpressions?.get(block.leaderIndex)

        if (blockExprs != null && blockExprs.expressions.isNotEmpty()) {
            emitBlockWithExpressions(block, blockExprs)
        } else {
            emitBlockInstructions(block)
        }

        // Close label if needed
        if (labelMap.containsKey(block.leaderIndex)) {
            sb.appendLine("        break")
            sb.appendLine("    }")
        }
    }

    private fun emitBlockWithExpressions(block: BasicBlock, blockExprs: BlockExpressions) {
        // Emit each expression tree
        for (exprTree in blockExprs.expressions) {
            // Get assembly comment from source lines
            val asmComment = getAssemblyCommentForLines(exprTree.lineRange)

            sb.appendLine("    // $asmComment")

            // Emit the expression
            val kotlinCode = emitExpression(exprTree.root)
            sb.appendLine("    $kotlinCode")
        }

        // Handle control flow at end of block
        emitBlockControlFlow(block)
    }

    private fun emitBlockInstructions(block: BasicBlock) {
        // Fall back to instruction-by-instruction emission
        for (lineIndex in block.lineIndexes) {
            if (lineIndex >= codeFile.lines.size) continue

            val line = codeFile.lines[lineIndex]
            val instruction = line.instruction ?: continue

            // Emit assembly comment
            val asmText = formatAssemblyLine(line)
            sb.appendLine("    // $asmText")

            // Emit Kotlin instruction
            val kotlinCode = emitInstruction(instruction, lineIndex)
            if (kotlinCode.isNotEmpty()) {
                sb.appendLine("    $kotlinCode")
            }
        }

        // Handle control flow
        emitBlockControlFlow(block)
    }

    private fun emitBlockControlFlow(block: BasicBlock) {
        val outgoingEdges = function.edges.filter { it.fromLeader == block.leaderIndex }

        when {
            // Return
            outgoingEdges.any { it.kind == CfgEdgeKind.RETURN } -> {
                sb.appendLine("    return")
            }

            // Conditional branch
            outgoingEdges.size == 2 -> {
                val trueEdge = outgoingEdges.find { it.kind == CfgEdgeKind.TRUE }
                val falseEdge = outgoingEdges.find { it.kind == CfgEdgeKind.FALSE }

                if (trueEdge?.toLeader != null) {
                    val targetLabel = labelMap[trueEdge.toLeader] ?: "label_${trueEdge.toLeader}"
                    sb.appendLine("    if (/* branch condition */) continue@$targetLabel")
                }
            }

            // Unconditional jump
            outgoingEdges.size == 1 && outgoingEdges[0].kind == CfgEdgeKind.UNCONDITIONAL -> {
                val target = outgoingEdges[0].toLeader
                if (target != null) {
                    val targetLabel = labelMap[target] ?: "label_$target"
                    sb.appendLine("    continue@$targetLabel")
                }
            }
        }
    }

    private fun emitExpression(expr: Expression): String = when (expr) {
        is Expression.Literal -> {
            when {
                expr.value < 10 -> expr.value.toString()
                expr.value < 256 -> "0x${expr.value.toString(16).uppercase()}"
                else -> "0x${expr.value.toString(16).uppercase().padStart(4, '0')}"
            }
        }

        is Expression.VariableRef -> expr.variable.toString()

        is Expression.MemoryAccess -> {
            "memory[${emitExpression(expr.address)}]"
        }

        is Expression.BinaryOp -> {
            val left = emitExpression(expr.left)
            val right = emitExpression(expr.right)
            "($left ${expr.op.symbol} $right) and 0xFF"  // Ensure 8-bit
        }

        is Expression.Comparison -> {
            val left = emitExpression(expr.left)
            val right = emitExpression(expr.right)
            "$left ${expr.op.symbol} $right"
        }

        is Expression.UnaryOp -> {
            val operand = emitExpression(expr.operand)
            "${expr.op.symbol}($operand)"
        }

        is Expression.ArrayAccess -> {
            val base = emitExpression(expr.base)
            val index = emitExpression(expr.index)
            "$base[$index]"
        }

        is Expression.Assignment -> {
            val target = emitExpression(expr.target)
            val value = emitExpression(expr.value)
            "$target = $value"
        }

        is Expression.FunctionCall -> {
            val args = expr.arguments.joinToString(", ") { emitExpression(it) }
            "${expr.target}($args)"
        }

        is Expression.FieldAccess -> {
            val base = emitExpression(expr.base)
            "$base.${expr.fieldName}"
        }

        is Expression.Phi -> {
            // Phi functions should be eliminated before emission
            "/* phi: ${expr.variable} */"
        }
    }

    private fun emitInstruction(instruction: AssemblyInstruction, lineIndex: Int): String {
        val op = instruction.op
        val addr = instruction.address ?: AssemblyAddressing.Accumulator

        return when (op) {
            // Load instructions
            AssemblyOp.LDA -> "A = ${emitAddressing(addr)}"
            AssemblyOp.LDX -> "X = ${emitAddressing(addr)}"
            AssemblyOp.LDY -> "Y = ${emitAddressing(addr)}"

            // Store instructions
            AssemblyOp.STA -> "${emitAddressingTarget(addr)} = A"
            AssemblyOp.STX -> "${emitAddressingTarget(addr)} = X"
            AssemblyOp.STY -> "${emitAddressingTarget(addr)} = Y"

            // Transfer instructions
            AssemblyOp.TAX -> "X = A"
            AssemblyOp.TAY -> "Y = A"
            AssemblyOp.TXA -> "A = X"
            AssemblyOp.TYA -> "A = Y"
            AssemblyOp.TSX -> "X = SP"
            AssemblyOp.TXS -> "SP = X"

            // Stack instructions
            AssemblyOp.PHA -> "memory[0x0100 + SP] = A; SP = (SP - 1) and 0xFF"
            AssemblyOp.PLA -> "SP = (SP + 1) and 0xFF; A = memory[0x0100 + SP]"
            AssemblyOp.PHP -> "memory[0x0100 + SP] = /* flags */; SP = (SP - 1) and 0xFF"
            AssemblyOp.PLP -> "SP = (SP + 1) and 0xFF; /* restore flags from memory[0x0100 + SP] */"

            // Arithmetic
            AssemblyOp.ADC -> "A = (A + ${emitAddressing(addr)} + (if (flagC) 1 else 0)) and 0xFF"
            AssemblyOp.SBC -> "A = (A - ${emitAddressing(addr)} - (if (!flagC) 1 else 0)) and 0xFF"
            AssemblyOp.INC -> "${emitAddressingTarget(addr)} = (${emitAddressingTarget(addr)} + 1) and 0xFF"
            AssemblyOp.DEC -> "${emitAddressingTarget(addr)} = (${emitAddressingTarget(addr)} - 1) and 0xFF"
            AssemblyOp.INX -> "X = (X + 1) and 0xFF"
            AssemblyOp.INY -> "Y = (Y + 1) and 0xFF"
            AssemblyOp.DEX -> "X = (X - 1) and 0xFF"
            AssemblyOp.DEY -> "Y = (Y - 1) and 0xFF"

            // Logical
            AssemblyOp.AND -> "A = A and ${emitAddressing(addr)}"
            AssemblyOp.ORA -> "A = A or ${emitAddressing(addr)}"
            AssemblyOp.EOR -> "A = A xor ${emitAddressing(addr)}"

            // Shift/Rotate
            AssemblyOp.ASL -> "${emitAddressingTarget(addr)} = (${emitAddressingTarget(addr)} shl 1) and 0xFF"
            AssemblyOp.LSR -> "${emitAddressingTarget(addr)} = ${emitAddressingTarget(addr)} shr 1"
            AssemblyOp.ROL -> "/* ROL ${emitAddressingTarget(addr)} */"
            AssemblyOp.ROR -> "/* ROR ${emitAddressingTarget(addr)} */"

            // Comparison
            AssemblyOp.CMP -> "flagZ = (A == ${emitAddressing(addr)}); flagN = (A < ${emitAddressing(addr)}); flagC = (A >= ${emitAddressing(addr)})"
            AssemblyOp.CPX -> "flagZ = (X == ${emitAddressing(addr)}); flagN = (X < ${emitAddressing(addr)}); flagC = (X >= ${emitAddressing(addr)})"
            AssemblyOp.CPY -> "flagZ = (Y == ${emitAddressing(addr)}); flagN = (Y < ${emitAddressing(addr)}); flagC = (Y >= ${emitAddressing(addr)})"

            // Bit test
            AssemblyOp.BIT -> "/* BIT ${emitAddressing(addr)} */"

            // Branches (handled in control flow)
            AssemblyOp.BEQ, AssemblyOp.BNE, AssemblyOp.BCS, AssemblyOp.BCC,
            AssemblyOp.BMI, AssemblyOp.BPL, AssemblyOp.BVS, AssemblyOp.BVC -> ""

            // Jumps (handled in control flow)
            AssemblyOp.JMP, AssemblyOp.JSR, AssemblyOp.RTS, AssemblyOp.RTI -> ""

            // Flags
            AssemblyOp.CLC -> "flagC = false"
            AssemblyOp.SEC -> "flagC = true"
            AssemblyOp.CLD -> "/* CLD - decimal mode off */"
            AssemblyOp.SED -> "/* SED - decimal mode on */"
            AssemblyOp.CLI -> "/* CLI - interrupts enabled */"
            AssemblyOp.SEI -> "/* SEI - interrupts disabled */"
            AssemblyOp.CLV -> "flagV = false"

            // No-op
            AssemblyOp.NOP -> "/* NOP */"

            // Break
            AssemblyOp.BRK -> "/* BRK */"

            else -> "/* ${op.name} */"
        }
    }

    private fun emitAddressing(addr: AssemblyAddressing): String = when (addr) {
        is AssemblyAddressing.Accumulator -> "A"
        is AssemblyAddressing.ValueHex -> "0x${Integer.toHexString(addr.value.toInt() and 0xFF).uppercase()}"
        is AssemblyAddressing.ValueDecimal -> (addr.value.toInt() and 0xFF).toString()
        is AssemblyAddressing.ValueBinary -> (addr.value.toInt() and 0xFF).toString()
        is AssemblyAddressing.ValueReference -> addr.name  // Label reference
        is AssemblyAddressing.Label -> "memory[/* ${addr.label} */]"
        is AssemblyAddressing.DirectX -> "memory[/* ${addr.label} */ + X]"
        is AssemblyAddressing.DirectY -> "memory[/* ${addr.label} */ + Y]"
        is AssemblyAddressing.IndirectX -> "memory[memory[/* ${addr.label} */ + X]]"
        is AssemblyAddressing.IndirectY -> "memory[memory[/* ${addr.label} */] + Y]"
        is AssemblyAddressing.IndirectAbsolute -> "memory[memory[/* ${addr.label} */]]"
    }

    private fun emitAddressingTarget(addr: AssemblyAddressing): String = when (addr) {
        is AssemblyAddressing.Accumulator -> "A"
        is AssemblyAddressing.Label -> "memory[/* ${addr.label} */]"
        is AssemblyAddressing.DirectX -> "memory[/* ${addr.label} */ + X]"
        is AssemblyAddressing.DirectY -> "memory[/* ${addr.label} */ + Y]"
        else -> emitAddressing(addr)
    }

    private fun getAssemblyCommentForLines(lineRange: IntRange): String {
        val lines = lineRange.mapNotNull { idx ->
            if (idx < codeFile.lines.size) {
                val line = codeFile.lines[idx]
                formatAssemblyLine(line)
            } else null
        }
        return lines.joinToString(" ; ")
    }

    private fun formatAssemblyLine(line: AssemblyLine): String {
        val parts = mutableListOf<String>()

        line.label?.let { parts.add("$it:") }
        line.instruction?.let { instr ->
            parts.add(instr.op.name)
            instr.address?.toString()?.let { parts.add(it) }
        }

        return parts.joinToString(" ")
    }
}

/**
 * Sanitize identifier to be valid Kotlin
 */
private fun String.sanitizeIdentifier(): String {
    // Replace invalid characters with underscore
    val sanitized = this.replace(Regex("[^a-zA-Z0-9_]"), "_")

    // Ensure doesn't start with digit
    return if (sanitized.firstOrNull()?.isDigit() == true) {
        "_$sanitized"
    } else {
        sanitized
    }
}

package com.ivieleague.decompiler6502tokotlin

/**
 * Pass 10: Data Flow Analysis
 * - Reaching definitions analysis
 * - Live variable analysis 
 * - Use-def and def-use chain construction
 * - Dead code identification
 */

/**
 * Represents a variable definition in the program
 */
data class Definition(
    /** The line reference where this definition occurs */
    val lineRef: AssemblyLineReference,
    /** The variable being defined (register, memory location, etc.) */
    val variable: Variable,
    /** The basic block leader where this definition occurs */
    val blockLeader: Int
) {
    /** Legacy property for backward compatibility */
    @Deprecated("Use lineRef instead", ReplaceWith("lineRef.line"))
    val lineIndex: Int get() = lineRef.line
}

/**
 * Represents a variable use in the program
 */
data class Use(
    /** The line reference where this use occurs */
    val lineRef: AssemblyLineReference,
    /** The variable being used */
    val variable: Variable,
    /** The basic block leader where this use occurs */
    val blockLeader: Int
) {
    /** Legacy property for backward compatibility */
    @Deprecated("Use lineRef instead", ReplaceWith("lineRef.line"))
    val lineIndex: Int get() = lineRef.line
}

/**
 * Represents a variable in the 6502 system
 */
sealed class Variable {
    /** CPU register A */
    object RegisterA : Variable() {
        override fun toString() = "A"
    }
    
    /** CPU register X */
    object RegisterX : Variable() {
        override fun toString() = "X"
    }
    
    /** CPU register Y */
    object RegisterY : Variable() {
        override fun toString() = "Y"
    }
    
    /** Stack pointer */
    object StackPointer : Variable() {
        override fun toString() = "SP"
    }
    
    /** Processor status flags */
    object StatusFlags : Variable() {
        override fun toString() = "P"
    }
    
    /** Memory location at specific address */
    data class Memory(val address: Int) : Variable() {
        override fun toString() = "MEM[$${address.toString(16).uppercase()}]"
    }
    
    /** Zero page memory location */
    data class ZeroPage(val address: Int) : Variable() {
        override fun toString() = "ZP[$${address.toString(16).uppercase()}]"
    }
    
    /** Indirect memory access */
    data class Indirect(val baseAddress: Int) : Variable() {
        override fun toString() = "IND[$${baseAddress.toString(16).uppercase()}]"
    }
}

/**
 * Data flow facts for a single basic block
 */
data class DataFlowFacts(
    /** Definitions generated by this block */
    val gen: Set<Definition>,
    /** Definitions killed by this block */
    val kill: Set<Definition>,
    /** Definitions reaching the entry of this block */
    val reachIn: MutableSet<Definition> = mutableSetOf(),
    /** Definitions reaching the exit of this block */
    val reachOut: MutableSet<Definition> = mutableSetOf(),
    /** Variables live at the entry of this block */
    val liveIn: MutableSet<Variable> = mutableSetOf(),
    /** Variables live at the exit of this block */
    val liveOut: MutableSet<Variable> = mutableSetOf()
)

/**
 * Use-def chain: connects each use to the definitions that may reach it
 */
data class UseDefChain(
    val use: Use,
    val reachingDefinitions: Set<Definition>
)

/**
 * Def-use chain: connects each definition to the uses it may reach
 */
data class DefUseChain(
    val definition: Definition,
    val reachedUses: Set<Use>
)

/**
 * Complete data flow analysis result for a function
 */
data class FunctionDataFlow(
    /** The function this analysis applies to */
    val function: FunctionCfg,
    /** Data flow facts for each basic block */
    val blockFacts: Map<Int, DataFlowFacts>,
    /** All definitions in this function */
    val definitions: List<Definition>,
    /** All uses in this function */
    val uses: List<Use>,
    /** Use-def chains */
    val useDefChains: List<UseDefChain>,
    /** Def-use chains */
    val defUseChains: List<DefUseChain>,
    /** Dead definitions (never used) */
    val deadDefinitions: Set<Definition>
)

/**
 * Data flow analysis result for the entire program
 */
data class DataFlowAnalysis(
    /** Data flow analysis for each function */
    val functions: List<FunctionDataFlow>
)

/**
 * Perform data flow analysis on all functions
 */
fun AssemblyCodeFile.analyzeDataFlow(
    cfg: CfgConstruction,
    dominators: DominatorConstruction
): DataFlowAnalysis {
    val functionAnalyses = cfg.functions.mapIndexed { index, function ->
        val domAnalysis = dominators.functions[index]
        analyzeDataFlowForFunction(this, function, domAnalysis)
    }
    
    return DataFlowAnalysis(functions = functionAnalyses)
}

/**
 * Legacy extension for backward compatibility
 */
@Deprecated("Use AssemblyCodeFile.analyzeDataFlow instead")
fun List<AssemblyLine>.analyzeDataFlow(
    cfg: CfgConstruction,
    dominators: DominatorConstruction
): DataFlowAnalysis = this.toCodeFile().analyzeDataFlow(cfg, dominators)

/**
 * Analyze data flow for a single function
 */
private fun analyzeDataFlowForFunction(
    codeFile: AssemblyCodeFile,
    function: FunctionCfg,
    dominatorAnalysis: DominatorAnalysis
): FunctionDataFlow {
    // Extract definitions and uses from the function
    val definitions = mutableListOf<Definition>()
    val uses = mutableListOf<Use>()
    
    function.blocks.forEach { block ->
        block.lineIndexes.forEach { lineIndex ->
            val lineRef = codeFile.get(lineIndex)
            val line = lineRef.content
            line.instruction?.let { instr ->
                // Extract definitions and uses from this instruction
                extractDefinitionsAndUses(lineRef, instr, block.leaderIndex, definitions, uses)
            }
        }
    }
    
    // Compute gen/kill sets for each block
    val blockFacts = mutableMapOf<Int, DataFlowFacts>()
    function.blocks.forEach { block ->
        val blockDefs = definitions.filter { it.blockLeader == block.leaderIndex }
        val blockUses = uses.filter { it.blockLeader == block.leaderIndex }
        
        // Gen set: definitions generated in this block
        val gen = blockDefs.toSet()
        
        // Kill set: definitions killed by definitions in this block
        val kill = mutableSetOf<Definition>()
        blockDefs.forEach { def ->
            // This definition kills all other definitions of the same variable
            definitions.filter { it.variable == def.variable && it != def }.forEach { killed ->
                kill.add(killed)
            }
        }
        
        blockFacts[block.leaderIndex] = DataFlowFacts(gen = gen, kill = kill)
    }
    
    // Perform reaching definitions analysis
    computeReachingDefinitions(function, blockFacts)
    
    // Perform live variable analysis
    computeLiveVariables(function, blockFacts, uses)
    
    // Build use-def chains
    val useDefChains = buildUseDefChains(uses, blockFacts)
    
    // Build def-use chains
    val defUseChains = buildDefUseChains(definitions, uses, blockFacts)
    
    // Identify dead definitions
    val deadDefinitions = findDeadDefinitions(definitions, defUseChains)
    
    return FunctionDataFlow(
        function = function,
        blockFacts = blockFacts,
        definitions = definitions,
        uses = uses,
        useDefChains = useDefChains,
        defUseChains = defUseChains,
        deadDefinitions = deadDefinitions
    )
}

/**
 * Extract definitions and uses from a single instruction
 */
private fun extractDefinitionsAndUses(
    lineRef: AssemblyLineReference,
    instruction: AssemblyInstruction,
    blockLeader: Int,
    definitions: MutableList<Definition>,
    uses: MutableList<Use>
) {
    val op = instruction.op
    val operand = instruction.address?.toString()
    
    when (op) {
        // Load instructions - define target register, use source
        AssemblyOp.LDA -> {
            definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
        }
        AssemblyOp.LDX -> {
            definitions.add(Definition(lineRef, Variable.RegisterX, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
        }
        AssemblyOp.LDY -> {
            definitions.add(Definition(lineRef, Variable.RegisterY, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
        }
        
        // Store instructions - use source register, define target memory
        AssemblyOp.STA -> {
            uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses) // For index registers
            extractDefinitionsFromOperand(lineRef, instruction, blockLeader, definitions)
        }
        AssemblyOp.STX -> {
            uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses) // For index registers
            extractDefinitionsFromOperand(lineRef, instruction, blockLeader, definitions)
        }
        AssemblyOp.STY -> {
            uses.add(Use(lineRef, Variable.RegisterY, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses) // For index registers
            extractDefinitionsFromOperand(lineRef, instruction, blockLeader, definitions)
        }
        
        // Arithmetic/logic instructions - define A, use A and operand
        AssemblyOp.ADC, AssemblyOp.SBC, AssemblyOp.AND, AssemblyOp.ORA, AssemblyOp.EOR, AssemblyOp.CMP -> {
            uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
        }
        
        // Register operations
        AssemblyOp.TAX -> {
            uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.TAY -> {
            uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.TXA -> {
            uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.TYA -> {
            uses.add(Use(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.TXS -> {
            uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.StackPointer, blockLeader))
        }
        AssemblyOp.TSX -> {
            uses.add(Use(lineRef, Variable.StackPointer, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Increment/decrement
        AssemblyOp.INX -> {
            uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.INY -> {
            uses.add(Use(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.DEX -> {
            uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.DEY -> {
            uses.add(Use(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Memory increment/decrement
        AssemblyOp.INC, AssemblyOp.DEC -> {
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
            extractDefinitionsFromOperand(lineRef, instruction, blockLeader, definitions)
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Shifts and rotates
        AssemblyOp.ASL, AssemblyOp.LSR, AssemblyOp.ROL, AssemblyOp.ROR -> {
            if (instruction.address == null) {
                // Accumulator mode
                uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
                definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            } else {
                // Memory mode
                extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
                extractDefinitionsFromOperand(lineRef, instruction, blockLeader, definitions)
            }
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Branches - use status flags
        AssemblyOp.BCC, AssemblyOp.BCS, AssemblyOp.BEQ, AssemblyOp.BMI, AssemblyOp.BNE, 
        AssemblyOp.BPL, AssemblyOp.BVC, AssemblyOp.BVS -> {
            uses.add(Use(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Stack operations
        AssemblyOp.PHA -> {
            uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
            uses.add(Use(lineRef, Variable.StackPointer, blockLeader))
            definitions.add(Definition(lineRef, Variable.StackPointer, blockLeader))
        }
        AssemblyOp.PLA -> {
            uses.add(Use(lineRef, Variable.StackPointer, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.StackPointer, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        AssemblyOp.PHP -> {
            uses.add(Use(lineRef, Variable.StatusFlags, blockLeader))
            uses.add(Use(lineRef, Variable.StackPointer, blockLeader))
            definitions.add(Definition(lineRef, Variable.StackPointer, blockLeader))
        }
        AssemblyOp.PLP -> {
            uses.add(Use(lineRef, Variable.StackPointer, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
            definitions.add(Definition(lineRef, Variable.StackPointer, blockLeader))
        }
        
        // Flag operations
        AssemblyOp.CLC, AssemblyOp.SEC, AssemblyOp.CLI, AssemblyOp.SEI, 
        AssemblyOp.CLV, AssemblyOp.CLD, AssemblyOp.SED -> {
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Compare instructions
        AssemblyOp.CPX, AssemblyOp.CPY -> {
            val register = if (op == AssemblyOp.CPX) Variable.RegisterX else Variable.RegisterY
            uses.add(Use(lineRef, register, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
        }
        
        // Bit test
        AssemblyOp.BIT -> {
            extractUsesFromOperand(lineRef, instruction, blockLeader, uses)
            uses.add(Use(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
        
        // Other instructions that don't affect registers directly
        AssemblyOp.NOP, AssemblyOp.JMP, AssemblyOp.JSR, AssemblyOp.RTS, AssemblyOp.RTI, AssemblyOp.BRK -> {
            // These may have side effects but don't directly define/use registers
            // JSR/RTS affect stack pointer but we handle that separately
            if (op == AssemblyOp.JSR || op == AssemblyOp.RTS) {
                uses.add(Use(lineRef, Variable.StackPointer, blockLeader))
                definitions.add(Definition(lineRef, Variable.StackPointer, blockLeader))
            }
        }
        
        else -> {
            // Unknown instruction - be conservative and assume it affects everything
            definitions.add(Definition(lineRef, Variable.RegisterA, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterX, blockLeader))
            definitions.add(Definition(lineRef, Variable.RegisterY, blockLeader))
            definitions.add(Definition(lineRef, Variable.StatusFlags, blockLeader))
        }
    }
}

/**
 * Extract uses from an operand
 */
private fun extractUsesFromOperand(
    lineRef: AssemblyLineReference,
    instruction: AssemblyInstruction,
    blockLeader: Int,
    uses: MutableList<Use>
) {
    instruction.address?.let { addressing ->
        when (addressing) {
            // Immediate modes - no memory uses
            is AssemblyAddressing.ValueHex,
            is AssemblyAddressing.ValueBinary, 
            is AssemblyAddressing.ValueDecimal,
            is AssemblyAddressing.ValueReference -> {
                // No register uses for immediate values
            }
            
            // Indexed addressing - use index register and base address
            is AssemblyAddressing.DirectX -> {
                uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    val variable = if (baseAddr < 256) Variable.ZeroPage(baseAddr) else Variable.Memory(baseAddr)
                    uses.add(Use(lineRef, variable, blockLeader))
                }
            }
            is AssemblyAddressing.DirectY -> {
                uses.add(Use(lineRef, Variable.RegisterY, blockLeader))
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    val variable = if (baseAddr < 256) Variable.ZeroPage(baseAddr) else Variable.Memory(baseAddr)
                    uses.add(Use(lineRef, variable, blockLeader))
                }
            }
            
            // Indirect addressing
            is AssemblyAddressing.IndirectX -> {
                uses.add(Use(lineRef, Variable.RegisterX, blockLeader))
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    uses.add(Use(lineRef, Variable.Indirect(baseAddr), blockLeader))
                }
            }
            is AssemblyAddressing.IndirectY -> {
                uses.add(Use(lineRef, Variable.RegisterY, blockLeader))
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    uses.add(Use(lineRef, Variable.Indirect(baseAddr), blockLeader))
                }
            }
            is AssemblyAddressing.IndirectAbsolute -> {
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    uses.add(Use(lineRef, Variable.Indirect(baseAddr), blockLeader))
                }
            }
            
            // Direct addressing
            is AssemblyAddressing.Label -> {
                val addr = parseAddressFromLabel(addressing.label)
                if (addr != null) {
                    val variable = if (addr < 256) Variable.ZeroPage(addr) else Variable.Memory(addr)
                    uses.add(Use(lineRef, variable, blockLeader))
                }
            }
            
            // Accumulator mode - no memory uses
            is AssemblyAddressing.Accumulator -> {
                // No memory uses
            }
        }
    }
}

/**
 * Extract definitions from an operand (for store instructions)
 */
private fun extractDefinitionsFromOperand(
    lineRef: AssemblyLineReference,
    instruction: AssemblyInstruction,
    blockLeader: Int,
    definitions: MutableList<Definition>
) {
    instruction.address?.let { addressing ->
        when (addressing) {
            // Indexed addressing - define memory at computed address
            is AssemblyAddressing.DirectX -> {
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    val variable = if (baseAddr < 256) Variable.ZeroPage(baseAddr) else Variable.Memory(baseAddr)
                    definitions.add(Definition(lineRef, variable, blockLeader))
                }
            }
            is AssemblyAddressing.DirectY -> {
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    val variable = if (baseAddr < 256) Variable.ZeroPage(baseAddr) else Variable.Memory(baseAddr)
                    definitions.add(Definition(lineRef, variable, blockLeader))
                }
            }
            
            // Indirect addressing
            is AssemblyAddressing.IndirectX -> {
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    definitions.add(Definition(lineRef, Variable.Indirect(baseAddr), blockLeader))
                }
            }
            is AssemblyAddressing.IndirectY -> {
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    definitions.add(Definition(lineRef, Variable.Indirect(baseAddr), blockLeader))
                }
            }
            is AssemblyAddressing.IndirectAbsolute -> {
                val baseAddr = parseAddressFromLabel(addressing.label)
                if (baseAddr != null) {
                    definitions.add(Definition(lineRef, Variable.Indirect(baseAddr), blockLeader))
                }
            }
            
            // Direct addressing
            is AssemblyAddressing.Label -> {
                val addr = parseAddressFromLabel(addressing.label)
                if (addr != null) {
                    val variable = if (addr < 256) Variable.ZeroPage(addr) else Variable.Memory(addr)
                    definitions.add(Definition(lineRef, variable, blockLeader))
                }
            }
            
            // Other addressing modes don't define memory
            else -> {
                // No memory definitions for immediate, accumulator, etc.
            }
        }
    }
}

/**
 * Parse address from label string
 */
private fun parseAddressFromLabel(label: String): Int? {
    return try {
        when {
            label.startsWith("$") -> label.substring(1).toInt(16)
            label.startsWith("0x") -> label.substring(2).toInt(16)
            label.all { it.isDigit() } -> label.toInt()
            else -> null // Label or other non-numeric operand
        }
    } catch (e: NumberFormatException) {
        null
    }
}

/**
 * Compute reaching definitions using iterative dataflow analysis
 */
private fun computeReachingDefinitions(
    function: FunctionCfg,
    blockFacts: Map<Int, DataFlowFacts>
) {
    // Initialize
    blockFacts.values.forEach { facts ->
        facts.reachIn.clear()
        facts.reachOut.addAll(facts.gen)
    }
    
    // Iterate until fixed point
    var changed = true
    var iterations = 0
    while (changed && iterations < 100) {
        changed = false
        iterations++
        
        function.blocks.forEach { block ->
            val facts = blockFacts[block.leaderIndex] ?: return@forEach
            
            // Collect reaching definitions from predecessors
            val newReachIn = mutableSetOf<Definition>()
            function.edges.filter { it.toLeader == block.leaderIndex }.forEach { edge ->
                val predFacts = blockFacts[edge.fromLeader]
                if (predFacts != null) {
                    newReachIn.addAll(predFacts.reachOut)
                }
            }
            
            if (newReachIn != facts.reachIn) {
                facts.reachIn.clear()
                facts.reachIn.addAll(newReachIn)
                changed = true
                
                // Recompute reachOut = gen ∪ (reachIn - kill)
                val newReachOut = facts.gen.toMutableSet()
                newReachOut.addAll(facts.reachIn - facts.kill)
                
                if (newReachOut != facts.reachOut) {
                    facts.reachOut.clear()
                    facts.reachOut.addAll(newReachOut)
                }
            }
        }
    }
}

/**
 * Compute live variables using backward dataflow analysis
 */
private fun computeLiveVariables(
    function: FunctionCfg,
    blockFacts: Map<Int, DataFlowFacts>,
    uses: List<Use>
) {
    // Compute use/def sets for each block
    val blockUses = mutableMapOf<Int, Set<Variable>>()
    val blockDefs = mutableMapOf<Int, Set<Variable>>()
    
    function.blocks.forEach { block ->
        val blockUsesSet = uses.filter { it.blockLeader == block.leaderIndex }.map { it.variable }.toSet()
        val blockDefsSet = blockFacts[block.leaderIndex]?.gen?.map { it.variable }?.toSet() ?: emptySet()
        
        blockUses[block.leaderIndex] = blockUsesSet
        blockDefs[block.leaderIndex] = blockDefsSet
    }
    
    // Initialize
    blockFacts.values.forEach { facts ->
        facts.liveIn.clear()
        facts.liveOut.clear()
    }
    
    // Iterate until fixed point (backward analysis)
    var changed = true
    var iterations = 0
    while (changed && iterations < 100) {
        changed = false
        iterations++
        
        // Process blocks in reverse order for backward analysis
        function.blocks.reversed().forEach { block ->
            val facts = blockFacts[block.leaderIndex] ?: return@forEach
            
            // Collect live variables from successors
            val newLiveOut = mutableSetOf<Variable>()
            function.edges.filter { it.fromLeader == block.leaderIndex && it.toLeader != null }.forEach { edge ->
                val succFacts = blockFacts[edge.toLeader!!]
                if (succFacts != null) {
                    newLiveOut.addAll(succFacts.liveIn)
                }
            }
            
            if (newLiveOut != facts.liveOut) {
                facts.liveOut.clear()
                facts.liveOut.addAll(newLiveOut)
                changed = true
                
                // Recompute liveIn = use ∪ (liveOut - def)
                val uses = blockUses[block.leaderIndex] ?: emptySet()
                val defs = blockDefs[block.leaderIndex] ?: emptySet()
                val newLiveIn = uses.toMutableSet()
                newLiveIn.addAll(facts.liveOut - defs)
                
                if (newLiveIn != facts.liveIn) {
                    facts.liveIn.clear()
                    facts.liveIn.addAll(newLiveIn)
                }
            }
        }
    }
}

/**
 * Build use-def chains
 */
private fun buildUseDefChains(
    uses: List<Use>,
    blockFacts: Map<Int, DataFlowFacts>
): List<UseDefChain> {
    return uses.map { use ->
        val blockFact = blockFacts[use.blockLeader]
        
        // Find definitions within the same block that come before this use
        val defsInBlock = blockFact?.gen?.filter { 
            it.variable == use.variable && it.lineRef.line < use.lineRef.line 
        } ?: emptyList()
        
        val allReachingDefs = if (defsInBlock.isNotEmpty()) {
            // If there are definitions in the same block, use only the most recent one
            // (later definitions kill earlier ones and definitions from block entry)
            setOf(defsInBlock.maxByOrNull { it.lineRef.line }!!)
        } else {
            // No definitions in block before this use, so use definitions reaching from entry
            blockFact?.reachIn?.filter { it.variable == use.variable }?.toSet() ?: emptySet()
        }
        UseDefChain(use, allReachingDefs)
    }
}

/**
 * Build def-use chains
 */
private fun buildDefUseChains(
    definitions: List<Definition>,
    uses: List<Use>,
    blockFacts: Map<Int, DataFlowFacts>
): List<DefUseChain> {
    return definitions.map { definition ->
        val reachedUses = mutableSetOf<Use>()
        
        // Find all uses that this definition can reach
        uses.filter { it.variable == definition.variable }.forEach { use ->
            val blockFact = blockFacts[use.blockLeader]
            
            if (definition.blockLeader == use.blockLeader) {
                // Same block: definition reaches use if it comes before and no other definition
                // of the same variable comes between them
                if (definition.lineRef.line < use.lineRef.line) {
                    val defsInBetween = blockFact?.gen?.any { otherDef ->
                        otherDef.variable == definition.variable &&
                        otherDef.lineRef.line > definition.lineRef.line &&
                        otherDef.lineRef.line < use.lineRef.line
                    } ?: false
                    
                    if (!defsInBetween) {
                        reachedUses.add(use)
                    }
                }
            } else {
                // Different blocks: check if definition reaches from block entry and no 
                // definition in the use's block kills it
                val reachesFromIn = blockFact?.reachIn?.contains(definition) == true
                if (reachesFromIn) {
                    val killedInBlock = blockFact?.gen?.any { otherDef ->
                        otherDef.variable == definition.variable && otherDef.lineRef.line < use.lineRef.line
                    } ?: false
                    
                    if (!killedInBlock) {
                        reachedUses.add(use)
                    }
                }
            }
        }
        
        DefUseChain(definition, reachedUses)
    }
}

/**
 * Find dead definitions (definitions that don't reach any uses)
 */
private fun findDeadDefinitions(
    definitions: List<Definition>,
    defUseChains: List<DefUseChain>
): Set<Definition> {
    val usedDefinitions = defUseChains.filter { it.reachedUses.isNotEmpty() }.map { it.definition }.toSet()
    return definitions.toSet() - usedDefinitions
}